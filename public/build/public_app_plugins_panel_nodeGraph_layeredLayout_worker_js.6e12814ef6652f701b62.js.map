{"version":3,"file":"public_app_plugins_panel_nodeGraph_layeredLayout_worker_js.6e12814ef6652f701b62.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0BAA0B;AACjF,uDAAuD,0BAA0B;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0BAA0B;AACjF,uDAAuD,0BAA0B;AACjF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,qBAAqB;AACrC;AACA;;AAEA;;AAEA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB;;AAErB,iCAAiC,uBAAuB;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wCAAwC;AACxC,iBAAiB;AACjB,wCAAwC;AACxC;AACA;AACA,uBAAuB;AACvB,0BAA0B;AAC1B,sBAAsB;AACtB;AACA,WAAW;AACX,kBAAkB;AAClB,yCAAyC;AACzC,qCAAqC,eAAe;AACpD,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA,8DAA8D,YAAY;;AAE1E;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,8BAA8B,WAAW;AACzC,8BAA8B,oBAAoB;AAClD;AACA;AACA,kCAAkC,wBAAwB;AAC1D,6BAA6B,gBAAgB;AAC7C;AACA;AACA,8BAA8B,0CAA0C;AACxE,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,2CAA2C;AAC3C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,2CAA2C;AAC3C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACt4FA,aAAa,mBAAO,CAAC,yCAAkB;AACvC;;;;;;;;;ACDa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,mFAAuB;AAC5C,aAAa,mBAAO,CAAC,qFAAyB;;;;;;;;;ACjBjC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;AChOd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;AC/RZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,4BAA4B;AACvD,eAAe,mBAAO,CAAC,qEAAS;AAChC;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,+BAA+B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;ACluBX;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,yFAAsB;AAC3C,aAAa,mBAAO,CAAC,yFAAsB;AAC3C,aAAa,mBAAO,CAAC,uFAAoB;;;;;;;;;AClB5B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,4BAA4B;AACvD,eAAe,mBAAO,CAAC,qEAAS;AAChC;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+BAA+B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,+BAA+B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;AC7qBX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;AClRH;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iFAAiF;AAC7F,aAAa,mBAAO,CAAC,4EAA+B;AACpD,aAAa,mBAAO,CAAC,kFAAqC;AAC1D,aAAa,mBAAO,CAAC,uDAAgB;;;;;;;;;AC1BxB;AACb,8CAA6C,EAAE,aAAa,EAAC;;;;;;;;;ACDhD;AACb,8CAA6C,EAAE,aAAa,EAAC;;;;;;;;;ACDhD;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,+FAAsB;AAC3C,aAAa,mBAAO,CAAC,+FAAsB;AAC3C,aAAa,mBAAO,CAAC,6FAAoB;;;;;;;;;AClB5B;AACb,8CAA6C,EAAE,aAAa,EAAC;;;;;;;;;ACDhD;AACb,8CAA6C,EAAE,aAAa,EAAC;;;;;;;;;ACDhD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;AChNA,cAAc,mBAAO,CAAC,gEAAe;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4BAA4B;AACtC,UAAU,4BAA4B;AACtC,UAAU,4BAA4B;AACtC,UAAU,8BAA8B;AACxC,UAAU,oCAAoC;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,mBAAmB,OAAO,QAAQ;AAClC,mBAAmB,OAAO,QAAQ;AAClC,oBAAoB,OAAO,OAAO;AAClC,oBAAoB,OAAO,OAAO;AAClC,mBAAmB,QAAQ,OAAO;AAClC,mBAAmB,QAAQ,OAAO;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACzrBA,kBAAkB,mBAAO,CAAC,sEAAe;;AAEzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC3Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,mBAAO,CAAC,wDAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;AC3HL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,mBAAO,CAAC,wDAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;ACrBa,8CAA2C,CAAC,SAAS,EAAC,CAAC,qBAAqB,CAAC,cAAc,CAAC,oBAAoB,CAAC,kBAAkB,CAAC,0BAA0B,CAAC,mBAAmB,QAAQ,iBAAiB,mCAAmC,wCAAwC,uCAAuC,sCAAsC,sCAAsC,qCAAqC,mBAAmB,IAAI,0BAA0B,oBAAoB,kBAAkB,YAAY,oBAAoB,cAAc,aAAa,qBAAqB,aAAa,GAAG,qBAAqB,aAAa,GAAG,gBAAgB,gBAAgB,iCAAiC,wCAAwC,+BAA+B,sCAAsC,8BAA8B,qCAAqC,iCAAiC,IAAI,sFAAsF,SAAS,0BAA0B,+BAA+B,IAAI,qBAAqB,uDAAuD,4BAA4B,YAAY,kBAAkB,KAAK,wBAAwB,sEAAsE,kBAAkB,8BAA8B,4BAA4B,yBAAyB,+CAA+C,yCAAyC,oEAAoE,qBAAqB,mDAAmD,SAAS,oCAAoC,8BAA8B,IAAI,2LAA2L,SAAS,oCAAoC,wDAAwD,8CAA8C,uBAAuB,8BAA8B,2BAA2B,OAAO,QAAQ,6EAA6E,IAAI,8EAA8E,EAAE,+BAA+B,cAAc,2CAA2C,2CAA2C,4EAA4E,8CAA8C,KAAK,EAAE,KAAK,EAAE,OAAO,kDAAkD,MAAM,6EAA6E,8CAA8C,OAAO,EAAE,KAAK,EAAE,KAAK,kDAAkD,MAAM,SAAS,mFAAmF,qEAAqE,4CAA4C,yBAAyB,4TAA4T,EAAE,IAAI,uFAAuF,4CAA4C,+CAA+C,yHAAyH,8CAA8C,qCAAqC,iDAAiD,uCAAuC,8BAA8B,mCAAmC,oCAAoC,uEAAuE,sDAAsD,MAAM,YAAY,wCAAwC,8CAA8C,mCAAmC,6CAA6C,yHAAyH,4BAA4B,gCAAgC,kGAAkG,0CAA0C,gEAAgE,kJAAkJ,qCAAqC,sBAAsB,YAAY,cAAc,4HAA4H,mBAAmB,UAAU,eAAe,eAAe,8CAA8C,uBAAuB,OAAO,aAAa,cAAc,QAAQ,oBAAoB,OAAO,sBAAsB,gFAAgF,WAAW,sCAAsC,WAAW,uBAAuB,cAAc,wBAAwB,cAAc,mBAAmB,kBAAkB,4BAA4B,kBAAkB,uBAAuB,6BAA6B,gDAAgD,6BAA6B,kCAAkC,iCAAiC,oDAAoD,iCAAiC,6CAA6C,QAAQ,eAAe,QAAQ,cAAc,qBAAqB;;;;;;;;;;;;;;ACS9xL;AACoB;;AAEzC;AACA;AACA;AACA;AACO;AACP,UAAU,0BAA0B;;AAEpC;AACA,gBAAgB,uDAAQ;AACxB,wBAAwB,kDAAS;AACjC;AACA,QAAQ,iDAAQ;AAChB;;AAEA;AACA,mBAAmB,iDAAQ;AAC3B,uBAAuB,qDAAY,kBAAkB,8CAAK;AAC1D;AACA,iCAAiC,+DAAsB;AACvD,4CAA4C,2DAAkB;AAC9D;AACA;AACA,EAAE,4DAAe;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,kEAAkE;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gDAAgD;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClOkD;AACkB;AAChB;AAC6F;AACjE;AAChC;AACM;AACF;AACF;AACM;AACkB;AACP;AACC;AACpB;AACO;AACf;AACA;AACQ;AACc;AACb;AACiD;AACjC;AACD;AACU;AACF;AACd;AACN;AACV;AACM;AACQ;AACY;AAC+B;AACd;AACM;AACnC;AACyB;AAClB;AACb;AACuD;AAChC;AACwG;AAC3I;AACE;AACF;AAC6B;AACR;AACc;AACb;AACN;AACQ;AACsB;AAChB;AAClB;AACe;AACX;AACI;AACN;AACE;AACF;AACL;AACL;AAC0B;AACJ;AAC2C;AAC3G;;;;;;;;;;;;;AChEqE;AACrE;AACO;AACP;AACA,uCAAuC,6EAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClD0D;AACP;AAC5C,oBAAoB,+DAAS;AACpC;AACA;AACA;AACA;AACA,4BAA4B,wDAAY;AACxC;AACA;AACA;AACA,gCAAgC,wDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAY;AAC5C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9BoD;AACgB;AAChB;AACI;AACQ;AACzD;AACP;AACA,oBAAoB;AACpB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAa;AAC7C,YAAY,uDAAK;AACjB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAO;AACzB,eAAe,uDAAK;AACpB;AACA;AACA;AACA,oBAAoB,uEAAa,mBAAmB,uEAAa;AACjE;AACA;AACA,2FAA2F,uEAAa;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,2FAA2F,uEAAa;AACxG;AACA,oBAAoB,uEAAa,mBAAmB,uEAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAK;AAClC;AACA;AACA,2FAA2F,uEAAa;AACxG,2FAA2F,uEAAa;AACxG,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,uEAAa;AAC5G,2FAA2F,uEAAa;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,wBAAwB,uDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAW;AAChC;AACA;AACA;AACA;;;;;;;;;;;;;AC1M8B;AACvB,wBAAwB,uCAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5B8B;AACvB,2BAA2B,uCAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5B0C;AACkB;AACc;AAClC;AACU;AACkB;AACX;AACH;AACI;AACnD,uBAAuB,mDAAU;AACxC;AACA;AACA,kCAAkC,iDAAK;AACvC;AACA;AACA,uCAAuC,uDAAW;AAClD;AACA;AACA;AACA,uCAAuC,2DAAO;AAC9C;AACA;AACA;AACA;AACA,uCAAuC,+DAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,mDAAU;AACxE;AACA;AACA,gCAAgC,yEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,WAAW;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,WAAW;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAK;AAC5B,uBAAuB,uDAAK;AAC5B,uBAAuB,uDAAK;AAC5B,uBAAuB,uDAAK;AAC5B,6BAA6B,6EAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uDAAK;AAChB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1M4C;AACoB;AACtB;AACJ;AACA;AACwC;AAC5B;AACqD;AAC7C;AACoB;AAC9C;AACoC;AAC1B;AACA;AACgB;AAC1D;AACO;AACP,qEAAqE;AACrE;AACA,wBAAwB,4GAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAS;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO,wBAAwB,+CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAQ;AAC1B;AACA;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAK;AACrB,YAAY,iDAAK,mEAAmE,yDAAa;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA,mBAAmB,+CAAQ;AAC3B;AACA;AACA;AACA,oBAAoB,GAAG,+DAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,uDAAK;AACjG;AACA;AACA;AACA;AACA,sBAAsB,mFAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA,kCAAkC,0DAAI;AACtC,oCAAoC,iDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB,0CAAK,GAAG,0EAA0E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAU;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,6BAA6B,gDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAI,iBAAiB,gDAAI;AACtD;AACA;AACA;AACA;AACO;AACP;AACA;AACA,qBAAqB,mDAAU;AAC/B,WAAW,mEAAO;AAClB;AACO;AACP;AACA;AACA,iBAAiB,+DAAS,kBAAkB,0DAAI;AAChD;AACA;AACA;AACA,sBAAsB,mDAAU;AAChC;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kEAAkE,+CAAQ;AAC1E;AACA;AACA,6BAA6B,0EAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAiB;AACtC;AACA;AACA,gBAAgB,+DAAS;AACzB,kBAAkB,iBAAiB,gEAAS,kDAAkD;AAC9F;AACA;AACA,wBAAwB,qBAAqB;AAC7C,sCAAsC,+DAAS,+BAA+B,iBAAiB,gEAAS,wBAAwB;AAChI;AACA;AACA;AACA,gBAAgB,+DAAS;AACzB,kBAAkB,iBAAiB,gEAAS,gDAAgD;AAC5F;AACA;AACA;AACA;AACA,WAAW,mEAAO;AAClB;AACA;;;;;;;;;;;;;;;AC/b4D;AAChB;AACF;AACnC,wBAAwB,mDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAS,UAAU,iDAAK,YAAY,iDAAK;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnEA;AACkE;AACxB;AAC0B;AAC7D,uBAAuB,mDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qEAAY;AACjD;AACA;AACA;AACA;AACA,gCAAgC,yEAAiB;AACjD;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrJoD;AACgB;AACpE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,yDAAS;AACzC;AACA,sBAAsB,yEAAiB;AACvC;AACA;AACA;AACA;AACA,gCAAgC,yEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yEAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AACA;AAC8B;AACvB,2CAA2C,uCAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CO;AACP;AACA;;;;;;;;;;;;;;ACFkD;AACJ;AACvC,mCAAmC,uDAAY;AACtD;AACA,8EAA8E,uDAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrDsC;AACE;AACI;AACA;AAC5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM,8BAA8B,iDAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAQ;AACpC;AACA;AACA,iCAAiC,iDAAS;AAC1C;AACA;AACA;AACA,sCAAsC,iDAAK;AAC3C;AACA,wCAAwC,yEAAyE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/DqE;AACL;AAC1B;AACc;AACF;AACV;AACyB;AACnC;AACgB;AACY;AACd;AAC5C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAI;AACvB;AACA;AACA,4BAA4B,yDAAU;AACtC,iCAAiC,uCAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAQ;AACrC,sBAAsB,+CAAQ;AAC9B,6BAA6B,uDAAK;AAClC;AACA,8CAA8C,iEAAiE;AAC/G;AACA;AACA;AACA,0CAA0C,2DAA2D;AACrG;AACA;AACA,8BAA8B,4FAA4F;AAC1H;AACA;AACA,8BAA8B,0FAA0F;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAQ;AAChC;AACA,sBAAsB;AACtB,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA,uBAAuB,+DAAY;AACnC,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qCAAqC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAA+D;AACnF,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,yBAAyB,kCAAkC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAqF,yBAAyB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6EAA6E;AAC9G;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAA+D;AACnF,YAAY;AACZ;AACA;AACA;AACA;AACA,yBAAyB,2CAA2C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iGAAiG;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAoB;AACrC;AACA,0CAA0C,uDAAK;AAC/C;AACA,mCAAmC,6EAA6E;AAChH;AACA;AACA;AACA,+BAA+B,8GAA8G;AAC7I;AACA;AACA,oCAAoC,4FAA4F;AAChI;AACA;AACA,oCAAoC,0FAA0F;AAC9H;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,kCAAkC,mCAAmC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA,oCAAoC,0DAAI;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC,sCAAsC,mDAAO;AAC7C;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAW;AACpD,uCAAuC,uDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uCAAI,KAAK,+DAAS,GAAG,8CAA8C;AACtG;AACA;AACA,wCAAwC,4DAA4D;AACpG;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uCAAI,KAAK,+DAAS,GAAG,8CAA8C;AAC1G;AACA;AACA,4CAA4C,gEAAgE;AAC5G;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAK;AACrC,mCAAmC,uDAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC,qCAAqC,+DAAS;AAC9C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAK,2EAA2E,uDAAK;AACnH;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,8DAA8D,yDAAa;AAC3E;AACA;AACA;AACA,+DAA+D,yDAAa;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uCAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACv3BqF;AAClB;AAC5B;AAC8B;AAC1B;AAC+B;AACkB;AAClD;AACmB;AACU;AACF;AACA;AACtB;AACF;AACa;AACS;AACL;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mFAAsB;AAC5C;AACA;AACA,sBAAsB,6EAAgB;AACtC;AACA;AACA,sBAAsB,gDAAiB;AACvC;AACA;AACA,sBAAsB,4DAA6B;AACnD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yBAAyB,sDAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6EAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mFAAsB,SAAS,6EAAgB;AACzE;AACA;AACA;AACA,4CAA4C,mFAAsB;AAClE,uBAAuB,4CAAa;AACpC;AACA;AACA,iDAAiD,gDAAiB;AAClE,6BAA6B,mDAAQ;AACrC;AACA;AACA,iDAAiD,6EAAgB;AACjE,2BAA2B,wEAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8EAA8E,iEAAoB;AAClG;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAU;AAClC;AACA;AACA;AACA;AACA,MAAM;AACN,oBAAoB,8EAAmB;AACvC,0BAA0B,qEAAe;AACzC;AACA;AACO;AACP;AACA,gCAAgC,qEAAe;AAC/C;AACA;AACA,qCAAqC,qEAAe,mCAAmC,qEAAe;AACtG,QAAQ,oEAAY;AACpB;AACA,qCAAqC,qEAAe;AACpD,QAAQ,mFAAuB;AAC/B;AACA,qCAAqC,qEAAe;AACpD,YAAY,gEAAY;AACxB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+CAAI;AAC1C,0CAA0C,oDAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0EAA0B;AAC5C;AACA;AACA;AACA,sBAAsB,iDAAK;AAC3B;AACA,0BAA0B,sDAAS;AACnC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACO;AACP,eAAe,6FAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,sDAAS;AACjB;AACA;AACA,mBAAmB,yDAAU;AAC7B;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,sDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAU;AAC7B;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oCAAK;AAC/B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvWyE;AAClB;AACR;AACC;AACH;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA,2BAA2B,qDAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,uDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAO;AACtC;AACA,+BAA+B,mEAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mEAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAa;AAC7C,6BAA6B,iDAAK;AAClC;AACA;AACA,gCAAgC,gDAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAI;AAC3B;AACA,4BAA4B,qDAAS;AACrC;AACA;AACA;AACA;AACA,gBAAgB,4DAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAY;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAY;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAY;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qDAAS,kBAAkB,gDAAI;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,sDAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAS,4BAA4B,gDAAI;AACnE;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7mBwD;AACE;AACsB;AACpB;AACrD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAQ;AAC3B;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxEiG;AACV;AACzC;AACM;AACpD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uDAAuD,mDAAO;AAC9D,8BAA8B,yDAAU;AACxC,wBAAwB,2BAA2B;AACnD;AACA;AACA,sBAAsB,2EAAe;AACrC,oCAAoC,sGAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,sBAAsB,+EAAmB;AACzC,oCAAoC,sGAAyB;AAC7D;AACA;AACA;AACA,sBAAsB,yDAAU;AAChC,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChEyC;AACyB;AAChB;AACQ;AACe;AACzB;AACE;AACwB;AACR;AAClE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2EAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB,4CAA4C,uDAAK;AACjD;AACA;AACA,sBAAsB,uDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAa;AAC9B;AACA;AACA,iBAAiB,uEAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA,oBAAoB,8EAAG;AACvB;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mFAA0B;AACpD;AACA;AACA;AACA;AACA,mCAAmC,2DAAc;AACjD;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,qBAAqB,+DAAS;AAC9B,qBAAqB,+DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAM;AACnD;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAQ;AACjC,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAK;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/SqC;AAC9B;AACP;AACA;AACA;AACA,4BAA4B,kDAAS;AACrC,4BAA4B,kDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxBA;AAC4C;AACgB;AACrD;AACP,oBAAoB,iEAAa;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCkD;AACgB;AAChC;AACW;AACD;AACQ;AACQ;AAC+D;AAC/E;AACU;AACoB;AAC1B;AACJ;AACA;AAC5C;AACA;AACA;;AAEA;AACO,wBAAwB,uDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iEAAa;AAClF,qEAAqE,iEAAa;AAClF;AACA;AACA,8BAA8B,2EAAe;AAC7C,yCAAyC,0GAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2CAAM;AACrC,gBAAgB,iEAAa,mBAAmB;AAChD;AACA;AACA;AACA;AACA,gBAAgB;AAChB,+BAA+B,2CAAM;AACrC,gBAAgB,iEAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAY;AAClD;AACA;AACA;AACA,sCAAsC,4DAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,4BAA4B,uDAAQ,sBAAsB,iDAAK;AAC/D;AACA;AACA,+BAA+B,qDAAM;AACrC;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAK;AAClC;AACA;AACA,oCAAoC,oFAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB,iDAAK,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAU;AAClC,wBAAwB,yDAAU;AAClC,uBAAuB,iEAAa;AACpC,uBAAuB,iEAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,kDAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAK;AAClC,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB,YAAY,iDAAM;AAClB,YAAY,iDAAM;AAClB,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvb+D;AACvB;AACjC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3Y+C;AACA;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd,QAAQ,iDAAM;AACd;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC,2BAA2B,iDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB,YAAY,iDAAM;AAClB,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5HyC;AACM;AACe;AACE;AAChE;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAAqB;AAC1D;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,2BAA2B,uEAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yEAAqB;AAC/D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yEAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3MA;AACA;AACmE;AACpB;AACjB;AAC9B;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAI;AAChC;AACA;AACA,4BAA4B,uCAAI;AAChC;AACA;AACA,4BAA4B,uCAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qBAAqB,+DAAU;AAC/B,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAI;AACvB;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA,8BAA8B,uCAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC,6CAA6C,uCAAI;AACjD,mCAAmC,uCAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;;;;;;;;;;;;;;AClH+C;AACA;AACxC;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjKgD;AACa;AACJ;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uCAAQ;AAC1B,6BAA6B,oCAAK;AAClC;AACA,0BAA0B,uCAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAK;AAClC,sBAAsB,wCAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAK;AAClC,2BAA2B,wCAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uCAAQ;AAC9B;AACA,sBAAsB,uCAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uCAAQ;AAC1B;AACA;AACA,oBAAoB,GAAG,qDAAS;AAChC,QAAQ,qEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uCAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5EkD;AACG;AACe;AACb;AACZ;AACuB;AACA;AACe;AACpB;AAC7D;AACO,4BAA4B,uDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,2EAAsB;AAC1I;AACA;AACA;AACA;AACA,qCAAqC,+DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2EAAsB;AAChE,4CAA4C,2EAAsB;AAClE;AACA;AACA;AACA;AACA,wCAAwC,qEAAiB;AACzD;AACA;AACA,qCAAqC,mDAAQ,+BAA+B,qEAAiB;AAC7F;AACA;AACA,4BAA4B,6DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,gBAAgB,yFAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AACkD;AACJ;AAC9C;AACA;AACO,wBAAwB,uDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,uBAAuB,mDAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpJyC;AACW;AACpD;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAU;AAC1C;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA,8BAA8B,mDAAK,IAAI;AACvC,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9DoD;AACN;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAO;AAClC,4BAA4B,mDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DA;AAC4C;AACJ;AACQ;AACU;AAC1D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iDAAS;AAC3D;AACA,4CAA4C,UAAU;AACtD,8CAA8C;AAC9C;AACA;AACA;AACA,sDAAsD,iDAAS;AAC/D;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA,iCAAiC,mEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;;;;;;;;;;;;;ACtJkE;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAa;AAChC,wBAAwB,kBAAkB;AAC1C,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAa;AAC5B;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAa;AACxC,oBAAoB,4CAA4C;AAChE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClGiE;AACnB;AACM;AACN;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA,6DAA6D,qBAAqB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAc,4DAA4D,mDAAO;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAU;AACtC;AACA;AACA,6BAA6B,mDAAO;AACpC;AACA,4BAA4B,uDAAY,gBAAgB,0EAAc;AACtE;AACA,yCAAyC,mDAAO;AAChD;AACA;AACA,iCAAiC,yDAAU;AAC3C;AACA;AACA,4BAA4B,mDAAO;AACnC;AACA,4BAA4B,yDAAU;AACtC;AACA;AACA,4BAA4B,mDAAO;AACnC;AACA;AACA;;;;;;;;;;;;;;;AC/F0C;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD,YAAY,mDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,2BAA2B;AAC3B;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7HwD;AACZ;AACJ;AACkB;AAC1D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C,qCAAqC;AACrC,uCAAuC,iEAAiB;AACxD;AACA,uCAAuC,iEAAiB;AACxD,8CAA8C,iDAAS;AACvD;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAkB;AACnD;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClOO;AACP;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;;;;;;;;;;;;;ACNsD;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnJ4D;AACI;AACJ;AAC5D,WAAW,YAAY,2BAA2B;AACgB;AAChB;AACC;AACJ;AACT;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAY;AACzB,qCAAqC,iEAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAY;AACzB,kCAAkC,iEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,+CAAQ;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,+CAAQ;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,+CAAQ;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,+CAAQ;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAQ;AACjC;AACA;AACA;AACA,yBAAyB,+CAAQ;AACjC;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uEAAa;AACxD;AACA;AACA;AACA,mDAAmD,uEAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAQ;AACjC;AACA;AACA;AACA,yBAAyB,+CAAQ;AACjC;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uEAAa;AACxD;AACA;AACA;AACA,mDAAmD,uEAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,iEAAU;AACrB;AACA;AACA,WAAW,iEAAU,iCAAiC,qEAAY;AAClE;AACA;;;;;;;;;;;;;;;;AC7TA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACyE;AACf;AACN;AACgB;AAC7D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAQ;AAChC;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAK,qCAAqC,qEAAmB;AACjF;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAK;AACnB,cAAc,uDAAK;AACnB;AACA;AACA,kBAAkB,uDAAK;AACvB;AACA;AACA;AACA;AACA,0BAA0B,qEAAmB;AAC7C;AACA,uBAAuB,qEAAmB;AAC1C;AACA,gCAAgC,qEAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAQ;AAC7B,gBAAgB,uDAAK;AACrB;AACA;AACA,gBAAgB,uDAAK;AACrB,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAQ;AAC7B,gBAAgB,uDAAK;AACrB,gBAAgB,uDAAK;AACrB,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/RO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;;;;;;;;;;;;;ACRsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,UAAU,EAAE,GAAG,EAAE;AACtC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZ4D;AACN;AACiB;AACrB;AACN;AACqC;AACnC;AACR;AACM;AACA;AACa;AACL;AACA;AACZ;AACkB;AAClB;AACgB;AACR;AACD;AACgB;AAC0B;AACvD;AAC4B;AAChB;AACY;AACC;AACvB;AAC0C;AACd;AACuB;AACb;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yEAAyE,2EAAsB;AAC/F,IAAI,+DAAqB;AACzB,IAAI,iEAAuB,8CAA8C,gDAAU,EAAE,kEAAoB;AACzG;AACA,yBAAyB,oFAAmB;AAC5C;AACA;AACA;AACO,4BAA4B,uDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAW;AAC3C;AACA;AACA,4BAA4B,2DAAU;AACtC;AACA,4BAA4B,+CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAS;AACtD;AACA;AACA;AACA;AACA,0EAA0E,sEAAe;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,sEAAe;AACvE;AACA,YAAY,oFAAuB;AACnC;AACA,0BAA0B,sEAAe;AACzC;AACA;AACA;AACA,YAAY,oDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAiE;AACzF;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uDAAK;AACnD;AACA;AACA;AACA,8CAA8C,uDAAK;AACnD;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,yBAAyB,iEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA,4BAA4B,8CAAO;AACnC;AACA;AACA;AACA;AACA,QAAQ,kDAAS;AACjB;AACA,8BAA8B,qDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oCAAoC,kDAAS;AAC7C;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA,oCAAoC,kDAAS;AAC7C;AACA;AACA,gCAAgC,kDAAS;AACzC;AACA;AACA;AACA,sCAAsC,kDAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAkB,KAAK,2DAAU;AACvE;AACA,mBAAmB,qDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAQ;AAChB,QAAQ,yEAAgB;AACxB;AACA;AACA;AACA;AACA,0DAA0D,mGAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAa;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAQ;AACtC,2CAA2C,qDAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,mCAAmC,uDAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAS;AACtD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAS;AACtD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,gEAAS;AACjC;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAc;AAC1C,6CAA6C;AAC7C,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAW;AACtC,2BAA2B,qDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA,+BAA+B,qDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAY;AACpC;AACA;AACA;AACA;AACA,QAAQ,wEAAoB;AAC5B;AACA;AACA,wBAAwB,0DAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAM;AAC3B;AACA;AACA;AACA,+CAA+C,2DAAU;AACzD;AACA;AACA;AACA,0CAA0C,0DAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC,yBAAyB,4CAAM;AAC/B;AACA,oBAAoB,oCAAoC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kEAAa;AACnD;AACA;AACA,sCAAsC,kEAAa;AACnD;AACA;AACA;AACA,YAAY,uDAAK,4EAA4E,qEAAmB;AAChH;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK,4EAA4E,qEAAmB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAS,sCAAsC,uDAAK,yCAAyC,uDAAK;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAS,kCAAkC,uDAAK,qCAAqC,uDAAK;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC56BsD;AACM;AACS;AACzB;AACH;AACS;AAClD;AACA;AACA;AACA,yBAAyB,qDAAW;AACpC,WAAW,2EAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qDAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAK;AAC7B;AACA;AACA,2BAA2B,mDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA,4EAA4E,wDAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA,iCAAiC,qDAAW;AAC5C;AACA;AACA;AACA,4DAA4D,qDAAW;AACvE;AACA;AACA;AACA;AACA;AACA,4DAA4D,qDAAW;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAK;AAC7B,2BAA2B,mDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,oCAAoC,qDAAW;AAC/C,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAW;AAC/B;AACA;AACA,gBAAgB,qDAAW,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAM,6BAA6B,IAAI,WAAW,GAAG,QAAQ,EAAE;AAC/F;AACA;AACA;AACA;AACA,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnkByD;AACZ;AACK;AAC3C;AACP;AACA,mBAAmB,2DAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BkF;AAClF;AACO;AACP;AACA;AACA,0BAA0B,kFAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACqD;AACG;AACL;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C,6DAA6D,uDAAK;AAClE;AACA;AACA,gEAAgE,uDAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1JA;AAC6C;AACK;AACE;AACX;AACqB;AACA;AACP;AACK;AAC5D;AACA;AACA;AACA,WAAW,wDAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kEAAY;AACvB;AACO;AACP;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACO,uBAAuB,uDAAS;AACvC;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAe;AAC/B,gCAAgC,oBAAoB;AACpD,oBAAoB,mDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAe;AAC1C;AACA,wBAAwB,qGAAqG;AAC7H;AACA;AACA;AACA,mCAAmC,6DAAe;AAClD,gBAAgB,6DAAe;AAC/B;AACA;AACA;AACA,qBAAqB,6DAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,mDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAK;AAC3B;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,mBAAmB,4CAA4C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2BAA2B;AACvE;AACA;AACA,4CAA4C,qCAAqC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/mBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxDwC;AACsB;AACZ;AACA;AAClD;AACA;AACA,8BAA8B,uDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAK;AAC5C,wBAAwB,mEAAW;AACnC;AACA;AACA,uCAAuC,uDAAK;AAC5C,wBAAwB,mEAAW;AACnC;AACA;AACA;AACA;AACA,YAAY,uDAAK,8BAA8B,uDAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA,wCAAwC,iDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnKkD;AACY;AACZ;AACQ;AACc;AACpB;AACc;AAClE,WAAW,iBAAiB;AACgC;AACtB;AACQ;AAC4B;AAChB;AACC;AAC3D;AACO,sBAAsB,uDAAS;AACtC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,2EAAsB;AAC9H;AACA,uBAAuB,gEAAY;AACnC;AACA,oBAAoB,oEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAK;AAC/C,0CAA0C,uDAAK;AAC/C,0CAA0C,uDAAK;AAC/C,0CAA0C,uDAAK;AAC/C,4BAA4B,iEAAU;AACtC,yCAAyC,6EAAgB;AACzD,wBAAwB,iEAAU;AAClC,wBAAwB,iEAAU;AAClC,wBAAwB,iEAAU;AAClC,wBAAwB,iEAAU;AAClC,oBAAoB,iEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uDAAK;AAChD,wCAAwC,uDAAK;AAC7C,oCAAoC,+DAAS;AAC7C;AACA;AACA;AACA;AACA,oBAAoB,sDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAS;AACzB;AACA;AACA;AACA;AACA,0BAA0B,oFAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAK;AAC5C,wBAAwB,mEAAW;AACnC;AACA;AACA,uCAAuC,uDAAK;AAC5C,wBAAwB,mEAAW;AACnC;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK,8BAA8B,uDAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+CAAQ,uCAAuC,+CAAQ,YAAY,+CAAQ;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC3O4D;AACV;AACgB;AACJ;AACI;AACK;AACC;AACZ;AACxB;AACE;AAC8B;AACjB;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qEAAmB;AACpD,eAAe,qEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qEAAmB;AACpD,eAAe,qEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6CAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,YAAY;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6CAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mEAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAQ;AACjC;AACA;AACA;AACA,8BAA8B,+CAAQ;AACtC;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAQ;AACjC,kCAAkC;AAClC;AACA,8BAA8B,+CAAQ;AACtC,kCAAkC;AAClC;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,uCAAuC,uEAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uEAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6EAAgB;AACnC;AACA;AACA,kBAAkB,mEAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAmB;AAC7C,0BAA0B,qEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mEAAW;AAC9E;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK;AACpB;AACA;AACA,eAAe,uDAAK,iEAAiE,qEAAmB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAuB;AAC/B;AACA;AACA,2CAA2C,iEAAU;AACrD,wBAAwB,0BAA0B;AAClD,0BAA0B,iEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAY;AACxB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAK;AACvC;AACA;AACA,uBAAuB,uDAAK;AAC5B,4BAA4B,uDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAY;AACxB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAK;AACvC,uCAAuC,uDAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAW;AAC/B,8BAA8B,uDAAK,sBAAsB,mEAAW;AACpE,YAAY,uDAAK,sBAAsB,mEAAW;AAClD,0BAA0B,uDAAK,sBAAsB,mEAAW;AAChE,YAAY,uDAAK,sBAAsB,mEAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uDAAK,qBAAqB,uDAAK;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAK;AAC7B;AACA,kBAAkB,uDAAK;AACvB;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA,6BAA6B,mEAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uCAAuC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uDAAK;AAClB,2BAA2B,uDAAK;AAChC,wBAAwB,mEAAW;AACnC;AACA;AACA;AACA,aAAa,uDAAK;AAClB,6BAA6B,mEAAW;AACxC;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAK;AAC3C,6BAA6B,mEAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAK;AAC7B,8BAA8B,uDAAK;AACnC;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACztBkF;AACI;AAC5B;AACoB;AAC3B;AACa;AACD;AACxD;AACP;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mFAAmB;AACjD;AACA;AACA;AACA;AACA;AACA,+BAA+B,uEAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAoB;AACtD,uCAAuC,2FAA8B;AACrE,yCAAyC,+FAAgC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mFAAmB;AAC5C;AACA;AACA,kEAAkE,qEAAe;AACjF;AACA;AACA,kBAAkB,mFAAmB;AACrC,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC,qBAAqB,4DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAkB;AACrC;AACA,mBAAmB,mEAAkB;AACrC;AACA,mBAAmB,mEAAkB;AACrC;AACA,mBAAmB,mEAAkB;AACrC;AACA;AACA;AACA;AACA,iBAAiB,mEAAkB;AACnC,iCAAiC,mFAAmB;AACpD;AACA,iBAAiB,mEAAkB;AACnC,iCAAiC,mFAAmB;AACpD;AACA,iBAAiB,mEAAkB;AACnC,iCAAiC,mFAAmB;AACpD;AACA,iBAAiB,mEAAkB;AACnC,iCAAiC,mFAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnLkE;AACpB;AACA;AACF;AACQ;AAC6C;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2EAAe;AACrC,4BAA4B,uDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA,2DAA2D,mDAAO;AAClE;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA,2DAA2D,mDAAO;AAClE;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAU;AACvD;AACA;AACA,mBAAmB,mDAAO;AAC1B;AACA;AACA,mBAAmB,mDAAO;AAC1B;AACA;AACA,mBAAmB,mDAAO;AAC1B;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0GAAsB;AACjD;AACA;AACA;AACA,eAAe,2EAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAO;AACvC;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAO;AACvC;AACA;AACA,uDAAuD,mDAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uDAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAU;AAClC;AACA,eAAe,2EAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5OA;AACA;AACA;AAC6E;AACX;AACpB;AACM;AACR;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mDAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mDAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAoE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,+BAA+B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,uCAAuC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAyD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;AACA,uCAAuC,qDAAW;AAClD;AACA,kBAAkB;AAClB;AACA;AACA,2BAA2B,2EAAe;AAC1C;AACA,yBAAyB,kFAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA,kEAAkE,4BAA4B;AAC9F;AACA;AACA;AACA;AACA;AACA,6DAA6D,oCAAoC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpkBA;AACA;AACoE;AAC7D,2BAA2B,yEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChEkD;AACc;AAChE;AACO,gCAAgC,uDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxE8F;AAC5C;AAClD;AACO,oCAAoC,uDAAS;AACpD;AACA;AACA,oDAAoD;AACpD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mGAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjEO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACbkD;AACQ;AACF;AACN;AACV;AACU;AACkB;AACmC;AACtB;AACjF;AACO,6BAA6B,uDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAc;AACjD;AACA;AACA,QAAQ,6EAAuB;AAC/B;AACA;AACA,4BAA4B,iEAAiB;AAC7C;AACA;AACA,sBAAsB,6EAAuB;AAC7C;AACA,YAAY,6EAAuB;AACnC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA,kCAAkC,uDAAK;AACvC;AACA;AACA;AACA;AACA,YAAY,yFAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4CAA4C;AACnF;AACA,4BAA4B,4GAAuB;AACnD;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,mBAAmB,+DAAS;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACjL+D;AAC/D;AACO;AACP;AACA,kCAAkC,uEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5I4C;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,wBAAwB,qDAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD,4BAA4B,OAAO;AACnC;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,4BAA4B,OAAO;AACnC;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1SkD;AACc;AAChE;AACO,6BAA6B,uDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,4BAA4B,yEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9CkD;AACO;AAC8B;AACrC;AACM;AACjD;AACP,4DAA4D,iEAAiB,kCAAkC,iEAAiB;AAChI,IAAI,8DAAqB;AACzB,IAAI,gEAAuB,0CAA0C,+CAAU,EAAE,iEAAoB;AACrG;AACA;AACO,uBAAuB,uDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDO;AACP;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;;;;;;;;;;;;ACLO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBkC;AACE;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2CAAM,CAAC,6CAAO;AACjD;AACA;AACA,mCAAmC,2CAAM,CAAC,6CAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6CAAO;AACrD;AACA;AACA,gCAAgC,6CAAO;AACvC,8BAA8B,6CAAO;AACrC,qCAAqC,6CAAO;AAC5C;AACA;AACA;AACA,qCAAqC,6CAAO,4BAA4B,6CAAO;AAC/E,8BAA8B,6CAAO;AACrC;AACA;AACA;AACA,0CAA0C,6CAAO;AACjD,uCAAuC,6CAAO;AAC9C,kCAAkC,6CAAO;AACzC;AACA;AACA;AACA;AACA,qCAAqC,6CAAO;AAC5C,oCAAoC,6CAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAAO;AACvC,8BAA8B,6CAAO;AACrC,qCAAqC,6CAAO;AAC5C;AACA;AACA;AACA,sCAAsC,6CAAO,2BAA2B,6CAAO;AAC/E,8BAA8B,6CAAO;AACrC;AACA;AACA;AACA,yCAAyC,6CAAO;AAChD,wCAAwC,6CAAO;AAC/C,kCAAkC,6CAAO;AACzC;AACA;AACA;AACA;AACA,qCAAqC,6CAAO;AAC5C,mCAAmC,6CAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,kBAAkB,6CAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAM,CAAC,6CAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6CAAO;AACzB,qDAAqD,6CAAO;AAC5D;AACA;AACA,gCAAgC,6CAAO;AACvC,qCAAqC,6CAAO;AAC5C,8BAA8B,6CAAO;AACrC,4CAA4C,6CAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAAO;AAC5C,4CAA4C,6CAAO;AACnD;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAAO;AACvC,qCAAqC,6CAAO;AAC5C,8BAA8B,6CAAO;AACrC,4CAA4C,6CAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAAO;AAC5C,4CAA4C,6CAAO;AACnD;AACA;AACA;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;;;;;;;;;;;;AChTkE;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uEAAa;AAClD;AACA;AACA,0CAA0C,uEAAa;AACvD;AACA;AACA;;;;;;;;;;;;AChFA;AACO;AACP;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;;;;;;;;;;;;;;ACNuI;AACvI;AACA;AACA;AACO;AACP,2BAA2B,gFAAgC,8BAA8B,+DAAe;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gFAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,cAAc;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAe;AACpC;AACA;AACA;AACA;AACA;AACA,6BAA6B,gFAAgC;AAC7D;AACA;AACA;AACA;AACA,yBAAyB,gFAAgC;AACzD;AACA;AACA;AACA,gCAAgC,+DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7OyC;AACW;AACpD;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6DAAe;AAC/D;AACA;AACA,mFAAmF,6DAAe;AAClG,oFAAoF,6DAAe;AACnG,2BAA2B,6DAAe;AAC1C;AACA,uBAAuB,6DAAe;AACtC;AACA,mBAAmB,6DAAe;AAClC;AACA,eAAe,6DAAe;AAC9B;AACA,WAAW,6DAAe;AAC1B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,6DAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6DAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1TO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxGwC;AACgB;AACxB;AACgB;AACY;AAC5D;AACO;AACP;AACA,iBAAiB;AACjB;AACA;AACA,8CAA8C,yCAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,oBAAoB,yCAAK;AACzB,wBAAwB,OAAO;AAC/B,oBAAoB,yCAAK;AACzB,eAAe,yCAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yDAAa;AACvE,wBAAwB,yCAAK;AAC7B,wBAAwB,yCAAK;AAC7B,wBAAwB,yCAAK;AAC7B,yBAAyB,yCAAK;AAC9B,yBAAyB,yCAAK;AAC9B,0BAA0B,yCAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAK;AACzB,oBAAoB,yCAAK;AACzB,oBAAoB,yCAAK;AACzB,qBAAqB,yCAAK;AAC1B,qBAAqB,yCAAK;AAC1B,sBAAsB,yCAAK;AAC3B;AACA,iCAAiC,yDAAa;AAC9C;AACA,iCAAiC,yDAAa;AAC9C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvUgD;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAa;AAC1D;AACA;AACA;AACA,2BAA2B,yDAAa;AACxC;AACA;AACA;AACA,+BAA+B,yDAAa;AAC5C;AACA;AACA;AACA;AACA,UAAU,sBAAsB,yDAAa;AAC7C;AACA;AACA,uDAAuD,yDAAa;AACpE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrCwE;AAChC;AACR;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAS;AACzB,kBAAkB,6EAAa;AAC/B,gBAAgB,iDAAS;AACzB;AACA,wBAAwB,6EAAa;AACrC,gBAAgB,iDAAS;AACzB;AACA,kBAAkB,6EAAa;AAC/B,oBAAoB,iDAAS;AAC7B;AACA,wBAAwB,6EAAa;AACrC,oBAAoB,iDAAS;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,iDAAS;AACzB;AACA;AACA;AACA;AACA,6BAA6B,6EAAa;AAC1C,gBAAgB,iDAAS;AACzB;AACA,mCAAmC,6EAAa;AAChD,gBAAgB,iDAAS;AACzB;AACA,2BAA2B,6EAAa;AACxC,iBAAiB,iDAAS;AAC1B;AACA,iCAAiC,6EAAa;AAC9C,iBAAiB,iDAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA,iBAAiB,iDAAS;AAC1B,uBAAuB,iDAAS;AAChC;AACA;AACA,uBAAuB,iDAAS;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAS,WAAW,iDAAS;AACrD;AACA;AACA,wBAAwB,iDAAS,YAAY,iDAAS;AACtD;AACA;AACA,wBAAwB,iDAAS,WAAW,iDAAS;AACrD;AACA;AACA,wBAAwB,iDAAS,YAAY,iDAAS;AACtD;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChLA;AACgD;AACK;AACf;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAK,mFAAmF,uDAAmB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAK;AACjC,4BAA4B,uDAAmB;AAC/C;AACA;AACA,4BAA4B,uDAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAa,6CAA6C,yDAAa;AAC5H;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,mLAAmL,EAAE,cAAc,EAAE;AACrM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAK;AACrB,iBAAiB,uDAAmB;AACpC;AACA;AACA,iBAAiB,uDAAmB;AACpC;AACA;AACA,iBAAiB,uDAAmB;AACpC;AACA;AACA;AACA,6BAA6B,yDAAa,8BAA8B,yDAAa;AACrF;AACA;AACA,8BAA8B,yDAAa,6BAA6B,yDAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3NgC;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CwD;AACxB;AACY;AACU;AACN;AACZ;AACE;AACU;AACD;AACS;AAChB;AACA;AACW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA,uBAAuB,6CAAO;AAC9B,iBAAiB;AACjB;AACA,uBAAuB,qDAAW;AAClC,iBAAiB;AACjB;AACA,uBAAuB,kDAAS;AAChC,iBAAiB;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qCAAqC,kDAAS;AAC9C;AACA;AACA,qCAAqC,6CAAO;AAC5C;AACA;AACA,qCAAqC,qDAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAa;AACxC;AACA,6BAA6B,yDAAa;AAC1C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAQ;AACtC;AACA;AACA;AACA,8BAA8B,6CAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAK,iBAAiB,yDAAa;AAClD;AACA;AACA,eAAe,yCAAK,aAAa,yDAAa;AAC9C;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC;AACA,gBAAgB,6DAAY;AAC5B,4BAA4B,yCAAK;AACjC,uCAAuC,yDAAa;AACpD;AACA,kDAAkD,yDAAa;AAC/D;AACA,qCAAqC,+DAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAa;AAC5C,wBAAwB;AACxB;AACA,YAAY,6DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAa;AAC9B;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA,oBAAoB,yCAAK;AACzB,+BAA+B,yDAAa;AAC5C;AACA,0CAA0C,yDAAa;AACvD;AACA,6BAA6B,+DAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAkD;AACjE;AACA;AACA;AACA;AACA,iCAAiC,+DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yDAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yDAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAgB;AACnC;AACA;AACA;AACA;AACA,mBAAmB,+DAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAa,0CAA0C,yDAAa;AACtG;AACA,wBAAwB,iEAAiB;AACzC,wBAAwB,iEAAiB;AACzC;AACA;AACA,kCAAkC,yDAAa;AAC/C;AACA,wBAAwB,iEAAiB;AACzC;AACA;AACA,kCAAkC,yDAAa;AAC/C;AACA,wBAAwB,iEAAiB;AACzC;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAK;AAClB;AACA;AACA,iBAAiB,yCAAK;AACtB,+CAA+C,qDAAW,aAAa,qDAAW;AAClF,+CAA+C,qDAAW,aAAa,qDAAW;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yDAAa;AAC3D,8CAA8C,yDAAa;AAC3D;AACA;AACA,wBAAwB,iEAAiB;AACzC,wBAAwB,iEAAiB;AACzC;AACA;AACA;AACA;AACA,wBAAwB,iEAAiB;AACzC;AACA;AACA;AACA;AACA,wBAAwB,iEAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAK;AACtB;AACA;AACA,qBAAqB,yCAAK;AAC1B,mDAAmD,qDAAW,aAAa,qDAAW;AACtF,mDAAmD,qDAAW,aAAa,qDAAW;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+CAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+CAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAW,iBAAiB,qDAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAa;AACpD;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAa;AACjC;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAa;AACvC;AACA;AACA,0BAA0B,yDAAa;AACvC;AACA;AACA,0BAA0B,yDAAa;AACvC;AACA;AACA,0BAA0B,yDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,gCAAgC,yCAAK;AACrC,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yCAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+CAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAK;AACjB;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,yDAAa;AAC/H;AACA;AACA,YAAY,yCAAK;AACjB;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,yDAAa;AACjI;AACA;AACA;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA,6BAA6B,yDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAK;AACjB;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,yDAAa;AAC/H;AACA;AACA,YAAY,yCAAK;AACjB;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,yDAAa;AACjI;AACA;AACA;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA,6BAA6B,yDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAS;AACzC;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAW;AAC3C;AACA;AACA,2CAA2C,yCAAK;AAChD;AACA;AACA;AACA,wCAAwC,yCAAK,cAAc,yCAAK;AAChE;AACA;AACA;AACA,2CAA2C,yCAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yDAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAa;AAC3C;AACA;AACA;AACA;AACA;AACA,wCAAwC,yDAAa;AACrD;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAK;AACvB,kBAAkB,yCAAK;AACvB;AACA,mBAAmB,kDAAS;AAC5B;AACA;AACA;AACA,mBAAmB,kDAAS;AAC5B;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC;AACA,6BAA6B,+CAAQ;AACrC;AACA;AACA,4BAA4B,+CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,6CAA6C;AAC7C,wCAAwC;AACxC,kEAAkE;AAClE,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAW;AAChC;AACA;AACA,uCAAuC;AACvC,+BAA+B,yCAAK,yBAAyB,yCAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,0CAA0C,yDAAa;AACvD;AACA;AACA;AACA,2CAA2C,yDAAa;AACxD;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,0DAA0D,yDAAa;AACvE;AACA;AACA;AACA,2DAA2D,yDAAa;AACxE;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/lDoC;AACJ;AACA;AACY;AACgB;AAC/B;AACtB;AACP;AACA,eAAe,6CAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uCAAQ;AAC7B,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uCAAQ;AAC7B,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAK;AACzB,oBAAoB,yCAAK;AACzB,oBAAoB,yCAAK;AACzB,oBAAoB,yCAAK;AACzB;AACA,oBAAoB,yCAAK;AACzB,oBAAoB,yCAAK;AACzB,oBAAoB,yCAAK;AACzB,oBAAoB,yCAAK;AACzB,wBAAwB,OAAO;AAC/B;AACA;AACA,eAAe,uCAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAK;AAC3B,QAAQ,yCAAK;AACb,QAAQ,yCAAK;AACb,QAAQ,yCAAK;AACb,QAAQ,yCAAK;AACb,eAAe,yCAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAK;AAC3B,uBAAuB,yCAAK,gBAAgB,yCAAK,gBAAgB,yCAAK,gBAAgB,yCAAK;AAC3F,mBAAmB,qDAAW,mBAAmB,qDAAW,mBAAmB,qDAAW,mBAAmB,qDAAW;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAmB;AACjD,0BAA0B,qEAAmB;AAC7C,0BAA0B,qEAAmB;AAC7C;AACA;AACA;AACA,eAAe,6CAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAK;AAC3B,uBAAuB,yCAAK,oBAAoB,yCAAK,oBAAoB,yCAAK,oBAAoB,yCAAK;AACvG,mBAAmB,qDAAW,mBAAmB,qDAAW,mBAAmB,qDAAW,mBAAmB,qDAAW;AACxH;AACA;AACA;AACA,4BAA4B,yCAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,yCAAyC,6CAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6CAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,yCAAK;AACtF;AACA;AACA;AACA,sBAAsB,yCAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAK;AAC3B,sBAAsB,yCAAK;AAC3B;AACA,yBAAyB,qDAAW,UAAU,yCAAK,sBAAsB,yCAAK;AAC9E,qBAAqB,6CAAO;AAC5B;AACA,yBAAyB,qDAAW,UAAU,yCAAK,qBAAqB,yCAAK;AAC7E,qBAAqB,6CAAO;AAC5B;AACA,yBAAyB,qDAAW,UAAU,yCAAK,mBAAmB,yCAAK;AAC3E,qBAAqB,6CAAO;AAC5B;AACA,yBAAyB,qDAAW,UAAU,yCAAK,oBAAoB,yCAAK;AAC5E,qBAAqB,6CAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtLA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1LA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;;;;;;;;;;;;;;;;;;;ACTgC;AACQ;AACgB;AACxB;AACgB;AACY;AACT;AAC5C;AACP;AACA;AACA;AACA;AACA,yDAAyD,yCAAK,wBAAwB,yCAAK,wBAAwB,yCAAK;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAK;AACpC;AACA;AACA;AACA,eAAe,yCAAK;AACpB;AACA;AACA;AACA,eAAe,yCAAK;AACpB;AACA;AACA;AACA,eAAe,yCAAK;AACpB;AACA;AACA;AACA;AACA;AACA,6BAA6B,iEAAiB;AAC9C;AACA;AACA,YAAY,4DAAY,sBAAsB,4DAAY;AAC1D;AACA;AACA;AACA,uBAAuB,iDAAS;AAChC;AACA;AACA,mEAAmE,uCAAuC;AAC1G;AACA;AACA;AACA;AACA;AACA,+DAA+D,yCAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,yCAAK,gBAAgB,yCAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAK,4DAA4D,yDAAa;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAK;AACpB;AACA;AACA;AACA;AACA,eAAe,iDAAS;AACxB;AACA;AACA;AACA,uDAAuD,yDAAa;AACpE,8DAA8D,yDAAa;AAC3E,YAAY,yCAAK;AACjB;AACA;AACA;;;;;;;;;;;;ACpRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACVoC;AACJ;AACY;AACJ;AACF;AAC/B;AACP;AACA;AACO;AACP;AACA;AACA,mBAAmB,6CAAO;AAC1B;AACA,mBAAmB,yCAAK;AACxB;AACA,mBAAmB,qDAAW;AAC9B;AACA,mBAAmB,iDAAS;AAC5B;AACA,mBAAmB,+CAAQ;AAC3B;AACA;AACA;AACA,sBAAsB,6CAAO;AAC7B;AACA;AACA,2BAA2B,yCAAK;AAChC;AACA;AACA,2BAA2B,qDAAW;AACtC;AACA;AACA,2BAA2B,iDAAS;AACpC;AACA;AACA,2BAA2B,+CAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,aAAa;AACb;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CkE;AACpB;AACd;AACS;AACK;AACR;AACU;AACR;AACI;AACI;AAChD;;;;;;;;;;;;ACVA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK,EAAE,aAAa,EAAE,UAAU,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK,EAAE,aAAa,EAAE,UAAU,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjCqD;AACL;AACR;AACQ;AACzC;AACP;AACA,gCAAgC,yCAAK,2BAA2B,yCAAK;AACrE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAK;AAC9B,uBAAuB,yCAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAK,eAAe,yDAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAK;AACvB,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAa;AAChC;AACA,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAK;AACtB,iBAAiB,yCAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAa;AACnD,sCAAsC,yDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wCAAwC,yDAAa;AACrD,oCAAoC,yDAAa;AACjD,oCAAoC,yDAAa;AACjD,oCAAoC,yDAAa;AACjD;AACA;AACO;AACP,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB,gBAAgB,yCAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAmB;AAClC;AACA,eAAe,uDAAmB;AAClC;AACA,eAAe,uDAAmB;AAClC;AACA,eAAe,uDAAmB;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5WA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACd4C;AACI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAW,2BAA2B,qDAAW;AACpF;AACA;AACA;AACA;AACA,gCAAgC,yDAAa;AAC7C,6EAA6E,yDAAa;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAa;AAC/C,kCAAkC,yDAAa;AAC/C,kCAAkC,yDAAa;AAC/C,kCAAkC,yDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,yBAAyB,yDAAa,+BAA+B,yDAAa;AAC5F;AACA;AACA;AACA,2BAA2B,yDAAa,mBAAmB,yDAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAa;AACnC;AACA;AACA,wBAAwB;AACxB,yCAAyC;AACzC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7PgC;AACgB;AACzC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA;AACA,kBAAkB,yDAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAK;AACjC,uBAAuB,yCAAK;AAC5B,uBAAuB,yCAAK;AAC5B;AACA;AACA;AACA,0BAA0B,yCAAK;AAC/B;AACA;AACA,0BAA0B,yCAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yDAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAa,8BAA8B,yDAAa;AACnF;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA,oBAAoB,yCAAK;AACzB;AACA;AACA,gBAAgB,yCAAK;AACrB;AACA;AACA,gBAAgB,yCAAK;AACrB;AACA;AACA,gBAAgB,yCAAK;AACrB;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAK;AACrB;AACA;AACA,gBAAgB,yCAAK;AACrB;AACA;AACA,gBAAgB,yCAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAK;AAC/B;AACA;AACA,0BAA0B,yCAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yDAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,yCAAK,kBAAkB,yCAAK,sBAAsB,yCAAK;AACtH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrPgC;AACY;AACI;AACA;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA,uBAAuB,yCAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yDAAa;AACjE,sDAAsD,yDAAa;AACnE,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA,0EAA0E,yCAAK,2BAA2B,yDAAa;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yDAAa;AACvE,uBAAuB,yDAAa,wBAAwB,yDAAa;AACzE,0BAA0B,yDAAa;AACvC,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,yDAAa;AAChH;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,+BAA+B,yDAAa;AAC5C;AACA;AACA;AACA;;;;;;;;;;;;;;ACrGmD;AACnB;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAY;AAC5B,YAAY,4DAAY;AACxB,YAAY,4DAAY;AACxB,YAAY,4DAAY;AACxB,YAAY,4DAAY;AACxB,YAAY,4DAAY;AACxB;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/E+C;AACC;AACK;AACrD,UAAU,QAAQ;AACX;AACP;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AAC5C;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gCAAgC,yDAAa,SAAS,yDAAa;AACnE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yDAAa;AAC/D,kDAAkD,yDAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAa,0CAA0C,yDAAa;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAc;AAChC;AACA;AACA,eAAe,8DAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC,oBAAoB,wDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC,kCAAkC,yDAAa;AAC/C;AACA,yBAAyB,yDAAa;AACtC;AACA;AACA;AACA,8BAA8B,yDAAa;AAC3C,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA,sBAAsB,yDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAa;AAChC;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAa;AAChC;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAa;AAC9C,qBAAqB;AACrB;AACA,sCAAsC,yDAAa;AACnD,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;;;;;;;;;;;;;AC/T6E;AAC5C;AACjC;AACO;AACP;AACA,YAAY,mEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAM;AACrB;AACA;AACA,mBAAmB,mEAAe;AAClC;AACA;AACA;AACA,eAAe,mEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrCqD;AACb;AACQ;AACA;AACJ;AACZ;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,4DAA4D,yCAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAK;AAC/B;AACA;AACA;AACA,gBAAgB,yCAAK;AACrB,YAAY,uDAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAa;AAChC;AACA;AACA,iBAAiB,yCAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAW;AACtC,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAW;AACtC,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,2BAA2B,yDAAa;AACxC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,iDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAK;AAC3B,QAAQ,yCAAK;AACb;AACA;AACA,YAAY,yCAAK;AACjB;AACA,YAAY,yCAAK;AACjB;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D,gBAAgB,yCAAK,oEAAoE,uDAAmB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/YO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/CgC;AACM;AACU;AACG;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAY;AAC5B,YAAY,4DAAY;AACxB,YAAY,4DAAY;AACxB,YAAY,4DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAa;AACjD;AACA,oCAAoC,yDAAa;AACjD;AACA;AACA;AACA;AACA,mCAAmC,yDAAa;AAChD;AACA,mCAAmC,yDAAa;AAChD;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAA8C;AAC7E;AACA;AACA;AACA;AACA,+BAA+B,oDAAoD;AACnF;AACA;AACA;AACA,kCAAkC,0CAA0C;AAC5E,kBAAkB,yCAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAa;AACpD,+CAA+C,yDAAa;AAC5D,qCAAqC,yDAAa;AAClD,6CAA6C,yDAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAK,8EAA8E,yCAAK;AAC9H;AACA;AACA;AACA,yBAAyB,+CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wEAAwE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAoD;AACnF;AACA;AACA;AACA;AACA;AACA,qBAAqB,yCAAK;AAC1B,qBAAqB,yCAAK;AAC1B,qBAAqB,yCAAK;AAC1B,qBAAqB,yCAAK;AAC1B;AACA;AACA;;;;;;;;;;;;;;AC9YqD;AACC;AACtD;AACO,6BAA6B,uDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAgB;AACxC;AACA,oBAAoB,+DAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrHkD;AACU;AAC5D;AACO,sCAAsC,2DAAc;AAC3D;AACA;AACA;AACA;AACA;AACA,cAAc,qEAAsB;AACpC;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCqD;AACrD;AACO,sBAAsB,uDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACTyC;AACR;AACG;AACpC;AACO,qCAAqC,6CAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA,uCAAuC,yCAAK;AAC5C,kDAAkD,yCAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/D0C;AACU;AACA;AACQ;AACrD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAU;AACjC;AACA;AACA;AACA,0BAA0B,mDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAK;AAC/B,+BAA+B;AAC/B,eAAe;AACf;AACA,2BAA2B,uDAAK;AAChC;AACA;AACA;AACA;AACA,qBAAqB,uDAAK;AAC1B,oBAAoB,uDAAK;AACzB;AACA,sBAAsB,uDAAK;AAC3B,gBAAgB,uDAAK;AACrB;AACA;AACA,UAAU;AACV;AACA;AACA,iBAAiB,uDAAK;AACtB,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA,oCAAoC,+DAAS,0BAA0B,uDAAK,yBAAyB,uDAAK;AAC1G;AACA;AACA,kBAAkB,uDAAK;AACvB,YAAY,uDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAS;AACxB;AACA;AACA;;;;;;;;;;;;;AC3GyC;AAClC;AACP;AACA,sBAAsB,mDAAK;AAC3B,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCgF;AACzE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qFAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtFgD;AACoB;AAC3B;AAClC;AACP;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,2EAAe,2BAA2B,mDAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAK;AAC5B;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,kCAAkC,wCAAwC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5EyC;AACa;AACZ;AACJ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,0BAA0B,GAAG,UAAU,MAAM,SAAS,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mDAAK;AACjD;AACA,oCAAoC,mDAAU;AAC9C,uCAAuC,+CAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+CAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mDAAK;AACjD;AACA;AACA,oCAAoC,mDAAU;AAC9C,uCAAuC,+CAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,2CAA2C;AAC3C;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjiBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChCsD;AACD;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,kBAAkB,EAAE,IAAI,EAAE,GAAG,IAAI,MAAM,KAAK,MAAM,IAAI,KAAK,EAAE,OAAO,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAc;AAChC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFyC;AAClC;AACP;AACA;AACA;AACA;AACA,6BAA6B,mDAAK;AAClC,oCAAoC,mDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFsD;AACtD,8DAA8D;AAC9D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,UAAU,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE;AACtD;AACA;AACA;;;;;;;;;;;;;AChCA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8BAA8B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8BAA8B;AAC3D;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChWA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACqD;AACI;AACzB;AACY;AACF;AACY;AACZ;AACZ;AACQ;AACc;AACd;AACY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAW;AACxC;AACA;AACA,kCAAkC,+DAAgB;AAClD;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAc;AAChD;AACA;AACA;AACA,gCAAgC,mDAAU;AAC1C;AACA,kCAAkC,+CAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAQ;AACnC,0BAA0B,yCAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA,gCAAgC;AAChC;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2CAA2C;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kDAAkD;AAClD,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAe;AAC7B,cAAc,6DAAe;AAC7B;AACA;AACA;AACA;AACA,yBAAyB,uCAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,6EAA6E,aAAa;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACn2BA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;;;;;;;;;;;;;;ACfA;AAC4D;AAC1B;AAC3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAc;AAC9C,8BAA8B,iEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxOiE;AACC;AACpB;AACF;AACU;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAO;AACpD;AACA;AACA,6CAA6C,mDAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2EAAe;AACpC;AACA,4BAA4B,sEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,sBAAsB,+DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClIO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrCsD;AACD;AACrD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,eAAe,gEAAM,UAAU,IAAI,MAAM,EAAE,KAAK,GAAG,OAAO,KAAK;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iCAAiC;AAC/E;AACA;AACA,eAAe,8DAAc;AAC7B;AACA;AACA;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;;;;;;;;;;;;ACtIO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjMyC;AACkC;AACpE,kCAAkC,mFAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,iDAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACkE;AACK;AACb;AACV;AACI;AAChB;AACA;AACM;AACkE;AACrG,kBAAkB,uDAAS;AAClC;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,sBAAsB,6CAAO,wBAAwB,uDAAK;AAC1D,sBAAsB,6CAAO,yBAAyB,uDAAK;AAC3D;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA,iCAAiC,uDAAK,8DAA8D,qEAAmB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,gBAAgB,uDAAK,0CAA0C,uEAAa;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oGAAgC,qDAAqD,mFAAe;AAChJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzOsD;AAC1B;AACrB;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB,qCAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,WAAW,EAAE,EAAE,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACrFyC;AACmB;AACN;AACY;AACJ;AACS;AACrB;AACA;AACU;AAChC;AACwB;AACR;AACI;AAChD;AACO,yBAAyB,uDAAS;AACzC;AACA;AACA,yBAAyB,uDAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAW;AACzC;AACA,8BAA8B,8DAAe;AAC7C,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK,qEAAqE,qEAAmB;AAC7G;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAU,8DAA8D,mEAAW;AAC3G;AACA;AACA,gBAAgB,iEAAU,mCAAmC,2DAAO;AACpE;AACA,4BAA4B,OAAO;AACnC;AACA,wBAAwB,iEAAU,yGAAyG,mEAAW;AACtJ;AACA;AACA;AACA;AACA,wBAAwB,iEAAU;AAClC;AACA;AACA,oBAAoB,iEAAU,qCAAqC,mEAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAU;AAClC;AACA;AACA;AACA;AACA,wBAAwB,iEAAU;AAClC;AACA;AACA;AACA;AACA,wBAAwB,iEAAU,qCAAqC,mEAAW;AAClF;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAU,+DAA+D,mEAAW;AACvG,eAAe,iEAAU,mFAAmF,mEAAW;AACvH;AACA;AACA;AACA,oBAAoB;AACpB,yDAAyD,uEAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8DAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB,gBAAgB,qEAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C,qCAAqC,8DAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB,gBAAgB,qEAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK,iGAAiG,qEAAmB;AACrI,uBAAuB,sDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAW;AAC3B,uBAAuB,sDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qKAAqK,iCAAiC;AACtM;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mKAAmK;AAC3N;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO,uDAAK,2EAA2E;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,gCAAgC,iEAAc,MAAM,uDAAK;AACzD,gCAAgC,iEAAc,MAAM,uDAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mCAAmC;AACtG,wCAAwC,2EAA2E;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,gCAAgC,iEAAc,MAAM,uDAAK;AACzD,gCAAgC,iEAAc,MAAM,uDAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO,uDAAK,6EAA6E;AACnG;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,kCAAkC;AAC1G,kBAAkB,0EAA0E;AAC5F;AACA;AACA,YAAY,uDAAK;AACjB;AACA;AACA,iBAAiB,uDAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA,sEAAsE,uDAAuD;AAC7H,+BAA+B,2EAA2E;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK,wDAAwD,qEAAmB;AAC5F,QAAQ,uDAAK,wDAAwD,qEAAmB;AACxF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,uEAAa;AAC3H;AACA;AACA,QAAQ,uDAAK;AACb,QAAQ,qEAAmB;AAC3B;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qCAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5+BmE;AACC;AACG;AACb;AAChB;AAC1C;AACO;AACP;AACA;AACA,yBAAyB,mDAAU;AACnC;AACA,yBAAyB,mDAAU;AACnC;AACA;AACA,iEAAiE,yDAAa;AAC9E;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,yBAAyB,uDAAK;AAC9B,wBAAwB,yDAAa;AACrC,uBAAuB,yDAAa;AACpC;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA,8BAA8B,yDAAa,YAAY,yDAAa;AACpE;AACA;AACA;AACA,6DAA6D,yDAAa;AAC1E;AACA,6DAA6D,yDAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6EAAiB;AAChC;AACA;AACA,4BAA4B,uDAAK;AACjC;AACA;AACA,iBAAiB,qEAAmB;AACpC;AACA;AACA,iBAAiB,qEAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB,iBAAiB,qEAAmB;AACpC;AACA;AACA;AACA;AACA,iBAAiB,qEAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,EAAE,EAAE,EAAE,EAAE,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClKO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7EA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;;;;;;;;;;;;;;ACXsD;AACF;AAC7C;AACP;AACA;AACA,oCAAoC,6DAAe;AACnD,kCAAkC,6DAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+DAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAe;AACrC;AACA,4CAA4C,+DAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC1HwD;AACiB;AACQ;AACO;AACM;AAC/B;AACpB;AACL;AACwB;AACI;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6FAAyB;AACjD;AACA;AACA;AACA,2BAA2B,uEAAY,kBAAkB,2EAAc;AACvE;AACA;AACA;AACA;AACA,2FAA2F,iDAAK,4CAA4C,yDAAa,WAAW,iFAAe,QAAQ,iFAAe;AAC1M;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0GAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2EAAe;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAyB;AAC5C;AACA,QAAQ,oGAA2B,iCAAiC,mDAAO;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAQ;AACvB;AACA;AACA;;;;;;;;;;;;;;ACpG2F;AACd;AACtE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mGAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,sFAAsB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjF+B;AACoB;AACnD;AACO;AACP;AACA;AACA;AACA;AACA,yBAAyB,wCAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AACgC;AACzB,4BAA4B,yCAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChBA;AACqD;AACsC;AAChB;AAC1B;AACjD,WAAW,QAAQ;AACyC;AACZ;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAa;AACvC,qBAAqB,mFAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAa;AACvC,qBAAqB,qEAAmB;AACxC;AACA;AACA;AACA,uCAAuC,yDAAc;AACrD;AACA,sCAAsC,mGAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAc;AACrD;AACA,sCAAsC,mGAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxHqD;AACE;AACP;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAU;AACrB;AACA;AACA;AACA,cAAc,+DAAU;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7FA;AACA;AACwD;AACC;AACJ;AACoD;AACzB;AACnC;AACS;AAC0B;AAChD;AACsB;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAU,KAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oGAAgC,oCAAoC,mFAAe;AAC1H,QAAQ,4FAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAK,4EAA4E,yDAAa;AAC7G;AACA;AACA;AACA;AACA,6BAA6B,yFAA6B;AAC1D,8BAA8B,yFAA6B;AAC3D,mCAAmC,yCAAK;AACxC,wBAAwB,+DAAgB;AACxC;AACA;AACA;AACA,+BAA+B,oGAAgC,oBAAoB,mFAAe;AAClG;AACA;AACA;AACA;AACA;AACA,8BAA8B,yFAA6B;AAC3D;AACA;AACA;AACA,mBAAmB,yFAA6B;AAChD,oCAAoC,kEAAY,+DAA+D,iDAAK,2CAA2C,yDAAa;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAQ,oBAAoB,iEAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjF2F;AACzC;AAC2B;AACtE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mGAA8B,CAAC,0DAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,sFAAsB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnF2F;AACzC;AAC2B;AACtE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mGAA8B,CAAC,0DAAc;AACpE;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,sFAAsB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChIA;AACqD;AACI;AACV;AACgB;AACJ;AACZ;AACsB;AACtB;AACD;AAC6B;AACpE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,uDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mFAAoB;AAChD;AACA;AACA,4BAA4B,mFAAoB;AAChD;AACA;AACA;AACA;AACA,QAAQ,6DAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uEAAa;AACpD;AACA;AACA,oFAAoF;AACpF;AACA,0BAA0B,uEAAa;AACvC,sBAAsB,uDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6EAAgB;AAC9B,cAAc,6EAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA,2DAA2D,uDAAK,eAAe,uDAAK;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAW;AAC9B,yBAAyB,uDAAK;AAC9B;AACA;AACA,6BAA6B,mEAAW;AACxC;AACA,6BAA6B,uDAAK;AAClC;AACA;AACA,qCAAqC,mEAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6EAAgB;AAClD;AACA;AACA,QAAQ,6DAAS;AACjB;AACA;AACA,8BAA8B,uDAAK;AACnC,8BAA8B,uDAAK;AACnC,8BAA8B,uDAAK;AACnC,8BAA8B,uDAAK;AACnC,mBAAmB,iEAAU;AAC7B,6BAA6B,6EAAgB;AAC7C,eAAe,iEAAU;AACzB,eAAe,iEAAU;AACzB,eAAe,iEAAU;AACzB,eAAe,iEAAU;AACzB,QAAQ,iEAAU;AAClB;AACA;AACA;AACA,QAAQ,uDAAY;AACpB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9LA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACwD;AACH;AACM;AACgC;AACZ;AAC5B;AACU;AACY;AACJ;AACW;AACsD;AACN;AACjE;AAChB;AAC8B;AACd;AACF;AACd;AACwE;AACrE;AACiC;AACnF,WAAW,QAAQ;AACZ,oCAAoC,wDAAS;AACpD;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,+BAA+B,wCAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAQ;AACtB,cAAc,oDAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mEAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yEAAe;AACtD;AACA;AACA;AACA;AACA,uCAAuC,wCAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iIAA2C;AAC5F;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6FAAyB,sGAAsG,uEAAc;AACrK;AACA;AACA,wBAAwB,6FAAyB,0HAA0H,uEAAc;AACzL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAK;AACjB,YAAY,qEAAmB;AAC/B;AACA;AACA;AACA;AACA,iBAAiB,uDAAW;AAC5B,kBAAkB,iDAAK;AACvB;AACA;AACA;AACA,iBAAiB,uDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yDAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,uDAAW;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA,yFAAyF,6DAAS;AAClG;AACA;AACA,yFAAyF,6DAAS;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAQ,sBAAsB,iDAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mEAAY;AACxE,4DAA4D,mEAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yFAA6B;AAC9D;AACA;AACA;AACA,gBAAgB,oCAAK,gFAAgF,qEAAmB;AACxH,YAAY,oCAAK,+EAA+E,qEAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH;AACtH,8CAA8C;AAC9C,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAK;AACvB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oDAAoD,iCAAiC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0IAAqD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yFAA6B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAM;AAClB,YAAY,qCAAM;AAClB;AACA,wCAAwC,yEAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAY;AAC1C;AACA;AACA;AACA,yBAAyB,uCAAQ;AACjC,iBAAiB,uDAAW;AAC5B;AACA,iCAAiC,oDAAQ;AACzC;AACA;AACA,qCAAqC,6EAAgB;AACrD;AACA;AACA;AACA;AACA,uCAAuC,6DAAS;AAChD,iBAAiB,uDAAW;AAC5B;AACA;AACA,qCAAqC,oDAAQ;AAC7C;AACA;AACA;AACA,6BAA6B,6EAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAS;AAChD;AACA;AACA,qBAAqB,6EAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6DAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAW;AAC9B;AACA;AACA;AACA;AACA,6BAA6B,oDAAQ;AACrC;AACA;AACA,eAAe,6EAAgB;AAC/B;AACA;AACA,uCAAuC,mEAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6EAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6EAAgB;AAC7C;AACA;AACA;AACA,6CAA6C,uDAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yEAAe;AACtD;AACA;AACA;AACA;AACA;AACA,uCAAuC,wCAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iIAA2C;AAC5F;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6FAAyB,4HAA4H,uEAAc;AAC/L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uFAAsB;AAC5F;AACA,gBAAgB,6FAAyB,uFAAuF,uEAAc;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oCAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mEAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAW;AAC5B;AACA,iCAAiC,oDAAQ;AACzC;AACA;AACA;AACA,oBAAoB,6EAAgB;AACpC;AACA;AACA;AACA;AACA,iBAAiB,uDAAW;AAC5B;AACA;AACA,qCAAqC,oDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAW;AAChC;AACA;AACA,yCAAyC,oDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAW;AACxC,6CAA6C,oDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAK;AAClC,6CAA6C,oDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,2DAA2D,uDAAW;AACtE;AACA,6CAA6C,oDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uDAAW;AACxB;AACA,6BAA6B,oDAAQ;AACrC,iCAAiC,6EAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAW;AAC3D;AACA;AACA;AACA;AACA,uCAAuC,yEAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iIAA2C;AAC5F;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,iDAAK,iDAAiD,yDAAa,WAAW,iFAAe,QAAQ,iFAAe;AACrM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mEAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yEAAW;AACtD;AACA;AACA,2CAA2C,iIAA2C;AACtF;AACA;AACA;AACA;AACA,qDAAqD,mEAAY,+BAA+B,6DAAS;AACzG,uCAAuC,mGAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAK,sFAAsF,yDAAa;AACxH;AACA,uCAAuC,6DAAS;AAChD;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,2CAA2C,6DAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mEAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAO;AAC/B,8BAA8B,iDAAK;AACnC;AACA,YAAY,oCAAK;AACjB,YAAY,qEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK,6BAA6B,uDAAW;AACpE,uBAAuB,iDAAK,6BAA6B,uDAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uDAAW;AAC7D,2BAA2B,iDAAK,6BAA6B,uDAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oCAAK,+DAA+D,qEAAmB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAK;AACvB;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA,gBAAgB,iDAAK,kDAAkD,yDAAa;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gJAAwD;AACrF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6FAAyB,wKAAwK,uEAAc;AAC3O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAS,UAAU,oCAAK,0DAA0D,oCAAK;AACtH;AACA;AACA;AACA,sBAAsB,yDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvvC+C;AACU;AACK;AACC;AACK;AACf;AACoD;AACjB;AACM;AAC3B;AACxB;AACF;AACa;AACP;AACxC;AACP;AACA,6CAA6C,uDAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB,YAAY,qEAAmB;AAC/B;AACA;AACA,kEAAkE,uDAAK;AACvE;AACA;AACA;AACA,gBAAgB,uEAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAU;AACnC,eAAe,6DAAQ;AACvB;AACA,4BAA4B,eAAe;AAC3C;AACA,4BAA4B,uDAAK,YAAY,sDAAM,yCAAyC,sDAAM;AAClG;AACA;AACA;AACA;AACA,eAAe,mFAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK,gDAAgD,+DAAa;AACjF;AACA;AACA,8DAA8D,uDAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oGAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAmB,kDAAkD,oDAAO;AAClG,oCAAoC,0GAAsB;AAC1D;AACA;AACA,2BAA2B,mEAAY;AACvC,+BAA+B,iEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK,sDAAsD,+DAAa;AACxF,YAAY,uDAAK,sDAAsD,+DAAa;AACpF;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA,QAAQ,oGAA2B;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAO;AACnC;AACA;AACA;AACA,+BAA+B,yDAAO,uBAAuB,yDAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK,qCAAqC,qEAAmB;AACzE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAK;AAC3B;AACA,qBAAqB;AACrB;AACA;AACA,uBAAuB,uEAAa;AACpC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK,qCAAqC,qEAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAQ;AAChC;AACA;AACA,sEAAsE,6DAAQ,+BAA+B,iEAAU;AACvH;AACA;AACA,sEAAsE,6DAAQ,+BAA+B,iEAAU;AACvH;AACA,4CAA4C,sBAAsB;AAClE;AACA,0EAA0E,6DAAQ,+BAA+B,iEAAU;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAQ;AAC5B;AACA,kCAAkC,GAAG;AACrC,oCAAoC,sDAAM;AAC1C,oCAAoC,sDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnV8D;AACvD,kCAAkC,sEAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACkE;AACR;AAC1D;AACO,gCAAgC,0EAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCgE;AACzD,+BAA+B,wEAAW;AACjD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AAC8E;AAChB;AACvD;AACP;AACA,6BAA6B,mFAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uEAAoB;AACxE,oDAAoD,uEAAoB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChDA;AACA;AAC+D;AACf;AACJ;AACc;AACnD;AACP;AACA;AACA;AACA;AACA,mCAAmC,qDAAW,oBAAoB,qDAAW;AAC7E;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;AACA,6CAA6C,qDAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yDAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAa;AACtC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAa;AAClC;AACA;AACA,iFAAiF,qDAAS,SAAS,qDAAS,SAAS,qDAAW;AAChI,iFAAiF,qDAAS,QAAQ,qDAAS,QAAQ,qDAAW;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtGA;AACA;AACA;AACsD;AACY;AACA;AAChB;AAClD;AACO;AACP;AACA,6BAA6B,uEAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK,4BAA4B,uEAAa;AAC7D;AACA;AACA,eAAe,gEAAM,UAAU,IAAI,EAAE;AACrC;AACA;AACA,sCAAsC,uEAAa;AACnD;;;;;;;;;;;;;;;;;AC1BsD;AACN;AACgB;AACA;AAChB;AAChD;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,qDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa,wCAAwC,yDAAa;AAClF;AACA;AACA;AACA;AACA,yCAAyC,yEAAqB;AAC9D;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,UAAU,EAAE;AACjC;AACA;AACA;;;;;;;;;;;;;ACvE8D;AACvD,kCAAkC,uEAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AACA;AACA;AACkD;AAC3C;AACP;AACA;AACA;AACA,6BAA6B,uDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtF8D;AACvD,iCAAiC,uEAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPsD;AAC/C,iCAAiC,+DAAgB;AACxD;AACA;AACA;AACA;AACO,kCAAkC,+DAAgB;AACzD;AACA;AACA;AACA;AACO,+BAA+B,+DAAgB;AACtD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChBkD;AACC;AACP;AACgB;AACrD;AACP;AACA,kDAAkD,qEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,eAAe,qEAAmB;AAClC;AACA;AACA;AACA,2CAA2C;AAC3C,iDAAiD;AACjD;AACA;AACA,mCAAmC,qEAAmB;AACtD;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA,yCAAyC,qDAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAmB;AAC5C;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4DAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1H0D;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9BuD;AACO;AACvD;AACP;AACA;AACA,mCAAmC,qDAAS;AAC5C;AACA;AACA;AACA,wBAAwB,iDAAK;AAC7B;AACA;AACA,6BAA6B,uEAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAK,6BAA6B,iDAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9CsD;AAC8D;AACpE;AACA;AACJ;AACc;AACnD;AACP;AACA;AACA;AACA;AACA,mCAAmC,qDAAW,oBAAoB,qDAAW;AAC7E;AACA;AACA,eAAe,yDAAa,iBAAiB,yDAAa;AAC1D;AACA;AACA,eAAe,mEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa,mFAAmF,qDAAS;AACxH;AACA;AACA;AACA,4CAA4C,qDAAW;AACvD;AACA;AACA;AACA;AACA,wBAAwB,uDAAW,oCAAoC,mEAAkB;AACzF,oBAAoB,iDAAK;AACzB;AACA,yCAAyC,iDAAK;AAC9C,oBAAoB;AACpB;AACA;AACA;AACA;AACA,sIAAsI,yDAAa;AACnJ;AACA,oDAAoD,qDAAW;AAC/D;AACA;AACA,kFAAkF,qDAAW;AAC7F;AACA;AACA;AACA;AACA;AACA,gDAAgD,qDAAW;AAC3D;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAkB;AACnC;AACA;AACA,yEAAyE,uDAAW;AACpF,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA,gBAAgB,yDAAa,aAAa,iDAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAkB;AACtC,eAAe,yDAAa,kEAAkE,yDAAa;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,UAAU,IAAI,EAAE,EAAE,IAAI,EAAE;AAC7C;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxJ8B;AACmF;AACrD;AACgB;AACgC;AACI;AACf;AAChC;AACd;AACL;AACM;AACK;AACa;AAChC;AACkB;AACR;AACA;AACA;AACU;AACnD;AACP;AACA;AACA,mDAAmD,gFAAwB;AAC3E;AACA,gCAAgC,0DAAU;AAC1C;AACA;AACA;AACA,iCAAiC,mDAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oGAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,mFAAe;AAC5E,eAAe,oGAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kCAAkC,mDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAO;AACzC;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAK,uDAAuD,yDAAa;AACxF;AACA;AACA;AACA;AACA,0CAA0C,mDAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0EAAc;AACpC,oCAAoC,0GAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0EAAc;AACpC,oCAAoC,0GAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAY;AACvC,4BAA4B,kEAAiB,CAAC,iEAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF,oBAAoB;AACpB;AACA,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAiB,CAAC,iEAAU;AAC5D;AACA;AACA,YAAY,iDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAK,6DAA6D,yDAAa;AAC/F,wCAAwC,iDAAK;AAC7C,qBAAqB,oCAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAAkB;AAC1D,YAAY,0DAAa,wDAAwD,qDAAS;AAC1F;AACA,mBAAmB,uDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0DAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iFAAe;AAClC;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,mBAAmB,iFAAe;AAClC;AACA,aAAa,oEAAkB;AAC/B;AACA,mBAAmB,iFAAe;AAClC;AACA;AACA;AACA,qBAAqB,oEAAkB;AACvC,oBAAoB,oEAAkB;AACtC,wBAAwB,uDAAW;AACnC,oBAAoB,iDAAK;AACzB;AACA,uBAAuB;AACvB;AACA;AACA;AACA,6BAA6B,oCAAK;AAClC,8BAA8B,oCAAK;AACnC;AACA,iBAAiB,0DAAa;AAC9B,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAY;AACjC,2BAA2B,iFAAe;AAC1C;AACA;AACA;AACA,eAAe,iFAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAa;AACpC,uBAAuB,qDAAS,yCAAyC,qDAAS;AAClF,qBAAqB,qDAAS,wCAAwC,qDAAS;AAC/E,uBAAuB,qDAAS,4CAA4C,qDAAS;AACrF,qBAAqB,qDAAS,2CAA2C,qDAAS;AAClF,iDAAiD,uDAAW,UAAU,oCAAK,sBAAsB,oCAAK;AACtG;AACA;AACA;AACA,aAAa,oEAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAa;AAC3C;AACA,8BAA8B,oCAAK;AACnC,mCAAmC,0DAAa;AAChD,mCAAmC,yDAAa;AAChD;AACA;AACA;AACA,gBAAgB,qDAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAK;AACvC,oBAAoB,oCAAK;AACzB,oBAAoB,oCAAK;AACzB;AACA;AACA;AACA;AACA,4CAA4C,0DAAa,yFAAyF,oEAAkB;AACpK;AACA;AACA;AACA;AACA;AACA,8BAA8B,oCAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAa;AACpD;AACA;AACA,+BAA+B,yDAAa;AAC5C;AACA,qFAAqF;AACrF;AACA,oCAAoC,yDAAa;AACjD,qCAAqC,yDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9mBsD;AAC/C,8BAA8B,+DAAgB;AACrD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACsC;AAC/B;AACP;AACA;AACA;AACA;AACA,QAAQ,+CAAQ;AAChB;AACA;AACA;;;;;;;;;;;;ACVA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRA;AACA;AACsD;AACE;AACR;AAChD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iEAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,yDAAa,yCAAyC,yDAAa;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,UAAU,GAAG,EAAE,EAAE;AACtC;AACA;AACA;;;;;;;;;;;;;;;ACtHkE;AACR;AACQ;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAa;AAC5B;AACA;AACA;AACA;AACA,eAAe,uEAAa;AAC5B;AACA;AACA,eAAe,uEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAS,iBAAiB,+DAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAa;AAC/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACqE;AACd;AACW;AACD;AACP;AACI;AACmB;AACnC;AACE;AACA;AACJ;AACc;AAClB;AAC0B;AACF;AAChB;AACA;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAQ;AACxC;AACA,sDAAsD,sDAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0EAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAK;AACrC,YAAY,+DAAa,aAAa,uDAAK;AAC3C,wDAAwD;AACxD;AACA;AACA;AACA,YAAY,+DAAa,aAAa,uDAAK;AAC3C,oDAAoD;AACpD;AACA;AACA,0BAA0B,uDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iDAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,+BAA+B,mEAAa;AAC5C,+BAA+B,mEAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,+DAAS,SAAS,+DAAS;AACnG;AACA,oEAAoE,+DAAS,QAAQ,+DAAS;AAC9F;AACA;AACA;AACA,YAAY,+DAAS;AACrB;AACA;AACA;AACA,2BAA2B,uEAAa;AACxC;AACA;AACA;AACA;AACA,8GAA8G,sDAAW;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,qEAAqE,qDAAS;AAC9E;AACA;AACA,4BAA4B,+DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAK;AACjB,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAS,MAAM,iDAAK,qDAAqD,iDAAK;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA,oBAAoB;AACpB,aAAa,yDAAa,qCAAqC,yDAAa;AAC5E;AACA,6BAA6B,mEAAW;AACxC;AACA,uCAAuC,iDAAK;AAC5C;AACA;AACA,uCAAuC,iDAAK;AAC5C;AACA,uCAAuC,iDAAK;AAC5C;AACA,uCAAuC,iDAAK;AAC5C;AACA;AACA;AACA;AACA,aAAa,yDAAa,sCAAsC,yDAAa;AAC7E;AACA,6BAA6B,mEAAW;AACxC;AACA,uCAAuC,iDAAK;AAC5C;AACA;AACA,uCAAuC,iDAAK;AAC5C;AACA,uCAAuC,iDAAK;AAC5C;AACA,uCAAuC,iDAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA,gBAAgB,iDAAK;AACrB,gBAAgB,iDAAK;AACrB;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC,aAAa,yDAAa;AAC1B;AACA;AACA,aAAa,yDAAa;AAC1B,+EAA+E,uEAAa;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yFAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC,+CAA+C,oEAAkB;AACjE;AACA;AACA;AACA,+CAA+C,wEAAa;AAC5D;AACA;AACA;AACA,6BAA6B,uEAAa;AAC1C;AACA,qBAAqB,uEAAa;AAClC,gBAAgB,+DAAS;AACzB;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAS;AAC9B,YAAY,yDAAa;AACzB,qBAAqB,+DAAS;AAC9B;AACA,iBAAiB,yDAAa;AAC9B,qBAAqB,+DAAS;AAC9B;AACA,iBAAiB,yDAAa;AAC9B,qBAAqB,+DAAS;AAC9B;AACA,iBAAiB,yDAAa;AAC9B,qBAAqB,+DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA,2CAA2C,uEAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,+CAA+C,sDAAW,oBAAoB,sDAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAkB;AACjC;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAkB;AACzC;AACA;AACA,0CAA0C,oEAAkB;AAC5D;AACA;AACA;AACA;AACA,+BAA+B,oEAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAkB;AAChD;AACA;AACA,sEAAsE,oEAAkB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAa;AAC9B;AACA;AACA;AACA,+DAA+D,uEAAa;AAC5E;AACA;AACA;AACA;AACA,kCAAkC,yDAAa;AAC/C,sBAAsB,yDAAa;AACnC;AACA;AACA,yBAAyB;AACzB,YAAY,0EAAqB;AACjC;AACA,wEAAwE,uEAAa,gHAAgH,uEAAa;AAClN;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAkB,+BAA+B,uEAAa;AACxF,wBAAwB,oEAAkB;AAC1C;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAkB;AAClD;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS,aAAa,iDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,sBAAsB,+DAAS;AAC/B;AACA;AACA;AACA,sBAAsB,oEAAkB;AACxC,0DAA0D,uEAAa;AACvE,0DAA0D,uEAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA,aAAa,yDAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAa;AACxC;AACA;AACA;AACA;AACA,2GAA2G,sDAAW;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAkB,oCAAoC,uEAAa;AACtG;AACA,yGAAyG,sDAAW;AACpH;AACA,oCAAoC,oEAAkB,oCAAoC,uEAAa;AACvG;AACA,0GAA0G,sDAAW;AACrH;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACj0BA;AACA;AACA;AACA;AACA;AAC0C;AACE;AACU;AACJ;AACI;AACY;AACV;AACN;AACH;AACA;AACa;AACtB;AACA;AACU;AACJ;AACqC;AACrB;AACJ;AACxD;AACO,oCAAoC,uDAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iDAAK,cAAc,iDAAK,+CAA+C,iDAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2FAA8B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sEAAmB;AACrE,kCAAkC,2FAA8B;AAChE,+BAA+B,sDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uDAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gDAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,yBAAyB,2DAAQ;AACjC;AACA;AACA;AACA;AACA,uCAAuC,sEAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,uDAAY;AACjF,kGAAkG;AAClG;AACA,QAAQ,mDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,6DAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAQ;AAC3B;AACA;AACA,0BAA0B,uDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB;AACA;AACA,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK;AACjB;AACA;AACA,YAAY,uDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,4BAA4B,uEAAa;AACzC,0BAA0B,2DAAO,WAAW,iDAAK,YAAY,iDAAK;AAClE;AACA;AACA;AACA;AACA,0BAA0B,2DAAO,WAAW,iDAAK,YAAY,iDAAK;AAClE;AACA;AACA;AACA;AACA,sBAAsB,2DAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxgBwD;AACsB;AAClC;AACgB;AACY;AACvB;AACe;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yEAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,mBAAmB;AACpF;AACA;AACA;AACA;AACA;AACA,oCAAoC,6EAAgB;AACpD;AACA;AACA,aAAa,6DAAS;AACtB,YAAY,6DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6EAAgB;AACpD;AACA;AACA,aAAa,6DAAS;AACtB,YAAY,6DAAS;AACrB;AACA;AACA;AACA,8BAA8B,iDAAK;AACnC,8BAA8B,iDAAK;AACnC,8BAA8B,iDAAK;AACnC,8BAA8B,iDAAK;AACnC,mBAAmB,iEAAU;AAC7B,6BAA6B,6EAAgB;AAC7C,eAAe,iEAAU;AACzB,eAAe,iEAAU;AACzB,eAAe,iEAAU;AACzB,eAAe,iEAAU;AACzB,QAAQ,iEAAU;AAClB;AACA;AACA;AACA;AACA,0BAA0B,yDAAa;AACvC,4BAA4B,mFAAoB,kDAAkD,iDAAK;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtIkD;AACoB;AAChB;AACI;AACY;AAC/D;AACP;AACA;AACA,4BAA4B,uDAAM;AAClC;AACA;AACA;AACA,mDAAmD,EAAE,iBAAiB,EAAE,oBAAoB,EAAE;AAC9F;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAe;AACnD;AACA;AACA;AACA,+BAA+B,+EAAwB;AACvD,gCAAgC,+EAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+DAAe;AAC/D,kDAAkD,+DAAe;AACjE,kBAAkB,+DAAe;AACjC;AACA,sBAAsB,8DAAc;AACpC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3FkE;AACR;AACV;AACU;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAa;AAC7C,6BAA6B,+DAAS,oCAAoC,+DAAS,QAAQ,+DAAS;AACpG,oCAAoC,uEAAa;AACjD,iCAAiC,uEAAa;AAC9C;AACA;AACA,eAAe,+DAAS;AACxB;AACA;AACA,eAAe,+DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA,qDAAqD,+DAAS;AAC9D,mDAAmD,+DAAS;AAC5D;;;;;;;;;;;;;;;;;;;;;AC3EA,WAAW,OAAO;AACgC;AACG;AACG;AACM;AACE;AACA;AAChB;AACA;AACU;AACnD,0BAA0B,gEAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAa,oBAAoB,yDAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,yEAAqB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAc;AACvC,QAAQ,wEAAe;AACvB;AACA;AACA;AACA,aAAa,yDAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yDAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B,YAAY,yDAAa;AACzB,YAAY,yDAAa,qCAAqC,yDAAa;AAC3E;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAK,gCAAgC,uDAAK;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,0DAAc;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B,kCAAkC,yEAAqB;AACvD;AACA,gBAAgB,yDAAa;AAC7B,mCAAmC,yEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sEAAc;AACzC;AACA;AACA;;;;;;;;;;;;;;;;ACzZkD;AACA;AACF;AACJ;AACrC;AACP;AACA;AACA,6BAA6B,qDAAW,QAAQ,uDAAK,YAAY,uDAAK;AACtE;AACA,+BAA+B,uDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrRA;AAC4C;AACoB;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qDAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iBAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iBAAiB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/HA;AACkD;AACF;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yDAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B,oBAAoB,yDAAa;AACjC,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uDAAK,8BAA8B,uDAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACkD;AACQ;AACV;AACY;AACN;AACF;AACJ;AACA;AACJ;AACY;AACE;AACY;AACtE;AACO,6CAA6C,gFAAwB;AAC5E;AACA;AACA;AACA,0CAA0C,qDAAQ;AAClD;AACA,wCAAwC,qDAAQ;AAChD;AACA;AACA,4CAA4C,qDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iEAAiB;AAChE,6CAA6C,iEAAiB;AAC9D,2BAA2B,gDAAgD;AAC3E;AACA;AACA,2BAA2B,8CAA8C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qEAAmB,KAAK,uDAAK;AACzE;AACA;AACA;AACA;AACA,wCAAwC,qEAAmB,KAAK,uDAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oEAAkB;AACpE,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA,mDAAmD,oEAAkB;AACrE,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,kIAAkI,6DAAe;AACjJ,YAAY,yDAAa;AACzB;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+DAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,qDAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,qDAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAK;AACvB,kBAAkB,uDAAK;AACvB,iEAAiE,qDAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,+DAAe;AACvE;AACA;AACA;AACA,oGAAoG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+DAAmB;AAC3D;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,mBAAmB;AACnB;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yFAAyF;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iBAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrdkD;AAC3C;AACP;AACA;AACA;AACA,wBAAwB,uDAAK;AAC7B;AACA,kBAAkB,uDAAK;AACvB,kBAAkB,uDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK;AACpB;AACA;AACA;;;;;;;;;;;;;;;;;AC3BA;AACkE;AACR;AACoC;AAC3B;AACvB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,+DAAS;AAC9H;AACA;AACA;AACA;AACA,yBAAyB,mGAA8B,CAAC,0DAAc;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+DAAS;AAChD;AACA;AACA,0EAA0E,uEAAa;AACvF;AACA;AACA,0EAA0E,uEAAa;AACvF;AACA;AACA,gDAAgD,+DAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAY,yBAAyB,4DAAY;AAC7D;AACA;AACA;AACA,4BAA4B,uEAAa;AACzC;AACA,iCAAiC,+DAAS;AAC1C,+BAA+B,+DAAS,SAAS,+DAAS,UAAU,+DAAS,QAAQ,+DAAS;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAS;AAC3B;AACA;AACA;AACA,kBAAkB,+DAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA,iBAAiB,+DAAS;AAC1B,uBAAuB,+DAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAW;AACrC;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAa;AAC/C;AACA,oCAAoC,+DAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA,qDAAqD,+DAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C,gFAAgF,uEAAa;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,oGAAoG;AACpG;AACA;AACA,4GAA4G;AAC5G;AACA;AACA,oCAAoC,uEAAa;AACjD,qEAAqE,uEAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAS;AACb,IAAI,+DAAS,SAAS,+DAAS,QAAQ,+DAAS;AAChD,IAAI,+DAAS,SAAS,+DAAS,QAAQ,+DAAS;AAChD;AACA,IAAI,+DAAS,QAAQ,+DAAS,SAAS,+DAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxbA,WAAW,eAAe;AACgC;AACR;AACF;AACzC;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,uDAAK,qCAAqC,uDAAK;AAClH;AACA;AACA,oBAAoB,yDAAa;AACjC,yDAAyD,uDAAK,wBAAwB,uDAAK;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAa,6BAA6B,yDAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAa,6BAA6B,yDAAa;AACrF;AACA;AACA;AACA;AACA,eAAe,yDAAa,4BAA4B,yDAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B,YAAY,yDAAa;AACzB,YAAY,yDAAa,gCAAgC,yDAAa;AACtE;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAS,SAAS,+DAAS;AACxD;AACA;AACA,8CAA8C,yDAAa;AAC3D;AACA;AACA,8CAA8C,yDAAa;AAC3D;AACA;AACA,8CAA8C,yDAAa;AAC3D;AACA;AACA,uBAAuB,+DAAS,SAAS,+DAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA,eAAe,+DAAS;AACxB;AACA;AACA;AACA,iBAAiB,+DAAS;AAC1B,iBAAiB,+DAAS;AAC1B,2BAA2B,uDAAK;AAChC;AACA,iBAAiB,+DAAS;AAC1B,iBAAiB,+DAAS;AAC1B,2BAA2B,uDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B,YAAY,yDAAa;AACzB,YAAY,yDAAa;AACzB,YAAY,yDAAa;AACzB;AACA;AACA,gBAAgB,yDAAa;AAC7B,YAAY,yDAAa;AACzB,YAAY,yDAAa;AACzB,YAAY,yDAAa;AACzB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7LsD;AAC6B;AAChC;AAC2B;AACd;AACA;AACA;AAChB;AACJ;AACqC;AACvB;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0FAA8B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,qDAAW;AACzE;AACA;AACA;AACA,uBAAuB;AACvB;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,yDAAa;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,8BAA8B,oEAAkB;AAChD;AACA;AACA;AACA,gBAAgB,iDAAK;AACrB;AACA;AACA;AACA,gCAAgC,yDAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yDAAa;AAC1B;AACA;AACA;AACA,yBAAyB,sFAAsB;AAC/C,QAAQ,wEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAe;AAC3B;AACA;AACA;AACA;AACA,eAAe,oEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAkB;AACjD;AACA;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAa;AAC3B;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB,+BAA+B,oEAAkB;AACjD;AACA;AACA;AACA,uBAAuB,yDAAa,kCAAkC,yDAAa;AACnF;AACA;AACA;AACA,kBAAkB,yDAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAkB,mCAAmC,yDAAa;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAK;AACjB;AACA;AACA;AACA,2BAA2B,yDAAa;AACxC,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA,0BAA0B,oEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAK,uDAAuD,iDAAK;AAC7E;AACA;AACA;AACA;AACA,8BAA8B,sFAAsB;AACpD;AACA;AACA,QAAQ,wEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qDAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC,oBAAoB,qDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oEAAkB;AACnD,sCAAsC,oEAAkB;AACxD,cAAc,iDAAK,gBAAgB,iDAAK;AACxC,cAAc,iDAAK,gBAAgB,iDAAK;AACxC,YAAY,iDAAK;AACjB;AACA;AACA;AACA,YAAY,yDAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAa;AACzB,gCAAgC,uDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAa;AAC3C,2BAA2B,oEAAkB;AAC7C;AACA,8BAA8B,yDAAa;AAC3C,2BAA2B,oEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAa;AAC7C,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAa;AAC/B;AACA,aAAa,oEAAkB;AAC/B;AACA;AACA,kBAAkB,yDAAa;AAC/B;AACA;AACA;AACA,+FAA+F,yDAAa;AAC5G;AACA,8CAA8C,uBAAuB,gBAAgB,oEAAkB;AACvG,kCAAkC,yDAAa;AAC/C;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC,wBAAwB,yDAAa;AACrC,6EAA6E,yDAAa;AAC1F;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC,wBAAwB,yDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC,eAAe;AACf,+BAA+B,oEAAkB;AACjD;AACA,sCAAsC,yDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oEAAkB;AAC7C,yBAAyB,oEAAkB;AAC3C,qBAAqB;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAAkB,iEAAiE,yDAAa;AACpI,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,qDAAW,oBAAoB,qDAAW;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,qDAAW,oBAAoB,qDAAW;AACxH,qEAAqE;AACrE;AACA,iFAAiF,qDAAW,oBAAoB,qDAAW;AAC3H;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAkB;AACjD;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mCAAmC,oEAAkB,sCAAsC,yDAAa;AACxG;AACA;AACA;AACA,+CAA+C,oEAAkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,wBAAwB,yDAAa;AACrC;AACA;AACA;AACA;AACA,2BAA2B,oEAAkB;AAC7C;AACA;AACA;AACA,gBAAgB,iDAAK;AACrB;AACA;AACA,+BAA+B,oEAAkB;AACjD;AACA;AACA,sBAAsB,yDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yDAAa;AACpE,oDAAoD,qDAAW;AAC/D;AACA,uDAAuD,yDAAa;AACpE,oDAAoD,qDAAW;AAC/D;AACA;AACA;AACA;AACA,4EAA4E,oEAAkB;AAC9F;AACA;AACA,iCAAiC,oEAAkB,gCAAgC,yDAAa;AAChG;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAY,0BAA0B,yEAAqB;AACvE;AACA;AACA,+CAA+C,qDAAW;AAC1D;AACA;AACA,eAAe,yDAAa,qDAAqD,yDAAa;AAC9F;AACA;AACA,eAAe,gEAAM,UAAU,IAAI,EAAE;AACrC;AACA;AACA;;;;;;;;;;;;;;ACxkBkE;AACR;AACnD;AACP;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uEAAa,mEAAmE,+DAAS;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACkD;AACQ;AACM;AACQ;AACV;AACpB;AAC4B;AACV;AACZ;AAC+C;AACrC;AACV;AACV;AACQ;AACM;AACJ;AACY;AACZ;AACI;AACJ;AACU;AACgB;AACR;AAClE;AACO;AACP;AACA;AACA,gCAAgC,wDAAY;AAC5C;AACA;AACA;AACA;AACA,mDAAmD,+EAAwB;AAC3E;AACA,oCAAoC,0DAAa;AACjD,qCAAqC,0DAAa;AAClD,6BAA6B,0DAAa;AAC1C,8BAA8B,mDAAU;AACxC,0CAA0C,8DAAe,CAAC,0DAAa;AACvE,wCAAwC,8DAAe,CAAC,0DAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAe;AACvC,2CAA2C,oFAA2B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA,4CAA4C;AAC5C;AACA,kCAAkC,0DAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gDAAQ;AAC9C;AACA,8BAA8B,uDAAK;AACnC,8BAA8B,uDAAK;AACnC,uBAAuB,gDAAQ;AAC/B;AACA;AACA,0BAA0B,uDAAK;AAC/B,0BAA0B,uDAAK;AAC/B,mBAAmB,gDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,kCAAkC,0DAAa;AAC/C;AACA,0BAA0B,uDAAK;AAC/B,0BAA0B,uDAAK;AAC/B,mBAAmB,gDAAQ;AAC3B;AACA;AACA,0BAA0B,uDAAK;AAC/B,0BAA0B,uDAAK;AAC/B,mBAAmB,gDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAmB;AAC/C,iCAAiC,yDAAa;AAC9C;AACA;AACA;AACA;AACA,wCAAwC,8DAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uEAAoB;AACnE,+EAA+E,EAAE;AACjF;AACA;AACA,wEAAwE,GAAG;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAS;AAC/B,sBAAsB,+DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAAS;AACvC;AACA;AACA;AACA,+BAA+B;AAC/B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,GAAG,iBAAiB,EAAE;AAClG,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,+EAA+E,GAAG;AAClF;AACA;AACA;AACA;AACA;AACA,8EAA8E,GAAG;AACjF;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAkB;AACvC;AACA;AACA,oFAAoF,GAAG,IAAI,EAAE;AAC7F,mDAAmD,EAAE;AACrD,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,GAAG,mCAAmC;AACzG;AACA;AACA,mEAAmE,GAAG,mCAAmC;AACzG;AACA;AACA;AACA,+DAA+D,GAAG,qCAAqC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAAkB;AAC1D;AACA;AACA,wCAAwC,qEAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAU;AACxC,0CAA0C,8DAAe,CAAC,0DAAa;AACvE,wCAAwC,8DAAe,CAAC,0DAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAe;AAC9C;AACA;AACA,oCAAoC,iEAAkB;AACtD;AACA;AACA,oCAAoC,kEAAmB;AACvD;AACA;AACA,oCAAoC,+DAAgB;AACpD;AACA;AACA,oCAAoC,oEAAkB;AACtD;AACA;AACA,oCAAoC,qEAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,8DAAe;AACzE,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAgB,KAAK,oEAAkB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,+DAAe,KAAK,oEAAkB;AAClG;AACA,cAAc,wEAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAe;AAC3C,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAkB;AACtD;AACA;AACA,+CAA+C;AAC/C;AACA,6BAA6B,gEAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+DAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAmB;AAC3D;AACA;AACA,wCAAwC,+DAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,qCAAqC;AAC3G;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAa;AAC5B;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;;;;;;;;;;;;;;AC9zBkE;AACA;AAC3D,0CAA0C,0EAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAa;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChB8D;AACvD,mCAAmC,sEAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AACqE;AACJ;AACjE;AACO,uBAAuB,sEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCiE;AAC1D,qCAAqC,sEAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXiE;AAC1D,oCAAoC,sEAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACyC;AAC4B;AACR;AACL;AACW;AAC7B;AACM;AACN;AAC/B;AACP;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,uCAAuC,wEAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qDAAW;AACtD,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAa;AACjC;AACA,iBAAiB,+DAAS;AAC1B,iBAAiB,+DAAS;AAC1B,2BAA2B,+CAAQ;AACnC,iBAAiB,+DAAS;AAC1B,iBAAiB,+DAAS;AAC1B,8BAA8B,+CAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,+CAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA,4FAA4F,uEAAa;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAc;AACjC;AACA;AACA;AACA;AACA,kFAAkF,uEAAa;AAC/F,8EAA8E,uEAAa;AAC3F;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9MA;AACqD;AACgB;AACrE,WAAW,YAAY,8BAA8B;AACQ;AACQ;AAChB;AACG;AACqB;AACF;AACI;AACF;AACV;AACA;AACD;AACF;AACN;AACK;AACxD,8BAA8B,yEAAe;AACpD;AACA;AACA;AACA,6BAA6B,uEAAa;AAC1C,iCAAiC,uEAAa;AAC9C;AACA,yCAAyC,+DAAS;AAClD,sCAAsC,uDAAM;AAC5C,yBAAyB,uEAAa;AACtC;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAW;AAC7C;AACA;AACA;AACA;AACA,sCAAsC,0EAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAS;AAC3C,mEAAmE,uEAAa;AAChF,mEAAmE,uEAAa;AAChF,mEAAmE,uEAAa;AAChF,mEAAmE,uEAAa;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kEAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK;AACpB;AACA;AACA,eAAe,uDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oEAAkB;AACpE;AACA;AACA;AACA;AACA;AACA,uGAAuG,uEAAa;AACpH;AACA,2DAA2D,uEAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gFAAe;AAClD;AACA;AACA;AACA,uCAAuC,kFAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA,sCAAsC,kFAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oFAAiB;AACtD,kCAAkC,kFAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAa;AAClC,qCAAqC,oFAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA,sCAAsC,gFAAe;AACrD;AACA;AACA;AACA;AACA,oCAAoC,kFAAgB;AACpD,kCAAkC,gFAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAa;AAClC,oCAAoC,kFAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,uEAAa;AACpF;AACA;AACA,mBAAmB,4EAAsB;AACzC;AACA;AACA,mBAAmB,0EAAqB;AACxC;AACA;AACA,eAAe,8DAAc;AAC7B;AACA;AACA,wCAAwC,uEAAa;AACrD;;;;;;;;;;;;AClZA,WAAW,eAAe;AAC1B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpCA;AACqD;AACgB;AAC4B;AAC5C;AACiB;AAC/D;AACP;AACA;AACA;AACA;AACA,wBAAwB,uDAAM,WAAW,8DAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,4CAA4C;AACvH,8BAA8B,uDAAK;AACnC;AACA;AACA;AACA;AACA;AACA,2EAA2E,2CAA2C;AACtH,8BAA8B,uDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uEAAa;AAChE,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAa;AAC7C,sBAAsB,uEAAa;AACnC;AACA,yCAAyC,uEAAa;AACtD,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mGAA8B,CAAC,0DAAc;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtHqE;AACR;AACF;AAC3D;AACO,mCAAmC,gEAAW;AACrD;AACA;AACA;AACA,gCAAgC,+DAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA,qBAAqB,+DAAS;AAC9B,0BAA0B,+DAAS;AACnC;AACA,qBAAqB,+DAAS;AAC9B,0BAA0B,+DAAS;AACnC;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAS;AAClD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GqD;AACQ;AAC4C;AACpC;AACD;AACL;AACF;AACQ;AACJ;AACN;AACL;AACM;AACR;AACU;AAClB;AACU;AACyB;AACgC;AAC/G;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,iCAAiC,qGAAgC;AACjE;AACA,4BAA4B,oFAAe;AAC3C;AACA;AACA;AACA,oCAAoC,qGAAgC,sBAAsB,oFAAe;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK,iDAAiD,+DAAa,WAAW,kFAAe,QAAQ,kFAAe;AACnI;AACA;AACA;AACA,QAAQ,sDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2CAA2C;AACtF;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,uEAAa,+DAA+D;AACnI;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB,uEAAa,+DAA+D;AACpI;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2GAA2B;AACrD,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAK,iBAAiB,uDAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAS,aAAa,uDAAK,mBAAmB,uDAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+DAAS;AACjD,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB,+DAAS;AAChC,kBAAkB,mEAAW;AAC7B,kBAAkB,mEAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAS;AAC1B,iBAAiB,+DAAS;AAC1B,uBAAuB,6DAAY;AACnC;AACA;AACA,uBAAuB,6DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAS;AACtC;AACA;AACA;AACA,oCAAoC,8DAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,0DAA0D,+DAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,+DAAS;AACpE;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAa;AACzC;AACA;AACA;AACA;AACA,wEAAwE,wEAAoB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAS,iBAAiB,+DAAS;AACvD,8BAA8B,uDAAK;AACnC;AACA;AACA,8BAA8B,uDAAK;AACnC;AACA;AACA;AACA,oBAAoB,+DAAS,iBAAiB,+DAAS;AACvD,mBAAmB,6DAAY;AAC/B;AACA,eAAe,6DAAY;AAC3B;AACA;AACA,oBAAoB,uEAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAS,iBAAiB,+DAAS;AACvD,8BAA8B,uDAAK;AACnC;AACA;AACA,8BAA8B,uDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA,wBAAwB,uEAAa;AACrC,qCAAqC,uEAAa,yCAAyC,+DAAS;AACpG,qBAAqB,uDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uDAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAS;AAClC,yBAAyB,+DAAS;AAClC,yBAAyB,+DAAS;AAClC;AACA;AACA;AACA;AACA,kCAAkC,6DAAQ;AAC1C;AACA;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C,kBAAkB,iEAAU,uDAAuD,mEAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC91B6D;AACjB;AAC5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qDAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAa;AACpC,uCAAuC,qDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAW;AACzC,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrEA;AACA;AACqE;AACf;AACtD;AACO;AACP;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,+BAA+B,uEAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxDA;AACA;AACmD;AACP;AACrC;AACP;AACA,yCAAyC,qDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qBAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrIA;AACA;AACA;AACqD;AACQ;AACjB;AACgB;AAClB;AACY;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB;AACA,wBAAwB,mBAAmB;AAC3C,uBAAuB,uDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C,oBAAoB,4DAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAS;AAC/C,sCAAsC,+DAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C,oBAAoB,4DAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAW;AACvC;AACA,wBAAwB,gBAAgB;AACxC,iCAAiC,qDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxKO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjB4G;AAC3C;AACX;AACR;AACvC;AACP;AACA,2BAA2B,mEAAW;AACtC;AACA,wCAAwC,mEAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAY,gBAAgB,uDAAY,gBAAgB,uDAAY,gBAAgB,uDAAY;AAC1H;AACA,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAY;AAClC,2BAA2B,iDAAK,yCAAyC,iDAAK;AAC9E;AACA;AACA;AACA,2CAA2C,uDAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAW,iDAAiD,uDAAW;AACvH;AACA;AACA,2FAA2F,iDAAK;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAa,qCAAqC,yDAAa;AAC3E,YAAY,yDAAa,qCAAqC,yDAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yDAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iDAAK,iBAAiB,iDAAK;AACzE;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C,+BAA+B,uDAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,wBAAwB,uDAAY;AACpC;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1KkE;AACA;AACK;AACf;AACE;AACuB;AACT;AACjE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAa;AACpC,yBAAyB,mEAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAe;AAChD,kCAAkC,gEAAgB;AAClD;AACA,8CAA8C;AAC9C;AACA,sCAAsC,gEAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yFAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAQ,qBAAqB,uDAAK,gBAAgB,uDAAK;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B,aAAa,uEAAa;AAC1B;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAa;AACzC;AACA,4BAA4B,uEAAa;AACzC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAK;AAC7B;AACA,UAAU;AACV;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAa;AACrC,gDAAgD,YAAY;AAC5D,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK,wFAAwF,qEAAmB;AAC5H;AACA;AACA;AACA;AACA,YAAY,uDAAK,0FAA0F,qEAAmB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yFAA6B,gCAAgC,uEAAa;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5LyC;AACzC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxFgC;AACuB;AACJ;AACwB;AAC5B;AACA;AAC+C;AAC9C;AACH;AACkB;AACA;AACA;AAC4B;AAC/B;AACyE;AAChF;AACC;AACf;AAC6C;AAChB;AACJ;AACyC;AAChE;AACY;AACN;AACM;AAC2B;AAClC;AACkC;AACzB;AACH;AACU;AACI;AACwB;AACjC;AACF;AACyB;AACxB;AACX;AACG;AAChD;AACO,2BAA2B,uDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8FAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,qEAAoB;AAC5F,0BAA0B,wDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8FAAyB;AAClD;AACA,QAAQ,6FAAmB;AAC3B,gBAAgB,iDAAK;AACrB;AACA;AACA,sCAAsC,yCAAS;AAC/C;AACA;AACA;AACA,wBAAwB,iDAAK;AAC7B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,0DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kEAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAS,oBAAoB,sEAAmB;AAC/E;AACA;AACA;AACA;AACA,gDAAgD,oGAA4B;AAC5E;AACA;AACA;AACA;AACA,oCAAoC,sEAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAa;AAC1C;AACA;AACA;AACA;AACA;AACA,sCAAsC,8EAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,wEAAY;AACnG;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,uCAAuC,mEAAY;AACnD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAU;AAClC;AACA;AACA,yBAAyB,kEAAU,8DAA8D,uDAAW;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA,oBAAoB,sCAAM,QAAQ,qEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA,oBAAoB,qEAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,wBAAwB,uEAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0FAA6B;AACzD;AACA;AACA;AACA;AACA,6EAA6E,yDAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAgB;AACvC;AACA;AACA;AACA,wBAAwB,8DAAe;AACvC;AACA;AACA;AACA,6CAA6C,8DAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oGAA4B,4BAA4B,oGAA4B;AAC3H;AACA;AACA;AACA;AACA,2BAA2B,0EAAqB;AAChD,mCAAmC,iEAAa;AAChD,wCAAwC,0FAA6B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,yDAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAS;AAClC,0BAA0B,oDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gEAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mGAA2B;AAC/C;AACA,iCAAiC,4EAAc;AAC/C,iCAAiC,wEAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qGAAgC,iEAAiE,oFAAe;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qGAAgC,uCAAuC,oFAAe;AACrG;AACA;AACA;AACA,0CAA0C,0FAA6B,6DAA6D,wEAAY;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oGAA4B;AACrE,YAAY,+DAAQ;AACpB;AACA,yCAAyC,oGAA4B;AACrE,YAAY,+DAAQ;AACpB;AACA,oBAAoB;AACpB,aAAa,uDAAK;AAClB;AACA;AACA;AACA,yBAAyB,2DAAQ;AACjC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,YAAY,yEAAe;AAC3B;AACA,QAAQ,8DAAS;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qGAAgC,0BAA0B,oFAAe;AACxF;AACA;AACA;AACA,eAAe,qGAAgC,+BAA+B,oFAAe;AAC7F;AACA;AACA,mEAAmE,qDAAQ,iCAAiC,qDAAQ;AACpH;AACA,yBAAyB,mEAAO,qDAAqD,qDAAS;AAC9F,4BAA4B,yEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kEAAU,sFAAsF,uDAAW;AACtK;AACA;AACA,uBAAuB,kEAAU;AACjC;AACA,2BAA2B,kEAAU,mCAAmC,wDAAY;AACpF;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAU;AACjC;AACA;AACA;AACA;AACA,uBAAuB,kEAAU;AACjC;AACA;AACA;AACA;AACA;AACA,6CAA6C,oGAA4B,+BAA+B,sEAAmB;AAC3H;AACA;AACA,6CAA6C,oGAA4B,+BAA+B,sEAAmB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAe;AAC7C,0BAA0B,yEAAW;AACrC;AACA;AACA;AACA,0BAA0B,yEAAe;AACzC,sBAAsB,yEAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAK;AACzB,qBAAqB,yDAAa;AAClC;AACA,0CAA0C,qDAAS;AACnD;AACA,qBAAqB,yDAAa;AAClC,0CAA0C,qDAAS;AACnD;AACA;AACA,wBAAwB,wEAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,gBAAgB,uDAAK,iCAAiC,uDAAK;AAC3D;AACA;AACA;AACA,yBAAyB,uDAAK;AAC9B,gBAAgB,4DAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yCAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mFAAoB,4DAA4D,uDAAK;AACzG;AACA;AACA;AACA,oBAAoB,mFAAoB,4DAA4D,uDAAK;AACzG;AACA;AACA;AACA;AACO;AACP,gBAAgB,6FAA4C;AAC5D;AACA;AACA;AACA;;;;;;;;;;;;;;AC1jCgD;AACmB;AAC5D;AACP;AACA,4BAA4B,oCAAK;AACjC,+BAA+B,qEAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAK;AACpB;AACA;AACA;AACA;AACA;AACA,0DAA0D,gDAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAa;AACpC;AACA;AACA;AACA;AACA,4BAA4B,gDAAa;AACzC;AACA;AACA;AACA,wDAAwD,gDAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAK;AACjC;AACA;AACA,YAAY,oCAAK;AACjB,YAAY,oCAAK;AACjB;AACA;AACA,YAAY,oCAAK;AACjB,YAAY,oCAAK;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7IqD;AACoD;AAChD;AACH;AACU;AACtB;AACA;AACkB;AACF;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2DAAO;AAC/C;AACA;AACA;AACA;AACA,mCAAmC,mDAAU;AAC7C;AACA,oCAAoC,mDAAU;AAC9C;AACA,wBAAwB,iDAAK,4EAA4E,yDAAa;AACtH;AACA,wBAAwB,sEAAgB;AACxC,wBAAwB,sEAAgB;AACxC;AACA,6BAA6B,iDAAK,4EAA4E,yDAAa;AAC3H;AACA,wBAAwB,sEAAgB;AACxC,wBAAwB,sEAAgB;AACxC;AACA;AACA,wBAAwB,sEAAgB;AACxC,wBAAwB,sEAAgB;AACxC;AACA;AACA,uCAAuC,mDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yEAAwB;AAC/C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wBAAwB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mEAAkB;AACxE,sDAAsD,mEAAkB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAO;AACjD;AACA;AACA;AACA,uBAAuB,uDAAK;AAC5B;AACA;AACA,8BAA8B,iDAAK,4BAA4B,uDAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,yDAAa;AAC5D,6CAA6C,yDAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2HAA2H;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB,mBAAmB,uDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iFAAiF;AAC/G;AACA;;;;;;;;;;;;;;ACrhBA;AACkF;AAClC;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAa;AACpC,uIAAuI,iDAAK;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,iDAAK;AACvG,uDAAuD,iDAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,gDAAgD,uDAAW;AAC3D;AACA;AACA;AACA,4EAA4E,iDAAK;AACjF;AACA;AACA;AACA,4CAA4C,uDAAW;AACvD;AACA;AACA;AACA,4DAA4D,iDAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB,kDAAkD,uDAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAW;AAC9B;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iDAAK,iBAAiB,uDAAW;AAChG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9SA;AACA;AACoC;AAC6D;AACrC;AACI;AAC0E;AACxF;AACG;AAC0C;AAC7C;AACoB;AAC5B;AACoG;AAChF;AACH;AACR;AAC5C,2BAA2B,uDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAU;AAClB;AACA;AACA,eAAe,qGAA4B,uBAAuB,iDAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAc;AACjD,QAAQ,+EAAwB;AAChC,YAAY,oDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAK,8BAA8B,uDAAW;AACzE;AACA;AACA;AACA;AACA,2BAA2B,iDAAK,8BAA8B,uDAAW;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mGAA4B;AACpF;AACA;AACA;AACA;AACA;AACA,wDAAwD,mGAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAmB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6EAA6E;AAC1I,sBAAsB,oJAA0D;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6EAA6E;AAC1I,sBAAsB,+IAAwD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,6BAA6B,uCAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/NO;AACP;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;;;;;;;;;;;;;;;;ACNiC;AACkD;AAClB;AACrB;AAC5C;AACO;AACP;AACA;AACA,YAAY,sEAAG;AACf;AACA;AACA,6BAA6B,qDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAW;AACtC;AACA;AACA;AACA;AACA,2BAA2B,uDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAG;AACf;AACA;AACA;AACA,6BAA6B,qDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,yBAAyB,oCAAK;AAC9B,uBAAuB,yDAAa;AACpC,uBAAuB,yDAAa;AACpC;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA,8BAA8B,yDAAa,YAAY,yDAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAG;AACf;AACA;AACA,6BAA6B,qDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpMiC;AACsB;AACY;AAC5D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAK;AACrB,gBAAgB,qEAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAK;AACrB,gBAAgB,qEAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAK,sIAAsI,yDAAa;AACpK;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oCAAK;AAC1B,mBAAmB,yDAAa;AAChC;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxIiC;AACyB;AACR;AAClD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAK;AACjB;AACA;AACA;AACA,qBAAqB,mEAAkB;AACvC;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7IiC;AACwD;AAC5B;AACE;AACN;AACH;AACD;AACW;AACN;AACU;AACG;AACvE;AACA,WAAW,QAAQ;AACnB;AACO,yBAAyB,uDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B;AACA;AACA;AACA,iCAAiC,6EAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yEAAqB;AAChD;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA,sBAAsB,iDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAW;AACpC;AACA;AACA;AACA,qBAAqB,uDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wBAAwB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAU,iCAAiC,wDAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iEAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAU,wCAAwC,uDAAW;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAU,iCAAiC,uDAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iEAAU,oCAAoC,wDAAY;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iEAAU;AACvC;AACA;AACA;AACA,gCAAgC,iEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAa;AACvC;AACA,8BAA8B,yDAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAK;AACxB,wBAAwB,oCAAK;AAC7B,wBAAwB,oCAAK;AAC7B;AACA;AACA;AACA,0BAA0B,iDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB,oCAAK;AAC1B,mBAAmB,uDAAW;AAC9B;AACA;AACA,uBAAuB,4DAAM;AAC7B,4BAA4B,4DAAM;AAClC;AACA,mBAAmB,uDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAO,qBAAqB,oCAAK,iBAAiB,oCAAK;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAO,qBAAqB,oCAAK,kBAAkB,oCAAK;AAC3E;AACA;AACA;AACA;AACA,mBAAmB,oCAAK;AACxB;AACA;AACA;AACA,oBAAoB,4DAAM;AAC1B,eAAe,+DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8EAAiB;AACnC;AACA;AACA;AACA;AACA,YAAY,oCAAK;AACjB,YAAY,oCAAK;AACjB;AACA;AACA;AACA;AACA,gCAAgC,yDAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAK;AAChC,2BAA2B,oCAAK;AAChC;AACA;AACA,0BAA0B,+DAAS;AACnC;AACA;AACA;AACA;AACA,2BAA2B,oCAAK;AAChC;AACA;AACA;AACA,0BAA0B,+DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,UAAU;AACV;AACA;AACA,mCAAmC,oCAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACndyC;AAC4B;AAClB;AACA;AACS;AACA;AACpB;AACjC;AACP;AACA;AACA;AACA;AACA;AACA,sCAAsC,qDAAQ;AAC9C,qCAAqC,qDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAwB;AAClD,0BAA0B,yEAAwB;AAClD;AACA;AACA;AACA;AACA,0BAA0B,yEAAwB;AAClD,0BAA0B,yEAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAS;AACjB;AACA,QAAQ,iDAAS;AACjB;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAQ;AACvC,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjX6D;AACL;AACG;AACC;AACV;AAClD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAAS;AACvC;AACA;AACA,4BAA4B,sCAAsC;AAClE;AACA;AACA;AACA;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAS;AAChC,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAY;AACvC;AACA;AACA,iDAAiD,gBAAgB;AACjE,8BAA8B,+DAAS;AACvC;AACA;AACA,kDAAkD,2DAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAc;AAC7B;AACA;AACA;AACA;AACA,mBAAmB,8DAAc;AACjC;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAwB;AACvC;AACA;AACA;;;;;;;;;;;;;;;;ACjJiC;AACsB;AAC0C;AACzC;AACxD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mGAA8B,CAAC,0DAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAa,8BAA8B,yDAAa;AAC9E;AACA;AACA,oBAAoB,oCAAK;AACzB;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjK+E;AACd;AACP;AAC1D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAkB;AACnD;AACA;AACA;AACA;AACA,wCAAwC,mEAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sEAAG,mCAAmC,iFAAe,QAAQ,iFAAe;AAC3F;AACA;AACA;;;;;;;;;;;;;;;AChDA;AACiC;AACuC;AACf;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK;AAC5B,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAK;AACxB,eAAe,oDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7KA;AACA;AACA;AACA;AACA;AACyC;AACR;AAC6B;AACX;AACA;AACsC;AACnC;AACN;AACR;AACQ;AACZ;AACgB;AAC2B;AACF;AACrB;AAClB;AACtC;AACO;AACP;AACA,8CAA8C,qDAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kGAA2B;AAClD;AACA;AACA;AACA;AACA,sCAAsC,yDAAa;AACnD,sCAAsC,yDAAa;AACnD,oCAAoC,+DAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAK;AAC/B,yBAAyB,qDAAQ;AACjC,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA,gBAAgB,qEAAc;AAC9B,gBAAgB,qEAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAK,uDAAuD,oCAAK;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAe;AAChC;AACA;AACA;AACA;AACA,sCAAsC,gDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA,4CAA4C,yDAAa;AACzD;AACA;AACA;AACA;AACA;AACA,yDAAyD,6BAA6B;AACtF;AACA;AACA,yBAAyB,sEAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAK,+CAA+C,yDAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAK,+CAA+C,yDAAa;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6BAA6B;AACtF;AACA;AACA;AACA,4CAA4C,sEAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,kEAAiB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAK,mDAAmD,yDAAa;AACrF,YAAY,iDAAK,mDAAmD,yDAAa;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,oCAAK;AACrB;AACA,gBAAgB,oCAAK;AACrB;AACA;AACA,QAAQ,6DAAY;AACpB,YAAY,6DAAY;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAY;AACpB;AACA;AACA,QAAQ,6DAAY,YAAY,6DAAY;AAC5C;AACA,eAAe,sEAAqB,CAAC,oCAAK;AAC1C;AACA;AACA,YAAY,sEAAqB;AACjC;AACO;AACP,WAAW,sEAAqB;AAChC;AACA;;;;;;;;;;;;ACjZA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjB4C;AAC+B;AACA;AACd;AACQ;AACkB;AACO;AAC7B;AACT;AACL;AACQ;AACR;AACe;AACpB;AACvC;AACP;AACA,kCAAkC,sDAAQ;AAC1C,iDAAiD,sDAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAY,IAAI;AACxC;AACA;AACA,4BAA4B,+DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAAY;AAChD,mCAAmC,mEAAW;AAC9C;AACA,sBAAsB,wCAAS;AAC/B,kBAAkB,yDAAa;AAC/B;AACA;AACA,4BAA4B,6FAAyB,sBAAsB,wCAAS;AACpF,QAAQ,oGAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAc,CAAC,4DAAM,iBAAiB,4DAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAQ;AACvC,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA,gBAAgB,oCAAK,iEAAiE,qEAAmB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wCAAS;AAC9B,iBAAiB,yDAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iDAAK,yDAAyD,iDAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3OO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA,0BAA0B,cAAc,EAAE,cAAc,KAAK,cAAc,EAAE,cAAc;AACpF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC/BiG;AACtC;AACE;AACkD;AACzB;AACW;AACnC;AACE;AACC;AACd;AACP;AACF;AACJ;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,qEAAmB;AACtF;AACA;AACA,mEAAmE,qEAAmB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,6BAA6B,mGAA8B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,qEAAmB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAG;AACf;AACA;AACA,6BAA6B,sDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2DAA2D;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAmB;AAC/C;AACA,iHAAiH,qBAAqB;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mGAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA,0BAA0B,wDAAO,mBAAmB,wDAAO;AAC3D,0BAA0B,wDAAO,mBAAmB,wDAAO;AAC3D;AACA;AACA;AACA;AACA;AACA,6BAA6B,oGAAgC,gDAAgD,mFAAe;AAC5H,2BAA2B,oGAAgC,6BAA6B,mFAAe,IAAI,+DAAS;AACpH,QAAQ,4FAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAc;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3aO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5BA;AACiC;AACmE;AACrC;AAChB;AACG;AACR;AACc;AACR;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAc;AAChD,yBAAyB,iEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAW;AAC9B;AACA;AACA,8BAA8B,iDAAK;AACnC;AACA,YAAY,mDAAU;AACtB,gBAAgB,iEAAU;AAC1B,gBAAgB,iEAAU,iCAAiC,wDAAY;AACvE,gBAAgB,iEAAU,kCAAkC,wDAAY;AACxE,gBAAgB,iEAAU,kCAAkC,wDAAY;AACxE,4CAA4C,iEAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,qDAAS,uCAAuC,iDAAK,sDAAsD,yDAAa;AACnN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAK;AACjC;AACA,oBAAoB;AACpB;AACA;AACA,YAAY,mDAAU;AACtB,gBAAgB,iEAAU,mCAAmC,yDAAa;AAC1E,gBAAgB,iEAAU,kCAAkC,wDAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAK;AACjC;AACA;AACA,wBAAwB;AACxB;AACA,+BAA+B,EAMlB;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAK,SAAS,qDAAM,YAAY,qDAAM;AACrD;AACA;;;;;;;;;;;;;ACjUiC;AACjC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oCAAK;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVyC;AACR;AACyC;AACpB;AACO;AACQ;AAC0C;AACjB;AACnC;AACR;AACiJ;AAChI;AAClB;AACQ;AAClB;AACkB;AACpB;AACtC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oGAA2B;AACnC;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA,mCAAmC,qDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oGAAgC;AAC/C;AACA;AACA;AACA,4BAA4B,oCAAK;AACjC,sBAAsB,qDAAS;AAC/B,mBAAmB,mFAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oDAAQ;AAC7D;AACA;AACA;AACA;AACA,wBAAwB,mDAAK;AAC7B;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAY;AAChD;AACA;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E,oCAAoC,+DAAS;AAC7C,gBAAgB,wEAAiB;AACjC;AACA;AACA,mCAAmC,qDAAQ;AAC3C;AACA;AACA,gDAAgD,sEAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,uCAAuC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAS;AAC7B,kCAAkC,6EAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAS;AACnD;AACA;AACA,gBAAgB,4DAAc;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,4DAAc;AAClC;AACA;AACA;AACA;AACA,mEAAmE,oEAAa;AAChF,qBAAqB,oEAAkB;AACvC;AACA,oBAAoB,4DAAc;AAClC;AACA;AACA;AACA,mEAAmE,oEAAa;AAChF,iBAAiB,oEAAkB;AACnC;AACA,oBAAoB,4DAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAM;AACzB,mBAAmB,4DAAM;AACzB,mBAAmB,4DAAM;AACzB;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAA2B;AACvC,YAAY,kFAA2B;AACvC,YAAY,yEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAQ;AACvC;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAK;AAC3B;AACA,uBAAuB,4DAAM;AAC7B,uBAAuB,4DAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAM,6BAA6B,4DAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0EAAqB,mDAAmD,uDAAW;AACxH;AACA;AACA;AACA,kCAAkC,0EAAqB,mDAAmD,uDAAW;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,sEAAe;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAM;AAClB,YAAY,4DAAM;AAClB,YAAY,4DAAM;AAClB,YAAY,4DAAM;AAClB,YAAY,4DAAM;AAClB,gBAAgB,4DAAc;AAC9B;AACA;AACA;AACA,iDAAiD,4DAAM,8BAA8B,4DAAM,wBAAwB,4DAAM;AACzH,oBAAoB,4DAAc;AAClC;AACA;AACA;AACA,iDAAiD,4DAAM,8BAA8B,4DAAM,wBAAwB,4DAAM;AACzH,oBAAoB,4DAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAkB;AACzC;AACA,oBAAoB,4DAAc;AAClC;AACA,kBAAkB,4DAAM;AACxB,oBAAoB,4DAAc,aAAa,4DAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4DAAM,oBAAoB,4DAAM;AAClF,+BAA+B,4DAAM;AACrC;AACA;AACA;AACA;AACA,6BAA6B,4DAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,sEAAe;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAS;AACtC;AACA;AACA,YAAY,oEAAkB;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5pBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDsC;AACtC;AACO,6BAA6B,+CAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AACA;AAC0C;AACnC,+BAA+B,mDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBsC;AAC/B,2BAA2B,+CAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBsC;AAC/B,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLiC;AACkC;AACjB;AACJ;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2DAAc;AAC7D,+CAA+C,2DAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAK;AAChC;AACA,iBAAiB,qEAAmB;AACpC;AACA,iBAAiB,qEAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAK;AACjC,4BAA4B,qEAAmB;AAC/C;AACA;AACA,4BAA4B,qEAAmB;AAC/C;AACA;AACA;AACA,mCAAmC,uDAAY;AAC/C;AACA;AACA,4BAA4B,oCAAK;AACjC,4BAA4B,qEAAmB;AAC/C;AACA;AACA,4BAA4B,qEAAmB;AAC/C;AACA;AACA;AACA;AACA,mCAAmC,uDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAK,wEAAwE,qEAAmB;AAC5G;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1EiC;AACoB;AACF;AACgB;AACvB;AACrC,0BAA0B,uDAAS;AAC1C;AACA;AACA;AACA;AACA,yBAAyB,qDAAQ;AACjC,qCAAqC,wEAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAwC;AACpE;AACA,sCAAsC,oCAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,wEAAe;AAC3C,kCAAkC,oCAAK;AACvC,4BAA4B,wEAAe;AAC3C,kCAAkC,oCAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAW;AACnB;AACA;AACA;;;;;;;;;;;;;AC/FA;AAC0C;AACnC,oCAAoC,mDAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnB8C;AACvC,+BAA+B,uDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACb4C;AACrC,8BAA8B,qDAAW;AAChD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACiC;AACiD;AACf;AACE;AAChB;AACC;AACa;AACc;AACd;AACjB;AACpB;AACwB;AACR;AACE;AACM;AACU;AACV;AACF;AACc;AACV;AACF;AACV;AACrC,0BAA0B,wEAAe;AAChD;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAgB;AACpD,iCAAiC,uDAAM;AACvC,kCAAkC,uDAAM;AACxC;AACA;AACA;AACA,uBAAuB,sFAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY,oCAAK;AACjB;AACA;AACA;AACA;AACA,iBAAiB,oCAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAK;AACjB;AACA;AACA;AACA,YAAY,oCAAK;AACjB;AACA;AACA,YAAY,oCAAK;AACjB;AACA;AACA,kBAAkB,oCAAK;AACvB,YAAY,oCAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA;AACA,6BAA6B,4EAAsB;AACnD;AACA;AACA;AACA,iCAAiC,0EAAqB;AACtD;AACA;AACA;AACA,qCAAqC,gEAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0DAAa;AAC5D;AACA,gBAAgB,oCAAK;AACrB,gBAAgB,qEAAmB;AACnC;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAK;AACvB;AACA,2BAA2B,gEAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wDAAY;AAC3D;AACA,gBAAgB,oCAAK;AACrB,gBAAgB,qEAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oCAAK,0EAA0E,qEAAmB;AAC3I;AACA;AACA,kBAAkB,oCAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,oCAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAe;AAClD;AACA;AACA;AACA;AACA,uCAAuC,gEAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,yDAAa;AACvF;AACA;AACA,kFAAkF,yDAAa;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAa;AAC1D,qCAAqC,kEAAiB;AACtD;AACA,qDAAqD,yDAAa;AAClE,oCAAoC,gEAAgB;AACpD;AACA,mCAAmC,yDAAa;AAChD;AACA;AACA,aAAa,oCAAK;AAClB;AACA;AACA,gBAAgB,oCAAK;AACrB,iDAAiD,gEAAgB;AACjE;AACA;AACA;AACA,iBAAiB,oCAAK;AACtB;AACA;AACA;AACA,iDAAiD,yDAAa;AAC9D;AACA,yCAAyC,kEAAiB;AAC1D;AACA,6CAA6C,gEAAgB;AAC7D;AACA;AACA;AACA,yCAAyC,gEAAgB;AACzD;AACA;AACA,yBAAyB,wCAAI;AAC7B,oCAAoC,2DAAc,4BAA4B,wDAAY;AAC1F;AACA,6BAA6B,0DAAa;AAC1C;AACA;AACA;AACA;AACA,sEAAsE,yDAAa;AACnF,qCAAqC,kEAAiB;AACtD;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAa;AAClD,qCAAqC,oCAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4EAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAY;AAC/C;AACA;AACA,6BAA6B,oCAAK;AAClC;AACA,kCAAkC,0EAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAK,wEAAwE,qEAAmB;AAC/G;AACA;AACA,eAAe,oCAAK,wEAAwE,qEAAmB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,oCAAK;AACjB;AACA,uCAAuC,wDAAY;AACnD;AACA,qCAAqC,oCAAK;AAC1C;AACA,0CAA0C,0EAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,yDAAa;AACvF;AACA;AACA;AACA,kFAAkF,yDAAa;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAa;AAC1D,oCAAoC,gEAAgB;AACpD;AACA;AACA,wBAAwB,yDAAa;AACrC,qCAAqC,kEAAiB;AACtD;AACA;AACA,wBAAwB,yDAAa;AACrC,aAAa,4DAAY,6EAA6E,yDAAa;AACnH;AACA,sDAAsD;AACtD;AACA,kBAAkB,oCAAK;AACvB;AACA;AACA,kCAAkC,8DAAe;AACjD;AACA;AACA,kBAAkB,oCAAK;AACvB;AACA;AACA,kCAAkC,8DAAe;AACjD;AACA;AACA,6BAA6B,wCAAI;AACjC,kCAAkC,2DAAc,+CAA+C,0DAAa;AAC5G;AACA,gCAAgC,wDAAY;AAC5C;AACA;AACA;AACA,qCAAqC,yDAAa;AAClD,wCAAwC,gEAAgB;AACxD;AACA;AACA;AACA,kCAAkC,8DAAe;AACjD,qCAAqC,yDAAa;AAClD;AACA;AACA;AACA,wCAAwC,gEAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,oCAAK;AACjB;AACA;AACA,uCAAuC,0DAAa;AACpD;AACA,oCAAoC,oCAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAI;AAC7B,4BAA4B,wDAAY;AACxC,6BAA6B,0DAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wDAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0DAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAK;AACvB;AACA,kCAAkC,0EAAqB;AACvD;AACA;AACA;AACA;AACA,kBAAkB,oCAAK;AACvB;AACA,kCAAkC,0EAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,GAAG,GAAG,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAK,uFAAuF,qEAAmB;AAC9H;AACA;AACA,eAAe,oCAAK,uFAAuF,qEAAmB;AAC9H;AACA;AACA;AACA;AACA;AACA,wFAAwF,yDAAa;AACrG,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACh+B4C;AACrC,gCAAgC,qDAAW;AAClD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACN2D;AACpD,2BAA2B,gEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnB0C;AAC1C;AACO,qCAAqC,mDAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtB8C;AACvC,gCAAgC,uDAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACb4C;AACrC,+BAA+B,qDAAW;AACjD;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNO;AACP;AACA;;;;;;;;;;;;;ACF0C;AACnC,0BAA0B,mDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACbyC;AACa;AACU;AACF;AAC9D,UAAU,gBAAgB;AAC1B,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAG;AAChC,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,iCAAiC;AACjC,iCAAiC;AACjC,kCAAkC;AAClC,6BAA6B;AAC7B,8BAA8B;AAC9B;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,sBAAsB,gDAAgD;AACtE;AACA,wBAAwB,oDAAQ;AAChC,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA,sDAAsD,aAAa;AACnE;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAK,6EAA6E,qEAAmB;AACrH,8BAA8B,mDAAmD;AACjF;AACA;AACA,8BAA8B,mDAAmD;AACjF;AACA;AACA;AACA;AACA,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpc8B;AACmC;AACD;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oCAAK;AACzB,qBAAqB,qEAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAK,mDAAmD,oCAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAa;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrCkE;AACD;AACM;AAChE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB,iBAAiB,qEAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uEAAa;AAC9D;AACA;AACA;AACA,uBAAuB,sEAAa;AACpC,eAAe,uEAAa,0CAA0C,uEAAa;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDsD;AACtD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAgB;AACvC;AACA,mBAAmB,+DAAgB;AACnC;AACA;AACA;AACA;AACA,uBAAuB,+DAAgB;AACvC;AACA,mBAAmB,+DAAgB;AACnC;AACA;AACA;;;;;;;;;;;;;AC7CsD;AAC/C;AACP;AACA,eAAe,gEAAM,UAAU,EAAE,EAAE,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AClC8B;AACkC;AACd;AACN;AACQ;AACF;AACZ;AACF;AAC4C;AACd;AAC3D,0DAA0D,uDAAS;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAM;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+CAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,yFAA6B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAK,yCAAyC,qEAAmB;AACjF,YAAY,oCAAK,kDAAkD,qEAAmB;AACtF,YAAY,oCAAK,kDAAkD,qEAAmB;AACtF;AACA;AACA;AACA,eAAe,2EAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAAO;AAC9B;AACA;AACA;AACA,uBAAuB,6CAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAQ;AACxC;AACA;AACA,qBAAqB;AACrB;AACA;AACA,0CAA0C,yFAA6B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzKA;AACkD;AACgB;AACY;AAC5B;AAC0B;AACd;AACN;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mFAAsB;AACpD,wCAAwC,uEAAoB;AAC5D,wCAAwC,uDAAM;AAC9C,yCAAyC,uDAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uEAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uDAAK;AACrE;AACA;AACA;AACA,iEAAiE,uDAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAiB;AACvD;AACA;AACA;AACA;AACA;AACA,8BAA8B,oFAAiB;AAC/C;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChIkD;AAClD,WAAW,eAAe;AACsC;AACzD;AACP;AACA;AACA;AACA;AACA,uBAAuB,uDAAK;AAC5B;AACA,iBAAiB,qEAAmB;AACpC;AACA;AACA,iBAAiB,qEAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AAC8B;AACsB;AACY;AACE;AACY;AAC5B;AACsB;AAC1C;AACoC;AACA;AAChB;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oCAAK;AACjD,4CAA4C,qEAAmB,qCAAqC,qEAAmB;AACvH;AACA;AACA,sCAAsC,uCAAI;AAC1C,sCAAsC,uCAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uCAAI;AAClC;AACA,kCAAkC,uCAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6HAA6H,oCAAK;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C;AACA;AACA,yBAAyB,2EAAsB;AAC/C,kCAAkC,mFAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4DAAc;AAClD,qCAAqC,4DAAc;AACnD,qFAAqF,2EAAsB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAK,yCAAyC,oCAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iFAAyB;AAC/D;AACA,mCAAmC,uDAAM;AACzC;AACA;AACA;AACA;AACA;AACA,kCAAkC,uCAAuC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAsC;AACrD,6CAA6C,uCAAI;AACjD;AACA;AACA,eAAe,oCAAK,oEAAoE,yDAAa;AACrG;AACA;AACA;;;;;;;;;;;;;;;;;ACnQ8D;AACS;AACf;AACJ;AACR;AACrC;AACP;AACA,2BAA2B,6DAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC,4BAA4B,aAAa;AACzC,0BAA0B,mEAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uCAAuC;AAC7E,gBAAgB,uDAAK,sEAAsE,qEAAmB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAK;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/J8D;AACvD,gCAAgC,sEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRsD;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,eAAe,EAAE,EAAE,EAAE;AAC1C;AACA;AACA;;;;;;;;;;;;;ACvCA;AACoD;AACpD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAa;AAChC;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,UAAU,EAAE,EAAE,EAAE;AACrC;AACA;AACA;;;;;;;;;;;;;;ACpDA;AAC8D;AACZ;AAClD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA,eAAe,uDAAK;AACpB;AACA;AACA;AACA;AACA,mBAAmB,uDAAK;AACxB;AACA,eAAe,uDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAK;AAClC,oBAAoB,uDAAK;AACzB;AACA,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAK;AAC9B,gBAAgB,uDAAK;AACrB;AACA,qBAAqB,uDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA,uBAAuB,mEAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAK;AACrC,oCAAoC,uDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAK;AACrC,oCAAoC,uDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK;AACpB,eAAe,uDAAK;AACpB,eAAe,uDAAK;AACpB,eAAe,uDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACniBkD;AAC3C,qCAAqC,2DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvGoD;AACE;AACtD,WAAW,QAAQ;AACnB;AACO;AACP;AACA,eAAe,uDAAK,iDAAiD,uDAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAM,UAAU,EAAE,GAAG,GAAG,EAAE,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAK;AAC5B,uBAAuB,uDAAK;AAC5B;AACA;;;;;;;;;;;;;;;;ACxCuE;AACvB;AACE;AACI;AAC/C;AACP;AACA;AACA;AACA,wCAAwC,+DAAgB;AACxD,oCAAoC,qDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,oCAAoC,uDAAK;AACzC,oCAAoC,qEAAmB;AACvD,0CAA0C,qEAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,2DAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvQO;AACP;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;;;;;;;;;;;;;ACLkD;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7FwD;AACjD,yBAAyB,iEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACO;AACP;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzFwC;AACgB;AACjD,4BAA4B,iDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAiB;AACnC;AACA;AACA,sBAAsB,iEAAiB;AACvC;AACA;AACA;AACA,gCAAgC,iEAAiB;AACjD;AACA;AACA;;;;;;;;;;;;AClBA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNyC;AAClC;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA,mCAAmC;AACnC;AACA,kCAAkC;AAClC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7JkC;AACF;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC,mBAAmB,2CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yCAAK;AACxC;AACA;AACA;AACA,mCAAmC,yCAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3DA;AAC6D;AACX;AACQ;AAC1D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1HO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACRyC;AACA;AACzC,WAAW,QAAQ;AACW;AACA;AACoB;AAClD;AACO,oBAAoB,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;AC9ZkC;AAC3B,oBAAoB,2CAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXkC;AAClC;AACO,mBAAmB,2CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDgC;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnGA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBoC;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA,2BAA2B,6CAAO;AAClC;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClGoC;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzD+C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtD+C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5E+D;AAC/D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAa,gCAAgC,uEAAa;AACjF;AACA;AACA;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACb+D;AACxD;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA,YAAY,uEAAa,8BAA8B,uEAAa;AACpE;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,uEAAa;AAC3B;AACA;AACA,aAAa,uEAAa;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CO;AACP,oBAAoB,cAAc;AAClC;AACA;AACA;;;;;;;;;;;;;;ACJ2B;AAC4B;AAChD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAK;AAC3B;AACA,uBAAuB,oCAAK;AAC5B,mBAAmB,+DAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChEA;AACyC;AACzC;AACO;AACP;AACA,wBAAwB,mDAAM;AAC9B;AACA;AACA;AACO;AACP,oBAAoB,mDAAM;AAC1B;AACO;AACP;AACA,wBAAwB,mDAAM;AAC9B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBuD;AACjB;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,+CAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,+DAAS;AACxC;AACO;AACP;AACA;AACA;AACA;AACO;AACP,oCAAoC,+DAAS;AAC7C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvHO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;;;;;;;;;;;;ACtBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC55BO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;;;;;;;;;;;;;;ACPgD;AACA;AACzC,0BAA0B,yDAAa;AAC9C;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA,yBAAyB,yDAAa;AACtC;AACA;AACA;AACA,QAAQ,yDAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxB+J;AAC/G;AACJ;AACI;AACJ;AACJ;AACxC;AACA;AACA;AACA;AACA;AACO,2BAA2B,qDAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA,gCAAgC,yDAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAI;AACvB,KAAK;AACL,8BAA8B,kDAAS;AACvC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+DAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAW,yBAAyB,qDAAW;AAC3E,6BAA6B,iDAAQ;AACrC,qCAAqC,yDAAa;AAClD,2CAA2C,kDAAS;AACpD;AACA,qCAAqC,yDAAa;AAClD,2CAA2C,kDAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yCAAyC,8CAAK;AAC9C,gBAAgB,kDAAS,QAAQ,kDAAS,UAAU,8CAAK,YAAY,8CAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B;AACA,iBAAiB,iDAAS;AAC1B,wBAAwB,qDAAY;AACpC;AACA;AACA,4DAA4D,qDAAY;AACxE;AACA,uCAAuC,8CAAK;AAC5C,yBAAyB,8CAAK;AAC9B,0BAA0B,yDAAa;AACvC,kCAAkC,kDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAW,yBAAyB,qDAAW;AAC/E,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA,iCAAiC,iDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC,+GAA+G,6CAAI;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;AClMgD;AAChB;AACQ;AACjC,0BAA0B,yDAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAK;AACpC;;;;;;;;;;;;;;AC/EgC;AAC2B;AAC3D;AACO,4BAA4B,kDAAS;AAC5C;AACA;AACA,kBAAkB,0DAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAiB;AACvC,8BAA8B,yCAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0DAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5HgD;AACR;AACF;AACE;AACI;AACE;AACd;AACc;AACF;AACA;AACI;AACY;AACJ;AACQ;AACP;AACe;AACxE;;;;;;;;;;;;;;AChBA;AACmE;AACX;AACf;AAClC;AACP;AACA;AACA;AACA;AACA,yBAAyB,8CAAK,CAAC,sEAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAW;AACnB,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA,uCAAuC,kDAAS;AAChD;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtHA;AAC0D;AACT;AAC8O;AACxR;AACP;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA,4BAA4B,0DAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAU;AAC/B;AACA;AACA,iBAAiB,8CAAK;AACtB,0BAA0B,8CAAK,gDAAgD,oDAAW;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wDAAe,yCAAyC,wDAAe;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA,QAAQ,qEAA4B;AACpC,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KACuG,EAAE,EAEjH;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAQ;AACrC;AACA;AACA;AACA,2BAA2B,mDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAY;AACnC;AACA,oBAAoB,2DAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAiB;AAC7B;AACA;AACA;AACA;AACA,mBAAmB,2DAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAS;AACtB,YAAY,kDAAS;AACrB;AACA,2BAA2B,6DAAoB;AAC/C,2BAA2B,6DAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAkB,2DAA2D,iDAAQ;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iDAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAS;AAC5C;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA,wCAAwC,iDAAQ;AAChD,mEAAmE,0DAAiB;AACpF;AACA;AACA;AACA;AACA,QAAQ,+CAAM,wBAAwB,kDAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAS;AACrC;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM,wBAAwB,kDAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B,iDAAiD,8CAAK;AACtD;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA,iDAAiD,8CAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B,oBAAoB,sDAAa;AACjC;AACA,eAAe,oDAAW;AAC1B,cAAc,8CAAK;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACplBA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;;;;;;;;;;;;;;;ACPwE;AAC1B;AACA;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAS;AAC1B;AACA;AACA,wCAAwC,uDAAY;AACpD;AACA,qBAAqB,kDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAY;AACxC;AACA;AACA;AACA;AACA,oBAAoB,kDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChJA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACR6W;AACvS;AAC5B;AACO;AACJ;AACA;AACI;AACC;AAC3C;AACP,0BAA0B,0DAAiB;AAC3C;AACA;AACA,WAAW,mDAAU;AACrB;AACA;AACA,wCAAwC,6CAAI;AAC5C;AACO;AACP;AACA,kDAAkD,0DAAiB;AACnE;AACA,6DAA6D,0DAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,iDAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ,QAAQ;AAC5C,4BAA4B,qDAAW;AACvC,+BAA+B,kDAAS;AACxC;AACA,mCAAmC,iEAAmB;AACtD;AACA,yCAAyC;AACzC,0CAA0C;AAC1C,gCAAgC;AAChC,0CAA0C;AAC1C,gCAAgC;AAChC;AACA,4BAA4B,qDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kDAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAe,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAK;AACrC,+CAA+C,0DAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAS;AACrC;AACA,kCAAkC,kDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC,oBAAoB,kDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,kCAAkC,8CAAK;AACvC;AACA;AACA;AACA,2BAA2B,qDAAW;AACtC;AACA;AACA,qDAAqD,yDAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0DAAiB;AAChE;AACA,YAAY,iEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6CAAI;AACvC,iDAAiD,0DAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAmB,0BAA0B,iDAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iEAAmB,uBAAuB,iDAAQ;AACxE;AACA;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,yDAAgB;AACpC;AACA;AACA;AACA;AACA,kDAAkD,8CAAK;AACvD;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2DAAgB,aAAa,2DAAgB;AAC5G,wCAAwC,2DAAgB,WAAW,2DAAgB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6CAAI;AACxC,uCAAuC,0DAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8CAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAI;AAC7B;AACA,YAAY,qDAAW,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kDAAS;AAC9C;AACA,mBAAmB,kDAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,oDAAoD,0DAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAK,gDAAgD,sDAAa;AACjF;AACA;AACA,gDAAgD,0DAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,0DAAiB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,gCAAgC,kDAAS,kBAAkB,6CAAI;AAC/D,kBAAkB,kDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2DAAgB,WAAW,2DAAgB;AACnG,6BAA6B,0DAAY,eAAe,0DAAY;AACpE;AACA;AACA,+CAA+C,0DAAiB;AAChE;AACA,QAAQ,qEAA4B;AACpC,4BAA4B,2DAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAS;AACjC;AACA;AACA;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA,8DAA8D,yDAAa;AAC3E,8DAA8D,yDAAa;AAC3E;AACA,iDAAiD,oDAAW;AAC5D;AACA;AACA;AACA;AACA,YAAY,kDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAI;AAC7B,6BAA6B,iDAAQ;AACrC,QAAQ,0DAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qEAAqE,0DAAiB;AACtF,gCAAgC,iEAAmB,0BAA0B,iDAAQ;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAK;AACtC;AACA,kCAAkC,mDAAU;AAC5C,gBAAgB,iEAAmB;AACnC;AACA;AACA;AACA,qCAAqC,6CAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAe,wBAAwB,wDAAe;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAS;AAClC;AACA;AACA;AACA;AACA,6CAA6C,8DAAqB,sEAAsE,iDAAQ;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,2DAAgB,WAAW,2DAAgB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,kBAAkB,oDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAW;AAC/B;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzoCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;;;;;;;;;;;;;;ACb8F;AAC7C;AACjD;AACO;AACP;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6CAAI;AACvC;AACA;AACA,wCAAwC,6CAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAK;AACxC;AACA;AACA,wCAAwC,6CAAI;AAC5C;AACA;AACA;AACA,wCAAwC,6CAAI;AAC5C;AACA;AACA,wCAAwC,8CAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAU;AACjC,gBAAgB,0DAAiB;AACjC,4BAA4B,yDAAa;AACzC,gBAAgB,0DAAiB;AACjC;AACA;AACA,gBAAgB,0DAAiB;AACjC;AACA;AACA;AACA;AACA,uBAAuB,8CAAK;AAC5B;AACA;AACA;AACA,4BAA4B,8CAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAI;AAChC;AACA;AACA;AACA,4BAA4B,6CAAI;AAChC;AACA;AACA;;;;;;;;;;;;;;AC7NwD;AACN;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAc;AACnD;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAc;AACnD;AACA,sDAAsD,0DAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtHO;AACP;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;;;;;;;;;;;;ACLO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;;;;;;;;;;;;ACRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;;;;;;;;;;;;ACvBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;;;;;;;;;;;;;;;;;;;;;;;ACb8B;AACsM;AAClE;AAC7H;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kDAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAY;AAClD,4CAA4C,kDAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kDAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kDAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kDAAS;AAChE;AACA;AACA,+DAA+D,8CAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kDAAS;AAChE;AACA;AACA,+DAA+D,8CAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAS,iBAAiB,kDAAS;AAC7E,iDAAiD,kDAAS;AAC1D;AACA;AACA;AACA;AACA,uCAAuC,kDAAU;AACjD;AACA;AACA,0CAA0C,kDAAU;AACpD;AACA;AACA,gDAAgD,kDAAU;AAC1D;AACA;AACA,2CAA2C,kDAAU;AACrD;AACA;AACA,2CAA2C,kDAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,0CAA0C,6CAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kDAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uDAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,yBAAyB,6CAAI;AAC7B,YAAY,uDAAW;AACvB;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA,2BAA2B,uDAAW;AACtC;AACA,yBAAyB,wDAAY;AACrC,YAAY,yDAAa;AACzB;AACA;AACA;AACA,YAAY,yDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAa;AACzB,gBAAgB,uDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAK;AAC9B,gCAAgC,wDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAY;AACnC;AACA,2CAA2C,uDAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAK;AAC1C;AACA;AACA,oCAAoC,wDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,wDAAY;AAClE;AACA;AACA;AACA,yDAAyD,wDAAY;AACrE;AACA;AACA,6CAA6C,8CAAK;AAClD;AACA;AACA,gCAAgC,wDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,uDAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iCAAiC,sCAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAkB;AAC7B;AACA;AACA;AACA,WAAW,oDAAQ;AACnB;AACA;AACA;AACA,WAAW,yDAAa;AACxB;AACA;AACA;AACA,WAAW,wDAAY;AACvB;AACA;AACA;AACA,WAAW,uDAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAS,8CAA8C,0DAAiB;AACpF,gBAAgB,kDAAS;AACzB;AACA;AACA,QAAQ,kDAAS,oDAAoD,0DAAiB;AACtF,YAAY,kDAAS;AACrB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD,cAAc,qCAAqC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAS;AAC/B;AACA;AACA,wBAAwB,sDAAsD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAU;AAC/B;AACA,gBAAgB;AAChB;AACA,oBAAoB,kDAAkD,yDAAY;AAClF;AACA,oBAAoB;AACpB;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oBAAoB;AACpB;AACA,wBAAwB;AACxB;AACA;AACA;AACA,0CAA0C,0DAAiB;AAC3D,4BAA4B;AAC5B,oBAAoB;AACpB;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA,oCAAoC,8CAAK;AACzC;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA,0DAA0D,kDAAS;AACnE;AACA,4BAA4B;AAC5B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,iDAAQ;AACvB,aAAa,sDAAsD,yDAAY;AAC/E;AACA;AACA,qBAAqB,mDAAU;AAC/B;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,oDAAoD,qDAAS;AAC7D,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA,6CAA6C,yDAAa;AAC1D,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA,6CAA6C,yDAAa;AAC1D,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB,mCAAmC,yDAAa;AAChE;AACA;AACA,gBAAgB,mCAAmC,yDAAa;AAChE;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA,yBAAyB,uDAAW;AACpC,2CAA2C,qDAAS;AACpD,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,iBAAiB,wDAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mDAAU;AAC3B;AACA;AACA,0BAA0B,8CAAK;AAC/B,mBAAmB,kDAAS;AAC5B;AACA,0BAA0B,6CAAI;AAC9B,mBAAmB,iDAAQ;AAC3B;AACA,0BAA0B,6CAAI;AAC9B,mBAAmB,iDAAQ;AAC3B;AACA;AACA;AACA;AACA,eAAe,wDAAY;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,wFAAwF;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,8CAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAAI;AAC9B,gBAAgB,uDAAW,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAY;AACpB;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAI;AACrC,YAAY,uDAAW;AACvB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,8CAAK;AACvB;AACA;AACA,gCAAgC,6CAAI;AACpC,uBAAuB,uDAAW;AAClC,gBAAgB,4BAA4B;AAC5C;AACA,uBAAuB,qDAAS;AAChC;AACA;AACA;AACA;AACA,uBAAuB,kDAAU;AACjC;AACA;AACA;AACA;AACA,uBAAuB,uDAAW;AAClC,gBAAgB,0DAA0D;AAC1E,uBAAuB,yDAAa;AACpC,uBAAuB,yDAAa;AACpC;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAU;AACjC;AACA;AACA,QAAQ,wDAAY,KAAK;AACzB;AACA;AACA;;;;;;;;;;;;;;;;;;AC9sCyE;AACP;AACnB;AAC/C;;;;;;;;;;;;;;ACHwC;AACD;AAChC;AACP,cAAc,wCAAa;AAC3B;AACA,eAAe,iDAAK;AACpB;AACA;AACA;AACA,uBAAuB,iDAAK;AAC5B;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA,WAAW,iDAAK;AAChB;AACA;;;;;;UCjBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;ACNyC;;AAEzC;AACA;AACA,UAAU,uBAAuB;AACjC,+BAA+B,sDAAM;AACrC,gBAAgB,kCAAkC;AAClD,CAAC","sources":["webpack://grafana/./node_modules/dotparser/grammar/dot.js","webpack://grafana/./node_modules/dotparser/index.js","webpack://grafana/./node_modules/linked-list-typed/dist/data-structures/base/index.js","webpack://grafana/./node_modules/linked-list-typed/dist/data-structures/base/iterable-element-base.js","webpack://grafana/./node_modules/linked-list-typed/dist/data-structures/base/iterable-entry-base.js","webpack://grafana/./node_modules/linked-list-typed/dist/data-structures/linked-list/doubly-linked-list.js","webpack://grafana/./node_modules/linked-list-typed/dist/data-structures/linked-list/index.js","webpack://grafana/./node_modules/linked-list-typed/dist/data-structures/linked-list/singly-linked-list.js","webpack://grafana/./node_modules/linked-list-typed/dist/data-structures/linked-list/skip-linked-list.js","webpack://grafana/./node_modules/linked-list-typed/dist/index.js","webpack://grafana/./node_modules/linked-list-typed/dist/types/common.js","webpack://grafana/./node_modules/linked-list-typed/dist/types/data-structures/linked-list/doubly-linked-list.js","webpack://grafana/./node_modules/linked-list-typed/dist/types/data-structures/linked-list/index.js","webpack://grafana/./node_modules/linked-list-typed/dist/types/data-structures/linked-list/singly-linked-list.js","webpack://grafana/./node_modules/linked-list-typed/dist/types/data-structures/linked-list/skip-linked-list.js","webpack://grafana/./node_modules/linked-list-typescript/lib/src/index.js","webpack://grafana/./node_modules/parse-color/index.js","webpack://grafana/./node_modules/parse-color/node_modules/color-convert/conversions.js","webpack://grafana/./node_modules/parse-color/node_modules/color-convert/index.js","webpack://grafana/./node_modules/queue-typescript/lib/src/index.js","webpack://grafana/./node_modules/reliable-random/dist/index.esm.js","webpack://grafana/./node_modules/stack-typescript/lib/src/index.js","webpack://grafana/./node_modules/typescript-string-operations/dist/index.js","webpack://grafana/./public/app/plugins/panel/nodeGraph/layeredLayout.js","webpack://grafana/./node_modules/@msagl/core/dist/index.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/commonLayoutSettings.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/RRect.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/arrowhead.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/curvePort.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/floatingPort.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/geomEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/geomGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/geomLabel.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/geomNode.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/geomObject.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/hookUpAnywhereFromInsidePort.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/port.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/relativeFloatingPort.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/tile.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/core/tileMap.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/driver.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/edgeLabelPlacement.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/MstLineSweeper.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/MstOnDelaunayTriangulation.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/OverlapRemovalSettings.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/gTreeOverlapRemoval.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/incremental/fiEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/incremental/fiNode.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/incremental/iPsepCola.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/incremental/iPsepColaSettings.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/incremental/multipole/disc.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/incremental/multipole/kdTree.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/incremental/multipole/minimumEnclosingDisc.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/incremental/multipole/multipoleCoefficients.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/initialLayout/geomConnectedComponent.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/initialLayout/initialLayout.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/initialLayout/layoutAlgorithmHelpers.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/Balancing.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/CycleRemoval.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/Database.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/EdgePathsInserter.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/HierarchyCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/HorizontalConstraintsForSugiyama.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/LayerArrays.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/LayerInserter.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/NodeKind.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/ProperLayeredGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/RefinerBetweenTwoLayers.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/anchor.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/layerDirectionEnum.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/layerEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/layeredLayout.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/layering/NetworkSimplex.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/layering/NetworkSimplexForGeneralGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/layering/longestPathLayering.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/layering/networkEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/ordering/edgeComparerBySource.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/ordering/edgeComparerByTarget.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/ordering/metroMapOrdering.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/ordering/ordering.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/ordering/orderingMeasure.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/polyIntEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/routing.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/smoothedPolylineCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/sugiyamaLayoutSettings.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/verticalConstraintsForSugiyama.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/xCoordsWithAlignment.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/layered/xLayoutGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/mds/AllPairsDistances.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/mds/SingleSourceDistances.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/mds/Transform.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/mds/mDSGraphLayout.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/mds/mDSLayoutSettings.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/mds/multiDimensionalScaling.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/mds/pivotDistances.js","webpack://grafana/./node_modules/@msagl/core/dist/layout/mds/pivotMDS.js","webpack://grafana/./node_modules/@msagl/core/dist/math/RBTree/rbColor.js","webpack://grafana/./node_modules/@msagl/core/dist/math/RBTree/rbNode.js","webpack://grafana/./node_modules/@msagl/core/dist/math/RBTree/rbTree.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/Interval.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/RTree/hitTestBehavior.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/bezierSeg.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/closestPointOnCurve.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/compassVector.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/convexHull.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/cornerSite.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/curve.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/curveFactory.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/debugCurve.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/direction.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/ellipse.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/geomConstants.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/icurve.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/index.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/intersectionInfo.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/lineSegment.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/linearSystem.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/minDistCurveCurve.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/parallelogram.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/parallelogramNode.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/planeTransformation.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/point.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/pointPair.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/polyline.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/rectangle.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/OptimalPacking.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/OptimalRectanglePacking.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/Packing.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/PackingConstants.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/RectanglePacking.js","webpack://grafana/./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js","webpack://grafana/./node_modules/@msagl/core/dist/math/graphAlgorithms/ConnectedComponentCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/math/graphAlgorithms/MinimumSpanningTreeByPrim.js","webpack://grafana/./node_modules/@msagl/core/dist/math/graphAlgorithms/topologicalSort.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/Block.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/BlockVector.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/Constraint.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/ConstraintVector.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/DfDvNode.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/Parameters.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/QPSC.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/Solution.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/Solver.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/SolverAlgorithm.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/SolverShell.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/UniformOneDimensionalSolver.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/UniformSolverVar.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/Variable.js","webpack://grafana/./node_modules/@msagl/core/dist/math/projectionSolver/ViolationCache.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/BundlingSettings.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ClusterBoundaryPort.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtFrontElement.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtSite.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtSweeper.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtTriangle.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/PerimeterEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/ThreeArray.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/EdgeRoutingMode.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/EdgeRoutingSettings.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/MultiEdgeRouter.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/PreGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/RelativeShape.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ShapeCreator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ShapeCreatorForRoutingToParents.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/ShapeObstacleCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/SingleSourceSingleTargetShortestPathOnVisibilityGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/StraightLineEdges.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/TightLooseCouple.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/interactiveEdgeRouter.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/interactiveObstacleCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/AxisCoordinateEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/BasicObstacleSide.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/BasicVertexEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/EventQueue.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/FreePoint.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/GroupBoundaryCrossing.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/GroupBoundaryCrossingMap.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/HighReflectionEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/LookaheadScan.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/LowReflectionEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/MiscVertexEvents.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/MsmtRectilinearPath.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/NeighborSides.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/ObstaclePort.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/ObstaclePortEntrance.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/ObstacleTree.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/OpenVertexEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/OverlapConvexHull.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/PointAndCrossings.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/PointAndCrossingsList.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/PortManager.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearEdgeRouter.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearInteractiveEditor.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearScanLine.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/ScanDirection.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentTree.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentVector.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentVectorItem.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/SparseVisibiltyGraphGenerator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/SpliceUtility.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/SsstRectilinearPath.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/TransientGraphUtility.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/VertexEntry.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/VisibilityGraphGenerator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/VisibilityVertexRectiline.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/basicReflectionEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgeHighPointEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgeLowPointEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgesContainer.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/CombinatorialNudger.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/FreeSpaceFinder.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPoint.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPointSplitter.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LongestNudgedSegment.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/Nudger.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/Path.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathMerger.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathRefiner.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/SegWithIndex.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/nudging/StaircaseRemover.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/rectilinear/obstacle.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/shape.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/splineRouter.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/BundleBase.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/BundleBasesCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/BundleInfo.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/BundleRouter.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/BundlingStatus.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/CdtIntersections.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/CdtThreader.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/CostCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/EdgeNudger.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/FlipSwitcher.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/GeneralMetroMapOrdering.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/HubRadiiCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/IntersectionCache.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/Intersections.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/MetroGraphData.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/MetroLine.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/MetroNodeInfo.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/OrientedHubSegment.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/PathFixer.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/PointPairOrder.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/SdBoneEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/SdShortestPath.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/SdVertex.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/SimulatedAnnealing.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/Station.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/StationEdgeInfo.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/StationPositionsAdjuster.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/bundling/tupleMap.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/BrokenConeSide.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/Cone.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeClosureEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeLeftSide.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeRightSide.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSide.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSideComparer.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSpanner.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftIntersectionEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftObstacleSide.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftVertexEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LineSweeper.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LowestVertexEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ObstacleSide.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightIntersectionEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightObstacleSide.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightVertexEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/coneSpanner/VertexEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/spline/pathOptimizer.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/ActiveDiagonalComparerWithRay.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/ActiveEdgeComparerWithRay.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/BimodalSequence.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/Diagonal.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/InteractiveTangentVisibilityGraphCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/LineSweeperBase.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/ObstacleSideComparer.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/PointVisibilityCalculator.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/Polygon.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/PortObstacleEvent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/SegmentBase.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/Stem.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/StemStartPointComparer.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/Tangent.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/TangentPair.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/UnimodalSequence.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/VisibilityEdge.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/VisibilityKind.js","webpack://grafana/./node_modules/@msagl/core/dist/routing/visibility/VisibilityVertex.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/BasicGraph.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/BinaryHeapPriorityQueue.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/BinaryHeapWithComparer.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/algorithmData.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/attribute.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/attributeRegistry.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/edge.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/entity.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/genericHeapElement.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/graph.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/label.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/node.js","webpack://grafana/./node_modules/@msagl/core/dist/structs/nodeCollection.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/IntPair.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/IntPairMap.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/IntPairSet.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/PointMap.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/PointSet.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/RealNumberSpan.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/algorithm.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/assert.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/cancelToken.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/compare.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/copy.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/pointPairMap.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/random.js","webpack://grafana/./node_modules/@msagl/core/dist/utils/setOperations.js","webpack://grafana/./node_modules/@msagl/drawing/dist/arrowTypeEnum.js","webpack://grafana/./node_modules/@msagl/drawing/dist/color.js","webpack://grafana/./node_modules/@msagl/drawing/dist/dirTypeEnum.js","webpack://grafana/./node_modules/@msagl/drawing/dist/drawingEdge.js","webpack://grafana/./node_modules/@msagl/drawing/dist/drawingGraph.js","webpack://grafana/./node_modules/@msagl/drawing/dist/drawingNode.js","webpack://grafana/./node_modules/@msagl/drawing/dist/drawingObject.js","webpack://grafana/./node_modules/@msagl/drawing/dist/index.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/bumperPusher.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/geomGraphEditor.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/iViewer.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/incrementalDragger.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/labelFixture.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/layoutEditor.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/modifierKeys.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/undoRedoAction.js","webpack://grafana/./node_modules/@msagl/drawing/dist/layoutEditing/undoRedoActionsList.js","webpack://grafana/./node_modules/@msagl/drawing/dist/orderingEnum.js","webpack://grafana/./node_modules/@msagl/drawing/dist/rankEnum.js","webpack://grafana/./node_modules/@msagl/drawing/dist/shapeEnum.js","webpack://grafana/./node_modules/@msagl/drawing/dist/styleEnum.js","webpack://grafana/./node_modules/@msagl/parser/dist/dotparser.js","webpack://grafana/./node_modules/@msagl/parser/dist/index.js","webpack://grafana/./node_modules/@msagl/parser/dist/utils.js","webpack://grafana/webpack/bootstrap","webpack://grafana/webpack/runtime/define property getters","webpack://grafana/webpack/runtime/hasOwnProperty shorthand","webpack://grafana/webpack/runtime/make namespace object","webpack://grafana/./public/app/plugins/panel/nodeGraph/layeredLayout.worker.js"],"sourcesContent":["/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = \"strict\",\n      peg$c1 = peg$literalExpectation(\"strict\", true),\n      peg$c2 = \"graph\",\n      peg$c3 = peg$literalExpectation(\"graph\", true),\n      peg$c4 = \"digraph\",\n      peg$c5 = peg$literalExpectation(\"digraph\", true),\n      peg$c6 = \"{\",\n      peg$c7 = peg$literalExpectation(\"{\", false),\n      peg$c8 = \"}\",\n      peg$c9 = peg$literalExpectation(\"}\", false),\n      peg$c10 = function(strict, type, id, children) {\n            if (children === null) children = [];\n            var ret = {type:type.toLowerCase(), children:children};\n            if (strict) { ret.strict = true }\n            if (id) { ret.id = id }\n            return ret;\n          },\n      peg$c11 = \";\",\n      peg$c12 = peg$literalExpectation(\";\", false),\n      peg$c13 = function(s, other) { return other; },\n      peg$c14 = function(s, e) { return [s].concat(e); },\n      peg$c15 = \"=\",\n      peg$c16 = peg$literalExpectation(\"=\", false),\n      peg$c17 = function(left, right) {\n          return {\n            type:'attr_stmt',\n            target:'graph',\n            attr_list:[{\n              type:'attr',\n              id:left,\n              eq:right\n            }]\n          };\n        },\n      peg$c18 = \"node\",\n      peg$c19 = peg$literalExpectation(\"node\", true),\n      peg$c20 = \"edge\",\n      peg$c21 = peg$literalExpectation(\"edge\", true),\n      peg$c22 = function(target, attr) {\n           return {\n             type:'attr_stmt',\n             target:target,\n             attr_list:attr\n           };\n        },\n      peg$c23 = \"[\",\n      peg$c24 = peg$literalExpectation(\"[\", false),\n      peg$c25 = \"]\",\n      peg$c26 = peg$literalExpectation(\"]\", false),\n      peg$c27 = function(list, rest) {\n          return (list || []).concat(rest || []);\n        },\n      peg$c28 = function(id, v) {return v},\n      peg$c29 = \",\",\n      peg$c30 = peg$literalExpectation(\",\", false),\n      peg$c31 = function(id, eq, rest) {\n              return [{\n                type:'attr',\n                id:id,\n                eq: eq\n              }].concat(rest || []);\n          },\n      peg$c32 = function(id, rhs, attr) {\n             var edge_list = [id];\n             edge_list = edge_list.concat(rhs.map(function(v){return v.id}));\n\n             return {\n               type:'edge_stmt',\n               edge_list:edge_list,\n               attr_list:attr || []\n             };\n          },\n      peg$c33 = \"->\",\n      peg$c34 = peg$literalExpectation(\"->\", false),\n      peg$c35 = \"--\",\n      peg$c36 = peg$literalExpectation(\"--\", false),\n      peg$c37 = function(edgeop, id, rest) {\n            return [{\n              type:'edgeRHS',\n              edgeop:edgeop,\n              id:id\n            }].concat(rest || []);\n        },\n      peg$c38 = function(id, attr) {\n          return {\n            type:'node_stmt',\n            node_id:id,\n            attr_list:attr || []\n          };\n        },\n      peg$c39 = function(id, port) {\n            return port ? {\n              type:'node_id', id:id, port:port\n            } : {\n              type:'node_id', id:id\n            };\n        },\n      peg$c40 = peg$otherExpectation(\"port\"),\n      peg$c41 = \":\",\n      peg$c42 = peg$literalExpectation(\":\", false),\n      peg$c43 = function(id, pt) {return pt},\n      peg$c44 = function(id, pt) {\n          return {\n            type:'port',\n            id:id,\n            compass_pt:pt || null\n          };\n        },\n      peg$c45 = function(pt) {\n          return {\n            type:'port',\n            compass_pt:pt || null\n          }\n        },\n      peg$c46 = \"subgraph\",\n      peg$c47 = peg$literalExpectation(\"subgraph\", true),\n      peg$c48 = function(id) {\n              return id ? {\n                type:'subgraph', id:id\n              } : {\n                type:'subgraph'\n              }\n            },\n      peg$c49 = function(g, s) {\n              g = g || {\n                type:'subgraph'\n              };\n              g.children = s || [];\n              return g;\n            },\n      peg$c50 = \"n\",\n      peg$c51 = peg$literalExpectation(\"n\", false),\n      peg$c52 = \"ne\",\n      peg$c53 = peg$literalExpectation(\"ne\", false),\n      peg$c54 = \"e\",\n      peg$c55 = peg$literalExpectation(\"e\", false),\n      peg$c56 = \"se\",\n      peg$c57 = peg$literalExpectation(\"se\", false),\n      peg$c58 = \"s\",\n      peg$c59 = peg$literalExpectation(\"s\", false),\n      peg$c60 = \"sw\",\n      peg$c61 = peg$literalExpectation(\"sw\", false),\n      peg$c62 = \"w\",\n      peg$c63 = peg$literalExpectation(\"w\", false),\n      peg$c64 = \"nw\",\n      peg$c65 = peg$literalExpectation(\"nw\", false),\n      peg$c66 = peg$otherExpectation(\"UNICODE_STRING\"),\n      peg$c67 = function(first, rest) {\n            return first + rest.join('');\n          },\n      peg$c68 = function(first, rest) {\n          return first + rest;\n        },\n      peg$c69 = \"$\",\n      peg$c70 = peg$literalExpectation(\"$\", false),\n      peg$c71 = \"_\",\n      peg$c72 = peg$literalExpectation(\"_\", false),\n      peg$c73 = peg$otherExpectation(\"NUMBER\"),\n      peg$c74 = \"-\",\n      peg$c75 = peg$literalExpectation(\"-\", false),\n      peg$c76 = \".\",\n      peg$c77 = peg$literalExpectation(\".\", false),\n      peg$c78 = /^[0-9]/,\n      peg$c79 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c80 = function(n) {\n             return parseFloat(text());\n          },\n      peg$c81 = function(v) {\n            return {\n              type:'id',\n              value:v.slice(1,v.length-1),\n              html:true\n            };\n          },\n      peg$c82 = \"<\",\n      peg$c83 = peg$literalExpectation(\"<\", false),\n      peg$c84 = \">\",\n      peg$c85 = peg$literalExpectation(\">\", false),\n      peg$c86 = function(v) {\n            return '<' + v.join('') + '>';\n          },\n      peg$c87 = peg$anyExpectation(),\n      peg$c88 = function(v) { return v; },\n      peg$c89 = function(v) { return v.join(\"\"); },\n      peg$c90 = \"\\\"\",\n      peg$c91 = peg$literalExpectation(\"\\\"\", false),\n      peg$c92 = function(chars) { return chars.join(\"\"); },\n      peg$c93 = function() { return text(); },\n      peg$c94 = \"\\\\\",\n      peg$c95 = peg$literalExpectation(\"\\\\\", false),\n      peg$c96 = function(v) { return v[1] === '\"' ? '\"' : v[0] + v[1]; },\n      peg$c97 = function() { return \"\"; },\n      peg$c98 = /^[\\n\\r\\u2028\\u2029]/,\n      peg$c99 = peg$classExpectation([\"\\n\", \"\\r\", \"\\u2028\", \"\\u2029\"], false, false),\n      peg$c100 = peg$otherExpectation(\"end of line\"),\n      peg$c101 = \"\\n\",\n      peg$c102 = peg$literalExpectation(\"\\n\", false),\n      peg$c103 = \"\\r\\n\",\n      peg$c104 = peg$literalExpectation(\"\\r\\n\", false),\n      peg$c105 = \"\\r\",\n      peg$c106 = peg$literalExpectation(\"\\r\", false),\n      peg$c107 = \"\\u2028\",\n      peg$c108 = peg$literalExpectation(\"\\u2028\", false),\n      peg$c109 = \"\\u2029\",\n      peg$c110 = peg$literalExpectation(\"\\u2029\", false),\n      peg$c111 = /^[^\"\\\\\\0-\\x1F\\x7F]/,\n      peg$c112 = peg$classExpectation([\"\\\"\", \"\\\\\", [\"\\0\", \"\\x1F\"], \"\\x7F\"], true, false),\n      peg$c113 = \"\\\\\\\"\",\n      peg$c114 = peg$literalExpectation(\"\\\\\\\"\", false),\n      peg$c115 = function() { return '\"'; },\n      peg$c116 = function() { return '\\\\'; },\n      peg$c117 = peg$otherExpectation(\"COMMENT\"),\n      peg$c118 = peg$otherExpectation(\"BLOCK_COMMENT\"),\n      peg$c119 = \"/*\",\n      peg$c120 = peg$literalExpectation(\"/*\", false),\n      peg$c121 = \"*/\",\n      peg$c122 = peg$literalExpectation(\"*/\", false),\n      peg$c123 = function(v) {return v;},\n      peg$c124 = function(v) { return v.join('') },\n      peg$c125 = peg$otherExpectation(\"C_COMMENT\"),\n      peg$c126 = \"//\",\n      peg$c127 = peg$literalExpectation(\"//\", false),\n      peg$c128 = /^[\\n]/,\n      peg$c129 = peg$classExpectation([\"\\n\"], false, false),\n      peg$c130 = function(v) { return v.join(''); },\n      peg$c131 = peg$otherExpectation(\"MACRO_COMMENT\"),\n      peg$c132 = \"#\",\n      peg$c133 = peg$literalExpectation(\"#\", false),\n      peg$c134 = peg$otherExpectation(\"WHITESPACE\"),\n      peg$c135 = /^[\\n\\r]/,\n      peg$c136 = peg$classExpectation([\"\\n\", \"\\r\"], false, false),\n      peg$c137 = /^[ \\t]/,\n      peg$c138 = peg$classExpectation([\" \", \"\\t\"], false, false),\n      peg$c139 = /^[a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137-\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148-\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C-\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA-\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9-\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC-\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF-\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F-\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0-\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB-\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE-\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6-\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FC7\\u1FD0-\\u1FD3\\u1FD6-\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6-\\u1FF7\\u210A\\u210E-\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C-\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65-\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73-\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3-\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A]/,\n      peg$c140 = peg$classExpectation([[\"a\", \"z\"], \"\\xB5\", [\"\\xDF\", \"\\xF6\"], [\"\\xF8\", \"\\xFF\"], \"\\u0101\", \"\\u0103\", \"\\u0105\", \"\\u0107\", \"\\u0109\", \"\\u010B\", \"\\u010D\", \"\\u010F\", \"\\u0111\", \"\\u0113\", \"\\u0115\", \"\\u0117\", \"\\u0119\", \"\\u011B\", \"\\u011D\", \"\\u011F\", \"\\u0121\", \"\\u0123\", \"\\u0125\", \"\\u0127\", \"\\u0129\", \"\\u012B\", \"\\u012D\", \"\\u012F\", \"\\u0131\", \"\\u0133\", \"\\u0135\", [\"\\u0137\", \"\\u0138\"], \"\\u013A\", \"\\u013C\", \"\\u013E\", \"\\u0140\", \"\\u0142\", \"\\u0144\", \"\\u0146\", [\"\\u0148\", \"\\u0149\"], \"\\u014B\", \"\\u014D\", \"\\u014F\", \"\\u0151\", \"\\u0153\", \"\\u0155\", \"\\u0157\", \"\\u0159\", \"\\u015B\", \"\\u015D\", \"\\u015F\", \"\\u0161\", \"\\u0163\", \"\\u0165\", \"\\u0167\", \"\\u0169\", \"\\u016B\", \"\\u016D\", \"\\u016F\", \"\\u0171\", \"\\u0173\", \"\\u0175\", \"\\u0177\", \"\\u017A\", \"\\u017C\", [\"\\u017E\", \"\\u0180\"], \"\\u0183\", \"\\u0185\", \"\\u0188\", [\"\\u018C\", \"\\u018D\"], \"\\u0192\", \"\\u0195\", [\"\\u0199\", \"\\u019B\"], \"\\u019E\", \"\\u01A1\", \"\\u01A3\", \"\\u01A5\", \"\\u01A8\", [\"\\u01AA\", \"\\u01AB\"], \"\\u01AD\", \"\\u01B0\", \"\\u01B4\", \"\\u01B6\", [\"\\u01B9\", \"\\u01BA\"], [\"\\u01BD\", \"\\u01BF\"], \"\\u01C6\", \"\\u01C9\", \"\\u01CC\", \"\\u01CE\", \"\\u01D0\", \"\\u01D2\", \"\\u01D4\", \"\\u01D6\", \"\\u01D8\", \"\\u01DA\", [\"\\u01DC\", \"\\u01DD\"], \"\\u01DF\", \"\\u01E1\", \"\\u01E3\", \"\\u01E5\", \"\\u01E7\", \"\\u01E9\", \"\\u01EB\", \"\\u01ED\", [\"\\u01EF\", \"\\u01F0\"], \"\\u01F3\", \"\\u01F5\", \"\\u01F9\", \"\\u01FB\", \"\\u01FD\", \"\\u01FF\", \"\\u0201\", \"\\u0203\", \"\\u0205\", \"\\u0207\", \"\\u0209\", \"\\u020B\", \"\\u020D\", \"\\u020F\", \"\\u0211\", \"\\u0213\", \"\\u0215\", \"\\u0217\", \"\\u0219\", \"\\u021B\", \"\\u021D\", \"\\u021F\", \"\\u0221\", \"\\u0223\", \"\\u0225\", \"\\u0227\", \"\\u0229\", \"\\u022B\", \"\\u022D\", \"\\u022F\", \"\\u0231\", [\"\\u0233\", \"\\u0239\"], \"\\u023C\", [\"\\u023F\", \"\\u0240\"], \"\\u0242\", \"\\u0247\", \"\\u0249\", \"\\u024B\", \"\\u024D\", [\"\\u024F\", \"\\u0293\"], [\"\\u0295\", \"\\u02AF\"], \"\\u0371\", \"\\u0373\", \"\\u0377\", [\"\\u037B\", \"\\u037D\"], \"\\u0390\", [\"\\u03AC\", \"\\u03CE\"], [\"\\u03D0\", \"\\u03D1\"], [\"\\u03D5\", \"\\u03D7\"], \"\\u03D9\", \"\\u03DB\", \"\\u03DD\", \"\\u03DF\", \"\\u03E1\", \"\\u03E3\", \"\\u03E5\", \"\\u03E7\", \"\\u03E9\", \"\\u03EB\", \"\\u03ED\", [\"\\u03EF\", \"\\u03F3\"], \"\\u03F5\", \"\\u03F8\", [\"\\u03FB\", \"\\u03FC\"], [\"\\u0430\", \"\\u045F\"], \"\\u0461\", \"\\u0463\", \"\\u0465\", \"\\u0467\", \"\\u0469\", \"\\u046B\", \"\\u046D\", \"\\u046F\", \"\\u0471\", \"\\u0473\", \"\\u0475\", \"\\u0477\", \"\\u0479\", \"\\u047B\", \"\\u047D\", \"\\u047F\", \"\\u0481\", \"\\u048B\", \"\\u048D\", \"\\u048F\", \"\\u0491\", \"\\u0493\", \"\\u0495\", \"\\u0497\", \"\\u0499\", \"\\u049B\", \"\\u049D\", \"\\u049F\", \"\\u04A1\", \"\\u04A3\", \"\\u04A5\", \"\\u04A7\", \"\\u04A9\", \"\\u04AB\", \"\\u04AD\", \"\\u04AF\", \"\\u04B1\", \"\\u04B3\", \"\\u04B5\", \"\\u04B7\", \"\\u04B9\", \"\\u04BB\", \"\\u04BD\", \"\\u04BF\", \"\\u04C2\", \"\\u04C4\", \"\\u04C6\", \"\\u04C8\", \"\\u04CA\", \"\\u04CC\", [\"\\u04CE\", \"\\u04CF\"], \"\\u04D1\", \"\\u04D3\", \"\\u04D5\", \"\\u04D7\", \"\\u04D9\", \"\\u04DB\", \"\\u04DD\", \"\\u04DF\", \"\\u04E1\", \"\\u04E3\", \"\\u04E5\", \"\\u04E7\", \"\\u04E9\", \"\\u04EB\", \"\\u04ED\", \"\\u04EF\", \"\\u04F1\", \"\\u04F3\", \"\\u04F5\", \"\\u04F7\", \"\\u04F9\", \"\\u04FB\", \"\\u04FD\", \"\\u04FF\", \"\\u0501\", \"\\u0503\", \"\\u0505\", \"\\u0507\", \"\\u0509\", \"\\u050B\", \"\\u050D\", \"\\u050F\", \"\\u0511\", \"\\u0513\", \"\\u0515\", \"\\u0517\", \"\\u0519\", \"\\u051B\", \"\\u051D\", \"\\u051F\", \"\\u0521\", \"\\u0523\", \"\\u0525\", \"\\u0527\", [\"\\u0561\", \"\\u0587\"], [\"\\u1D00\", \"\\u1D2B\"], [\"\\u1D6B\", \"\\u1D77\"], [\"\\u1D79\", \"\\u1D9A\"], \"\\u1E01\", \"\\u1E03\", \"\\u1E05\", \"\\u1E07\", \"\\u1E09\", \"\\u1E0B\", \"\\u1E0D\", \"\\u1E0F\", \"\\u1E11\", \"\\u1E13\", \"\\u1E15\", \"\\u1E17\", \"\\u1E19\", \"\\u1E1B\", \"\\u1E1D\", \"\\u1E1F\", \"\\u1E21\", \"\\u1E23\", \"\\u1E25\", \"\\u1E27\", \"\\u1E29\", \"\\u1E2B\", \"\\u1E2D\", \"\\u1E2F\", \"\\u1E31\", \"\\u1E33\", \"\\u1E35\", \"\\u1E37\", \"\\u1E39\", \"\\u1E3B\", \"\\u1E3D\", \"\\u1E3F\", \"\\u1E41\", \"\\u1E43\", \"\\u1E45\", \"\\u1E47\", \"\\u1E49\", \"\\u1E4B\", \"\\u1E4D\", \"\\u1E4F\", \"\\u1E51\", \"\\u1E53\", \"\\u1E55\", \"\\u1E57\", \"\\u1E59\", \"\\u1E5B\", \"\\u1E5D\", \"\\u1E5F\", \"\\u1E61\", \"\\u1E63\", \"\\u1E65\", \"\\u1E67\", \"\\u1E69\", \"\\u1E6B\", \"\\u1E6D\", \"\\u1E6F\", \"\\u1E71\", \"\\u1E73\", \"\\u1E75\", \"\\u1E77\", \"\\u1E79\", \"\\u1E7B\", \"\\u1E7D\", \"\\u1E7F\", \"\\u1E81\", \"\\u1E83\", \"\\u1E85\", \"\\u1E87\", \"\\u1E89\", \"\\u1E8B\", \"\\u1E8D\", \"\\u1E8F\", \"\\u1E91\", \"\\u1E93\", [\"\\u1E95\", \"\\u1E9D\"], \"\\u1E9F\", \"\\u1EA1\", \"\\u1EA3\", \"\\u1EA5\", \"\\u1EA7\", \"\\u1EA9\", \"\\u1EAB\", \"\\u1EAD\", \"\\u1EAF\", \"\\u1EB1\", \"\\u1EB3\", \"\\u1EB5\", \"\\u1EB7\", \"\\u1EB9\", \"\\u1EBB\", \"\\u1EBD\", \"\\u1EBF\", \"\\u1EC1\", \"\\u1EC3\", \"\\u1EC5\", \"\\u1EC7\", \"\\u1EC9\", \"\\u1ECB\", \"\\u1ECD\", \"\\u1ECF\", \"\\u1ED1\", \"\\u1ED3\", \"\\u1ED5\", \"\\u1ED7\", \"\\u1ED9\", \"\\u1EDB\", \"\\u1EDD\", \"\\u1EDF\", \"\\u1EE1\", \"\\u1EE3\", \"\\u1EE5\", \"\\u1EE7\", \"\\u1EE9\", \"\\u1EEB\", \"\\u1EED\", \"\\u1EEF\", \"\\u1EF1\", \"\\u1EF3\", \"\\u1EF5\", \"\\u1EF7\", \"\\u1EF9\", \"\\u1EFB\", \"\\u1EFD\", [\"\\u1EFF\", \"\\u1F07\"], [\"\\u1F10\", \"\\u1F15\"], [\"\\u1F20\", \"\\u1F27\"], [\"\\u1F30\", \"\\u1F37\"], [\"\\u1F40\", \"\\u1F45\"], [\"\\u1F50\", \"\\u1F57\"], [\"\\u1F60\", \"\\u1F67\"], [\"\\u1F70\", \"\\u1F7D\"], [\"\\u1F80\", \"\\u1F87\"], [\"\\u1F90\", \"\\u1F97\"], [\"\\u1FA0\", \"\\u1FA7\"], [\"\\u1FB0\", \"\\u1FB4\"], [\"\\u1FB6\", \"\\u1FB7\"], \"\\u1FBE\", [\"\\u1FC2\", \"\\u1FC4\"], [\"\\u1FC6\", \"\\u1FC7\"], [\"\\u1FD0\", \"\\u1FD3\"], [\"\\u1FD6\", \"\\u1FD7\"], [\"\\u1FE0\", \"\\u1FE7\"], [\"\\u1FF2\", \"\\u1FF4\"], [\"\\u1FF6\", \"\\u1FF7\"], \"\\u210A\", [\"\\u210E\", \"\\u210F\"], \"\\u2113\", \"\\u212F\", \"\\u2134\", \"\\u2139\", [\"\\u213C\", \"\\u213D\"], [\"\\u2146\", \"\\u2149\"], \"\\u214E\", \"\\u2184\", [\"\\u2C30\", \"\\u2C5E\"], \"\\u2C61\", [\"\\u2C65\", \"\\u2C66\"], \"\\u2C68\", \"\\u2C6A\", \"\\u2C6C\", \"\\u2C71\", [\"\\u2C73\", \"\\u2C74\"], [\"\\u2C76\", \"\\u2C7B\"], \"\\u2C81\", \"\\u2C83\", \"\\u2C85\", \"\\u2C87\", \"\\u2C89\", \"\\u2C8B\", \"\\u2C8D\", \"\\u2C8F\", \"\\u2C91\", \"\\u2C93\", \"\\u2C95\", \"\\u2C97\", \"\\u2C99\", \"\\u2C9B\", \"\\u2C9D\", \"\\u2C9F\", \"\\u2CA1\", \"\\u2CA3\", \"\\u2CA5\", \"\\u2CA7\", \"\\u2CA9\", \"\\u2CAB\", \"\\u2CAD\", \"\\u2CAF\", \"\\u2CB1\", \"\\u2CB3\", \"\\u2CB5\", \"\\u2CB7\", \"\\u2CB9\", \"\\u2CBB\", \"\\u2CBD\", \"\\u2CBF\", \"\\u2CC1\", \"\\u2CC3\", \"\\u2CC5\", \"\\u2CC7\", \"\\u2CC9\", \"\\u2CCB\", \"\\u2CCD\", \"\\u2CCF\", \"\\u2CD1\", \"\\u2CD3\", \"\\u2CD5\", \"\\u2CD7\", \"\\u2CD9\", \"\\u2CDB\", \"\\u2CDD\", \"\\u2CDF\", \"\\u2CE1\", [\"\\u2CE3\", \"\\u2CE4\"], \"\\u2CEC\", \"\\u2CEE\", \"\\u2CF3\", [\"\\u2D00\", \"\\u2D25\"], \"\\u2D27\", \"\\u2D2D\", \"\\uA641\", \"\\uA643\", \"\\uA645\", \"\\uA647\", \"\\uA649\", \"\\uA64B\", \"\\uA64D\", \"\\uA64F\", \"\\uA651\", \"\\uA653\", \"\\uA655\", \"\\uA657\", \"\\uA659\", \"\\uA65B\", \"\\uA65D\", \"\\uA65F\", \"\\uA661\", \"\\uA663\", \"\\uA665\", \"\\uA667\", \"\\uA669\", \"\\uA66B\", \"\\uA66D\", \"\\uA681\", \"\\uA683\", \"\\uA685\", \"\\uA687\", \"\\uA689\", \"\\uA68B\", \"\\uA68D\", \"\\uA68F\", \"\\uA691\", \"\\uA693\", \"\\uA695\", \"\\uA697\", \"\\uA723\", \"\\uA725\", \"\\uA727\", \"\\uA729\", \"\\uA72B\", \"\\uA72D\", [\"\\uA72F\", \"\\uA731\"], \"\\uA733\", \"\\uA735\", \"\\uA737\", \"\\uA739\", \"\\uA73B\", \"\\uA73D\", \"\\uA73F\", \"\\uA741\", \"\\uA743\", \"\\uA745\", \"\\uA747\", \"\\uA749\", \"\\uA74B\", \"\\uA74D\", \"\\uA74F\", \"\\uA751\", \"\\uA753\", \"\\uA755\", \"\\uA757\", \"\\uA759\", \"\\uA75B\", \"\\uA75D\", \"\\uA75F\", \"\\uA761\", \"\\uA763\", \"\\uA765\", \"\\uA767\", \"\\uA769\", \"\\uA76B\", \"\\uA76D\", \"\\uA76F\", [\"\\uA771\", \"\\uA778\"], \"\\uA77A\", \"\\uA77C\", \"\\uA77F\", \"\\uA781\", \"\\uA783\", \"\\uA785\", \"\\uA787\", \"\\uA78C\", \"\\uA78E\", \"\\uA791\", \"\\uA793\", \"\\uA7A1\", \"\\uA7A3\", \"\\uA7A5\", \"\\uA7A7\", \"\\uA7A9\", \"\\uA7FA\", [\"\\uFB00\", \"\\uFB06\"], [\"\\uFB13\", \"\\uFB17\"], [\"\\uFF41\", \"\\uFF5A\"]], false, false),\n      peg$c141 = /^[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5-\\u06E6\\u07F4-\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA7F8-\\uA7F9\\uA9CF\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uFF70\\uFF9E-\\uFF9F]/,\n      peg$c142 = peg$classExpectation([[\"\\u02B0\", \"\\u02C1\"], [\"\\u02C6\", \"\\u02D1\"], [\"\\u02E0\", \"\\u02E4\"], \"\\u02EC\", \"\\u02EE\", \"\\u0374\", \"\\u037A\", \"\\u0559\", \"\\u0640\", [\"\\u06E5\", \"\\u06E6\"], [\"\\u07F4\", \"\\u07F5\"], \"\\u07FA\", \"\\u081A\", \"\\u0824\", \"\\u0828\", \"\\u0971\", \"\\u0E46\", \"\\u0EC6\", \"\\u10FC\", \"\\u17D7\", \"\\u1843\", \"\\u1AA7\", [\"\\u1C78\", \"\\u1C7D\"], [\"\\u1D2C\", \"\\u1D6A\"], \"\\u1D78\", [\"\\u1D9B\", \"\\u1DBF\"], \"\\u2071\", \"\\u207F\", [\"\\u2090\", \"\\u209C\"], [\"\\u2C7C\", \"\\u2C7D\"], \"\\u2D6F\", \"\\u2E2F\", \"\\u3005\", [\"\\u3031\", \"\\u3035\"], \"\\u303B\", [\"\\u309D\", \"\\u309E\"], [\"\\u30FC\", \"\\u30FE\"], \"\\uA015\", [\"\\uA4F8\", \"\\uA4FD\"], \"\\uA60C\", \"\\uA67F\", [\"\\uA717\", \"\\uA71F\"], \"\\uA770\", \"\\uA788\", [\"\\uA7F8\", \"\\uA7F9\"], \"\\uA9CF\", \"\\uAA70\", \"\\uAADD\", [\"\\uAAF3\", \"\\uAAF4\"], \"\\uFF70\", [\"\\uFF9E\", \"\\uFF9F\"]], false, false),\n      peg$c143 = /^[\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E-\\u066F\\u0671-\\u06D3\\u06D5\\u06EE-\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0-\\u0AE1\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58-\\u0C59\\u0C60-\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0-\\u0CE1\\u0CF1-\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E45\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065-\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE-\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5-\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A-\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n      peg$c144 = peg$classExpectation([\"\\xAA\", \"\\xBA\", \"\\u01BB\", [\"\\u01C0\", \"\\u01C3\"], \"\\u0294\", [\"\\u05D0\", \"\\u05EA\"], [\"\\u05F0\", \"\\u05F2\"], [\"\\u0620\", \"\\u063F\"], [\"\\u0641\", \"\\u064A\"], [\"\\u066E\", \"\\u066F\"], [\"\\u0671\", \"\\u06D3\"], \"\\u06D5\", [\"\\u06EE\", \"\\u06EF\"], [\"\\u06FA\", \"\\u06FC\"], \"\\u06FF\", \"\\u0710\", [\"\\u0712\", \"\\u072F\"], [\"\\u074D\", \"\\u07A5\"], \"\\u07B1\", [\"\\u07CA\", \"\\u07EA\"], [\"\\u0800\", \"\\u0815\"], [\"\\u0840\", \"\\u0858\"], \"\\u08A0\", [\"\\u08A2\", \"\\u08AC\"], [\"\\u0904\", \"\\u0939\"], \"\\u093D\", \"\\u0950\", [\"\\u0958\", \"\\u0961\"], [\"\\u0972\", \"\\u0977\"], [\"\\u0979\", \"\\u097F\"], [\"\\u0985\", \"\\u098C\"], [\"\\u098F\", \"\\u0990\"], [\"\\u0993\", \"\\u09A8\"], [\"\\u09AA\", \"\\u09B0\"], \"\\u09B2\", [\"\\u09B6\", \"\\u09B9\"], \"\\u09BD\", \"\\u09CE\", [\"\\u09DC\", \"\\u09DD\"], [\"\\u09DF\", \"\\u09E1\"], [\"\\u09F0\", \"\\u09F1\"], [\"\\u0A05\", \"\\u0A0A\"], [\"\\u0A0F\", \"\\u0A10\"], [\"\\u0A13\", \"\\u0A28\"], [\"\\u0A2A\", \"\\u0A30\"], [\"\\u0A32\", \"\\u0A33\"], [\"\\u0A35\", \"\\u0A36\"], [\"\\u0A38\", \"\\u0A39\"], [\"\\u0A59\", \"\\u0A5C\"], \"\\u0A5E\", [\"\\u0A72\", \"\\u0A74\"], [\"\\u0A85\", \"\\u0A8D\"], [\"\\u0A8F\", \"\\u0A91\"], [\"\\u0A93\", \"\\u0AA8\"], [\"\\u0AAA\", \"\\u0AB0\"], [\"\\u0AB2\", \"\\u0AB3\"], [\"\\u0AB5\", \"\\u0AB9\"], \"\\u0ABD\", \"\\u0AD0\", [\"\\u0AE0\", \"\\u0AE1\"], [\"\\u0B05\", \"\\u0B0C\"], [\"\\u0B0F\", \"\\u0B10\"], [\"\\u0B13\", \"\\u0B28\"], [\"\\u0B2A\", \"\\u0B30\"], [\"\\u0B32\", \"\\u0B33\"], [\"\\u0B35\", \"\\u0B39\"], \"\\u0B3D\", [\"\\u0B5C\", \"\\u0B5D\"], [\"\\u0B5F\", \"\\u0B61\"], \"\\u0B71\", \"\\u0B83\", [\"\\u0B85\", \"\\u0B8A\"], [\"\\u0B8E\", \"\\u0B90\"], [\"\\u0B92\", \"\\u0B95\"], [\"\\u0B99\", \"\\u0B9A\"], \"\\u0B9C\", [\"\\u0B9E\", \"\\u0B9F\"], [\"\\u0BA3\", \"\\u0BA4\"], [\"\\u0BA8\", \"\\u0BAA\"], [\"\\u0BAE\", \"\\u0BB9\"], \"\\u0BD0\", [\"\\u0C05\", \"\\u0C0C\"], [\"\\u0C0E\", \"\\u0C10\"], [\"\\u0C12\", \"\\u0C28\"], [\"\\u0C2A\", \"\\u0C33\"], [\"\\u0C35\", \"\\u0C39\"], \"\\u0C3D\", [\"\\u0C58\", \"\\u0C59\"], [\"\\u0C60\", \"\\u0C61\"], [\"\\u0C85\", \"\\u0C8C\"], [\"\\u0C8E\", \"\\u0C90\"], [\"\\u0C92\", \"\\u0CA8\"], [\"\\u0CAA\", \"\\u0CB3\"], [\"\\u0CB5\", \"\\u0CB9\"], \"\\u0CBD\", \"\\u0CDE\", [\"\\u0CE0\", \"\\u0CE1\"], [\"\\u0CF1\", \"\\u0CF2\"], [\"\\u0D05\", \"\\u0D0C\"], [\"\\u0D0E\", \"\\u0D10\"], [\"\\u0D12\", \"\\u0D3A\"], \"\\u0D3D\", \"\\u0D4E\", [\"\\u0D60\", \"\\u0D61\"], [\"\\u0D7A\", \"\\u0D7F\"], [\"\\u0D85\", \"\\u0D96\"], [\"\\u0D9A\", \"\\u0DB1\"], [\"\\u0DB3\", \"\\u0DBB\"], \"\\u0DBD\", [\"\\u0DC0\", \"\\u0DC6\"], [\"\\u0E01\", \"\\u0E30\"], [\"\\u0E32\", \"\\u0E33\"], [\"\\u0E40\", \"\\u0E45\"], [\"\\u0E81\", \"\\u0E82\"], \"\\u0E84\", [\"\\u0E87\", \"\\u0E88\"], \"\\u0E8A\", \"\\u0E8D\", [\"\\u0E94\", \"\\u0E97\"], [\"\\u0E99\", \"\\u0E9F\"], [\"\\u0EA1\", \"\\u0EA3\"], \"\\u0EA5\", \"\\u0EA7\", [\"\\u0EAA\", \"\\u0EAB\"], [\"\\u0EAD\", \"\\u0EB0\"], [\"\\u0EB2\", \"\\u0EB3\"], \"\\u0EBD\", [\"\\u0EC0\", \"\\u0EC4\"], [\"\\u0EDC\", \"\\u0EDF\"], \"\\u0F00\", [\"\\u0F40\", \"\\u0F47\"], [\"\\u0F49\", \"\\u0F6C\"], [\"\\u0F88\", \"\\u0F8C\"], [\"\\u1000\", \"\\u102A\"], \"\\u103F\", [\"\\u1050\", \"\\u1055\"], [\"\\u105A\", \"\\u105D\"], \"\\u1061\", [\"\\u1065\", \"\\u1066\"], [\"\\u106E\", \"\\u1070\"], [\"\\u1075\", \"\\u1081\"], \"\\u108E\", [\"\\u10D0\", \"\\u10FA\"], [\"\\u10FD\", \"\\u1248\"], [\"\\u124A\", \"\\u124D\"], [\"\\u1250\", \"\\u1256\"], \"\\u1258\", [\"\\u125A\", \"\\u125D\"], [\"\\u1260\", \"\\u1288\"], [\"\\u128A\", \"\\u128D\"], [\"\\u1290\", \"\\u12B0\"], [\"\\u12B2\", \"\\u12B5\"], [\"\\u12B8\", \"\\u12BE\"], \"\\u12C0\", [\"\\u12C2\", \"\\u12C5\"], [\"\\u12C8\", \"\\u12D6\"], [\"\\u12D8\", \"\\u1310\"], [\"\\u1312\", \"\\u1315\"], [\"\\u1318\", \"\\u135A\"], [\"\\u1380\", \"\\u138F\"], [\"\\u13A0\", \"\\u13F4\"], [\"\\u1401\", \"\\u166C\"], [\"\\u166F\", \"\\u167F\"], [\"\\u1681\", \"\\u169A\"], [\"\\u16A0\", \"\\u16EA\"], [\"\\u1700\", \"\\u170C\"], [\"\\u170E\", \"\\u1711\"], [\"\\u1720\", \"\\u1731\"], [\"\\u1740\", \"\\u1751\"], [\"\\u1760\", \"\\u176C\"], [\"\\u176E\", \"\\u1770\"], [\"\\u1780\", \"\\u17B3\"], \"\\u17DC\", [\"\\u1820\", \"\\u1842\"], [\"\\u1844\", \"\\u1877\"], [\"\\u1880\", \"\\u18A8\"], \"\\u18AA\", [\"\\u18B0\", \"\\u18F5\"], [\"\\u1900\", \"\\u191C\"], [\"\\u1950\", \"\\u196D\"], [\"\\u1970\", \"\\u1974\"], [\"\\u1980\", \"\\u19AB\"], [\"\\u19C1\", \"\\u19C7\"], [\"\\u1A00\", \"\\u1A16\"], [\"\\u1A20\", \"\\u1A54\"], [\"\\u1B05\", \"\\u1B33\"], [\"\\u1B45\", \"\\u1B4B\"], [\"\\u1B83\", \"\\u1BA0\"], [\"\\u1BAE\", \"\\u1BAF\"], [\"\\u1BBA\", \"\\u1BE5\"], [\"\\u1C00\", \"\\u1C23\"], [\"\\u1C4D\", \"\\u1C4F\"], [\"\\u1C5A\", \"\\u1C77\"], [\"\\u1CE9\", \"\\u1CEC\"], [\"\\u1CEE\", \"\\u1CF1\"], [\"\\u1CF5\", \"\\u1CF6\"], [\"\\u2135\", \"\\u2138\"], [\"\\u2D30\", \"\\u2D67\"], [\"\\u2D80\", \"\\u2D96\"], [\"\\u2DA0\", \"\\u2DA6\"], [\"\\u2DA8\", \"\\u2DAE\"], [\"\\u2DB0\", \"\\u2DB6\"], [\"\\u2DB8\", \"\\u2DBE\"], [\"\\u2DC0\", \"\\u2DC6\"], [\"\\u2DC8\", \"\\u2DCE\"], [\"\\u2DD0\", \"\\u2DD6\"], [\"\\u2DD8\", \"\\u2DDE\"], \"\\u3006\", \"\\u303C\", [\"\\u3041\", \"\\u3096\"], \"\\u309F\", [\"\\u30A1\", \"\\u30FA\"], \"\\u30FF\", [\"\\u3105\", \"\\u312D\"], [\"\\u3131\", \"\\u318E\"], [\"\\u31A0\", \"\\u31BA\"], [\"\\u31F0\", \"\\u31FF\"], [\"\\u3400\", \"\\u4DB5\"], [\"\\u4E00\", \"\\u9FCC\"], [\"\\uA000\", \"\\uA014\"], [\"\\uA016\", \"\\uA48C\"], [\"\\uA4D0\", \"\\uA4F7\"], [\"\\uA500\", \"\\uA60B\"], [\"\\uA610\", \"\\uA61F\"], [\"\\uA62A\", \"\\uA62B\"], \"\\uA66E\", [\"\\uA6A0\", \"\\uA6E5\"], [\"\\uA7FB\", \"\\uA801\"], [\"\\uA803\", \"\\uA805\"], [\"\\uA807\", \"\\uA80A\"], [\"\\uA80C\", \"\\uA822\"], [\"\\uA840\", \"\\uA873\"], [\"\\uA882\", \"\\uA8B3\"], [\"\\uA8F2\", \"\\uA8F7\"], \"\\uA8FB\", [\"\\uA90A\", \"\\uA925\"], [\"\\uA930\", \"\\uA946\"], [\"\\uA960\", \"\\uA97C\"], [\"\\uA984\", \"\\uA9B2\"], [\"\\uAA00\", \"\\uAA28\"], [\"\\uAA40\", \"\\uAA42\"], [\"\\uAA44\", \"\\uAA4B\"], [\"\\uAA60\", \"\\uAA6F\"], [\"\\uAA71\", \"\\uAA76\"], \"\\uAA7A\", [\"\\uAA80\", \"\\uAAAF\"], \"\\uAAB1\", [\"\\uAAB5\", \"\\uAAB6\"], [\"\\uAAB9\", \"\\uAABD\"], \"\\uAAC0\", \"\\uAAC2\", [\"\\uAADB\", \"\\uAADC\"], [\"\\uAAE0\", \"\\uAAEA\"], \"\\uAAF2\", [\"\\uAB01\", \"\\uAB06\"], [\"\\uAB09\", \"\\uAB0E\"], [\"\\uAB11\", \"\\uAB16\"], [\"\\uAB20\", \"\\uAB26\"], [\"\\uAB28\", \"\\uAB2E\"], [\"\\uABC0\", \"\\uABE2\"], [\"\\uAC00\", \"\\uD7A3\"], [\"\\uD7B0\", \"\\uD7C6\"], [\"\\uD7CB\", \"\\uD7FB\"], [\"\\uF900\", \"\\uFA6D\"], [\"\\uFA70\", \"\\uFAD9\"], \"\\uFB1D\", [\"\\uFB1F\", \"\\uFB28\"], [\"\\uFB2A\", \"\\uFB36\"], [\"\\uFB38\", \"\\uFB3C\"], \"\\uFB3E\", [\"\\uFB40\", \"\\uFB41\"], [\"\\uFB43\", \"\\uFB44\"], [\"\\uFB46\", \"\\uFBB1\"], [\"\\uFBD3\", \"\\uFD3D\"], [\"\\uFD50\", \"\\uFD8F\"], [\"\\uFD92\", \"\\uFDC7\"], [\"\\uFDF0\", \"\\uFDFB\"], [\"\\uFE70\", \"\\uFE74\"], [\"\\uFE76\", \"\\uFEFC\"], [\"\\uFF66\", \"\\uFF6F\"], [\"\\uFF71\", \"\\uFF9D\"], [\"\\uFFA0\", \"\\uFFBE\"], [\"\\uFFC2\", \"\\uFFC7\"], [\"\\uFFCA\", \"\\uFFCF\"], [\"\\uFFD2\", \"\\uFFD7\"], [\"\\uFFDA\", \"\\uFFDC\"]], false, false),\n      peg$c145 = /^[\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC]/,\n      peg$c146 = peg$classExpectation([\"\\u01C5\", \"\\u01C8\", \"\\u01CB\", \"\\u01F2\", [\"\\u1F88\", \"\\u1F8F\"], [\"\\u1F98\", \"\\u1F9F\"], [\"\\u1FA8\", \"\\u1FAF\"], \"\\u1FBC\", \"\\u1FCC\", \"\\u1FFC\"], false, false),\n      peg$c147 = /^[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178-\\u0179\\u017B\\u017D\\u0181-\\u0182\\u0184\\u0186-\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193-\\u0194\\u0196-\\u0198\\u019C-\\u019D\\u019F-\\u01A0\\u01A2\\u01A4\\u01A6-\\u01A7\\u01A9\\u01AC\\u01AE-\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7-\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A-\\u023B\\u023D-\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9-\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0-\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E-\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D-\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA\\uFF21-\\uFF3A]/,\n      peg$c148 = peg$classExpectation([[\"A\", \"Z\"], [\"\\xC0\", \"\\xD6\"], [\"\\xD8\", \"\\xDE\"], \"\\u0100\", \"\\u0102\", \"\\u0104\", \"\\u0106\", \"\\u0108\", \"\\u010A\", \"\\u010C\", \"\\u010E\", \"\\u0110\", \"\\u0112\", \"\\u0114\", \"\\u0116\", \"\\u0118\", \"\\u011A\", \"\\u011C\", \"\\u011E\", \"\\u0120\", \"\\u0122\", \"\\u0124\", \"\\u0126\", \"\\u0128\", \"\\u012A\", \"\\u012C\", \"\\u012E\", \"\\u0130\", \"\\u0132\", \"\\u0134\", \"\\u0136\", \"\\u0139\", \"\\u013B\", \"\\u013D\", \"\\u013F\", \"\\u0141\", \"\\u0143\", \"\\u0145\", \"\\u0147\", \"\\u014A\", \"\\u014C\", \"\\u014E\", \"\\u0150\", \"\\u0152\", \"\\u0154\", \"\\u0156\", \"\\u0158\", \"\\u015A\", \"\\u015C\", \"\\u015E\", \"\\u0160\", \"\\u0162\", \"\\u0164\", \"\\u0166\", \"\\u0168\", \"\\u016A\", \"\\u016C\", \"\\u016E\", \"\\u0170\", \"\\u0172\", \"\\u0174\", \"\\u0176\", [\"\\u0178\", \"\\u0179\"], \"\\u017B\", \"\\u017D\", [\"\\u0181\", \"\\u0182\"], \"\\u0184\", [\"\\u0186\", \"\\u0187\"], [\"\\u0189\", \"\\u018B\"], [\"\\u018E\", \"\\u0191\"], [\"\\u0193\", \"\\u0194\"], [\"\\u0196\", \"\\u0198\"], [\"\\u019C\", \"\\u019D\"], [\"\\u019F\", \"\\u01A0\"], \"\\u01A2\", \"\\u01A4\", [\"\\u01A6\", \"\\u01A7\"], \"\\u01A9\", \"\\u01AC\", [\"\\u01AE\", \"\\u01AF\"], [\"\\u01B1\", \"\\u01B3\"], \"\\u01B5\", [\"\\u01B7\", \"\\u01B8\"], \"\\u01BC\", \"\\u01C4\", \"\\u01C7\", \"\\u01CA\", \"\\u01CD\", \"\\u01CF\", \"\\u01D1\", \"\\u01D3\", \"\\u01D5\", \"\\u01D7\", \"\\u01D9\", \"\\u01DB\", \"\\u01DE\", \"\\u01E0\", \"\\u01E2\", \"\\u01E4\", \"\\u01E6\", \"\\u01E8\", \"\\u01EA\", \"\\u01EC\", \"\\u01EE\", \"\\u01F1\", \"\\u01F4\", [\"\\u01F6\", \"\\u01F8\"], \"\\u01FA\", \"\\u01FC\", \"\\u01FE\", \"\\u0200\", \"\\u0202\", \"\\u0204\", \"\\u0206\", \"\\u0208\", \"\\u020A\", \"\\u020C\", \"\\u020E\", \"\\u0210\", \"\\u0212\", \"\\u0214\", \"\\u0216\", \"\\u0218\", \"\\u021A\", \"\\u021C\", \"\\u021E\", \"\\u0220\", \"\\u0222\", \"\\u0224\", \"\\u0226\", \"\\u0228\", \"\\u022A\", \"\\u022C\", \"\\u022E\", \"\\u0230\", \"\\u0232\", [\"\\u023A\", \"\\u023B\"], [\"\\u023D\", \"\\u023E\"], \"\\u0241\", [\"\\u0243\", \"\\u0246\"], \"\\u0248\", \"\\u024A\", \"\\u024C\", \"\\u024E\", \"\\u0370\", \"\\u0372\", \"\\u0376\", \"\\u0386\", [\"\\u0388\", \"\\u038A\"], \"\\u038C\", [\"\\u038E\", \"\\u038F\"], [\"\\u0391\", \"\\u03A1\"], [\"\\u03A3\", \"\\u03AB\"], \"\\u03CF\", [\"\\u03D2\", \"\\u03D4\"], \"\\u03D8\", \"\\u03DA\", \"\\u03DC\", \"\\u03DE\", \"\\u03E0\", \"\\u03E2\", \"\\u03E4\", \"\\u03E6\", \"\\u03E8\", \"\\u03EA\", \"\\u03EC\", \"\\u03EE\", \"\\u03F4\", \"\\u03F7\", [\"\\u03F9\", \"\\u03FA\"], [\"\\u03FD\", \"\\u042F\"], \"\\u0460\", \"\\u0462\", \"\\u0464\", \"\\u0466\", \"\\u0468\", \"\\u046A\", \"\\u046C\", \"\\u046E\", \"\\u0470\", \"\\u0472\", \"\\u0474\", \"\\u0476\", \"\\u0478\", \"\\u047A\", \"\\u047C\", \"\\u047E\", \"\\u0480\", \"\\u048A\", \"\\u048C\", \"\\u048E\", \"\\u0490\", \"\\u0492\", \"\\u0494\", \"\\u0496\", \"\\u0498\", \"\\u049A\", \"\\u049C\", \"\\u049E\", \"\\u04A0\", \"\\u04A2\", \"\\u04A4\", \"\\u04A6\", \"\\u04A8\", \"\\u04AA\", \"\\u04AC\", \"\\u04AE\", \"\\u04B0\", \"\\u04B2\", \"\\u04B4\", \"\\u04B6\", \"\\u04B8\", \"\\u04BA\", \"\\u04BC\", \"\\u04BE\", [\"\\u04C0\", \"\\u04C1\"], \"\\u04C3\", \"\\u04C5\", \"\\u04C7\", \"\\u04C9\", \"\\u04CB\", \"\\u04CD\", \"\\u04D0\", \"\\u04D2\", \"\\u04D4\", \"\\u04D6\", \"\\u04D8\", \"\\u04DA\", \"\\u04DC\", \"\\u04DE\", \"\\u04E0\", \"\\u04E2\", \"\\u04E4\", \"\\u04E6\", \"\\u04E8\", \"\\u04EA\", \"\\u04EC\", \"\\u04EE\", \"\\u04F0\", \"\\u04F2\", \"\\u04F4\", \"\\u04F6\", \"\\u04F8\", \"\\u04FA\", \"\\u04FC\", \"\\u04FE\", \"\\u0500\", \"\\u0502\", \"\\u0504\", \"\\u0506\", \"\\u0508\", \"\\u050A\", \"\\u050C\", \"\\u050E\", \"\\u0510\", \"\\u0512\", \"\\u0514\", \"\\u0516\", \"\\u0518\", \"\\u051A\", \"\\u051C\", \"\\u051E\", \"\\u0520\", \"\\u0522\", \"\\u0524\", \"\\u0526\", [\"\\u0531\", \"\\u0556\"], [\"\\u10A0\", \"\\u10C5\"], \"\\u10C7\", \"\\u10CD\", \"\\u1E00\", \"\\u1E02\", \"\\u1E04\", \"\\u1E06\", \"\\u1E08\", \"\\u1E0A\", \"\\u1E0C\", \"\\u1E0E\", \"\\u1E10\", \"\\u1E12\", \"\\u1E14\", \"\\u1E16\", \"\\u1E18\", \"\\u1E1A\", \"\\u1E1C\", \"\\u1E1E\", \"\\u1E20\", \"\\u1E22\", \"\\u1E24\", \"\\u1E26\", \"\\u1E28\", \"\\u1E2A\", \"\\u1E2C\", \"\\u1E2E\", \"\\u1E30\", \"\\u1E32\", \"\\u1E34\", \"\\u1E36\", \"\\u1E38\", \"\\u1E3A\", \"\\u1E3C\", \"\\u1E3E\", \"\\u1E40\", \"\\u1E42\", \"\\u1E44\", \"\\u1E46\", \"\\u1E48\", \"\\u1E4A\", \"\\u1E4C\", \"\\u1E4E\", \"\\u1E50\", \"\\u1E52\", \"\\u1E54\", \"\\u1E56\", \"\\u1E58\", \"\\u1E5A\", \"\\u1E5C\", \"\\u1E5E\", \"\\u1E60\", \"\\u1E62\", \"\\u1E64\", \"\\u1E66\", \"\\u1E68\", \"\\u1E6A\", \"\\u1E6C\", \"\\u1E6E\", \"\\u1E70\", \"\\u1E72\", \"\\u1E74\", \"\\u1E76\", \"\\u1E78\", \"\\u1E7A\", \"\\u1E7C\", \"\\u1E7E\", \"\\u1E80\", \"\\u1E82\", \"\\u1E84\", \"\\u1E86\", \"\\u1E88\", \"\\u1E8A\", \"\\u1E8C\", \"\\u1E8E\", \"\\u1E90\", \"\\u1E92\", \"\\u1E94\", \"\\u1E9E\", \"\\u1EA0\", \"\\u1EA2\", \"\\u1EA4\", \"\\u1EA6\", \"\\u1EA8\", \"\\u1EAA\", \"\\u1EAC\", \"\\u1EAE\", \"\\u1EB0\", \"\\u1EB2\", \"\\u1EB4\", \"\\u1EB6\", \"\\u1EB8\", \"\\u1EBA\", \"\\u1EBC\", \"\\u1EBE\", \"\\u1EC0\", \"\\u1EC2\", \"\\u1EC4\", \"\\u1EC6\", \"\\u1EC8\", \"\\u1ECA\", \"\\u1ECC\", \"\\u1ECE\", \"\\u1ED0\", \"\\u1ED2\", \"\\u1ED4\", \"\\u1ED6\", \"\\u1ED8\", \"\\u1EDA\", \"\\u1EDC\", \"\\u1EDE\", \"\\u1EE0\", \"\\u1EE2\", \"\\u1EE4\", \"\\u1EE6\", \"\\u1EE8\", \"\\u1EEA\", \"\\u1EEC\", \"\\u1EEE\", \"\\u1EF0\", \"\\u1EF2\", \"\\u1EF4\", \"\\u1EF6\", \"\\u1EF8\", \"\\u1EFA\", \"\\u1EFC\", \"\\u1EFE\", [\"\\u1F08\", \"\\u1F0F\"], [\"\\u1F18\", \"\\u1F1D\"], [\"\\u1F28\", \"\\u1F2F\"], [\"\\u1F38\", \"\\u1F3F\"], [\"\\u1F48\", \"\\u1F4D\"], \"\\u1F59\", \"\\u1F5B\", \"\\u1F5D\", \"\\u1F5F\", [\"\\u1F68\", \"\\u1F6F\"], [\"\\u1FB8\", \"\\u1FBB\"], [\"\\u1FC8\", \"\\u1FCB\"], [\"\\u1FD8\", \"\\u1FDB\"], [\"\\u1FE8\", \"\\u1FEC\"], [\"\\u1FF8\", \"\\u1FFB\"], \"\\u2102\", \"\\u2107\", [\"\\u210B\", \"\\u210D\"], [\"\\u2110\", \"\\u2112\"], \"\\u2115\", [\"\\u2119\", \"\\u211D\"], \"\\u2124\", \"\\u2126\", \"\\u2128\", [\"\\u212A\", \"\\u212D\"], [\"\\u2130\", \"\\u2133\"], [\"\\u213E\", \"\\u213F\"], \"\\u2145\", \"\\u2183\", [\"\\u2C00\", \"\\u2C2E\"], \"\\u2C60\", [\"\\u2C62\", \"\\u2C64\"], \"\\u2C67\", \"\\u2C69\", \"\\u2C6B\", [\"\\u2C6D\", \"\\u2C70\"], \"\\u2C72\", \"\\u2C75\", [\"\\u2C7E\", \"\\u2C80\"], \"\\u2C82\", \"\\u2C84\", \"\\u2C86\", \"\\u2C88\", \"\\u2C8A\", \"\\u2C8C\", \"\\u2C8E\", \"\\u2C90\", \"\\u2C92\", \"\\u2C94\", \"\\u2C96\", \"\\u2C98\", \"\\u2C9A\", \"\\u2C9C\", \"\\u2C9E\", \"\\u2CA0\", \"\\u2CA2\", \"\\u2CA4\", \"\\u2CA6\", \"\\u2CA8\", \"\\u2CAA\", \"\\u2CAC\", \"\\u2CAE\", \"\\u2CB0\", \"\\u2CB2\", \"\\u2CB4\", \"\\u2CB6\", \"\\u2CB8\", \"\\u2CBA\", \"\\u2CBC\", \"\\u2CBE\", \"\\u2CC0\", \"\\u2CC2\", \"\\u2CC4\", \"\\u2CC6\", \"\\u2CC8\", \"\\u2CCA\", \"\\u2CCC\", \"\\u2CCE\", \"\\u2CD0\", \"\\u2CD2\", \"\\u2CD4\", \"\\u2CD6\", \"\\u2CD8\", \"\\u2CDA\", \"\\u2CDC\", \"\\u2CDE\", \"\\u2CE0\", \"\\u2CE2\", \"\\u2CEB\", \"\\u2CED\", \"\\u2CF2\", \"\\uA640\", \"\\uA642\", \"\\uA644\", \"\\uA646\", \"\\uA648\", \"\\uA64A\", \"\\uA64C\", \"\\uA64E\", \"\\uA650\", \"\\uA652\", \"\\uA654\", \"\\uA656\", \"\\uA658\", \"\\uA65A\", \"\\uA65C\", \"\\uA65E\", \"\\uA660\", \"\\uA662\", \"\\uA664\", \"\\uA666\", \"\\uA668\", \"\\uA66A\", \"\\uA66C\", \"\\uA680\", \"\\uA682\", \"\\uA684\", \"\\uA686\", \"\\uA688\", \"\\uA68A\", \"\\uA68C\", \"\\uA68E\", \"\\uA690\", \"\\uA692\", \"\\uA694\", \"\\uA696\", \"\\uA722\", \"\\uA724\", \"\\uA726\", \"\\uA728\", \"\\uA72A\", \"\\uA72C\", \"\\uA72E\", \"\\uA732\", \"\\uA734\", \"\\uA736\", \"\\uA738\", \"\\uA73A\", \"\\uA73C\", \"\\uA73E\", \"\\uA740\", \"\\uA742\", \"\\uA744\", \"\\uA746\", \"\\uA748\", \"\\uA74A\", \"\\uA74C\", \"\\uA74E\", \"\\uA750\", \"\\uA752\", \"\\uA754\", \"\\uA756\", \"\\uA758\", \"\\uA75A\", \"\\uA75C\", \"\\uA75E\", \"\\uA760\", \"\\uA762\", \"\\uA764\", \"\\uA766\", \"\\uA768\", \"\\uA76A\", \"\\uA76C\", \"\\uA76E\", \"\\uA779\", \"\\uA77B\", [\"\\uA77D\", \"\\uA77E\"], \"\\uA780\", \"\\uA782\", \"\\uA784\", \"\\uA786\", \"\\uA78B\", \"\\uA78D\", \"\\uA790\", \"\\uA792\", \"\\uA7A0\", \"\\uA7A2\", \"\\uA7A4\", \"\\uA7A6\", \"\\uA7A8\", \"\\uA7AA\", [\"\\uFF21\", \"\\uFF3A\"]], false, false),\n      peg$c149 = /^[\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]/,\n      peg$c150 = peg$classExpectation([[\"\\u16EE\", \"\\u16F0\"], [\"\\u2160\", \"\\u2182\"], [\"\\u2185\", \"\\u2188\"], \"\\u3007\", [\"\\u3021\", \"\\u3029\"], [\"\\u3038\", \"\\u303A\"], [\"\\uA6E6\", \"\\uA6EF\"]], false, false),\n      peg$c151 = /^[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]/,\n      peg$c152 = peg$classExpectation([[\"0\", \"9\"], [\"\\u0660\", \"\\u0669\"], [\"\\u06F0\", \"\\u06F9\"], [\"\\u07C0\", \"\\u07C9\"], [\"\\u0966\", \"\\u096F\"], [\"\\u09E6\", \"\\u09EF\"], [\"\\u0A66\", \"\\u0A6F\"], [\"\\u0AE6\", \"\\u0AEF\"], [\"\\u0B66\", \"\\u0B6F\"], [\"\\u0BE6\", \"\\u0BEF\"], [\"\\u0C66\", \"\\u0C6F\"], [\"\\u0CE6\", \"\\u0CEF\"], [\"\\u0D66\", \"\\u0D6F\"], [\"\\u0E50\", \"\\u0E59\"], [\"\\u0ED0\", \"\\u0ED9\"], [\"\\u0F20\", \"\\u0F29\"], [\"\\u1040\", \"\\u1049\"], [\"\\u1090\", \"\\u1099\"], [\"\\u17E0\", \"\\u17E9\"], [\"\\u1810\", \"\\u1819\"], [\"\\u1946\", \"\\u194F\"], [\"\\u19D0\", \"\\u19D9\"], [\"\\u1A80\", \"\\u1A89\"], [\"\\u1A90\", \"\\u1A99\"], [\"\\u1B50\", \"\\u1B59\"], [\"\\u1BB0\", \"\\u1BB9\"], [\"\\u1C40\", \"\\u1C49\"], [\"\\u1C50\", \"\\u1C59\"], [\"\\uA620\", \"\\uA629\"], [\"\\uA8D0\", \"\\uA8D9\"], [\"\\uA900\", \"\\uA909\"], [\"\\uA9D0\", \"\\uA9D9\"], [\"\\uAA50\", \"\\uAA59\"], [\"\\uABF0\", \"\\uABF9\"], [\"\\uFF10\", \"\\uFF19\"]], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parsegraph();\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsegraph();\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsegraph() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c0) {\n        s2 = input.substr(peg$currPos, 6);\n        peg$currPos += 6;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c2) {\n            s4 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c3); }\n          }\n          if (s4 === peg$FAILED) {\n            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c4) {\n              s4 = input.substr(peg$currPos, 7);\n              peg$currPos += 7;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c5); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseID();\n              if (s6 === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 123) {\n                    s8 = peg$c6;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c7); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsestmt_list();\n                    if (s9 === peg$FAILED) {\n                      s9 = null;\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 125) {\n                          s11 = peg$c8;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parse_();\n                          if (s12 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c10(s2, s4, s6, s9);\n                            s0 = s1;\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestmt_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsestmt();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 59) {\n            s4 = peg$c11;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c12); }\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$currPos;\n            s7 = peg$parse_();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsestmt();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parse_();\n                if (s9 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 59) {\n                    s10 = peg$c11;\n                    peg$currPos++;\n                  } else {\n                    s10 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c12); }\n                  }\n                  if (s10 === peg$FAILED) {\n                    s10 = null;\n                  }\n                  if (s10 !== peg$FAILED) {\n                    peg$savedPos = s6;\n                    s7 = peg$c13(s2, s8);\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$currPos;\n              s7 = peg$parse_();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parsestmt();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parse_();\n                  if (s9 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 59) {\n                      s10 = peg$c11;\n                      peg$currPos++;\n                    } else {\n                      s10 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c12); }\n                    }\n                    if (s10 === peg$FAILED) {\n                      s10 = null;\n                    }\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s6;\n                      s7 = peg$c13(s2, s8);\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c14(s2, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestmt() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseID();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s3 = peg$c15;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c16); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseID();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c17(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseattr_stmt();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseedge_stmt();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsesubgraph();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsenode_stmt();\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseID();\n              if (s1 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 61) {\n                  s2 = peg$c15;\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c16); }\n                }\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parseID();\n                  if (s3 !== peg$FAILED) {\n                    s1 = [s1, s2, s3];\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseattr_stmt() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c2) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c18) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c20) {\n          s1 = input.substr(peg$currPos, 4);\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseattr_list();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c22(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseattr_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s2 = peg$c23;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsea_list();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c25;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c26); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseattr_list();\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c27(s4, s8);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsea_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseID();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s5 = peg$c15;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseID();\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c28(s2, s7);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c29;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c30); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 59) {\n                s5 = peg$c11;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c12); }\n              }\n            }\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsea_list();\n              if (s6 === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c31(s2, s3, s6);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseedge_stmt() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesubgraph();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsenode_id();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseedgeRHS();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseattr_list();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c32(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseedgeRHS() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c33) {\n        s2 = peg$c33;\n        peg$currPos += 2;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c34); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c35) {\n          s2 = peg$c35;\n          peg$currPos += 2;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c36); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesubgraph();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsenode_id();\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseedgeRHS();\n              if (s6 === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c37(s2, s4, s6);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenode_stmt() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenode_id();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseattr_list();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c38(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenode_id() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseID();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseport();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c39(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseport() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 58) {\n      s1 = peg$c41;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c42); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseID();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s4 = peg$c41;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecompass_pt();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c43(s2, s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c44(s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c41;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsecompass_pt();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c45(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c40); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesubgraph() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c46) {\n      s2 = input.substr(peg$currPos, 8);\n      peg$currPos += 8;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c47); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseID();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c48(s4);\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s2 = peg$c6;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestmt_list();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s5 = peg$c8;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c9); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c49(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecompass_pt() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 110) {\n      s0 = peg$c50;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c51); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c52) {\n        s0 = peg$c52;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 101) {\n          s0 = peg$c54;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c55); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c56) {\n            s0 = peg$c56;\n            peg$currPos += 2;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c57); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 115) {\n              s0 = peg$c58;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c59); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c60) {\n                s0 = peg$c60;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 119) {\n                  s0 = peg$c62;\n                  peg$currPos++;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c63); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c64) {\n                    s0 = peg$c64;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c65); }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseID() {\n    var s0;\n\n    s0 = peg$parseSTRING();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseNUMBER_STRING();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNUMBER();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseQUOTED_STRING();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseHTML_STRING();\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSTRING() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseStringStart();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseStringPart();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseStringPart();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c67(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c66); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNUMBER_STRING() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseNUMBER();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSTRING();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c68(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseStringStart() {\n    var s0;\n\n    s0 = peg$parseUnicodeLetter();\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 36) {\n        s0 = peg$c69;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 95) {\n          s0 = peg$c71;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c72); }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseStringPart() {\n    var s0;\n\n    s0 = peg$parseStringStart();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseNd();\n    }\n\n    return s0;\n  }\n\n  function peg$parseNUMBER() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 45) {\n      s2 = peg$c74;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c75); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s4 = peg$c76;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c77); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        if (peg$c78.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c79); }\n        }\n        if (s6 !== peg$FAILED) {\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            if (peg$c78.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c79); }\n            }\n          }\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$c78.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c79); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c78.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c79); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s6 = peg$c76;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c77); }\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = [];\n            if (peg$c78.test(input.charAt(peg$currPos))) {\n              s8 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c79); }\n            }\n            while (s8 !== peg$FAILED) {\n              s7.push(s8);\n              if (peg$c78.test(input.charAt(peg$currPos))) {\n                s8 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c79); }\n              }\n            }\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c80(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c73); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHTML_STRING() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsehtml_raw_string();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c81(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsehtml_raw_string() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 60) {\n      s1 = peg$c82;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c83); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsehtml_char();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsehtml_raw_string();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsehtml_char();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsehtml_raw_string();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s3 = peg$c84;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c85); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c86(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehtml_char() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 62) {\n      s4 = peg$c84;\n      peg$currPos++;\n    } else {\n      s4 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c85); }\n    }\n    if (s4 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 60) {\n        s4 = peg$c82;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c83); }\n      }\n    }\n    peg$silentFails--;\n    if (s4 === peg$FAILED) {\n      s3 = void 0;\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c87); }\n      }\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s2;\n        s3 = peg$c88(s4);\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s4 = peg$c84;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c85); }\n        }\n        if (s4 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 60) {\n            s4 = peg$c82;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c83); }\n          }\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = void 0;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c87); }\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c88(s4);\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c89(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseQUOTED_STRING() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c90;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c91); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseDoubleStringCharacter();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseDoubleStringCharacter();\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s3 = peg$c90;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c91); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c92(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDoubleStringCharacter() {\n    var s0, s1, s2;\n\n    s0 = peg$parseQuoteEscape();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s2 = peg$c90;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c91); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseLineTerminator();\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSourceCharacter();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c93();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseQuoteEscape() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s2 = peg$c94;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c95); }\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c87); }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c96(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseLineContinuation() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c94;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c95); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseLineTerminatorSequence();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c97();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminator() {\n    var s0;\n\n    if (peg$c98.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c99); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminatorSequence() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 10) {\n      s0 = peg$c101;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c102); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c103) {\n        s0 = peg$c103;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c104); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c105;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c106); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8232) {\n            s0 = peg$c107;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c108); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8233) {\n              s0 = peg$c109;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c110); }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c100); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSourceCharacter() {\n    var s0;\n\n    if (input.length > peg$currPos) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c87); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsechars() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsechar();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsechar();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c92(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsechar() {\n    var s0, s1, s2;\n\n    if (peg$c111.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c112); }\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c113) {\n        s1 = peg$c113;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c114); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c115();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s1 = peg$c94;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c95); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseNEWLINE();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c97();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s1 = peg$c94;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c95); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c116();\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCOMMENT() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseBLOCK_COMMENT();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseC_COMMENT();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseMACRO_COMMENT();\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c117); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseBLOCK_COMMENT() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c119) {\n      s1 = peg$c119;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c120); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 2) === peg$c121) {\n        s5 = peg$c121;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c122); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c87); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c123(s5);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c121) {\n          s5 = peg$c121;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c122); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c87); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c123(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c121) {\n          s3 = peg$c121;\n          peg$currPos += 2;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c122); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c124(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c118); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseC_COMMENT() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c126) {\n      s1 = peg$c126;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c127); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (peg$c128.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c129); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c87); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c88(s5);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (peg$c128.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c129); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c87); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c88(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (peg$c128.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c129); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c130(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c125); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMACRO_COMMENT() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c132;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c133); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (peg$c128.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c129); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c87); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c88(s5);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (peg$c128.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c129); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c87); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c88(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (peg$c128.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c129); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c130(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c131); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = peg$parseWHITESPACE();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseCOMMENT();\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWHITESPACE();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseCOMMENT();\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c134); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNEWLINE() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c135.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c136); }\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c135.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c136); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseWHITESPACE() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c137.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c138); }\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseNEWLINE();\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c137.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c138); }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseNEWLINE();\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeLetter() {\n    var s0;\n\n    s0 = peg$parseLu();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseLl();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLt();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseLm();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseLo();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseNl();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLl() {\n    var s0;\n\n    if (peg$c139.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c140); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLm() {\n    var s0;\n\n    if (peg$c141.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c142); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLo() {\n    var s0;\n\n    if (peg$c143.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c144); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLt() {\n    var s0;\n\n    if (peg$c145.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c146); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLu() {\n    var s0;\n\n    if (peg$c147.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c148); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNl() {\n    var s0;\n\n    if (peg$c149.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c150); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNd() {\n    var s0;\n\n    if (peg$c151.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c152); }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","var parser = require('./grammar/dot.js');\nmodule.exports = parser.parse;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./iterable-entry-base\"), exports);\n__exportStar(require(\"./iterable-element-base\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IterableElementBase = void 0;\nclass IterableElementBase {\n    /**\n     * The protected constructor initializes the options for the IterableElementBase class, including the\n     * toElementFn function.\n     * @param [options] - An optional object that contains the following properties:\n     */\n    constructor(options) {\n        if (options) {\n            const { toElementFn } = options;\n            if (typeof toElementFn === 'function')\n                this._toElementFn = toElementFn;\n            else if (toElementFn)\n                throw new TypeError('toElementFn must be a function type');\n        }\n    }\n    /**\n     * The function returns the _toElementFn property, which is a function that converts a raw element to\n     * a specific type.\n     * @returns The function `get toElementFn()` is returning either a function that takes a raw element\n     * `rawElement` of type `R` and returns an element `E`, or `undefined` if no function is assigned to\n     * `_toElementFn`.\n     */\n    get toElementFn() {\n        return this._toElementFn;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function is an implementation of the Symbol.iterator method that returns an IterableIterator.\n     * @param {any[]} args - The `args` parameter in the code snippet represents a rest parameter. It\n     * allows the function to accept any number of arguments as an array. In this case, the `args`\n     * parameter is used to pass any number of arguments to the `_getIterator` method.\n     */\n    *[Symbol.iterator](...args) {\n        yield* this._getIterator(...args);\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The function returns an iterator that yields all the values in the object.\n     */\n    *values() {\n        for (const item of this) {\n            yield item;\n        }\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `every` function checks if every element in the array satisfies a given predicate.\n     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:\n     * the current element being processed, its index, and the array it belongs to. It should return a\n     * boolean value indicating whether the element satisfies a certain condition or not.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be\n     * passed as the `this` value to the `predicate` function. If `thisArg` is\n     * @returns The `every` method is returning a boolean value. It returns `true` if every element in\n     * the array satisfies the provided predicate function, and `false` otherwise.\n     */\n    every(predicate, thisArg) {\n        let index = 0;\n        for (const item of this) {\n            if (!predicate.call(thisArg, item, index++, this)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The \"some\" function checks if at least one element in a collection satisfies a given predicate.\n     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:\n     * `value`, `index`, and `array`. It should return a boolean value indicating whether the current\n     * element satisfies the condition.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as the `this` value when executing the `predicate` function. If `thisArg` is provided,\n     * it will be passed as the `this` value to the `predicate` function. If `thisArg\n     * @returns a boolean value. It returns true if the predicate function returns true for any element\n     * in the collection, and false otherwise.\n     */\n    some(predicate, thisArg) {\n        let index = 0;\n        for (const item of this) {\n            if (predicate.call(thisArg, item, index++, this)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `forEach` function iterates over each element in an array-like object and calls a callback\n     * function for each element.\n     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in\n     * the array. It takes three arguments: the current element being processed, the index of the current\n     * element, and the array that forEach was called upon.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will\n     * be passed as the `this` value to the `callbackfn` function. If `thisArg\n     */\n    forEach(callbackfn, thisArg) {\n        let index = 0;\n        for (const item of this) {\n            callbackfn.call(thisArg, item, index++, this);\n        }\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `find` function iterates over the elements of an array-like object and returns the first\n     * element that satisfies the provided callback function.\n     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in\n     * the array. It takes three arguments: the current element being processed, the index of the current\n     * element, and the array itself. The function should return a boolean value indicating whether the\n     * current element matches the desired condition.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will\n     * be passed as the `this` value to the `callbackfn` function. If `thisArg\n     * @returns The `find` method returns the first element in the array that satisfies the provided\n     * callback function. If no element satisfies the callback function, `undefined` is returned.\n     */\n    find(callbackfn, thisArg) {\n        let index = 0;\n        for (const item of this) {\n            if (callbackfn.call(thisArg, item, index++, this))\n                return item;\n        }\n        return;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function checks if a given element exists in a collection.\n     * @param {E} element - The parameter \"element\" is of type E, which means it can be any type. It\n     * represents the element that we want to check for existence in the collection.\n     * @returns a boolean value. It returns true if the element is found in the collection, and false\n     * otherwise.\n     */\n    has(element) {\n        for (const ele of this) {\n            if (ele === element)\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `reduce` function iterates over the elements of an array-like object and applies a callback\n     * function to reduce them into a single value.\n     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in\n     * the array. It takes four arguments:\n     * @param {U} initialValue - The initialValue parameter is the initial value of the accumulator. It\n     * is the value that the accumulator starts with before the reduction operation begins.\n     * @returns The `reduce` method is returning the final value of the accumulator after iterating over\n     * all the elements in the array and applying the callback function to each element.\n     */\n    reduce(callbackfn, initialValue) {\n        let accumulator = initialValue;\n        let index = 0;\n        for (const item of this) {\n            accumulator = callbackfn(accumulator, item, index++, this);\n        }\n        return accumulator;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The print function logs the elements of an array to the console.\n     */\n    print() {\n        console.log([...this]);\n    }\n}\nexports.IterableElementBase = IterableElementBase;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IterableEntryBase = void 0;\nclass IterableEntryBase {\n    // protected _toEntryFn?: (rawElement: R) => BTNEntry<K, V>;\n    //\n    // /**\n    //  * The function returns the value of the _toEntryFn property.\n    //  * @returns The function being returned is `this._toEntryFn`.\n    //  */\n    // get toEntryFn() {\n    //   return this._toEntryFn;\n    // }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function is an implementation of the Symbol.iterator method that returns an iterable iterator.\n     * @param {any[]} args - The `args` parameter in the code snippet represents a rest parameter. It\n     * allows the function to accept any number of arguments as an array. In this case, the `args`\n     * parameter is used to pass any additional arguments to the `_getIterator` method.\n     */\n    *[Symbol.iterator](...args) {\n        yield* this._getIterator(...args);\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The function returns an iterator that yields key-value pairs from the object, where the value can\n     * be undefined.\n     */\n    *entries() {\n        for (const item of this) {\n            yield item;\n        }\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The function returns an iterator that yields the keys of a data structure.\n     */\n    *keys() {\n        for (const item of this) {\n            yield item[0];\n        }\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The function returns an iterator that yields the values of a collection.\n     */\n    *values() {\n        for (const item of this) {\n            yield item[1];\n        }\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `every` function checks if every element in a collection satisfies a given condition.\n     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:\n     * `value`, `key`, and `index`. It should return a boolean value indicating whether the condition is\n     * met for the current element in the iteration.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be\n     * passed as the first argument to the `predicate` function. If `thisArg` is not provided\n     * @returns The `every` method is returning a boolean value. It returns `true` if every element in\n     * the collection satisfies the provided predicate function, and `false` otherwise.\n     */\n    every(predicate, thisArg) {\n        let index = 0;\n        for (const item of this) {\n            if (!predicate.call(thisArg, item[1], item[0], index++, this)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The \"some\" function iterates over a collection and returns true if at least one element satisfies\n     * a given predicate.\n     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:\n     * `value`, `key`, and `index`. It should return a boolean value indicating whether the condition is\n     * met for the current element in the iteration.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as the `this` value when executing the `predicate` function. If `thisArg` is provided,\n     * it will be passed as the first argument to the `predicate` function. If `thisArg` is\n     * @returns a boolean value. It returns true if the predicate function returns true for any pair in\n     * the collection, and false otherwise.\n     */\n    some(predicate, thisArg) {\n        let index = 0;\n        for (const item of this) {\n            if (predicate.call(thisArg, item[1], item[0], index++, this)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `forEach` function iterates over each key-value pair in a collection and executes a callback\n     * function for each pair.\n     * @param callbackfn - The callback function that will be called for each element in the collection.\n     * It takes four parameters: the value of the current element, the key of the current element, the\n     * index of the current element, and the collection itself.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to\n     * specify the value of `this` within the callback function. If `thisArg` is provided, it will be\n     * used as the `this` value when calling the callback function. If `thisArg` is not provided, `\n     */\n    forEach(callbackfn, thisArg) {\n        let index = 0;\n        for (const item of this) {\n            const [key, value] = item;\n            callbackfn.call(thisArg, value, key, index++, this);\n        }\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `find` function iterates over the entries of a collection and returns the first value for\n     * which the callback function returns true.\n     * @param callbackfn - The callback function that will be called for each entry in the collection. It\n     * takes three arguments: the value of the entry, the key of the entry, and the index of the entry in\n     * the collection. It should return a boolean value indicating whether the current entry matches the\n     * desired condition.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will\n     * be passed as the `this` value to the `callbackfn` function. If `thisArg\n     * @returns The method `find` returns the value of the first element in the iterable that satisfies\n     * the provided callback function. If no element satisfies the callback function, `undefined` is\n     * returned.\n     */\n    find(callbackfn, thisArg) {\n        let index = 0;\n        for (const item of this) {\n            const [key, value] = item;\n            if (callbackfn.call(thisArg, value, key, index++, this))\n                return item;\n        }\n        return;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function checks if a given key exists in a collection.\n     * @param {K} key - The parameter \"key\" is of type K, which means it can be any type. It represents\n     * the key that we want to check for existence in the data structure.\n     * @returns a boolean value. It returns true if the key is found in the collection, and false\n     * otherwise.\n     */\n    has(key) {\n        for (const item of this) {\n            const [itemKey] = item;\n            if (itemKey === key)\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function checks if a given value exists in a collection.\n     * @param {V} value - The parameter \"value\" is the value that we want to check if it exists in the\n     * collection.\n     * @returns a boolean value, either true or false.\n     */\n    hasValue(value) {\n        for (const [, elementValue] of this) {\n            if (elementValue === value)\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `get` function retrieves the value associated with a given key from a collection.\n     * @param {K} key - K (the type of the key) - This parameter represents the key that is being\n     * searched for in the collection.\n     * @returns The `get` method returns the value associated with the specified key if it exists in the\n     * collection, otherwise it returns `undefined`.\n     */\n    get(key) {\n        for (const item of this) {\n            const [itemKey, value] = item;\n            if (itemKey === key)\n                return value;\n        }\n        return;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `reduce` function iterates over key-value pairs and applies a callback function to each pair,\n     * accumulating a single value.\n     * @param callbackfn - The callback function that will be called for each element in the collection.\n     * It takes four arguments: the current accumulator value, the current value of the element, the key\n     * of the element, and the index of the element in the collection. It should return the updated\n     * accumulator value.\n     * @param {U} initialValue - The `initialValue` parameter is the initial value of the accumulator. It\n     * is the value that will be used as the first argument to the `callbackfn` function when reducing\n     * the elements of the collection.\n     * @returns The `reduce` method is returning the final value of the accumulator after iterating over\n     * all the elements in the collection.\n     */\n    reduce(callbackfn, initialValue) {\n        let accumulator = initialValue;\n        let index = 0;\n        for (const item of this) {\n            const [key, value] = item;\n            accumulator = callbackfn(accumulator, value, key, index++, this);\n        }\n        return accumulator;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The print function logs the elements of an array to the console.\n     */\n    print() {\n        console.log([...this]);\n    }\n}\nexports.IterableEntryBase = IterableEntryBase;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DoublyLinkedList = exports.DoublyLinkedListNode = void 0;\nconst base_1 = require(\"../base\");\nclass DoublyLinkedListNode {\n    /**\n     * The constructor function initializes the value, next, and previous properties of an object.\n     * @param {E} value - The \"value\" parameter is the value that will be stored in the node. It can be of any data type, as it\n     * is defined as a generic type \"E\".\n     */\n    constructor(value) {\n        this._value = value;\n        this._next = undefined;\n        this._prev = undefined;\n    }\n    /**\n     * The function returns the value of a protected variable.\n     * @returns The value of the variable `_value` is being returned.\n     */\n    get value() {\n        return this._value;\n    }\n    /**\n     * The above function sets the value of a variable.\n     * @param {E} value - The parameter \"value\" is of type E, which means it can be any type.\n     */\n    set value(value) {\n        this._value = value;\n    }\n    /**\n     * The \"next\" function returns the next node in a doubly linked list.\n     * @returns The `next` property is being returned. It can be either a `DoublyLinkedListNode<E>`\n     * object or `undefined`.\n     */\n    get next() {\n        return this._next;\n    }\n    /**\n     * The \"next\" property of a DoublyLinkedListNode is set to the provided value.\n     * @param {DoublyLinkedListNode<E> | undefined} value - The `value` parameter is of type\n     * `DoublyLinkedListNode<E> | undefined`. This means that it can accept either a\n     * `DoublyLinkedListNode` object or `undefined` as its value.\n     */\n    set next(value) {\n        this._next = value;\n    }\n    /**\n     * The `prev` function returns the previous node in a doubly linked list.\n     * @returns The `prev` property of the `DoublyLinkedListNode` class is being returned. It can either\n     * be a `DoublyLinkedListNode` object or `undefined`.\n     */\n    get prev() {\n        return this._prev;\n    }\n    /**\n     * The function sets the previous node of a doubly linked list node.\n     * @param {DoublyLinkedListNode<E> | undefined} value - The `value` parameter is of type\n     * `DoublyLinkedListNode<E> | undefined`. This means that it can accept either a\n     * `DoublyLinkedListNode` object or `undefined` as its value.\n     */\n    set prev(value) {\n        this._prev = value;\n    }\n}\nexports.DoublyLinkedListNode = DoublyLinkedListNode;\n/**\n * 1. Node Structure: Each node contains three parts: a data field, a pointer (or reference) to the previous node, and a pointer to the next node. This structure allows traversal of the linked list in both directions.\n * 2. Bidirectional Traversal: Unlike singly linked lists, doubly linked lists can be easily traversed forwards or backwards. This makes insertions and deletions in the list more flexible and efficient.\n * 3. No Centralized Index: Unlike arrays, elements in a linked list are not stored contiguously, so there is no centralized index. Accessing elements in a linked list typically requires traversing from the head or tail node.\n * 4. High Efficiency in Insertion and Deletion: Adding or removing elements in a linked list does not require moving other elements, making these operations more efficient than in arrays.\n */\nclass DoublyLinkedList extends base_1.IterableElementBase {\n    constructor(elements = [], options) {\n        super(options);\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        if (elements) {\n            for (const el of elements) {\n                if (this.toElementFn) {\n                    this.push(this.toElementFn(el));\n                }\n                else\n                    this.push(el);\n            }\n        }\n    }\n    /**\n     * The `head` function returns the first node of a doubly linked list.\n     * @returns The method `getHead()` returns either a `DoublyLinkedListNode<E>` object or `undefined`.\n     */\n    get head() {\n        return this._head;\n    }\n    /**\n     * The `tail` function returns the last node of a doubly linked list.\n     * @returns The `get tail()` method is returning either a `DoublyLinkedListNode<E>` object or\n     * `undefined`.\n     */\n    get tail() {\n        return this._tail;\n    }\n    /**\n     * The function returns the size of an object.\n     * @returns The size of the object, which is a number.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     * where n is the number of elements in the linked list.\n     */\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     *\n     * The `get first` function returns the first node in a doubly linked list, or undefined if the list is empty.\n     * @returns The method `get first()` returns the first node of the doubly linked list, or `undefined` if the list is empty.\n     */\n    get first() {\n        var _a;\n        return (_a = this.head) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     *\n     * The `get last` function returns the last node in a doubly linked list, or undefined if the list is empty.\n     * @returns The method `get last()` returns the last node of the doubly linked list, or `undefined` if the list is empty.\n     */\n    get last() {\n        var _a;\n        return (_a = this.tail) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `fromArray` function creates a new instance of a DoublyLinkedList and populates it with the elements from the\n     * given array.\n     * @param {E[]} data - The `data` parameter is an array of elements of type `E`.\n     * @returns The `fromArray` function returns a DoublyLinkedList object.\n     */\n    static fromArray(data) {\n        return new DoublyLinkedList(data);\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * The push function adds a new element to the end of a doubly linked list.\n     * @param {E} element - The \"element\" parameter represents the value that you want to add to the\n     * doubly linked list.\n     * @returns The `push` method is returning a boolean value, `true`.\n     */\n    push(element) {\n        const newNode = new DoublyLinkedListNode(element);\n        if (!this.head) {\n            this._head = newNode;\n            this._tail = newNode;\n        }\n        else {\n            newNode.prev = this.tail;\n            this.tail.next = newNode;\n            this._tail = newNode;\n        }\n        this._size++;\n        return true;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * The `pop()` function removes and returns the value of the last element in a linked list.\n     * @returns The method is returning the value of the removed node.\n     */\n    pop() {\n        if (!this.tail)\n            return undefined;\n        const removedNode = this.tail;\n        if (this.head === this.tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else {\n            this._tail = removedNode.prev;\n            this.tail.next = undefined;\n        }\n        this._size--;\n        return removedNode.value;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * The `shift()` function removes and returns the value of the first element in a doubly linked list.\n     * @returns The value of the removed node.\n     */\n    shift() {\n        if (!this.head)\n            return undefined;\n        const removedNode = this.head;\n        if (this.head === this.tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else {\n            this._head = removedNode.next;\n            this.head.prev = undefined;\n        }\n        this._size--;\n        return removedNode.value;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * The unshift function adds a new element to the beginning of a doubly linked list.\n     * @param {E} element - The \"element\" parameter represents the value of the element that you want to\n     * add to the beginning of the doubly linked list.\n     * @returns The `unshift` method is returning a boolean value, `true`.\n     */\n    unshift(element) {\n        const newNode = new DoublyLinkedListNode(element);\n        if (!this.head) {\n            this._head = newNode;\n            this._tail = newNode;\n        }\n        else {\n            newNode.next = this.head;\n            this.head.prev = newNode;\n            this._head = newNode;\n        }\n        this._size++;\n        return true;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `at` function returns the value at a specified index in a linked list, or undefined if the index is out of bounds.\n     * @param {number} index - The index parameter is a number that represents the position of the element we want to\n     * retrieve from the list.\n     * @returns The method is returning the value at the specified index in the linked list. If the index is out of bounds\n     * or the linked list is empty, it will return undefined.\n     */\n    at(index) {\n        if (index < 0 || index >= this.size)\n            return undefined;\n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        return current.value;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function `getNodeAt` returns the node at a given index in a doubly linked list, or undefined if the index is out of\n     * range.\n     * @param {number} index - The `index` parameter is a number that represents the position of the node we want to\n     * retrieve from the doubly linked list. It indicates the zero-based index of the node we want to access.\n     * @returns The method `getNodeAt(index: number)` returns a `DoublyLinkedListNode<E>` object if the index is within the\n     * valid range of the linked list, otherwise it returns `undefined`.\n     */\n    getNodeAt(index) {\n        if (index < 0 || index >= this.size)\n            return undefined;\n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        return current;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function `findNodeByValue` searches for a node with a specific value in a doubly linked list and returns the\n     * node if found, otherwise it returns undefined.\n     * @param {E} value - The `value` parameter is the value that we want to search for in the doubly linked list.\n     * @returns The function `findNodeByValue` returns a `DoublyLinkedListNode<E>` if a node with the specified value `value`\n     * is found in the linked list. If no such node is found, it returns `undefined`.\n     */\n    getNode(value) {\n        let current = this.head;\n        while (current) {\n            if (current.value === value) {\n                return current;\n            }\n            current = current.next;\n        }\n        return undefined;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `insert` function inserts a value at a specified index in a doubly linked list.\n     * @param {number} index - The index parameter represents the position at which the new value should be inserted in the\n     * DoublyLinkedList. It is of type number.\n     * @param {E} value - The `value` parameter represents the value that you want to insert into the Doubly Linked List at the\n     * specified index.\n     * @returns The `insert` method returns a boolean value. It returns `true` if the insertion is successful, and `false`\n     * if the index is out of bounds.\n     */\n    addAt(index, value) {\n        if (index < 0 || index > this.size)\n            return false;\n        if (index === 0) {\n            this.unshift(value);\n            return true;\n        }\n        if (index === this.size) {\n            this.push(value);\n            return true;\n        }\n        const newNode = new DoublyLinkedListNode(value);\n        const prevNode = this.getNodeAt(index - 1);\n        const nextNode = prevNode.next;\n        newNode.prev = prevNode;\n        newNode.next = nextNode;\n        prevNode.next = newNode;\n        nextNode.prev = newNode;\n        this._size++;\n        return true;\n    }\n    /**\n     * Time Complexity: O(1) or O(n)\n     * Space Complexity: O(1)\n     * where n is the number of elements in the linked list.\n     */\n    /**\n     * Time Complexity: O(1) or O(n)\n     * Space Complexity: O(1)\n     *\n     * The `addBefore` function inserts a new value before an existing value or node in a doubly linked list.\n     * @param {E | DoublyLinkedListNode<E>} existingValueOrNode - The existing value or node in the doubly linked list\n     * before which the new value will be inserted. It can be either the value of the existing node or the existing node\n     * itself.\n     * @param {E} newValue - The `newValue` parameter represents the value that you want to insert into the doubly linked\n     * list.\n     * @returns The method returns a boolean value. It returns `true` if the insertion is successful, and `false` if the\n     * insertion fails.\n     */\n    addBefore(existingValueOrNode, newValue) {\n        let existingNode;\n        if (existingValueOrNode instanceof DoublyLinkedListNode) {\n            existingNode = existingValueOrNode;\n        }\n        else {\n            existingNode = this.getNode(existingValueOrNode);\n        }\n        if (existingNode) {\n            const newNode = new DoublyLinkedListNode(newValue);\n            newNode.prev = existingNode.prev;\n            if (existingNode.prev) {\n                existingNode.prev.next = newNode;\n            }\n            newNode.next = existingNode;\n            existingNode.prev = newNode;\n            if (existingNode === this.head) {\n                this._head = newNode;\n            }\n            this._size++;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(1) or O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1) or O(n)\n     * Space Complexity: O(1)\n     *\n     * The `addAfter` function inserts a new node with a given value after an existing node in a doubly linked list.\n     * @param {E | DoublyLinkedListNode<E>} existingValueOrNode - The existing value or node in the doubly linked list\n     * after which the new value will be inserted. It can be either the value of the existing node or the existing node\n     * itself.\n     * @param {E} newValue - The value that you want to insert into the doubly linked list.\n     * @returns The method returns a boolean value. It returns true if the insertion is successful, and false if the\n     * existing value or node is not found in the doubly linked list.\n     */\n    addAfter(existingValueOrNode, newValue) {\n        let existingNode;\n        if (existingValueOrNode instanceof DoublyLinkedListNode) {\n            existingNode = existingValueOrNode;\n        }\n        else {\n            existingNode = this.getNode(existingValueOrNode);\n        }\n        if (existingNode) {\n            const newNode = new DoublyLinkedListNode(newValue);\n            newNode.next = existingNode.next;\n            if (existingNode.next) {\n                existingNode.next.prev = newNode;\n            }\n            newNode.prev = existingNode;\n            existingNode.next = newNode;\n            if (existingNode === this.tail) {\n                this._tail = newNode;\n            }\n            this._size++;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `deleteAt` function removes an element at a specified index from a linked list and returns the removed element.\n     * @param {number} index - The index parameter represents the position of the element that needs to be deleted in the\n     * data structure. It is of type number.\n     * @returns The method `deleteAt` returns the value of the node that was deleted, or `undefined` if the index is out of\n     * bounds.\n     */\n    deleteAt(index) {\n        if (index < 0 || index >= this.size)\n            return false;\n        if (index === 0) {\n            this.shift();\n            return true;\n        }\n        if (index === this.size - 1) {\n            this.pop();\n            return true;\n        }\n        const removedNode = this.getNodeAt(index);\n        const prevNode = removedNode.prev;\n        const nextNode = removedNode.next;\n        prevNode.next = nextNode;\n        nextNode.prev = prevNode;\n        this._size--;\n        return true;\n    }\n    /**\n     * Time Complexity: O(1) or O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1) or O(n)\n     * Space Complexity: O(1)\n     *\n     * The `delete` function removes a node from a doubly linked list based on either the node itself or its value.\n     * @param {E | DoublyLinkedListNode<E>} valOrNode - The `valOrNode` parameter can accept either a value of type `E` or\n     * a `DoublyLinkedListNode<E>` object.\n     * @returns The `delete` method returns a boolean value. It returns `true` if the value or node was successfully\n     * deleted from the doubly linked list, and `false` if the value or node was not found in the list.\n     */\n    delete(valOrNode) {\n        let node;\n        if (valOrNode instanceof DoublyLinkedListNode) {\n            node = valOrNode;\n        }\n        else {\n            node = this.getNode(valOrNode);\n        }\n        if (node) {\n            if (node === this.head) {\n                this.shift();\n            }\n            else if (node === this.tail) {\n                this.pop();\n            }\n            else {\n                const prevNode = node.prev;\n                const nextNode = node.next;\n                prevNode.next = nextNode;\n                nextNode.prev = prevNode;\n                this._size--;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     *\n     * The function checks if a variable has a size greater than zero and returns a boolean value.\n     * @returns A boolean value is being returned.\n     */\n    isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     *\n     * The `clear` function resets the linked list by setting the head, tail, and size to undefined and 0 respectively.\n     */\n    clear() {\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function returns the index of the first occurrence of a given value in a linked list.\n     * @param {E} value - The parameter `value` is of type `E`, which means it can be any data type. It represents the value\n     * that we are searching for in the linked list.\n     * @returns The method `indexOf` returns the index of the first occurrence of the specified value `value` in the linked\n     * list. If the value is not found, it returns -1.\n     */\n    indexOf(value) {\n        let index = 0;\n        let current = this.head;\n        while (current) {\n            if (current.value === value) {\n                return index;\n            }\n            index++;\n            current = current.next;\n        }\n        return -1;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `findBackward` function iterates through a linked list from the last node to the first node and returns the last\n     * value that satisfies the given callback function, or undefined if no value satisfies the callback.\n     * @param callback - A function that takes a value of type E as its parameter and returns a boolean value. This\n     * function is used to determine whether a given value satisfies a certain condition.\n     * @returns The method `findBackward` returns the last value in the linked list that satisfies the condition specified by\n     * the callback function. If no value satisfies the condition, it returns `undefined`.\n     */\n    findBackward(callback) {\n        let current = this.tail;\n        while (current) {\n            if (callback(current.value)) {\n                return current.value;\n            }\n            current = current.prev;\n        }\n        return undefined;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `reverse` function reverses the order of the elements in a doubly linked list.\n     */\n    reverse() {\n        let current = this.head;\n        [this._head, this._tail] = [this.tail, this.head];\n        while (current) {\n            const next = current.next;\n            [current.prev, current.next] = [current.next, current.prev];\n            current = next;\n        }\n        return this;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `toArray` function converts a linked list into an array.\n     * @returns The `toArray()` method is returning an array of type `E[]`.\n     */\n    toArray() {\n        const array = [];\n        let current = this.head;\n        while (current) {\n            array.push(current.value);\n            current = current.next;\n        }\n        return array;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `toReversedArray` function converts a doubly linked list into an array in reverse order.\n     * @returns The `toReversedArray()` function returns an array of type `E[]`.\n     */\n    toReversedArray() {\n        const array = [];\n        let current = this.tail;\n        while (current) {\n            array.push(current.value);\n            current = current.prev;\n        }\n        return array;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `clone` function creates a new instance of the `DoublyLinkedList` class with the same values\n     * as the original list.\n     * @returns The `clone()` method is returning a new instance of the `DoublyLinkedList` class, which\n     * is a copy of the original list.\n     */\n    clone() {\n        return new DoublyLinkedList(this);\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `filter` function creates a new DoublyLinkedList by iterating over the elements of the current\n     * list and applying a callback function to each element, returning only the elements for which the\n     * callback function returns true.\n     * @param callback - The `callback` parameter is a function that will be called for each element in\n     * the DoublyLinkedList. It takes three arguments: the current element, the index of the current\n     * element, and the DoublyLinkedList itself. The callback function should return a boolean value\n     * indicating whether the current element should be included\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be\n     * passed as the `this` value to the `callback` function. If `thisArg` is\n     * @returns The `filter` method is returning a new `DoublyLinkedList` object that contains the\n     * elements that pass the filter condition specified by the `callback` function.\n     */\n    filter(callback, thisArg) {\n        const filteredList = new DoublyLinkedList([], { toElementFn: this.toElementFn });\n        let index = 0;\n        for (const current of this) {\n            if (callback.call(thisArg, current, index, this)) {\n                filteredList.push(current);\n            }\n            index++;\n        }\n        return filteredList;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * The `map` function takes a callback function and returns a new DoublyLinkedList with the results\n     * of applying the callback to each element in the original list.\n     * @param callback - The callback parameter is a function that will be called for each element in the\n     * original DoublyLinkedList. It takes three arguments: current (the current element being\n     * processed), index (the index of the current element), and this (the original DoublyLinkedList).\n     * The callback function should return a value of type\n     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to\n     * convert the raw element (`RR`) to the desired element type (`T`). It takes the raw element as\n     * input and returns the converted element. If this parameter is not provided, the raw element will\n     * be used as is.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to\n     * specify the value of `this` within the callback function. It is used to set the context or scope\n     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the\n     * value of\n     * @returns a new instance of the `DoublyLinkedList` class with elements of type `T` and `RR`.\n     */\n    map(callback, toElementFn, thisArg) {\n        const mappedList = new DoublyLinkedList([], { toElementFn });\n        let index = 0;\n        for (const current of this) {\n            mappedList.push(callback.call(thisArg, current, index, this));\n            index++;\n        }\n        return mappedList;\n    }\n    /**\n     * The function returns an iterator that iterates over the values of a linked list.\n     */\n    *_getIterator() {\n        let current = this.head;\n        while (current) {\n            yield current.value;\n            current = current.next;\n        }\n    }\n}\nexports.DoublyLinkedList = DoublyLinkedList;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./singly-linked-list\"), exports);\n__exportStar(require(\"./doubly-linked-list\"), exports);\n__exportStar(require(\"./skip-linked-list\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SinglyLinkedList = exports.SinglyLinkedListNode = void 0;\nconst base_1 = require(\"../base\");\nclass SinglyLinkedListNode {\n    /**\n     * The constructor function initializes an instance of a class with a given value and sets the next property to undefined.\n     * @param {E} value - The \"value\" parameter is of type E, which means it can be any data type. It represents the value that\n     * will be stored in the node of a linked list.\n     */\n    constructor(value) {\n        this._value = value;\n        this._next = undefined;\n    }\n    /**\n     * The function returns the value of a protected variable.\n     * @returns The value of the variable `_value` is being returned.\n     */\n    get value() {\n        return this._value;\n    }\n    /**\n     * The above function sets the value of a variable.\n     * @param {E} value - The parameter \"value\" is of type E, which means it can be any type.\n     */\n    set value(value) {\n        this._value = value;\n    }\n    /**\n     * The `next` function returns the next node in a singly linked list.\n     * @returns The `next` property is being returned. It can be either a `SinglyLinkedListNode<E>`\n     * object or `undefined`.\n     */\n    get next() {\n        return this._next;\n    }\n    /**\n     * The \"next\" property of a SinglyLinkedListNode is set to the provided value.\n     * @param {SinglyLinkedListNode<E> | undefined} value - The `value` parameter is of type\n     * `SinglyLinkedListNode<E> | undefined`. This means that it can accept either a\n     * `SinglyLinkedListNode` object or `undefined` as its value.\n     */\n    set next(value) {\n        this._next = value;\n    }\n}\nexports.SinglyLinkedListNode = SinglyLinkedListNode;\nclass SinglyLinkedList extends base_1.IterableElementBase {\n    constructor(elements = [], options) {\n        super(options);\n        this._size = 0;\n        if (elements) {\n            for (const el of elements) {\n                if (this.toElementFn) {\n                    this.push(this.toElementFn(el));\n                }\n                else {\n                    this.push(el);\n                }\n            }\n        }\n    }\n    /**\n     * The `head` function returns the first node of a singly linked list.\n     * @returns The method is returning either a SinglyLinkedListNode object or undefined.\n     */\n    get head() {\n        return this._head;\n    }\n    /**\n     * The `tail` function returns the last node of a singly linked list.\n     * @returns The method is returning either a SinglyLinkedListNode object or undefined.\n     */\n    get tail() {\n        return this._tail;\n    }\n    /**\n     * The above function returns the value of the first element in a linked list, or undefined if the\n     * list is empty.\n     * @returns The value of the first node in the linked list, or undefined if the linked list is empty.\n     */\n    get first() {\n        var _a;\n        return (_a = this.head) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    /**\n     * The function returns the value of the last element in a linked list, or undefined if the list is\n     * empty.\n     * @returns The value of the last node in the linked list, or undefined if the linked list is empty.\n     */\n    get last() {\n        var _a;\n        return (_a = this.tail) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    /**\n     * The function returns the size of an object.\n     * @returns The size of the object, which is a number.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     * Linear time, where n is the length of the input array, as it performs a loop to push each element into the linked list.\n     * Linear space, as it creates a new node for each element in the array.\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `fromArray` function creates a new SinglyLinkedList instance and populates it with the elements from the given\n     * array.\n     * @param {E[]} data - The `data` parameter is an array of elements of type `E`.\n     * @returns The `fromArray` function returns a `SinglyLinkedList` object.\n     */\n    static fromArray(data) {\n        const singlyLinkedList = new SinglyLinkedList();\n        for (const item of data) {\n            singlyLinkedList.push(item);\n        }\n        return singlyLinkedList;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     *\n     * The push function adds a new element to the end of a singly linked list.\n     * @param {E} element - The \"element\" parameter represents the value of the element that you want to\n     * add to the linked list.\n     * @returns The `push` method is returning a boolean value, `true`.\n     */\n    push(element) {\n        const newNode = new SinglyLinkedListNode(element);\n        if (!this.head) {\n            this._head = newNode;\n            this._tail = newNode;\n        }\n        else {\n            this.tail.next = newNode;\n            this._tail = newNode;\n        }\n        this._size++;\n        return true;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     * Linear time in the worst case, as it may need to traverse the list to find the last element.\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `pop` function removes and returns the value of the last element in a linked list.\n     * @returns The method is returning the value of the element that is being popped from the end of the\n     * list.\n     */\n    pop() {\n        if (!this.head)\n            return undefined;\n        if (this.head === this.tail) {\n            const value = this.head.value;\n            this._head = undefined;\n            this._tail = undefined;\n            this._size--;\n            return value;\n        }\n        let current = this.head;\n        while (current.next !== this.tail) {\n            current = current.next;\n        }\n        const value = this.tail.value;\n        current.next = undefined;\n        this._tail = current;\n        this._size--;\n        return value;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     *\n     * The `shift()` function removes and returns the value of the first element in a linked list.\n     * @returns The value of the removed node.\n     */\n    shift() {\n        if (!this.head)\n            return undefined;\n        const removedNode = this.head;\n        this._head = this.head.next;\n        this._size--;\n        return removedNode.value;\n    }\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     *\n     * The unshift function adds a new element to the beginning of a singly linked list.\n     * @param {E} element - The \"element\" parameter represents the value of the element that you want to\n     * add to the beginning of the singly linked list.\n     * @returns The `unshift` method is returning a boolean value, `true`.\n     */\n    unshift(element) {\n        const newNode = new SinglyLinkedListNode(element);\n        if (!this.head) {\n            this._head = newNode;\n            this._tail = newNode;\n        }\n        else {\n            newNode.next = this.head;\n            this._head = newNode;\n        }\n        this._size++;\n        return true;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function `at` returns the value at a specified index in a linked list, or undefined if the index is out of range.\n     * @param {number} index - The index parameter is a number that represents the position of the element we want to\n     * retrieve from the list.\n     * @returns The method `at(index: number): E | undefined` returns the value at the specified index in the linked list, or\n     * `undefined` if the index is out of bounds.\n     */\n    at(index) {\n        if (index < 0 || index >= this.size)\n            return undefined;\n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        return current.value;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function `getNodeAt` returns the node at a given index in a singly linked list.\n     * @param {number} index - The `index` parameter is a number that represents the position of the node we want to\n     * retrieve from the linked list. It indicates the zero-based index of the node we want to access.\n     * @returns The method `getNodeAt(index: number)` returns a `SinglyLinkedListNode<E>` object if the node at the\n     * specified index exists, or `undefined` if the index is out of bounds.\n     */\n    getNodeAt(index) {\n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        return current;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `deleteAt` function removes an element at a specified index from a linked list and returns the removed element.\n     * @param {number} index - The index parameter represents the position of the element that needs to be deleted in the\n     * data structure. It is of type number.\n     * @returns The method `deleteAt` returns the value of the node that was deleted, or `undefined` if the index is out of\n     * bounds.\n     */\n    deleteAt(index) {\n        if (index < 0 || index >= this.size)\n            return false;\n        if (index === 0) {\n            this.shift();\n            return true;\n        }\n        if (index === this.size - 1) {\n            this.pop();\n            return true;\n        }\n        const prevNode = this.getNodeAt(index - 1);\n        const removedNode = prevNode.next;\n        prevNode.next = removedNode.next;\n        this._size--;\n        return true;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The delete function removes a node with a specific value from a singly linked list.\n     * @param {E | SinglyLinkedListNode<E>} valueOrNode - The `valueOrNode` parameter can accept either a value of type `E`\n     * or a `SinglyLinkedListNode<E>` object.\n     * @returns The `delete` method returns a boolean value. It returns `true` if the value or node is found and\n     * successfully deleted from the linked list, and `false` if the value or node is not found in the linked list.\n     */\n    delete(valueOrNode) {\n        if (!valueOrNode)\n            return false;\n        let value;\n        if (valueOrNode instanceof SinglyLinkedListNode) {\n            value = valueOrNode.value;\n        }\n        else {\n            value = valueOrNode;\n        }\n        let current = this.head, prev = undefined;\n        while (current) {\n            if (current.value === value) {\n                if (prev === undefined) {\n                    this._head = current.next;\n                    if (current === this.tail) {\n                        this._tail = undefined;\n                    }\n                }\n                else {\n                    prev.next = current.next;\n                    if (current === this.tail) {\n                        this._tail = prev;\n                    }\n                }\n                this._size--;\n                return true;\n            }\n            prev = current;\n            current = current.next;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `addAt` function inserts a value at a specified index in a singly linked list.\n     * @param {number} index - The index parameter represents the position at which the new value should be inserted in the\n     * linked list. It is of type number.\n     * @param {E} value - The `value` parameter represents the value that you want to insert into the linked list at the\n     * specified index.\n     * @returns The `insert` method returns a boolean value. It returns `true` if the insertion is successful, and `false`\n     * if the index is out of bounds.\n     */\n    addAt(index, value) {\n        if (index < 0 || index > this.size)\n            return false;\n        if (index === 0) {\n            this.unshift(value);\n            return true;\n        }\n        if (index === this.size) {\n            this.push(value);\n            return true;\n        }\n        const newNode = new SinglyLinkedListNode(value);\n        const prevNode = this.getNodeAt(index - 1);\n        newNode.next = prevNode.next;\n        prevNode.next = newNode;\n        this._size++;\n        return true;\n    }\n    /**\n     * The function checks if the length of a data structure is equal to zero and returns a boolean value indicating\n     * whether it is empty or not.\n     * @returns A boolean value indicating whether the length of the object is equal to 0.\n     */\n    isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * The `clear` function resets the linked list by setting the head, tail, and length to undefined and 0 respectively.\n     */\n    clear() {\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     * Linear time, where n is the length of the list, as it needs to traverse the entire list to convert it to an array.\n     * Linear space, as it creates an array with the same length as the list.\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `toArray` function converts a linked list into an array.\n     * @returns The `toArray()` method is returning an array of type `E[]`.\n     */\n    toArray() {\n        const array = [];\n        let current = this.head;\n        while (current) {\n            array.push(current.value);\n            current = current.next;\n        }\n        return array;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `reverse` function reverses the order of the nodes in a singly linked list.\n     * @returns The reverse() method does not return anything. It has a return type of void.\n     */\n    reverse() {\n        if (!this.head || this.head === this.tail)\n            return this;\n        let prev = undefined;\n        let current = this.head;\n        let next = undefined;\n        while (current) {\n            next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        [this._head, this._tail] = [this.tail, this.head];\n        return this;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `indexOf` function returns the index of the first occurrence of a given value in a linked list.\n     * @param {E} value - The value parameter is the value that you want to find the index of in the linked list.\n     * @returns The method is returning the index of the first occurrence of the specified value in the linked list. If the\n     * value is not found, it returns -1.\n     */\n    indexOf(value) {\n        let index = 0;\n        let current = this.head;\n        while (current) {\n            if (current.value === value) {\n                return index;\n            }\n            index++;\n            current = current.next;\n        }\n        return -1;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function finds a node in a singly linked list by its value and returns the node if found, otherwise returns\n     * undefined.\n     * @param {E} value - The value parameter is the value that we want to search for in the linked list.\n     * @returns a `SinglyLinkedListNode<E>` if a node with the specified value is found in the linked list. If no node with\n     * the specified value is found, the function returns `undefined`.\n     */\n    getNode(value) {\n        let current = this.head;\n        while (current) {\n            if (current.value === value) {\n                return current;\n            }\n            current = current.next;\n        }\n        return undefined;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `addBefore` function inserts a new value before an existing value in a singly linked list.\n     * @param {E | SinglyLinkedListNode<E>} existingValueOrNode - The existing value or node that you want to insert the\n     * new value before. It can be either the value itself or a node containing the value in the linked list.\n     * @param {E} newValue - The `newValue` parameter represents the value that you want to insert into the linked list.\n     * @returns The method `addBefore` returns a boolean value. It returns `true` if the new value was successfully\n     * inserted before the existing value, and `false` otherwise.\n     */\n    addBefore(existingValueOrNode, newValue) {\n        if (!this.head)\n            return false;\n        let existingValue;\n        if (existingValueOrNode instanceof SinglyLinkedListNode) {\n            existingValue = existingValueOrNode.value;\n        }\n        else {\n            existingValue = existingValueOrNode;\n        }\n        if (this.head.value === existingValue) {\n            this.unshift(newValue);\n            return true;\n        }\n        let current = this.head;\n        while (current.next) {\n            if (current.next.value === existingValue) {\n                const newNode = new SinglyLinkedListNode(newValue);\n                newNode.next = current.next;\n                current.next = newNode;\n                this._size++;\n                return true;\n            }\n            current = current.next;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The `addAfter` function inserts a new node with a given value after an existing node in a singly linked list.\n     * @param {E | SinglyLinkedListNode<E>} existingValueOrNode - The existing value or node in the linked list after which\n     * the new value will be inserted. It can be either the value of the existing node or the existing node itself.\n     * @param {E} newValue - The value that you want to insert into the linked list after the existing value or node.\n     * @returns The method returns a boolean value. It returns true if the new value was successfully inserted after the\n     * existing value or node, and false if the existing value or node was not found in the linked list.\n     */\n    addAfter(existingValueOrNode, newValue) {\n        let existingNode;\n        if (existingValueOrNode instanceof SinglyLinkedListNode) {\n            existingNode = existingValueOrNode;\n        }\n        else {\n            existingNode = this.getNode(existingValueOrNode);\n        }\n        if (existingNode) {\n            const newNode = new SinglyLinkedListNode(newValue);\n            newNode.next = existingNode.next;\n            existingNode.next = newNode;\n            if (existingNode === this.tail) {\n                this._tail = newNode;\n            }\n            this._size++;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * The function counts the number of occurrences of a given value in a linked list.\n     * @param {E} value - The value parameter is the value that you want to count the occurrences of in the linked list.\n     * @returns The count of occurrences of the given value in the linked list.\n     */\n    countOccurrences(value) {\n        let count = 0;\n        let current = this.head;\n        while (current) {\n            if (current.value === value) {\n                count++;\n            }\n            current = current.next;\n        }\n        return count;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `clone` function returns a new instance of the `SinglyLinkedList` class with the same values\n     * as the original list.\n     * @returns The `clone()` method is returning a new instance of the `SinglyLinkedList` class, which\n     * is a clone of the original list.\n     */\n    clone() {\n        return new SinglyLinkedList(this, { toElementFn: this.toElementFn });\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * The `filter` function creates a new SinglyLinkedList by iterating over the elements of the current\n     * list and applying a callback function to each element to determine if it should be included in the\n     * filtered list.\n     * @param callback - The callback parameter is a function that will be called for each element in the\n     * list. It takes three arguments: the current element, the index of the current element, and the\n     * list itself. The callback function should return a boolean value indicating whether the current\n     * element should be included in the filtered list or not\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value\n     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be\n     * passed as the `this` value to the `callback` function. If `thisArg` is\n     * @returns The `filter` method is returning a new `SinglyLinkedList` object that contains the\n     * elements that pass the filter condition specified by the `callback` function.\n     */\n    filter(callback, thisArg) {\n        const filteredList = new SinglyLinkedList([], { toElementFn: this.toElementFn });\n        let index = 0;\n        for (const current of this) {\n            if (callback.call(thisArg, current, index, this)) {\n                filteredList.push(current);\n            }\n            index++;\n        }\n        return filteredList;\n    }\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     */\n    /**\n     * The `map` function takes a callback function and returns a new SinglyLinkedList with the results\n     * of applying the callback to each element in the original list.\n     * @param callback - The `callback` parameter is a function that will be called for each element in\n     * the original list. It takes three arguments: `current` (the current element being processed),\n     * `index` (the index of the current element), and `this` (the original list). It should return a\n     * value\n     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to\n     * convert the raw element (`RR`) to the desired element type (`T`). It takes the raw element as\n     * input and returns the converted element. If this parameter is not provided, the raw element will\n     * be used as is.\n     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to\n     * specify the value of `this` within the callback function. It is used to set the context or scope\n     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the\n     * value of\n     * @returns a new instance of the `SinglyLinkedList` class with the mapped elements.\n     */\n    map(callback, toElementFn, thisArg) {\n        const mappedList = new SinglyLinkedList([], { toElementFn });\n        let index = 0;\n        for (const current of this) {\n            mappedList.push(callback.call(thisArg, current, index, this));\n            index++;\n        }\n        return mappedList;\n    }\n    /**\n     * The function `_getIterator` returns an iterable iterator that yields the values of a linked list.\n     */\n    *_getIterator() {\n        let current = this.head;\n        while (current) {\n            yield current.value;\n            current = current.next;\n        }\n    }\n}\nexports.SinglyLinkedList = SinglyLinkedList;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SkipList = exports.SkipListNode = void 0;\nclass SkipListNode {\n    constructor(key, value, level) {\n        this.key = key;\n        this.value = value;\n        this.forward = new Array(level);\n    }\n}\nexports.SkipListNode = SkipListNode;\nclass SkipList {\n    /**\n     * The constructor function initializes a SkipLinkedList object with optional options and elements.\n     * @param elements - The `elements` parameter is an iterable containing key-value pairs `[K, V]`. It\n     * is used to initialize the SkipLinkedList with the given key-value pairs. If no elements are\n     * provided, the SkipLinkedList will be empty.\n     * @param {SkipLinkedListOptions} [options] - The `options` parameter is an optional object that can\n     * contain two properties:\n     */\n    constructor(elements = [], options) {\n        this._head = new SkipListNode(undefined, undefined, this.maxLevel);\n        this._level = 0;\n        this._maxLevel = 16;\n        this._probability = 0.5;\n        if (options) {\n            const { maxLevel, probability } = options;\n            if (typeof maxLevel === 'number')\n                this._maxLevel = maxLevel;\n            if (typeof probability === 'number')\n                this._probability = probability;\n        }\n        if (elements) {\n            for (const [key, value] of elements)\n                this.add(key, value);\n        }\n    }\n    /**\n     * The function returns the head node of a SkipList.\n     * @returns The method is returning a SkipListNode object with generic key type K and value type V.\n     */\n    get head() {\n        return this._head;\n    }\n    /**\n     * The function returns the value of the protected variable _level.\n     * @returns The level property of the object.\n     */\n    get level() {\n        return this._level;\n    }\n    /**\n     * The function returns the maximum level.\n     * @returns The value of the variable `_maxLevel` is being returned.\n     */\n    get maxLevel() {\n        return this._maxLevel;\n    }\n    /**\n     * The function returns the probability value.\n     * @returns The probability value stored in the protected variable `_probability` is being returned.\n     */\n    get probability() {\n        return this._probability;\n    }\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(1)\n     * Space Complexity: O(1)\n     *\n     * Get the value of the first element (the smallest element) in the Skip List.\n     * @returns The value of the first element, or undefined if the Skip List is empty.\n     */\n    get first() {\n        const firstNode = this.head.forward[0];\n        return firstNode ? firstNode.value : undefined;\n    }\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     *\n     * Get the value of the last element (the largest element) in the Skip List.\n     * @returns The value of the last element, or undefined if the Skip List is empty.\n     */\n    get last() {\n        let current = this.head;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i]) {\n                current = current.forward[i];\n            }\n        }\n        return current.value;\n    }\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     *\n     * The add function adds a new node with a given key and value to a Skip List data structure.\n     * @param {K} key - The key parameter represents the key of the node that needs to be added to the skip list.\n     * @param {V} value - The \"value\" parameter represents the value associated with the key that is being added to the Skip\n     * List.\n     */\n    add(key, value) {\n        const newNode = new SkipListNode(key, value, this._randomLevel());\n        const update = new Array(this.maxLevel).fill(this.head);\n        let current = this.head;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i] && current.forward[i].key < key) {\n                current = current.forward[i];\n            }\n            update[i] = current;\n        }\n        for (let i = 0; i < newNode.forward.length; i++) {\n            newNode.forward[i] = update[i].forward[i];\n            update[i].forward[i] = newNode;\n        }\n        if (!newNode.forward[0]) {\n            this._level = Math.max(this.level, newNode.forward.length);\n        }\n    }\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     *\n     * The function `get` retrieves the value associated with a given key from a skip list data structure.\n     * @param {K} key - The `key` parameter is the key of the element that we want to retrieve from the data structure.\n     * @returns The method `get(key: K)` returns the value associated with the given key if it exists in the data structure,\n     * otherwise it returns `undefined`.\n     */\n    get(key) {\n        let current = this.head;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i] && current.forward[i].key < key) {\n                current = current.forward[i];\n            }\n        }\n        current = current.forward[0];\n        if (current && current.key === key) {\n            return current.value;\n        }\n        return undefined;\n    }\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * The function checks if a key exists in a data structure.\n     * @param {K} key - The parameter \"key\" is of type K, which represents the type of the key being\n     * checked.\n     * @returns a boolean value.\n     */\n    has(key) {\n        return this.get(key) !== undefined;\n    }\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     *\n     * The `delete` function removes a node with a specific key from a Skip List data structure.\n     * @param {K} key - The key parameter represents the key of the node that needs to be removed from the skip list.\n     * @returns The `delete` method returns a boolean value. It returns `true` if the key was successfully removed from the\n     * skip list, and `false` if the key was not found in the skip list.\n     */\n    delete(key) {\n        const update = new Array(this.maxLevel).fill(this.head);\n        let current = this.head;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i] && current.forward[i].key < key) {\n                current = current.forward[i];\n            }\n            update[i] = current;\n        }\n        current = current.forward[0];\n        if (current && current.key === key) {\n            for (let i = 0; i < this.level; i++) {\n                if (update[i].forward[i] !== current) {\n                    break;\n                }\n                update[i].forward[i] = current.forward[i];\n            }\n            while (this.level > 0 && !this.head.forward[this.level - 1]) {\n                this._level--;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     *\n     * Get the value of the first element in the Skip List that is greater than the given key.\n     * @param key - the given key.\n     * @returns The value of the first element greater than the given key, or undefined if there is no such element.\n     */\n    higher(key) {\n        let current = this.head;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i] && current.forward[i].key <= key) {\n                current = current.forward[i];\n            }\n        }\n        const nextNode = current.forward[0];\n        return nextNode ? nextNode.value : undefined;\n    }\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     */\n    /**\n     * Time Complexity: O(log n)\n     * Space Complexity: O(1)\n     *\n     * Get the value of the last element in the Skip List that is less than the given key.\n     * @param key - the given key.\n     * @returns The value of the last element less than the given key, or undefined if there is no such element.\n     */\n    lower(key) {\n        let current = this.head;\n        let lastLess = undefined;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i] && current.forward[i].key < key) {\n                current = current.forward[i];\n            }\n            if (current.key < key) {\n                lastLess = current;\n            }\n        }\n        return lastLess ? lastLess.value : undefined;\n    }\n    /**\n     * Time Complexity: O(maxLevel)\n     * Space Complexity: O(1)\n     * where maxLevel is the maximum level of the SkipList, as it may iterate up to maxLevel times in the worst case.\n     */\n    /**\n     * Time Complexity: O(maxLevel)\n     * Space Complexity: O(1)\n     *\n     * The function \"_randomLevel\" generates a random level based on a given probability and maximum level.\n     * @returns the level, which is a number.\n     */\n    _randomLevel() {\n        let level = 1;\n        while (Math.random() < this.probability && level < this.maxLevel) {\n            level++;\n        }\n        return level;\n    }\n}\nexports.SkipList = SkipList;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\n// export { DoublyLinkedListNode, DoublyLinkedList, SinglyLinkedListNode, SinglyLinkedList } from 'data-structure-typed';\n__exportStar(require(\"./data-structures/linked-list\"), exports);\n__exportStar(require(\"./types/data-structures/linked-list\"), exports);\n__exportStar(require(\"./types/common\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./singly-linked-list\"), exports);\n__exportStar(require(\"./doubly-linked-list\"), exports);\n__exportStar(require(\"./skip-linked-list\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass LinkedList {\n    constructor(...values) {\n        this._head = this._tail = null;\n        this._length = 0;\n        if (values.length > 0) {\n            values.forEach((value) => {\n                this.append(value);\n            });\n        }\n    }\n    *iterator() {\n        let currentItem = this._head;\n        while (currentItem) {\n            yield currentItem.value;\n            currentItem = currentItem.next;\n        }\n    }\n    [Symbol.iterator]() {\n        return this.iterator();\n    }\n    get head() {\n        return this._head ? this._head.value : null;\n    }\n    get tail() {\n        return this._tail ? this._tail.value : null;\n    }\n    get length() {\n        return this._length;\n    }\n    // Adds the element at a specific position inside the linked list\n    insert(val, previousItem, checkDuplicates = false) {\n        if (checkDuplicates && this.isDuplicate(val)) {\n            return false;\n        }\n        let newItem = new LinkedListItem(val);\n        let currentItem = this._head;\n        if (!currentItem) {\n            return false;\n        }\n        else {\n            while (true) {\n                if (currentItem.value === previousItem) {\n                    newItem.next = currentItem.next;\n                    newItem.prev = currentItem;\n                    currentItem.next = newItem;\n                    if (newItem.next) {\n                        newItem.next.prev = newItem;\n                    }\n                    else {\n                        this._tail = newItem;\n                    }\n                    this._length++;\n                    return true;\n                }\n                else {\n                    if (currentItem.next) {\n                        currentItem = currentItem.next;\n                    }\n                    else {\n                        // can't locate previousItem\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    // Adds the element at the end of the linked list\n    append(val, checkDuplicates = false) {\n        if (checkDuplicates && this.isDuplicate(val)) {\n            return false;\n        }\n        let newItem = new LinkedListItem(val);\n        if (!this._tail) {\n            this._head = this._tail = newItem;\n        }\n        else {\n            this._tail.next = newItem;\n            newItem.prev = this._tail;\n            this._tail = newItem;\n        }\n        this._length++;\n        return true;\n    }\n    // Add the element at the beginning of the linked list\n    prepend(val, checkDuplicates = false) {\n        if (checkDuplicates && this.isDuplicate(val)) {\n            return false;\n        }\n        let newItem = new LinkedListItem(val);\n        if (!this._head) {\n            this._head = this._tail = newItem;\n        }\n        else {\n            newItem.next = this._head;\n            this._head.prev = newItem;\n            this._head = newItem;\n        }\n        this._length++;\n        return true;\n    }\n    remove(val) {\n        let currentItem = this._head;\n        if (!currentItem) {\n            return;\n        }\n        if (currentItem.value === val) {\n            this._head = currentItem.next;\n            this._head.prev = null;\n            currentItem.next = currentItem.prev = null;\n            this._length--;\n            return currentItem.value;\n        }\n        else {\n            while (true) {\n                if (currentItem.value === val) {\n                    if (currentItem.next) { // special case for last element\n                        currentItem.prev.next = currentItem.next;\n                        currentItem.next.prev = currentItem.prev;\n                        currentItem.next = currentItem.prev = null;\n                    }\n                    else {\n                        currentItem.prev.next = null;\n                        this._tail = currentItem.prev;\n                        currentItem.next = currentItem.prev = null;\n                    }\n                    this._length--;\n                    return currentItem.value;\n                }\n                else {\n                    if (currentItem.next) {\n                        currentItem = currentItem.next;\n                    }\n                    else {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    removeHead() {\n        let currentItem = this._head;\n        // empty list\n        if (!currentItem) {\n            return;\n        }\n        // single item list\n        if (!this._head.next) {\n            this._head = null;\n            this._tail = null;\n            // full list\n        }\n        else {\n            this._head.next.prev = null;\n            this._head = this._head.next;\n            currentItem.next = currentItem.prev = null;\n        }\n        this._length--;\n        return currentItem.value;\n    }\n    removeTail() {\n        let currentItem = this._tail;\n        // empty list\n        if (!currentItem) {\n            return;\n        }\n        // single item list\n        if (!this._tail.prev) {\n            this._head = null;\n            this._tail = null;\n            // full list\n        }\n        else {\n            this._tail.prev.next = null;\n            this._tail = this._tail.prev;\n            currentItem.next = currentItem.prev = null;\n        }\n        this._length--;\n        return currentItem.value;\n    }\n    first(num) {\n        let iter = this.iterator();\n        let result = [];\n        let n = Math.min(num, this.length);\n        for (let i = 0; i < n; i++) {\n            let val = iter.next();\n            result.push(val.value);\n        }\n        return result;\n    }\n    toArray() {\n        return [...this];\n    }\n    isDuplicate(val) {\n        let set = new Set(this.toArray());\n        return set.has(val);\n    }\n}\nexports.LinkedList = LinkedList;\nclass LinkedListItem {\n    constructor(val) {\n        this.value = val;\n        this.next = null;\n        this.prev = null;\n    }\n}\nexports.LinkedListItem = LinkedListItem;\n//# sourceMappingURL=index.js.map","var convert = require('color-convert');\n\nmodule.exports = function (cstr) {\n    var m, conv, parts, alpha;\n    if (m = /^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\\s*\\(([^\\)]*)\\)/.exec(cstr)) {\n        var name = m[1];\n        var base = name.replace(/a$/, '');\n        var size = base === 'cmyk' ? 4 : 3;\n        conv = convert[base];\n        \n        parts = m[2].replace(/^\\s+|\\s+$/g, '')\n            .split(/\\s*,\\s*/)\n            .map(function (x, i) {\n                if (/%$/.test(x) && i === size) {\n                    return parseFloat(x) / 100;\n                }\n                else if (/%$/.test(x)) {\n                    return parseFloat(x);\n                }\n                return parseFloat(x);\n            })\n        ;\n        if (name === base) parts.push(1);\n        alpha = parts[size] === undefined ? 1 : parts[size];\n        parts = parts.slice(0, size);\n        \n        conv[base] = function () { return parts };\n    }\n    else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {\n        var base = cstr.replace(/^#/,'');\n        var size = base.length;\n        conv = convert.rgb;\n        parts = base.split(size === 3 ? /(.)/ : /(..)/);\n        parts = parts.filter(Boolean)\n            .map(function (x) {\n                if (size === 3) {\n                    return parseInt(x + x, 16);\n                }\n                else {\n                    return parseInt(x, 16)\n                }\n            })\n        ;\n        alpha = 1;\n        conv.rgb = function () { return parts };\n        if (!parts[0]) parts[0] = 0;\n        if (!parts[1]) parts[1] = 0;\n        if (!parts[2]) parts[2] = 0;\n    }\n    else {\n        conv = convert.keyword;\n        conv.keyword = function () { return cstr };\n        parts = cstr;\n        alpha = 1;\n    }\n    \n    var res = {\n        rgb: undefined,\n        hsl: undefined,\n        hsv: undefined,\n        cmyk: undefined,\n        keyword: undefined,\n        hex: undefined\n    };\n    try { res.rgb = conv.rgb(parts) } catch (e) {}\n    try { res.hsl = conv.hsl(parts) } catch (e) {}\n    try { res.hsv = conv.hsv(parts) } catch (e) {}\n    try { res.cmyk = conv.cmyk(parts) } catch (e) {}\n    try { res.keyword = conv.keyword(parts) } catch (e) {}\n    \n    if (res.rgb) res.hex = '#' + res.rgb.map(function (x) {\n        var s = x.toString(16);\n        if (s.length === 1) return '0' + s;\n        return s;\n    }).join('');\n    \n    if (res.rgb) res.rgba = res.rgb.concat(alpha);\n    if (res.hsl) res.hsla = res.hsl.concat(alpha);\n    if (res.hsv) res.hsva = res.hsv.concat(alpha);\n    if (res.cmyk) res.cmyka = res.cmyk.concat(alpha);\n    \n    return res;\n};\n","/* MIT license */\n\nmodule.exports = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n}\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n","var conversions = require(\"./conversions\");\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst linked_list_typescript_1 = require(\"linked-list-typescript\");\nclass Queue extends linked_list_typescript_1.LinkedList {\n    constructor(...values) {\n        super(...values);\n    }\n    get front() {\n        return this.head;\n    }\n    enqueue(val) {\n        this.append(val);\n    }\n    dequeue() {\n        return this.removeHead();\n    }\n}\nexports.Queue = Queue;\n//# sourceMappingURL=index.js.map","/**\r\n * A random constant that is part of the random generation algorithm.\r\n */\r\nconst RANDOM_CONSTANT = BigInt('6364136223846793005');\r\n/**\r\n * A mask of 32 set bits. Used to ensure values stay within a 32 bit range.\r\n */\r\nconst U32_MASK = (BigInt(1) << BigInt(32)) - BigInt(1);\r\n/**\r\n * A mask of 64 set bits. Used to ensure values stay within a 64 bit range.\r\n */\r\nconst U64_MASK = (BigInt(1) << BigInt(64)) - BigInt(1);\r\nclass Random {\r\n    /**\r\n     * A PRNG class. Provides two main methods:\r\n     *\r\n     * - `random` - Produces a \"continuous\" standard uniform distribution.\r\n     * - `randint` - Produces a discrete uniform distribution.\r\n     *\r\n     * For more details, check the individual methods.\r\n     *\r\n     * @param initState The seed to initialise the state of the generator.\r\n     * @param initSequence The seed to initialise the sequence number of the\r\n     * generator.\r\n     */\r\n    // The state and sequence are stored as bigints, but anything that is\r\n    // coercible to a bigint should be a valid seed.\r\n    constructor(initState, initSequence) {\r\n        this._state = BigInt(0);\r\n        this._inc = ((BigInt(initSequence) << BigInt(1)) | BigInt(1)) & U64_MASK;\r\n        this._random_b();\r\n        this._state = (this._state + BigInt(initState)) & U64_MASK;\r\n        this._random_b();\r\n    }\r\n    /**\r\n     * This is the source of randomness for all other random methods.\r\n     *\r\n     * Produces a uniformly distributed 32-bit unsigned integer as a bigint.\r\n     *\r\n     * Although the produced number is 32 bits; the implementation requires that\r\n     * the state of the generator be a 64 bit unsigned integer. Since the js\r\n     * Number datatype cannot reliably handle integers that large, we use the\r\n     * BigInt class for the calculation.\r\n     */\r\n    _random_b() {\r\n        const old = this._state;\r\n        this._state = (old * RANDOM_CONSTANT + this._inc) & U64_MASK;\r\n        const xorshifted = ((old >> BigInt(18)) ^ old) >> BigInt(27);\r\n        const rightRot = old >> BigInt(59);\r\n        const leftRot = rightRot ^ BigInt(31);\r\n        return ((xorshifted >> rightRot) | (xorshifted << leftRot)) & U32_MASK;\r\n    }\r\n    /**\r\n     * Advances the internal state of the generator `delta` steps. Delta can be\r\n     * negative to reverse.\r\n     *\r\n     * This is calculated in a very similar way to the square and multiply method\r\n     * for taking the power of a number. As you may expect, it is calculated in\r\n     * log(delta) time.\r\n     */\r\n    _advance(delta) {\r\n        // The period is 2 ^ 64.\r\n        // If delta is negative, we make it positive and go around the other way.\r\n        delta &= U64_MASK;\r\n        /** The accumulated multiplier */\r\n        let mult_acc = BigInt(1);\r\n        /** The current multiplier */\r\n        let mult_curr = RANDOM_CONSTANT;\r\n        /** The accumulated increment */\r\n        let plus_acc = BigInt(0);\r\n        let plus_curr = this._inc;\r\n        while (delta > 0) {\r\n            if (delta & BigInt(1)) {\r\n                mult_acc = (mult_acc * mult_curr) & U64_MASK;\r\n                plus_acc = (plus_acc * mult_curr + plus_curr) & U64_MASK;\r\n            }\r\n            plus_curr = ((mult_curr + BigInt(1)) * plus_curr) & U64_MASK;\r\n            mult_curr = (mult_curr * mult_curr) & U64_MASK;\r\n            delta >>= BigInt(1);\r\n        }\r\n        this._state = (mult_acc * this._state + plus_acc) & U64_MASK;\r\n    }\r\n    /**\r\n     * Produces a uniformly distributed integer, r, with 0  r < bound.\r\n     *\r\n     * To produce a uniformly distributed integer in the range [low, high):\r\n     *\r\n     * ```js\r\n     * const i = low + rand.randint(high - low)\r\n     * ```\r\n     *\r\n     * @param bound The lower bound for the number.\r\n     */\r\n    randint(bound) {\r\n        if (bound > U32_MASK) {\r\n            throw new TypeError(`Bound too large: ${bound}`);\r\n        }\r\n        if (bound <= 0) {\r\n            throw new TypeError(`Empty sample space for r: 0  r < ${bound}`);\r\n        }\r\n        const bound_big = BigInt(bound);\r\n        // By excluding the integers less than this threshold, we can be sure that\r\n        // the final value will be uniformly distributed in the intended range.\r\n        const threshold = (U32_MASK ^ bound_big) % bound_big;\r\n        // The uniformity of _random_b makes sure that this loop will exit\r\n        // eventually.\r\n        for (;;) {\r\n            const r = this._random_b();\r\n            if (r >= threshold) {\r\n                return Number(r % bound_big);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Generates an approximately uniformly distributed number, r, with 0  r < 1.\r\n     *\r\n     * @returns The number r.\r\n     */\r\n    random() {\r\n        return Number(this._random_b()) / Math.pow(2, 32);\r\n    }\r\n}\n\nexport { Random };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst linked_list_typescript_1 = require(\"linked-list-typescript\");\nclass Stack extends linked_list_typescript_1.LinkedList {\n    constructor(...values) {\n        super(...values);\n    }\n    get top() {\n        return this.head;\n    }\n    get size() {\n        return this.length;\n    }\n    push(val) {\n        this.prepend(val);\n    }\n    pop() {\n        return this.removeHead();\n    }\n}\nexports.Stack = Stack;\n//# sourceMappingURL=index.js.map","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.StringBuilder=exports.String=exports.formatString=exports.joinString=exports.isNullOrWhiteSpace=exports.emptyString=void 0;const EOL=\"\\r\\n\";function isNullOrWhiteSpace(value){return String.isNullOrWhiteSpace(value)}function joinString(delimiter,...args){return String.join(delimiter,...args)}function formatString(format,...args){return String.format(format,...args)}exports.emptyString=\"\",exports.isNullOrWhiteSpace=isNullOrWhiteSpace,exports.joinString=joinString,exports.formatString=formatString;class String{static regexNumber=/{(\\d+(:\\w*)?)}/g;static regexObject=/{(\\w+(:\\w*)?)}/g;static empty=\"\";static Empty=\"\";static IsNullOrWhiteSpace(value){return String.isNullOrWhiteSpace(value)}static Join(delimiter,...args){return String.join(delimiter,...args)}static Format(format,...args){return String.format(format,...args)}static isNullOrWhiteSpace(value){try{return null==value||\"undefined\"==value?!0:value.toString().replace(/\\s/g,\"\").length<1}catch(e){return console.log(e),!1}}static join(delimiter,...args){try{var firstArg=args[0];if(Array.isArray(firstArg)||firstArg instanceof Array){let tempString=String.empty;for(let i=0;i<firstArg.length;i++){var current=firstArg[i];i<firstArg.length-1?tempString+=current+delimiter:tempString+=current}return tempString}if(\"object\"==typeof firstArg){let tempString=String.empty;const objectArg=firstArg;return Object.keys(firstArg).forEach(element=>{tempString+=objectArg[element]+delimiter}),tempString=tempString.slice(0,tempString.length-delimiter.length)}var stringArray=args;return String.joinString(delimiter,...stringArray)}catch(e){return console.log(e),String.empty}}static format(format,...args){try{return format.match(String.regexNumber)?String.formatString(String.regexNumber,format,args):format.match(String.regexObject)?String.formatString(String.regexObject,format,args,!0):format}catch(e){return console.log(e),String.empty}}static formatString(regex,format,args,parseByObject=!1){return format.replace(regex,function(match,x){var s=match.split(\":\");1<s.length&&(x=s[0].replace(\"{\",\"\"),match=s[1].replace(\"}\",\"\"));let arg;return null==(arg=(parseByObject?args[0]:args)[x])||null==arg||match.match(/{\\d+}/)||void 0!==(arg=String.parsePattern(match,arg))&&null!=arg?arg:String.empty})}static parsePattern(match,arg){switch(match){case\"L\":return arg=arg.toLocaleLowerCase();case\"U\":return arg=arg.toLocaleUpperCase();case\"d\":if(\"string\"==typeof arg)return String.getDisplayDateFromString(arg);if(arg instanceof Date)return String.format(\"{0:00}.{1:00}.{2:0000}\",arg.getDate(),arg.getMonth(),arg.getFullYear());break;case\"s\":if(\"string\"==typeof arg)return String.getSortableDateFromString(arg);if(arg instanceof Date)return String.format(\"{0:0000}-{1:00}-{2:00}\",arg.getFullYear(),arg.getMonth(),arg.getDate());break;case\"n\":{var replacedString=(arg=\"string\"!=typeof arg?arg.toString():arg).replace(/,/g,\".\");if(isNaN(parseFloat(replacedString))||replacedString.length<=3)break;replacedString=replacedString.split(/\\D+/g);let parts=replacedString;var replacedString=(parts=1<replacedString.length?[String.joinString(\"\",...replacedString.splice(0,replacedString.length-1)),replacedString[replacedString.length-1]]:parts)[0],mod=replacedString.length%3,output=0<mod?replacedString.substring(0,mod):String.empty,replacedString=replacedString.substring(mod).match(/.{3}/g);return arg=output+\".\"+String.join(\".\",replacedString)+(1<parts.length?\",\"+parts[1]:\"\")}case\"x\":return this.decimalToHexString(arg);case\"X\":return this.decimalToHexString(arg,!0)}return\"number\"!=typeof arg&&isNaN(arg)||isNaN(+match)||String.isNullOrWhiteSpace(arg)?arg:String.formatNumber(arg,match)}static decimalToHexString(value,upperCase=!1){value=parseFloat(value).toString(16);return upperCase?value.toLocaleUpperCase():value}static getDisplayDateFromString(input){var splitted=input.split(\"-\");if(splitted.length<=1)return input;let day=splitted[splitted.length-1];input=splitted[splitted.length-2],splitted=splitted[splitted.length-3];return(day=(day=day.split(\"T\")[0]).split(\" \")[0])+`.${input}.`+splitted}static getSortableDateFromString(input){var splitted=input.replace(\",\",\"\").split(\".\");if(splitted.length<=1)return input;input=splitted[splitted.length-1].split(\" \");let time=String.empty,result=(1<input.length&&(time=input[input.length-1]),splitted[splitted.length-1].split(\" \")[0]+`-${splitted[splitted.length-2]}-`+splitted[splitted.length-3]);return!String.isNullOrWhiteSpace(time)&&1<time.length?result+=\"T\"+time:result+=\"T00:00:00\",result}static formatNumber(input,formatTemplate){var formatTemplate=formatTemplate.length,input=input.toString();return formatTemplate<=input.length?input:(formatTemplate=formatTemplate-input.length,++formatTemplate,new Array(formatTemplate).join(\"0\")+input)}static joinString(delimiter,...args){let temp=String.empty;for(let i=0;i<args.length;i++)if(!(\"string\"==typeof args[i]&&String.isNullOrWhiteSpace(args[i])||\"number\"!=typeof args[i]&&\"string\"!=typeof args[i])){var arg=\"\"+args[i];temp+=arg;for(let i2=i+1;i2<args.length;i2++)if(!String.isNullOrWhiteSpace(args[i2])){temp+=delimiter,i=i2-1;break}}return temp}}exports.String=String;class StringBuilder{Values;constructor(value=\"\"){this.Values=[],String.isNullOrWhiteSpace(value)||(this.Values=new Array(value))}toString(){return this.Values.join(String.empty)}ToString(){return this.toString()}append(value){this.Values.push(value)}Append(value){this.append(value)}appendLine(value){this.Values.push(EOL+value)}AppendLine(value){this.appendLine(value)}appendFormat(format,...args){this.Values.push(String.format(format,...args))}AppendFormat(format,...args){this.appendFormat(format,...args)}appendLineFormat(format,...args){this.Values.push(EOL+String.format(format,...args))}AppendLineFormat(format,...args){return this.appendLineFormat(format,...args)}clear(){this.Values=[]}Clear(){this.clear()}}exports.StringBuilder=StringBuilder;","import {\n  GeomGraph,\n  GeomEdge,\n  GeomNode,\n  Point,\n  CurveFactory,\n  SugiyamaLayoutSettings,\n  LayerDirectionEnum,\n  layoutGeomGraph,\n} from '@msagl/core';\nimport { parseDot } from '@msagl/parser';\n\n/**\n * Use d3 force layout to lay the nodes in a sensible way. This function modifies the nodes adding the x,y positions\n * and also fills in node references in edges instead of node ids.\n */\nexport function layout(nodes, edges) {\n  const { mappedEdges, DOTToIdMap } = createMappings(nodes, edges);\n\n  const dot = graphToDOT(mappedEdges, DOTToIdMap);\n  const graph = parseDot(dot);\n  const geomGraph = new GeomGraph(graph);\n  for (const e of graph.deepEdges) {\n    new GeomEdge(e);\n  }\n\n  for (const n of graph.nodesBreadthFirst) {\n    const gn = new GeomNode(n);\n    gn.boundaryCurve = CurveFactory.mkCircle(50, new Point(0, 0));\n  }\n  geomGraph.layoutSettings = new SugiyamaLayoutSettings();\n  geomGraph.layoutSettings.layerDirection = LayerDirectionEnum.LR;\n  geomGraph.layoutSettings.LayerSeparation = 60;\n  geomGraph.layoutSettings.commonSettings.NodeSeparation = 40;\n  layoutGeomGraph(geomGraph);\n\n  const nodesMap = {};\n  for (const node of geomGraph.nodesBreadthFirst) {\n    nodesMap[DOTToIdMap[node.id]] = {\n      obj: node,\n    };\n  }\n\n  for (const node of nodes) {\n    nodesMap[node.id] = {\n      ...nodesMap[node.id],\n      datum: {\n        ...node,\n        x: nodesMap[node.id].obj.center.x,\n        y: nodesMap[node.id].obj.center.y,\n      },\n    };\n  }\n  const edgesMapped = edges.map((e) => {\n    return {\n      ...e,\n      source: nodesMap[e.source].datum,\n      target: nodesMap[e.target].datum,\n    };\n  });\n\n  // This section checks if there are separate disjointed subgraphs. If so it groups nodes for each and then aligns\n  // each subgraph, so it starts on a single vertical line. Otherwise, they are laid out randomly from left to right.\n  const subgraphs = [];\n  for (const e of edgesMapped) {\n    const sourceGraph = subgraphs.find((g) => g.nodes.has(e.source));\n    const targetGraph = subgraphs.find((g) => g.nodes.has(e.target));\n    if (sourceGraph && targetGraph) {\n      // if the node sets are not the same we merge them\n      if (sourceGraph !== targetGraph) {\n        targetGraph.nodes.forEach(sourceGraph.nodes.add, sourceGraph.nodes);\n        subgraphs.splice(subgraphs.indexOf(targetGraph), 1);\n        sourceGraph.top = Math.min(sourceGraph.top, targetGraph.top);\n        sourceGraph.bottom = Math.max(sourceGraph.bottom, targetGraph.bottom);\n        sourceGraph.left = Math.min(sourceGraph.left, targetGraph.left);\n        sourceGraph.right = Math.max(sourceGraph.right, targetGraph.right);\n      }\n      // if the sets are the same nothing to do.\n    } else if (sourceGraph) {\n      sourceGraph.nodes.add(e.target);\n      sourceGraph.top = Math.min(sourceGraph.top, e.target.y);\n      sourceGraph.bottom = Math.max(sourceGraph.bottom, e.target.y);\n      sourceGraph.left = Math.min(sourceGraph.left, e.target.x);\n      sourceGraph.right = Math.max(sourceGraph.right, e.target.x);\n    } else if (targetGraph) {\n      targetGraph.nodes.add(e.source);\n      targetGraph.top = Math.min(targetGraph.top, e.source.y);\n      targetGraph.bottom = Math.max(targetGraph.bottom, e.source.y);\n      targetGraph.left = Math.min(targetGraph.left, e.source.x);\n      targetGraph.right = Math.max(targetGraph.right, e.source.x);\n    } else {\n      // we don't have these nodes\n      subgraphs.push({\n        top: Math.min(e.source.y, e.target.y),\n        bottom: Math.max(e.source.y, e.target.y),\n        left: Math.min(e.source.x, e.target.x),\n        right: Math.max(e.source.x, e.target.x),\n        nodes: new Set([e.source, e.target]),\n      });\n    }\n  }\n\n  let top = 0;\n  let left = 0;\n  for (const g of subgraphs) {\n    if (top === 0) {\n      top = g.bottom + 200;\n      left = g.left;\n    } else {\n      const topDiff = top - g.top;\n      const leftDiff = left - g.left;\n      for (const n of g.nodes) {\n        n.x += leftDiff;\n        n.y += topDiff;\n      }\n      top += g.bottom - g.top + 200;\n    }\n  }\n\n  const finalNodes = Object.values(nodesMap).map((v) => v.datum);\n\n  centerNodes(finalNodes);\n  return [finalNodes, edgesMapped];\n}\n\n// We create mapping because the DOT language we use later to create the graph doesn't support arbitrary IDs. So we\n// map our IDs to just an index of the node so the IDs are safe for the DOT parser and also create and inverse mapping\n// for quick lookup.\nfunction createMappings(nodes, edges) {\n  // Edges where the source and target IDs are the indexes we use for layout\n  const mappedEdges = [];\n\n  // Key is an ID of the node and value is new ID which is just iteration index\n  const idToDOTMap = {};\n\n  // Key is an iteration index and value is actual ID of the node\n  const DOTToIdMap = {};\n\n  let index = 0;\n  for (const node of nodes) {\n    idToDOTMap[node.id] = index.toString(10);\n    DOTToIdMap[index.toString(10)] = node.id;\n    index++;\n  }\n\n  for (const edge of edges) {\n    mappedEdges.push({ source: idToDOTMap[edge.source], target: idToDOTMap[edge.target] });\n  }\n\n  return {\n    mappedEdges,\n    DOTToIdMap,\n    idToDOTMap,\n  };\n}\n\nfunction graphToDOT(edges, nodeIDsMap) {\n  let dot = `\n  digraph G {\n    rankdir=\"LR\"; TBbalance=\"min\"\n  `;\n  for (const edge of edges) {\n    dot += edge.source + '->' + edge.target + ' ' + '[ minlen=3 ]\\n';\n  }\n  dot += nodesDOT(nodeIDsMap);\n  dot += '}';\n  return dot;\n}\n\nfunction nodesDOT(nodeIdsMap) {\n  let dot = '';\n  for (const node of Object.keys(nodeIdsMap)) {\n    dot += node + ' [fixedsize=true, width=1.2, height=1.7] \\n';\n  }\n  return dot;\n}\n\n/**\n * Makes sure that the center of the graph based on its bound is in 0, 0 coordinates.\n * Modifies the nodes directly.\n */\nfunction centerNodes(nodes) {\n  const bounds = graphBounds(nodes);\n  for (let node of nodes) {\n    node.x = node.x - bounds.center.x;\n    node.y = node.y - bounds.center.y;\n  }\n}\n\n/**\n * Get bounds of the graph meaning the extent of the nodes in all directions.\n */\nfunction graphBounds(nodes) {\n  if (nodes.length === 0) {\n    return { top: 0, right: 0, bottom: 0, left: 0, center: { x: 0, y: 0 } };\n  }\n\n  const bounds = nodes.reduce(\n    (acc, node) => {\n      if (node.x > acc.right) {\n        acc.right = node.x;\n      }\n      if (node.x < acc.left) {\n        acc.left = node.x;\n      }\n      if (node.y > acc.bottom) {\n        acc.bottom = node.y;\n      }\n      if (node.y < acc.top) {\n        acc.top = node.y;\n      }\n      return acc;\n    },\n    { top: Infinity, right: -Infinity, bottom: -Infinity, left: Infinity }\n  );\n\n  const y = bounds.top + (bounds.bottom - bounds.top) / 2;\n  const x = bounds.left + (bounds.right - bounds.left) / 2;\n\n  return {\n    ...bounds,\n    center: {\n      x,\n      y,\n    },\n  };\n}\n","export { GeomEdge } from './layout/core/geomEdge';\nexport { RectangleNode } from './math/geometry/RTree/rectangleNode';\nexport { insertRange } from './utils/setOperations';\nexport { buildRTree, buildRTreeWithInterpolatedEdges, GeomGraph, getGeomIntersectedObjects, intersectedObjects, } from './layout/core/geomGraph';\nexport { createRectangleNodeOnData } from './math/geometry/RTree/rectangleNode';\nexport { TileMap } from './layout/core/tileMap';\nexport { Tile as TileData } from './layout/core/tile';\nexport { GeomLabel } from './layout/core/geomLabel';\nexport { GeomNode } from './layout/core/geomNode';\nexport { EventHandler } from './layout/core/geomObject';\nexport { PlaneTransformation } from './math/geometry/planeTransformation';\nexport { BinaryRTree as RTree } from './math/geometry/RTree/rTree';\nexport { SmoothedPolyline } from './math/geometry/smoothedPolyline';\nexport { Attribute } from './structs/attribute';\nexport { pagerank as pageRank } from './structs/graph';\nexport { Label } from './structs/label';\nexport { Assert } from './utils/assert';\nexport { IntPairMap } from './utils/IntPairMap';\nexport { PolylinePoint } from './math/geometry/polylinePoint';\nexport { PivotMDS } from './layout/mds/pivotMDS';\nexport { RectilinearInteractiveEditor } from './routing/rectilinear/RectilinearInteractiveEditor';\nexport { EdgeLabelPlacement } from './layout/edgeLabelPlacement';\nexport { StraightLineEdges } from './routing/StraightLineEdges';\nexport { RelativeFloatingPort } from './layout/core/relativeFloatingPort';\nexport { InteractiveEdgeRouter } from './routing/interactiveEdgeRouter';\nexport { FloatingPort } from './layout/core/floatingPort';\nexport { CurvePort } from './layout/core/curvePort';\nexport { Port } from './layout/core/port';\nexport { PointLocation } from './math/geometry';\nexport { CornerSite } from './math/geometry/cornerSite';\nexport { IntersectionInfo } from './math/geometry/intersectionInfo';\nexport { OptimalRectanglePacking } from './math/geometry/rectanglePacking/OptimalRectanglePacking';\nexport { PackingConstants } from './math/geometry/rectanglePacking/PackingConstants';\nexport { GreedyRectanglePacking } from './math/geometry/rectanglePacking/RectanglePacking';\nexport { DebugCurve } from './math/geometry/debugCurve';\nexport { SugiyamaLayoutSettings } from './layout/layered/sugiyamaLayoutSettings';\nexport { LayeredLayout } from './layout/layered/layeredLayout';\nexport { CancelToken } from './utils/cancelToken';\nexport { CurveFactory, interpolateICurve, Point, Rectangle, Size, parameterSpan } from './math/geometry';\nexport { LayerDirectionEnum } from './layout/layered/layerDirectionEnum';\nexport { layoutGeomGraph, layoutGeomGraphDetailed as layoutGeomGraphInternal, routeRectilinearEdges, routeEdges, layoutIsCalculated, geometryIsCreated, } from './layout/driver';\nexport { Edge } from './structs/edge';\nexport { Graph } from './structs/graph';\nexport { Node } from './structs/node';\nexport { MdsLayoutSettings } from './layout/mds/mDSLayoutSettings';\nexport { layoutGraphWithMds } from './layout/mds/pivotMDS';\nexport { layoutGraphWithSugiayma } from './layout/layered/layeredLayout';\nexport { EdgeRoutingMode } from './routing/EdgeRoutingMode';\nexport { SplineRouter } from './routing/splineRouter';\nexport { BundlingSettings } from './routing/BundlingSettings';\nexport { RectilinearEdgeRouter } from './routing/rectilinear/RectilinearEdgeRouter';\nexport { EdgeRoutingSettings } from './routing/EdgeRoutingSettings';\nexport { Ellipse } from './math/geometry/ellipse';\nexport { Curve, clipWithRectangle } from './math/geometry/curve';\nexport { BezierSeg } from './math/geometry/bezierSeg';\nexport { LineSegment } from './math/geometry/lineSegment';\nexport { Polyline } from './math/geometry/polyline';\nexport { GeomObject } from './layout/core/geomObject';\nexport { Arrowhead } from './layout/core/arrowhead';\nexport { setNewParent } from './structs/graph';\nexport { Entity } from './structs/entity';\nexport { iCurveToJSON, JSONToICurve } from './math/geometry/icurve';\nexport { AttributeRegistry } from './structs/attributeRegistry';\nexport { IPsepColaSetting as FastIncrementalLayoutSettings } from './layout/incremental/iPsepColaSettings';\n//# sourceMappingURL=index.js.map","import { EdgeRoutingSettings } from '../routing/EdgeRoutingSettings';\n/** The common data of layout settings: it specifies the minumal allowed distance between the nodes,  the minimal size of the resulting bounding box, settings for edge routing, and the ratio for the graph boxes packing algorithm  */\nexport class CommonLayoutSettings {\n    constructor() {\n        this.edgeRoutingSettings = new EdgeRoutingSettings();\n        this.nodeSeparation = 10;\n        this.packingAspectRatio = 1.5;\n    }\n    static fromJSON(s) {\n        const ret = new CommonLayoutSettings();\n        if (s.nodeSeparation != 10) {\n            ret.nodeSeparation = s.nodeSeparation;\n        }\n        if (s.packingAspectRatio) {\n            ret.packingAspectRatio = s.packingAspectRatio;\n        }\n        if (s.edgeRoutingSettings) {\n            ret.edgeRoutingSettings = EdgeRoutingSettings.fromJSON(s.edgeRoutingSettings);\n        }\n        return ret;\n    }\n    toJSON() {\n        let differentFromDefault = false;\n        const ret = {};\n        if (this.nodeSeparation != 10) {\n            ret.nodeSeparation = this.nodeSeparation;\n            differentFromDefault = true;\n        }\n        if (this.packingAspectRatio != 1.5) {\n            ret.packingAspectRatio = this.packingAspectRatio;\n            differentFromDefault = true;\n        }\n        if ((ret.edgeRoutingSettings = this.edgeRoutingSettings.toJSON())) {\n            differentFromDefault = true;\n        }\n        return differentFromDefault ? ret : undefined;\n    }\n    get NodeSeparation() {\n        return this.nodeSeparation;\n    }\n    set NodeSeparation(value) {\n        this.nodeSeparation = value;\n    }\n    get PackingAspectRatio() {\n        return this.packingAspectRatio;\n    }\n    set PackingAspectRatio(value) {\n        this.packingAspectRatio = value;\n    }\n}\n//# sourceMappingURL=commonLayoutSettings.js.map","import { Rectangle } from '../../math/geometry/rectangle';\nimport { CurveFactory } from '../../math/geometry';\nexport class RRect extends Rectangle {\n    constructor(t) {\n        super(t);\n        this.radX = t.radX;\n        this.radY = t.radY;\n        this.roundedRect_ = CurveFactory.mkRectangleWithRoundedCorners(this.width, this.height, t.radX, t.radY, this.center);\n    }\n    onUpdated() {\n        if (!this.isEmpty) {\n            this.roundedRect_ = CurveFactory.mkRectangleWithRoundedCorners(this.width, this.height, this.radX, this.radY, this.center);\n        }\n    }\n    isOk() {\n        if (this.isEmpty()) {\n            return true;\n        }\n        return this.roundedRect_.boundingBox.equalEps(this);\n    }\n    setRect(value) {\n        this.left = value.left;\n        this.right = value.right;\n        this.top = value.top;\n        this.bottom = value.bottom;\n        if (!this.isEmpty()) {\n            this.roundedRect_ = CurveFactory.mkRectangleWithRoundedCorners(value.width, value.height, this.radX, this.radY, this.center);\n        }\n    }\n}\n//# sourceMappingURL=RRect.js.map","import { Point } from './../../math/geometry/point';\nimport { GeomConstants } from './../../math/geometry/geomConstants';\nimport { Curve } from './../../math/geometry/curve';\nimport { Ellipse } from './../../math/geometry/ellipse';\nimport { LineSegment } from './../../math/geometry/lineSegment';\nexport class Arrowhead {\n    toJSON() {\n        let str = '{';\n        if (this.tipPosition) {\n            str += '\"tipPosition\": ' + this.tipPosition.toJSON();\n        }\n        str += '}';\n        return str;\n    }\n    clone() {\n        const r = new Arrowhead();\n        r.length = this.length;\n        r.width = this.width;\n        r.tipPosition = this.tipPosition;\n        return r;\n    }\n    constructor() {\n        this.length = Arrowhead.defaultArrowheadLength;\n        this.width = 0;\n        // just for debug\n        this.length = Arrowhead.defaultArrowheadLength;\n    }\n    // the edgeGeometry.Curve is trimmed already by the node boundaries</param>\n    static calculateArrowheads(edge) {\n        if (edge.sourceArrowhead == null && edge.targetArrowhead == null)\n            return true;\n        const parStart = Arrowhead.findTrimStartForArrowheadAtSource(edge);\n        if (parStart == null) {\n            return false;\n        }\n        const parEnd = Arrowhead.findTrimEndForArrowheadAtTarget(edge);\n        if (parEnd == null) {\n            return false;\n        }\n        if (parStart > parEnd - GeomConstants.intersectionEpsilon ||\n            Curve.closeIntersectionPoints(edge.curve.value(parStart), edge.curve.value(parEnd)))\n            return false; //after the trim nothing would be left of the curve\n        const c = edge.curve.trim(parStart, parEnd);\n        if (c == null)\n            return false;\n        if (edge.sourceArrowhead != null)\n            edge.sourceArrowhead.tipPosition = edge.curve.start;\n        if (edge.targetArrowhead != null)\n            edge.targetArrowhead.tipPosition = edge.curve.end;\n        edge.curve = c;\n        return true;\n    }\n    static getIntersectionsWithArrowheadCircle(curve, arrowheadLength, circleCenter) {\n        const e = Ellipse.mkFullEllipseNNP(arrowheadLength, arrowheadLength, circleCenter);\n        return Curve.getAllIntersections(e, curve, true);\n    }\n    // we need to pass arrowhead length here since the original length mibh\n    static findTrimEndForArrowheadAtTarget(edgeGeometry) {\n        const eps = GeomConstants.distanceEpsilon * GeomConstants.distanceEpsilon;\n        //Assert.assert((edgeGeometry.Curve.End - edgeGeometry.Curve.start).LengthSquared > eps);\n        let p = edgeGeometry.curve.parEnd;\n        if (edgeGeometry.targetArrowhead == null || edgeGeometry.targetArrowhead.length <= GeomConstants.distanceEpsilon)\n            return p;\n        const curve = edgeGeometry.curve;\n        let arrowheadLength = edgeGeometry.targetArrowhead.length;\n        let newCurveEnd;\n        let intersections;\n        let reps = 10;\n        do {\n            reps--;\n            if (reps === 0)\n                return;\n            intersections = Arrowhead.getIntersectionsWithArrowheadCircle(curve, arrowheadLength, curve.end);\n            p = intersections.length !== 0 ? Math.max(...intersections.map((x) => x.par1)) : curve.parEnd;\n            newCurveEnd = edgeGeometry.curve.value(p);\n            arrowheadLength /= 2;\n        } while (newCurveEnd.sub(curve.start).lengthSquared < eps || intersections.length === 0);\n        //we would like to have at least something left from the curve\n        return p;\n    }\n    static findTrimStartForArrowheadAtSource(edgeGeometry) {\n        if (edgeGeometry.sourceArrowhead == null || edgeGeometry.sourceArrowhead.length <= GeomConstants.distanceEpsilon)\n            return edgeGeometry.curve.parStart;\n        const eps = GeomConstants.distanceEpsilon * GeomConstants.distanceEpsilon;\n        /*Assert.assert(\n          edgeGeometry.curve.end.sub(edgeGeometry.curve.start).lengthSquared > eps,\n        )*/\n        let arrowheadLength = edgeGeometry.sourceArrowhead.length;\n        let newStart;\n        const curve = edgeGeometry.curve;\n        let intersections;\n        let reps = 10;\n        let p;\n        while (--reps > 0) {\n            intersections = Arrowhead.getIntersectionsWithArrowheadCircle(curve, arrowheadLength, curve.start);\n            if (intersections.length === 0)\n                return curve.parStart;\n            p = Math.min(...intersections.map((x) => x.par1));\n            newStart = intersections.filter((x) => x.par1 === p)[0].x;\n            // check that something is left from the curve\n            if (newStart.sub(curve.end).lengthSquared >= eps)\n                return p;\n            arrowheadLength /= 2;\n        }\n    }\n    // trim the edge curve with the node boundaries\n    static trimSplineAndCalculateArrowheads(edge, spline, narrowestInterval) {\n        return Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, spline, narrowestInterval);\n    }\n    // trim the edge curve with the node boundaries\n    static trimSplineAndCalculateArrowheadsII(edgeGeometry, sourceBoundary, targetBoundary, spline, narrowestInterval) {\n        edgeGeometry.curve = Curve.trimEdgeSplineWithNodeBoundaries(sourceBoundary, targetBoundary, spline, narrowestInterval);\n        if (edgeGeometry.curve == null)\n            return false;\n        if ((edgeGeometry.sourceArrowhead == null || edgeGeometry.sourceArrowhead.length < GeomConstants.distanceEpsilon) &&\n            (edgeGeometry.targetArrowhead == null || edgeGeometry.targetArrowhead.length < GeomConstants.distanceEpsilon))\n            return true; //there are no arrowheads\n        let success = false;\n        const sourceArrowheadSavedLength = edgeGeometry.sourceArrowhead != null ? edgeGeometry.sourceArrowhead.length : 0;\n        const targetArrowheadSavedLength = edgeGeometry.targetArrowhead != null ? edgeGeometry.targetArrowhead.length : 0;\n        const len = edgeGeometry.curve.end.sub(edgeGeometry.curve.start).length;\n        if (edgeGeometry.sourceArrowhead != null)\n            edgeGeometry.sourceArrowhead.length = Math.min(len, sourceArrowheadSavedLength);\n        if (edgeGeometry.targetArrowhead != null)\n            edgeGeometry.targetArrowhead.length = Math.min(len, targetArrowheadSavedLength);\n        let count = 10;\n        while (((edgeGeometry.sourceArrowhead != null && edgeGeometry.sourceArrowhead.length > GeomConstants.intersectionEpsilon) ||\n            (edgeGeometry.targetArrowhead != null && edgeGeometry.targetArrowhead.length > GeomConstants.intersectionEpsilon)) &&\n            !success) {\n            success = Arrowhead.calculateArrowheads(edgeGeometry);\n            if (!success) {\n                if (edgeGeometry.sourceArrowhead != null)\n                    edgeGeometry.sourceArrowhead.length *= 0.5;\n                if (edgeGeometry.targetArrowhead != null)\n                    edgeGeometry.targetArrowhead.length *= 0.5;\n            }\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (!success) {\n            //to avoid drawing the arrowhead to (0,0)\n            if (edgeGeometry.sourceArrowhead != null)\n                edgeGeometry.sourceArrowhead.tipPosition = spline.start;\n            if (edgeGeometry.targetArrowhead != null)\n                edgeGeometry.targetArrowhead.tipPosition = spline.end;\n        }\n        if (edgeGeometry.sourceArrowhead != null)\n            edgeGeometry.sourceArrowhead.length = sourceArrowheadSavedLength;\n        if (edgeGeometry.targetArrowhead != null)\n            edgeGeometry.targetArrowhead.length = targetArrowheadSavedLength;\n        return success;\n    }\n    /** Creates a spline between two nodes big enough to draw arrowheads */\n    static createBigEnoughSpline(edge) {\n        const a = edge.source.center;\n        let b = edge.target.center;\n        const bMinA = b.sub(a);\n        const l = bMinA.length;\n        let perp;\n        if (l < 0.001) {\n            perp = new Point(1, 0);\n            b = a.add(perp.rotate(Math.PI / 2));\n        }\n        else {\n            perp = bMinA.rotate(Math.PI / 2);\n        }\n        let maxArrowLength = 1;\n        if (edge.sourceArrowhead != null) {\n            maxArrowLength += edge.sourceArrowhead.length;\n        }\n        if (edge.targetArrowhead != null) {\n            maxArrowLength += edge.targetArrowhead.length;\n        }\n        perp = perp.normalize().mul(1.5 * maxArrowLength);\n        for (let i = 1; i < 10000; i = i * 2) {\n            const seg = Curve.createBezierSegN(a, b, perp, i);\n            if (Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, seg, false)) {\n                return;\n            }\n        }\n        Arrowhead.createEdgeCurveWithNoTrimming(edge, a, b);\n    }\n    // this method should never be called: it is a super emergency measure\n    static createEdgeCurveWithNoTrimming(edge, a, b) {\n        const ab = b.sub(a).normalize();\n        let lineStart = a;\n        let lineEnd = b;\n        const targetArrow = edge.targetArrowhead;\n        if (targetArrow != null) {\n            targetArrow.tipPosition = b;\n            lineEnd = b.sub(ab.mul(targetArrow.length));\n        }\n        const sourceArrow = edge.sourceArrowhead;\n        if (sourceArrow != null) {\n            sourceArrow.tipPosition = a;\n            lineStart = a.add(ab.mul(sourceArrow.length));\n        }\n        edge.curve = LineSegment.mkPP(lineStart, lineEnd);\n    }\n}\nArrowhead.defaultArrowheadLength = 5;\n//# sourceMappingURL=arrowhead.js.map","import { Port } from './port';\nexport class CurvePort extends Port {\n    get Location() {\n        return this.curve.value(this.parameter);\n    }\n    set Location(value) {\n        throw new Error('Method should not be called.');\n    }\n    // constructor\n    static mk(curve, parameter) {\n        const ret = new CurvePort();\n        ret.curve = curve;\n        ret.parameter = parameter;\n        return ret;\n    }\n    get Parameter() {\n        return this.parameter;\n    }\n    set Parameter(value) {\n        this.parameter = value;\n    }\n    get Curve() {\n        return this.curve;\n    }\n    set Curve(value) {\n        this.curve = value;\n    }\n}\n//# sourceMappingURL=curvePort.js.map","import { Port } from './port';\nexport class FloatingPort extends Port {\n    // a curve associated with the port\n    // constructor\n    constructor(curve, location) {\n        super();\n        this.curve = this.curve;\n        this.location = location.clone();\n    }\n    // the location of the port\n    get Location() {\n        return this.location;\n    }\n    set Location(value) {\n        this.location = value;\n    }\n    // translate the port location by delta\n    Translate(delta) {\n        this.location = this.location.add(delta);\n    }\n    // the port's curve\n    get Curve() {\n        return this.curve;\n    }\n    set Curve(value) {\n        this.curve = value;\n    }\n}\n//# sourceMappingURL=floatingPort.js.map","import { GeomObject } from './geomObject';\nimport { Rectangle } from './../../math/geometry/rectangle';\nimport { SmoothedPolyline } from './../../math/geometry/smoothedPolyline';\nimport { GeomLabel } from './geomLabel';\nimport { Point } from '../../math/geometry/point';\nimport { AttributeRegistry } from '../../structs/attributeRegistry';\nimport { Curve, LineSegment } from '../../math/geometry';\nimport { Ellipse } from '../../math/geometry/ellipse';\nimport { BezierSeg } from '../../math/geometry/bezierSeg';\nexport class GeomEdge extends GeomObject {\n    *getSmoothPolyPoints() {\n        yield this.source.center;\n        if (this.curve instanceof Curve) {\n            yield* this.getCurvePoints(this.curve);\n        }\n        else if (this.curve instanceof LineSegment) {\n            yield this.curve.start;\n            yield this.curve.end;\n        }\n        else if (this.curve instanceof Ellipse) {\n            yield this.curve.start;\n            yield this.curve.value((this.curve.parStart + this.curve.parEnd) / 0.5);\n            yield this.curve.end;\n        }\n        else if (this.curve instanceof BezierSeg) {\n            yield this.curve.start;\n            yield this.curve.value(0.25);\n            yield this.curve.value(0.75);\n            yield this.curve.end;\n        }\n        yield this.target.center;\n    }\n    *getCurvePoints(curve) {\n        for (const e of curve.segs) {\n            yield e.start;\n            if (e instanceof BezierSeg) {\n                const p = topOfBezierSeg(e);\n                if (p)\n                    yield p;\n            }\n        }\n        yield curve.end;\n    }\n    static getGeom(e) {\n        return GeomObject.getGeom(e);\n    }\n    /** clones but does not bind to the entity */\n    clone() {\n        const geomEdge = new GeomEdge(null);\n        if (this.smoothedPolyline)\n            geomEdge.smoothedPolyline = this.smoothedPolyline.clone();\n        geomEdge.curve = this.curve.clone();\n        if (this.sourceArrowhead != null) {\n            geomEdge.sourceArrowhead = this.sourceArrowhead.clone();\n        }\n        if (this.targetArrowhead != null) {\n            geomEdge.targetArrowhead = this.targetArrowhead.clone();\n        }\n        return geomEdge;\n    }\n    get label() {\n        return this.edge != null && this.edge.label != null ? GeomObject.getGeom(this.edge.label) : null;\n    }\n    set label(value) {\n        this.edge.label.setAttr(AttributeRegistry.GeomObjectIndex, value);\n    }\n    RaiseLayoutChangeEvent(delta) {\n        this.edge.raiseEvents(delta);\n    }\n    requireRouting() {\n        this.curve = null;\n        this.smoothedPolyline = null;\n    }\n    translate(delta) {\n        if (delta.x === 0 && delta.y === 0)\n            return;\n        // RaiseLayoutChangeEvent(delta);\n        if (this.curve != null)\n            this.curve.translate(delta);\n        if (this.smoothedPolyline != null)\n            for (let s = this.smoothedPolyline.headSite, s0 = this.smoothedPolyline.headSite; s != null; s = s.next, s0 = s0.next)\n                s.point = s0.point.add(delta);\n        if (this.sourceArrowhead != null && this.sourceArrowhead.tipPosition)\n            this.sourceArrowhead.tipPosition = this.sourceArrowhead.tipPosition.add(delta);\n        if (this.targetArrowhead != null && this.targetArrowhead.tipPosition)\n            this.targetArrowhead.tipPosition = this.targetArrowhead.tipPosition.add(delta);\n        if (this.edge.label) {\n            const geomLabel = GeomLabel.getGeom(this.edge.label);\n            if (geomLabel)\n                geomLabel.translate(delta);\n        }\n    }\n    GetMaxArrowheadLength() {\n        let l = 0;\n        if (this.sourceArrowhead != null) {\n            l = this.sourceArrowhead.length;\n        }\n        if (this.targetArrowhead != null && this.targetArrowhead.length > l) {\n            return this.targetArrowhead.length;\n        }\n        return l;\n    }\n    transform(matrix) {\n        if (this.curve == null)\n            return;\n        this.curve = this.curve.transform(matrix);\n        if (this.smoothedPolyline != null)\n            for (let s = this.smoothedPolyline.headSite, s0 = this.smoothedPolyline.headSite; s != null; s = s.next, s0 = s0.next)\n                s.point = matrix.multiplyPoint(s.point);\n        if (this.sourceArrowhead != null) {\n            this.sourceArrowhead.tipPosition = matrix.multiplyPoint(this.sourceArrowhead.tipPosition);\n        }\n        if (this.targetArrowhead != null) {\n            this.targetArrowhead.tipPosition = matrix.multiplyPoint(this.targetArrowhead.tipPosition);\n        }\n    }\n    get edge() {\n        return this.entity;\n    }\n    get source() {\n        return GeomObject.getGeom(this.edge.source);\n    }\n    /** iterates over the source arrowhead corner points */\n    *sourceArrowheadPoints(angle) {\n        if (this.sourceArrowhead == null)\n            return;\n        yield this.sourceArrowhead.tipPosition;\n        let d = this.sourceArrowhead.tipPosition.sub(this.curve.start);\n        // assume that the arrowhead angle is 25 degrees\n        d = d.rotate90Cw().mul(Math.tan(angle * 0.5 * (Math.PI / 180.0)));\n        yield d.add(this.curve.start);\n        yield this.curve.start.sub(d);\n    }\n    /** iterates over the target arrowhead corner points */\n    *targetArrowheadPoints(angle) {\n        if (this.targetArrowhead == null)\n            return;\n        yield this.targetArrowhead.tipPosition;\n        let d = this.targetArrowhead.tipPosition.sub(this.curve.end);\n        // assume that the arrowhead angle is 25 degrees\n        d = d.rotate90Cw().mul(Math.tan(angle * 0.5 * (Math.PI / 180.0)));\n        yield d.add(this.curve.end);\n        yield this.curve.end.sub(d);\n    }\n    get boundingBox() {\n        const rect = Rectangle.mkEmpty();\n        if (this.smoothedPolyline != null)\n            for (const p of this.smoothedPolyline)\n                rect.add(p);\n        if (this.curve != null)\n            rect.addRecSelf(this.curve.boundingBox);\n        for (const p of this.sourceArrowheadPoints(25)) {\n            rect.add(p);\n        }\n        for (const p of this.targetArrowheadPoints(25)) {\n            rect.add(p);\n        }\n        if (this.label) {\n            rect.addRecSelf(this.label.boundingBox);\n        }\n        const del = this.lineWidth;\n        rect.left -= del;\n        rect.top += del;\n        rect.right += del;\n        rect.bottom -= del;\n        return rect;\n    }\n    isInterGraphEdge() {\n        return this.edge.isInterGraphEdge();\n    }\n    get target() {\n        return GeomObject.getGeom(this.edge.target);\n    }\n    constructor(edge) {\n        super(edge);\n        this.lineWidth = 1;\n    }\n    toString() {\n        return this.source.toString() + '->' + this.target;\n    }\n    static RouteSelfEdge(boundaryCurve, howMuchToStickOut, t) {\n        // we just need to find the box of the corresponding node\n        const w = boundaryCurve.boundingBox.width;\n        const h = boundaryCurve.boundingBox.height;\n        const center = boundaryCurve.boundingBox.center;\n        const p0 = new Point(center.x - w / 4, center.y);\n        const p1 = new Point(center.x - w / 4, center.y - h / 2 - howMuchToStickOut);\n        const p2 = new Point(center.x + w / 4, center.y - h / 2 - howMuchToStickOut);\n        const p3 = new Point(center.x + w / 4, center.y);\n        t.smoothedPolyline = SmoothedPolyline.mkFromPoints([p0, p1, p2, p3]);\n        return t.smoothedPolyline.createCurve();\n    }\n    underCollapsedGraph() {\n        return this.source.underCollapsedGraph() || this.target.underCollapsedGraph();\n    }\n    EdgeToAncestor() {\n        return this.edge.EdgeToAncestor();\n    }\n}\nfunction topOfBezierSeg(e) {\n    return Point.lineLineIntersection(e.b[0], e.b[1], e.b[2], e.b[3]);\n}\n//# sourceMappingURL=geomEdge.js.map","import { Graph } from '../../structs/graph';\nimport { Rectangle, Size } from '../../math/geometry/rectangle';\nimport { GeomObject } from './geomObject';\nimport { GeomNode } from './geomNode';\nimport { GeomEdge } from './geomEdge';\nimport { PlaneTransformation } from '../../math/geometry/planeTransformation';\nimport { Point } from '../../math/geometry/point';\nimport { OptimalRectanglePacking } from '../../math/geometry/rectanglePacking/OptimalRectanglePacking';\nimport { mkRTree } from '../../math/geometry/RTree/rTree';\nimport { Curve, interpolateICurve, PointLocation } from '../../math/geometry';\nimport { RRect } from './RRect';\nimport { AttributeRegistry } from '../../structs/attributeRegistry';\nimport { Edge } from '../../structs/edge';\nimport { Node } from '../../structs/node';\nimport { PointPair } from '../../math/geometry/pointPair';\n// packs the subgraphs and set the bounding box of the parent graph\nexport function optimalPackingRunner(geomGraph, subGraphs) {\n    const subgraphsRects = subGraphs.map((g) => [g, g.boundingBox]); // g.boundingBox is a clone of the graph rectangle\n    const rectangles = subgraphsRects.map((t) => t[1]);\n    const packing = new OptimalRectanglePacking(rectangles, 1.5);\n    packing.run();\n    for (const [g, rect] of subgraphsRects) {\n        const delta = rect.leftBottom.sub(g.boundingBox.leftBottom);\n        g.translate(delta);\n    }\n    geomGraph.boundingBox = new Rectangle({\n        left: 0,\n        bottom: 0,\n        right: packing.PackedWidth,\n        top: packing.PackedHeight,\n    });\n}\n/** GeomGraph is an attribute on a Graph. The underlying Graph keeps all structural information but GeomGraph holds the geometry data, and the layout settings */\nexport class GeomGraph extends GeomNode {\n    isAncestor(source) {\n        return this.graph.isAncestor(source.node);\n    }\n    deepTranslate(delta) {\n        for (const n of this.nodesBreadthFirst) {\n            if (n instanceof GeomGraph) {\n                n.boundingBox = n.boundingBox.translate(delta);\n            }\n            else {\n                n.translate(delta);\n            }\n            for (const e of n.selfEdges()) {\n                e.translate(delta);\n            }\n            for (const e of n.outEdges()) {\n                if (this.graph.isAncestor(e.target.node))\n                    e.translate(delta);\n            }\n        }\n        this.boundingBox = this.boundingBox.translate(delta);\n    }\n    /** it is a rather shallow clone */\n    clone() {\n        const gg = new GeomGraph(null);\n        gg.boundingBox = this.boundingBox.clone();\n        gg.layoutSettings = this.layoutSettings;\n        gg.margins = this.margins;\n        gg.radX = this.radX;\n        gg.radY = this.radY;\n        return gg;\n    }\n    /** Calculate bounding box from children, not updating the bounding boxes recursively. */\n    calculateBoundsFromChildren() {\n        const bb = Rectangle.mkEmpty();\n        for (const n of this.shallowNodes) {\n            bb.addRecSelf(n.boundingBoxWithPadding);\n        }\n        bb.padEverywhere(this.margins);\n        return bb;\n    }\n    *allSuccessorsWidthFirst() {\n        for (const n of this.graph.allSuccessorsWidthFirst()) {\n            yield GeomNode.getGeom(n);\n        }\n    }\n    static getGeom(attrCont) {\n        return GeomObject.getGeom(attrCont);\n    }\n    edgeCurveOrArrowheadsIntersectRect(geomEdge, rect) {\n        for (const p of geomEdge.sourceArrowheadPoints(25)) {\n            if (rect.contains(p))\n                return true;\n        }\n        for (const p of geomEdge.targetArrowheadPoints(25)) {\n            if (rect.contains(p))\n                return true;\n        }\n        const curveUnderTest = geomEdge.curve;\n        const perimeter = rect.perimeter();\n        return (Curve.intersectionOne(curveUnderTest, perimeter, false) != null ||\n            Curve.PointRelativeToCurveLocation(curveUnderTest.start, perimeter) === PointLocation.Inside);\n    }\n    isEmpty() {\n        return this.graph.isEmpty();\n    }\n    setSettingsRecursively(ls) {\n        this.layoutSettings = ls;\n        for (const n of this.nodesBreadthFirst) {\n            const gg = n;\n            gg.layoutSettings = ls;\n        }\n    }\n    get layoutSettings() {\n        return this._layoutSettings;\n    }\n    // recursively sets the same settings for subgraphs\n    set layoutSettings(value) {\n        this._layoutSettings = value;\n    }\n    get labelSize() {\n        return this._labelSize;\n    }\n    set labelSize(value) {\n        this._labelSize = value;\n    }\n    get boundingBox() {\n        if (this.rrect)\n            return this.rrect.clone();\n        else\n            return null;\n    }\n    set boundingBox(value) {\n        if (value) {\n            this.rrect.setRect(value);\n        }\n        else {\n            this.rrect.roundedRect_ = null;\n        }\n        // Assert.assert(this.bbIsCorrect())\n    }\n    transform(matrix) {\n        if (matrix.isIdentity())\n            return;\n        for (const n of this.shallowNodes) {\n            n.transform(matrix);\n        }\n        for (const e of this.shallowEdges) {\n            e.transform(matrix);\n            if (e.label)\n                e.label.transform(matrix);\n        }\n        this.boundingBox =\n            this.rrect == null || this.rrect.isEmpty() ? this.pumpTheBoxToTheGraphWithMargins() : this.boundingBox.transform(matrix);\n    }\n    /** Contrary to the deepTranslate() it also translates edges leading out of the graph */\n    translate(delta) {\n        if (delta.x === 0 && delta.y === 0)\n            return;\n        this.deepTranslate(delta);\n    }\n    get nodesBreadthFirst() {\n        return this.nodesBreadthFirstIter();\n    }\n    *nodesBreadthFirstIter() {\n        for (const n of this.graph.nodesBreadthFirst) {\n            yield GeomObject.getGeom(n);\n        }\n    }\n    setEdge(s, t) {\n        const structEdge = this.graph.setEdge(s, t);\n        return new GeomEdge(structEdge);\n    }\n    /** this does not change the graph bounding box */\n    getPumpedGraphWithMarginsBox() {\n        const t = { b: Rectangle.mkEmpty() };\n        pumpTheBoxToTheGraph(this, t);\n        t.b.padEverywhere(this.margins);\n        return t.b;\n    }\n    /** sets the bounding box and the boundary curve as well */\n    pumpTheBoxToTheGraphWithMargins() {\n        return (this.boundingBox = this.getPumpedGraphWithMarginsBox());\n    }\n    // Fields which are set by Msagl\n    // return the center of the curve bounding box\n    get center() {\n        return this.boundingBox || this.boundingBox.isEmpty ? this.boundingBox.center : new Point(0, 0);\n    }\n    set center(value) {\n        // Assert.assert(this.bbIsCorrect())\n        const del = value.sub(this.center);\n        const t = new PlaneTransformation(1, 0, del.x, 0, 1, del.y);\n        this.transform(t);\n    }\n    get left() {\n        return this.boundingBox.left;\n    }\n    get right() {\n        return this.boundingBox.right;\n    }\n    get top() {\n        return this.boundingBox.top;\n    }\n    get bottom() {\n        return this.boundingBox.bottom;\n    }\n    CheckClusterConsistency() {\n        throw new Error('Method not implemented.');\n    }\n    get edgeCount() {\n        return this.graph.edgeCount;\n    }\n    get boundaryCurve() {\n        // Assert.assert(this.rrect.isOk())\n        return this.rrect.roundedRect_;\n    }\n    set boundaryCurve(value) {\n        throw new Error();\n    }\n    get shallowNodes() {\n        return this.shallowNodes_();\n    }\n    *shallowNodes_() {\n        for (const n of this.graph.shallowNodes)\n            yield GeomObject.getGeom(n);\n    }\n    /** iterates over the edges of the graph which adjacent to the nodes of the graph:\n     * not iterating over the subgraphs\n     */\n    /** iterates over the edges of the graph including subgraphs */\n    get deepEdges() {\n        return this.deepEdgesIt();\n    }\n    *deepEdgesIt() {\n        for (const e of this.graph.deepEdges) {\n            yield GeomObject.getGeom(e);\n        }\n    }\n    get shallowEdges() {\n        return this.shallowEdgesIt();\n    }\n    *shallowEdgesIt() {\n        for (const e of this.graph.shallowEdges) {\n            yield GeomObject.getGeom(e);\n        }\n    }\n    static mk(id, labelSize = new Size(0, 0)) {\n        const g = new GeomGraph(new Graph(id));\n        g.labelSize = labelSize;\n        return g;\n    }\n    get Clusters() {\n        return this.subgraphs();\n    }\n    /** iterates over all subgraphs  */\n    *subgraphs() {\n        for (const g of this.graph.subgraphsBreadthFirst()) {\n            yield GeomObject.getGeom(g);\n        }\n    }\n    static mkWithGraphAndLabel(graph, labelSize) {\n        const g = new GeomGraph(graph);\n        g.labelSize = labelSize;\n        return g;\n    }\n    constructor(graph) {\n        super(graph);\n        /** The empty space between the graph inner entities and its boundary */\n        this.margins = { left: 10, top: 10, bottom: 10, right: 10 };\n        /** The X radius of the rounded rectangle border */\n        this.radX = 10;\n        /** The Y radius of the rounded rectangle border */\n        this.radY = 10;\n        this.rrect = new RRect({ left: 0, right: -1, top: 20, bottom: 0, radX: this.radX, radY: this.radY });\n    }\n    get deepNodeCount() {\n        let n = 0;\n        for (const v of this.graph.nodesBreadthFirst)\n            n++;\n        return n;\n    }\n    get subgraphsDepthFirst() {\n        return this.getSubgraphsDepthFirst();\n    }\n    *getSubgraphsDepthFirst() {\n        for (const n of this.graph.allSuccessorsDepthFirst()) {\n            if (n instanceof Graph)\n                yield GeomGraph.getGeom(n);\n        }\n    }\n    get uniformMargins() {\n        return Math.max(this.margins.left, this.margins.right, this.margins.right, this.margins.bottom);\n    }\n    set uniformMargins(value) {\n        this.margins.left = this.margins.right = this.margins.right = this.margins.bottom = value;\n    }\n    get height() {\n        return this.boundingBox.height;\n    }\n    get width() {\n        return this.boundingBox.width;\n    }\n    get shallowNodeCount() {\n        return this.graph.shallowNodeCount;\n    }\n    get graph() {\n        return this.entity;\n    }\n    liftNode(n) {\n        const liftedNode = this.graph.liftNode(n.node);\n        return liftedNode ? GeomObject.getGeom(liftedNode) : null;\n    }\n    findNode(id) {\n        const n = this.graph.findNode(id);\n        if (!n)\n            return null;\n        return GeomObject.getGeom(n);\n    }\n    addNode(gn) {\n        this.graph.addNode(gn.node);\n        return gn;\n    }\n    addLabelToGraphBB(rect) {\n        if (this.labelSize) {\n            rect.top += this.labelSize.height + 2; // 2 for label margin\n            if (rect.width < this.labelSize.width) {\n                rect.width = this.labelSize.width;\n            }\n        }\n    }\n}\nexport function pumpTheBoxToTheGraph(igraph, t) {\n    for (const e of igraph.shallowEdges) {\n        if (!isProperEdge(e))\n            continue;\n        const cb = e.curve.boundingBox;\n        // cb.pad(e.lineWidth)\n        t.b.addRecSelf(cb);\n        if (e.edge.label != null) {\n            const labelGeom = GeomObject.getGeom(e.edge.label);\n            if (labelGeom) {\n                t.b.addRecSelf(labelGeom.boundingBox);\n            }\n        }\n    }\n    for (const n of igraph.shallowNodes) {\n        if ('shallowEdges' in n) {\n            pumpTheBoxToTheGraph(n, t);\n        }\n        if (n.underCollapsedGraph() || !n.boundingBox)\n            continue;\n        t.b.addRecSelf(n.boundingBox);\n    }\n    if (igraph instanceof GeomGraph) {\n        igraph.addLabelToGraphBB(t.b);\n    }\n    function isProperEdge(geomEdge) {\n        if (geomEdge == null)\n            return false;\n        if (geomEdge.curve == null)\n            return false;\n        if (geomEdge.underCollapsedGraph())\n            return false;\n        if (igraph instanceof GeomGraph) {\n            const graph = igraph.entity;\n            return graph.isAncestor(geomEdge.source.entity) && graph.isAncestor(geomEdge.target.entity);\n        }\n        else {\n            return true;\n        }\n    }\n}\n/** iterate over the graph objects intersected by a rectangle: by default, return only the intersected nodes */\nexport function* intersectedObjects(rtree, rect, onlyNodes = true) {\n    const result = rtree.GetAllIntersecting(rect);\n    if (onlyNodes) {\n        for (const r of result) {\n            if (r instanceof Node)\n                yield r;\n        }\n    }\n    else {\n        // nodes and edges\n        for (const r of result) {\n            if (r instanceof Node || r instanceof Edge)\n                yield r;\n        }\n    }\n}\nexport function buildRTree(graph) {\n    const data = Array.from(graph.nodesBreadthFirst)\n        .concat(Array.from(graph.deepEdges))\n        .map((o) => [GeomObject.getGeom(o).boundingBox, o]);\n    return mkRTree(data);\n}\nexport function* getGeomIntersectedObjects(tree, slack, point) {\n    if (!tree)\n        return;\n    const rect = Rectangle.mkSizeCenter(new Size(slack * 2), point);\n    for (const t of tree.RootNode.AllHitItems(rect, null)) {\n        if ('edge' in t) {\n            if (dist(point, t.pp._first, t.pp._second) < slack) {\n                yield GeomObject.getGeom(t.edge);\n            }\n        }\n        else {\n            yield GeomObject.getGeom(t);\n        }\n    }\n    function dist(p, s, e) {\n        const l = e.sub(s);\n        const len = l.length;\n        if (len < 1.0 / 10) {\n            return p.sub(Point.middle(s, e)).length;\n        }\n        const perp = l.rotate90Cw();\n        return Math.abs(p.sub(s).dot(perp)) / len;\n    }\n}\nexport function buildRTreeWithInterpolatedEdges(graph, slack) {\n    if (graph == null)\n        return null;\n    const nodes = Array.from(graph.nodesBreadthFirst).map((n) => [GeomNode.getGeom(n).boundingBox, n]);\n    const edgesPlusEdgeLabels = [];\n    for (const e of graph.deepEdges) {\n        const ge = e.getAttr(AttributeRegistry.GeomObjectIndex);\n        if (!ge)\n            continue;\n        if (ge.label) {\n            edgesPlusEdgeLabels.push([ge.label.boundingBox, e.label]);\n        }\n        if (!ge.curve)\n            continue;\n        const poly = interpolateICurve(ge.curve, slack / 2);\n        if (ge.sourceArrowhead) {\n            edgesPlusEdgeLabels.push([\n                Rectangle.mkPP(ge.sourceArrowhead.tipPosition, ge.curve.start),\n                { edge: e, pp: new PointPair(ge.sourceArrowhead.tipPosition, ge.curve.start) },\n            ]);\n        }\n        for (let i = 0; i < poly.length - 1; i++) {\n            edgesPlusEdgeLabels.push([Rectangle.mkPP(poly[i], poly[i + 1]), { edge: e, pp: new PointPair(poly[i], poly[i + 1]) }]);\n        }\n        if (ge.targetArrowhead) {\n            edgesPlusEdgeLabels.push([\n                Rectangle.mkPP(ge.curve.end, ge.targetArrowhead.tipPosition),\n                { edge: e, pp: new PointPair(ge.curve.end, ge.targetArrowhead.tipPosition) },\n            ]);\n        }\n    }\n    const t = nodes.concat(edgesPlusEdgeLabels);\n    return mkRTree(t);\n}\n//# sourceMappingURL=geomGraph.js.map","import { Rectangle } from './../../math/geometry/rectangle';\nimport { Point } from '../../math/geometry';\nimport { GeomObject } from './geomObject';\nexport class GeomLabel extends GeomObject {\n    /** clones but does not bind to the entity and does not set the parent edge*/\n    clone() {\n        const ret = new GeomLabel(null, null);\n        ret.isPositioned = this.isPositioned;\n        ret._boundingBox = this._boundingBox.clone();\n        ret.attachmentSegmentEnd = this.attachmentSegmentEnd;\n        ret.attachmentSegmentStart = this.attachmentSegmentStart;\n        return ret;\n    }\n    get isPositioned() {\n        return this._isPositioned;\n    }\n    set isPositioned(value) {\n        this._isPositioned = value;\n    }\n    constructor(entity, size) {\n        super(entity);\n        this._isPositioned = false;\n        if (size) {\n            this.boundingBox = Rectangle.mkPP(new Point(0, 0), new Point(size.width, size.height));\n        }\n    }\n    get boundingBox() {\n        return this._boundingBox;\n    }\n    set boundingBox(value) {\n        this._boundingBox = value;\n    }\n    setBoundingBox(b) {\n        this.isPositioned = true;\n        this._boundingBox = b;\n    }\n    get width() {\n        return this.boundingBox.width;\n    }\n    set width(value) {\n        this.boundingBox.width = value;\n    }\n    get height() {\n        return this.boundingBox.height;\n    }\n    set height(value) {\n        this.boundingBox.height = value;\n    }\n    get center() {\n        return this.boundingBox.center;\n    }\n    set center(value) {\n        this.boundingBox.center = value;\n    }\n    translate(delta) {\n        if (this.isPositioned)\n            this.center = this.center.add(delta);\n    }\n    transform(m) {\n        if (this.isPositioned)\n            this.center = m.multiplyPoint(this.center);\n    }\n    positionCenter(p) {\n        this.boundingBox.center = p;\n        this.isPositioned = true;\n    }\n}\n//# sourceMappingURL=geomLabel.js.map","// A node of a GeomGraph\nimport { CurveFactory } from './../../math/geometry/curveFactory';\nimport { GeomObject } from './geomObject';\nimport { AttributeRegistry } from '../../structs/attributeRegistry';\nexport class GeomNode extends GeomObject {\n    constructor() {\n        super(...arguments);\n        this.padding = 1;\n    }\n    /** clones but does not bind to the entity */\n    clone() {\n        const ret = new GeomNode(null);\n        if (this.boundaryCurve)\n            ret.boundaryCurve = this.boundaryCurve.clone();\n        return ret;\n    }\n    translate(delta) {\n        if (delta.x === 0 && delta.y === 0)\n            return;\n        this.boundaryCurve.translate(delta);\n    }\n    toJSON() {\n        return { boundaryCurve: this.boundaryCurve, padding: this.padding };\n    }\n    get node() {\n        return this.entity;\n    }\n    get boundaryCurve() {\n        return this._boundaryCurve;\n    }\n    set boundaryCurve(value) {\n        if (value != null &&\n            value.boundingBox &&\n            (value.boundingBox.height < GeomNode.minHeight || value.boundingBox.width < GeomNode.minWidth)) {\n            value = CurveFactory.mkCircle(GeomNode.minWidth, value.boundingBox.center);\n        }\n        this._boundaryCurve = value;\n    }\n    get id() {\n        return this.node.id;\n    }\n    toString() {\n        return this.id;\n    }\n    // Creates a Node instance\n    static mkNode(curve, node) {\n        const n = new GeomNode(node);\n        n.boundaryCurve = curve;\n        return n;\n    }\n    // Fields which are set by Msagl\n    // return the center of the curve bounding box\n    get center() {\n        return this.boundaryCurve.boundingBox.center;\n    }\n    set center(value) {\n        const del = value.sub(this.center);\n        this.boundaryCurve.translate(del);\n    }\n    // sets the bounding curve scaled to fit the targetBounds\n    fitBoundaryCurveToTarget(targetBounds) {\n        if (this.boundaryCurve != null) {\n            // RoundedRect is special, rather then simply scaling the geometry we want to keep the corner radii constant\n            const radii = CurveFactory.isRoundedRect(this.boundaryCurve);\n            if (radii == null) {\n                /*Assert.assert(this.boundaryCurve.boundingBox.width > 0)*/\n                /*Assert.assert(this.boundaryCurve.boundingBox.height > 0)*/\n                const scaleX = targetBounds.width / this.boundaryCurve.boundingBox.width;\n                const scaleY = targetBounds.height / this.boundaryCurve.boundingBox.height;\n                this.boundaryCurve = this.boundaryCurve.scaleFromOrigin(scaleX, scaleY);\n                this.boundaryCurve.translate(targetBounds.center.sub(this.boundaryCurve.boundingBox.center));\n            }\n            else {\n                this.boundaryCurve = CurveFactory.mkRectangleWithRoundedCorners(targetBounds.width, targetBounds.height, radii.radX, radii.radY, targetBounds.center);\n            }\n        }\n    }\n    static getGeom(attrCont) {\n        return attrCont.getAttr(AttributeRegistry.GeomObjectIndex);\n    }\n    *inEdges() {\n        for (const e of this.node.inEdges) {\n            yield GeomObject.getGeom(e);\n        }\n    }\n    *outEdges() {\n        for (const e of this.node.outEdges) {\n            yield GeomObject.getGeom(e);\n        }\n    }\n    *selfEdges() {\n        for (const e of this.node.selfEdges) {\n            yield GeomObject.getGeom(e);\n        }\n    }\n    /** creates a new rectangle equal to the padded  */\n    get boundingBoxWithPadding() {\n        const ret = this.boundingBox.clone();\n        ret.pad(this.padding);\n        return ret;\n    }\n    // the bounding box of the node\n    get boundingBox() {\n        return this.boundaryCurve ? this.boundaryCurve.boundingBox : null;\n    }\n    set boundingBox(value) {\n        if (!this.boundaryCurve) {\n            return;\n        }\n        if (Math.abs(value.width - this.width) < 0.0001 && Math.abs(value.height - this.height) < 0.0001) {\n            this.center = value.center;\n        }\n        else {\n            this.fitBoundaryCurveToTarget(value);\n        }\n    }\n    // width of the node does not include the padding\n    get width() {\n        return this.boundaryCurve.boundingBox.width;\n    }\n    // height of the node does not including the padding\n    get height() {\n        return this.boundaryCurve.boundingBox.height;\n    }\n    transform(t) {\n        if (this.boundaryCurve != null) {\n            this.boundaryCurve = this.boundaryCurve.transform(t);\n        }\n    }\n    underCollapsedGraph() {\n        const graph = this.node.parent;\n        if (graph == null)\n            return false;\n        const gGraph = GeomObject.getGeom(graph);\n        if (gGraph == null)\n            return false;\n        if (gGraph.isCollapsed) {\n            return true;\n        }\n        return gGraph.underCollapsedGraph();\n    }\n    *getAncestors() {\n        for (const g of this.node.getAncestors()) {\n            yield GeomObject.getGeom(g);\n        }\n    }\n}\nGeomNode.minHeight = 2;\nGeomNode.minWidth = 3;\n//# sourceMappingURL=geomNode.js.map","import { Attribute } from '../../structs/attribute';\nimport { AttributeRegistry } from '../../structs/attributeRegistry';\n/** represents a set of functions to handle an event */\nexport class EventHandler {\n    constructor() {\n        this.actions = new Set();\n    }\n    forEach(action) {\n        this.actions.forEach((a) => a(action, null));\n    }\n    subscribe(f) {\n        this.actions.add(f);\n    }\n    unsubscribe(f) {\n        this.actions.delete(f);\n    }\n    raise(a, b) {\n        this.actions.forEach((f) => f(a, b));\n    }\n}\nexport class GeomObject extends Attribute {\n    constructor(entity) {\n        super(entity, AttributeRegistry.GeomObjectIndex);\n    }\n    static getGeom(attrCont) {\n        if (attrCont == null)\n            return null;\n        return attrCont.getAttr(AttributeRegistry.GeomObjectIndex);\n    }\n    get parent() {\n        const p = this.entity.parent;\n        return p ? GeomObject.getGeom(p) : null;\n    }\n    rebind(e) {\n        this.entity = e;\n        this.bind(AttributeRegistry.GeomObjectIndex);\n    }\n    *getAncestors() {\n        let p = this.parent;\n        while (p != null) {\n            yield p;\n            p = p.parent;\n        }\n    }\n}\n//# sourceMappingURL=geomObject.js.map","// This port is for an edge connecting a node inside of the curve going out of the curve and creating a hook to\n// connect to the curve\nimport { Port } from './port';\nexport class HookUpAnywhereFromInsidePort extends Port {\n    mk(boundaryCurve, hookSize) {\n        const ret = new HookUpAnywhereFromInsidePort(boundaryCurve);\n        ret.HookSize = hookSize;\n        return ret;\n    }\n    constructor(boundaryCurve) {\n        super();\n        this.adjustmentAngle = Math.PI / 10;\n        this.hookSize = 9;\n        this.curve = boundaryCurve;\n        this.location = this.curve().start;\n    }\n    // returns a point on the boundary curve\n    get Location() {\n        return this.location;\n    }\n    // Gets the boundary curve of the port.\n    get Curve() {\n        return this.curve();\n    }\n    SetLocation(p) {\n        this.location = p;\n    }\n    // We are trying to correct the last segment of the polyline by make it perpendicular to the Port.Curve.\n    // For this purpose we trim the curve by the cone of the angle 2*adjustment angle and project the point before the last of the polyline to this curve.\n    get AdjustmentAngle() {\n        return this.adjustmentAngle;\n    }\n    set AdjustmentAngle(value) {\n        this.adjustmentAngle = value;\n    }\n    // the size of the self-loop\n    get HookSize() {\n        return this.hookSize;\n    }\n    set HookSize(value) {\n        this.hookSize = value;\n    }\n}\n//# sourceMappingURL=hookUpAnywhereFromInsidePort.js.map","export class Port {\n}\n//# sourceMappingURL=port.js.map","import { Point } from '../../math/geometry/point';\nimport { FloatingPort } from './floatingPort';\nexport class RelativeFloatingPort extends FloatingPort {\n    static mk(boundaryDelegate, centerDelegate) {\n        return new RelativeFloatingPort(boundaryDelegate, centerDelegate, new Point(0, 0));\n    }\n    // the delegate returning center\n    get CenterDelegate() {\n        return this.centerDelegate;\n    }\n    set CenterDelegate(value) {\n        this.centerDelegate = value;\n    }\n    // the delegate returning center\n    get CurveDelegate() {\n        return this.curveDelegate;\n    }\n    set CurveDelegate(value) {\n        this.curveDelegate = value;\n    }\n    //\n    //        // The node where we calculate our location and Curve from\n    //\n    //        public Node RelativeTo { get; private set; }\n    // An offset relative to the Center of the Node that we use to calculate Location\n    get LocationOffset() {\n        return this.locationOffset;\n    }\n    set LocationOffset(value) {\n        this.locationOffset = value;\n    }\n    // Create a port relative to a specific node with an offset for the port Location from the nodes center\n    constructor(curveDelegate, centerDelegate, locationOffset) {\n        super(null, centerDelegate().add(locationOffset));\n        this.LocationOffset = locationOffset;\n        this.CurveDelegate = curveDelegate;\n        this.CenterDelegate = centerDelegate;\n    }\n    //\n    // // Create a port relative to the center of a specific node\n    //\n    // public constructor (curveDelegate: Func<ICurve>, centerDelegate: Func<Point>) :\n    //        this(curveDelegate, centerDelegate, new Point()) {\n    // }\n    // Get the location = CenterDelegate() + LocationOffset\n    get Location() {\n        return this.CenterDelegate().add(this.LocationOffset);\n    }\n    // Get the curve from the node's BoundaryCurve\n    get Curve() {\n        return this.CurveDelegate();\n    }\n}\n//# sourceMappingURL=relativeFloatingPort.js.map","import { GeomNode } from './geomNode';\nimport { GeomLabel } from './geomLabel';\nimport { Curve } from '../../math/geometry';\nimport { Assert } from '../../utils/assert';\n/** keeps the data needed to render a tile, and some fields for optimizations */\nexport class Tile {\n    get curveClips() {\n        return this._curveClips;\n    }\n    set curveClips(value) {\n        this._curveClips = value;\n    }\n    constructor(rect) {\n        this._curveClips = [];\n        this.arrowheads = [];\n        this.nodes = [];\n        this.labels = [];\n        this.rect = rect;\n        this._curveClips = [];\n    }\n    addCurveClip(cc) {\n        Assert.assert(!(cc.curve instanceof Curve), 'CurveClip.curve should not be a Curve!');\n        this._curveClips.push(cc);\n    }\n    isEmpty() {\n        return this._curveClips.length == 0 && this.arrowheads.length == 0 && this.nodes.length == 0 && this.labels.length == 0;\n    }\n    initCurveClips() {\n        this._curveClips = [];\n    }\n    /** clears all arrays but does not touch this.rect */\n    clear() {\n        this.arrowheads = [];\n        this.nodes = [];\n        this.labels = [];\n        this._curveClips = [];\n    }\n    /** returns the number of entities that will be rendered for a tile: each bundle is counted as one entity */\n    get entityCount() {\n        return this._curveClips.length + this.arrowheads.length + this.labels.length + this.nodes.length;\n    }\n    addElement(data) {\n        if (data instanceof GeomNode) {\n            this.nodes.push(data);\n        }\n        else if (data instanceof GeomLabel) {\n            this.labels.push(data);\n        }\n        else if ('curve' in data) {\n            if (data.curve instanceof Curve) {\n                for (const seg of data.curve.segs) {\n                    this.addCurveClip({ edge: data.edge, curve: seg, startPar: seg.parStart, endPar: seg.parEnd });\n                }\n            }\n            else {\n                this.addCurveClip(data);\n            }\n        }\n        else {\n            this.arrowheads.push(data);\n        }\n    }\n}\n//# sourceMappingURL=tile.js.map","import { edgeNodesBelongToSet, pagerank } from '../../structs/graph';\nimport { Rectangle, Size } from '../../math/geometry/rectangle';\nimport { GeomEdge } from './geomEdge';\nimport { IntPairMap } from '../../utils/IntPairMap';\nimport { Curve } from '../../math/geometry/curve';\nimport { GeomGraph } from './geomGraph';\nimport { GeomConstants, LineSegment } from '../../math/geometry';\nimport { Tile } from './tile';\nimport { IntPair } from '../../utils/IntPair';\nimport { SplineRouter } from '../../routing/splineRouter';\nimport { Assert } from '../../utils/assert';\n//const debCount = 0\n/** keeps the data needed to render the tile hierarchy */\nexport class TileMap {\n    /** retrieves the data for a single tile(x-y-z) */\n    getTileData(x, y, z) {\n        const mapOnLevel = this.levels[z];\n        if (!mapOnLevel)\n            return null;\n        return mapOnLevel.get(x, y);\n    }\n    /** retrieves all the tiles of z-th level */\n    *getTilesOfLevel(z) {\n        const tm = this.levels[z];\n        if (tm == null)\n            return;\n        for (const [key, val] of tm.keyValues()) {\n            yield { x: key.x, y: key.y, data: val };\n        }\n    }\n    /** geomGraph  - the graph to work with.\n     * The topLevelTileRect serves as the only tile of the top level.\n     */\n    constructor(geomGraph, topLevelTileRect) {\n        this.numberOfNodesOnLevel = [];\n        this.nodeScales = [];\n        /** the maximal number visual elements vizible in a tile */\n        this.tileCapacity = 5000; // in the number of elements\n        /** the tiles of level z is represented by levels[z] */\n        this.levels = [];\n        this.nodeIndexInSortedNodes = new Map();\n        this.geomGraph = geomGraph;\n        this.topLevelTileRect = topLevelTileRect;\n        this.tileSizes = [];\n        this.tileSizes.push(topLevelTileRect.size);\n    }\n    getMinTileSize() {\n        let w = 0;\n        let h = 0;\n        let n = 0;\n        for (const node of this.geomGraph.nodesBreadthFirst) {\n            if (node instanceof GeomGraph)\n                continue;\n            if (n == 0) {\n                w = node.width;\n                h = node.height;\n            }\n            else {\n                w = (n * w + node.width) / (n + 1);\n                h = (n * h + node.height) / (n + 1);\n            }\n            n++;\n        }\n        return new Size(w * 10, h * 10);\n    }\n    fillTheLowestLayer() {\n        const tileMap = new IntPairMap();\n        const topLevelTile = new Tile(this.topLevelTileRect);\n        const arrows = topLevelTile.arrowheads;\n        const geomLabels = topLevelTile.labels;\n        for (const e of this.geomGraph.graph.deepEdges) {\n            addEdgeToTiles(e);\n        }\n        // geomLabels and arrowheads are sorted, because edges are sorted: all arrays of TileData are sorted by rank\n        topLevelTile.nodes = Array.from(this.geomGraph.nodesBreadthFirst);\n        tileMap.set(0, 0, topLevelTile);\n        this.levels.push(tileMap);\n        function addEdgeToTiles(e) {\n            const geomEdge = GeomEdge.getGeom(e);\n            const c = GeomEdge.getGeom(e).curve;\n            if (c instanceof Curve) {\n                for (const seg of c.segs) {\n                    topLevelTile.addElement({ edge: e, curve: seg, startPar: seg.parStart, endPar: seg.parEnd });\n                }\n            }\n            else {\n                topLevelTile.addElement({ edge: e, curve: c, startPar: c.parStart, endPar: c.parEnd });\n            }\n            if (geomEdge.sourceArrowhead) {\n                arrows.push({ edge: geomEdge.edge, tip: geomEdge.sourceArrowhead.tipPosition, base: geomEdge.curve.start });\n            }\n            if (geomEdge.targetArrowhead) {\n                arrows.push({ edge: geomEdge.edge, tip: geomEdge.targetArrowhead.tipPosition, base: geomEdge.curve.end });\n            }\n            if (geomEdge.label) {\n                geomLabels.push(geomEdge.label);\n            }\n        }\n    }\n    /**\n     * Creates tilings for levels from 0 to z, including the level z.\n     * The method does not necesserely creates all levels until z, but can exit earlier\n     *  if all tiles either has size smaller or equal than this.minTileSize or have at most this.tileCapacityMin elements.\n     * Returns the number of created levels.\n     */\n    buildUpToLevel(z) {\n        this.fillTheLowestLayer();\n        this.minTileSize = this.getMinTileSize();\n        this.pageRank = pagerank(this.geomGraph.graph, 0.85);\n        if (!this.needToSubdivide())\n            return 1; // we have only one layer\n        for (let i = 1; i <= z; i++) {\n            if (this.subdivideLevel(i)) {\n                break;\n            }\n        }\n        this.sortedNodes = Array.from(this.pageRank.keys()).sort(this.compareByPagerank.bind(this));\n        for (let i = 0; i < this.sortedNodes.length; i++) {\n            this.nodeIndexInSortedNodes.set(this.sortedNodes[i], i);\n        }\n        // filter out entities that are not visible on lower layers.\n        // do not filter the uppermost layer: it should show everything\n        for (let i = 0; i < this.levels.length - 1; i++) {\n            this.numberOfNodesOnLevel.push(this.filterOutEntities(this.levels[i], i));\n        }\n        this.numberOfNodesOnLevel.push(this.sortedNodes.length);\n        // for (let i = 0; i < this.levels.length; i++) {\n        //   this.checkLevel(i)\n        // }\n        const sr = new SplineRouter(this.geomGraph, []);\n        for (let i = this.levels.length - 2; i >= 0; i--) {\n            const activeNodes = this.setOfNodesOnTheLevel(i);\n            sr.rerouteOnSubsetOfNodes(activeNodes);\n            this.regenerateCurveClipsUpToLevel(i, activeNodes);\n        }\n        // for (let i = 0; i < this.levels.length; i++) {\n        //   this.checkLevel(i)\n        // }\n        this.calculateNodeRank();\n        //this.makeSomeNodesVizible()\n        //Assert.assert(this.lastLayerHasAllNodes())\n        return this.levels.length;\n    }\n    // private makeSomeNodesVizible() {\n    //   for (let levelIndex = 0; levelIndex < this.levels.length - 1; levelIndex++) {\n    //     this.calculateNodeAdditionalScales(levelIndex)\n    //   }\n    // }\n    // calculateNodeAdditionalScalesOnLevelZero() {\n    //   const tree = new RTree()\n    //   // we always get at least one intersection with the whole graph record\n    //   tree.batchInsert([\n    //     {\n    //       x: this.geomGraph.left,\n    //       y: this.geomGraph.bottom,\n    //       width: this.geomGraph.width,\n    //       height: this.geomGraph.height,\n    //       data: {node: this.geomGraph.graph, nodeBB: this.geomGraph.boundingBox},\n    //     },\n    //   ]) // to init with the whole\n    //   const scales = new Map<Node, number>()\n    //   this.nodeScales.push(scales)\n    //   // with this scale the node will be rendered at level[this.level.length -1]\n    //   let scale = Math.pow(2, this.levels.length - 1)\n    //   for (let j = 0; j < this.numberOfNodesOnLevel[0]; j++) {\n    //     const n = this.sortedNodes[j]\n    //     scale = this.findMaxScaleToNotIntersectTree(n, tree, scale)\n    //     if (scale < 1.1) break // getting almost no enlargement\n    //     scales.set(n, scale)\n    //   }\n    // }\n    // findMaxScaleToNotIntersectTree(n: Node, tree: RTree, maxScale: number): number {\n    //   const geomNode = GeomNode.getGeom(n)\n    //   let nodeBB = geomNode.boundingBox\n    //   // make sure that we are not rendering the node outside of  the the graph bounding box\n    //   maxScale = Math.min(this.keepInsideGraphBoundingBox(nodeBB), maxScale)\n    //   const ret = this.intersectWithTreeAndGetScale(tree, nodeBB, maxScale)\n    //   // use the resulting bounding box and insert it to the tree\n    //   nodeBB = geomNode.boundingBox.clone()\n    //   nodeBB.scaleAroundCenter(ret)\n    //   tree.insert({x: nodeBB.left, y: nodeBB.bottom, width: nodeBB.width, height: nodeBB.height, data: {node: n, nodeBB: nodeBB}})\n    //   return ret\n    // }\n    /** returns the maximal scale keeping nodeBB inside of the graph bounding box */\n    keepInsideGraphBoundingBox(nodeBB) {\n        const graphBB = this.geomGraph.boundingBox;\n        const w = nodeBB.width / 2;\n        const h = nodeBB.height / 2;\n        const keepInsideScale = Math.min(\n        // left stays inside\n        (nodeBB.center.x - graphBB.left) / w, \n        // top stays inside\n        (graphBB.top - nodeBB.center.y) / h, \n        // right stays inside\n        (graphBB.right - nodeBB.center.x) / w, \n        //bottom stays inside\n        (nodeBB.center.y - graphBB.bottom) / h);\n        return keepInsideScale;\n    }\n    // intersectWithTreeAndGetScale(tree: RTree, nodeBB: Rectangle, maxScale: number): number {\n    //   const xx = tree.search({x: nodeBB.left, y: nodeBB.bottom, width: nodeBB.width, height: nodeBB.height}) as {\n    //     node: Node\n    //     nodeBB: Rectangle\n    //   }[]\n    //   if (xx.length == 1) return maxScale // there is always one intersection with the whole graph\n    //   let scale = maxScale\n    //   for (const x of xx) {\n    //     if (x.node == this.geomGraph.graph) continue\n    //     scale = this.diminishScaleToAvoidTree(x.node, x.nodeBB, nodeBB)\n    //     if (scale == 1) return scale // no separation\n    //   }\n    //   return scale\n    // }\n    diminishScaleToAvoidTree(intersectedNode, intersectedRect, nodeBB) {\n        Assert.assert(intersectedRect.intersects(nodeBB));\n        let scaleX;\n        const x = nodeBB.center.x;\n        const y = nodeBB.center.y;\n        const h = nodeBB.height / 2;\n        const w = nodeBB.width / 2;\n        if (x < intersectedRect.left) {\n            scaleX = (intersectedRect.left - x) / h;\n        }\n        else if (x > intersectedRect.right) {\n            scaleX = (x - intersectedRect.right) / h;\n        }\n        else {\n            return 1;\n        }\n        let scaleY;\n        if (y < intersectedRect.bottom) {\n            scaleY = (intersectedRect.bottom - y) / w;\n        }\n        else if (y > intersectedRect.top) {\n            scaleY = (y - intersectedRect.top) / w;\n        }\n        else {\n            return scaleX;\n        }\n        return Math.min(scaleX, scaleY);\n    }\n    // calculateNodeAdditionalScales(levelIndex: number) {\n    //   const tree = new RTree()\n    //   // we always get at least one intersection with the whole graph record\n    //   tree.batchInsert([\n    //     {\n    //       x: this.geomGraph.left,\n    //       y: this.geomGraph.bottom,\n    //       width: this.geomGraph.width,\n    //       height: this.geomGraph.height,\n    //       data: {node: this.geomGraph.graph, nodeBB: this.geomGraph.boundingBox},\n    //     },\n    //   ]) // to init with the whole graph bounding box\n    //   const scales = new Map<Node, number>()\n    //   this.nodeScales.push(scales)\n    //   let scale = Math.pow(2, this.levels.length - 1 - levelIndex)\n    //   for (let j = 0; j < this.numberOfNodesOnLevel[levelIndex]; j++) {\n    //     const n = this.sortedNodes[j]\n    //     scale = this.findMaxScaleToNotIntersectTree(n, tree, scale)\n    //     if (scale <= 1) break\n    //     scales.set(n, scale)\n    //   }\n    // }\n    // findMaxScale(n: Node, levelIndex: number, tree: RTree, maxScale: number): number {\n    //   const geomNode = GeomNode.getGeom(n)\n    //   let boundingBox = geomNode.boundingBox.clone()\n    //   boundingBox.scaleAroundCenter(maxScale)\n    //   let ret = maxScale\n    //   while (ret > 1 && treeIntersectsRect(tree, boundingBox)) {\n    //     ret /= 2\n    //     if (ret < 1) ret = 1\n    //   }\n    //   boundingBox = geomNode.boundingBox.clone()\n    //   boundingBox.scaleAroundCenter(ret)\n    //   tree.insert({x: boundingBox.left, y: boundingBox.bottom, width: boundingBox.width, height: boundingBox.height})\n    //   return ret\n    // }\n    needToSubdivide() {\n        let needSubdivide = false;\n        for (const tile of this.levels[0].values()) {\n            if (tile.entityCount > this.tileCapacity) {\n                needSubdivide = true;\n                break;\n            }\n        }\n        return needSubdivide;\n    }\n    setOfNodesOnTheLevel(i) {\n        const ret = new Set();\n        for (const t of this.levels[i].values()) {\n            for (const node of t.nodes) {\n                ret.add(node.node);\n            }\n        }\n        return ret;\n    }\n    // checkLevel(i: number) {\n    //   const [edgeMap, nodeSet] = this.getEntityDataFromLevel(i)\n    //   for (const [e, entDataArray] of edgeMap) {\n    //     this.checkEntityDataArray(e, entDataArray, nodeSet)\n    //   }\n    // }\n    // checkEntityDataArray(e: Entity, entDataArray: EntityDataInTile[], nodeSet: Set<Node>) {\n    //   if (e instanceof Edge) {\n    //     if (!nodeSet.has(e.source)) {\n    //       Assert.assert(false)\n    //     }\n    //     if (!nodeSet.has(e.target)) {\n    //       Assert.assert(false)\n    //     }\n    //     let connectedToSource = false\n    //     let connectedToTarget = false\n    //     const ge = GeomEdge.getGeom(e)\n    //     const sb = ge.source.boundingBox\n    //     const tb = ge.target.boundingBox\n    //     for (const cc of entDataArray) {\n    //       if ('curve' in cc.data) {\n    //         Assert.assert(cc.data.edge === e)\n    //         const curve = cc.data.curve\n    //         if (sb.contains(curve.start)) connectedToSource = true\n    //         if (tb.contains(curve.end)) connectedToTarget = true\n    //       }\n    //     }\n    //     Assert.assert(connectedToSource && connectedToTarget)\n    //   }\n    // }\n    regenerateCurveClipsUpToLevel(levelIndex, activeNodes) {\n        this.clearCurveClipsInLevelsUpTo(levelIndex);\n        for (const t of this.levels[0].values()) {\n            this.regenerateCurveClipsUnderTileUpToLevel(t, levelIndex, activeNodes);\n        }\n    }\n    clearCurveClipsInLevelsUpTo(levelIndex) {\n        for (let i = 0; i <= levelIndex; i++) {\n            for (const t of this.levels[i].values()) {\n                t.initCurveClips();\n            }\n        }\n    }\n    regenerateCurveClipsUnderTileUpToLevel(t, levelIndex, activeNodes) {\n        t.arrowheads = [];\n        t.initCurveClips();\n        for (const geomEdge of this.geomGraph.deepEdges) {\n            if (!edgeNodesBelongToSet(geomEdge.edge, activeNodes))\n                continue;\n            if (geomEdge.curve instanceof Curve) {\n                for (const seg of geomEdge.curve.segs) {\n                    t.addElement({ edge: geomEdge.edge, curve: seg, startPar: seg.parStart, endPar: seg.parEnd });\n                }\n            }\n            else {\n                t.addElement({ edge: geomEdge.edge, curve: geomEdge.curve, startPar: geomEdge.curve.parStart, endPar: geomEdge.curve.parEnd });\n            }\n            if (geomEdge.sourceArrowhead) {\n                t.arrowheads.push({ edge: geomEdge.edge, tip: geomEdge.sourceArrowhead.tipPosition, base: geomEdge.curve.start });\n            }\n            if (geomEdge.targetArrowhead) {\n                t.arrowheads.push({ edge: geomEdge.edge, tip: geomEdge.targetArrowhead.tipPosition, base: geomEdge.curve.end });\n            }\n        }\n        // do not change the labels\n        // Now the root tile(s) is ready\n        for (let i = 1; i <= levelIndex; i++) {\n            this.regenerateCurveClipsWhenPreviosLayerIsDone(i);\n            this.removeEmptyTiles(i);\n        }\n    }\n    removeEmptyTiles(i) {\n        const level = this.levels[i];\n        const keysToDelete = [];\n        for (const [k, t] of level.keyValues()) {\n            if (t.isEmpty()) {\n                keysToDelete.push(k);\n            }\n        }\n        for (const k of keysToDelete) {\n            level.delete(k.x, k.y);\n        }\n    }\n    regenerateCurveClipsWhenPreviosLayerIsDone(z) {\n        for (const [key, tile] of this.levels[z - 1].keyValues()) {\n            this.subdivideTile(key, z, tile, /** for regenerate */ true);\n        }\n    }\n    // regenerateUnderOneTile(key: IntPair, upperTile: Tile, z: number) {\n    //   const subTilesRects = createSubTileRects()\n    //   const clipsPerRect = this.regenerateCurveClipsUnderTile(upperTile, subTilesRects)\n    //   pushRegeneratedClips(this.levels[z])\n    //   cleanArrowheadsInSubtiles(this.levels[z])\n    //   pushArrowheadsToSubtiles(this.levels[z])\n    //   cleanUpSubtilesAboveTile(this.levels[z])\n    //   function cleanUpSubtilesAboveTile(level: IntPairMap<Tile>) {\n    //     for (let i = 0; i < 2; i++)\n    //       for (let j = 0; j < 2; j++) {\n    //         const ti = 2 * key.x + i\n    //         const tj = 2 * key.y + j\n    //         const tile = level.get(ti, tj)\n    //         if (tile == null) continue\n    //         if (tile.isEmpty()) {\n    //           level.delete(ti, tj)\n    //         }\n    //       }\n    //   }\n    //   function pushArrowheadsToSubtiles(level: IntPairMap<Tile>) {\n    //     for (const arrowhead of upperTile.arrowheads) {\n    //       const arrowheadBox = Rectangle.mkPP(arrowhead.base, arrowhead.tip)\n    //       const d = arrowhead.tip.sub(arrowhead.base).div(3)\n    //       const dRotated = d.rotate90Cw()\n    //       arrowheadBox.add(arrowhead.base.add(dRotated))\n    //       arrowheadBox.add(arrowhead.base.sub(dRotated))\n    //       for (let i = 0; i < 2; i++)\n    //         for (let j = 0; j < 2; j++) {\n    //           const k = 2 * i + j\n    //           if (arrowheadBox.intersects(subTilesRects[k])) {\n    //             const ti = 2 * key.x + i\n    //             const tj = 2 * key.y + j\n    //             level.get(ti, tj).arrowheads.push(arrowhead)\n    //           }\n    //         }\n    //     }\n    //   }\n    //   function cleanArrowheadsInSubtiles(levelMap: IntPairMap<Tile>) {\n    //     for (let i = 0; i < 2; i++)\n    //       for (let j = 0; j < 2; j++) {\n    //         const ti = 2 * key.x + i\n    //         const tj = 2 * key.y + j\n    //         const tile = levelMap.get(ti, tj)\n    //         if (tile == null) {\n    //           continue\n    //         }\n    //         tile.arrowheads = []\n    //       }\n    //   }\n    //   function pushRegeneratedClips(levelMap: IntPairMap<Tile>) {\n    //     for (let i = 0; i < 2; i++)\n    //       for (let j = 0; j < 2; j++) {\n    //         const k = 2 * i + j\n    //         const clips = clipsPerRect[k]\n    //         const ti = 2 * key.x + i\n    //         const tj = 2 * key.y + j\n    //         let tile = levelMap.get(ti, tj)\n    //         if (tile == null) {\n    //           if (clips.length) {\n    //             levelMap.set(ti, tj, (tile = new Tile(subTilesRects[k])))\n    //           } else {\n    //             continue\n    //           }\n    //         }\n    //         tile.initCurveClips()\n    //         for (const clip of clips) {\n    //           tile.addElement({edge: clip.edge, curve: clip.curve})\n    //         }\n    //       }\n    //   }\n    //   function createSubTileRects() {\n    //     const subTilesRects = new Array<Rectangle>()\n    //     const w = upperTile.rect.width / 2\n    //     const h = upperTile.rect.height / 2\n    //     for (let i = 0; i < 2; i++)\n    //       for (let j = 0; j < 2; j++) {\n    //         const tileRect = new Rectangle({\n    //           left: upperTile.rect.left + w * i,\n    //           right: upperTile.rect.left + w * (i + 1),\n    //           bottom: upperTile.rect.bottom + h * j,\n    //           top: upperTile.rect.bottom + h * (j + 1),\n    //         })\n    //         subTilesRects.push(tileRect)\n    //       }\n    //     return subTilesRects\n    //   }\n    // }\n    // lastLayerHasAllNodes(): boolean {\n    //   const lastLayerNodes = new Set<Node>()\n    //   for (const tile of this.levels[this.levels.length - 1].values()) {\n    //     for (const n of tile.nodes) {\n    //       lastLayerNodes.add(n.node)\n    //     }\n    //   }\n    //   const gNodes = new Set<Node>(this.geomGraph.graph.nodesBreadthFirst)\n    //   return setsAreEqual(gNodes, lastLayerNodes)\n    // }\n    calculateNodeRank() {\n        this.nodeRank = new Map();\n        const n = this.sortedNodes.length;\n        const log_n_10 = Math.log10(n);\n        for (let i = 0; i < n; i++) {\n            this.nodeRank.set(this.sortedNodes[i], log_n_10 - Math.log10(i + 1));\n        }\n    }\n    compareByPagerank(u, v) {\n        return this.pageRank.get(v) - this.pageRank.get(u);\n    }\n    /** Fills the tiles up to the capacity.\n     * Returns the number of inserted node.\n     * An edge and its attributes is inserted just after its source and the target are inserted.\n     * The nodes are sorted by rank here.  */\n    filterOutEntities(levelToReduce, z) {\n        // create a map,edgeToIndexOfPrevLevel, from the prevLevel edges to integers,\n        // For each edge edgeToIndexOfPrevLevel.get(edge) = min {i: edge == tile.getCurveClips[i].edge}\n        const dataByEntityMap = this.transferDataOfLevelToMap(levelToReduce);\n        let k = 0;\n        for (; k < this.sortedNodes.length; k++) {\n            const node = this.sortedNodes[k];\n            if (!this.addNodeToLevel(levelToReduce, node, dataByEntityMap)) {\n                break;\n            }\n        }\n        this.removeEmptyTiles(z);\n        //dumpTiles(levelToReduce, z)\n        return k;\n    }\n    /** Goes over all tiles where 'node' had presence and tries to add.\n     *  If the above succeeds then all edges leading to the higher ranking nodes added without consulting with tileCapacity. The edge attributes added as well\n     */\n    addNodeToLevel(levelToReduce, node, dataByEntity) {\n        const entityToData = dataByEntity.get(node);\n        for (const edt of entityToData) {\n            const tile = edt.tile;\n            if (tile.entityCount >= this.tileCapacity) {\n                return false;\n            }\n        }\n        for (const edt of entityToData) {\n            const tile = edt.tile;\n            const data = edt.data;\n            tile.addElement(data);\n        }\n        for (const e of node.selfEdges) {\n            const ed = dataByEntity.get(e);\n            for (const edt of ed) {\n                const tile = edt.tile;\n                const data = edt.data;\n                tile.addElement(data);\n            }\n            if (e.label) {\n                for (const edt of dataByEntity.get(e.label)) {\n                    const tile = edt.tile;\n                    const data = edt.data;\n                    tile.addElement(data);\n                }\n            }\n        }\n        const nodeIndex = this.nodeIndexInSortedNodes.get(node);\n        for (const e of node.inEdges) {\n            const source = e.source;\n            const sourceIndex = this.nodeIndexInSortedNodes.get(source);\n            if (sourceIndex > nodeIndex)\n                continue;\n            for (const edt of dataByEntity.get(e)) {\n                const tile = edt.tile;\n                const data = edt.data;\n                tile.addElement(data);\n            }\n            if (e.label) {\n                for (const edt of dataByEntity.get(e.label)) {\n                    const tile = edt.tile;\n                    const data = edt.data;\n                    tile.addElement(data);\n                }\n            }\n        }\n        for (const e of node.outEdges) {\n            const target = e.target;\n            const targetIndex = this.nodeIndexInSortedNodes.get(target);\n            if (targetIndex > nodeIndex)\n                continue;\n            for (const edt of dataByEntity.get(e)) {\n                const tile = edt.tile;\n                const data = edt.data;\n                tile.addElement(data);\n            }\n            if (e.label) {\n                if (dataByEntity.get(e.label))\n                    for (const edt of dataByEntity.get(e.label)) {\n                        const tile = edt.tile;\n                        const data = edt.data;\n                        tile.addElement(data);\n                    }\n            }\n        }\n        return true;\n    }\n    transferDataOfLevelToMap(levelToReduce) {\n        const entityToData = new Map();\n        for (const tile of levelToReduce.values()) {\n            for (const clip of tile.curveClips) {\n                const edge = clip.edge;\n                const arr = getCreateEntityDataArray(edge);\n                arr.push({ tile: tile, data: clip });\n            }\n            for (const label of tile.labels) {\n                const edge = label.parent.edge;\n                const arr = getCreateEntityDataArray(edge);\n                arr.push({ tile: tile, data: label });\n            }\n            for (const gnode of tile.nodes) {\n                const node = gnode.node;\n                const arr = getCreateEntityDataArray(node);\n                arr.push({ tile: tile, data: gnode });\n            }\n            for (const arrowhead of tile.arrowheads) {\n                const edge = arrowhead.edge;\n                const arr = getCreateEntityDataArray(edge);\n                arr.push({ tile: tile, data: arrowhead });\n            }\n            tile.clear();\n        }\n        return entityToData;\n        function getCreateEntityDataArray(ent) {\n            let arr = entityToData.get(ent);\n            if (!arr) {\n                entityToData.set(ent, (arr = new Array()));\n            }\n            return arr;\n        }\n    }\n    /** It is assumed that the previous level z-1 have been calculated.\n     * Returns true if every edge is appears in some tile as the first edge\n     */\n    subdivideLevel(z) {\n        console.log('subdivideLevel', z);\n        const tilesInRow = Math.pow(2, z);\n        this.levels[z] = new IntPairMap();\n        /** the width and the height of z-th level tile */\n        const allTilesAreSmall = this.subdivideTilesOnLevel(z);\n        if (allTilesAreSmall) {\n            console.log('done subdividing at level', z, 'because each tile contains less than', this.tileCapacity);\n            return true;\n        }\n        const { w, h } = this.getWHOnLevel(z);\n        if (w <= this.minTileSize.width && h <= this.minTileSize.height) {\n            console.log('done subdividing at level', z, ' because of tile size = ', w, h, 'is less than ', this.minTileSize);\n            return true;\n        }\n        return false;\n    }\n    countClips(z) {\n        let count = 0;\n        for (const tile of this.levels[z].values()) {\n            count += tile.curveClips.length;\n        }\n        return count;\n    }\n    getWHOnLevel(z) {\n        for (let i = this.tileSizes.length; i <= z; i++) {\n            const s = this.tileSizes[i - 1];\n            this.tileSizes.push(new Size(s.width / 2, s.height / 2));\n        }\n        return { w: this.tileSizes[z].width, h: this.tileSizes[z].height };\n    }\n    subdivideTilesOnLevel(z) {\n        const tileCount = 0;\n        let allTilesAreSmall = true;\n        for (const [key, tile] of this.levels[z - 1].keyValues()) {\n            const res = this.subdivideTile(key, z, tile, false);\n            allTilesAreSmall && (allTilesAreSmall = res.allSmall);\n        }\n        this.removeEmptyTiles(z);\n        console.log('generated', this.levels[z].size, 'tiles');\n        return allTilesAreSmall;\n    }\n    subdivideTile(\n    /** the tile key */\n    key, z, // the level above the lowerTile level\n    /** this is the tile we are subdividing */\n    lowerTile, regenerate) {\n        const { w, h } = this.getWHOnLevel(z);\n        /** this is the map we collect new tiles to */\n        const levelTiles = this.levels[z];\n        const xp = key.x;\n        const yp = key.y;\n        const left = this.topLevelTileRect.left + xp * w * 2;\n        const bottom = this.topLevelTileRect.bottom + yp * h * 2;\n        /** tiles under the upper tile */\n        const keys = new Array(4);\n        // fill the keys\n        for (let i = 0; i < 2; i++) {\n            for (let j = 0; j < 2; j++) {\n                keys[i * 2 + j] = new IntPair(xp * 2 + i, yp * 2 + j);\n            }\n        }\n        if (!regenerate) {\n            this.generateSubtilesWithoutTileClips(left, w, bottom, h, keys, lowerTile, z);\n        }\n        const horizontalMiddleLine = new LineSegment(left, bottom + h, left + 2 * w, bottom + h);\n        const verticalMiddleLine = new LineSegment(left + w, bottom, left + w, bottom + 2 * h);\n        subdivideWithCachedClipsAboveTile();\n        let r = 0;\n        let allSmall = true;\n        for (const key of keys) {\n            const tile = levelTiles.get(key.x, key.y);\n            if (tile == null)\n                continue;\n            r++;\n            if (tile.entityCount > this.tileCapacity) {\n                allSmall = false;\n            }\n        }\n        return { count: r, allSmall: allSmall };\n        // local functions\n        function subdivideWithCachedClipsAboveTile() {\n            //create temparary PointPairMap to store the result of the intersection\n            // each entry in the map is an array of curves corresponding to the intersections with one subtile\n            for (const clip of lowerTile.curveClips) {\n                // Assert.assert(upperTile.rect.containsRect(cs.curve.boundingBox))\n                const cs = clip.curve;\n                const xs = intersectWithMiddleLines(cs, clip.startPar, clip.endPar);\n                Assert.assert(xs.length >= 2);\n                if (xs.length == 2) {\n                    const t = (xs[0] + xs[1]) / 2;\n                    const p = cs.value(t);\n                    const i = p.x <= left + w ? 0 : 1;\n                    const j = p.y <= bottom + h ? 0 : 1;\n                    const k = 2 * i + j;\n                    const key = keys[k];\n                    let tile = levelTiles.getI(key);\n                    if (!tile) {\n                        const l = left + i * w;\n                        const b = bottom + j * h;\n                        tile = new Tile(new Rectangle({ left: l, bottom: b, top: b + h, right: l + w }));\n                        levelTiles.setPair(key, tile);\n                    }\n                    tile.addCurveClip({ curve: cs, edge: clip.edge, startPar: xs[0], endPar: xs[1] });\n                }\n                else\n                    for (let u = 0; u < xs.length - 1; u++) {\n                        const t = (xs[u] + xs[u + 1]) / 2;\n                        const p = cs.value(t);\n                        const i = p.x <= left + w ? 0 : 1;\n                        const j = p.y <= bottom + h ? 0 : 1;\n                        const k = 2 * i + j;\n                        //const tr = cs.trim(xs[u][1], xs[u + 1][1])\n                        const key = keys[k];\n                        let tile = levelTiles.getI(key);\n                        if (!tile) {\n                            const l = left + i * w;\n                            const b = bottom + j * h;\n                            tile = new Tile(new Rectangle({ left: l, bottom: b, top: b + h, right: l + w }));\n                            levelTiles.setPair(key, tile);\n                        }\n                        tile.addCurveClip({ curve: cs, edge: clip.edge, startPar: xs[u], endPar: xs[u + 1] });\n                    }\n            }\n        }\n        function intersectWithMiddleLines(seg, start, end) {\n            // point, parameter\n            let xs = Array.from(Curve.getAllIntersections(seg, horizontalMiddleLine, true))\n                .concat(Array.from(Curve.getAllIntersections(seg, verticalMiddleLine, true)))\n                .map((x) => x.par0);\n            xs.sort((a, b) => a - b);\n            return [start].concat(xs.filter((x) => x >= start && x <= end)).concat(end);\n        }\n    }\n    /** returns the updated value of allTilesAreSmall */\n    addSubtilesToLevel(tdArr, levelTiles, xp, yp, allTilesAreSmall) {\n        //debCount++\n        for (let i = 0; i < 2; i++)\n            for (let j = 0; j < 2; j++) {\n                const tile = tdArr[i * 2 + j];\n                if (!tile.isEmpty()) {\n                    levelTiles.set(2 * xp + i, 2 * yp + j, tile);\n                    // try {\n                    //   if (debCount % 10 === 0) {\n                    //     const cc = Array.from(tile.getCurveClips())\n                    //     // SvgDebugWriter.dumpDebugCurves(\n                    //     //   './tmp/tile' + debCount + '-' + (2 * xp + i) + '-' + (2 * yp + j) + '.svg',\n                    //     //   cc\n                    //     //     .map((c) => DebugCurve.mkDebugCurveCI('Green', c.curve))\n                    //     //     .concat([DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Black', tile.rect.perimeter())])\n                    //     //     .concat(tile.nodes.map((n) => DebugCurve.mkDebugCurveCI('Red', n.boundaryCurve)))\n                    //     //     .concat(tile.arrowheads.map((t) => LineSegment.mkPP(t.base, t.tip)).map((l) => DebugCurve.mkDebugCurveWCI(1, 'Blue', l))),\n                    //     // )\n                    //   }\n                    // } catch (e) {}\n                    if (allTilesAreSmall && tile.entityCount > this.tileCapacity) {\n                        //console.log('found a tile at level', z, ' with ', tile.elementCount, 'elements, which is greater than', this.tileCapacity)\n                        allTilesAreSmall = false;\n                    }\n                }\n            }\n        return allTilesAreSmall;\n    }\n    generateSubtilesWithoutTileClips(left, w, bottom, h, keysAbove, upperTile, z) {\n        let k = 0;\n        for (let i = 0; i < 2; i++)\n            for (let j = 0; j < 2; j++) {\n                const tileRect = new Rectangle({\n                    left: left + w * i,\n                    right: left + w * (i + 1),\n                    bottom: bottom + h * j,\n                    top: bottom + h * (j + 1),\n                });\n                const tile = this.generateOneSubtileExceptEdgeClips(upperTile, tileRect);\n                if (tile) {\n                    this.levels[z].set(keysAbove[k].x, keysAbove[k].y, tile);\n                }\n                k++;\n            }\n    }\n    innerClips(curve, verticalMiddleLine, horizontalMiddleLine) {\n        //debCount++\n        const ret = [];\n        // Assert.assert(upperTile.rect.containsRect(cs.curve.boundingBox))\n        const xs = Array.from(Curve.getAllIntersections(curve, horizontalMiddleLine, true)).concat(Array.from(Curve.getAllIntersections(curve, verticalMiddleLine, true)));\n        xs.sort((a, b) => a.par0 - b.par0);\n        const filteredXs = [curve.parStart];\n        for (let i = 0; i < xs.length; i++) {\n            const ii = xs[i];\n            if (ii.par0 > filteredXs[filteredXs.length - 1] + GeomConstants.distanceEpsilon) {\n                filteredXs.push(ii.par0);\n            }\n        }\n        if (curve.parEnd > filteredXs[filteredXs.length - 1] + GeomConstants.distanceEpsilon) {\n            filteredXs.push(curve.parEnd);\n        }\n        if (filteredXs.length <= 2) {\n            ret.push(curve);\n            return ret;\n        }\n        for (let u = 0; u < filteredXs.length - 1; u++) {\n            ret.push(curve.trim(filteredXs[u], filteredXs[u + 1]));\n        }\n        // if (debCount == 3) {\n        //   console.log(ret)\n        //   const trs = []\n        //   for (let i = 0; i < ret.length; i++) {\n        //     trs.push(DebugCurve.mkDebugCurveWCI(i + 1, 'Black', ret[i]))\n        //   }\n        //   SvgDebugWriter.dumpDebugCurves(\n        //     './tmp/innerClips.svg',\n        //     [\n        //       DebugCurve.mkDebugCurveTWCI(150, 2, 'Yellow', verticalMiddleLine),\n        //       DebugCurve.mkDebugCurveTWCI(100, 2, 'Magenta', horizontalMiddleLine),\n        //       DebugCurve.mkDebugCurveTWCI(100, 5, 'Blue', curve),\n        //     ].concat(trs),\n        //   )\n        // }\n        return ret;\n    }\n    generateOneSubtileExceptEdgeClips(upperTile, tileRect) {\n        const tile = new Tile(tileRect);\n        for (const n of upperTile.nodes) {\n            if (n.boundingBox.intersects(tileRect)) {\n                tile.nodes.push(n);\n            }\n        }\n        for (const lab of upperTile.labels) {\n            if (lab.boundingBox.intersects(tileRect)) {\n                tile.labels.push(lab);\n            }\n        }\n        for (const arrowhead of upperTile.arrowheads) {\n            const arrowheadBox = Rectangle.mkPP(arrowhead.base, arrowhead.tip);\n            const d = arrowhead.tip.sub(arrowhead.base).div(3);\n            const dRotated = d.rotate90Cw();\n            arrowheadBox.add(arrowhead.base.add(dRotated));\n            arrowheadBox.add(arrowhead.base.sub(dRotated));\n            if (arrowheadBox.intersects(tileRect))\n                tile.arrowheads.push(arrowhead);\n        }\n        if (tile.isEmpty())\n            return null;\n        return tile;\n    }\n}\n// function treeIntersectsRect(tree: RTree, boundingBox: Rectangle): boolean {\n//   const bb = {x: boundingBox.left, y: boundingBox.bottom, width: boundingBox.width, height: boundingBox.height}\n//   const a = tree.search(bb)\n//   return a && a.length > 0\n// }\n// function dumpTiles(tileMap: IntPairMap<Tile>, z: number) {\n//   for (const [p, tile] of tileMap.keyValues()) {\n//     try {\n//       const cc = Array.from(tile.getCurveClips()).map((c) => c.curve)\n//       SvgDebugWriter.dumpDebugCurves(\n//         './tmp/filteredTile' + z + '-' + p.x + '-' + p.y + '.svg',\n//         cc\n//           .map((c) => DebugCurve.mkDebugCurveCI('Green', c))\n//           .concat([DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Black', tile.rect.perimeter())])\n//           .concat(tile.nodes.map((n) => DebugCurve.mkDebugCurveCI('Red', n.boundaryCurve)))\n//           .concat(tile.arrowheads.map((t) => LineSegment.mkPP(t.base, t.tip)).map((l) => DebugCurve.mkDebugCurveWCI(1, 'Blue', l))),\n//       )\n//     } catch (Error) {\n//       console.log(Error.message)\n//     }\n//   }\n// }\n//# sourceMappingURL=tileMap.js.map","import { RectilinearEdgeRouter } from '../routing/rectilinear/RectilinearEdgeRouter';\nimport { GeomGraph, optimalPackingRunner } from './core/geomGraph';\nimport { Edge } from '../structs/edge';\nimport { Graph, shallowConnectedComponents } from '../structs/graph';\nimport { GeomEdge } from './core/geomEdge';\nimport { SugiyamaLayoutSettings } from './layered/sugiyamaLayoutSettings';\nimport { FastIncrementalLayoutSettings, LayeredLayout, MdsLayoutSettings, Point } from '..';\nimport { PivotMDS } from './mds/pivotMDS';\nimport { EdgeRoutingMode } from '../routing/EdgeRoutingMode';\nimport { straightLineEdgePatcher } from '../routing/StraightLineEdges';\nimport { routeSplines, SplineRouter } from '../routing/splineRouter';\nimport { EdgeRoutingSettings } from '../routing/EdgeRoutingSettings';\nimport { GeomObject } from './core/geomObject';\nimport { initRandom } from '../utils/random';\nimport { EdgeLabelPlacement } from './edgeLabelPlacement';\nimport { IPsepColaSetting } from './incremental/iPsepColaSettings';\nimport { InitialLayout } from './initialLayout/initialLayout';\n// function routeEdges(\n//  geomG: GeomGraph,\n//  edgeRoutingSettings: EdgeRoutingSettings,\n//  cornerFitRadius = 3,\n// ) {\n//  if (edgeRoutingSettings.edgeRoutingMode !== EdgeRoutingMode.Rectilinear) {\n//    // TODO: enable other modes\n//    routeStraightEdges(geomG)\n//  } else {\n//    if (edgeRoutingSettings.EdgeRoutingMode === EdgeRoutingMode.Rectilinear)\n//      routeRectilinearEdges(geomG, edgeRoutingSettings.padding, cornerFitRadius)\n//  }\n// }\n// function routeStraightEdges(geomG: GeomGraph) {\n//  for (const u of geomG.deepNodes) {\n//    for (const e of u.outEdges()) {\n//      if (e.curve == null ) StraightLineEdges.RouteEdge(e, 0)\n//    }\n//    for (const e of u.selfEdges()) {\n//      if (e.curve == null ) StraightLineEdges.RouteEdge(e, 0)\n//    }\n//  }\n// }\nfunction settingsTag(ss) {\n    if (ss instanceof SugiyamaLayoutSettings) {\n        return 0;\n    }\n    if (ss instanceof IPsepColaSetting) {\n        return 1;\n    }\n    if (ss instanceof MdsLayoutSettings) {\n        return 2;\n    }\n    if (ss instanceof FastIncrementalLayoutSettings) {\n        return 3;\n    }\n    throw new Error('not implemented');\n}\nexport function enforceLayoutSettings(geomGraph, ss) {\n    if (!geomGraph.layoutSettings || settingsTag(geomGraph.layoutSettings) !== settingsTag(ss))\n        geomGraph.layoutSettings = ss;\n    for (const n of geomGraph.shallowNodes) {\n        if (n instanceof GeomGraph) {\n            enforceLayoutSettings(n, geomGraph.layoutSettings);\n        }\n    }\n}\nfunction createSettingsIfNeeded(geomGraph) {\n    if (!geomGraph.layoutSettings) {\n        geomGraph.layoutSettings = figureOutSettings(geomGraph);\n    }\n}\nexport function getSettingsFromAncestor(geomGraph) {\n    let p = geomGraph.parent;\n    while (p) {\n        if (p.layoutSettings) {\n            return p.layoutSettings;\n        }\n        p = p.parent;\n    }\n    return null;\n}\nfunction figureOutSettings(geomGraph) {\n    const settings = getSettingsFromAncestor(geomGraph);\n    if (settings)\n        return settings;\n    const tooLargeForLayered = geomGraph.graph.shallowNodeCount > 2000 || geomGraph.graph.deepEdgesCount > 4000;\n    if (tooLargeForLayered) {\n        return new IPsepColaSetting();\n    }\n    let directed = false;\n    for (const e of geomGraph.deepEdges) {\n        if (e.sourceArrowhead != null || e.targetArrowhead != null) {\n            directed = true;\n            break;\n        }\n    }\n    return directed ? new SugiyamaLayoutSettings() : new IPsepColaSetting();\n}\nfunction layoutEngine(geomGraph, cancelToken, edgeLenght = () => 1) {\n    createSettingsIfNeeded(geomGraph);\n    if (geomGraph.layoutSettings instanceof SugiyamaLayoutSettings) {\n        const ll = new LayeredLayout(geomGraph, geomGraph.layoutSettings, cancelToken);\n        ll.run();\n    }\n    else if (geomGraph.layoutSettings instanceof MdsLayoutSettings) {\n        const pivotMds = new PivotMDS(geomGraph, cancelToken, edgeLenght, geomGraph.layoutSettings);\n        pivotMds.run();\n    }\n    else if (geomGraph.layoutSettings instanceof IPsepColaSetting) {\n        const layout = new InitialLayout(geomGraph, geomGraph.layoutSettings);\n        layout.SingleComponent = true;\n        layout.run();\n    }\n    else {\n        throw new Error('not implemented');\n    }\n}\nexport function layoutGeomGraph(geomGraph, cancelToken = null) {\n    createSettingsIfNeeded(geomGraph);\n    layoutGeomGraphDetailed(geomGraph, cancelToken, layoutEngine, routeEdges, optimalPackingRunner);\n    shiftToFirstQuarter(geomGraph);\n}\nexport function getEdgeRoutingSettingsFromAncestorsOrDefault(geomGraph) {\n    do {\n        if (geomGraph.layoutSettings && geomGraph.layoutSettings.commonSettings.edgeRoutingSettings) {\n            return geomGraph.layoutSettings.commonSettings.edgeRoutingSettings;\n        }\n        const parent = geomGraph.graph.parent;\n        if (parent) {\n            geomGraph = GeomObject.getGeom(parent);\n        }\n        else {\n            break;\n        }\n    } while (true);\n    const ers = new EdgeRoutingSettings();\n    ers.EdgeRoutingMode = EdgeRoutingMode.Spline;\n    return ers;\n}\nexport function routeEdges(geomGraph, edgesToRoute, cancelToken) {\n    const ers = getEdgeRoutingSettingsFromAncestorsOrDefault(geomGraph);\n    if (ers.EdgeRoutingMode === EdgeRoutingMode.Rectilinear) {\n        routeRectilinearEdges(geomGraph, edgesToRoute, cancelToken);\n    }\n    else if (ers.EdgeRoutingMode === EdgeRoutingMode.Spline || ers.EdgeRoutingMode === EdgeRoutingMode.SplineBundling) {\n        routeSplines(geomGraph, edgesToRoute, cancelToken);\n    }\n    else if (ers.EdgeRoutingMode === EdgeRoutingMode.StraightLine) {\n        straightLineEdgePatcher(geomGraph, edgesToRoute, cancelToken);\n    }\n    else if (ers.EdgeRoutingMode !== EdgeRoutingMode.None) {\n        new SplineRouter(geomGraph, edgesToRoute).run();\n    }\n    positionLabelsIfNeeded(geomGraph, edgesToRoute);\n}\n/** Lays out a GeomGraph, which is possibly disconnected and might have sub-graphs */\nexport function layoutGeomGraphDetailed(geomG, cancelToken, layoutEngine, edgeRouter, packing, randomSeed = 1, \n/** used only for PivotMDS */\nedgeLength = () => 1) {\n    if (geomG.graph.isEmpty()) {\n        return;\n    }\n    // @ts-ignore\n    const gn = geomG.shallowNodes.next();\n    if (geomG.parent == null) {\n        //console.log('loading graph', geomG.id, 'with', geomG.deepNodeCount, 'nodes, and', geomG.graph.deepEdgesCount, 'edges')\n        //console.time('layout')\n        // go over some intitial settings only on the top level\n        initRandom(randomSeed);\n        requireLabelPositioning(geomG);\n    }\n    const removedEdges = removeEdgesLeadingOutOfGraphOrCollapsingToSelfEdges();\n    layoutShallowSubgraphs(geomG);\n    const liftedEdges = createLiftedEdges(geomG.graph);\n    const connectedGraphs = getConnectedComponents(geomG);\n    layoutComps();\n    liftedEdges.forEach((e) => {\n        e[0].edge.remove();\n        e[1].add();\n    });\n    // restore the parent\n    connectedGraphs.forEach((g) => {\n        for (const n of g.graph.shallowNodes)\n            n.parent = geomG.graph;\n    });\n    removedEdges.forEach((e) => e.add());\n    //the final touches\n    if (geomG.graph.parent == null) {\n        //console.timeEnd('layout')\n        //console.time('routing')\n        const edgesToRoute = getUnroutedEdges(geomG);\n        edgeRouter(geomG, edgesToRoute, cancelToken);\n        positionLabelsIfNeeded(geomG, edgesToRoute);\n        geomG.pumpTheBoxToTheGraphWithMargins();\n        //console.timeEnd('routing')\n    }\n    // end of layoutGeomGraphDetailed body\n    function getUnroutedEdges(g) {\n        const edges = [];\n        for (const n of g.nodesBreadthFirst) {\n            for (const e of n.outEdges())\n                if (e.curve == null)\n                    edges.push(e);\n            for (const e of n.selfEdges())\n                if (e.curve == null)\n                    edges.push(e);\n        }\n        return edges;\n    }\n    function layoutShallowSubgraphs(geomG) {\n        for (const n of geomG.shallowNodes) {\n            if (n instanceof GeomGraph) {\n                layoutGeomGraphDetailed(n, cancelToken, layoutEngine, edgeRouter, packing);\n            }\n        }\n    }\n    function removeEdgesLeadingOutOfGraphOrCollapsingToSelfEdges() {\n        const ret = new Set();\n        const graphUnderSurgery = geomG.graph;\n        if (graphUnderSurgery.parent == null)\n            return ret;\n        for (const n of graphUnderSurgery.shallowNodes) {\n            for (const e of n.outEdges) {\n                const lifted = graphUnderSurgery.liftNode(e.target);\n                if (lifted == null || lifted === n) {\n                    ret.add(e);\n                }\n            }\n            for (const e of n.inEdges) {\n                const lifted = graphUnderSurgery.liftNode(e.source);\n                if (lifted == null || lifted === n) {\n                    ret.add(e);\n                }\n            }\n        }\n        for (const e of ret)\n            e.remove();\n        return ret;\n    }\n    function layoutComps() {\n        if (connectedGraphs.length === 1) {\n            layoutEngine(geomG, cancelToken, edgeLength);\n        }\n        else {\n            for (const cg of connectedGraphs) {\n                layoutEngine(cg, cancelToken, edgeLength);\n                cg.boundingBox = cg.pumpTheBoxToTheGraphWithMargins();\n            }\n            packing(geomG, connectedGraphs);\n        }\n    }\n} // end of layoutGeomGraphDetailed\n// returns arrays of pairs (new lifted GeomEdge, existing Edge)\nfunction createLiftedEdges(graph) {\n    const liftedEdges = new Array();\n    for (const u of graph.nodesBreadthFirst) {\n        const liftedU = graph.liftNode(u);\n        if (liftedU == null)\n            continue;\n        for (const uv of u.outEdges.values()) {\n            const v = uv.target;\n            const liftedV = graph.liftNode(v);\n            if (liftedV == null || (liftedU === u && liftedV === v) || liftedU === liftedV) {\n                continue;\n            }\n            uv.remove();\n            const newLiftedEdge = new Edge(liftedU, liftedV);\n            const newLiftedGeomEdge = new GeomEdge(newLiftedEdge);\n            liftedEdges.push([newLiftedGeomEdge, uv]);\n        }\n    }\n    return liftedEdges;\n}\nfunction getConnectedComponents(parentGeomGraph) {\n    var _a;\n    const parentGraph = parentGeomGraph.graph;\n    const comps = shallowConnectedComponents(parentGraph);\n    const ret = [];\n    let i = 0;\n    for (const comp of comps) {\n        const g = new Graph(parentGraph.id + i++);\n        g.parent = parentGraph;\n        const geomG = new GeomGraph(g);\n        geomG.layoutSettings = (_a = parentGeomGraph.layoutSettings) !== null && _a !== void 0 ? _a : figureOutSettings(parentGeomGraph);\n        for (const n of comp) {\n            n.parent = g;\n            g.addNode(n); // this changes the parent - should be restored to graph\n        }\n        ret.push(geomG);\n    }\n    return ret;\n}\n/** route edges with segments paralles to either X or Y axes */\nexport function routeRectilinearEdges(geomG, edgesToRoute, cancelToken, nodePadding = 1, cornerFitRadius = 3, edgeSeparatian = 3) {\n    const rr = RectilinearEdgeRouter.constructorGNAN(geomG, edgesToRoute, nodePadding, cornerFitRadius);\n    rr.edgeSeparatian = edgeSeparatian;\n    rr.run();\n}\nfunction positionLabelsIfNeeded(geomG, edges) {\n    if (edges.length === 0)\n        return;\n    const ep = EdgeLabelPlacement.constructorGA(geomG, edges);\n    ep.run();\n}\n/** mark labels as required positoning */\nfunction requireLabelPositioning(geomG) {\n    for (const e of geomG.deepEdges) {\n        if (e.label)\n            e.label.isPositioned = false;\n    }\n}\nexport function geometryIsCreated(graph) {\n    if (GeomGraph.getGeom(graph) == null)\n        return false;\n    for (const n of graph.shallowNodes) {\n        const gn = GeomObject.getGeom(n);\n        if (gn == null || gn.boundaryCurve == null)\n            return false;\n        if (n instanceof Graph) {\n            if (geometryIsCreated(n) === false) {\n                return false;\n            }\n        }\n    }\n    for (const e of graph.edges) {\n        const ge = GeomEdge.getGeom(e);\n        if (ge == null)\n            return false;\n    }\n    return true;\n}\nexport function layoutIsCalculated(graph) {\n    const geomGraph = GeomGraph.getGeom(graph);\n    if (geomGraph == null)\n        return false;\n    if (geomGraph.boundingBox == null || geomGraph.boundingBox.isEmpty())\n        return false;\n    for (const n of graph.shallowNodes) {\n        const gn = GeomObject.getGeom(n);\n        if (gn == null || gn.boundaryCurve == null)\n            return false;\n        if (n instanceof Graph) {\n            if (layoutIsCalculated(n) === false)\n                return false;\n        }\n    }\n    for (const e of graph.deepEdges) {\n        const ge = GeomEdge.getGeom(e);\n        if (ge == null || ge.curve == null)\n            return false;\n    }\n    // todo: consider adding more checks. For example, check that the bounding boxes of subgraphs make sense, and the edge curves are attached to the nodes\n    return true;\n}\nfunction shiftToFirstQuarter(geomGraph) {\n    const lb = geomGraph.boundingBox.leftBottom;\n    if (lb.x < 0 || lb.y < 0) {\n        const delta = new Point(-lb.x, -lb.y);\n        geomGraph.translate(delta);\n    }\n}\n//# sourceMappingURL=driver.js.map","import { GeomConstants, Point, Rectangle, Size } from '../math/geometry';\nimport { mkRTree } from '../math/geometry/RTree/rTree';\nimport { Algorithm } from '../utils/algorithm';\nimport { closeDistEps } from '../utils/compare';\nimport { GeomGraph } from './core/geomGraph';\nexport var LabelPlacementResult;\n(function (LabelPlacementResult) {\n    /**\n       Placement result meaning that another label was overlapped\n      */\n    LabelPlacementResult[LabelPlacementResult[\"OverlapsOtherLabels\"] = 0] = \"OverlapsOtherLabels\";\n    /**\n      Placement result meaning that the label overlaps a node, but not a label\n      */\n    LabelPlacementResult[LabelPlacementResult[\"OverlapsNodes\"] = 1] = \"OverlapsNodes\";\n    /**\n      Placement result meaning that the label overlaps an edge, but not a node or label.\n      */\n    LabelPlacementResult[LabelPlacementResult[\"OverlapsEdges\"] = 2] = \"OverlapsEdges\";\n    /**\n      Placement result meaning that the label overlaps nothing.\n      */\n    LabelPlacementResult[LabelPlacementResult[\"OverlapsNothing\"] = Number.MAX_VALUE] = \"OverlapsNothing\";\n})(LabelPlacementResult || (LabelPlacementResult = {}));\nexport var PlacementSide;\n(function (PlacementSide) {\n    /**\n      //Places the label on any side\n      */\n    PlacementSide[PlacementSide[\"Any\"] = 0] = \"Any\";\n    /**\n      //Places the label on the port side of the edge.\n      //Port is the left side of the edge if you were facing away from the source and towards the target.\n      */\n    PlacementSide[PlacementSide[\"Port\"] = 1] = \"Port\";\n    /**\n      //Places the label on the starboard side of the edge.\n      //Starboard is the right side of the edge if you were facing away from the source and towards the target.\n      */\n    PlacementSide[PlacementSide[\"Starboard\"] = 2] = \"Starboard\";\n    /**\n      //Places the label on the top side of the line.\n      //If the line is vertical, the label is placed on the left.\n      */\n    PlacementSide[PlacementSide[\"Top\"] = 3] = \"Top\";\n    /**\n      //Places the label on the bottom side of the line.\n      //If the line is vertical, the label is placed on the right.\n      */\n    PlacementSide[PlacementSide[\"Bottom\"] = 4] = \"Bottom\";\n    /**\n      //Places the label on the left side of the line.\n      //If the line is horizontal, the label is placed on the top.\n      */\n    PlacementSide[PlacementSide[\"Left\"] = 5] = \"Left\";\n    /**\n      //Places the label on the right side of the line.\n      //If the line is horizontal, the label is placed on the bottom.\n      */\n    PlacementSide[PlacementSide[\"Right\"] = 6] = \"Right\";\n})(PlacementSide || (PlacementSide = {}));\nclass PointSet {\n}\nclass PointSetList {\n    constructor() {\n        this.points = [];\n        this.coveredLength = 0;\n    }\n    AddFirst(p) {\n        if (this.points.length !== 0) {\n            const q = this.points[0];\n            this.coveredLength = this.coveredLength + p.Center.sub(q.Center).length;\n        }\n        this.points.unshift(p);\n        return this.coveredLength;\n    }\n    AddLast(p) {\n        if (this.points.length !== 0) {\n            const q = this.points[this.points.length - 1];\n            this.coveredLength = this.coveredLength + p.Center.sub(q.Center).length;\n        }\n        this.points.push(p);\n        return this.coveredLength;\n    }\n}\nvar PlacementStrategy;\n(function (PlacementStrategy) {\n    //Try to place the label running along the curve path\n    PlacementStrategy[PlacementStrategy[\"AlongCurve\"] = 0] = \"AlongCurve\";\n    //Standard horizontal label\n    PlacementStrategy[PlacementStrategy[\"Horizontal\"] = 1] = \"Horizontal\";\n})(PlacementStrategy || (PlacementStrategy = {}));\nclass PortObstacle {\n    constructor(p) {\n        this.location = p;\n        this.boundingBox = Rectangle.rectangleOnPoint(p);\n    }\n}\nclass RectangleObstacle {\n    constructor(box, data) {\n        this.data = data;\n        this.boundingBox = box;\n    }\n}\nclass LabelInfo {\n    constructor(edgePoints) {\n        this.innerPoints = [];\n        this.outerPoints = [];\n        this.placementSide = PlacementSide.Any;\n        this.placementOffset = 0.5;\n        this.edgePoints = edgePoints;\n        this.placementSide;\n    }\n}\n/** The class to place labels */\nexport class EdgeLabelPlacement extends Algorithm {\n    //     The granularity with which to break up a curve into sub points.\n    get CollisionGranularity() {\n        return this.granularity;\n    }\n    set CollisionGranularity(value) {\n        this.granularity = value;\n    }\n    //     Constructs an edge label placer that places all labels in the graph.\n    static constructorG(graph) {\n        return new EdgeLabelPlacement(Array.from(graph.nodesBreadthFirst), Array.from(graph.deepEdges).filter((e) => e.label));\n    }\n    //     Constructs an edge label placer that places the given labels in the graph.\n    static constructorGA(graph, edges) {\n        return new EdgeLabelPlacement(Array.from(graph.nodesBreadthFirst), edges.filter((e) => e.label));\n    }\n    //     Constructs a edge label placer that will only avoid overlaps with the given nodes and edges.\n    constructor(nodes, edges) {\n        super(null);\n        this.placementStrategy = [PlacementStrategy.Horizontal, PlacementStrategy.AlongCurve];\n        this.obstacleMaps = [];\n        this.edgeInfos = new Map();\n        this.granularity = EdgeLabelPlacement.MinGranularity;\n        /**      True if the edge collision granularity should be degraded as the number of edges increases. */\n        this.ScaleCollisionGranularity = true;\n        this.granularity = this.ScaleCollisionGranularity ? this.interpolateGranularity(edges.length) : EdgeLabelPlacement.MinGranularity;\n        this.InitializeObstacles(nodes, edges);\n        this.edges = edges;\n    }\n    interpolateGranularity(edgeCount) {\n        if (edgeCount <= EdgeLabelPlacement.LowerEdgeBound) {\n            return EdgeLabelPlacement.MaxGranularity;\n        }\n        if (edgeCount >= EdgeLabelPlacement.UpperEdgeBound) {\n            return EdgeLabelPlacement.MinGranularity;\n        }\n        const delta = (EdgeLabelPlacement.UpperEdgeBound - EdgeLabelPlacement.LowerEdgeBound) / (edgeCount - EdgeLabelPlacement.LowerEdgeBound);\n        return Math.ceil(EdgeLabelPlacement.MinGranularity + delta);\n    }\n    InitializeObstacles(nodes, edgeList) {\n        const edgeObstacles = this.GetEdgeObstacles(edgeList);\n        this.obstacleMaps[1] = mkRTree(nodes.map((n) => [n.boundingBox, new RectangleObstacle(n.boundingBox, n)]));\n        // later we init obstacleMaps[0] to lableObstacleMap\n        this.obstacleMaps[2] = mkRTree(edgeObstacles.map((e) => [e.boundingBox, new RectangleObstacle(e.boundingBox, e)]));\n        // Avoiding edge overlaps is lowest priority, so put it last\n    }\n    static CurvePoints(curve, granularity) {\n        const points = [];\n        const delta = curve.end.sub(curve.start).lengthSquared / (granularity * granularity);\n        EdgeLabelPlacement.SubdivideCurveSegment(points, curve, delta, curve.parStart, curve.parEnd);\n        points.sort(EdgeLabelPlacement.compareByArgument);\n        return points;\n    }\n    static compareByArgument(x, y) {\n        if (x[0] < y[0]) {\n            return -1;\n        }\n        if (x[0] > y[0]) {\n            return 1;\n        }\n        return 0;\n    }\n    static SubdivideCurveSegment(list, curve, delta2, start, end) {\n        if (list.length > 64) {\n            //LN I saw this function never finishing for a very long curve\n            return;\n        }\n        const startPoint = curve.value(start);\n        const endPoint = curve.value(end);\n        if (startPoint.sub(endPoint).lengthSquared > delta2) {\n            const mid = (start + end) / 2.0;\n            EdgeLabelPlacement.SubdivideCurveSegment(list, curve, delta2, start, mid);\n            EdgeLabelPlacement.SubdivideCurveSegment(list, curve, delta2, mid, end);\n        }\n        else {\n            list.push([start, startPoint]);\n        }\n    }\n    //Places the given labels at their default positions.  Only avoids overlaps with the edge and source/target node that the label is connected to.\n    static PlaceLabelsAtDefaultPositions(cancelToken, edges) {\n        for (const edge of edges) {\n            if (edge.label) {\n                const placer = new EdgeLabelPlacement([edge.source, edge.target], [edge]);\n                placer.run();\n            }\n        }\n    }\n    GetEdgeObstacles(edges) {\n        const edgeObstacles = [];\n        for (const e of edges) {\n            if (e.curve == null)\n                continue;\n            const curvePoints = EdgeLabelPlacement.CurvePoints(e.curve, this.CollisionGranularity);\n            this.edgeInfos.set(e, new LabelInfo(curvePoints));\n            for (const p of curvePoints) {\n                edgeObstacles.push(new PortObstacle(p[1]));\n            }\n        }\n        return edgeObstacles;\n    }\n    /**       Adds the label to the label obstacle map.*/\n    AddLabelObstacle(label) {\n        if (this.labelObstacleMap == null) {\n            this.labelObstacleMap = mkRTree([[label.boundingBox, label]]);\n            this.obstacleMaps[0] = this.labelObstacleMap;\n        }\n        else {\n            this.labelObstacleMap.Add(label.boundingBox, label);\n        }\n    }\n    //     Places the given labels.\n    run() {\n        // Place labels on short edges before labels on long edges, since short edges have less options.\n        this.edges.sort((a, b) => {\n            return this.edgeInfos.get(a).edgePoints.length - this.edgeInfos.get(b).edgePoints.length;\n        });\n        for (const edge of this.edges) {\n            this.PlaceLabel(edge);\n        }\n    }\n    //     Places the given label in an available location.\n    PlaceLabel(edge) {\n        let placed = false;\n        for (const s of this.placementStrategy) {\n            switch (s) {\n                case PlacementStrategy.AlongCurve:\n                    placed = this.PlaceEdgeLabelOnCurve(edge.label);\n                    break;\n                case PlacementStrategy.Horizontal:\n                    placed = this.PlaceEdgeLabelHorizontally(edge);\n                    break;\n                default:\n                    throw new Error('unexpected case');\n            }\n            if (placed) {\n                break;\n            }\n        }\n        if (placed) {\n            this.CalculateCenterLabelInfoCenter(edge.label);\n        }\n        else {\n            this.PlaceLabelAtFirstPosition(edge.label);\n        }\n    }\n    getLabelInfo(label) {\n        const ge = label.parent;\n        return this.edgeInfos.get(ge);\n    }\n    //     Places the label at the first position requested.  Ignores all overlaps.\n    PlaceLabelAtFirstPosition(label) {\n        const edge = label.parent;\n        const curve = edge.curve;\n        const points = this.edgeInfos.get(edge).edgePoints;\n        const index = this.StartIndex(label, points.map((p) => p[1]));\n        const point = points[index][1];\n        let derivative = curve.derivative(points[index][0]);\n        // If the curve is a line of length (close to) 0, the derivative may be (close to) 0.\n        // Pick a direction in that case.\n        if (derivative.length < GeomConstants.distanceEpsilon) {\n            derivative = new Point(1, 1);\n        }\n        derivative = derivative.normalize();\n        const widthHeight = new Size(label.width, label.height);\n        const labelInfo = this.getLabelInfo(label);\n        const side = EdgeLabelPlacement.GetPossibleSides(labelInfo.placementSide, derivative)[0];\n        const bounds = EdgeLabelPlacement.GetLabelBounds(point, derivative, widthHeight, side);\n        this.SetLabelBounds(this.getLabelInfo(label), bounds);\n    }\n    StartIndex(label, points) {\n        const labelInfo = this.getLabelInfo(label);\n        return Math.min(points.length - 1, Math.max(0, Math.floor(points.length * labelInfo.placementOffset)));\n    }\n    CalculateCenterLabelInfoCenter(label) {\n        const labelInfo = this.getLabelInfo(label);\n        let cen = new Point(0, 0);\n        for (const p of labelInfo.innerPoints) {\n            cen = cen.add(p);\n        }\n        for (const p of labelInfo.outerPoints) {\n            cen = cen.add(p);\n        }\n        label.positionCenter(cen.div(labelInfo.innerPoints.length + labelInfo.outerPoints.length));\n    }\n    PlaceEdgeLabelHorizontally(edge) {\n        const label = edge.label;\n        // approximate label with a rectangle\n        // process candidate points for label ordered by priority\n        // check candidate point for conflicts - if none then stop and keep placement\n        const labelInfo = this.getLabelInfo(label);\n        const curvePoints = labelInfo.edgePoints;\n        const wh = new Size(label.width, label.height);\n        let bestConflictIndex = -1;\n        let bestRectangle = Rectangle.mkEmpty();\n        const curve = edge.curve;\n        for (const index of EdgeLabelPlacement.ExpandingSearch(this.StartIndex(label, curvePoints.map((p) => p[1])), 0, curvePoints.length)) {\n            const cp = curvePoints[index];\n            let der = curve.derivative(cp[0]);\n            if (closeDistEps(der.lengthSquared, 0)) {\n                continue;\n            }\n            der = der.normalize();\n            for (const side of EdgeLabelPlacement.GetPossibleSides(this.getLabelInfo(label).placementSide, der)) {\n                const queryRect = EdgeLabelPlacement.GetLabelBounds(cp[1], der, wh, side);\n                const conflictIndex = this.ConflictIndexRL(queryRect, label);\n                if (conflictIndex > bestConflictIndex) {\n                    bestConflictIndex = conflictIndex;\n                    bestRectangle = queryRect;\n                    // If the best location was found, we're done\n                    if (bestConflictIndex === Number.MAX_VALUE) {\n                        break;\n                    }\n                }\n            }\n            // If the best location was found, we're done\n            if (bestConflictIndex === Number.MAX_VALUE) {\n                break;\n            }\n        }\n        if (bestConflictIndex >= 0) {\n            this.SetLabelBounds(this.getLabelInfo(label), bestRectangle);\n            const r = new RectangleObstacle(bestRectangle, null);\n            this.AddLabelObstacle(r);\n            const labelInfo = this.getLabelInfo(label);\n            if (bestConflictIndex === 0)\n                labelInfo.placementResult = LabelPlacementResult.OverlapsOtherLabels;\n            else if (bestConflictIndex === 1)\n                labelInfo.placementResult = LabelPlacementResult.OverlapsNodes;\n            else if (bestConflictIndex === 2)\n                labelInfo.placementResult = LabelPlacementResult.OverlapsEdges;\n            else\n                labelInfo.placementResult = LabelPlacementResult.OverlapsNothing;\n            return true;\n        }\n        return false;\n    }\n    //     Gets the label placement bounds for the given location, side, and label size.\n    // The point along a curve that the label should be placed near.\n    // The derivative of the curve at the point position.\n    // The width and height of the label.\n    // The side (1 or -1) of the line to place the label on.\n    // <returns>The label's desired position.</returns>\n    static GetLabelBounds(point, derivative, size, side) {\n        const o = derivative.rotate(Math.PI / 2).mul(side);\n        const labelPos = point.add(o);\n        const oLength = 1;\n        let left = o.x > 0 ? labelPos.x : labelPos.x - size.width;\n        let bottom = o.y > 0 ? labelPos.y : labelPos.y - size.height;\n        // If the line is near horizontal, shift the placement\n        // to make it naturally transistion from o.X being negative to positive.\n        if (Math.abs(o.x) < 0.75) {\n            // _________  /\n            // |______w_|/\n            //     \\   o/\n            //      \\  /\n            //       \\/ <-- right angle\n            //       /\n            //      /\n            // Get the angle, 'o', between the line and the label\n            const horizontalAngle = Math.acos(Math.abs(o.y) / oLength);\n            // Get the distance, 'w', from the tip of the normal to the line\n            const horizontalShift = oLength / Math.sin(horizontalAngle);\n            const verticalShift = oLength / Math.cos(horizontalAngle);\n            // Shift the label by this amount, or by half the width.  Whichever is smaller\n            left += (o.x > 0 ? -1 : 1) * Math.min(horizontalShift, size.width / 2.0);\n            bottom += (o.y > 0 ? 1 : -1) * verticalShift;\n        }\n        else if (Math.abs(o.y) < 0.75) {\n            const verticalAngle = Math.acos(Math.abs(o.x) / oLength);\n            const verticalShift = oLength / Math.sin(verticalAngle);\n            const horizontalShift = oLength / Math.cos(verticalAngle);\n            left += (o.x > 0 ? 1 : -1) * horizontalShift;\n            bottom += (o.y > 0 ? -1 : 1) * Math.min(verticalShift, size.height / 2.0);\n        }\n        return Rectangle.mkLeftBottomSize(left, bottom, size);\n    }\n    //     Sets the label's position to be the given bounds.\n    SetLabelBounds(labelInfo, bounds) {\n        labelInfo.innerPoints = [bounds.leftTop, bounds.rightTop];\n        labelInfo.outerPoints = [bounds.leftBottom, bounds.rightBottom];\n    }\n    //     Gets the possible sides for the given label and the given derivative point.\n    // <returns>An enumeration of the possible sides (-1 or 1).</returns>\n    static GetPossibleSides(side, derivative) {\n        if (derivative.length === 0) {\n            side = PlacementSide.Any;\n        }\n        switch (side) {\n            case PlacementSide.Port:\n                return [-1];\n                break;\n            case PlacementSide.Starboard:\n                return [1];\n            case PlacementSide.Top:\n                if (closeDistEps(derivative.x, 0)) {\n                    // If the line is vertical, Top becomes Left\n                    return EdgeLabelPlacement.GetPossibleSides(PlacementSide.Left, derivative);\n                }\n                return [1];\n            case PlacementSide.Bottom:\n                if (closeDistEps(derivative.x, 0)) {\n                    // If the line is vertical, Bottom becomes Right\n                    return EdgeLabelPlacement.GetPossibleSides(PlacementSide.Right, derivative);\n                }\n                return [derivative.x < 0 ? -1 : 1];\n            case PlacementSide.Left:\n                if (closeDistEps(derivative.y, 0)) {\n                    // If the line is horizontal, Left becomes Top\n                    return EdgeLabelPlacement.GetPossibleSides(PlacementSide.Top, derivative);\n                }\n                return [derivative.y < 0 ? -1 : 1];\n            case PlacementSide.Right:\n                if (closeDistEps(derivative.y, 0)) {\n                    // If the line is horizontal, Right becomes Bottom\n                    return EdgeLabelPlacement.GetPossibleSides(PlacementSide.Bottom, derivative);\n                }\n                return [derivative.y < 0 ? 1 : -1];\n            default:\n                return [-1, 1];\n        }\n    }\n    static *ExpandingSearch(start, min, max) {\n        let upper = start + 1;\n        let lower = upper;\n        while (lower > min) {\n            yield --lower;\n        }\n        while (upper < max) {\n            yield upper++;\n        }\n    }\n    static PointSetLength(ps) {\n        let l = 0;\n        let q = null;\n        for (const p of ps) {\n            if (q != null) {\n                l += q.sub(p.Center).length;\n            }\n            q = p.Center;\n        }\n        return l;\n    }\n    PlaceEdgeLabelOnCurve(label) {\n        // approximate label with a set of circles\n        // generate list of candidate points for label ordered by priority\n        // check candidate point for conflicts - if none then stop and keep placement\n        const edge = label.parent;\n        const labelInfo = this.getLabelInfo(label);\n        labelInfo.innerPoints = null;\n        const curvePoints = labelInfo.edgePoints;\n        const distanceFromCurve = 3;\n        const radius = label.height / 2;\n        const wh = new Size(radius, radius);\n        const labelLength = label.width;\n        for (const index of EdgeLabelPlacement.ExpandingSearch(this.StartIndex(label, curvePoints), 0, curvePoints.length)) {\n            const sides = this.GetSidesAndEdgeCurve(label, edge, curvePoints, index);\n            for (const side of sides) {\n                const placedPoints = new PointSetList();\n                const t = { coveredLength: 0 };\n                this.ProcessExpandingSearchOnSide(index, curvePoints, edge.curve, side, radius, distanceFromCurve, wh, t, placedPoints, labelLength);\n                if (t.coveredLength >= labelLength) {\n                    this.CaseOfCoveredLengthGreaterThanLabelLength(label, placedPoints, t.coveredLength, labelLength, wh);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    CaseOfCoveredLengthGreaterThanLabelLength(label, placedPoints, coveredLength, labelLength, wh) {\n        const innerPoints = new Array();\n        const outerPoints = new Array();\n        const orderedPoints = Array.from(placedPoints.points);\n        const excess = coveredLength - labelLength;\n        if (excess > 0) {\n            // move back the last point\n            let q = orderedPoints[orderedPoints.length - 1];\n            let p = orderedPoints[orderedPoints.length - 2];\n            let v = q.Center.sub(p.Center);\n            let length = v.length;\n            if (excess > length) {\n                q = orderedPoints[0];\n                p = orderedPoints[1];\n                v = q.Center.sub(p.Center);\n                length = v.length;\n            }\n            const w = v.mul((length - excess) / length);\n            q.Center = p.Center.add(w);\n            q.Inner = p.Inner.add(w);\n            q.Outer = p.Outer.add(w);\n        }\n        this.GoOverOrderedPointsAndAddLabelObstacels(orderedPoints, innerPoints, outerPoints, wh);\n        // placed all points in label so we are done\n        const labelInfo = this.getLabelInfo(label);\n        labelInfo.innerPoints = innerPoints;\n        labelInfo.outerPoints = outerPoints;\n    }\n    GoOverOrderedPointsAndAddLabelObstacels(orderedPoints, innerPoints, outerPoints, wh) {\n        for (const p of orderedPoints) {\n            const center = p.Center;\n            innerPoints.push(p.Inner);\n            outerPoints.push(p.Outer);\n            const r = new RectangleObstacle(Rectangle.mkSizeCenter(new Size(wh.width * 2, wh.height * 2), center), null);\n            this.AddLabelObstacle(r);\n        }\n    }\n    ProcessExpandingSearchOnSide(index, curvePoints, curve, side, radius, distanceFromCurve, wh, t, placedPoints, labelLength) {\n        for (const i of EdgeLabelPlacement.ExpandingSearch(index, 0, curvePoints.length)) {\n            const [par, pnt] = curvePoints[i];\n            const der = curve.derivative(par);\n            if (closeDistEps(der.lengthSquared, 0)) {\n                continue;\n            }\n            const o = der\n                .rotate(Math.PI / 2)\n                .normalize()\n                .mul(side);\n            const labelPos = pnt.add(o.mul(radius + distanceFromCurve));\n            if (!this.Conflict(labelPos, radius, wh)) {\n                // found a valid candidate position\n                const ps = new PointSet();\n                ps.Center = labelPos;\n                ps.Inner = pnt.add(o.mul(distanceFromCurve));\n                ps.Outer = pnt.add(o.mul(2.0 * radius + distanceFromCurve));\n                t.coveredLength = i <= index ? placedPoints.AddFirst(ps) : placedPoints.AddLast(ps);\n                if (t.coveredLength >= labelLength) {\n                    break;\n                }\n            }\n            else {\n                // not going to work!\n                break;\n            }\n        }\n    }\n    GetSidesAndEdgeCurve(label, e, curvePoints, index) {\n        const initialDer = e.curve.derivative(curvePoints[index][0]);\n        return EdgeLabelPlacement.GetPossibleSides(this.getLabelInfo(label).placementSide, initialDer);\n    }\n    //     Determines if the query point intersects with any of the obstacles.\n    // <returns>True if the query point itnersects with any of the obstacles.</returns>\n    Conflict(labelPos, radius, wh) {\n        return this.ConflictIndex(labelPos, radius, wh) !== Number.MAX_VALUE;\n    }\n    //    Determines the index of the first obstacle map that the rectangle intersects.\n    //    Clusters that are parents/grandparents of the label's source/target nodes are not considered intersection.\n    // <returns>The index of the first obstacle map that the rectangle intersects. int.MaxValue if there is no intersection.</returns>\n    ConflictIndexRL(queryRect, label) {\n        const edge = label.parent;\n        const source = edge.source;\n        const target = edge.target;\n        for (let i = 0; i < this.obstacleMaps.length; i++) {\n            if (this.obstacleMaps[i] == null) {\n                continue;\n            }\n            for (const obstacle of this.obstacleMaps[i].GetAllIntersecting(queryRect)) {\n                // If we're overlapping a node...\n                if (i === LabelPlacementResult.OverlapsNodes) {\n                    // ...and the node is a cluster...\n                    const isRectangleObstacle = obstacle instanceof RectangleObstacle;\n                    if (isRectangleObstacle) {\n                        const isCluster = obstacle.data instanceof GeomGraph;\n                        // ...and the cluster is a grandparent of the source or target...\n                        if (isCluster && (source.node.isDescendantOf(obstacle.data.graph) || target.node.isDescendantOf(obstacle.data))) {\n                            // ...don't consider the overlap to be a conflict.\n                            continue;\n                        }\n                    }\n                }\n                return i;\n            }\n        }\n        return Number.MAX_VALUE;\n    }\n    /**   Determines the index of the first obstacle map that the point intersects.\n      Returns the index of the first obstacle map that the point intersects. int.MaxValue if there is no intersection.*/\n    ConflictIndex(labelPos, radius, wh) {\n        const queryRect = Rectangle.creatRectangleWithSize(new Size(wh.width * 2, wh.height * 2), labelPos);\n        const r2 = radius * radius;\n        for (let i = 0; i < this.obstacleMaps.length; i++) {\n            if (this.obstacleMaps[i] == null) {\n                continue;\n            }\n            for (let i = 0; i < this.obstacleMaps.length; i++) {\n                if (this.obstacleMaps[i] == null)\n                    continue;\n                for (const c of this.obstacleMaps[i].GetAllIntersecting(queryRect)) {\n                    if (c instanceof PortObstacle) {\n                        if (labelPos.sub(c.location).lengthSquared < r2)\n                            return i;\n                    }\n                    else\n                        return i;\n                }\n            }\n            return Number.MAX_VALUE;\n        }\n    }\n}\n/**       The default and minimum granularity for breaking up a curve into many points.*/\nEdgeLabelPlacement.MinGranularity = 5;\n/**       The maximum granulairty for breaking up a curve into many points.*/\nEdgeLabelPlacement.MaxGranularity = 50;\n/**       The number of edges at which to start increasing the granularity.*/\nEdgeLabelPlacement.LowerEdgeBound = 500;\n/**       The number of edges at which to stop increasing the granularity.*/\nEdgeLabelPlacement.UpperEdgeBound = 3000;\n//# sourceMappingURL=edgeLabelPlacement.js.map","import { Interval } from '../../math/geometry/Interval';\nimport { mkRTree } from '../../math/geometry/RTree/rTree';\nimport { BinaryHeapPriorityQueue } from '../../structs/BinaryHeapPriorityQueue';\nimport { GTreeOverlapRemoval } from './gTreeOverlapRemoval';\nexport class MstLineSweeper {\n    constructor(proximityEdges, nodeSizes, nodePositions, forLayers) {\n        this._numberOfOverlaps = 0;\n        this._proximityEdges = proximityEdges;\n        this._nodeSizes = nodeSizes;\n        this._nodePositions = nodePositions;\n        this._forLayers = forLayers;\n        /*Assert.assert(nodePositions.length === nodeSizes.length)*/\n        this._q = new BinaryHeapPriorityQueue(nodeSizes.length * 2);\n    }\n    Run() {\n        this.InitQueue();\n        this.FindOverlaps();\n        return this._numberOfOverlaps;\n    }\n    FindOverlaps() {\n        while (this._q.Count > 0) {\n            let i = this._q.Dequeue();\n            if (i < this._nodePositions.length) {\n                this.FindOverlapsWithInterval(i);\n                this.AddIntervalToTree(i);\n            }\n            else {\n                i -= this._nodePositions.length;\n                this.RemoveIntervalFromTree(i);\n            }\n        }\n    }\n    RemoveIntervalFromTree(i) {\n        this._intervalTree.Remove(this.GetInterval(i), i);\n    }\n    AddIntervalToTree(i) {\n        const interval = this.GetInterval(i);\n        if (this._intervalTree == null) {\n            this._intervalTree = mkRTree([]);\n        }\n        this._intervalTree.Add(interval, i);\n    }\n    FindOverlapsWithInterval(i) {\n        if (this._intervalTree == null) {\n            return;\n        }\n        const interval = this.GetInterval(i);\n        for (const j of this._intervalTree.GetAllIntersecting(interval)) {\n            const edge = GTreeOverlapRemoval.GetIdealEdge(i, j, this._nodePositions[i], this._nodePositions[j], this._nodeSizes);\n            if (edge.overlapFactor <= 1) {\n                return;\n            }\n            this._proximityEdges.push(edge);\n            this._numberOfOverlaps++;\n        }\n    }\n    GetInterval(i) {\n        const w = this._nodeSizes[i].width / 2;\n        const nodeCenterX = this._nodePositions[i].x;\n        return new Interval(nodeCenterX - w, nodeCenterX + w);\n    }\n    InitQueue() {\n        for (let i = 0; i < this._nodeSizes.length; i++) {\n            const h = this._nodeSizes[i].height / 2;\n            const nodeCenterY = this._nodePositions[i].y;\n            this._q.Enqueue(i, nodeCenterY - h);\n            // enqueue the bottom event\n            this._q.Enqueue(this._nodeSizes.length + i, nodeCenterY + h);\n            // enqueue the top event\n        }\n    }\n}\n//# sourceMappingURL=MstLineSweeper.js.map","import { MinimumSpanningTreeByPrim } from '../../math/graphAlgorithms/MinimumSpanningTreeByPrim';\nimport { mkGraphOnEdgesArray, mkGraphOnEdgesN } from '../../structs/basicGraphOnEdges';\nimport { IntPair } from '../../utils/IntPair';\nimport { IntPairMap } from '../../utils/IntPairMap';\n// Computes the minimum spanning tree on a triangulation or on a set of edges given by a list of tuples\nexport class MstOnDelaunayTriangulation {\n    // Computes the minimum spanning tree on a set of edges\n    static GetMst(proximityEdges, size) {\n        if (proximityEdges.length === 0) {\n            return null;\n        }\n        const intPairs = proximityEdges.map((t) => new IntPair(t.source, t.target));\n        const weighting = new IntPairMap();\n        for (let i = 0; i < proximityEdges.length; i++) {\n            weighting.setPair(intPairs[i], proximityEdges[i]);\n        }\n        const graph = mkGraphOnEdgesN(intPairs, size);\n        const mstOnBasicGraph = new MinimumSpanningTreeByPrim(graph, (intPair) => weighting.get(intPair.source, intPair.target).weight, intPairs[0].source);\n        return mstOnBasicGraph.GetTreeEdges().map((e) => weighting.get(e.source, e.target));\n    }\n    // Computes the minimum spanning tree on a DT with given weights.\n    static GetMstOnCdt(cdt, weights) {\n        const siteArray = Array.from(cdt.PointsToSites.values());\n        const siteIndex = new Map();\n        for (let i = 0; i < siteArray.length; i++) {\n            siteIndex.set(siteArray[i], i);\n        }\n        const intPairsToCdtEdges = MstOnDelaunayTriangulation.GetEdges(siteArray, siteIndex);\n        const graph = mkGraphOnEdgesArray(Array.from(intPairsToCdtEdges.keys()));\n        const mstOnBasicGraph = new MinimumSpanningTreeByPrim(graph, (e) => weights(intPairsToCdtEdges.get(e.source, e.target)), 0);\n        return mstOnBasicGraph.GetTreeEdges().map((e) => intPairsToCdtEdges.get(e.source, e.target));\n    }\n    static GetEdges(siteArray, siteIndex) {\n        const d = new IntPairMap();\n        for (let i = 0; i < siteArray.length; i++) {\n            const site = siteArray[i];\n            const sourceIndex = siteIndex.get(site);\n            for (const e of site.Edges) {\n                d.set(sourceIndex, siteIndex.get(e.lowerSite), e);\n            }\n        }\n        return d;\n    }\n}\n//# sourceMappingURL=MstOnDelaunayTriangulation.js.map","// Settings for Overlap Removal process. Usage of the properties depends on the algorithm.\nexport class OverlapRemovalSettings {\n    constructor() {\n        this.epsilon = 0.01;\n        this.iterationsMax = 1000;\n        this.stopOnMaxIterat = false;\n        this.nodeSeparation = 4;\n        this.randomizationSeed = 1;\n        this.randomizationShift = 0.1;\n    }\n    // If true, the overlap iteration process stops after maxIterat iterations.\n    get StopOnMaxIterat() {\n        return this.stopOnMaxIterat;\n    }\n    set StopOnMaxIterat(value) {\n        this.stopOnMaxIterat = value;\n    }\n    // Epsilon\n    get Epsilon() {\n        return this.epsilon;\n    }\n    set Epsilon(value) {\n        this.epsilon = value;\n    }\n    // Number of maxIterat to be made. In each iteration overlap is partly removed.\n    get IterationsMax() {\n        return this.iterationsMax;\n    }\n    set IterationsMax(value) {\n        this.iterationsMax = value;\n    }\n    // Minimal distance between nodes.\n    get NodeSeparation() {\n        return this.nodeSeparation;\n    }\n    set NodeSeparation(value) {\n        this.nodeSeparation = value;\n    }\n    //\n    get RandomizationSeed() {\n        return this.randomizationSeed;\n    }\n    set RandomizationSeed(value) {\n        this.randomizationSeed = value;\n    }\n    //\n    get RandomizationShift() {\n        return this.randomizationShift;\n    }\n    set RandomizationShift(value) {\n        this.randomizationShift = value;\n    }\n    // Clones the settings together with the stressmajorization settings\n    Clone() {\n        const settings = new OverlapRemovalSettings();\n        settings.Epsilon = this.Epsilon;\n        settings.IterationsMax = this.IterationsMax;\n        settings.StopOnMaxIterat = this.StopOnMaxIterat;\n        settings.NodeSeparation = this.NodeSeparation;\n        settings.RandomizationSeed = this.RandomizationSeed;\n        settings.RandomizationShift = this.randomizationShift;\n        return settings;\n    }\n}\n//# sourceMappingURL=OverlapRemovalSettings.js.map","import { Random } from 'reliable-random';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { Point } from '../../math/geometry/point';\nimport { Rectangle } from '../../math/geometry/rectangle';\nimport { Cdt } from '../../routing/ConstrainedDelaunayTriangulation/Cdt';\nimport { PointSet } from '../../utils/PointSet';\nimport { MstLineSweeper } from './MstLineSweeper';\nimport { MstOnDelaunayTriangulation } from './MstOnDelaunayTriangulation';\nimport { OverlapRemovalSettings } from './OverlapRemovalSettings';\n// Overlap Removal using Minimum Spanning Tree on the delaunay triangulation. The edge weight corresponds to the amount of overlap between two nodes.\nexport class GTreeOverlapRemoval {\n    // Settings to be used for the overlap removal, not all of them are used.\n    constructor(settings, nodes) {\n        this._settings = settings;\n        this._nodes = nodes;\n    }\n    // Removes the overlap by using the default settings.\n    static RemoveOverlaps(nodes, nodeSeparation) {\n        const settings = new OverlapRemovalSettings();\n        settings.RandomizationShift = 1;\n        settings.NodeSeparation = nodeSeparation;\n        const mst = new GTreeOverlapRemoval(settings, nodes);\n        mst.RemoveOverlaps();\n    }\n    // Removes the overlaps for the given graph.\n    RemoveOverlaps() {\n        if (this._nodes.length < 3) {\n            this.RemoveOverlapsOnTinyGraph();\n            return;\n        }\n        const t = { nodePositions: new Array(), nodeSizes: new Array() };\n        InitNodePositionsAndBoxes(this._settings, this._nodes, t, this._settings.RandomizationShift);\n        this.lastRunNumberIterations = 0;\n        while (this.OneIteration(t.nodePositions, t.nodeSizes, false)) {\n            this.lastRunNumberIterations++;\n        }\n        while (this.OneIteration(t.nodePositions, t.nodeSizes, true)) {\n            this.lastRunNumberIterations++;\n        }\n        for (let i = 0; i < this._nodes.length; i++) {\n            this._nodes[i].center = t.nodePositions[i];\n        }\n    }\n    RemoveOverlapsOnTinyGraph() {\n        if (this._nodes.length === 1) {\n            return;\n        }\n        if (this._nodes.length === 2) {\n            const a = this._nodes[0];\n            const b = this._nodes[1];\n            if (Point.closeDistEps(a.center, b.center)) {\n                b.center = b.center.add(new Point(0.001, 0));\n            }\n            const idealDist = this.GetIdealDistanceBetweenTwoNodes(a, b);\n            const o = Point.middle(a.center, b.center);\n            let dir = a.center.sub(b.center);\n            const dist = dir.length;\n            dir = dir.mul(0.5 * (idealDist / dist));\n            a.center = o.add(dir);\n            b.center = o.sub(dir);\n        }\n    }\n    GetIdealDistanceBetweenTwoNodes(a, b) {\n        const ab = a.center.sub(b.center);\n        const dx = Math.abs(ab.x);\n        const dy = Math.abs(ab.y);\n        const w = (a.width + b.width) / 2 + this._settings.NodeSeparation;\n        const h = (a.height + b.height) / 2 + this._settings.NodeSeparation;\n        let scaleX = Number.POSITIVE_INFINITY;\n        let scaleY = Number.POSITIVE_INFINITY;\n        if (dx > GeomConstants.tolerance) {\n            scaleX = w / dx;\n        }\n        if (dy > GeomConstants.tolerance) {\n            scaleY = h / dy;\n        }\n        return Math.min(scaleX, scaleY) * ab.length;\n    }\n    static AvgEdgeLength(nodes) {\n        let count = 0;\n        let avgEdgeLength = 0;\n        for (const n of nodes) {\n            for (const edge of n.outEdges()) {\n                avgEdgeLength += n.center.sub(edge.target.center).length;\n                count++;\n            }\n        }\n        return count > 0 ? avgEdgeLength / count : 1;\n    }\n    // Does one iterations in which a miniminum spanning tree is\n    // determined on the delaunay triangulation and finally the tree is extended to resolve the overlaps.\n    OneIteration(nodePositions, nodeSizes, scanlinePhase) {\n        const ts = new Array();\n        for (let i = 0; i < nodePositions.length; i++) {\n            ts.push([nodePositions[i], i]);\n        }\n        const cdt = Cdt.constructor_(ts);\n        cdt.run();\n        const siteIndex = new Map();\n        for (let i = 0; i < nodePositions.length; i++) {\n            siteIndex.set(cdt.PointsToSites.get(nodePositions[i]), i);\n        }\n        let numCrossings = 0;\n        const proximityEdges = new Array();\n        for (const site of cdt.PointsToSites.values()) {\n            for (const edge of site.Edges) {\n                const point1 = edge.upperSite.point;\n                const point2 = edge.lowerSite.point;\n                const i = siteIndex.get(edge.upperSite);\n                const j = siteIndex.get(edge.lowerSite);\n                /*Assert.assert(Point.closeDistEps(point1, nodePositions[i]))*/\n                /*Assert.assert(Point.closeDistEps(point2, nodePositions[j]))*/\n                const mstEdge = GTreeOverlapRemoval.GetIdealEdge(i, j, point1, point2, nodeSizes);\n                proximityEdges.push(mstEdge);\n                if (mstEdge.overlapFactor > 1) {\n                    numCrossings++;\n                }\n            }\n        }\n        if (numCrossings === 0 || scanlinePhase) {\n            const additionalCrossings = this.FindProximityEdgesWithSweepLine(proximityEdges, nodeSizes, nodePositions);\n            if (numCrossings === 0 && additionalCrossings === 0) {\n                //                    if(nodeSizes.Length>100)\n                //                    ShowAndMoveBoxesRemoveLater(null, proximityEdges, nodeSizes, nodePositions, -1);\n                return false;\n            }\n            if (numCrossings === 0 && !scanlinePhase) {\n                return false;\n            }\n        }\n        const treeEdges = MstOnDelaunayTriangulation.GetMst(proximityEdges, nodePositions.length);\n        GTreeOverlapRemoval.MoveNodePositions(treeEdges, nodePositions, treeEdges[0].source);\n        return true;\n    }\n    FindProximityEdgesWithSweepLine(proximityEdges, nodeSizes, nodePositions) {\n        const mstLineSweeper = new MstLineSweeper(proximityEdges, nodeSizes, nodePositions, this._overlapForLayers);\n        return mstLineSweeper.Run();\n    }\n    // Returns an edge with: i, j, t(overlapFactor), ideal distance, edge weight.\n    static GetIdealEdge(i, j, point1, point2, nodeSizes) {\n        const t = { overlapFactor: 0 };\n        const idealDist = GTreeOverlapRemoval.GetIdealEdgeLength(i, j, point1, point2, nodeSizes, t);\n        const length = point1.sub(point2).length;\n        const box1 = Rectangle.mkSizeCenter(nodeSizes[i], point1);\n        const box2 = Rectangle.mkSizeCenter(nodeSizes[j], point2);\n        const weight = t.overlapFactor > 1 ? length - idealDist : GTreeOverlapRemoval.GetDistanceRects(box1, box2);\n        return {\n            source: Math.min(i, j),\n            target: Math.max(i, j),\n            overlapFactor: t.overlapFactor,\n            idealDistance: idealDist,\n            weight: weight,\n        };\n    }\n    // Returns the ideal edge length, such that the overlap is removed.\n    static GetIdealEdgeLength(i, j, point1, point2, nodeBoxes, wrapTRes) {\n        const p1p2 = point1.sub(point2);\n        const dist = p1p2.length;\n        const dx = Math.abs(p1p2.x);\n        const dy = Math.abs(p1p2.y);\n        const h = (nodeBoxes[i].width + nodeBoxes[j].width) / 2;\n        const w = (nodeBoxes[i].height + nodeBoxes[j].height) / 2;\n        if (dx >= h || dy >= w) {\n            // no overlap\n            wrapTRes.overlapFactor = 1;\n            return p1p2.length;\n        }\n        let t;\n        const accuracy = 1e-10;\n        if (dx > accuracy) {\n            if (dy > accuracy) {\n                t = Math.min(h / dx, w / dy);\n            }\n            else {\n                t = h / dx;\n            }\n        }\n        else if (dy > accuracy) {\n            t = w / dy;\n        }\n        else {\n            // the points almost coincide : this should not happen.\n            // Anyway, they will be moved away on some random vector\n            wrapTRes.overlapFactor = 2; // important that is greater than 1\n            return Math.sqrt(h * h + w * w) / 4;\n        }\n        /*Assert.assert(t >= 1)*/\n        t = Math.max(t, 1.001); // to be  on the safe side\n        wrapTRes.overlapFactor = t;\n        return t * dist;\n    }\n    // Returns the distance between two given rectangles or zero if they intersect.\n    static GetDistanceRects(a, b) {\n        if (a.intersects(b)) {\n            return 0;\n        }\n        let dy = 0;\n        let dx = 0;\n        if (a.right < b.left) {\n            dx = a.left - b.right;\n        }\n        else if (b.right < a.left) {\n            dx = a.left - b.right;\n        }\n        if (a.top < b.bottom) {\n            dy = b.bottom - a.top;\n        }\n        else if (b.top < a.bottom) {\n            dy = a.bottom - b.top;\n        }\n        const euclid = Math.sqrt(dx * dx + dy * dy);\n        return euclid;\n    }\n    /*\n    // Shows the current state of the algorithm for debug purposes.\n    ShowAndMoveBoxesRemoveLater(treeEdges: Array<MstEdge>, proximityEdges: Array<MstEdge>, nodeSizes: Size[], nodePos: Point[], rootId: number) {\n      let l = new Array<DebugCurve>();\n      for (let tuple of proximityEdges) {\n        l.Add(new DebugCurve(100, 0.5, \"black\", new LineSegment(nodePos[tuple.Item1], nodePos[tuple.Item2])));\n      }\n  \n      // just for debug\n      let nodeBoxes = new Array(nodeSizes.length);\n      for (let i: number = 0; (i < nodePos.length); i++) {\n        nodeBoxes[i] = new Rectangle(nodeSizes[i], nodePos[i]);\n      }\n  \n      l.AddRange(nodeBoxes.Select(() => { }, new DebugCurve(100, 0.3, \"green\", b.Perimeter())));\n      if ((treeEdges != null)) {\n        l.AddRange(treeEdges.Select(() => { }, new DebugCurve(200, GTreeOverlapRemoval.GetEdgeWidth(e), \"red\", new LineSegment(nodePos[e.Item1], nodePos[e.Item2]))));\n      }\n  \n      if ((rootId >= 0)) {\n        l.Add(new DebugCurve(100, 10, \"blue\", CurveFactory.CreateOctagon(30, 30, nodePos[rootId])));\n      }\n  \n      LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n    }\n  \n    static GetEdgeWidth(edge: MstEdge): number {\n      if ((edge.Item3 > 1)) {\n        return 6;\n      }\n  \n      return 2;\n    }\n  */\n    // Lets the tree grow according to the ideal distances.\n    static MoveNodePositions(treeEdges, nodePositions, rootNodeId) {\n        const posOld = nodePositions.map((p) => p.clone());\n        const visited = new Set();\n        visited.add(rootNodeId);\n        for (let i = 0; i < treeEdges.length; i++) {\n            const e = treeEdges[i];\n            if (visited.has(e.source)) {\n                GTreeOverlapRemoval.MoveNode(e.source, e.target, posOld, nodePositions, visited, e.idealDistance);\n            }\n            else {\n                /*Assert.assert(visited.has(e.target))*/ // hmm, why does this hold?\n                GTreeOverlapRemoval.MoveNode(e.target, e.source, posOld, nodePositions, visited, e.idealDistance);\n            }\n        }\n    }\n    static MoveNode(standingNode, movingNode, oldPos, newPos, visited, idealDist) {\n        let dir = oldPos[movingNode].sub(oldPos[standingNode]);\n        dir = dir.mul(idealDist / dir.length + 0.01);\n        newPos[movingNode] = newPos[standingNode].add(dir);\n        visited.add(movingNode);\n    }\n    //\n    GetLastRunIterations() {\n        return this.lastRunNumberIterations;\n    }\n}\nfunction InitNodePositionsAndBoxes(overlapRemovalSettings, nodes, t, randomizeShift) {\n    t.nodePositions = nodes.map((v) => v.center);\n    if (randomizeShift)\n        randomizePoints(t.nodePositions, new Random(0, 0), randomizeShift);\n    t.nodeSizes = nodes.map((n) => {\n        const s = n.boundingBox.size;\n        s.width += overlapRemovalSettings.NodeSeparation; // this pad with both sides by overlapRemovalSettings.NodeSeparation/2\n        s.height += overlapRemovalSettings.NodeSeparation;\n        return s;\n    });\n}\n/** When randomizeAll is true then the points are shifter randomly at the small distance between 0 and epsilon.\n * Otherwise the points are shifted just to avoid the exact repetition.\n */\nfunction randomizePoints(points, random, randomizationShift) {\n    const pointSet = new PointSet();\n    for (let i = 0; i < points.length; i++) {\n        let p = points[i];\n        if (randomizationShift || pointSet.has(p)) {\n            do {\n                const newX = p.x + (2 * random.random() - 1) * randomizationShift;\n                const newY = p.y + (2 * random.random() - 1) * randomizationShift;\n                p = new Point(newX, newY);\n            } while (pointSet.has(p));\n        }\n        points[i] = p;\n        pointSet.add(p);\n    }\n}\n//# sourceMappingURL=gTreeOverlapRemoval.js.map","import { getFiNode } from './fiNode';\nexport class FiEdge {\n    constructor(mEdge) {\n        this._length = 1;\n        this.mEdge = mEdge;\n        this.sourceFiNode = getFiNode(this.mEdge.source);\n        this.targetFiNode = getFiNode(this.mEdge.target);\n    }\n    get source() {\n        return this.sourceFiNode.index;\n    }\n    get target() {\n        return this.targetFiNode.index;\n    }\n    get length() {\n        return this._length;\n    }\n    set length(value) {\n        this._length = value;\n    }\n    vector() {\n        return this.sourceFiNode.geomNode.center.sub(this.targetFiNode.geomNode.center);\n    }\n}\n//# sourceMappingURL=fiEdge.js.map","//  Wrapper for GeomNode node to add force and velocity vectors\nimport { Point } from '../../math/geometry';\nimport { AlgorithmData } from '../../structs/algorithmData';\nexport function getFiNode(filNode) {\n    const algData = AlgorithmData.getAlgData(filNode.node);\n    if (algData == null)\n        return null;\n    return algData.data;\n}\nexport class FiNode {\n    //  local cache of node center (which in the MSAGL node has to be computed from the bounding box)\n    get Center() {\n        return this.center;\n    }\n    set Center(value) {\n        this.geomNode.center = value;\n        this.center = value;\n    }\n    //  When mNode's bounds change we need to update our local\n    //  previous and current center to MSAGL node center\n    //  and update width and height\n    ResetBounds() {\n        this.previousCenter = this.geomNode.center;\n        this.center = this.geomNode.center;\n        this.Width = this.geomNode.width;\n        this.Height = this.geomNode.height;\n    }\n    constructor(index, mNode) {\n        this.force = new Point(0, 0);\n        this.stayWeight = 1;\n        this.index = index;\n        this.geomNode = mNode;\n        this.ResetBounds();\n    }\n    //  Update the current X or Y coordinate of the node center from the result of a solve\n    ToString() {\n        return 'FINode(' + (this.index + ('):' + this.geomNode));\n    }\n}\n//# sourceMappingURL=fiNode.js.map","import { Algorithm } from '../../utils/algorithm';\nimport { mkGraphOnEdgesN } from '../../structs/basicGraphOnEdges';\nimport { FiEdge } from './fiEdge';\nimport { FiNode, getFiNode } from './fiNode';\nimport { Point } from '../../math/geometry';\nimport { FloatingPort } from '../core/floatingPort';\nimport { AlgorithmData } from '../../structs/algorithmData';\nimport { GetConnectedComponents as getConnectedComponents } from '../../math/graphAlgorithms/ConnectedComponentCalculator';\nimport { Assert } from '../../utils/assert';\nimport { KDTree, Particle } from './multipole/kdTree';\nimport { MultipoleCoefficients } from './multipole/multipoleCoefficients';\nimport { GeomObject } from '../core/geomObject';\nimport { Graph } from '../../structs/graph';\nimport { GeomNode } from '../core/geomNode';\n/**\n  Using a force directed layout strategy with approximate computation of long-range node-node repulsive forces to achieve O(n log n) running time per iteration.\n  It can be invoked on an existing layout (for example, as computed by MDS) to beautify it.\n\n*/\nexport class IPsepCola extends Algorithm {\n    //  Create the graph data structures.\n    constructor(geometryGraph, settings, initialConstraintLevel) {\n        super(null);\n        this.clustersInfo = new Map();\n        this.clusterEdges = new Array();\n        this.graph = geometryGraph;\n        this.settings = settings;\n        this.initFiNodesEdges();\n        this.edges = Array.from(this.graph.shallowEdges).map((gn) => AlgorithmData.getAlgData(gn.edge).data);\n        this.nodes = Array.from(this.graph.shallowNodes).map((gn) => AlgorithmData.getAlgData(gn.node).data);\n        this.components = new Array();\n        if (!this.settings.InterComponentForces) {\n            this.basicGraph = mkGraphOnEdgesN(this.edges, this.nodes.length);\n            for (const componentNodes of getConnectedComponents(this.basicGraph)) {\n                const vs = new Array(componentNodes.length);\n                let vi = 0;\n                for (const v of componentNodes) {\n                    vs[vi++] = this.nodes[v];\n                }\n                this.components.push(vs);\n            }\n        }\n        else {\n            this.components.push(this.nodes);\n        }\n        this.computeWeight(geometryGraph);\n        // if (this.getRB(this.graph) == null) {\n        //   this.setRB(this.graph, new RectangularClusterBoundary())\n        // }\n        this.setCurrentConstraintLevel(initialConstraintLevel);\n    }\n    initFiNodesEdges() {\n        let i = 0;\n        for (const gn of this.graph.shallowNodes) {\n            const fiNode = new FiNode(i++, gn);\n            new AlgorithmData(gn.node, fiNode); //this will bind the new fiNode with the underlying Node\n        }\n        for (const e of this.graph.shallowEdges) {\n            // if (e.source instanceof GeomGraph || e.target instanceof GeomGraph) {\n            // continue\n            //} else {\n            const fiEdge = new FiEdge(e);\n            new AlgorithmData(e.edge, fiEdge);\n            //}\n        }\n    }\n    //  Controls which constraints are applied of CalculateLayout.  Setter enforces feasibility at that level.\n    getCurrentConstraintLevel() {\n        return this.currentConstraintLevel;\n    }\n    setCurrentConstraintLevel(value) {\n        this.currentConstraintLevel = value;\n        this.settings.Unconverge();\n    }\n    //  Add constraint to constraints lists.  Warning, no check that dictionary alread holds a list for the level.\n    //  Make sure you call AddConstraintLevel first (perf).\n    //  Check for constraint level of dictionary, if it doesn't exist add the list at that level.\n    ResetNodePositions() {\n        for (const v of this.nodes) {\n            v.ResetBounds();\n        }\n    }\n    AddRepulsiveForce(v, repulsion) {\n        //  scale repulsion\n        v.force = repulsion.mul(10 * this.settings.RepulsiveForceConstant);\n    }\n    AddLogSpringForces(e, duv, d) {\n        const l = duv.length;\n        const f = 0.0007 * this.settings.AttractiveForceConstant * l * Math.log((l + 0.1) / (d + 0.1));\n        e.sourceFiNode.force = e.sourceFiNode.force.add(duv.mul(f));\n        e.targetFiNode.force = e.targetFiNode.force.sub(duv.mul(f));\n    }\n    AddSquaredSpringForces(e, duv, d) {\n        /*\n      double l = duv.Length,\n                       d2 = d*d + 0.1,\n                       f = settings.AttractiveForceConstant*(l - d)/d2;\n                e.source.force += f*duv;\n                e.target.force -= f*duv;\n                */\n        const l = duv.length;\n        const d2 = d * d + 0.1;\n        const f = (this.settings.AttractiveForceConstant * (l - d)) / d2;\n        e.sourceFiNode.force = e.sourceFiNode.force.add(duv.mul(f));\n        e.targetFiNode.force = e.targetFiNode.force.sub(duv.mul(f));\n    }\n    AddSpringForces(e) {\n        let duv;\n        if (this.settings.RespectEdgePorts) {\n            let sourceLocation = e.sourceFiNode.Center;\n            let targetLocation = e.targetFiNode.Center;\n            const sourcePort = e.mEdge.sourcePort;\n            if (sourcePort instanceof FloatingPort) {\n                sourceLocation = sourcePort.Location;\n            }\n            const targetPort = e.mEdge.targetPort;\n            if (targetPort instanceof FloatingPort) {\n                targetLocation = targetPort.Location;\n            }\n            duv = sourceLocation.sub(targetLocation);\n        }\n        else {\n            duv = e.vector();\n        }\n        if (this.settings.LogScaleEdgeForces) {\n            this.AddLogSpringForces(e, duv, e.length);\n        }\n        else {\n            this.AddSquaredSpringForces(e, duv, e.length);\n        }\n    }\n    static AddGravityForce(origin, gravity, v) {\n        if (v == null)\n            return;\n        //  compute and add gravity  v.force -= 0.0001*gravity*(origin - v.Center);\n        v.force = v.force.sub(origin.sub(v.Center).mul(gravity * 0.0001));\n    }\n    ComputeRepulsiveForces(vs) {\n        const n = vs.length;\n        if (n > 16 && this.settings.ApproximateRepulsion) {\n            const ps = new Array(vs.length);\n            //  before calculating forces we perturb each center by a small vector of a unique\n            //  but deterministic direction (by walking around a circle of n steps) - this allows\n            //  the KD-tree to decompose even when some nodes are at exactly the same position\n            const angleDelta = 2 * (Math.PI / n);\n            let angle = 0;\n            for (let i = 0; i < n; i++) {\n                ps[i] = new Particle(vs[i].Center.add(new Point(Math.cos(angle), Math.sin(angle)).mul(1e-5)));\n                angle += angleDelta;\n            }\n            const kdTree = new KDTree(ps, 8);\n            kdTree.ComputeForces(5);\n            for (let i = 0; i < vs.length; i++) {\n                this.AddRepulsiveForce(vs[i], ps[i].force);\n            }\n        }\n        else {\n            for (const u of vs) {\n                let fu = new Point(0, 0);\n                for (const v of vs) {\n                    if (u != v) {\n                        fu = fu.add(MultipoleCoefficients.Force(u.Center, v.Center));\n                    }\n                }\n                this.AddRepulsiveForce(u, fu);\n            }\n        }\n    }\n    SetBarycenter(root) {\n        const w = this.clustersInfo.get(root);\n        if (w != undefined)\n            return w.barycenter;\n        let center = new Point(0, 0);\n        //  If these are empty then Weight is 0 and barycenter becomes NaN.\n        //  If there are no child clusters with nodes, then Weight stays 0.\n        if (root.shallowNodeCount || hasSomeClusters(root)) {\n            const clusterInfo = this.clustersInfo.get(root);\n            if (clusterInfo == undefined || clusterInfo.weight == undefined) {\n                this.computeWeight(root);\n            }\n            if (clusterInfo.weight != null) {\n                for (const v of root.shallowNodes) {\n                    if (v instanceof GeomNode) {\n                        center = center.add(v.center);\n                    }\n                    else {\n                        center = center.add(this.SetBarycenter(v).mul(this.clustersInfo.get(v).weight));\n                    }\n                }\n                this.clustersInfo.get(root).barycenter = center = center.div(clusterInfo.weight);\n            }\n        }\n        else {\n            this.clustersInfo.get(root).barycenter = center;\n        }\n        return center;\n    }\n    computeWeight(root) {\n        let w = 0;\n        for (const n of root.shallowNodes) {\n            if (n.entity instanceof Graph) {\n                w += this.computeWeight(n);\n            }\n            else {\n                w++;\n            }\n        }\n        let info = this.clustersInfo.get(root);\n        if (info == null) {\n            this.clustersInfo.set(root, (info = { barycenter: new Point(0, 0) }));\n        }\n        info.weight = w;\n        return w;\n    }\n    AddClusterForces(root) {\n        if (root == null) {\n            return;\n        }\n        //  SetBarycenter is recursive.\n        this.SetBarycenter(root);\n        //  The cluster edges draw the barycenters of the connected clusters together\n        for (const e of this.clusterEdges) {\n            //  foreach cluster keep a force vector.  Replace ForEachNode calls below with a simple\n            //  addition to this force vector.  Traverse top down, tallying up force vectors of children\n            //  to be the sum of their parents.\n            const gn1 = GeomObject.getGeom(e.source);\n            const gn2 = GeomObject.getGeom(e.target);\n            const n1 = AlgorithmData.getAlgData(e.source).data;\n            const n2 = AlgorithmData.getAlgData(e.target).data;\n            const c1_is_cluster = gn1.hasOwnProperty('shallowNodes');\n            const center1 = c1_is_cluster ? this.clustersInfo.get(gn1).barycenter : gn1.center;\n            const c2_is_cluster = gn2.hasOwnProperty('shallowNodes');\n            const center2 = c2_is_cluster ? this.clustersInfo.get(gn2).barycenter : gn2.center;\n            let duv = center1.sub(center2);\n            const l = duv.length;\n            const f = 1e-8 * (this.settings.AttractiveInterClusterForceConstant * (l * Math.log(l + 0.1)));\n            duv = duv.mul(f);\n            if (c1_is_cluster) {\n                const ig = gn1;\n                for (const v of ig.shallowNodes) {\n                    const fv = AlgorithmData.getAlgData(v.node).data;\n                    fv.force = fv.force.add(duv);\n                }\n            }\n            else {\n                n1.force = n1.force.add(duv);\n            }\n            if (c2_is_cluster) {\n                const ig = gn2;\n                for (const v of ig.shallowNodes) {\n                    const fv = AlgorithmData.getAlgData(v.node).data;\n                    fv.force = fv.force.sub(duv);\n                }\n            }\n            else {\n                n2.force = n2.force.sub(duv);\n            }\n        }\n        for (const c of root.subgraphsDepthFirst) {\n            const cCenter = this.clustersInfo.get(c).barycenter;\n            for (const v of c.shallowNodes) {\n                IPsepCola.AddGravityForce(cCenter, this.settings.ClusterGravity, getFiNode(v));\n            }\n        }\n    }\n    //  Aggregate all the forces affecting each node\n    ComputeForces() {\n        if (this.components != null) {\n            for (const c of this.components)\n                this.ComputeRepulsiveForces(c);\n        }\n        else {\n            this.ComputeRepulsiveForces(this.nodes);\n        }\n        this.edges.forEach((e) => this.AddSpringForces(e));\n        for (const c of this.components) {\n            let origin = new Point(0, 0);\n            for (let i = 0; i < c.length; i++) {\n                origin = origin.add(c[i].Center);\n            }\n            origin = origin.div(c.length);\n            let maxForce = Number.NEGATIVE_INFINITY;\n            for (let i = 0; i < c.length; i++) {\n                const v = c[i];\n                IPsepCola.AddGravityForce(origin, this.settings.GravityConstant, v);\n                if (v.force.length > maxForce) {\n                    maxForce = v.force.length;\n                }\n            }\n            if (maxForce > 100) {\n                for (let i = 0; i < c.length; i++) {\n                    c[i].force = c[i].force.mul(100 / maxForce);\n                }\n            }\n        }\n        //  This is the only place where ComputeForces (and hence verletIntegration) considers clusters.\n        //  It's just adding a \"gravity\" force on nodes inside each cluster towards the barycenter of the cluster.\n        this.AddClusterForces(this.graph);\n    }\n    //  Checks if solvers need to be applied, i.e. if there are user constraints or\n    //  generated constraints (such as non-overlap) that need satisfying\n    //  Force directed layout is basically an iterative approach to solving a bunch of differential equations.\n    //  Different integration schemes are possible for applying the forces iteratively.  Euler is the simplest:\n    //   v_(i+1) = v_i + a dt\n    //   x_(i+1) = x_i + v_(i+1) dt\n    //\n    //  Verlet is much more stable (and not really much more complicated):\n    //   x_(i+1) = x_i + (x_i - x_(i-1)) + a dt dt\n    VerletIntegration() {\n        //  The following sets the Centers of all nodes to a (not necessarily feasible) configuration that reduces the cost (forces)\n        const energy0 = this.energy;\n        this.energy = this.ComputeDescentDirection(1);\n        this.UpdateStepSize(energy0);\n        let displacementSquared = 0;\n        for (let i = 0; i < this.nodes.length; i++) {\n            const v = this.nodes[i];\n            displacementSquared += v.Center.sub(v.previousCenter).lengthSquared;\n        }\n        return displacementSquared;\n    }\n    ComputeDescentDirection(alpha) {\n        this.ResetForceVectors();\n        //  velocity is the distance travelled last time step\n        if (this.settings.ApplyForces) {\n            this.ComputeForces();\n        }\n        let lEnergy = 0;\n        for (const v of this.nodes) {\n            lEnergy = lEnergy + v.force.lengthSquared;\n            let dx = v.Center.sub(v.previousCenter).mul(this.settings.Friction);\n            const a = v.force.mul(-this.stepSize * alpha);\n            v.previousCenter = v.Center;\n            Assert.assert(!Number.isNaN(a.x), '!double.IsNaN(a.X)');\n            Assert.assert(!Number.isNaN(a.y), '!double.IsNaN(a.Y)');\n            Assert.assert(Number.isFinite(a.x), '!double.IsInfinity(a.X)');\n            Assert.assert(Number.isFinite(a.y), '!double.IsInfinity(a.Y)');\n            dx = dx.add(a);\n            dx = dx.div(v.stayWeight);\n            v.Center = v.Center.add(dx);\n        }\n        return lEnergy;\n    }\n    ResetForceVectors() {\n        for (const v of this.nodes) {\n            v.force = new Point(0, 0);\n        }\n    }\n    //  Adapt StepSize based on change of energy.\n    //  Five sequential improvements of energy mean we increase the stepsize.\n    //  Any increase of energy means we reduce the stepsize.\n    UpdateStepSize(energy0) {\n        if (this.energy < energy0) {\n            if (++this.progress >= 3) {\n                this.progress = 0;\n                this.stepSize /= this.settings.Decay;\n            }\n        }\n        else {\n            this.progress = 0;\n            this.stepSize *= this.settings.Decay;\n        }\n    }\n    RungeKuttaIntegration() {\n        const y0 = new Array(this.nodes.length);\n        const k1 = new Array(this.nodes.length);\n        const k2 = new Array(this.nodes.length);\n        const k3 = new Array(this.nodes.length);\n        const k4 = new Array(this.nodes.length);\n        const energy0 = this.energy;\n        for (let i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].previousCenter = this.nodes[i].Center;\n            y0[i] = this.nodes[i].Center;\n        }\n        const alpha = 3;\n        this.ComputeDescentDirection(alpha);\n        for (let i = 0; i < this.nodes.length; i++) {\n            k1[i] = this.nodes[i].Center.sub(this.nodes[i].previousCenter);\n            this.nodes[i].Center = y0[i].add(k1[i].mul(0.5));\n        }\n        this.ComputeDescentDirection(alpha);\n        for (let i = 0; i < this.nodes.length; i++) {\n            k2[i] = this.nodes[i].Center.sub(this.nodes[i].previousCenter);\n            this.nodes[i].previousCenter = y0[i];\n            this.nodes[i].Center = y0[i].add(k2[i].mul(0.5));\n        }\n        this.ComputeDescentDirection(alpha);\n        for (let i = 0; i < this.nodes.length; i++) {\n            k3[i] = this.nodes[i].Center.sub(this.nodes[i].previousCenter);\n            this.nodes[i].previousCenter = y0[i];\n            this.nodes[i].Center = y0[i].add(k3[i]);\n        }\n        this.energy = this.ComputeDescentDirection(alpha);\n        for (let i = 0; i < this.nodes.length; i++) {\n            k4[i] = this.nodes[i].Center.sub(this.nodes[i].previousCenter);\n            this.nodes[i].previousCenter = y0[i];\n            /* (k1[i] + 2.0*k2[i] + 2.0*k3[i] + k4[i])/6.0;*/\n            const dx = k1[i].add(k2[i].mul(2).add(k3[i].mul(2)).add(k4[i])).div(6);\n            this.nodes[i].Center = y0[i].add(dx);\n        }\n        this.UpdateStepSize(energy0);\n        return this.nodes.reduce((prevSum, v) => v.Center.sub(v.previousCenter).lengthSquared + prevSum, 0);\n    }\n    //  Apply a small number of iterations of the layout.\n    //  The idea of incremental layout is that settings.minorIterations should be a small number (e.g. 3) and\n    //  CalculateLayout should be invoked of a loop, e.g.:\n    //\n    //  while(settings.RemainingIterations > 0) {\n    //     fastIncrementalLayout.CalculateLayout();\n    //     InvokeYourProcedureToRedrawTheGraphOrHandleInteractionEtc();\n    //  }\n    //\n    //  In the verletIntegration step above, the RemainingIterations is used to control damping.\n    run() {\n        this.settings.Converged = false;\n        this.settings.EdgeRoutesUpToDate = false;\n        if (this.settings.Iterations++ == 0) {\n            this.stepSize = this.settings.InitialStepSize;\n            this.energy = Number.MAX_VALUE;\n            this.progress = 0;\n        }\n        //this.StartListenToLocalProgress(this.settings.MinorIterations);\n        for (let i = 0; i < this.settings.MinorIterations; i++) {\n            const d2 = this.settings.RungeKuttaIntegration ? this.RungeKuttaIntegration() : this.VerletIntegration();\n            if (d2 < this.settings.DisplacementThreshold || this.settings.Iterations > this.settings.MaxIterations) {\n                this.settings.Converged = true;\n                //      this.ProgressComplete();\n                break;\n            }\n            this.ProgressStep();\n        }\n    }\n}\nfunction hasSomeClusters(g) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const _ of g.Clusters) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=iPsepCola.js.map","import { CommonLayoutSettings } from '../commonLayoutSettings';\nimport { IPsepCola } from './iPsepCola';\nexport class IPsepColaSetting {\n    get edgeRoutingSettings() {\n        return this.commonSettings.edgeRoutingSettings;\n    }\n    set edgeRoutingSettings(value) {\n        this.commonSettings.edgeRoutingSettings = value;\n    }\n    get PackingAspectRatio() {\n        return this.commonSettings.PackingAspectRatio;\n    }\n    set PackingAspectRatio(value) {\n        this.commonSettings.PackingAspectRatio = value;\n    }\n    get NodeSeparation() {\n        return this.commonSettings.NodeSeparation;\n    }\n    set NodeSeparation(value) {\n        this.commonSettings.NodeSeparation = value;\n    }\n    //  Stop after maxIterations completed\n    get MaxIterations() {\n        return this.maxIterations;\n    }\n    set MaxIterations(value) {\n        this.maxIterations = value;\n    }\n    //  Number of iterations in inner loop.\n    get MinorIterations() {\n        return this.minorIterations;\n    }\n    set MinorIterations(value) {\n        this.minorIterations = value;\n    }\n    //  Number of iterations completed\n    get Iterations() {\n        return this.iterations;\n    }\n    set Iterations(value) {\n        this.iterations = value;\n    }\n    //  number of times to project over all constraints at each layout iteration\n    get ProjectionIterations() {\n        return this.projectionIterations;\n    }\n    set ProjectionIterations(value) {\n        this.projectionIterations = value;\n    }\n    //  Rather than computing the exact repulsive force between all pairs of nodes (which would take O(n^2) time for n nodes)\n    //  use a fast inexact technique (that takes O(n log n) time)\n    get ApproximateRepulsion() {\n        return this.approximateRepulsion;\n    }\n    set ApproximateRepulsion(value) {\n        this.approximateRepulsion = value;\n    }\n    //  StepSize taken at each iteration (a coefficient of the force on each node) adapts depending on change in\n    //  potential energy at each step.  With this scheme changing the InitialStepSize doesn't have much effect\n    //  because if it is too large or too small it will be quickly updated by the algorithm anyway.\n    get InitialStepSize() {\n        return this.initialStepSize;\n    }\n    set InitialStepSize(value) {\n        if (value <= 0 || value > 2) {\n            throw new Error('ForceScalar should be greater than 0 and less than 2 (if we let you set it to 0 nothing would happen, greater than 2 would most likely be very unstable!)');\n        }\n        this.initialStepSize = value;\n    }\n    //  FrictionalDecay isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.\n    get Decay() {\n        return this.decay;\n    }\n    set Decay(value) {\n        if (value < 0.1 || value > 1) {\n            throw new Error('Setting decay too small gives no progress.  1==no decay, 0.1==minimum allowed value');\n        }\n        this.decay = value;\n    }\n    //  Friction isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.\n    get Friction() {\n        return this.friction;\n    }\n    set Friction(value) {\n        if (value < 0 || value > 1) {\n            throw new Error('Setting friction less than 0 or greater than 1 would just be strange.  1==no friction, 0==no conservation of velocity');\n        }\n        this.friction = value;\n    }\n    //  strength of repulsive force between each pair of nodes.  A setting of 1.0 should work OK.\n    get RepulsiveForceConstant() {\n        return this.repulsiveForceConstant;\n    }\n    set RepulsiveForceConstant(value) {\n        this.repulsiveForceConstant = value;\n    }\n    //  strength of attractive force between pairs of nodes joined by an edge.  A setting of 1.0 should work OK.\n    get AttractiveForceConstant() {\n        return this.attractiveForceConstant;\n    }\n    set AttractiveForceConstant(value) {\n        this.attractiveForceConstant = value;\n    }\n    //  gravity is a constant force applied to all nodes attracting them to the Origin\n    //  and keeping disconnected components from flying apart.  A setting of 1.0 should work OK.\n    get GravityConstant() {\n        return this.gravity;\n    }\n    set GravityConstant(value) {\n        this.gravity = value;\n    }\n    //  If the following is false forces will not be considered between each component and each component will have its own gravity origin.\n    get InterComponentForces() {\n        return this.interComponentForces;\n    }\n    set InterComponentForces(value) {\n        this.interComponentForces = value;\n    }\n    //  If the following is false forces will not be applied, but constraints will still be satisfied.\n    get ApplyForces() {\n        return this.applyForces;\n    }\n    set ApplyForces(value) {\n        this.applyForces = value;\n    }\n    constructor() {\n        this.commonSettings = new CommonLayoutSettings();\n        //  Stop after maxIterations completed\n        this.maxIterations = 100;\n        this.clusterMargin = 10;\n        this.minorIterations = 3;\n        this.projectionIterations = 5;\n        this.approximateRepulsion = true;\n        //  RungaKutta integration potentially gives smoother increments, but is more expensive\n        this.RungeKuttaIntegration = false;\n        this.initialStepSize = 1.4;\n        this.decay = 0.9;\n        this.friction = 0.8;\n        this.repulsiveForceConstant = 1;\n        this.attractiveForceConstant = 1;\n        this.gravity = 1;\n        this.interComponentForces = true;\n        this.applyForces = true;\n        //  Avoid overlaps between nodes boundaries, and if there are any\n        //  clusters, then between each cluster boundary and nodes that are not\n        //  part of that cluster.\n        this.AvoidOverlaps = true;\n        this.approximateRouting = true;\n        this.logScaleEdgeForces = true;\n        this.displacementThreshold = 0.1;\n        this.maxConstraintLevel = 2;\n        this.minConstraintLevel = 0;\n        this.attractiveInterClusterForceConstant = 1;\n        this.clusterGravity = 1;\n        this.commonSettings.NodeSeparation *= 2;\n    }\n    //  restart layout, use e.g. after a mouse drag or non-structural change to the graph\n    ResetLayout() {\n        this.Unconverge();\n        if (this.algorithm != null) {\n            this.algorithm.ResetNodePositions();\n        }\n    }\n    /**   reset iterations and convergence status*/\n    Unconverge() {\n        this.iterations = 0;\n        this.converged = false;\n    }\n    InitializeLayoutGN(graph, initialConstraintLevel) {\n        this.InitializeLayout(graph, initialConstraintLevel);\n    }\n    //  Initialize the layout algorithm\n    InitializeLayout(graph, initialConstraintLevel) {\n        this.algorithm = new IPsepCola(graph, this, initialConstraintLevel);\n        this.ResetLayout();\n    }\n    //\n    Uninitialize() {\n        this.algorithm = null;\n    }\n    //\n    get IsInitialized() {\n        return this.algorithm != null;\n    }\n    //\n    IncrementalRunG(graph) {\n        this.IncrementalRunGF(graph);\n    }\n    SetupIncrementalRun(graph) {\n        if (!this.IsInitialized) {\n            this.InitializeLayout(graph, this.MaxConstraintLevel);\n        }\n        else if (this.IsDone) {\n            //  If we were already done from last time but we are doing more work then something has changed.\n            this.ResetLayout();\n        }\n    }\n    //  Run the FastIncrementalLayout instance incrementally\n    IncrementalRunGF(graph) {\n        this.SetupIncrementalRun(graph);\n        this.algorithm.run();\n        // graph.UpdateBoundingBox()\n    }\n    //\n    IncrementalRun(cancelToken, graph) {\n        if (cancelToken != null) {\n            cancelToken.throwIfCanceled();\n        }\n        this.SetupIncrementalRun(graph);\n        this.algorithm.cancelToken = cancelToken;\n        this.algorithm.run();\n        // graph.UpdateBoundingBox()\n    }\n    Clone() {\n        return IPsepColaSetting.ctorClone(this);\n    }\n    //  If RouteEdges is true then the following is checked to see whether to do optimal shortest path routing\n    //  or use a sparse visibility graph spanner to do approximate---but much faster---shortest path routing\n    get ApproximateRouting() {\n        return this.approximateRouting;\n    }\n    set ApproximateRouting(value) {\n        this.approximateRouting = value;\n    }\n    //  If true then attractive forces across edges are computed as:\n    //  AttractiveForceConstant * actualLength * Math.Log((actualLength + epsilon) / (idealLength + epsilon))\n    //  where epsilon is a small positive constant to avoid divide by zero or taking the log of zero.\n    //  Note that LogScaleEdges can lead to ghost forces in highly constrained scenarios.\n    //  If false then a the edge force is based on (actualLength - idealLength)^2, which works better with\n    //  lots of constraints.\n    get LogScaleEdgeForces() {\n        return this.logScaleEdgeForces;\n    }\n    set LogScaleEdgeForces(value) {\n        this.logScaleEdgeForces = value;\n    }\n    //  If the amount of total squared displacement after a particular iteration falls below DisplacementThreshold then Converged is set to true.\n    //  Make DisplacementThreshold larger if you want layout to finish sooner - but not necessarily make as much progress towards a good layout.\n    get DisplacementThreshold() {\n        return this.displacementThreshold;\n    }\n    set DisplacementThreshold(value) {\n        this.displacementThreshold = value;\n    }\n    //  Set to true if displacement from the last iteration was less than DisplacementThreshold.\n    //  The caller should invoke FastIncrementalLayout.CalculateLayout() in a loop, e.g.:\n    //\n    //   while(!settings.Converged)\n    //   {\n    //     layout.CalculateLayout();\n    //     redrawGraphOrHandleInteractionOrWhatever();\n    //   }\n    //\n    //  RemainingIterations affects damping.\n    get Converged() {\n        return this.converged;\n    }\n    set Converged(value) {\n        this.converged = value;\n    }\n    //  Return iterations as a percentage of MaxIterations.  Useful for reporting progress, e.g. in a progress bar.\n    get PercentDone() {\n        if (this.Converged) {\n            return 100;\n        }\n        else {\n            return ((100 * this.iterations) / this.MaxIterations);\n        }\n    }\n    //  Not quite the same as Converged:\n    get IsDone() {\n        return this.Converged || this.iterations >= this.MaxIterations;\n    }\n    //  Returns an estimate of the cost function calculated in the most recent iteration.\n    //  It's a float because FastIncrementalLayout.Energy is a volatile float so it\n    //  can be safely read from other threads\n    get Energy() {\n        if (this.algorithm != null) {\n            return this.algorithm.energy;\n        }\n        return 0;\n    }\n    //\n    get MaxConstraintLevel() {\n        return this.maxConstraintLevel;\n    }\n    set MaxConstraintLevel(value) {\n        if (this.maxConstraintLevel != value) {\n            this.maxConstraintLevel = value;\n            if (this.IsInitialized) {\n                this.Uninitialize();\n            }\n        }\n    }\n    //\n    get MinConstraintLevel() {\n        return this.minConstraintLevel;\n    }\n    set MinConstraintLevel(value) {\n        this.minConstraintLevel = value;\n    }\n    //  Constraint level ranges from Min to MaxConstraintLevel.\n    //  0 = no constraints\n    //  1 = only structural constraints\n    //  2 = all constraints including non-overlap constraints\n    //\n    //  A typical run of FastIncrementalLayout will apply it at each constraint level, starting at 0 to\n    //  obtain an untangled unconstrained layout, then 1 to introduce structural constraints and finally 2 to beautify.\n    //  Running only at level 2 will most likely leave the graph stuck in a tangled local minimum.\n    getCurrentConstraintLevel() {\n        if (this.algorithm == null) {\n            return 0;\n        }\n        return this.algorithm.getCurrentConstraintLevel();\n    }\n    setCurrentConstraintLevel(value) {\n        this.algorithm.setCurrentConstraintLevel(value);\n    }\n    //  Attractive strength of edges connected to clusters\n    get AttractiveInterClusterForceConstant() {\n        return this.attractiveInterClusterForceConstant;\n    }\n    set AttractiveInterClusterForceConstant(value) {\n        this.attractiveInterClusterForceConstant = value;\n    }\n    //  Shallow copy the settings\n    static ctorClone(previousSettings) {\n        const ret = new IPsepColaSetting();\n        ret.maxIterations = previousSettings.maxIterations;\n        ret.minorIterations = previousSettings.minorIterations;\n        ret.projectionIterations = previousSettings.projectionIterations;\n        ret.approximateRepulsion = previousSettings.approximateRepulsion;\n        ret.initialStepSize = previousSettings.initialStepSize;\n        ret.RungeKuttaIntegration = previousSettings.RungeKuttaIntegration;\n        ret.decay = previousSettings.decay;\n        ret.friction = previousSettings.friction;\n        ret.repulsiveForceConstant = previousSettings.repulsiveForceConstant;\n        ret.attractiveForceConstant = previousSettings.attractiveForceConstant;\n        ret.gravity = previousSettings.gravity;\n        ret.interComponentForces = previousSettings.interComponentForces;\n        ret.applyForces = previousSettings.applyForces;\n        ret.AvoidOverlaps = previousSettings.AvoidOverlaps;\n        ret.RespectEdgePorts = previousSettings.RespectEdgePorts;\n        ret.RouteEdges = previousSettings.RouteEdges;\n        ret.approximateRouting = previousSettings.approximateRouting;\n        ret.logScaleEdgeForces = previousSettings.logScaleEdgeForces;\n        ret.displacementThreshold = previousSettings.displacementThreshold;\n        ret.minConstraintLevel = previousSettings.minConstraintLevel;\n        ret.maxConstraintLevel = previousSettings.maxConstraintLevel;\n        ret.attractiveInterClusterForceConstant = previousSettings.attractiveInterClusterForceConstant;\n        ret.clusterGravity = previousSettings.clusterGravity;\n        ret.PackingAspectRatio = previousSettings.PackingAspectRatio;\n        ret.NodeSeparation = previousSettings.NodeSeparation;\n        ret.clusterMargin = previousSettings.clusterMargin;\n        return ret;\n    }\n    //  Controls how tightly members of clusters are pulled together\n    get ClusterGravity() {\n        return this.clusterGravity;\n    }\n    set ClusterGravity(value) {\n        this.clusterGravity = value;\n    }\n    //      creates the settings that seems working\n    //  <returns></returns>\n    static CreateFastIncrementalLayoutSettings() {\n        const f = new IPsepColaSetting();\n        f.ApplyForces = false;\n        f.ApproximateRepulsion = true;\n        f.ApproximateRouting = true;\n        f.AttractiveForceConstant = 1.0;\n        f.AttractiveInterClusterForceConstant = 1.0;\n        f.AvoidOverlaps = true;\n        f.ClusterGravity = 1.0;\n        f.Decay = 0.9;\n        f.DisplacementThreshold = 0.00000005;\n        f.Friction = 0.8;\n        f.GravityConstant = 1.0;\n        f.InitialStepSize = 2.0;\n        f.InterComponentForces = false;\n        f.Iterations = 0;\n        f.LogScaleEdgeForces = false;\n        f.MaxConstraintLevel = 2;\n        f.MaxIterations = 20;\n        f.MinConstraintLevel = 0;\n        f.MinorIterations = 1;\n        f.ProjectionIterations = 5;\n        f.RepulsiveForceConstant = 2.0;\n        f.RespectEdgePorts = false;\n        f.RouteEdges = false;\n        f.RungeKuttaIntegration = true;\n        f.NodeSeparation = 20;\n        return f;\n    }\n}\n//# sourceMappingURL=iPsepColaSettings.js.map","import { Point } from '../../../math/geometry';\nimport { Assert } from '../../../utils/assert';\nexport class Disc {\n    /**   disc centre*/\n    get Center() {\n        return this.c;\n    }\n    /**   Radius of disc */\n    get Radius() {\n        return this.r;\n    }\n    //  squared distance from the centre of this disc to point\n    //  <returns></returns>\n    Distance2(point) {\n        const dy = this.c.y - point.y;\n        const dx = this.c.x - point.x;\n        return dx * dx + dy * dy;\n    }\n    //  Test if point is contained in this disc\n    //  <returns></returns>\n    Contains(point) {\n        return this.Distance2(point) - 1e-7 <= this.r2;\n    }\n    //  test if all specified points (apart from the except list) are contained in this disc\n    //  <returns>true if all points are contained in the disc</returns>\n    ContainsPN(points, except) {\n        for (let i = 0; i < points.length; i++) {\n            if (except.findIndex((j) => j == i) == -1 && !this.Contains(points[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //  create a zero radius disc centred at center\n    static constructorP(center) {\n        const r = new Disc();\n        r.c = center;\n        r.r = 0;\n        r.r2 = 0;\n        return r;\n    }\n    //  find the point mid-way between two points\n    static midPoint(startPoint, endPoint) {\n        return new Point((endPoint.x + startPoint.x) / 2, (endPoint.y + startPoint.y) / 2);\n    }\n    //  Create the smallest possible disc with the specified points on the boundary\n    static constructorPP(firstBoundaryPoint, secondBoundaryPoint) {\n        const d = new Disc();\n        d.c = Disc.midPoint(firstBoundaryPoint, secondBoundaryPoint);\n        d.r2 = d.Distance2(firstBoundaryPoint);\n        d.r = Math.sqrt(d.r2);\n        Assert.assert(d.OnBoundary(firstBoundaryPoint));\n        Assert.assert(d.OnBoundary(secondBoundaryPoint));\n        return d;\n    }\n    //  test if a point lies on (within a small delta of) the boundary of this disc\n    //  <returns></returns>\n    OnBoundary(point) {\n        const d = this.Distance2(point);\n        return Math.abs(d - this.r2) / (d + this.r2) < 1e-5;\n    }\n    //  computes the centre of the disc with the 3 specified points on the boundary\n    //  <returns></returns>\n    static centre(p1, p2, p3) {\n        Assert.assert(p2.x != p1.x);\n        Assert.assert(p3.x != p2.x);\n        const ma = (p2.y - p1.y) / (p2.x - p1.x);\n        const mb = (p3.y - p2.y) / (p3.x - p2.x);\n        Assert.assert(mb != ma);\n        //  collinear points not allowed\n        let y;\n        const x = (ma * mb * (p1.y - p3.y) + mb * (p1.x + p2.x) - ma * (p2.x + p3.x)) / (2 * (mb - ma));\n        if (Math.abs(ma) > Math.abs(mb)) {\n            y = (p1.y + p2.y) / 2 - (x - (p1.x + p2.x) / 2) / ma;\n        }\n        else {\n            y = (p2.y + p3.y) / 2 - (x - (p2.x + p3.x) / 2) / mb;\n        }\n        return new Point(x, y);\n    }\n    //  if the area of the triangle formed by the 3 points is 0 then the points are collinear\n    //  <returns></returns>\n    static Collinear(p1, p2, p3) {\n        return p1.x * (p2.y - p3.y) + (p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) == 0;\n    }\n    //  Create a disc with the specified points on the boundary\n    static constructorPPP(p1, p2, p3) {\n        Disc.count++;\n        const d = new Disc();\n        if (Disc.Collinear(p1, p2, p3)) {\n            const LL = new Point(Math.min(p1.x, Math.min(p2.x, p3.x)), Math.min(p1.y, Math.max(p2.y, p3.y)));\n            const UR = new Point(Math.max(p1.x, Math.max(p2.x, p3.x)), Math.max(p1.y, Math.max(p2.y, p3.y)));\n            d.c = Disc.midPoint(LL, UR);\n            d.r2 = d.Distance2(UR);\n            d.r = Math.sqrt(d.r2);\n        }\n        else {\n            const dx12 = p2.x - p1.x;\n            const dx23 = p3.x - p2.x;\n            const dx13 = p3.x - p1.x;\n            if (dx12 != 0) {\n                if (dx23 != 0) {\n                    d.c = Disc.centre(p1, p2, p3);\n                }\n                else {\n                    Assert.assert(dx13 != 0);\n                    d.c = Disc.centre(p2, p1, p3);\n                }\n            }\n            else {\n                Assert.assert(dx23 != 0);\n                //  because points are not collinear\n                d.c = Disc.centre(p2, p3, p1);\n            }\n            d.r2 = d.Distance2(p1);\n            d.r = Math.sqrt(d.r2);\n            Assert.assert(d.OnBoundary(p1));\n            Assert.assert(d.OnBoundary(p2));\n            Assert.assert(d.OnBoundary(p3));\n        }\n        return d;\n    }\n}\nDisc.count = 0;\n//# sourceMappingURL=disc.js.map","import { Queue } from 'queue-typescript';\nimport { Point } from '../../../math/geometry';\nimport { MinimumEnclosingDisc } from './minimumEnclosingDisc';\nimport { MultipoleCoefficients } from './multipoleCoefficients';\nvar Dim;\n(function (Dim) {\n    Dim[Dim[\"Horizontal\"] = 0] = \"Horizontal\";\n    Dim[Dim[\"Vertical\"] = 1] = \"Vertical\";\n})(Dim || (Dim = {}));\nclass KdNode {\n    intersects(v) {\n        const d = v.med.Center.sub(this.med.Center);\n        const l = d.length;\n        return l < v.med.Radius + this.med.Radius;\n    }\n}\nclass InternalKdNode extends KdNode {\n    constructor(med, left, right) {\n        super();\n        this.med = med;\n        this.parent = left.parent;\n        if (this.parent != null) {\n            if (this.parent.leftChild == left) {\n                this.parent.leftChild = this;\n            }\n            else {\n                //Assert.assert(this.parent.rightChild == left)\n                this.parent.rightChild = this;\n            }\n        }\n        this.leftChild = left;\n        this.rightChild = right;\n        left.parent = this;\n        right.parent = this;\n    }\n    computeMultipoleCoefficients(precision) {\n        this.leftChild.computeMultipoleCoefficients(precision);\n        this.rightChild.computeMultipoleCoefficients(precision);\n        this.multipoleCoefficients = MultipoleCoefficients.constructorPMM(this.med.Center, this.leftChild.multipoleCoefficients, this.rightChild.multipoleCoefficients);\n    }\n}\nclass LeafKdNode extends KdNode {\n    constructor(particles) {\n        super();\n        //Assert.assert(particles[0].length == particles[1].length)\n        this.particles = particles;\n        this.ComputeMinimumEnclosingDisc();\n    }\n    computeMultipoleCoefficients(precision) {\n        this.multipoleCoefficients = MultipoleCoefficients.constructorNPA(precision, this.med.Center, this.ps);\n    }\n    ComputeMinimumEnclosingDisc() {\n        const n = this.Size();\n        this.ps = new Array(n);\n        for (let i = 0; i < n; i++) {\n            this.ps[i] = this.particles[0][i].point;\n        }\n        return (this.med = MinimumEnclosingDisc.LinearComputation(this.ps));\n    }\n    Min(d) {\n        return this.particles[d][0].pos(d);\n    }\n    Size() {\n        return this.particles[0].length;\n    }\n    Max(d) {\n        return this.particles[d][this.Size() - 1].pos(d);\n    }\n    Dimension(d) {\n        return this.Max(d) - this.Min(d);\n    }\n    Split(t) {\n        const splitDirection = this.Dimension(Dim.Horizontal) > this.Dimension(Dim.Vertical) ? Dim.Horizontal : Dim.Vertical;\n        const nonSplitDirection = splitDirection == Dim.Horizontal ? Dim.Vertical : Dim.Horizontal;\n        const n = this.Size();\n        const nLeft = n >> 1;\n        const nRight = n - nLeft;\n        const leftParticles = [new Array(nLeft), new Array(nLeft)];\n        const rightParticles = [new Array(nRight), new Array(nRight)];\n        let rCtr = 0;\n        let lCtr = 0;\n        for (let i = 0; i < n; i++) {\n            const p = this.particles[splitDirection][i];\n            if (i < nLeft) {\n                leftParticles[splitDirection][i] = p;\n                p.splitLeft = true;\n            }\n            else {\n                rightParticles[splitDirection][i - nLeft] = p;\n                p.splitLeft = false;\n            }\n        }\n        for (let i = 0; i < n; i++) {\n            const p = this.particles[nonSplitDirection][i];\n            if (p.splitLeft) {\n                leftParticles[nonSplitDirection][lCtr++] = p;\n            }\n            else {\n                rightParticles[nonSplitDirection][rCtr++] = p;\n            }\n        }\n        // Assert.assert(lCtr == nLeft)\n        // Assert.assert(rCtr == nRight)\n        const parentMED = this.med;\n        this.particles = leftParticles;\n        this.ComputeMinimumEnclosingDisc();\n        t.rightSibling = new LeafKdNode(rightParticles);\n        return new InternalKdNode(parentMED, this, t.rightSibling);\n    }\n    ComputeForces() {\n        for (const u of this.particles[0]) {\n            for (const v of this.particles[0]) {\n                if (u != v) {\n                    u.force = u.force.add(MultipoleCoefficients.Force(u.point, v.point));\n                }\n            }\n        }\n    }\n}\nexport class Particle {\n    pos(d) {\n        return d == Dim.Horizontal ? this.point.x : this.point.y;\n    }\n    //  Create particle at point\n    constructor(point) {\n        this.point = point;\n        this.force = new Point(0, 0);\n    }\n}\n//  A KDTree recursively divides particles of a 2D space into a balanced tree structure by doing horizontal splits for wide bounding boxes and vertical splits for tall bounding boxes.\nexport class KDTree {\n    particlesBy(d) {\n        return this.particles.map((t) => t).sort((a, b) => a.pos(d) - b.pos(d));\n    }\n    //  Create a KDTree over the specified particles, with the leaf partitions each containing bucketSize particles.\n    constructor(particles, bucketSize) {\n        this.particles = particles;\n        const ps = new Array();\n        ps.push(this.particlesBy(Dim.Horizontal));\n        ps.push(this.particlesBy(Dim.Vertical));\n        this.leaves = new Array();\n        let l = new LeafKdNode(ps);\n        this.leaves.push(l);\n        const t = { rightSibling: null };\n        this.root = l.Split(t);\n        this.leaves.push(t.rightSibling);\n        const splitQueue = new SplitQueue(bucketSize);\n        splitQueue.EnqueueLL(l, t.rightSibling);\n        while (splitQueue.length > 0) {\n            l = splitQueue.dequeue();\n            l.Split(t);\n            this.leaves.push(t.rightSibling);\n            splitQueue.EnqueueLL(l, t.rightSibling);\n        }\n    }\n    //  Compute forces between particles using multipole approximations.\n    ComputeForces(precision) {\n        this.root.computeMultipoleCoefficients(precision);\n        for (const l of this.leaves) {\n            l.ComputeForces();\n            const stack = new Array();\n            stack.push(this.root);\n            while (stack.length > 0) {\n                const v = stack.pop();\n                if (!l.intersects(v)) {\n                    for (const p of l.particles[0]) {\n                        p.force = p.force.sub(v.multipoleCoefficients.ApproximateForce(p.point));\n                    }\n                }\n                else {\n                    if (v instanceof LeafKdNode) {\n                        for (const p of l.particles[0]) {\n                            for (const q of v.particles[0]) {\n                                if (p != q) {\n                                    p.force = p.force.add(MultipoleCoefficients.Force(p.point, q.point));\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        const n = v;\n                        stack.push(n.leftChild);\n                        stack.push(n.rightChild);\n                    }\n                }\n            }\n        }\n    }\n}\nclass SplitQueue extends Queue {\n    constructor(B) {\n        super();\n        this.B = B;\n    }\n    EnqueueLL(l, r) {\n        if (l.Size() > this.B) {\n            this.enqueue(l);\n        }\n        if (r.Size() > this.B) {\n            this.enqueue(r);\n        }\n    }\n}\n//# sourceMappingURL=kdTree.js.map","//  implementation of the \"MoveToFront\" method for computing the minimum enclosing disc of a collection of points.\n//  Runs in time linear in the number of points.  After Welzl'1991.\nimport { SinglyLinkedList as LinkedList } from \"linked-list-typed\";\nimport { Assert } from '../../../utils/assert';\nimport { Disc } from './disc';\nclass MinDisc {\n    constructor(ps, b) {\n        this.boundary = b;\n        Assert.assert(b.length <= 3);\n        switch (b.length) {\n            case 0:\n                this.disc = null;\n                break;\n            case 1:\n                this.disc = Disc.constructorP(ps[b[0]]);\n                break;\n            case 2:\n                this.disc = Disc.constructorPP(ps[b[0]], ps[b[1]]);\n                break;\n            case 3:\n                this.disc = Disc.constructorPPP(ps[b[0]], ps[b[1]], ps[b[2]]);\n                break;\n        }\n    }\n    contains(p) {\n        if (this.disc == null) {\n            return false;\n        }\n        return this.disc.Contains(p);\n    }\n}\nexport class MoveToFront {\n    //  Constructs the minimum enclosing disc for the specified points\n    constructor(ps) {\n        this.ps = ps;\n        this.L = new LinkedList();\n        for (let i = 0; i < this.ps.length; i++) {\n            this.L.push(i);\n        }\n        const md = this.mtf_md(null, new Array());\n        this.disc = md.disc;\n        this.boundary = md.boundary;\n    }\n    collinear3(b) {\n        if (b.length == 3) {\n            return Disc.Collinear(this.ps[b[0]], this.ps[b[1]], this.ps[b[2]]);\n        }\n        return false;\n    }\n    mtf_md(lPtr, b) {\n        Assert.assert(b.length <= 3);\n        let md = new MinDisc(this.ps, b);\n        if (b.length == 3) {\n            return md;\n        }\n        let lnode = this.L.head;\n        while (lnode != null && lnode != lPtr) {\n            const lnext = lnode.next;\n            const p = lnode.value;\n            if (!md.contains(this.ps[p])) {\n                const _b = Array.from(b);\n                _b.push(p);\n                Assert.assert(!this.collinear3(_b), 'Collinear points on boundary of minimal enclosing disc');\n                md = this.mtf_md(lnode, _b);\n                this.L.delete(lnode);\n                this.L.unshift(lnode.value);\n            }\n            lnode = lnext;\n        }\n        return md;\n    }\n}\n/** static methods for obtaining a minimum enclosing disc of a collection of points */\nexport class MinimumEnclosingDisc {\n    //  linear-time computation using the move-to-front heuristic by Welzl\n    //  <returns>Smallest disc that encloses all the points</returns>\n    static LinearComputation(points) {\n        const m = new MoveToFront(points);\n        return m.disc;\n    }\n    //  Computing the minimum enclosing disc the slow stupid way.  Just for testing purposes.\n    //  <returns>Smallest disc that encloses all the points</returns>\n    static SlowComputation(points) {\n        const n = points.length;\n        let mc = null;\n        let b = null;\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (i != j) {\n                    const c = Disc.constructorPP(points[i], points[j]);\n                    if (c.ContainsPN(points, [i, j])) {\n                        if (mc == null || mc.Radius > c.Radius) {\n                            mc = c;\n                            b = [i, j];\n                        }\n                    }\n                }\n                for (let k = 0; k < n; k++) {\n                    if (k != i && k != j && !Disc.Collinear(points[i], points[j], points[k])) {\n                        const c3 = Disc.constructorPPP(points[i], points[j], points[k]);\n                        if (c3.ContainsPN(points, [i, j, k])) {\n                            if (mc == null || mc.Radius > c3.Radius) {\n                                mc = c3;\n                                b = [i, j, k];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Assert.assert(b != null);\n        return mc;\n    }\n}\n//# sourceMappingURL=minimumEnclosingDisc.js.map","import { Point } from '../../../math/geometry';\nimport { Assert } from '../../../utils/assert';\nexport class MultipoleCoefficients {\n    static constructorNPA(precision, center, points) {\n        const r = new MultipoleCoefficients();\n        r.p = precision;\n        r.z0 = new Complex(center.x, center.y);\n        r.a = new Array(precision);\n        for (let k = 0; k < precision; k++) {\n            r.a[k] = r.compute(k, points);\n        }\n        return r;\n    }\n    static constructorPMM(center, m1, m2) {\n        const r = new MultipoleCoefficients();\n        Assert.assert(m1.p == m2.p);\n        r.p = m1.p;\n        r.z0 = new Complex(center.x, center.y);\n        const m2a = m2.shift(r.z0);\n        const m1a = m1.shift(r.z0);\n        r.a = new Array(r.p);\n        for (let i = 0; i < r.p; i++) {\n            r.a[i] = add(m1a[i], m2a[i]);\n        }\n        return r;\n    }\n    static factorial(n) {\n        let f = 1;\n        for (let i = 2; i <= n; i++) {\n            f *= i;\n        }\n        return f;\n    }\n    static binomial(n, k) {\n        return MultipoleCoefficients.factorial(n) / (MultipoleCoefficients.factorial(k) * MultipoleCoefficients.factorial(n - k));\n    }\n    sum(l, z0_minus_z1) {\n        let s = Complex.constructorN(0);\n        for (let k = 1; k <= l; k++) {\n            const bi = Complex.constructorN(MultipoleCoefficients.binomial(l - 1, k - 1));\n            s = add(s, prod(this.a[k], prod(Complex.Pow(z0_minus_z1, l - k), bi)));\n        }\n        return s;\n    }\n    shift(z1) {\n        const b = new Array(this.p);\n        const a0 = (b[0] = this.a[0]);\n        const z0_minus_z1 = min(this.z0, z1);\n        for (let l = 1; l < this.p; l++) {\n            /*  Complex lz = new Complex(l);\n                b[l] = -a0 * Complex.Pow(z0_minus_z1, l) / lz + sum(l, z0_minus_z1);\n            */\n            const lz = Complex.constructorN(l);\n            b[l] = add(prod(neg(a0), div(Complex.Pow(z0_minus_z1, l), lz)), this.sum(l, z0_minus_z1));\n        }\n        return b;\n    }\n    //  Compute kth multipole coefficient of a set of points ps around a centre z0\n    compute(k, ps) {\n        const m = ps.length;\n        let ak = Complex.constructorN(0);\n        if (k == 0) {\n            ak.re = m;\n        }\n        else {\n            for (let i = 0; i < m; i++) {\n                const q = ps[i];\n                const pc = new Complex(q.x, q.y);\n                ak = min(ak, Complex.Pow(min(pc, this.z0), k));\n            }\n            ak.divideBy(k);\n        }\n        return ak;\n    }\n    //  Compute approximate force at point v due to potential energy moments\n    ApproximateForce(v) {\n        const z = new Complex(v.x, v.y);\n        const z_minus_z0 = min(z, this.z0);\n        let fz = div(this.a[0], z_minus_z0);\n        let z_minus_z0_to_k_plus_1 = z_minus_z0;\n        let k = 0;\n        while (true) {\n            fz = min(fz, div(prodN(this.a[k], k), z_minus_z0_to_k_plus_1));\n            k++;\n            if (k == this.p) {\n                break;\n            }\n            z_minus_z0_to_k_plus_1 = prod(z_minus_z0_to_k_plus_1, z_minus_z0);\n        }\n        return new Point(fz.re, -fz.im);\n    }\n    //  Force on point u due to point v.\n    //  If v and u at the same position it returns a small vector to separate them\n    static Force(u, v) {\n        const duv = v.sub(u);\n        const l = duv.lengthSquared;\n        if (l < 0.1) {\n            if (l != 0) {\n                return duv.div(0.1);\n            }\n            return new Point(1, 0);\n        }\n        return duv.div(l);\n    }\n}\nclass Complex {\n    constructor(re, im) {\n        this.re = re;\n        this.im = im;\n    }\n    static constructorN(re) {\n        return new Complex(re, 0);\n    }\n    divideBy(r) {\n        this.re /= r;\n        this.im /= r;\n    }\n    static Pow(a, k) {\n        Assert.assert(k >= 0);\n        switch (k) {\n            case 0:\n                return Complex.constructorN(1);\n                break;\n            case 1:\n                return a;\n                break;\n            case 2:\n                return prod(a, a);\n                break;\n            case 3:\n                return prod(a, prod(a, a));\n                break;\n            default:\n                return prod(Complex.Pow(a, k / 2), Complex.Pow(a, k / 2 + (k % 2)));\n        }\n    }\n}\nfunction add(a, b) {\n    return new Complex(a.re + b.re, a.im + b.im);\n}\nfunction prod(a, b) {\n    return new Complex(a.re * b.re - a.im * b.im, a.re * b.im + b.re * a.im);\n}\nfunction prodN(a, b) {\n    return new Complex(a.re * b, a.im * b);\n}\nfunction min(a, b) {\n    return new Complex(a.re - b.re, a.im - b.im);\n}\nfunction neg(a) {\n    return new Complex(-a.re, -a.im);\n}\nfunction div(a, b) {\n    const d = b.re * b.re + b.im * b.im;\n    if (d == 0) {\n        return Complex.constructorN(0.0);\n    }\n    const c1 = a.re * b.re + a.im * b.im;\n    const c2 = a.im * b.re - a.re * b.im;\n    return new Complex(c1 / d, c2 / d);\n}\n//# sourceMappingURL=multipoleCoefficients.js.map","import { Rectangle } from '../../math/geometry';\nimport { GeomEdge, GeomGraph, GeomNode, Graph } from '../..';\nimport { pumpTheBoxToTheGraph } from '../core/geomGraph';\nexport class GeomConnectedComponent {\n    constructor(topNodes) {\n        this.topNodes = topNodes;\n    }\n    get nodesBreadthFirst() {\n        return this.nodesBreadthFirst_();\n    }\n    *nodesBreadthFirst_() {\n        for (const n of this.topNodes) {\n            yield GeomNode.getGeom(n);\n            if (n instanceof Graph) {\n                for (const nn of n.nodesBreadthFirst) {\n                    yield GeomNode.getGeom(nn);\n                }\n            }\n        }\n    }\n    get Clusters() {\n        return this.clusters();\n    }\n    *clusters() {\n        for (const n of this.topNodes)\n            if (n instanceof Graph)\n                yield GeomGraph.getGeom(n);\n    }\n    get subgraphsDepthFirst() {\n        return this.subgraphsDepthFirst_();\n    }\n    *subgraphsDepthFirst_() {\n        for (const n of this.topNodes) {\n            if (n instanceof Graph) {\n                const gn = GeomGraph.getGeom(n);\n                yield* gn.subgraphsDepthFirst;\n                yield gn;\n            }\n        }\n    }\n    get shallowEdges() {\n        return this.edges_();\n    }\n    *edges_() {\n        for (const n of this.topNodes) {\n            for (const e of n.outEdges)\n                yield GeomEdge.getGeom(e);\n            for (const e of n.selfEdges)\n                yield GeomEdge.getGeom(e);\n        }\n    }\n    get shallowNodes() {\n        return this.shallowNodes_();\n    }\n    *shallowNodes_() {\n        for (const n of this.topNodes)\n            yield GeomNode.getGeom(n);\n    }\n    pumpTheBoxToTheGraphWithMargins() {\n        const t = { b: Rectangle.mkEmpty() };\n        pumpTheBoxToTheGraph(this, t);\n        return (this.boundingBox = t.b);\n    }\n    get shallowNodeCount() {\n        return this.topNodes.length;\n    }\n    translate(delta) {\n        if (this.boundingBox)\n            this.boundingBox.center = this.boundingBox.center.add(delta);\n        for (const n of this.topNodes) {\n            const gn = GeomNode.getGeom(n);\n            gn.translate(delta);\n        }\n        // todo :test the edges!\n    }\n}\n//# sourceMappingURL=geomConnectedComponent.js.map","import { Algorithm } from '../../utils/algorithm';\nimport { IPsepCola } from '../incremental/iPsepCola';\nimport { IPsepColaSetting } from '../incremental/iPsepColaSettings';\nimport { MdsGraphLayout } from '../mds/mDSGraphLayout';\nimport { PivotMDS } from '../mds/pivotMDS';\nimport { GeomConnectedComponent } from './geomConnectedComponent';\nimport { LayoutAlgorithmHelpers } from './layoutAlgorithmHelpers';\nimport { GTreeOverlapRemoval } from '../gTreeOverlapRemoval/gTreeOverlapRemoval';\nimport { MdsLayoutSettings } from '../mds/mDSLayoutSettings';\n//  Methods for obtaining an initial layout of a graph using various means.\nexport class InitialLayout extends Algorithm {\n    //  Static layout of graph by gradually adding constraints.\n    //  Uses PivotMds to find initial layout.\n    //  Breaks the graph into connected components (nodes of the same cluster are considered\n    //  connected whether or not there is an edge between them), then lays out each component\n    //  individually.  Finally, a simple packing is applied.\n    //  ratio as close as possible to the PackingAspectRatio property (not currently used).\n    constructor(graph, settings) {\n        super(null);\n        //  Set to true if the graph specified is a single connected component with no clusters\n        this.SingleComponent = false;\n        this.graph = graph;\n        this.settings = IPsepColaSetting.ctorClone(settings);\n        this.settings.ApplyForces = true;\n        this.settings.InterComponentForces = true;\n        this.settings.RungeKuttaIntegration = false;\n        this.settings.RespectEdgePorts = false;\n    }\n    //  The actual layout process\n    run() {\n        if (this.SingleComponent) {\n            this.componentCount = 1;\n            this.LayoutComponent(this.graph);\n        }\n        else {\n            const components = Array.from(this.graph.graph.getClusteredConnectedComponents()).map((topNodes) => new GeomConnectedComponent(topNodes));\n            this.componentCount = components.length;\n            for (const component of components) {\n                this.LayoutComponent(component);\n            }\n            this.graph.boundingBox = MdsGraphLayout.PackGraphs(components, this.settings.commonSettings);\n            // for (let c of this.graph.subgraphs()) {\n            //     let copy = (<GraphConnectedComponents.AlgorithmDataNodeWrap>(c.AlgorithmData));\n            //     let copyCluster = (<Cluster>(copy.node));\n            //     Assert.assert((copyCluster != null));\n            //     c.RectangularBoundary = copyCluster.RectangularBoundary;\n            //     c.RectangularBoundary.GenerateFixedConstraints = c.RectangularBoundary.GenerateFixedConstraintsDefault;\n            //     c.BoundingBox = c.RectangularBoundary.Rect;\n            //     c.RaiseLayoutDoneEvent();\n            // }\n        }\n    }\n    LayoutComponent(component) {\n        if (component.shallowNodeCount > 1) {\n            //  for small graphs (below 100 nodes) do extra iterations\n            this.settings.MaxIterations = LayoutAlgorithmHelpers.NegativeLinearInterpolation(component.shallowNodeCount, 50, 500, 5, 10);\n            this.settings.MinorIterations = LayoutAlgorithmHelpers.NegativeLinearInterpolation(component.shallowNodeCount, 50, 500, 3, 20);\n            if (this.settings.MinConstraintLevel == 0) {\n                //  run PivotMDS with a largish Scale so that the layout comes back oversized.\n                //  subsequent incremental iterations do a better job of untangling when they're pulling it in\n                //  rather than pushing it apart.\n                const mdsSettings = new MdsLayoutSettings();\n                mdsSettings.removeOverlaps = false;\n                mdsSettings.IterationsWithMajorization = 0;\n                const pivotMDS = new PivotMDS(component, null, () => 1, new MdsLayoutSettings());\n                pivotMDS.run();\n            }\n            const fil = new IPsepCola(component, this.settings, this.settings.MinConstraintLevel);\n            //Assert.assert(this.settings.Iterations == 0)\n            for (const level of this.GetConstraintLevels(component)) {\n                if (level > this.settings.MaxConstraintLevel) {\n                    break;\n                }\n                if (level > this.settings.MinConstraintLevel) {\n                    fil.setCurrentConstraintLevel(level);\n                }\n                do {\n                    fil.run();\n                } while (!this.settings.IsDone);\n            }\n            if (this.settings.AvoidOverlaps) {\n                GTreeOverlapRemoval.RemoveOverlaps(Array.from(this.graph.shallowNodes), this.settings.NodeSeparation);\n            }\n        }\n        component.pumpTheBoxToTheGraphWithMargins();\n        //  Pad the graph with margins so the packing will be spaced out.\n        component.uniformMargins = this.settings.NodeSeparation;\n        //  Zero the graph\n        component.translate(component.boundingBox.leftBottom.mul(-1));\n    }\n    /** returns 0, 1 or 2:\n     *   Get the distinct ConstraintLevels that need to be applied to layout.\n      Used by InitialLayout.\n     Will only include ConstraintLevel == 2 if AvoidOverlaps is on and there are fewer than 2000 nodes\n     */\n    GetConstraintLevels(component) {\n        const keys = new Set();\n        keys.add(0);\n        if (this.settings.AvoidOverlaps && component.shallowNodeCount < 2000) {\n            keys.add(2);\n        }\n        return keys;\n    }\n}\n//# sourceMappingURL=initialLayout.js.map","export class LayoutAlgorithmHelpers {\n    //  Linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.\n    //  <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>\n    static LinearInterpolation(value, lowerThreshold, upperThreshold, minResult, maxResult) {\n        if (value < lowerThreshold) {\n            return minResult;\n        }\n        if (value > upperThreshold) {\n            return maxResult;\n        }\n        const fraction = (value - lowerThreshold) / (upperThreshold - lowerThreshold);\n        return minResult + (fraction * (maxResult - minResult));\n    }\n    //  Negatively linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.\n    //  <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>\n    static NegativeLinearInterpolation(value, lowerThreshold, upperThreshold, minResult, maxResult) {\n        if (value < lowerThreshold) {\n            return maxResult;\n        }\n        if (value > upperThreshold) {\n            return minResult;\n        }\n        const fraction = (value - lowerThreshold) / (upperThreshold - lowerThreshold);\n        return minResult + ((1 - fraction) * (maxResult - minResult));\n    }\n}\n//# sourceMappingURL=layoutAlgorithmHelpers.js.map","// balances the layers by moving vertices with\nimport { Algorithm } from '../../utils/algorithm';\nimport { IntPair } from '../../utils/IntPair';\n// balances the layers by moving vertices with\n// the same number of input-output edges to feasible layers with fewer nodes\nexport class Balancing extends Algorithm {\n    static Balance(dag, layering, nodeCount, cancelObj) {\n        const b = new Balancing(dag, layering, nodeCount, cancelObj);\n        b.run();\n    }\n    constructor(dag, layering, nodeCount, cancelToken) {\n        super(cancelToken);\n        this.jumpers = new Set();\n        this.possibleJumperFeasibleIntervals = new Map();\n        this.nodeCount = nodeCount;\n        this.dag = dag;\n        this.layering = layering;\n        this.Init();\n    }\n    run() {\n        while (this.jumpers.size > 0)\n            this.Jump(this.ChooseJumper());\n    }\n    Init() {\n        this.CalculateLayerCounts();\n        this.InitJumpers();\n    }\n    Jump(jumper) {\n        this.jumpers.delete(jumper);\n        const upLow = this.possibleJumperFeasibleIntervals.get(jumper);\n        const ji = this.CalcJumpInfo(upLow.x, upLow.y, jumper);\n        if (ji == null)\n            return;\n        this.layering[jumper] = ji.layerToJumpTo;\n        const jumperCount = this.nodeCount[jumper];\n        this.vertsCounts[ji.jumperLayer] -= jumperCount;\n        this.vertsCounts[ji.layerToJumpTo] += jumperCount;\n        this.UpdateRegionsForPossibleJumpersAndInsertJumpers(ji.jumperLayer, jumper);\n    }\n    IsJumper(v) {\n        return this.possibleJumperFeasibleIntervals.has(v);\n    }\n    // some other jumpers may stop being ones if the jump\n    // was just in to their destination layer, so before the actual\n    // jump we have to recheck if the jump makes sense\n    //\n    UpdateRegionsForPossibleJumpersAndInsertJumpers(jumperLayer, jumper) {\n        const neighborPossibleJumpers = new Set();\n        //update possible jumpers neighbors\n        for (const v of this.dag.pred(jumper))\n            if (this.IsJumper(v)) {\n                this.CalculateRegionAndInsertJumper(v);\n                neighborPossibleJumpers.add(v);\n            }\n        for (const v of this.dag.succ(jumper))\n            if (this.IsJumper(v)) {\n                this.CalculateRegionAndInsertJumper(v);\n                neighborPossibleJumpers.add(v);\n            }\n        const possibleJumpersToUpdate = new Array();\n        for (const kv of this.possibleJumperFeasibleIntervals) {\n            if (!neighborPossibleJumpers.has(kv[0]))\n                if (kv[1].x > jumperLayer && kv[1].y < jumperLayer)\n                    possibleJumpersToUpdate.push(kv[0]);\n        }\n        for (const v of possibleJumpersToUpdate)\n            this.CalculateRegionAndInsertJumper(v);\n    }\n    InitJumpers() {\n        const deltas = new Array(this.dag.nodeCount).fill(0);\n        for (const ie of this.dag.edges) {\n            deltas[ie.source] -= ie.weight;\n            deltas[ie.target] += ie.weight;\n        }\n        this.possibleJumperFeasibleIntervals = new Map();\n        for (let i = 0; i < this.dag.nodeCount; i++)\n            if (deltas[i] === 0)\n                this.CalculateRegionAndInsertJumper(i);\n    }\n    CalculateRegionAndInsertJumper(i) {\n        const ip = new IntPair(this.Up(i), this.Down(i));\n        this.possibleJumperFeasibleIntervals.set(i, ip);\n        this.InsertJumper(ip.x, ip.y, i);\n    }\n    InsertJumper(upLayer, lowLayer, jumper) {\n        const ji = this.CalcJumpInfo(upLayer, lowLayer, jumper);\n        if (ji != null)\n            this.jumpers.add(jumper);\n    }\n    // layerToJumpTo is -1 if there is no jump\n    CalcJumpInfo(upLayer, lowLayer, jumper) {\n        const jumperLayer = this.layering[jumper];\n        let layerToJumpTo = -1;\n        let min = this.vertsCounts[jumperLayer] - 2 * this.nodeCount[jumper];\n        // jump makes sense if some layer has less than min vertices\n        for (let i = upLayer - 1; i > jumperLayer; i--)\n            if (this.vertsCounts[i] < min) {\n                min = this.vertsCounts[i];\n                layerToJumpTo = i;\n            }\n        for (let i = jumperLayer - 1; i > lowLayer; i--)\n            if (this.vertsCounts[i] < min) {\n                min = this.vertsCounts[i];\n                layerToJumpTo = i;\n            }\n        if (layerToJumpTo === -1)\n            return;\n        return { jumperLayer: jumperLayer, layerToJumpTo: layerToJumpTo };\n    }\n    // Up returns the first infeasible layer up from i that i cannot jump to\n    Up(i) {\n        let ret = Number.MAX_SAFE_INTEGER;\n        //minimum of incoming edge sources layeres\n        for (const ie of this.dag.inEdges[i]) {\n            const r = this.layering[ie.source] - ie.separation + 1;\n            if (r < ret)\n                ret = r;\n        }\n        if (ret === Number.MAX_SAFE_INTEGER)\n            ret = this.layering[i] + 1;\n        return ret;\n    }\n    // Returns the first infeasible layer down from i that i cannot jump to\n    Down(i) {\n        let ret = Number.NEGATIVE_INFINITY;\n        for (const ie of this.dag.outEdges[i]) {\n            const r = this.layering[ie.target] + ie.separation - 1;\n            if (r > ret)\n                ret = r;\n        }\n        if (ret === Number.NEGATIVE_INFINITY)\n            ret = this.layering[i] - 1;\n        return ret;\n    }\n    CalculateLayerCounts() {\n        /*Assert.assert(this.layering.length > 0)*/\n        this.vertsCounts = new Array(Math.max(...this.layering) + 1).fill(0);\n        for (const r of this.layering) {\n            this.vertsCounts[r] += this.nodeCount[r];\n        }\n    }\n    ChooseJumper() {\n        //just return the first available\n        for (const jumper of this.jumpers)\n            return jumper;\n        throw new Error('there are no jumpers to choose');\n    }\n}\n//# sourceMappingURL=Balancing.js.map","import { Stack } from 'stack-typescript';\nimport { IntPairMap } from '../../utils/IntPairMap';\nvar VertStatus;\n(function (VertStatus) {\n    VertStatus[VertStatus[\"NotVisited\"] = 0] = \"NotVisited\";\n    VertStatus[VertStatus[\"InStack\"] = 1] = \"InStack\";\n    VertStatus[VertStatus[\"Visited\"] = 2] = \"Visited\";\n})(VertStatus || (VertStatus = {}));\nclass StackStruct {\n    constructor(v, i) {\n        this.v = v;\n        this.i = i;\n    }\n}\nexport class CycleRemoval {\n    static getFeedbackSetWithConstraints(arg0, arg1) {\n        throw new Error('Method not implemented.');\n    }\n    static push(stack, status, v, i) {\n        status[v] = VertStatus.InStack;\n        stack.push(new StackStruct(v, i));\n    }\n    static getFeedbackSet(graph) {\n        const feedbackSet = new IntPairMap();\n        if (graph == null || graph.nodeCount === 0)\n            return [];\n        const status = new Array(graph.nodeCount).fill(VertStatus.NotVisited);\n        for (let vertex = 0; vertex < graph.nodeCount; vertex++) {\n            if (status[vertex] === VertStatus.Visited)\n                continue;\n            /*Assert.assert(status[vertex] !== VertStatus.InStack)*/\n            const stack = new Stack(); //avoiding the recursion\n            let i = 0; // the index in the outEnum\n            CycleRemoval.push(stack, status, vertex, i);\n            while (stack.size > 0) {\n                const s = stack.pop();\n                vertex = s.v;\n                status[vertex] = VertStatus.Visited;\n                i = s.i;\n                let outEnum = graph.outEdges[vertex];\n                for (; i < outEnum.length; i++) {\n                    const e = outEnum[i];\n                    if (e.source === e.target)\n                        continue;\n                    const targetStatus = status[e.target];\n                    if (targetStatus === VertStatus.InStack) {\n                        feedbackSet.set(e.source, e.target, e);\n                    }\n                    else if (targetStatus === VertStatus.NotVisited) {\n                        //have to go deeper\n                        CycleRemoval.push(stack, status, vertex, i + 1);\n                        vertex = e.target;\n                        status[e.target] = VertStatus.Visited;\n                        outEnum = graph.outEdges[vertex];\n                        i = -1;\n                    }\n                }\n            }\n        }\n        return Array.from(feedbackSet.values());\n    }\n}\n//# sourceMappingURL=CycleRemoval.js.map","import { IntPairMap } from '../../utils/IntPairMap';\nimport { IntPair } from '../../utils/IntPair';\nexport class Database {\n    *RegularMultiedges() {\n        for (const [k, v] of this.Multiedges.keyValues())\n            if (k.x !== k.y)\n                yield v;\n    }\n    *AllIntEdges() {\n        for (const l of this.Multiedges.values())\n            for (const e of l)\n                yield e;\n    }\n    addFeedbackSet(feedbackSet) {\n        for (const e of feedbackSet) {\n            const ip = new IntPair(e.source, e.target);\n            const ipr = new IntPair(e.target, e.source);\n            //we shuffle reversed edges into the other multiedge\n            const listToShuffle = this.Multiedges.get(ip.x, ip.y);\n            for (const er of listToShuffle)\n                er.reverse();\n            if (this.Multiedges.has(ipr.x, ipr.y)) {\n                const m = this.Multiedges.get(ipr.x, ipr.y);\n                for (const e of listToShuffle)\n                    m.push(e);\n            }\n            else {\n                this.Multiedges.set(ipr.x, ipr.y, listToShuffle);\n            }\n            this.Multiedges.delete(ip.x, ip.y);\n        }\n    }\n    constructor(n) {\n        this.MultipleMiddles = new Set();\n        this.Multiedges = new IntPairMap();\n    }\n    registerOriginalEdgeInMultiedges(edge) {\n        let o = this.Multiedges.get(edge.source, edge.target);\n        if (o == null) {\n            this.Multiedges.set(edge.source, edge.target, (o = []));\n        }\n        o.push(edge);\n    }\n    *SkeletonEdges() {\n        for (const [k, v] of this.Multiedges.keyValues()) {\n            if (k.x !== k.y)\n                yield v[0];\n        }\n    }\n    GetMultiedge(source, target) {\n        return this.GetMultiedgeI(new IntPair(source, target));\n    }\n    GetMultiedgeI(ip) {\n        if (this.Multiedges.has(ip.x, ip.y))\n            return this.Multiedges.get(ip.x, ip.y);\n        return new Array();\n    }\n}\n//# sourceMappingURL=Database.js.map","// This class is used of the case when there are multiple edges, but there is no need to duplicate layers.\nimport { LayerArrays } from './LayerArrays';\nimport { LayerEdge } from './layerEdge';\nimport { LayerInserter } from './LayerInserter';\nimport { ProperLayeredGraph } from './ProperLayeredGraph';\n// We just insert dummy nodes for edge middles without distorting the order of vertices of the layers.\nexport class EdgePathsInserter {\n    get NLayering() {\n        return this.Nla.y;\n    }\n    static InsertPaths(layeredGraph, la, db, intGraphP) {\n        const li = new EdgePathsInserter(layeredGraph, la, db, intGraphP);\n        li.InsertPaths();\n        return {\n            layeredGraph: li.NLayeredGraph,\n            la: li.Nla,\n        };\n    }\n    constructor(layeredGraph, la, database, intGraphP) {\n        this.virtNodesToIntEdges = new Map();\n        this.la = la;\n        this.database = database;\n        this.layeredGraph = layeredGraph;\n        this.intGraph = intGraphP;\n    }\n    InsertPaths() {\n        /*Assert.assert(layersAreCorrect(this.la))*/\n        this.CreateFullLayeredGraph();\n        this.InitNewLayering();\n        this.MapVirtualNodesToEdges();\n        this.WidenOriginalLayers();\n        /*Assert.assert(layersAreCorrect(this.la))*/\n    }\n    WidenOriginalLayers() {\n        for (let i = 0; i < this.la.Layers.length; i++) {\n            const layer = this.Nla.Layers[i];\n            let offset = 0;\n            for (const v of this.la.Layers[i]) {\n                const e = this.virtNodesToIntEdges.get(v);\n                if (e != null) {\n                    const layerOffsetInTheEdge = this.NLayering[e.source] - this.NLayering[v];\n                    const list = this.database.Multiedges.get(e.source, e.target);\n                    for (const ie of list) {\n                        if (!this.EdgeIsFlat(ie)) {\n                            if (ie !== e) {\n                                const u = ie.LayerEdges[layerOffsetInTheEdge].Source;\n                                layer[offset] = u;\n                                this.Nla.x[u] = offset++;\n                            }\n                            else {\n                                layer[offset] = v;\n                                this.Nla.x[v] = offset++;\n                            }\n                        }\n                    }\n                }\n                else {\n                    layer[offset] = v;\n                    this.Nla.x[v] = offset++;\n                }\n            }\n        }\n    }\n    EdgeIsFlat(ie) {\n        return this.la.y[ie.source] === this.la.y[ie.target];\n    }\n    MapVirtualNodesToEdges() {\n        for (const list of this.database.RegularMultiedges())\n            for (const e of list)\n                if (!this.EdgeIsFlat(e))\n                    //the edge is not flat\n                    for (const le of e.LayerEdges)\n                        if (le.Target !== e.target) {\n                            this.virtNodesToIntEdges.set(le.Target, e);\n                        }\n    }\n    CreateFullLayeredGraph() {\n        let currentVV = this.layeredGraph.NodeCount;\n        for (const [k, list] of this.database.Multiedges.keyValues()) {\n            if (k.x !== k.y) {\n                //not a self edge\n                let first = true;\n                let span = 0;\n                for (const e of list) {\n                    if (first) {\n                        first = false;\n                        span = e.LayerSpan;\n                    }\n                    else {\n                        e.LayerEdges = new Array(span);\n                        if (span === 1)\n                            e.LayerEdges[0] = new LayerEdge(e.source, e.target, e.CrossingWeight);\n                        else {\n                            for (let i = 0; i < span; i++) {\n                                const bVV = { currentVV: currentVV };\n                                const source = EdgePathsInserter.GetSource(bVV, e, i);\n                                currentVV = bVV.currentVV;\n                                const target = EdgePathsInserter.GetTarget(currentVV, e, i, span);\n                                e.LayerEdges[i] = new LayerEdge(source, target, e.CrossingWeight);\n                            }\n                        }\n                    }\n                    LayerInserter.RegisterDontStepOnVertex(this.database, e);\n                }\n            }\n        }\n        this.NLayeredGraph = new ProperLayeredGraph(this.intGraph);\n    }\n    static GetTarget(currentVV, e, i, span) {\n        if (i < span - 1)\n            return currentVV;\n        return e.target;\n    }\n    static GetSource(boxedVV, e, i) {\n        if (i === 0)\n            return e.source;\n        return boxedVV.currentVV++;\n    }\n    InitNewLayering() {\n        this.Nla = new LayerArrays(new Array(this.NLayeredGraph.NodeCount));\n        for (let i = 0; i < this.layeredGraph.NodeCount; i++)\n            this.NLayering[i] = this.la.y[i];\n        for (const [k, list] of this.database.Multiedges.keyValues()) {\n            if (k.x !== k.y && this.la.y[k.x] !== this.la.y[k.y]) {\n                //not a self edge and not a flat edge\n                let layer = 0;\n                let first = true;\n                for (const e of list) {\n                    if (first) {\n                        first = false;\n                        layer = this.la.y[e.source];\n                    }\n                    let cl = layer - 1;\n                    for (const le of e.LayerEdges)\n                        this.NLayering[le.Target] = cl--;\n                }\n            }\n        }\n        // number[][] newLayers = new number[la.Layers.length][];\n        const newLayers = new Array(this.la.Layers.length);\n        //count new layer widths\n        const counts = new Array(newLayers.length).fill(0);\n        for (const l of this.NLayering)\n            counts[l]++;\n        for (let i = 0; i < counts.length; i++)\n            newLayers[i] = new Array(counts[i]);\n        this.Nla = new LayerArrays(this.NLayering);\n        this.Nla.Layers = newLayers;\n    }\n}\n//# sourceMappingURL=EdgePathsInserter.js.map","import { Parallelogram } from '../../math/geometry/parallelogram';\nexport class HierarchyCalculator {\n    static Calculate(nodes, groupSplitThresholdPar = 0) {\n        const calc = new HierarchyCalculator(nodes, groupSplitThresholdPar);\n        return calc.Calculate();\n    }\n    constructor(nodes, groupSplitThresholdPar) {\n        this.groupSplitThreshold = 2;\n        this.initialNodes = nodes;\n        this.groupSplitThreshold = groupSplitThresholdPar;\n    }\n    Calculate() {\n        return this.Calc(this.initialNodes);\n    }\n    Calc(nodes) {\n        if (nodes.length === 0) {\n            return null;\n        }\n        if (nodes.length === 1) {\n            return nodes[0];\n        }\n        // Finding the seeds\n        const b0 = nodes[0].parallelogram;\n        // the first seed\n        let seed0 = 1;\n        let area = Parallelogram.parallelogramOfTwo(b0, nodes[seed0].parallelogram).area;\n        for (let i = 2; i < nodes.length; i++) {\n            const area0 = Parallelogram.parallelogramOfTwo(b0, nodes[i].parallelogram).area;\n            if (area0 > area) {\n                seed0 = i;\n                area = area0;\n            }\n        }\n        // Got the first seed seed0\n        // Now looking for a seed for the second group\n        let seed1;\n        // the compiler forces me to init it\n        // init seed1\n        for (let i = 0; i < nodes.length; i++) {\n            if (i !== seed0) {\n                seed1 = i;\n                break;\n            }\n        }\n        area = Parallelogram.parallelogramOfTwo(nodes[seed0].parallelogram, nodes[seed1].parallelogram).area;\n        // Now try to improve the second seed\n        for (let i = 0; i < nodes.length; i++) {\n            if (i === seed0) {\n                continue;\n            }\n            const area1 = Parallelogram.parallelogramOfTwo(nodes[seed0].parallelogram, nodes[i].parallelogram).area;\n            if (area1 > area) {\n                seed1 = i;\n                area = area1;\n            }\n        }\n        // We have two seeds at hand. Build two groups.\n        const gr0 = new Array();\n        const gr1 = new Array();\n        gr0.push(nodes[seed0]);\n        gr1.push(nodes[seed1]);\n        let box0 = nodes[seed0].parallelogram;\n        let box1 = nodes[seed1].parallelogram;\n        // divide nodes on two groups\n        for (let i = 0; i < nodes.length; i++) {\n            if (i === seed0 || i === seed1) {\n                continue;\n            }\n            const box0_ = Parallelogram.parallelogramOfTwo(box0, nodes[i].parallelogram);\n            const delta0 = box0_.area - box0.area;\n            const box1_ = Parallelogram.parallelogramOfTwo(box1, nodes[i].parallelogram);\n            const delta1 = box1_.area - box1.area;\n            // keep the tree roughly balanced\n            if (gr0.length * this.groupSplitThreshold < gr1.length) {\n                gr0.push(nodes[i]);\n                box0 = box0_;\n            }\n            else if (gr1.length * this.groupSplitThreshold < gr0.length) {\n                gr1.push(nodes[i]);\n                box1 = box1_;\n            }\n            else if (delta0 < delta1) {\n                gr0.push(nodes[i]);\n                box0 = box0_;\n            }\n            else {\n                gr1.push(nodes[i]);\n                box1 = box1_;\n            }\n        }\n        return {\n            parallelogram: Parallelogram.parallelogramOfTwo(box0, box1),\n            node: { children: [this.Calc(gr0), this.Calc(gr1)] },\n            seg: undefined,\n            leafBoxesOffset: undefined,\n        };\n    }\n}\n//# sourceMappingURL=HierarchyCalculator.js.map","import { mkGraphOnEdges } from '../../structs/basicGraphOnEdges';\nimport { IntPair } from '../../utils/IntPair';\nimport { IntPairSet } from '../../utils/IntPairSet';\nimport { CycleRemoval } from './CycleRemoval';\nfunction mktuple(a, b) {\n    return [a, b];\n}\nexport class HorizontalConstraintsForSugiyama {\n    constructor() {\n        this.leftRightConstraints = new Array();\n        this.leftRightNeighbors = new Array();\n        // node is mapped to the block root\n        this.nodeToBlockRoot = new Map();\n        this.upDownVerticalConstraints = new Array();\n        // The right most node to the left of the  block is called a block root. The root does not belong to its block.\n        this.BlockRootToBlock = new Map();\n    }\n    get IsEmpty() {\n        return this.leftRightNeighbors.length === 0 && this.upDownVerticalConstraints.length === 0 && this.leftRightConstraints.length === 0;\n    }\n    AddSameLayerNeighbors(neighbors) {\n        for (let i = 0; i < neighbors.length - 1; i++)\n            this.AddSameLayerNeighborsPair(neighbors[i], neighbors[i + 1]);\n    }\n    AddSameLayerNeighborsPair(leftNode, rightNode) {\n        this.leftRightNeighbors.push([leftNode, rightNode]);\n    }\n    NodeToBlockRootSoft(i) {\n        const blockRoot = this.nodeToBlockRoot.get(i);\n        return blockRoot ? blockRoot : i;\n    }\n    CreateMappingOfNeibBlocks() {\n        const graph = this.BasicGraphFromLeftRightIntNeibs();\n        for (let root = 0; root < graph.nodeCount; root++)\n            if (graph.inEdges[root].length === 0 && !this.nodeToBlockRoot.has(root)) {\n                const block = new Array();\n                let current = root;\n                for (let outEdges = graph.outEdges[current]; outEdges.length > 0; outEdges = graph.outEdges[current]) {\n                    current = outEdges[0].y;\n                    block.push(current);\n                    this.nodeToBlockRoot.set(current, root);\n                }\n                if (block.length > 0)\n                    this.BlockRootToBlock.set(root, block);\n            }\n    }\n    BasicGraphFromLeftRightIntNeibs() {\n        return mkGraphOnEdges(Array.from(this.LeftRightIntNeibs.values()).map((p) => new IntPair(p.x, p.y)));\n    }\n    NodeIndex(node) {\n        const index = this.nodeIdToIndex.get(node.id);\n        return index ? index : -1;\n    }\n    PrepareForOrdering(nodeToIndexParameter, yLayers) {\n        this.nodeIdToIndex = nodeToIndexParameter;\n        this.MapNodesToToIntegers(yLayers);\n        this.CreateMappingOfNeibBlocks();\n        this.LiftLeftRightRelationsToNeibBlocks();\n        //MakeUpDownRelationsMonotone(yLayers);\n    }\n    //see UpDownMonotone.png\n    //       void MakeUpDownRelationsMonotone(number[] yLayers) {\n    //           BasicGraph<IntPair> upDownGraph = new BasicGraph<IntPair>(from c in this.verticalInts select new IntPair(c.First,c.Second));\n    //           Array<Tuple<number, number>> upDownToRemove = new Array<Tuple<number, number>>();\n    //           foreach (Array<number> componentNodes of ConnectedComponentCalculator<IntPair>.GetComponents(GraphOfLeftRightRelations())) {\n    //               ResolveConflictsUboveComponent(upDownGraph, componentNodes, upDownToRemove, yLayers);\n    //               ResolveConflictsBelowComponent(upDownGraph, componentNodes, upDownToRemove, yLayers);\n    //           }\n    //\n    //           foreach (var v of upDownToRemove)\n    //               this.verticalInts.Remove(v);\n    //       }\n    //makes left-right relations to be between neighb blocks and removes cycles in these relations\n    LiftLeftRightRelationsToNeibBlocks() {\n        this.LeftRighInts = IntPairSet.mk(this.leftRightConstraints\n            .map((p) => mktuple(this.NodeIndex(p[0]), this.NodeIndex(p[1])))\n            .filter((p) => p[0] !== -1 && p[1] !== -1)\n            .map((ip) => new IntPair(this.NodeToBlockRootSoft(ip[0]), this.NodeToBlockRootSoft(ip[1])))\n            .filter((ip) => ip.x !== ip.x));\n        const feedbackSet = CycleRemoval.getFeedbackSet(mkGraphOnEdges(Array.from(this.LeftRighInts.values())));\n        for (const ip of feedbackSet)\n            this.LeftRighInts.remove(new IntPair(ip.source, ip.target));\n    }\n    MapNodesToToIntegers(yLayers) {\n        this.LeftRightIntNeibs = IntPairSet.mk(Array.from(this.leftRightNeighbors.values())\n            .map((p) => [this.NodeIndex(p[0]), this.NodeIndex(p[1])])\n            .filter((t) => t[0] !== -1 && t[1] !== -1)\n            .map((t) => new IntPair(t[0], t[1])));\n        //as we follow yLayers there will not be cycles in verticalIntConstraints\n        this.VerticalInts = IntPairSet.mk(this.upDownVerticalConstraints\n            .map((p) => [this.NodeIndex(p[0]), this.NodeIndex(p[1])])\n            .filter((p) => p[0] !== -1 && p[1] !== -1 && yLayers[p[0]] > yLayers[p[1]])\n            .map((p) => new IntPair(p[0], p[1])));\n    }\n}\n//# sourceMappingURL=HorizontalConstraintsForSugiyama.js.map","import { copyTo } from '../../utils/copy';\nexport class LayerArrays {\n    constructor(verticesToLayers) {\n        this.initialize(verticesToLayers);\n    }\n    initialize(verticesToLayers) {\n        this.y = verticesToLayers;\n        this.verticesToX = null;\n        this.layers = null;\n    }\n    // Returns the same arrays but with no empty layers.\n    DropEmptyLayers() {\n        const drop = new Array(this.Layers.length);\n        let dropVal = 0;\n        for (let i = 0; i < this.Layers.length; i++) {\n            drop[i] = dropVal;\n            if (this.Layers[i].length === 0)\n                dropVal++;\n        }\n        if (dropVal === 0)\n            return this;\n        //we do have empty layers\n        const ny = new Array(this.y.length);\n        for (let i = 0; i < ny.length; i++)\n            ny[i] = this.y[i] - drop[this.y[i]];\n        //copy the layers itself\n        const nls = new Array(this.layers.length - dropVal);\n        for (let i = 0; i < this.layers.length; i++) {\n            if (this.layers[i].length > 0)\n                nls[i - drop[i]] = Array.from(this.layers[i]);\n        }\n        const la = new LayerArrays(ny);\n        la.layers = nls;\n        return la;\n    }\n    updateLayers(ulayers) {\n        if (this.layers == null)\n            this.InitLayers();\n        for (let i = 0; i < this.layers.length; i++)\n            copyTo(ulayers[i], this.layers[i]);\n        this.UpdateXFromLayers();\n    }\n    UpdateXFromLayers() {\n        if (this.layers == null)\n            this.InitLayers();\n        if (this.verticesToX == null)\n            this.verticesToX = new Array(this.y.length);\n        for (const layer of this.layers) {\n            let i = 0;\n            for (const v of layer)\n                this.verticesToX[v] = i++;\n        }\n    }\n    // gives the order of the vertices in the y-layer\n    // <value></value>\n    get x() {\n        if (this.verticesToX != null)\n            return this.verticesToX;\n        this.verticesToX = new Array(this.y.length);\n        this.UpdateXFromLayers();\n        return this.verticesToX;\n    }\n    // returns the layer hierarchy where the order of the layers is reversed\n    ReversedClone() {\n        const rv = new Array(this.y.length);\n        const lastLayer = this.Layers.length - 1; //call Layers to ensure that the layers are calculated\n        for (let i = 0; i < this.y.length; i++)\n            rv[i] = lastLayer - this.y[i];\n        return new LayerArrays(rv);\n    }\n    // Layers[i] is the array of vertices of i-th layer\n    get Layers() {\n        if (this.layers != null)\n            return this.layers;\n        this.InitLayers();\n        return this.layers;\n    }\n    set Layers(value) {\n        this.layers = value;\n    }\n    InitLayers() {\n        //find the number of layers\n        let nOfLayers = 0;\n        for (const l of this.y) {\n            if (l + 1 > nOfLayers)\n                nOfLayers = l + 1;\n        }\n        const counts = new Array(nOfLayers).fill(0);\n        //find the number of vertices in the layer\n        for (const l of this.y)\n            counts[l]++;\n        this.layers = new Array(nOfLayers);\n        for (let i = 0; i < nOfLayers; i++) {\n            this.layers[i] = new Array(counts[i]);\n            counts[i] = 0; //we reuse these counts below\n        }\n        for (let i = 0; i < this.y.length; i++) {\n            const l = this.y[i];\n            this.layers[l][counts[l]++] = i;\n        }\n        /*Assert.assert(layersAreCorrect(this))*/\n    }\n}\nexport function layersAreCorrect(layerArrays) {\n    if (layerArrays.layers == null)\n        return true;\n    for (const layer of layerArrays.layers) {\n        if (layerHasDublicatesOrUndef(layer)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function layerHasDublicatesOrUndef(layer) {\n    const s = new Set();\n    for (const v of layer) {\n        if (v == null) {\n            return true;\n        }\n        if (s.has(v))\n            return true;\n        s.add(v);\n    }\n    return false;\n}\n//# sourceMappingURL=LayerArrays.js.map","import { EdgePathsInserter } from './EdgePathsInserter';\nimport { LayerArrays } from './LayerArrays';\nimport { LayerEdge } from './layerEdge';\nimport { ProperLayeredGraph } from './ProperLayeredGraph';\n// Preparing the graph for x-coordinate calculation by inserting dummy nodes into the layers\nexport class LayerInserter {\n    constructor(layeredGraph, la, database, intGraphP) {\n        this.la = la;\n        this.database = database;\n        this.layeredGraph = layeredGraph;\n        this.intGraph = intGraphP;\n    }\n    // the entry point of the class\n    static InsertLayers(layeredGraph, la, db, intGraphP) {\n        const li = new LayerInserter(layeredGraph, la, db, intGraphP);\n        li.InsertLayers();\n        return {\n            layeredGraph: li.nLayeredGraph,\n            la: li.Nla.DropEmptyLayers(),\n        };\n    }\n    // new Y-layering\n    get NLayering() {\n        return this.Nla.y;\n    }\n    // does the main work\n    InsertLayers() {\n        this.EditOldLayering();\n        this.CreateFullLayeredGraph();\n        this.InitNewLayering();\n        this.MapVirtualNodesToEdges();\n        this.FillUnsortedNewOddLayers();\n        this.WidenOriginalLayers();\n        this.SortNewOddLayers();\n    }\n    // virtual nodes inside of an edge should be of the form i,i+1, ....\n    EditOldLayering() {\n        let curVNode = this.intGraph.nodeCount;\n        for (const list of this.database.RegularMultiedges()) {\n            let span = 0;\n            const e = list[0];\n            span = e.LayerSpan * 2;\n            if (span > 0) {\n                //ignoring flat edges\n                for (const le of e.LayerEdges) {\n                    if (le.Target !== e.target) {\n                        curVNode++;\n                        this.UpdateOldLayer(curVNode++, le.Target);\n                    }\n                }\n                curVNode += (span - 1) * (list.length - 1) + 1;\n            }\n        }\n    }\n    UpdateOldLayer(replacingNode, prevNode) {\n        const x = this.la.x[prevNode];\n        const y = this.la.y[prevNode];\n        const layer = this.la.Layers[y];\n        layer[x] = replacingNode;\n        //  this.la.x[replacingNode] = x;\n        // this.la.y[replacingNode] = y;\n    }\n    // Original layers are represented by even layers of the new layering.\n    // Here we add new virtices of such layers and\n    // set new x-offsets of original and dummy vertices of these layers.\n    WidenOriginalLayers() {\n        for (let i = 0; i < this.la.Layers.length; i++) {\n            const layer = this.Nla.Layers[i * 2];\n            let offset = 0;\n            for (const v of this.la.Layers[i]) {\n                const e = this.virtNodesToIntEdges[v];\n                if (e != null) {\n                    const layerOffsetInTheEdge = this.NLayering[e.source] - this.NLayering[v];\n                    const list = this.database.Multiedges.get(e.source, e.target);\n                    for (const ie of list) {\n                        if (ie !== e) {\n                            const u = ie.LayerEdges[layerOffsetInTheEdge].Source;\n                            layer[offset] = u;\n                            this.Nla.x[u] = offset++;\n                        }\n                        else {\n                            layer[offset] = v;\n                            this.Nla.x[v] = offset++;\n                        }\n                    }\n                }\n                else {\n                    layer[offset] = v;\n                    this.Nla.x[v] = offset++;\n                }\n            }\n        }\n    }\n    // filling new layers not corresponding to the original layers\n    FillUnsortedNewOddLayers() {\n        const c = new Array(this.Nla.Layers.length).fill(0);\n        for (let i = this.intGraph.nodeCount; i < this.nLayeredGraph.NodeCount; i++) {\n            const layer = this.NLayering[i];\n            if (layer % 2 === 1) {\n                //new layers have odd numbers\n                this.Nla.Layers[layer][c[layer]++] = i;\n            }\n        }\n    }\n    // create the mapping from the vertices to edges to which they belong\n    MapVirtualNodesToEdges() {\n        this.virtNodesToIntEdges = new Array(this.NLayering.length);\n        for (const e of this.database.AllIntEdges())\n            if (e.source !== e.target && e.LayerEdges != null)\n                for (const le of e.LayerEdges)\n                    if (le.Target !== e.target)\n                        this.virtNodesToIntEdges[le.Target] = e;\n    }\n    // Creating buckets for multi edges and allocating the graph.\n    CreateFullLayeredGraph() {\n        this.totalNodes = this.intGraph.nodeCount;\n        for (const list of this.database.RegularMultiedges()) {\n            let span = 0;\n            let first = true;\n            for (const e of list) {\n                if (first) {\n                    first = false;\n                    span = e.LayerSpan * 2;\n                }\n                if (span > 0) {\n                    e.LayerEdges = new Array(span);\n                    for (let i = 0; i < span; i++) {\n                        const bT = { currentVV: this.totalNodes };\n                        const source = EdgePathsInserter.GetSource(bT, e, i);\n                        this.totalNodes = bT.currentVV;\n                        const target = EdgePathsInserter.GetTarget(this.totalNodes, e, i, span);\n                        e.LayerEdges[i] = new LayerEdge(source, target, e.CrossingWeight);\n                    }\n                    LayerInserter.RegisterDontStepOnVertex(this.database, e);\n                }\n            }\n        }\n        this.nLayeredGraph = new ProperLayeredGraph(this.intGraph);\n    }\n    // Sort new odd layers by the sum of x-coordinatates of predecessors and the successors of\n    // dummy nodes.\n    SortNewOddLayers() {\n        for (let i = 1; i < this.Nla.Layers.length; i += 2) {\n            const sd = new Map();\n            const layer = this.Nla.Layers[i];\n            for (const v of layer) {\n                //find unique predecessor and successor\n                let predecessor = -1;\n                for (const ie of this.nLayeredGraph.InEdges(v))\n                    predecessor = ie.Source;\n                let successor = -1;\n                for (const ie of this.nLayeredGraph.OutEdges(v))\n                    successor = ie.Target;\n                const x = this.Nla.x[predecessor] + this.Nla.x[successor];\n                if (sd.has(x)) {\n                    const o = sd.get(x);\n                    if (typeof o === 'number') {\n                        const l = new Array();\n                        l.push(o);\n                        l.push(v);\n                        sd.set(x, l);\n                    }\n                    else {\n                        const l = o;\n                        l.push(v);\n                    }\n                }\n                else {\n                    sd.set(x, v);\n                }\n            }\n            // Create a sorted array from the Map\n            const sortedEntries = Array.from(sd.entries()).sort((a, b) => a[0] - b[0]);\n            //fill the layer according to this order\n            let c = 0;\n            for (const v of sortedEntries.map(e => e[1]))\n                if (typeof v === 'number') {\n                    layer[c++] = v;\n                }\n                else {\n                    for (const k of v) {\n                        layer[c++] = k;\n                    }\n                }\n            //update X now\n            for (let m = 0; m < layer.length; m++)\n                this.Nla.x[layer[m]] = m;\n        }\n    }\n    // Allocating new layering and filling its y-layers\n    InitNewLayering() {\n        this.Nla = new LayerArrays(new Array(this.totalNodes));\n        for (let i = 0; i < this.layeredGraph.NodeCount; i++)\n            this.NLayering[i] = this.la.y[i] * 2;\n        for (const [ip, v] of this.database.Multiedges.keyValues()) {\n            if (ip.x !== ip.y && this.la.y[ip.x] !== this.la.y[ip.y]) {\n                //not a self edge and not a flat edge\n                const top = this.la.y[ip.x] * 2;\n                for (const e of v) {\n                    let layer = top - 1;\n                    //Assert.assert(e.LayerEdges !== undefined && e.LayerEdges != null)\n                    for (const le of e.LayerEdges)\n                        if (le.Target !== e.target)\n                            this.NLayering[le.Target] = layer--;\n                }\n            }\n        }\n        const newLayers = new Array(2 * this.la.Layers.length - 1);\n        //count new layer widths\n        const counts = new Array(newLayers.length).fill(0);\n        for (const l of this.NLayering)\n            counts[l]++;\n        for (let i = 0; i < counts.length; i++)\n            newLayers[i] = new Array(counts[i]);\n        this.Nla = new LayerArrays(this.NLayering);\n        this.Nla.Layers = newLayers;\n    }\n    // mark the vertex as one representing a label\n    // or a middle of a multi edge\n    static RegisterDontStepOnVertex(db, parent) {\n        if (db.Multiedges.get(parent.source, parent.target).length > 1) {\n            const e = parent.LayerEdges[Math.floor(parent.LayerEdges.length / 2)];\n            db.MultipleMiddles.add(e.Source);\n        }\n    }\n}\n//# sourceMappingURL=LayerInserter.js.map","export var NodeKind;\n(function (NodeKind) {\n    NodeKind[NodeKind[\"Top\"] = 0] = \"Top\";\n    NodeKind[NodeKind[\"Internal\"] = 1] = \"Internal\";\n    NodeKind[NodeKind[\"Bottom\"] = 2] = \"Bottom\";\n})(NodeKind || (NodeKind = {}));\n//# sourceMappingURL=NodeKind.js.map","import { BasicGraph } from '../../structs/BasicGraph';\n// a class representing a graph where every edge goes down only one layer\nexport class ProperLayeredGraph {\n    constructor(intGraph) {\n        this.Initialize(intGraph);\n    }\n    Initialize(intGraph) {\n        this.BaseGraph = intGraph;\n        this.totalNumberOfNodes = intGraph.nodeCount;\n        for (const edge of this.BaseGraph.edges) {\n            if (edge.LayerEdges == null)\n                continue;\n            for (const layerEdge of edge.LayerEdges) {\n                const m = Math.max(layerEdge.Source, layerEdge.Target) + 1;\n                if (m > this.totalNumberOfNodes)\n                    this.totalNumberOfNodes = m;\n            }\n        }\n        this.firstVirtualNode = Number.POSITIVE_INFINITY;\n        for (const e of this.BaseGraph.edges) {\n            if (e.LayerEdges == null) {\n                continue;\n            }\n            for (let i = 1; i < e.LayerEdges.length; i++) {\n                const le = e.LayerEdges[i];\n                // Assert.assert(le.Source !== e.source)\n                this.firstVirtualNode = Math.min(this.firstVirtualNode, le.Source);\n            }\n        }\n        if (this.firstVirtualNode === Number.POSITIVE_INFINITY) {\n            this.firstVirtualNode = this.BaseGraph.nodeCount;\n            this.totalNumberOfNodes = this.BaseGraph.nodeCount;\n        }\n        this.virtualNodesToInEdges = new Array(this.totalNumberOfNodes - this.firstVirtualNode);\n        this.virtualNodesToOutEdges = new Array(this.totalNumberOfNodes - this.firstVirtualNode);\n        for (const e of this.BaseGraph.edges)\n            if (e.LayerSpan > 0)\n                for (const le of e.LayerEdges) {\n                    if (le.Target !== e.target)\n                        this.virtualNodesToInEdges[le.Target - this.firstVirtualNode] = le;\n                    if (le.Source !== e.source)\n                        this.virtualNodesToOutEdges[le.Source - this.firstVirtualNode] = le;\n                }\n    }\n    // enumerates over the graph edges\n    *edges_() {\n        for (const ie of this.BaseGraph.edges) {\n            if (ie.LayerSpan > 0)\n                for (const le of ie.LayerEdges)\n                    yield le;\n        }\n    }\n    get Edges() {\n        return this.edges_();\n    }\n    // enumerates over edges of a node\n    *InEdges(node) {\n        if (node < this.BaseGraph.nodeCount)\n            //original node\n            for (const e of this.BaseGraph.inEdges[node]) {\n                if (e.source !== e.target && e.LayerEdges != null)\n                    yield ProperLayeredGraph.LastEdge(e);\n            }\n        else if (node >= this.firstVirtualNode)\n            yield this.InEdgeOfVirtualNode(node);\n    }\n    static LastEdge(e) {\n        return e.LayerEdges[e.LayerEdges.length - 1];\n    }\n    InEdgeOfVirtualNode(node) {\n        return this.virtualNodesToInEdges[node - this.firstVirtualNode];\n    }\n    // enumerates over the node outcoming edges\n    *OutEdges(node) {\n        if (node < this.BaseGraph.nodeCount)\n            //original node\n            for (const e of this.BaseGraph.outEdges[node]) {\n                if (e.source !== e.target && e.LayerEdges != null)\n                    yield ProperLayeredGraph.FirstEdge(e);\n            }\n        else if (node >= this.firstVirtualNode)\n            yield this.OutEdgeOfVirtualNode(node);\n    }\n    OutDegreeIsMoreThanOne(node) {\n        if (node < this.BaseGraph.nodeCount)\n            //original node\n            return this.BaseGraph.outEdges[node].length > 1;\n        else\n            return false;\n    }\n    InDegreeIsMoreThanOne(node) {\n        if (node < this.BaseGraph.nodeCount)\n            //original node\n            return this.BaseGraph.inEdges[node].length > 1;\n        else\n            return false;\n    }\n    OutEdgeOfVirtualNode(node) {\n        return this.virtualNodesToOutEdges[node - this.firstVirtualNode];\n    }\n    static FirstEdge(e) {\n        return e.LayerEdges[0];\n    }\n    // returns the number of incoming edges for an edge\n    InEdgesCount(node) {\n        return this.RealInEdgesCount(node);\n    }\n    RealInEdgesCount(node) {\n        return node < this.BaseGraph.nodeCount ? this.BaseGraph.inEdges[node].filter((e) => e.LayerEdges != null).length : 1;\n    }\n    // returns the number of outcoming edges for an edge\n    OutEdgesCount(node) {\n        return this.RealOutEdgesCount(node);\n    }\n    RealOutEdgesCount(node) {\n        return node < this.BaseGraph.nodeCount ? this.BaseGraph.outEdges[node].filter((l) => l.LayerEdges != null).length : 1;\n    }\n    // returns the node count\n    get NodeCount() {\n        return this.totalNumberOfNodes;\n    }\n    IsRealNode(node) {\n        return node < this.BaseGraph.nodeCount;\n    }\n    IsVirtualNode(node) {\n        return !this.IsRealNode(node);\n    }\n    ReversedClone() {\n        const reversedEdges = this.CreateReversedEdges();\n        return new ProperLayeredGraph(new BasicGraph(reversedEdges, this.BaseGraph.nodeCount));\n    }\n    CreateReversedEdges() {\n        const ret = new Array();\n        for (const e of this.BaseGraph.edges)\n            if (!e.isSelfEdge())\n                ret.push(e.reversedClone());\n        return ret;\n    }\n    *Succ(node) {\n        for (const le of this.OutEdges(node))\n            yield le.Target;\n    }\n    *Pred(node) {\n        for (const le of this.InEdges(node))\n            yield le.Source;\n    }\n}\n//# sourceMappingURL=ProperLayeredGraph.js.map","import { CornerSite } from '../../math/geometry/cornerSite';\nimport { CurveFactory } from '../../math/geometry/curveFactory';\nimport { DebugCurve } from '../../math/geometry/debugCurve';\n//import{ {DebugCurve} from '../../math/geometry/}DebugCurve'\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { Point } from '../../math/geometry/point';\nimport { closeDistEps } from '../../utils/compare';\nimport { randomInt } from '../../utils/random';\nimport { NodeKind } from './NodeKind';\nexport class RefinerBetweenTwoLayers {\n    constructor(topNodeP, bottomNodeP, topSiteP, layerArraysP, layeredGraphP, originalGraphP, anchorsP, layerSeparation) {\n        this.topNode = topNodeP;\n        this.bottomNode = bottomNodeP;\n        this.topSite = topSiteP;\n        this.bottomSite = topSiteP.next;\n        this.currentTopSite = topSiteP;\n        this.currentBottomSite = topSiteP.next;\n        this.layerArrays = layerArraysP;\n        this.layeredGraph = layeredGraphP;\n        this.originalGraph = originalGraphP;\n        this.anchors = anchorsP;\n        this.layerSeparation = layerSeparation;\n    }\n    static Refine(topNodeP, bottomNode, topSiteP, anchors, layerArraysP, layeredGraph, originalGraph, layerSeparation) {\n        const refiner = new RefinerBetweenTwoLayers(topNodeP, bottomNode, topSiteP, layerArraysP, layeredGraph, originalGraph, anchors, layerSeparation);\n        refiner.Refine();\n    }\n    Refine() {\n        this.Init();\n        while (this.InsertSites()) { }\n    }\n    FixCorner(start, corner, end) {\n        if (start.equal(corner)) {\n            return corner;\n        }\n        const a = Point.ClosestPointAtLineSegment(corner, start, end);\n        let offsetInTheChannel = corner.sub(a);\n        const y = Math.abs(offsetInTheChannel.y);\n        const sep = this.layerSeparation / 2;\n        if (y > sep) {\n            offsetInTheChannel = offsetInTheChannel.mul(sep / (y * 2));\n        }\n        return offsetInTheChannel.add(corner);\n    }\n    InsertSites() {\n        if (randomInt(2) === 0) {\n            return this.CalculateNewTopSite() || this.CalculateNewBottomSite();\n        }\n        else {\n            return this.CalculateNewBottomSite() || this.CalculateNewTopSite();\n        }\n    }\n    // circimvating from the side\n    CalculateNewBottomSite() {\n        const mainSeg = this.currentBottomSite.point.sub(this.currentTopSite.point);\n        let cotan = RefinerBetweenTwoLayers.absCotan(mainSeg);\n        let vOfNewSite;\n        let someBottomCorners = false;\n        for (const p of this.bottomCorners()) {\n            const cornerCotan = RefinerBetweenTwoLayers.absCotan(p.sub(this.currentBottomSite.point));\n            if (cornerCotan < cotan) {\n                cotan = cornerCotan;\n                vOfNewSite = p;\n                someBottomCorners = true;\n            }\n        }\n        if (!someBottomCorners) {\n            return false;\n        }\n        if (!closeDistEps(cotan, RefinerBetweenTwoLayers.absCotan(mainSeg))) {\n            this.currentBottomSite = CornerSite.mkSiteSPS(this.currentTopSite, this.FixCorner(this.currentTopSite.point, vOfNewSite, this.currentBottomSite.point), this.currentBottomSite);\n            // consider a different FixCorner\n            return true;\n        }\n        return false;\n        // no progress\n    }\n    static absCotan(mainSeg) {\n        return Math.abs(mainSeg.x / mainSeg.y);\n    }\n    CalculateNewTopSite() {\n        const mainSeg = this.currentBottomSite.point.sub(this.currentTopSite.point);\n        let cotan = RefinerBetweenTwoLayers.absCotan(mainSeg);\n        let vOfNewSite;\n        let someTopCorners = false;\n        for (const p of this.topCorners()) {\n            const cornerCotan = RefinerBetweenTwoLayers.absCotan(p.sub(this.currentTopSite.point));\n            if (cornerCotan < cotan) {\n                cotan = cornerCotan;\n                vOfNewSite = p;\n                someTopCorners = true;\n            }\n        }\n        if (!someTopCorners) {\n            return false;\n        }\n        if (!closeDistEps(cotan, RefinerBetweenTwoLayers.absCotan(mainSeg))) {\n            this.currentTopSite = CornerSite.mkSiteSPS(this.currentTopSite, this.FixCorner(this.currentTopSite.point, vOfNewSite, this.currentBottomSite.point), this.currentBottomSite);\n            // consider a different FixCorner\n            return true;\n        }\n        return false;\n        // no progress\n    }\n    // private CornerSite AvoidBottomLayer() {\n    //    Point corner;\n    //    if (StickingCornerFromTheBottomLayer(out corner)) {\n    //        corner = FixCorner(this.currentTopSite.v, corner, this.currentBottomSite.v);\n    //        return new CornerSite(this.currentTopSite, corner, this.currentBottomSite);\n    //    } else\n    //        return null;\n    // }\n    // private CornerSite AvoidTopLayer() {\n    //    Point corner;\n    //    if (StickingCornerFromTheTopLayer(out corner)) {\n    //        corner = FixCorner(this.currentTopSite.v, corner, this.currentBottomSite.v);\n    //        return new CornerSite(this.currentTopSite, corner, this.currentBottomSite);\n    //    } else\n    //        return null;\n    // }\n    // private bool StickingCornerFromTheTopLayer(out Point corner) {\n    //    corner = this.currentBottomSite.v;\n    //    foreach (Point l of this.topCorners()) {\n    //        Point p = l;\n    //        if (this.counterClockwise(ref currentTopSite.v, ref p, ref corner))\n    //            corner = p;\n    //    }\n    //    return corner !== this.currentBottomSite.v;\n    // }\n    // private bool StickingCornerFromTheBottomLayer(out Point corner) {\n    //    corner = this.currentTopSite.v;\n    //    foreach (Point l of this.bottomCorners()) {\n    //        Point p = l;\n    //        if (this.counterClockwise(ref currentBottomSite.v, ref p, ref corner))\n    //            corner = p;\n    //    }\n    //    return corner !== this.currentTopSite.v;\n    // }\n    Init() {\n        if (this.IsTopToTheLeftOfBottom()) {\n            this.topCorners = () => this.CornersToTheRightOfTop();\n            this.bottomCorners = () => this.CornersToTheLeftOfBottom();\n        }\n        else {\n            this.topCorners = () => this.CornersToTheLeftOfTop();\n            this.bottomCorners = () => this.CornersToTheRightOfBottom();\n        }\n    }\n    IsTopToTheLeftOfBottom() {\n        return this.topSite.point.x < this.topSite.next.point.x;\n    }\n    *NodeCorners(node) {\n        for (const p of this.anchors[node].polygonalBoundary.polylinePoints()) {\n            yield p.point;\n        }\n    }\n    *CornersToTheLeftOfBottom() {\n        const bottomPosition = this.layerArrays.x[this.bottomNode];\n        const leftMost = this.currentTopSite.point.x;\n        const rightMost = this.currentBottomSite.point.x;\n        for (const node of this.LeftFromTheNode(this.NodeLayer(this.bottomNode), bottomPosition, NodeKind.Bottom, leftMost, rightMost)) {\n            for (const p of this.NodeCorners(node)) {\n                if (p.y > this.currentBottomSite.point.y && RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p)) {\n                    yield p;\n                }\n            }\n        }\n    }\n    *CornersToTheLeftOfTop() {\n        const topPosition = this.layerArrays.x[this.topNode];\n        const leftMost = this.currentBottomSite.point.x;\n        const rightMost = this.currentTopSite.point.x;\n        for (const node of this.LeftFromTheNode(this.NodeLayer(this.topNode), topPosition, NodeKind.Top, leftMost, rightMost)) {\n            for (const p of this.NodeCorners(node)) {\n                if (p.y < this.currentTopSite.point.y && RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p)) {\n                    yield p;\n                }\n            }\n        }\n    }\n    *CornersToTheRightOfBottom() {\n        const bottomPosition = this.layerArrays.x[this.bottomNode];\n        const leftMost = this.currentBottomSite.point.x;\n        const rightMost = this.currentTopSite.point.x;\n        for (const node of this.RightFromTheNode(this.NodeLayer(this.bottomNode), bottomPosition, NodeKind.Bottom, leftMost, rightMost)) {\n            for (const p of this.NodeCorners(node)) {\n                if (p.y > this.currentBottomSite.point.y && RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p)) {\n                    yield p;\n                }\n            }\n        }\n    }\n    *CornersToTheRightOfTop() {\n        const topPosition = this.layerArrays.x[this.topNode];\n        const leftMost = this.currentTopSite.point.x;\n        const rightMost = this.currentBottomSite.point.x;\n        for (const node of this.RightFromTheNode(this.NodeLayer(this.topNode), topPosition, NodeKind.Top, leftMost, rightMost)) {\n            for (const p of this.NodeCorners(node)) {\n                if (p.y < this.currentTopSite.point.y && RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p)) {\n                    yield p;\n                }\n            }\n        }\n    }\n    static PossibleCorner(leftMost, rightMost, p) {\n        return p.x > leftMost && p.x < rightMost;\n    }\n    NodeLayer(j) {\n        return this.layerArrays.Layers[this.layerArrays.y[j]];\n    }\n    IsLabel(u) {\n        return this.anchors[u].hasLabel;\n    }\n    NodeUCanBeCrossedByNodeV(u, v) {\n        if (this.IsLabel(u) || this.IsLabel(v)) {\n            return false;\n        }\n        if (this.IsVirtualVertex(u) && this.IsVirtualVertex(v) && this.AdjacentEdgesIntersect(u, v)) {\n            return true;\n        }\n        return false;\n    }\n    AdjacentEdgesIntersect(u, v) {\n        return this.Intersect(this.IncomingEdge(u), this.IncomingEdge(v)) || this.Intersect(this.OutcomingEdge(u), this.OutcomingEdge(v));\n    }\n    Intersect(e, m) {\n        return (this.layerArrays.x[e.Source] - this.layerArrays.x[m.Source]) * (this.layerArrays.x[e.Target] - this.layerArrays.x[m.Target]) < 0;\n    }\n    IncomingEdge(u) {\n        for (const le of this.layeredGraph.InEdges(u)) {\n            return le;\n        }\n        throw new Error();\n    }\n    // here u is a virtual vertex\n    OutcomingEdge(u) {\n        for (const le of this.layeredGraph.OutEdges(u)) {\n            return le;\n        }\n        throw new Error();\n    }\n    IsVirtualVertex(v) {\n        return v >= this.originalGraph.shallowNodeCount;\n    }\n    *RightFromTheNode(layer, vPosition, nodeKind, leftMostX, rightMostX) {\n        let b = 0;\n        let t = 0;\n        if (nodeKind === NodeKind.Bottom) {\n            b = Number.MAX_VALUE;\n        }\n        // we don't have bottom boundaries here since they will be cut off\n        if (nodeKind === NodeKind.Top) {\n            t = Number.MAX_VALUE;\n        }\n        // we don't have top boundaries here since they will be cut off\n        const v = layer[vPosition];\n        for (let i = vPosition + 1; i < layer.length; i++) {\n            const u = layer[i];\n            if (this.NodeUCanBeCrossedByNodeV(u, v)) {\n                continue;\n            }\n            const anchor = this.anchors[u];\n            if (anchor.left >= rightMostX) {\n                break;\n            }\n            if (anchor.right > leftMostX) {\n                if (anchor.topAnchor > t + GeomConstants.distanceEpsilon) {\n                    t = anchor.topAnchor;\n                    yield u;\n                }\n                else if (anchor.bottomAnchor > b + GeomConstants.distanceEpsilon) {\n                    b = anchor.bottomAnchor;\n                    yield u;\n                }\n            }\n        }\n    }\n    *LeftFromTheNode(layer, vPosition, nodeKind, leftMostX, rightMostX) {\n        let b = 0;\n        let t = 0;\n        if (nodeKind === NodeKind.Bottom) {\n            b = Number.MAX_VALUE;\n        }\n        // we don't have bottom boundaries here since they will be cut off\n        if (nodeKind === NodeKind.Top) {\n            t = Number.MAX_VALUE;\n        }\n        // we don't have top boundaries here since they will be cut off\n        const v = layer[vPosition];\n        for (let i = vPosition - 1; i > -1; i--) {\n            const u = layer[i];\n            if (this.NodeUCanBeCrossedByNodeV(u, v)) {\n                continue;\n            }\n            const anchor = this.anchors[u];\n            if (anchor.right <= leftMostX) {\n                break;\n            }\n            if (anchor.left < rightMostX) {\n                if (anchor.topAnchor > t + GeomConstants.distanceEpsilon) {\n                    t = anchor.topAnchor;\n                    yield u;\n                }\n                else if (anchor.bottomAnchor > b + GeomConstants.distanceEpsilon) {\n                    b = anchor.bottomAnchor;\n                    yield u;\n                }\n            }\n        }\n    }\n}\nexport function getAnchorDebugCurve(a) {\n    return DebugCurve.mkDebugCurveTWCI(100, 1, 'black', a.polygonalBoundary);\n}\nfunction getCornerDebugCurve(p, color) {\n    return DebugCurve.mkDebugCurveTWCI(200, 2, color, CurveFactory.mkCircle(10, p));\n}\n//# sourceMappingURL=RefinerBetweenTwoLayers.js.map","// Defines the anchors for a node; anchors can be not symmetrical in general\n//\n//          |TopAnchor\n//Left anchor|\n// ======Origin==================RightAnchor\n//          |\n//          |\n//          |BottomAnchor\nimport { Point, TriangleOrientation } from './../../math/geometry/point';\nimport { Polyline } from './../../math/geometry/polyline';\nimport { Curve } from './../../math/geometry/curve';\nimport { GeomConstants } from './../../math/geometry/geomConstants';\nexport class Anchor {\n    // ToString\n    toString() {\n        return 'la:ra ' + this.la + ' ' + this.ra + ' ta:ba ' + this.ta + ' ' + this.ba + ' x:y ' + this.x_ + ' ' + this.y_;\n    }\n    // distance for the center of the node to its left boundary\n    get leftAnchor() {\n        return this.la;\n    }\n    set leftAnchor(value) {\n        //the absence of this check allows a situation when an edge crosses its label or\n        // a label which does not belong to the edge\n        //      if(value<-Curve.DistEps)\n        //      throw new Exception(\"assigning negative value to a anchor\");\n        this.la = Math.max(value, 0);\n    }\n    // distance from the center of the node to its right boundary\n    get rightAnchor() {\n        return this.ra;\n    }\n    set rightAnchor(value) {\n        //  if(value<-Curve.DistEps)\n        //  throw new Exception(\"assigning negative value to a anchor: \"+value );\n        this.ra = Math.max(value, 0);\n    }\n    // distance from the center of the node to its top boundary\n    get topAnchor() {\n        return this.ta;\n    }\n    set topAnchor(value) {\n        //if(value<-Curve.DistEps)\n        //throw new Exception(\"assigning negative value to a anchor\");\n        this.ta = Math.max(value, 0);\n    }\n    get bottomAnchor() {\n        return this.ba;\n    }\n    set bottomAnchor(value) {\n        //if(value<-Curve.DistEps)\n        //throw new Error();//\"assigning negative value to a anchor\");\n        this.ba = Math.max(value, 0);\n    }\n    // Left boundary of the node\n    get left() {\n        return this.x_ - this.la;\n    }\n    // right boundary of the node\n    get right() {\n        return this.x_ + this.ra;\n    }\n    // top boundary of the node\n    get top() {\n        return this.y_ + this.ta;\n    }\n    set top(value) {\n        this.y_ += value - this.ta;\n    }\n    // bottom of the node\n    get bottom() {\n        return this.y_ - this.ba;\n    }\n    set bottom(value) {\n        this.y_ += value - this.ba;\n    }\n    get leftTop() {\n        return new Point(this.left, this.top);\n    }\n    get leftBottom() {\n        return new Point(this.left, this.bottom);\n    }\n    // this.right bottom of the node\n    get rightBottom() {\n        return new Point(this.right, this.bottom);\n    }\n    get node() {\n        return this.node_;\n    }\n    set node(value) {\n        this.node_ = value;\n        this.polygonalBoundary_ = null;\n    }\n    // Right top of the node\n    get rightTop() {\n        return new Point(this.right, this.top);\n    }\n    constructor(labelCornersPreserveCoefficient) {\n        this.padding = 0;\n        this.alreadySitsOnASpline = false;\n        // An anchor for an edge label with the label to the left of the spline has its height equal to the one of the label\n        // Its rightAnchor is a reserved space for the spline and the leftAnchor is equal to the label width.\n        this.labelIsToTheLeftOfTheSpline = false;\n        // An anchor for an edge label with the label to the right of the spline has its height equal to the one of the label\n        // Its leftAnchor is a reserved space for the spline and the rightAnchor is equal to the label width.\n        this.labelIsToTheRightOfTheSpline = false;\n        /*Assert.assert(\n          0 <= labelCornersPreserveCoefficient &&\n            labelCornersPreserveCoefficient <= 1,\n        )*/\n        this.labelCornersPreserveCoefficient = labelCornersPreserveCoefficient;\n    }\n    // constructor\n    static mkAnchor(leftAnchor, rightAnchor, topAnchor, bottomAnchor, node, labelCornersPreserveCoefficient) {\n        const a = new Anchor(labelCornersPreserveCoefficient);\n        a.la = leftAnchor;\n        a.ra = rightAnchor;\n        a.ta = topAnchor;\n        a.ba = bottomAnchor;\n        a.node = node;\n        return a;\n    }\n    // the x position\n    get x() {\n        return this.x_;\n    }\n    set x(value) {\n        this.polygonalBoundary_ = null;\n        this.x_ = value;\n    }\n    get y() {\n        return this.y_;\n    }\n    set y(value) {\n        this.polygonalBoundary_ = null;\n        this.y_ = value;\n    }\n    // Center of the node\n    get origin() {\n        return new Point(this.x, this.y);\n    }\n    get width() {\n        return this.la + this.ra;\n    }\n    get height() {\n        return this.ta + this.ba;\n    }\n    // set to true if the anchor has been introduced for a label\n    get hasLabel() {\n        return this.labelIsToTheLeftOfTheSpline || this.labelIsToTheLeftOfTheSpline;\n    }\n    get LabelWidth() {\n        if (this.labelIsToTheLeftOfTheSpline)\n            return this.leftAnchor;\n        if (this.labelIsToTheRightOfTheSpline)\n            return this.rightAnchor;\n        throw new Error();\n    }\n    // the polygon representing the boundary of a node\n    get polygonalBoundary() {\n        if (this.polygonalBoundary_ != null)\n            return this.polygonalBoundary_;\n        return (this.polygonalBoundary_ = Anchor.pad(this.creatPolygonalBoundaryWithoutPadding(), this.padding));\n    }\n    static pad(curve, padding) {\n        if (padding === 0)\n            return curve;\n        if (Anchor.curveIsConvex(curve)) {\n            return Anchor.padConvexCurve(curve, padding);\n        }\n        else\n            return Anchor.padConvexCurve(curve.boundingBox.perimeter(), padding);\n    }\n    static padCorner(poly, p0, p1, p2, padding) {\n        const cornerInfo = Anchor.getPaddedCorner(p0, p1, p2, padding);\n        poly.addPoint(cornerInfo.a);\n        if (cornerInfo.numberOfPoints === 2)\n            poly.addPoint(cornerInfo.b);\n    }\n    static padConvexCurve(poly, padding) {\n        const ret = new Polyline();\n        Anchor.padCorner(ret, poly.endPoint.prev, poly.endPoint, poly.startPoint, padding);\n        Anchor.padCorner(ret, poly.endPoint, poly.startPoint, poly.startPoint.next, padding);\n        for (let pp = poly.startPoint; pp.next.next != null; pp = pp.next)\n            Anchor.padCorner(ret, pp, pp.next, pp.next.next, padding);\n        ret.closed = true;\n        return ret;\n    }\n    static getPaddedCorner(first, second, third, padding) {\n        const u = first.point;\n        const v = second.point;\n        const w = third.point;\n        const ccw = Point.getTriangleOrientation(u, v, w) === TriangleOrientation.Counterclockwise;\n        const uv = v.sub(u);\n        //uvPerp has to look outside of the curve\n        const uvPerp = uv.rotate((ccw ? -Math.PI : Math.PI) / 2).normalize();\n        //l is bisector of the corner (u,v,w) pointing out of the corner - outside of the polyline\n        const l = uv.normalize().add(v.sub(w).normalize());\n        if (l.length < GeomConstants.intersectionEpsilon) {\n            return {\n                a: v.add(uvPerp.mul(padding)),\n                b: null,\n                numberOfPoints: 1,\n            };\n        }\n        const d = l.normalize().mul(padding);\n        const dp = d.rotate(Math.PI / 2);\n        //look for a in the form d+x*dp + v\n        //we need to have:  padding = (d+x*dp)*uvPerp\n        const xp = (padding - d.dot(uvPerp)) / dp.dot(uvPerp);\n        return {\n            a: d.add(dp.mul(xp)).add(v),\n            b: d.sub(dp.mul(xp)).add(v),\n            numberOfPoints: 2, //number of points to add\n        };\n    }\n    static *orientations(poly) {\n        yield Point.getTriangleOrientation(poly.endPoint.point, poly.startPoint.point, poly.startPoint.next.point);\n        yield Point.getTriangleOrientation(poly.endPoint.prev.point, poly.endPoint.point, poly.startPoint.point);\n        let pp = poly.startPoint;\n        while (pp.next.next != null) {\n            yield Point.getTriangleOrientation(pp.point, pp.next.point, pp.next.next.point);\n            pp = pp.next;\n        }\n    }\n    static curveIsConvex(poly) {\n        let orientation = TriangleOrientation.Collinear;\n        for (const or of Anchor.orientations(poly)) {\n            if (or === TriangleOrientation.Collinear)\n                continue;\n            if (orientation === TriangleOrientation.Collinear)\n                orientation = or;\n            else if (or !== orientation)\n                return false;\n        }\n        return true;\n    }\n    //private static number TurnAfterSeg(Curve curve, int i) {\n    //   return Point.SignedDoubledTriangleArea(curve.segs[i].start, curve.segs[i].End, curve.segs[(i + 1) / curve.segs.Count].End);\n    //}\n    creatPolygonalBoundaryWithoutPadding() {\n        if (this.hasLabel)\n            return this.labelIsToTheLeftOfTheSpline ? this.polygonOnLeftLabel() : this.polygonOnRightLabel();\n        else if (this.nodeBoundary == null)\n            return this.standardRectBoundary();\n        else\n            return Curve.polylineAroundClosedCurve(this.nodeBoundary);\n    }\n    get nodeBoundary() {\n        return this.node == null ? null : this.node.boundaryCurve;\n    }\n    standardRectBoundary() {\n        const poly = new Polyline();\n        poly.addPoint(this.leftTop);\n        poly.addPoint(this.rightTop);\n        poly.addPoint(this.rightBottom);\n        poly.addPoint(this.leftBottom);\n        poly.closed = true;\n        return poly;\n    }\n    polygonOnLeftLabel() {\n        const t = this.left + (1 - this.labelCornersPreserveCoefficient) * this.LabelWidth;\n        const poly = Polyline.mkClosedFromPoints([\n            new Point(t, this.top),\n            this.rightTop,\n            this.rightBottom,\n            new Point(t, this.bottom),\n            new Point(this.left, this.y),\n        ]);\n        return poly;\n    }\n    polygonOnRightLabel() {\n        const t = this.right - (1 - this.labelCornersPreserveCoefficient) * this.LabelWidth;\n        const poly = Polyline.mkClosedFromPoints([\n            new Point(t, this.top),\n            new Point(this.right, this.y),\n            new Point(t, this.bottom),\n            this.leftBottom,\n            this.leftTop,\n        ]);\n        return poly;\n    }\n    move(p) {\n        this.x += p.x;\n        this.y += p.y;\n    }\n}\n//# sourceMappingURL=anchor.js.map","export var LayerDirectionEnum;\n(function (LayerDirectionEnum) {\n    LayerDirectionEnum[LayerDirectionEnum[\"TB\"] = 0] = \"TB\";\n    LayerDirectionEnum[LayerDirectionEnum[\"LR\"] = 1] = \"LR\";\n    LayerDirectionEnum[LayerDirectionEnum[\"BT\"] = 2] = \"BT\";\n    LayerDirectionEnum[LayerDirectionEnum[\"RL\"] = 3] = \"RL\";\n    LayerDirectionEnum[LayerDirectionEnum[\"None\"] = 4] = \"None\";\n})(LayerDirectionEnum || (LayerDirectionEnum = {}));\n//# sourceMappingURL=layerDirectionEnum.js.map","import { String } from 'typescript-string-operations';\nexport class LayerEdge {\n    constructor(source, target, crossingWeight, weight = 1) {\n        this.Source = source;\n        this.Target = target;\n        this.CrossingWeight = crossingWeight;\n        this.Weight = weight;\n    }\n    toString() {\n        return String.Format('{0}->{1}', this.Source, this.Target);\n    }\n}\n//# sourceMappingURL=layerEdge.js.map","import { RealNumberSpan } from '../../utils/RealNumberSpan';\nimport { BasicGraph } from '../../structs/BasicGraph';\nimport { Point, TriangleOrientation } from '../../math/geometry/point';\nimport { Algorithm } from '../../utils/algorithm';\nimport { PolyIntEdge } from './polyIntEdge';\nimport { SugiyamaLayoutSettings, SnapToGridByY } from './sugiyamaLayoutSettings';\nimport { CycleRemoval } from './CycleRemoval';\nimport { Database } from './Database';\nimport { LayerArrays } from './LayerArrays';\nimport { GeomEdge } from '../core/geomEdge';\nimport { optimalPackingRunner } from '../core/geomGraph';\nimport { IntPairMap } from '../../utils/IntPairMap';\nimport { IntPairSet } from '../../utils/IntPairSet';\nimport { Balancing } from './Balancing';\nimport { ProperLayeredGraph } from './ProperLayeredGraph';\nimport { LayerEdge } from './layerEdge';\nimport { EdgePathsInserter } from './EdgePathsInserter';\nimport { LayerInserter } from './LayerInserter';\nimport { Ordering } from './ordering/ordering';\nimport { MetroMapOrdering } from './ordering/metroMapOrdering';\nimport { NetworkSimplexForGeneralGraph } from './layering/NetworkSimplexForGeneralGraph';\nimport { Anchor } from './anchor';\nimport { XCoordsWithAlignment } from './xCoordsWithAlignment';\nimport { XLayoutGraph } from './xLayoutGraph';\nimport { Rectangle } from '../../math/geometry/rectangle';\nimport { NetworkSimplex } from './layering/NetworkSimplex';\nimport { Routing } from './routing';\nimport { PlaneTransformation } from '../../math/geometry/planeTransformation';\nimport { EdgeRoutingMode } from '../../routing/EdgeRoutingMode';\nimport { routeEdges, enforceLayoutSettings, layoutGeomGraphDetailed } from '../driver';\nimport { straightLineEdgePatcher } from '../../routing/StraightLineEdges';\nfunction layeredLayoutRunner(geomGraph, cancelToken) {\n    const ll = new LayeredLayout(geomGraph, geomGraph.layoutSettings, cancelToken);\n    ll.run();\n}\n/** Executes the layered layout following the Sugiyama Scheme.\n * Cancel token allows to cancel the layout run(is ignored by now).\n * If \"transformToScreen\" is true then the y-coordinate of the graph will be reversed:\n * and the graph will be positioned in the first quadrand with left-bottom = (0,0)\n */\nexport function layoutGraphWithSugiayma(geomGraph, cancelToken, transformToScreen) {\n    const ss = geomGraph.layoutSettings ? geomGraph.layoutSettings : new SugiyamaLayoutSettings();\n    enforceLayoutSettings(geomGraph, ss);\n    layoutGeomGraphDetailed(geomGraph, cancelToken, layeredLayoutRunner, routeEdges, optimalPackingRunner);\n    if (transformToScreen) {\n        const flip = new PlaneTransformation(1, 0, -geomGraph.boundingBox.left, 0, -1, geomGraph.top);\n        geomGraph.transform(flip);\n    }\n}\nexport class LayeredLayout extends Algorithm {\n    /** return true if the ratio is less than 1/50 or greater than 50 */\n    get extremeAspectRatio() {\n        const bb = this.originalGraph.boundingBox;\n        const ratio = bb.width / bb.height;\n        return ratio < 1 / 50 || ratio > 50;\n    }\n    get verticalConstraints() {\n        return this.sugiyamaSettings.verticalConstraints;\n    }\n    get HorizontalConstraints() {\n        return this.sugiyamaSettings.horizontalConstraints;\n    }\n    constructor(originalGraph, settings, cancelToken) {\n        super(cancelToken);\n        this.LayersAreDoubled = false;\n        if (originalGraph == null)\n            return;\n        this.originalGraph = originalGraph;\n        this.sugiyamaSettings = settings;\n        //enumerate the nodes - maps node indices to strings\n        const nodeArray = Array.from(originalGraph.shallowNodes);\n        this.nodeIdToIndex = new Map();\n        let index = 0;\n        for (const n of nodeArray) {\n            this.nodeIdToIndex.set(n.id, index++);\n        }\n        const intEdges = [];\n        for (const edge of this.originalGraph.shallowEdges) {\n            /*Assert.assert(!(edge.source == null  || edge.target == null ))*/\n            const source = this.nodeIdToIndex.get(edge.source.id);\n            if (source == null)\n                continue;\n            const target = this.nodeIdToIndex.get(edge.target.id);\n            if (target == null)\n                continue;\n            const intEdge = new PolyIntEdge(source, target, edge);\n            intEdges.push(intEdge);\n        }\n        this.IntGraph = new BasicGraph(intEdges, originalGraph.shallowNodeCount);\n        this.IntGraph.nodes = nodeArray;\n        this.database = new Database(nodeArray.length);\n        for (const e of this.IntGraph.edges)\n            this.database.registerOriginalEdgeInMultiedges(e);\n        this.cycleRemoval();\n    }\n    run() {\n        if (this.originalGraph.shallowNodeCount === 0) {\n            this.originalGraph.boundingBox = Rectangle.mkEmpty();\n            return;\n        }\n        preRunTransform(this.originalGraph, this.sugiyamaSettings.transform);\n        this.engineLayerArrays = this.calculateLayers();\n        if (this.sugiyamaSettings.edgeRoutingSettings.EdgeRoutingMode === EdgeRoutingMode.SugiyamaSplines) {\n            this.runPostLayering();\n        }\n        postRunTransform(this.originalGraph, this.sugiyamaSettings.transform);\n    }\n    runPostLayering() {\n        const routingSettings = this.sugiyamaSettings.commonSettings.edgeRoutingSettings;\n        const mode = this.constrainedOrdering != null ? EdgeRoutingMode.Spline : routingSettings.EdgeRoutingMode;\n        if (this.extremeAspectRatio) {\n            straightLineEdgePatcher(this.originalGraph, Array.from(this.originalGraph.deepEdges), this.cancelToken);\n        }\n        else if (mode === EdgeRoutingMode.SugiyamaSplines) {\n            this.calculateEdgeSplines();\n        }\n        else {\n            routeEdges(this.originalGraph, Array.from(this.originalGraph.deepEdges), this.cancelToken);\n        }\n    }\n    SetLabels() {\n        throw new Error('not implementedt');\n        // const edgeLabeller = new EdgeLabelPlacement(originalGraph)\n        // edgeLabeller.run()\n    }\n    cycleRemoval() {\n        const verticalConstraints = this.sugiyamaSettings.verticalConstraints;\n        const feedbackSet = verticalConstraints.isEmpty\n            ? CycleRemoval.getFeedbackSet(this.IntGraph)\n            : verticalConstraints.getFeedbackSetExternal(this.IntGraph, this.nodeIdToIndex);\n        this.database.addFeedbackSet(feedbackSet);\n    }\n    calculateLayers() {\n        this.CreateGluedDagSkeletonForLayering();\n        const layerArrays = this.CalculateLayerArrays();\n        this.UpdateNodePositionData();\n        return layerArrays;\n    }\n    UpdateNodePositionData() {\n        for (let i = 0; i < this.IntGraph.nodeCount && i < this.database.Anchors.length; i++)\n            this.IntGraph.nodes[i].center = this.database.Anchors[i].origin;\n        if (this.sugiyamaSettings.GridSizeByX > 0) {\n            for (let i = 0; i < this.originalGraph.shallowNodeCount; i++) {\n                this.SnapLeftSidesOfTheNodeToGrid(i, this.sugiyamaSettings.GridSizeByX);\n            }\n        }\n    }\n    SnapLeftSidesOfTheNodeToGrid(i, gridSize) {\n        const node = this.IntGraph.nodes[i];\n        const anchor = this.database.Anchors[i];\n        anchor.leftAnchor -= gridSize / 2;\n        anchor.rightAnchor -= gridSize / 2;\n        const left = node.boundingBox.left;\n        const k = Math.floor(left / gridSize);\n        const delta = left - k * gridSize;\n        if (Math.abs(delta) < 0.001) {\n            return;\n        }\n        // we are free to shift at least gridSize horizontally\n        // find the minimal shift\n        if (Math.abs(delta) <= gridSize / 2) {\n            node.center = node.center.add(new Point(-delta, 0));\n            // shifting to the left\n        }\n        else {\n            node.center = node.center.add(new Point(gridSize - delta, 0));\n            // shifting to the right\n        }\n        anchor.x = node.center.x;\n    }\n    GetCurrentHeight() {\n        const span = new RealNumberSpan();\n        for (const anchor of this.NodeAnchors()) {\n            span.AddValue(anchor.top);\n            span.AddValue(anchor.bottom);\n        }\n        return span.length;\n    }\n    *NodeAnchors() {\n        const n = Math.min(this.IntGraph.nodeCount, this.anchors.length);\n        for (let i = 0; i < n; i++)\n            yield this.anchors[i];\n    }\n    GetCurrentWidth() {\n        const span = new RealNumberSpan();\n        for (const anchor of this.NodeAnchors()) {\n            span.AddValue(anchor.left);\n            span.AddValue(anchor.right);\n        }\n        return span.length;\n    }\n    ExtendLayeringToUngluedSameLayerVertices(p) {\n        const vc = this.verticalConstraints;\n        for (let i = 0; i < p.length; i++)\n            p[i] = p[vc.nodeToRepr(i)];\n        return p;\n    }\n    calculateEdgeSplines() {\n        const routing = new Routing(this.sugiyamaSettings, this.originalGraph, this.database, this.engineLayerArrays, this.properLayeredGraph, this.IntGraph);\n        routing.run();\n    }\n    YLayeringAndOrdering(layering) {\n        let yLayers = layering.GetLayers();\n        Balancing.Balance(this.gluedDagSkeletonForLayering, yLayers, this.GetNodeCountsOfGluedDag(), null);\n        yLayers = this.ExtendLayeringToUngluedSameLayerVertices(yLayers);\n        let layerArrays = new LayerArrays(yLayers);\n        /*Assert.assert(layersAreCorrect(layerArrays))*/\n        if (this.HorizontalConstraints == null || this.HorizontalConstraints.IsEmpty) {\n            layerArrays = this.YLayeringAndOrderingWithoutHorizontalConstraints(layerArrays);\n            return layerArrays;\n        }\n        throw new Error('not implemented');\n        // this.constrainedOrdering = new ConstrainedOrdering(\n        //  this.originalGraph,\n        //  this.IntGraph,\n        //  layerArrays.y,\n        //  this.nodeIdToIndex,\n        //  this.database,\n        //  this.sugiyamaSettings,\n        // )\n        // this.constrainedOrdering.Calculate()\n        // this.properLayeredGraph = this.constrainedOrdering.ProperLayeredGraph\n        // // SugiyamaLayoutSettings.ShowDatabase(this.database);\n        // return this.constrainedOrdering.LayerArrays\n    }\n    // Creating a proper layered graph, a graph where each\n    // edge goes only one layer down from the i+1-th layer to the i-th layer.\n    CreateProperLayeredGraph(layering) {\n        const n = layering.length;\n        let nOfVV = 0;\n        for (const e of this.database.SkeletonEdges()) {\n            const span = EdgeSpan(layering, e);\n            // Assert.assert(span >= 0)\n            if (span > 0) {\n                e.LayerEdges = new Array(span);\n            }\n            let pe = 0; //offset in the string\n            if (span > 1) {\n                //we create span-2 dummy nodes and span new edges\n                let d0 = n + nOfVV++;\n                let layerEdge = new LayerEdge(e.source, d0, e.CrossingWeight, e.weight);\n                e.LayerEdges[pe++] = layerEdge;\n                //create span-2 internal edges all from dummy nodes\n                for (let j = 0; j < span - 2; j++) {\n                    d0++;\n                    nOfVV++;\n                    layerEdge = new LayerEdge(d0 - 1, d0, e.CrossingWeight, e.weight);\n                    e.LayerEdges[pe++] = layerEdge;\n                }\n                layerEdge = new LayerEdge(d0, e.target, e.CrossingWeight, e.weight);\n                e.LayerEdges[pe] = layerEdge;\n            }\n            else if (span === 1) {\n                const layerEdge = new LayerEdge(e.source, e.target, e.CrossingWeight, e.weight);\n                e.LayerEdges[pe] = layerEdge;\n            }\n        }\n        const extendedVertexLayering = new Array(this.originalGraph.shallowNodeCount + nOfVV).fill(0);\n        for (const e of this.database.SkeletonEdges())\n            if (e.LayerEdges != null) {\n                let l = layering[e.source];\n                extendedVertexLayering[e.source] = l--;\n                for (const le of e.LayerEdges)\n                    extendedVertexLayering[le.Target] = l--;\n            }\n            else {\n                extendedVertexLayering[e.source] = layering[e.source];\n                extendedVertexLayering[e.target] = layering[e.target];\n            }\n        this.properLayeredGraph = new ProperLayeredGraph(new BasicGraph(Array.from(this.database.SkeletonEdges()), layering.length));\n        this.properLayeredGraph.BaseGraph.nodes = this.IntGraph.nodes;\n        return new LayerArrays(extendedVertexLayering);\n    }\n    YLayeringAndOrderingWithoutHorizontalConstraints(layerArraysIn) {\n        /*Assert.assert(layersAreCorrect(layerArraysIn))*/\n        const layerArrays = this.CreateProperLayeredGraph(layerArraysIn.y);\n        /*Assert.assert(layersAreCorrect(layerArrays))*/\n        Ordering.OrderLayers(this.properLayeredGraph, layerArrays, this.originalGraph.shallowNodeCount, this.sugiyamaSettings, this.cancelToken);\n        MetroMapOrdering.UpdateLayerArrays1(this.properLayeredGraph, layerArrays);\n        /*Assert.assert(layersAreCorrect(layerArrays))*/\n        return layerArrays;\n    }\n    CalculateYLayers() {\n        const layerArrays = this.YLayeringAndOrdering(new NetworkSimplexForGeneralGraph(this.gluedDagSkeletonForLayering, this.cancelToken));\n        /*Assert.assert(layersAreCorrect(layerArrays))*/\n        if (this.constrainedOrdering != null)\n            return layerArrays;\n        return this.InsertLayersIfNeeded(layerArrays);\n    }\n    InsertLayersIfNeeded(layerArrays) {\n        this.InsertVirtualEdgesIfNeeded(layerArrays);\n        const r = this.AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays);\n        if (r.needToInsertLayers) {\n            const t = LayerInserter.InsertLayers(this.properLayeredGraph, layerArrays, this.database, this.IntGraph);\n            this.properLayeredGraph = t.layeredGraph;\n            layerArrays = t.la;\n            this.LayersAreDoubled = true;\n        }\n        else if (r.multipleEdges) {\n            const t = EdgePathsInserter.InsertPaths(this.properLayeredGraph, layerArrays, this.database, this.IntGraph);\n            this.properLayeredGraph = t.layeredGraph;\n            layerArrays = t.la;\n            /*Assert.assert(layersAreCorrect(layerArrays))*/\n        }\n        this.RecreateIntGraphFromDataBase();\n        return layerArrays;\n    }\n    RecreateIntGraphFromDataBase() {\n        let edges = new Array();\n        for (const list of this.database.Multiedges.values())\n            edges = edges.concat(list);\n        this.IntGraph.SetEdges(edges, this.IntGraph.nodeCount);\n    }\n    InsertVirtualEdgesIfNeeded(layerArrays) {\n        if (this.constrainedOrdering != null)\n            //if there are constraints we handle multiedges correctly\n            return;\n        // If there are an even number of multi-edges between two nodes then\n        // add a virtual edge in the multi-edge dict to improve the placement, but only in case when the edge goes down only one layer.\n        for (const [k, v] of this.database.Multiedges.keyValues())\n            if (v.length % 2 === 0 && layerArrays.y[k.x] - 1 === layerArrays.y[k.y]) {\n                const e = new GeomEdge(null);\n                const newVirtualEdge = new PolyIntEdge(k.x, k.y, e);\n                newVirtualEdge.IsVirtualEdge = true;\n                v.splice(v.length / 2, 0, newVirtualEdge);\n                this.IntGraph.addEdge(newVirtualEdge);\n            }\n    }\n    AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays) {\n        let needToInsertLayers = false;\n        let multipleEdges = false;\n        for (const ie of this.IntGraph.edges)\n            if (ie.hasLabel && layerArrays.y[ie.source] !== layerArrays.y[ie.target]) {\n                //if an edge is a flat edge then\n                needToInsertLayers = true;\n                break;\n            }\n        if (needToInsertLayers === false && this.constrainedOrdering == null)\n            //if we have constrains the multiple edges have been already represented in layers\n            for (const [k, v] of this.database.Multiedges.keyValues())\n                if (v.length > 1) {\n                    multipleEdges = true;\n                    if (layerArrays.y[k.x] - layerArrays.y[k.y] === 1) {\n                        //there is a multi edge spanning exactly one layer; unfortunately we need to introduce virtual vertices for\n                        //the edges middle points\n                        needToInsertLayers = true;\n                        break;\n                    }\n                }\n        return {\n            needToInsertLayers: needToInsertLayers,\n            multipleEdges: multipleEdges,\n        };\n    }\n    UseBrandesXCalculations(layerArrays) {\n        return layerArrays.x.length >= this.sugiyamaSettings.BrandesThreshold;\n    }\n    CalculateAnchorsAndYPositions(layerArrays) {\n        this.anchors = CalculateAnchorSizes(this.database, this.properLayeredGraph, this.originalGraph, this.IntGraph, this.sugiyamaSettings);\n        CalcInitialYAnchorLocations(layerArrays, 500, this.originalGraph, this.database, this.IntGraph, this.sugiyamaSettings, this.LayersAreDoubled);\n    }\n    // put some labels to the left of the splines if it makes sense\n    OptimizeEdgeLabelsLocations() {\n        for (let i = 0; i < this.anchors.length; i++) {\n            const a = this.anchors[i];\n            if (a.labelIsToTheRightOfTheSpline) {\n                //by default the label is put to the right of the spline\n                const sp = this.GetSuccessorAndPredecessor(i);\n                if (!TryToPutLabelOutsideOfAngle(a, sp.predecessor, sp.successor)) {\n                    const sumNow = sp.predecessor.origin.sub(a.origin).length + sp.successor.origin.sub(a.origin).length;\n                    const nx = a.right - a.leftAnchor; //new potential anchor center\n                    const xy = new Point(nx, a.y);\n                    const sumWouldBe = sp.predecessor.origin.sub(xy).length + sp.successor.origin.sub(xy).length;\n                    if (sumWouldBe < sumNow)\n                        //we need to swap\n                        PutLabelToTheLeft(a);\n                }\n            }\n        }\n    }\n    GetSuccessorAndPredecessor(i) {\n        let predecessor;\n        for (const ie of this.properLayeredGraph.InEdges(i))\n            predecessor = ie.Source; // there will be only one\n        let successor;\n        for (const ie of this.properLayeredGraph.OutEdges(i))\n            successor = ie.Target; //there will be only one\n        //we compare the sum of length of projections of edges (predecessor,i), (i,successor) to x in cases when the label is to the right and to the left\n        return {\n            predecessor: this.anchors[predecessor],\n            successor: this.anchors[successor],\n        };\n    }\n    CalculateLayerArrays() {\n        const layerArrays = this.CalculateYLayers();\n        if (this.constrainedOrdering == null) {\n            this.CalculateAnchorsAndYPositions(layerArrays);\n            if (this.UseBrandesXCalculations(layerArrays))\n                this.CalculateXPositionsByBrandes(layerArrays);\n            else\n                this.CalculateXLayersByGansnerNorth(layerArrays);\n        }\n        else\n            this.anchors = this.database.Anchors;\n        this.OptimizeEdgeLabelsLocations();\n        this.engineLayerArrays = layerArrays;\n        this.StraightensShortEdges();\n        this.CalculateOriginalGraphBox();\n        // address this.sugiyamaSettings.AspectRatio at the final stage\n        return layerArrays;\n    }\n    StretchToDesiredAspectRatio(aspectRatio, desiredAR) {\n        if (aspectRatio > desiredAR) {\n            this.StretchInYDirection(aspectRatio / desiredAR);\n        }\n        else if (aspectRatio < desiredAR) {\n            this.StretchInXDirection(desiredAR / aspectRatio);\n        }\n    }\n    StretchInYDirection(scaleFactor) {\n        const center = (this.originalGraph.boundingBox.top + this.originalGraph.boundingBox.bottom) / 2;\n        for (const a of this.database.Anchors) {\n            a.bottomAnchor = a.bottomAnchor * scaleFactor;\n            a.topAnchor = a.topAnchor * scaleFactor;\n            a.y = center + scaleFactor * (a.y - center);\n        }\n        const h = this.originalGraph.height * scaleFactor;\n        this.originalGraph.boundingBox = new Rectangle({\n            left: this.originalGraph.boundingBox.left,\n            top: center + h / 2,\n            right: this.originalGraph.boundingBox.right,\n            bottom: center - h / 2,\n        });\n    }\n    StretchInXDirection(scaleFactor) {\n        const center = (this.originalGraph.boundingBox.left + this.originalGraph.boundingBox.right) / 2;\n        for (const a of this.database.Anchors) {\n            a.leftAnchor = a.leftAnchor * scaleFactor;\n            a.rightAnchor = a.rightAnchor * scaleFactor;\n            a.x = center + scaleFactor * (a.x - center);\n        }\n        const w = this.originalGraph.width * scaleFactor;\n        this.originalGraph.boundingBox = new Rectangle({\n            left: center - w / 2,\n            top: this.originalGraph.boundingBox.top,\n            right: center + w / 2,\n            bottom: this.originalGraph.boundingBox.bottom,\n        });\n    }\n    CalculateOriginalGraphBox() {\n        if (this.anchors.length === 0)\n            return;\n        const box = new Rectangle({\n            left: this.anchors[0].left,\n            top: this.anchors[0].top,\n            right: this.anchors[0].right,\n            bottom: this.anchors[0].bottom,\n        });\n        for (let i = 1; i < this.anchors.length; i++) {\n            const a = this.anchors[i];\n            box.add(a.leftTop);\n            box.add(a.rightBottom);\n        }\n        if (this.originalGraph.labelSize) {\n            this.originalGraph.addLabelToGraphBB(box);\n        }\n        box.padEverywhere(this.originalGraph.margins);\n        this.originalGraph.boundingBox = box;\n    }\n    StraightensShortEdges() {\n        // it seems this heuristic is not needed for small graphs\n        if (this.anchors.length < 20)\n            return;\n        // eslint-disable-next-line no-empty\n        for (; this.StraightenEdgePaths();) { }\n    }\n    StraightenEdgePaths() {\n        let ret = false;\n        for (const e of this.database.AllIntEdges())\n            if (e.LayerSpan === 2)\n                ret = this.ShiftVertexWithNeighbors(e.LayerEdges[0].Source, e.LayerEdges[0].Target, e.LayerEdges[1].Target) || ret;\n        return ret;\n        //foreach (LayerEdge[][] edgeStrings of this.dataBase.RefinedEdges.Values)\n        //   if (edgeStrings[0].length === 2)\n        //       foreach (LayerEdge[] edgePath of edgeStrings)\n        //           ret = ShiftVertexWithNeighbors(edgePath[0].Source, edgePath[0].Target, edgePath[1].Target) || ret;\n        //return ret;\n    }\n    ShiftVertexWithNeighbors(u, i, v) {\n        const upper = this.database.Anchors[u];\n        const lower = this.database.Anchors[v];\n        const iAnchor = this.database.Anchors[i];\n        // calculate the ideal x position for i\n        // (x- upper.x)/(iAnchor.y-upper.y)=(lower.x-upper.x)/(lower.y-upper.y)\n        const x = (iAnchor.y - upper.y) * ((lower.x - upper.x) / (lower.y - upper.y)) + upper.x;\n        const eps = 0.0001;\n        if (x > iAnchor.x + eps) {\n            return this.TryShiftToTheRight(x, i);\n        }\n        if (x < iAnchor.x - eps) {\n            return this.TryShiftToTheLeft(x, i);\n        }\n        return false;\n    }\n    TryShiftToTheLeft(x, v) {\n        const layer = this.engineLayerArrays.Layers[this.engineLayerArrays.y[v]];\n        const vPosition = this.engineLayerArrays.x[v];\n        if (vPosition > 0) {\n            const uAnchor = this.database.Anchors[layer[vPosition - 1]];\n            const allowedX = Math.max(uAnchor.right + (this.sugiyamaSettings.NodeSeparation + this.database.Anchors[v].leftAnchor), x);\n            if (allowedX < this.database.Anchors[v].x - 1) {\n                this.database.Anchors[v].x = allowedX;\n                return true;\n            }\n            return false;\n        }\n        this.database.Anchors[v].x = x;\n        return true;\n    }\n    TryShiftToTheRight(x, v) {\n        const layer = this.engineLayerArrays.Layers[this.engineLayerArrays.y[v]];\n        const vPosition = this.engineLayerArrays.x[v];\n        if (vPosition < layer.length - 1) {\n            const uAnchor = this.database.Anchors[layer[vPosition + 1]];\n            const allowedX = Math.min(uAnchor.left - (this.sugiyamaSettings.NodeSeparation - this.database.Anchors[v].rightAnchor), x);\n            if (allowedX > this.database.Anchors[v].x + 1) {\n                this.database.Anchors[v].x = allowedX;\n                return true;\n            }\n            return false;\n        }\n        this.database.Anchors[v].x = x;\n        return true;\n    }\n    CalculateXLayersByGansnerNorth(layerArrays) {\n        this.xLayoutGraph = this.CreateXLayoutGraph(layerArrays);\n        this.CalculateXLayersByGansnerNorthOnProperLayeredGraph();\n    }\n    CalculateXLayersByGansnerNorthOnProperLayeredGraph() {\n        const xLayers = new NetworkSimplex(this.xLayoutGraph, null).GetLayers();\n        //TestYXLayers(layerArrays, xLayers);//this will not be called in the release version\n        for (let i = 0; i < this.database.Anchors.length; i++)\n            this.anchors[i].x = xLayers[i];\n    }\n    // // A quote from Gansner93.\n    // // The method involves constructing an auxiliary graph as illustrated in figure 4-2.\n    // // This transformation is the graphical analogue of the algebraic\n    // // transformation mentioned above for removing the absolute values\n    // // from the optimization problem. The nodes of the auxiliary graph G^ are the nodes of\n    // // the original graph G plus, for every edge e in G, there is a new node ne.\n    // // There are two kinds of edges in G^. One edge class encodes the\n    // // cost of the original edges. Every edge e = (u,v) in G is replaced by two edges (ne ,u)\n    // // and (ne, v) with d = 0 and w = w(e)W(e). The other class of edges separates nodes in the same layer.\n    // // If v is the left neighbor of w, then G^ has an edge f = e(v,w) with d( f ) = r(v,w) and\n    // // w( f ) = 0. This edge forces the nodes to be sufficiently\n    // // separated but does not affect the cost of the layout.\n    CreateXLayoutGraph(layerArrays) {\n        let nOfVerts = this.properLayeredGraph.NodeCount;\n        // create edges of XLayoutGraph\n        const edges = new Array();\n        for (const e of this.properLayeredGraph.Edges) {\n            const n1 = new PolyIntEdge(nOfVerts, e.Source, null);\n            const n2 = new PolyIntEdge(nOfVerts, e.Target, null);\n            n2.weight = e.Weight;\n            n1.weight = e.Weight;\n            n1.separation = 0;\n            // these edge have 0 separation\n            n2.separation = 0;\n            nOfVerts++;\n            edges.push(n1);\n            edges.push(n2);\n        }\n        for (const layer of layerArrays.Layers) {\n            for (let i = layer.length - 1; i > 0; i--) {\n                const source = layer[i];\n                const target = layer[i - 1];\n                const ie = new PolyIntEdge(source, target, null);\n                const sourceAnchor = this.database.Anchors[source];\n                const targetAnchor = this.database.Anchors[target];\n                const sep = sourceAnchor.leftAnchor + (targetAnchor.rightAnchor + this.sugiyamaSettings.NodeSeparation);\n                ie.separation = Math.ceil(sep + 0.5);\n                edges.push(ie);\n            }\n        }\n        const ret = new XLayoutGraph(this.IntGraph, this.properLayeredGraph, layerArrays, edges, nOfVerts);\n        ret.SetEdgeWeights();\n        return ret;\n    }\n    CalculateXPositionsByBrandes(layerArrays) {\n        XCoordsWithAlignment.CalculateXCoordinates(layerArrays, this.properLayeredGraph, this.originalGraph.shallowNodeCount, this.database.Anchors, this.sugiyamaSettings.NodeSeparation);\n    }\n    GluedDagSkeletonEdges() {\n        const ret = new IntPairMap();\n        for (const [k, v] of this.database.Multiedges.keyValues()) {\n            if (k.isDiagonal())\n                continue;\n            const e = this.verticalConstraints.gluedIntEdge(v[0]);\n            if (e.source !== e.target)\n                ret.set(e.source, e.target, e);\n        }\n        const gluedUpDownConstraints = Array.from(this.verticalConstraints.gluedUpDownIntConstraints.values()).map((p) => CreateUpDownConstrainedIntEdge(p, null));\n        for (const e of gluedUpDownConstraints)\n            ret.set(e.source, e.target, e);\n        return Array.from(ret.values());\n    }\n    static CalcAnchorsForOriginalNode(i, intGraph, anchors, database, settings) {\n        const t = {\n            leftAnchor: 0,\n            rightAnchor: 0,\n            topAnchor: 0,\n            bottomAnchor: 0,\n        };\n        //that's what we would have without the label and multiedges\n        if (intGraph.nodes != null) {\n            const node = intGraph.nodes[i];\n            ExtendStandardAnchors(t, node, settings);\n        }\n        RightAnchorMultiSelfEdges(i, t, database, settings);\n        const hw = settings.MinNodeWidth / 2;\n        if (t.leftAnchor < hw)\n            t.leftAnchor = hw;\n        if (t.rightAnchor < hw)\n            t.rightAnchor = hw;\n        const hh = settings.MinNodeHeight / 2;\n        if (t.topAnchor < hh)\n            t.topAnchor = hh;\n        if (t.bottomAnchor < hh)\n            t.bottomAnchor = hh;\n        anchors[i] = Anchor.mkAnchor(t.leftAnchor, t.rightAnchor, t.topAnchor, t.bottomAnchor, intGraph.nodes[i], settings.LabelCornersPreserveCoefficient);\n        anchors[i].padding = intGraph.nodes[i].padding;\n    }\n    CreateGluedDagSkeletonForLayering() {\n        this.gluedDagSkeletonForLayering = new BasicGraph(this.GluedDagSkeletonEdges(), this.originalGraph.shallowNodeCount);\n        this.SetGluedEdgesWeights();\n    }\n    SetGluedEdgesWeights() {\n        const gluedPairsToGluedEdge = new IntPairMap();\n        for (const ie of this.gluedDagSkeletonForLayering.edges)\n            gluedPairsToGluedEdge.set(ie.source, ie.target, ie);\n        for (const [k, v] of this.database.Multiedges.keyValues())\n            if (k.x !== k.y) {\n                const gluedPair = this.verticalConstraints.gluedIntPair(k);\n                if (gluedPair.x === gluedPair.y)\n                    continue;\n                const gluedIntEdge = gluedPairsToGluedEdge.get(gluedPair.x, gluedPair.y);\n                for (const ie of v)\n                    gluedIntEdge.weight += ie.weight;\n            }\n    }\n    GetNodeCountsOfGluedDag() {\n        if (this.verticalConstraints.isEmpty) {\n            return new Array(this.IntGraph.nodeCount).fill(1);\n        }\n        return this.verticalConstraints.getGluedNodeCounts();\n    }\n}\nfunction SnapDeltaUp(y, gridSize) {\n    if (gridSize === 0)\n        return 0;\n    // how much to snap?\n    const k = Math.floor(y / gridSize);\n    const delta = y - k * gridSize;\n    /*Assert.assert(delta >= 0 && delta < gridSize)*/\n    if (Math.abs(delta) < 0.0001) {\n        // do not snap\n        return 0;\n    }\n    return gridSize - delta;\n}\nfunction LayerIsOriginal(yLayer, origNodeCount) {\n    for (const j of yLayer)\n        if (j < origNodeCount)\n            return true;\n    return false;\n}\nfunction CalculateAnchorSizes(database, properLayeredGraph, originalGraph, intGraph, settings) {\n    const anchors = (database.Anchors = new Array(properLayeredGraph.NodeCount));\n    for (let i = 0; i < anchors.length; i++)\n        anchors[i] = new Anchor(settings.LabelCornersPreserveCoefficient);\n    //go over the old vertices\n    for (let i = 0; i < originalGraph.shallowNodeCount; i++)\n        LayeredLayout.CalcAnchorsForOriginalNode(i, intGraph, anchors, database, settings);\n    //go over virtual vertices\n    for (const intEdge of database.AllIntEdges())\n        if (intEdge.LayerEdges != null) {\n            for (const layerEdge of intEdge.LayerEdges) {\n                const v = layerEdge.Target;\n                if (v !== intEdge.target) {\n                    const anchor = anchors[v];\n                    if (!database.MultipleMiddles.has(v)) {\n                        anchor.leftAnchor = anchor.rightAnchor = VirtualNodeWidth() / 2.0;\n                        anchor.topAnchor = anchor.bottomAnchor = VirtualNodeHeight(settings) / 2.0;\n                    }\n                    else {\n                        anchor.leftAnchor = anchor.rightAnchor = VirtualNodeWidth() * 4;\n                        anchor.topAnchor = anchor.bottomAnchor = VirtualNodeHeight(settings) / 2.0;\n                    }\n                }\n            }\n            //fix label vertices\n            if (intEdge.hasLabel) {\n                const lj = intEdge.LayerEdges[intEdge.LayerEdges.length / 2].Source;\n                const a = anchors[lj];\n                const w = intEdge.labelWidth, h = intEdge.labelHeight;\n                a.rightAnchor = w;\n                a.leftAnchor = VirtualNodeWidth() * 8;\n                if (a.topAnchor < h / 2.0)\n                    a.topAnchor = a.bottomAnchor = h / 2.0;\n                a.labelIsToTheRightOfTheSpline = true;\n            }\n        }\n    return anchors;\n}\nfunction VirtualNodeWidth() {\n    return 1;\n}\n// the height of dummy nodes\nfunction VirtualNodeHeight(settings) {\n    return (settings.MinNodeHeight * 1.5) / 8;\n}\nfunction SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax) {\n    let flatEdgesHeight = 0;\n    if (i > 0) {\n        //looking for flat edges on the previous level\n        //we stack labels of multiple flat edges on top of each other\n        const flatPairs = GetFlatPairs(layerArrays.Layers[i - 1], layerArrays.y, intGraph);\n        if (flatPairs.length) {\n            const dyOfFlatEdge = settings.LayerSeparation / 3;\n            const ym = ymax;\n            flatEdgesHeight = Math.max(...flatPairs.map((pair) => SetFlatEdgesLabelsHeightAndPositionts(pair, ym, dyOfFlatEdge, database)));\n        }\n    }\n    return flatEdgesHeight;\n}\n// returnst the height of the graph+spaceBeforeMargins\nfunction CalcInitialYAnchorLocations(layerArrays, spaceBeforeMargins, originalGraph, database, intGraph, settings, layersAreDoubled) {\n    const anchors = database.Anchors;\n    let ymax = originalGraph.margins.top + spaceBeforeMargins; //setting up y coord - going up by y-layers\n    let i = 0;\n    for (const yLayer of layerArrays.Layers) {\n        let bottomAnchorMax = 0;\n        let topAnchorMax = 0;\n        for (const j of yLayer) {\n            const p = anchors[j];\n            if (p.bottomAnchor > bottomAnchorMax)\n                bottomAnchorMax = p.bottomAnchor;\n            if (p.topAnchor > topAnchorMax)\n                topAnchorMax = p.topAnchor;\n        }\n        MakeVirtualNodesTall(yLayer, bottomAnchorMax, topAnchorMax, originalGraph.shallowNodeCount, database.Anchors);\n        const flatEdgesHeight = SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax);\n        const layerCenter = ymax + bottomAnchorMax + flatEdgesHeight;\n        let layerTop = layerCenter + topAnchorMax;\n        if (NeedToSnapTopsToGrid(settings)) {\n            layerTop += SnapDeltaUp(layerTop, settings.GridSizeByY);\n            for (const j of yLayer)\n                anchors[j].top = layerTop;\n        }\n        else if (NeedToSnapBottomsToGrid(settings)) {\n            let layerBottom = layerCenter - bottomAnchorMax;\n            layerBottom += SnapDeltaUp(layerBottom, layerBottom);\n            for (const j of yLayer) {\n                anchors[j].bottom = layerBottom;\n                layerTop = Math.max(anchors[j].top, layerTop);\n            }\n        }\n        else\n            for (const j of yLayer)\n                anchors[j].y = layerCenter;\n        const layerSep = settings.ActualLayerSeparation(layersAreDoubled);\n        ymax = layerTop + layerSep;\n        i++;\n    }\n    // for the last layer\n    SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax);\n}\nfunction CreateUpDownConstrainedIntEdge(intPair, e) {\n    const intEdge = new PolyIntEdge(intPair.x, intPair.y, e);\n    intEdge.weight = 0;\n    //we do not want the edge weight to contribute in to the sum but just take the constraint into account\n    intEdge.separation = 1;\n    return intEdge;\n}\nfunction EdgeSpan(layers, e) {\n    return layers[e.source] - layers[e.target];\n}\nfunction MakeVirtualNodesTall(yLayer, bottomAnchorMax, topAnchorMax, originalNodeCount, anchors) {\n    if (LayerIsOriginal(yLayer, originalNodeCount))\n        for (const j of yLayer)\n            if (j >= originalNodeCount) {\n                const p = anchors[j];\n                p.bottomAnchor = bottomAnchorMax;\n                p.topAnchor = topAnchorMax;\n            }\n}\nfunction NeedToSnapTopsToGrid(settings) {\n    return settings.SnapToGridByY === SnapToGridByY.Top;\n}\nfunction NeedToSnapBottomsToGrid(settings) {\n    return settings.SnapToGridByY === SnapToGridByY.Bottom;\n}\nfunction TryToPutLabelOutsideOfAngle(a, predecessor, successor) {\n    if (a.labelIsToTheRightOfTheSpline) {\n        if (Point.getTriangleOrientation(predecessor.origin, a.origin, successor.origin) === TriangleOrientation.Clockwise)\n            return true;\n        const la = a.leftAnchor;\n        const ra = a.rightAnchor;\n        const x = a.x;\n        PutLabelToTheLeft(a);\n        if (Point.getTriangleOrientation(predecessor.origin, a.origin, successor.origin) === TriangleOrientation.Counterclockwise)\n            return true;\n        a.x = x;\n        a.leftAnchor = la;\n        a.rightAnchor = ra;\n        a.labelIsToTheRightOfTheSpline = true;\n        a.labelIsToTheLeftOfTheSpline = false;\n        return false;\n    }\n    return false;\n}\nfunction PutLabelToTheLeft(a) {\n    const r = a.right;\n    const t = a.leftAnchor;\n    a.leftAnchor = a.rightAnchor;\n    a.rightAnchor = t;\n    a.x = r - a.rightAnchor;\n    a.labelIsToTheLeftOfTheSpline = true;\n    a.labelIsToTheRightOfTheSpline = false;\n}\nfunction GetFlatPairs(layer, layering, intGraph) {\n    const pairs = new IntPairSet();\n    for (const v of layer) {\n        if (v >= intGraph.nodeCount)\n            continue;\n        for (const edge of intGraph.outEdges[v])\n            if (layering[edge.source] === layering[edge.target])\n                pairs.addNN(edge.source, edge.target);\n    }\n    return Array.from(pairs.values());\n}\nfunction SetFlatEdgesLabelsHeightAndPositionts(pair, ymax, dy, database) {\n    let height = 0;\n    const list = database.GetMultiedgeI(pair);\n    for (const edge of list) {\n        height += dy;\n        const label = edge.edge.label;\n        if (label != null) {\n            label.positionCenter(new Point(label.center.x, ymax + height + label.height / 2));\n            height += label.height;\n        }\n    }\n    return height;\n}\nfunction ExtendStandardAnchors(t, node, settings) {\n    t.rightAnchor = t.leftAnchor = (node.width + settings.GridSizeByX) / 2;\n    t.topAnchor = t.bottomAnchor = node.height / 2;\n}\nfunction RightAnchorMultiSelfEdges(i, t, database, settings) {\n    const delta = WidthOfSelfEdge(database, i, t, settings);\n    t.rightAnchor += delta;\n}\nfunction WidthOfSelfEdge(database, i, t, settings) {\n    let delta = 0;\n    const multiedges = database.GetMultiedge(i, i);\n    //it could be a multiple self edge\n    if (multiedges.length > 0) {\n        for (const e of multiedges)\n            if (e.edge.label != null) {\n                t.rightAnchor += e.edge.label.width;\n                if (t.topAnchor < e.edge.label.height / 2.0)\n                    t.topAnchor = t.bottomAnchor = e.edge.label.height / 2.0;\n            }\n        delta += (settings.NodeSeparation + settings.MinNodeWidth) * multiedges.length;\n    }\n    return delta;\n}\nfunction preRunTransform(geomGraph, m) {\n    if (m.isIdentity()) {\n        return;\n    }\n    const matrixInverse = m.inverse();\n    for (const n of geomGraph.shallowNodes) {\n        n.transform(matrixInverse);\n    }\n    // calculate new label widths and heights\n    for (const e of geomGraph.shallowEdges) {\n        if (e.label != null) {\n            const r = Rectangle.mkPP(matrixInverse.multiplyPoint(new Point(0, 0)), matrixInverse.multiplyPoint(new Point(e.label.width, e.label.height)));\n            e.label.width = r.width;\n            e.label.height = r.height;\n        }\n    }\n}\nfunction postRunTransform(geometryGraph, transform) {\n    if (transform.isIdentity())\n        return;\n    for (const n of geometryGraph.shallowNodes) {\n        n.transform(transform);\n    }\n    // restore labels widths and heights\n    for (const e of geometryGraph.shallowEdges) {\n        if (e.label != null) {\n            const r = Rectangle.mkPP(transform.multiplyPoint(new Point(0, 0)), transform.multiplyPoint(new Point(e.label.width, e.label.height)));\n            e.label.width = r.width;\n            e.label.height = r.height;\n        }\n    }\n    TransformEdges(geometryGraph, transform);\n    if (geometryGraph.graph.parent == null) {\n        geometryGraph.boundingBox = null;\n    }\n}\nfunction TransformEdges(geometryGraph, m) {\n    for (const e of geometryGraph.shallowEdges) {\n        if (e.label) {\n            e.label.transform(m);\n        }\n        TransformEdgeCurve(m, e);\n    }\n}\nfunction TransformEdgeCurve(transformation, e) {\n    if (e.curve != null) {\n        e.curve = e.curve.transform(transformation);\n        const eg = e;\n        if (eg.sourceArrowhead != null) {\n            eg.sourceArrowhead.tipPosition = transformation.multiplyPoint(eg.sourceArrowhead.tipPosition);\n        }\n        if (eg.targetArrowhead != null) {\n            eg.targetArrowhead.tipPosition = transformation.multiplyPoint(eg.targetArrowhead.tipPosition);\n        }\n        TransformUnderlyingPolyline(e, transformation);\n    }\n}\nfunction TransformUnderlyingPolyline(e, transformation) {\n    if (e.smoothedPolyline != null) {\n        for (let s = e.smoothedPolyline.headSite; s != null; s = s.next) {\n            s.point = transformation.multiplyPoint(s.point);\n        }\n    }\n}\n//# sourceMappingURL=layeredLayout.js.map","import { String } from 'typescript-string-operations';\nimport { LongestPathLayering } from './longestPathLayering';\nimport { mkGraphOnEdgesN } from '../../../structs/basicGraphOnEdges';\nimport { NetworkEdge } from './networkEdge';\nimport { Stack } from 'stack-typescript';\nimport { randomInt } from '../../../utils/random';\nfunction CreateGraphWithIEEdges(bg) {\n    const ieEdges = new Array();\n    for (const e of bg.edges)\n        ieEdges.push(new NetworkEdge(e));\n    return mkGraphOnEdgesN(ieEdges, bg.nodeCount);\n}\nclass StackStruct {\n    constructor(v, outEnum, i, // points to outEnum\n    inEnum, j) {\n        this.v = v;\n        this.outEnum = outEnum;\n        this.i = i;\n        this.inEnum = inEnum;\n        this.j = j;\n    }\n}\n// The implementation follows \"A technique for Drawing Directed Graphs\", Gansner, Koutsofios, North, Vo.\nexport class NetworkSimplex {\n    get weight() {\n        return this.graph.edges.map((e) => e.weight * (this.layers[e.source] - this.layers[e.target])).reduce((sum, w) => sum + w, 0);\n    }\n    get nodeCount() {\n        return this.vertices.length;\n    }\n    setLow(v, l) {\n        this.vertices[v].low = l;\n    }\n    setLim(v, l) {\n        this.vertices[v].lim = l;\n    }\n    setParent(v, e) {\n        this.vertices[v].parent = e;\n    }\n    constructor(graph, cancelToken) {\n        // fields\n        this.layers = null;\n        this.treeVertices = [];\n        this.vertices = [];\n        this.leaves = [];\n        this.graph = CreateGraphWithIEEdges(graph);\n        this.networkCancelToken = cancelToken;\n        for (let i = 0; i < this.graph.nodeCount; i++) {\n            this.vertices.push({\n                inTree: false,\n                lim: -1,\n                low: -1,\n                parent: null,\n            });\n        }\n    }\n    GetLayers() {\n        if (this.layers == null)\n            this.run();\n        return this.layers;\n    }\n    shiftLayerToZero() {\n        const minLayer = Math.min(...this.layers);\n        for (let i = 0; i < this.layers.length; i++)\n            this.layers[i] -= minLayer;\n    }\n    addVertexToTree(v) {\n        this.vertices[v].inTree = true;\n    }\n    vertexInTree(v) {\n        return this.vertices[v].inTree;\n    }\n    lim(v) {\n        return this.vertices[v].lim;\n    }\n    low(v) {\n        return this.vertices[v].low;\n    }\n    parent(v) {\n        return this.vertices[v].parent;\n    }\n    // The function feasibleTree constructs an initial feasible spanning tree.\n    feasibleTree() {\n        this.initLayers();\n        while (this.tightTree() < this.nodeCount) {\n            const e = this.getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();\n            if (e == null)\n                break; //all edges are tree edges\n            let slack = this.slack(e);\n            /*Assert.assert(slack !== 0, 'the tree should be tight')*/\n            if (this.vertexInTree(e.source))\n                slack = -slack;\n            //shift the tree rigidly up or down and make e tight\n            // since the slack is minimal the layering remains feasible\n            for (const i of this.treeVertices)\n                this.layers[i] += slack;\n        }\n        this.initCutValues();\n    }\n    // A treeEdge, belonging to the tree, divides the vertices to source and target components\n    // If v belongs to the source component we return 1\n    // otherwise we return 0\n    vertexSourceTargetVal(v, treeEdge) {\n        /*Assert.assert(treeEdge.inTree)*/\n        const s = treeEdge.source;\n        const t = treeEdge.target;\n        if (this.lim(s) > this.lim(t))\n            if (this.lim(v) <= this.lim(t) && this.low(t) <= this.lim(v))\n                //s belongs to the tree root component\n                return 0;\n            else\n                return 1;\n        //t belongs to the tree root component\n        else if (this.lim(v) <= this.lim(s) && this.low(s) <= this.lim(v))\n            return 1;\n        else\n            return 0;\n    }\n    // a convenient wrapper of IncEdges incident to v\n    incidentEdges(v) {\n        return this.graph.incidentEdges(v);\n    }\n    allLowCutsHaveBeenDone(v) {\n        for (const ie of this.incidentEdges(v))\n            if (ie.inTree && ie.cut === NetworkEdge.infinity && ie !== this.parent(v))\n                return false;\n        return true;\n    }\n    // treeEdge, belonging to the tree, divides the vertices to source and target components\n    // e does not belong to the tree . If e goes from the source component to target component\n    // then the return value is 1,\n    // if e goes from the target component ot the source then the return value is -1\n    // otherwise return zero\n    edgeSourceTargetVal(e, treeEdge) {\n        // if (e.inTree || treeEdge.inTree === false)\n        // throw new Exception(\"wrong params for EdgeSOurceTargetVal\");\n        return this.vertexSourceTargetVal(e.source, treeEdge) - this.vertexSourceTargetVal(e.target, treeEdge);\n    }\n    // initCutValues computes the cut values of the tree edges.\n    // For each tree edge, this is computed by marking the nodes as belonging to the source or\n    // target component, and then performing the sum of the signed weights of all\n    // edges whose source and target are in different components, the sign being negative for those edges\n    // going from the source to the target component.\n    // To reduce this cost, we note that the cut values can be computed using information local to an edge\n    // if the search is ordered from the leaves of the feasible tree inward. It is trivial to compute the\n    // cut value of a tree edge with one of its endpoints a leaf in the tree,\n    // since either the source or the target component consists of a single node.\n    // Now, assuming the cut values are known for all the edges incident on a given\n    // node except one, the cut value of the remaining edge is the sum of the known cut\n    // values plus a term dependent only on the edges incident to the given node.\n    initCutValues() {\n        this.initLimLowAndParent();\n        //going up from the leaves following parents\n        let front = new Stack();\n        for (const i of this.leaves)\n            front.push(i);\n        let newFront = new Stack();\n        while (front.length > 0) {\n            while (front.length > 0) {\n                const w = front.pop();\n                const cutEdge = this.parent(w);\n                if (cutEdge == null)\n                    continue;\n                let cut = 0;\n                for (const e of this.incidentEdges(w)) {\n                    if (e.inTree === false) {\n                        const e0Val = this.edgeSourceTargetVal(e, cutEdge);\n                        if (e0Val !== 0)\n                            cut += e0Val * e.weight;\n                    } //e0 is a tree edge\n                    else {\n                        if (e === cutEdge)\n                            cut += e.weight;\n                        else {\n                            const impact = cutEdge.source === e.target || cutEdge.target === e.source ? 1 : -1;\n                            const edgeContribution = this.edgeContribution(e, w);\n                            cut += edgeContribution * impact;\n                        }\n                    }\n                }\n                cutEdge.cut = cut;\n                const v = cutEdge.source === w ? cutEdge.target : cutEdge.source;\n                if (this.allLowCutsHaveBeenDone(v))\n                    newFront.push(v);\n            }\n            //swap new front and front\n            const t = front;\n            front = newFront;\n            newFront = t;\n        }\n    }\n    // e is a tree edge for which the cut has been calculted already.\n    // EdgeContribution gives an amount that edge e brings to the cut of parent(w).\n    // The contribution is the cut value minus the weight of e. Let S be the component of e source.\n    // We should also substruct W(ie) for every ie going from S to w and add W(ie) going from w to S.\n    // These numbers appear in e.cut but with opposite signs.\n    edgeContribution(e, w) {\n        let ret = e.cut - e.weight;\n        for (const ie of this.incidentEdges(w)) {\n            if (ie.inTree === false) {\n                const sign = this.edgeSourceTargetVal(ie, e);\n                if (sign === -1)\n                    ret += ie.weight;\n                else if (sign === 1)\n                    ret -= ie.weight;\n            }\n        }\n        return ret;\n    }\n    // A quote:\n    // Another valuable optimization, similar to a technique described in [Ch],\n    // is to perform a postorder traversal of the tree, starting from some fixed\n    // root node vroot, and labeling each node v with its postorder\n    // traversal number lim(v), the least number low(v) of any descendant in the search,\n    // and the edge parent(v) by which the node was reached (see figure 2-5).\n    // This provides an inexpensive way to test whether a node lies in the\n    // source or target component of a tree edge, and thus whether a non-tree edge\n    // crosses between the two components. For example, if e = (u,v) is a\n    // tree edge and vroot is in the source component of the edge (i.e., lim(u) less lim(v)),\n    // then a node w is in the target component of e if and only if low(u) is less or equal than lim(w)\n    // is less or equal than lim(u). These numbers can also be used to update the tree efficiently\n    // during the network simplex iterations. If f = (w,x) is the entering edge, the\n    // only edges whose cut values must be adjusted are those in the path\n    // connecting w and x in the tree. This path is determined by following\n    // the parent edges back from w and x until the least common ancestor is reached,\n    // i.e., the first node l such that low(l) is less or equal lim(w) than ,\n    // lim(x) is less or equal than lim(l).\n    // Of course, these postorder parameters must also be adjusted when\n    // exchanging tree edges, but only for nodes below l.\n    initLimLowAndParent() {\n        this.initLowLimParentAndLeavesOnSubtree(1, 0);\n    }\n    // initializes lim and low in the subtree\n    initLowLimParentAndLeavesOnSubtree(curLim, v) {\n        const stack = new Stack();\n        let outEnum = this.graph.outEdges[v];\n        let i = -1;\n        let inEnum = this.graph.inEdges[v];\n        let j = -1;\n        stack.push(new StackStruct(v, outEnum, i, inEnum, j)); //vroot is 0 here\n        this.vertices[v].low = curLim;\n        while (stack.length > 0) {\n            const ss = stack.pop();\n            v = ss.v;\n            outEnum = ss.outEnum;\n            i = ss.i;\n            inEnum = ss.inEnum;\n            j = ss.j;\n            //for sure we will have a descendant with the lowest number curLim since curLim may only grow\n            //from the current value\n            let done;\n            do {\n                done = true;\n                while (++i < outEnum.length) {\n                    const e = outEnum[i];\n                    if (!e.inTree || this.vertices[e.target].low > 0)\n                        continue;\n                    stack.push(new StackStruct(v, outEnum, i, inEnum, j));\n                    v = e.target;\n                    this.setParent(v, e);\n                    this.setLow(v, curLim);\n                    outEnum = this.graph.outEdges[v];\n                    i = -1;\n                    inEnum = this.graph.inEdges[v];\n                    j = -1;\n                }\n                while (++j < inEnum.length) {\n                    const e = inEnum[j];\n                    if (!e.inTree || this.vertices[e.source].low > 0) {\n                        continue;\n                    }\n                    stack.push(new StackStruct(v, outEnum, i, inEnum, j));\n                    v = e.source;\n                    this.setLow(v, curLim);\n                    this.setParent(v, e);\n                    outEnum = this.graph.outEdges[v];\n                    i = -1;\n                    inEnum = this.graph.inEdges[v];\n                    j = -1;\n                    done = false;\n                    break;\n                }\n            } while (!done);\n            //finally done with v\n            this.setLim(v, curLim++);\n            if (this.lim(v) === this.low(v))\n                this.leaves.push(v);\n        }\n    }\n    // here we update values lim and low for the subtree with the root l\n    updateLimLowLeavesAndParentsUnderNode(l) {\n        //first we zero all low values in the subtree since they are an indication when positive that\n        //the node has been processed\n        //We are updating leaves also\n        const llow = this.vertices[l].low;\n        const llim = this.vertices[l].lim;\n        this.leaves = [];\n        for (let i = 0; i < this.nodeCount; i++) {\n            if (llow <= this.vertices[i].lim && this.vertices[i].lim <= llim)\n                this.setLow(i, 0);\n            else if (this.low(i) === this.lim(i))\n                this.leaves.push(i);\n        }\n        this.initLowLimParentAndLeavesOnSubtree(llow, l);\n    }\n    slack(e) {\n        const ret = this.layers[e.source] - this.layers[e.target] - e.separation;\n        /*Assert.assert(\n          ret >= -GeomConstants.tolerance,\n          'separation is not satisfied',\n        )*/\n        return ret;\n    }\n    // one of the returned edge vertices does not belong to the tree but another does\n    getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack() {\n        let eret = null;\n        let minSlack = NetworkEdge.infinity;\n        for (const v of this.treeVertices) {\n            for (const e of this.graph.outEdges[v]) {\n                if (this.vertexInTree(e.source) && this.vertexInTree(e.target))\n                    continue;\n                const slack = this.slack(e);\n                if (slack < minSlack) {\n                    eret = e;\n                    minSlack = slack;\n                    if (slack === 1)\n                        return e;\n                }\n            }\n            for (const e of this.graph.inEdges[v]) {\n                if (this.vertexInTree(e.source) && this.vertexInTree(e.target))\n                    continue;\n                const slack = this.slack(e);\n                if (slack < minSlack) {\n                    eret = e;\n                    minSlack = slack;\n                    if (slack === 1)\n                        return e;\n                }\n            }\n        }\n        return eret;\n    }\n    // The function TightTree finds a maximal tree of tight edges containing\n    // some fixed node and returns the number of nodes in the tree.\n    // Note that such a maximal tree is just a spanning tree for the subgraph\n    // induced by all nodes reachable from the fixed node in the underlying\n    // undirected graph using only tight edges. In particular, all such trees have the same number of nodes.\n    // The function also builds the tree. It returns the number of verices in the tight tree\n    tightTree() {\n        this.treeVertices = [];\n        for (const ie of this.graph.edges)\n            ie.inTree = false;\n        for (let i = 1; i < this.nodeCount; i++)\n            this.vertices[i].inTree = false;\n        //the vertex 0 is a fixed node\n        this.vertices[0].inTree = true;\n        this.treeVertices.push(0);\n        const q = new Stack();\n        q.push(0);\n        while (q.length > 0) {\n            const v = q.pop();\n            for (const e of this.graph.outEdges[v]) {\n                if (this.vertexInTree(e.target))\n                    continue;\n                if (this.layers[e.source] - this.layers[e.target] === e.separation) {\n                    q.push(e.target);\n                    this.addVertexToTree(e.target);\n                    this.treeVertices.push(e.target);\n                    e.inTree = true;\n                }\n            }\n            for (const e of this.graph.inEdges[v]) {\n                if (this.vertexInTree(e.source))\n                    continue;\n                if (this.layers[e.source] - this.layers[e.target] === e.separation) {\n                    q.push(e.source);\n                    this.addVertexToTree(e.source);\n                    this.treeVertices.push(e.source);\n                    e.inTree = true;\n                }\n            }\n        }\n        return this.treeVertices.length;\n    }\n    // leaveEnterEdge finds a non-tree edge to replace e.\n    // This is done by breaking the tree, by removing e, into\n    // the source and the target componentx.\n    // All edges going from the source component to the\n    // target are considered for the replacement, and an edge with the minimum\n    // slack being chosen. This maintains feasibility.\n    leaveEnterEdge() {\n        let leavingEdge;\n        let enteringEdge;\n        let minCut = 0;\n        for (const e of this.graph.edges) {\n            if (e.inTree) {\n                if (e.cut < minCut) {\n                    minCut = e.cut;\n                    leavingEdge = e;\n                }\n            }\n        }\n        if (leavingEdge == null)\n            return null;\n        //now we are looking for a non-tree edge with a minimal slack belonging to TS\n        let continuation = false;\n        let minSlack = NetworkEdge.infinity;\n        for (const f of this.graph.edges) {\n            const slack = this.slack(f);\n            if (f.inTree === false &&\n                this.edgeSourceTargetVal(f, leavingEdge) === -1 &&\n                (slack < minSlack || (slack === minSlack && (continuation = randomInt(2) === 1)))) {\n                minSlack = slack;\n                enteringEdge = f;\n                if (minSlack === 0 && !continuation)\n                    break;\n                continuation = false;\n            }\n        }\n        if (enteringEdge == null) {\n            throw new Error();\n        }\n        return { leaving: leavingEdge, entering: enteringEdge };\n    }\n    // If f = (w,x) is the entering edge, the\n    // only edges whose cut values must be adjusted are those in the path\n    // connecting w and x in the tree, excluding e. This path is determined by\n    // following the parent edges back from w and x until the least common ancestor is\n    // reached, i.e., the first node l such that low(l) less or equal lim(w) ,lim(x) less or equal lim(l).\n    // Of course, these postorder parameters must also be adjusted when\n    // exchanging tree edges, but only for nodes below l.\n    // e - exiting edge, f - entering edge\n    exchange(e, f) {\n        const l = this.commonPredecessorOfSourceAndTargetOfF(f);\n        this.createPathForCutUpdates(e, f, l);\n        this.updateLimLowLeavesAndParentsUnderNode(l);\n        this.updateCuts(e);\n        this.updateLayersUnderNode(l);\n    }\n    updateLayersUnderNode(l) {\n        //update the layers under l\n        const front = new Stack();\n        front.push(l);\n        //set layers to infinity under l\n        for (let i = 0; i < this.nodeCount; i++)\n            if (this.low(l) <= this.lim(i) && this.lim(i) <= this.lim(l) && i !== l)\n                this.layers[i] = NetworkEdge.infinity;\n        while (front.length > 0) {\n            const u = front.pop();\n            for (const oe of this.graph.outEdges[u]) {\n                if (oe.inTree && this.layers[oe.target] === NetworkEdge.infinity) {\n                    this.layers[oe.target] = this.layers[u] - oe.separation;\n                    front.push(oe.target);\n                }\n            }\n            for (const ie of this.graph.inEdges[u]) {\n                if (ie.inTree && this.layers[ie.source] === NetworkEdge.infinity) {\n                    this.layers[ie.source] = this.layers[u] + ie.separation;\n                    front.push(ie.source);\n                }\n            }\n        }\n    }\n    updateCuts(e) {\n        //going up from the leaves of the branch following parents\n        let front = new Stack();\n        let newFront = new Stack();\n        //We start cut updates from the vertices of e. It will work only if in the new tree\n        // the  parents of the vertices of e are end edges on the path connecting the two vertices.\n        //Let  e be (w,x) and let f be (u,v). Let T be the tree containing e but no f,\n        //and T0 be the tree without with e but containg f. Let us consider the path with no edge repetitions from u to v in T.\n        //It has to contain e since there is a path from u to v in T containing e, because v lies in the component of w in T\n        //and u lies in the component of x in T, if there is a path without e then we have a cycle in T.\n        // Now if we remove e from this path and add f to it we get a path without edge repetitions connecting w to x.\n        // The edge adjacent in this path to w is parent(w) in T0, and the edge of the path adjacent to x is\n        //parent(x) in T0. If it is not true then we can get a cycle by constructing another path from w to x going up through the\n        //parents to the common ancessor of w and x.\n        front.push(e.source);\n        front.push(e.target);\n        while (front.length > 0) {\n            while (front.length > 0) {\n                const w = front.pop();\n                const cutEdge = this.parent(w); //have to find the cut of cutEdge\n                if (cutEdge == null)\n                    continue;\n                if (cutEdge.cut !== NetworkEdge.infinity)\n                    continue; //the value of this cut has not been changed\n                let cut = 0;\n                for (const ce of this.incidentEdges(w)) {\n                    if (ce.inTree === false) {\n                        cut += this.edgeSourceTargetVal(ce, cutEdge) * ce.weight;\n                    } //e0 is a tree edge\n                    else {\n                        if (ce === cutEdge)\n                            cut += ce.weight;\n                        else {\n                            const impact = cutEdge.source === ce.target || cutEdge.target === ce.source ? 1 : -1;\n                            const edgeContribution = this.edgeContribution(ce, w);\n                            cut += edgeContribution * impact;\n                        }\n                    }\n                }\n                cutEdge.cut = cut;\n                const u = cutEdge.source === w ? cutEdge.target : cutEdge.source;\n                if (this.allLowCutsHaveBeenDone(u))\n                    newFront.push(u);\n            }\n            //swap newFrontAndFront\n            const t = front;\n            front = newFront;\n            newFront = t;\n        }\n    }\n    createPathForCutUpdates(e, f, l) {\n        //we mark the path by setting the cut value to infinity\n        let v = f.target;\n        while (v !== l) {\n            const p = this.parent(v);\n            p.cut = NetworkEdge.infinity;\n            v = p.source === v ? p.target : p.source;\n        }\n        f.cut = NetworkEdge.infinity; //have to do it because f will be in the path between end points of e in the new tree\n        //remove e from the tree and put f inside of it\n        e.inTree = false;\n        f.inTree = true;\n    }\n    commonPredecessorOfSourceAndTargetOfF(f) {\n        //find the common predecessor of f.source and f.target\n        let fMin, fmax;\n        if (this.lim(f.source) < this.lim(f.target)) {\n            fMin = this.lim(f.source);\n            fmax = this.lim(f.target);\n        }\n        else {\n            fMin = this.lim(f.target);\n            fmax = this.lim(f.source);\n        }\n        //it is the best to walk up from the highest of nodes f\n        //but we don't know the depths\n        //so just start walking up from the source\n        let l = f.source;\n        while ((this.low(l) <= fMin && fmax <= this.lim(l)) === false) {\n            const p = this.parent(l);\n            p.cut = NetworkEdge.infinity;\n            l = p.source === l ? p.target : p.source;\n        }\n        return l;\n    }\n    checkCutValues() {\n        for (const e of this.graph.edges) {\n            if (e.inTree) {\n                let cut = 0;\n                for (const f of this.graph.edges) {\n                    cut += this.edgeSourceTargetVal(f, e) * f.weight;\n                }\n                if (e.cut !== cut)\n                    console.log(String.Format('cuts are wrong for {0}; should be {1} but is {2}', e, cut, e.cut));\n            }\n        }\n    }\n    initLayers() {\n        const lp = new LongestPathLayering(this.graph);\n        return (this.layers = lp.GetLayers());\n    }\n    run() {\n        if (this.graph.edges.length === 0 && this.graph.nodeCount === 0) {\n            this.layers = [];\n        }\n        else {\n            this.feasibleTree();\n            let leaveEnter;\n            while ((leaveEnter = this.leaveEnterEdge()) != null) {\n                this.exchange(leaveEnter.leaving, leaveEnter.entering);\n            }\n            this.shiftLayerToZero();\n        }\n    }\n}\n//# sourceMappingURL=NetworkSimplex.js.map","import { BasicGraph } from '../../../structs/BasicGraph';\nimport { PolyIntEdge } from '../polyIntEdge';\nimport { NetworkSimplex } from './NetworkSimplex';\nexport class NetworkSimplexForGeneralGraph {\n    GetLayers() {\n        return new NetworkSimplex(this.graph, this.Cancel).GetLayers();\n    }\n    ShrunkComponent(dictionary) {\n        const edges = [];\n        for (const p of dictionary) {\n            const v = p[0];\n            const newEdgeSource = p[1];\n            for (const e of this.graph.outEdges[v]) {\n                const pe = new PolyIntEdge(newEdgeSource, dictionary.get(e.target), e.edge);\n                pe.separation = e.separation;\n                pe.weight = e.weight;\n                edges.push(pe);\n            }\n        }\n        return new BasicGraph(edges, dictionary.size);\n    }\n    constructor(graph, cancelObject) {\n        this.graph = graph;\n        this.Cancel = cancelObject;\n    }\n}\n//# sourceMappingURL=NetworkSimplexForGeneralGraph.js.map","import { TopologicalSort } from './../../../math/graphAlgorithms/topologicalSort';\n// Layering the DAG by longest path\nexport class LongestPathLayering {\n    GetLayers() {\n        //sort the vertices in topological order\n        const topoOrder = TopologicalSort.getOrderOnGraph(this.graph);\n        // Assert.assert(this.checkTopoOrder(topoOrder))\n        // initially all nodes belong to the same layer 0\n        const layering = new Array(this.graph.nodeCount).fill(0);\n        //going backward from leaves\n        let k = this.graph.nodeCount;\n        while (k-- > 0) {\n            const v = topoOrder[k];\n            for (const e of this.graph.inEdges[v]) {\n                const u = e.source;\n                const l = layering[v] + e.separation;\n                if (layering[u] < l)\n                    layering[u] = l;\n            }\n        }\n        return layering;\n    }\n    checkTopoOrder(topoOrder) {\n        for (const e of this.graph.edges) {\n            if (edgeIsOff(e, topoOrder)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    constructor(graph) {\n        this.graph = graph;\n    }\n}\nfunction edgeIsOff(e, topoOrder) {\n    const i = topoOrder.findIndex((x) => x === e.source);\n    const j = topoOrder.findIndex((x) => x === e.target);\n    if (i === -1 || j === -1 || i >= j) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=longestPathLayering.js.map","export class NetworkEdge {\n    constructor(e) {\n        this.inTree = false;\n        this.cut = NetworkEdge.infinity;\n        this.iedge = e;\n    }\n    get source() {\n        return this.iedge.source;\n    }\n    get target() {\n        return this.iedge.target;\n    }\n    get separation() {\n        return this.iedge.separation;\n    }\n    get crossingWeight() {\n        return this.iedge.CrossingWeight;\n    }\n    get weight() {\n        return this.iedge.weight;\n    }\n}\nNetworkEdge.infinity = Number.MAX_SAFE_INTEGER;\n//# sourceMappingURL=networkEdge.js.map","export class EdgeComparerBySource {\n    constructor(X) {\n        this.x = X;\n    }\n    Compare(a, b) {\n        const r = this.x[a.Source] - this.x[b.Source];\n        if (r !== 0)\n            return r;\n        return this.x[a.Target] - this.x[b.Target];\n    }\n}\n//# sourceMappingURL=edgeComparerBySource.js.map","export class EdgeComparerByTarget {\n    constructor(X) {\n        this.x = X;\n    }\n    Compare(a, b) {\n        const r = this.x[a.Target] - this.x[b.Target];\n        if (r !== 0)\n            return r;\n        return this.x[a.Source] - this.x[b.Source];\n    }\n}\n//# sourceMappingURL=edgeComparerByTarget.js.map","// Following \"Improving Layered Graph Layouts with Edge Bundling\" and\n// \"Two polynomial time algorithms for the bundle-Line crossing minimization problem\"\n// Postprocessing minimizing crossings step that works on the layered graph\nimport { Point } from '../../../math/geometry/point';\nimport { compareNumbers } from '../../../utils/compare';\nimport { PointMap } from '../../../utils/PointMap';\nexport class MetroMapOrdering {\n    constructor(properLayeredGraph, layerArrays, nodePositions) {\n        this.properLayeredGraph = properLayeredGraph;\n        this.layerArrays = layerArrays;\n        this.nodePositions = nodePositions;\n    }\n    // Reorder only points having identical nodePositions\n    static UpdateLayerArrays0(properLayeredGraph, layerArrays, nodePositions) {\n        new MetroMapOrdering(properLayeredGraph, layerArrays, nodePositions).UpdateLayerArrays();\n    }\n    // Reorder virtual nodes between the same pair of real nodes\n    static UpdateLayerArrays1(properLayeredGraph, layerArrays) {\n        /*Assert.assert(layersAreCorrect(layerArrays))*/\n        const nodePositions = MetroMapOrdering.BuildInitialNodePositions(properLayeredGraph, layerArrays);\n        /*Assert.assert(layersAreCorrect(layerArrays))*/\n        this.UpdateLayerArrays0(properLayeredGraph, layerArrays, nodePositions);\n        /*Assert.assert(layersAreCorrect(layerArrays))*/\n    }\n    static BuildInitialNodePositions(properLayeredGraph, layerArrays) {\n        const result = new Map();\n        for (let i = 0; i < layerArrays.Layers.length; i++) {\n            let curr = 0;\n            let prev = 0;\n            while (curr < layerArrays.Layers[i].length) {\n                while (curr < layerArrays.Layers[i].length && properLayeredGraph.IsVirtualNode(layerArrays.Layers[i][curr])) {\n                    curr++;\n                }\n                for (let j = prev; j < curr; j++) {\n                    result.set(layerArrays.Layers[i][j], new Point(i, prev));\n                }\n                if (curr < layerArrays.Layers[i].length) {\n                    result.set(layerArrays.Layers[i][curr], new Point(i, curr));\n                }\n                curr++;\n                prev = curr;\n            }\n        }\n        return result;\n    }\n    UpdateLayerArrays() {\n        // algo stuff here\n        let ordering = this.CreateInitialOrdering();\n        ordering = this.BuildOrdering(ordering);\n        this.RestoreLayerArrays(ordering);\n    }\n    CreateInitialOrdering() {\n        const initialOrdering = new PointMap();\n        for (const layer of this.layerArrays.Layers) {\n            for (const node of layer) {\n                const p = this.nodePositions.get(node);\n                if (!initialOrdering.hasxy(p.x, p.y)) {\n                    initialOrdering.setxy(p.x, p.y, []);\n                }\n                initialOrdering.getxy(p.x, p.y).push(node);\n            }\n        }\n        return initialOrdering;\n    }\n    BuildOrdering(initialOrdering) {\n        // run through nodes points and build order\n        const result = new PointMap();\n        const inverseOrder = new Map();\n        for (const layer of this.layerArrays.Layers) {\n            for (const node of layer) {\n                // already processed\n                const p = this.nodePositions.get(node);\n                if (result.hasxy(p.x, p.y)) {\n                    continue;\n                }\n                this.BuildNodeOrdering(initialOrdering.get(p), inverseOrder);\n                result.set(p, initialOrdering.get(p));\n            }\n        }\n        return result;\n    }\n    BuildNodeOrdering(result, inverseToOrder) {\n        result.sort(this.Comparison(inverseToOrder));\n        for (let i = 0; i < result.length; i++) {\n            inverseToOrder.set(result[i], i);\n        }\n    }\n    firstSucc(node) {\n        for (const s of this.properLayeredGraph.Succ(node)) {\n            return s;\n        }\n    }\n    firstPred(node) {\n        for (const s of this.properLayeredGraph.Pred(node)) {\n            return s;\n        }\n    }\n    Comparison(inverseToOrder) {\n        return (node1, node2) => {\n            /*Assert.assert(\n              this.properLayeredGraph.IsVirtualNode(node1) &&\n                this.properLayeredGraph.IsVirtualNode(node2),\n            )*/\n            const succ1 = this.firstSucc(node1);\n            const succ2 = this.firstSucc(node2);\n            let pred1 = this.firstPred(node1);\n            let pred2 = this.firstPred(node2);\n            const succPoint1 = this.nodePositions.get(succ1);\n            const succPoint2 = this.nodePositions.get(succ2);\n            const predPoint1 = this.nodePositions.get(pred1);\n            const predPoint2 = this.nodePositions.get(pred2);\n            if (!succPoint1.equal(succPoint2)) {\n                if (!predPoint1.equal(predPoint2)) {\n                    return predPoint1.compareTo(predPoint2);\n                }\n                return succPoint1.compareTo(succPoint2);\n            }\n            if (this.properLayeredGraph.IsVirtualNode(succ1)) {\n                if (!predPoint1.equal(predPoint2)) {\n                    return predPoint1.compareTo(predPoint2);\n                }\n                const o1 = inverseToOrder.get(succ1);\n                const o2 = inverseToOrder.get(succ2);\n                /*Assert.assert(o1 !== -1 && o2 !== -1)*/\n                return compareNumbers(o1, o2);\n            }\n            while (this.nodePositions.get(pred1).equal(this.nodePositions.get(pred2)) && this.properLayeredGraph.IsVirtualNode(pred1)) {\n                pred1 = this.firstPred(pred1);\n                pred2 = this.firstPred(pred2);\n            }\n            if (this.nodePositions.get(pred1).equal(this.nodePositions.get(pred2))) {\n                return compareNumbers(node1, node2);\n            }\n            return this.nodePositions.get(pred1).compareTo(this.nodePositions.get(pred2));\n        };\n    }\n    RestoreLayerArrays(ordering) {\n        for (const layer of this.layerArrays.Layers) {\n            let tec = 0;\n            let pred = 0;\n            while (tec < layer.length) {\n                while (tec < layer.length && this.nodePositions.get(layer[pred]).equal(this.nodePositions.get(layer[tec]))) {\n                    tec++;\n                }\n                const t = ordering.get(this.nodePositions.get(layer[pred]));\n                for (let j = pred; j < tec; j++) {\n                    layer[j] = t[j - pred];\n                }\n                pred = tec;\n            }\n        }\n        this.layerArrays.UpdateXFromLayers();\n    }\n}\n//# sourceMappingURL=metroMapOrdering.js.map","// Following \"A technique for Drawing Directed Graphs\" of Gansner, Koutsofios, North and Vo\nimport { copyTo } from '../../../utils/copy';\nimport { randomInt } from '../../../utils/random';\nimport { OrderingMeasure } from './orderingMeasure';\nimport { Stack } from 'stack-typescript';\nimport { EdgeComparerBySource } from './edgeComparerBySource';\nimport { EdgeComparerByTarget } from './edgeComparerByTarget';\nimport { Algorithm } from './../../../utils/algorithm';\nimport { flattenArray } from '../../../utils/setOperations';\n// Works on the layered graph.\n// See GraphLayout.pdfhttps://www.researchgate.net/profile/Lev_Nachmanson/publication/30509007_Drawing_graphs_with_GLEE/links/54b6b2930cf2e68eb27edf71/Drawing-graphs-with-GLEE.pdf\nfunction HeadOfTheCoin() {\n    return randomInt(2) === 0;\n}\n// This method can be improved: see the paper Simple And Efficient ...\nfunction GetCrossingCountFromStrip(bottom, properLayeredGraph, layerArrays) {\n    const topVerts = layerArrays.Layers[bottom + 1];\n    const bottomVerts = layerArrays.Layers[bottom];\n    if (bottomVerts.length <= topVerts.length)\n        return GetCrossingCountFromStripWhenBottomLayerIsShorter(bottomVerts, properLayeredGraph, layerArrays);\n    else\n        return GetCrossingCountFromStripWhenTopLayerIsShorter(topVerts, bottomVerts, properLayeredGraph, layerArrays);\n}\nfunction GetCrossingCountFromStripWhenTopLayerIsShorter(topVerts, bottomVerts, properLayeredGraph, layerArrays) {\n    const edges = EdgesOfStrip(bottomVerts, properLayeredGraph);\n    const comparer = new EdgeComparerByTarget(layerArrays.x);\n    edges.sort((a, b) => comparer.Compare(a, b));\n    //find first n such that 2^n >=topVerts.length\n    let n = 1;\n    while (n < topVerts.length)\n        n *= 2;\n    //init the accumulator tree\n    const tree = new Array(2 * n - 1).fill(0);\n    n--; // the first bottom node starts from n now\n    let cc = 0; //number of crossings\n    for (const edge of edges) {\n        let index = n + layerArrays.x[edge.Source];\n        const ew = edge.CrossingWeight;\n        tree[index] += ew;\n        while (index > 0) {\n            if (index % 2 !== 0)\n                cc += ew * tree[index + 1]; //intersect everything accumulated in the right sibling\n            index = Math.floor((index - 1) / 2);\n            tree[index] += ew;\n        }\n    }\n    return cc;\n}\n// see: Simple and Efficient Bilayer Cross Counting, by Wilhelm Barth, Petra Mutzel\nfunction GetCrossingCountFromStripWhenBottomLayerIsShorter(bottomVerts, properLayeredGraph, layerArrays) {\n    const edges = EdgesOfStrip(bottomVerts, properLayeredGraph);\n    const comparer = new EdgeComparerBySource(layerArrays.x);\n    edges.sort((a, b) => comparer.Compare(a, b));\n    //find first n such that 2^n >=bottomVerts.length\n    let n = 1;\n    while (n < bottomVerts.length)\n        n *= 2;\n    //init accumulator\n    const tree = new Array(2 * n - 1).fill(0);\n    n--; // the first bottom node starts from n now\n    let cc = 0; //number of crossings\n    for (const edge of edges) {\n        let index = n + layerArrays.x[edge.Target];\n        const ew = edge.CrossingWeight;\n        tree[index] += ew;\n        while (index > 0) {\n            if (index % 2 !== 0)\n                cc += ew * tree[index + 1]; //intersect everything accumulated in the right sibling\n            index = Math.floor((index - 1) / 2);\n            tree[index] += ew;\n        }\n    }\n    return cc;\n}\nfunction EdgesOfStrip(bottomVerts, properLayeredGraph) {\n    return flattenArray(bottomVerts, (v) => properLayeredGraph.InEdges(v));\n}\nexport function GetCrossingsTotal(properLayeredGraph, layerArrays) {\n    let x = 0;\n    for (let i = 0; i < layerArrays.Layers.length - 1; i++)\n        x += GetCrossingCountFromStrip(i, properLayeredGraph, layerArrays);\n    return x;\n}\nexport class Ordering extends Algorithm {\n    get NoGainStepsBound() {\n        return this.SugSettings.NoGainAdjacentSwapStepsBound * this.SugSettings.NoGainStepsForOrderingMultiplier;\n    }\n    // gets the random seed for some random choices inside of layer ordering\n    get SeedOfRandom() {\n        return randomInt(100);\n    }\n    constructor(graphPar, tryReverse, layerArraysParam, startOfVirtualNodes, hasCrossWeights, settings, cancelToken) {\n        super(cancelToken);\n        this.tryReverse = true;\n        // Gets or sets the number of of passes over all layers to rung adjacent exchanges, where every pass goes '\n        // all way up to the top layer and down to the lowest layer\n        this.MaxNumberOfAdjacentExchanges = 50;\n        this.cancelToken = cancelToken;\n        this.tryReverse = tryReverse;\n        this.startOfVirtNodes = startOfVirtualNodes;\n        this.layerArrays = layerArraysParam;\n        this.layering = layerArraysParam.y;\n        this.nOfLayers = layerArraysParam.Layers.length;\n        this.layers = layerArraysParam.Layers;\n        this.properLayeredGraph = graphPar;\n        this.hasCrossWeights = hasCrossWeights;\n        this.SugSettings = settings;\n    }\n    // an upper limit on a number of passes in layer ordering\n    get MaxOfIterations() {\n        return this.SugSettings.MaxNumberOfPassesInOrdering * this.SugSettings.NoGainStepsForOrderingMultiplier;\n    }\n    static OrderLayers(graph, layerArrays, startOfVirtualNodes, settings, cancelToken) {\n        let hasCrossWeight = false;\n        for (const le of graph.Edges)\n            if (le.CrossingWeight !== 1) {\n                hasCrossWeight = true;\n                break;\n            }\n        const o = new Ordering(graph, true, layerArrays, startOfVirtualNodes, hasCrossWeight, settings, cancelToken);\n        o.run();\n    }\n    run() {\n        // #if DEBUGORDERING\n        // if (graph.NumberOfVertices !== layering.length)\n        //  throw new System.Exception(\"the layering does not correspond to the graph\");\n        // for (IntEdge e of graph.Edges)\n        // if (layering[e.Source] - layering[e.Target] !== 1)\n        //  throw new System.Exception(\"the edge in the graph does not span exactly one layer:\" + e);\n        // #endif\n        this.Calculate();\n        if ( /*orderingMeasure.x>0 &&*/this.tryReverse) {\n            const secondLayers = this.layerArrays.ReversedClone();\n            const revOrdering = new Ordering(this.properLayeredGraph.ReversedClone(), false, secondLayers, this.startOfVirtNodes, this.hasCrossWeights, this.SugSettings, this.cancelToken);\n            revOrdering.run();\n            if (OrderingMeasure.less(revOrdering.measure, this.measure)) {\n                for (let j = 0; j < this.nOfLayers; j++)\n                    copyTo(secondLayers.Layers[j], this.layerArrays.Layers[this.nOfLayers - 1 - j]);\n                this.layerArrays.UpdateXFromLayers();\n            }\n        }\n    }\n    Calculate() {\n        this.Init();\n        this.layerArraysCopy = Ordering.CloneLayers(this.layers, this.layerArraysCopy);\n        let countOfNoGainSteps = 0;\n        this.measure = new OrderingMeasure(this.layerArraysCopy, GetCrossingsTotal(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes);\n        //Stopwatch sw = Stopwatch.StartNew();\n        for (let i = 0; i < this.MaxOfIterations && countOfNoGainSteps < this.NoGainStepsBound && !this.measure.IsPerfect(); i++) {\n            const up = i % 2 === 0;\n            this.LayerByLayerSweep(up);\n            this.AdjacentExchange();\n            const newMeasure = new OrderingMeasure(this.layerArrays.Layers, GetCrossingsTotal(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes);\n            if (OrderingMeasure.less(this.measure, newMeasure)) {\n                this.Restore();\n                countOfNoGainSteps++;\n            }\n            else if (OrderingMeasure.less(newMeasure, this.measure) || HeadOfTheCoin()) {\n                countOfNoGainSteps = 0;\n                this.layerArraysCopy = Ordering.CloneLayers(this.layers, this.layerArraysCopy);\n                this.measure = newMeasure;\n            }\n        }\n    }\n    static CloneLayers(layers, layerArraysCopy) {\n        if (layerArraysCopy == null) {\n            layerArraysCopy = new Array(layers.length);\n            for (let i = 0; i < layers.length; i++)\n                layerArraysCopy[i] = layers[i].map((i) => i);\n        }\n        else\n            for (let i = 0; i < layers.length; i++)\n                copyTo(layers[i], layerArraysCopy[i]);\n        return layerArraysCopy;\n    }\n    Restore() {\n        this.layerArrays.updateLayers(this.layerArraysCopy);\n    }\n    LayerByLayerSweep(up) {\n        if (up) {\n            for (let i = 1; i < this.nOfLayers; i++)\n                this.SweepLayer(i, true);\n        }\n        else\n            for (let i = this.nOfLayers - 2; i >= 0; i--)\n                this.SweepLayer(i, false);\n    }\n    // the layer layer-1 is fixed if\n    // upperLayer us true and layer+1 is fixed in\n    // the opposite case\n    // the layer with index \"layer\" is updated\n    // of the strip</param>\n    SweepLayer(layer, upperLayer) {\n        const l = this.layers[layer];\n        const medianValues = new Array(l.length);\n        for (let i = 0; i < medianValues.length; i++)\n            medianValues[i] = this.WMedian(l[i], upperLayer);\n        this.Sort(layer, medianValues);\n        //update X\n        const vertices = this.layerArrays.Layers[layer];\n        for (let i = 0; i < vertices.length; i++)\n            this.layerArrays.x[vertices[i]] = i;\n    }\n    // sorts layerToSort according to medianValues\n    // if medianValues[i] is -1 then layer[i] does not move\n    Sort(layerToSort, medianValues) {\n        const s = new Map();\n        const vertices = this.layers[layerToSort];\n        let i = 0;\n        for (const m of medianValues) {\n            const v = vertices[i++];\n            if (m === -1.0)\n                continue;\n            if (!s.has(m))\n                s.set(m, v);\n            else {\n                const o = s.get(m);\n                if (!(typeof o === 'number')) {\n                    const al = o;\n                    if (HeadOfTheCoin())\n                        al.push(v);\n                    else {\n                        //stick it in the middle\n                        const j = randomInt(al.length);\n                        const k = al[j];\n                        al[j] = v;\n                        al.push(k);\n                    }\n                }\n                else {\n                    const io = o;\n                    const al = new Array();\n                    s.set(m, al);\n                    if (HeadOfTheCoin()) {\n                        al.push(io);\n                        al.push(v);\n                    }\n                    else {\n                        al.push(v);\n                        al.push(io);\n                    }\n                }\n            }\n        }\n        const senum = Array.from(s).sort((a, b) => a[0] - b[0]).map(a => a[1]);\n        let j = 0;\n        for (i = 0; i < vertices.length;) {\n            if (medianValues[i] !== -1) {\n                const o = senum[j++];\n                if (typeof o === 'number')\n                    vertices[i++] = o;\n                else {\n                    const al = o;\n                    for (const v of al) {\n                        //find the first empty spot\n                        while (medianValues[i] === -1)\n                            i++;\n                        vertices[i++] = v;\n                    }\n                }\n            }\n            else\n                i++;\n        }\n    }\n    WMedian(node, theMedianGoingDown) {\n        let edges;\n        let p;\n        if (theMedianGoingDown) {\n            edges = this.properLayeredGraph.OutEdges(node);\n            p = this.properLayeredGraph.OutEdgesCount(node);\n        }\n        else {\n            edges = this.properLayeredGraph.InEdges(node);\n            p = this.properLayeredGraph.InEdgesCount(node);\n        }\n        if (p === 0)\n            return -1.0;\n        const parray = new Array(p); //we do not have multiple edges\n        let i = 0;\n        if (theMedianGoingDown)\n            for (const e of edges)\n                parray[i++] = this.X[e.Target];\n        else\n            for (const e of edges)\n                parray[i++] = this.X[e.Source];\n        parray.sort((a, b) => a - b);\n        const m = Math.floor(p / 2);\n        if (p % 2 === 1)\n            return parray[m];\n        if (p === 2)\n            return 0.5 * (parray[0] + parray[1]);\n        const left = parray[m - 1] - parray[0];\n        const right = parray[p - 1] - parray[m];\n        return Math.floor((parray[m - 1] * left + parray[m] * right) / (left + right));\n    }\n    // Just depth search and assign the index saying when the node was visited\n    Init() {\n        const counts = new Array(this.nOfLayers).fill(0);\n        //the initial layers are set by following the order of the\n        //depth first traversal inside one layer\n        const q = new Stack();\n        //enqueue all sources of the graph\n        for (let i = 0; i < this.properLayeredGraph.NodeCount; i++)\n            if (this.properLayeredGraph.InEdgesCount(i) === 0)\n                q.push(i);\n        const visited = new Array(this.properLayeredGraph.NodeCount).fill(false);\n        while (q.size > 0) {\n            const u = q.pop();\n            const l = this.layerArrays.y[u];\n            this.layerArrays.Layers[l][counts[l]] = u;\n            this.layerArrays.x[u] = counts[l];\n            counts[l]++;\n            for (const v of this.properLayeredGraph.Succ(u))\n                if (!visited[v]) {\n                    visited[v] = true;\n                    q.push(v);\n                }\n        }\n        this.X = this.layerArrays.x;\n    }\n    AdjacentExchange() {\n        this.InitArrays();\n        let count = 0;\n        let progress = true;\n        while (progress && count++ < this.MaxNumberOfAdjacentExchanges) {\n            progress = false;\n            for (let i = 0; i < this.layers.length; i++)\n                progress = this.AdjExchangeLayer(i) || progress;\n            for (let i = this.layers.length - 2; i >= 0; i--)\n                progress = this.AdjExchangeLayer(i) || progress;\n        }\n    }\n    AllocArrays() {\n        const n = this.properLayeredGraph.NodeCount;\n        this.predecessors = new Array(n);\n        this.successors = new Array(n);\n        this.pOrder = new Array(n);\n        this.sOrder = new Array(n);\n        if (this.hasCrossWeights) {\n            this.outCrossingCount = new Array(n);\n            this.inCrossingCount = new Array(n);\n        }\n        for (let i = 0; i < n; i++) {\n            let count = this.properLayeredGraph.InEdgesCount(i);\n            this.predecessors[i] = new Array(count);\n            if (this.hasCrossWeights) {\n                const inCounts = (this.inCrossingCount[i] = new Map());\n                for (const le of this.properLayeredGraph.InEdges(i))\n                    inCounts.set(le.Source, le.CrossingWeight);\n            }\n            this.pOrder[i] = new Map();\n            count = this.properLayeredGraph.OutEdgesCount(i);\n            this.successors[i] = new Array(count);\n            this.sOrder[i] = new Map();\n            if (this.hasCrossWeights) {\n                const outCounts = (this.outCrossingCount[i] = new Map());\n                for (const le of this.properLayeredGraph.OutEdges(i))\n                    outCounts.set(le.Target, le.CrossingWeight);\n            }\n        }\n    }\n    // Is called just after median layer swap is done\n    InitArrays() {\n        if (this.successors == null)\n            this.AllocArrays();\n        for (let i = 0; i < this.properLayeredGraph.NodeCount; i++) {\n            this.pOrder[i] = new Map();\n            this.sOrder[i] = new Map();\n        }\n        for (const t of this.layers)\n            this.InitPsArraysForLayer(t);\n    }\n    // calculates the number of intersections between edges adjacent to u and v\n    CalcPair(u, v) {\n        const su = this.successors[u];\n        const sv = this.successors[v];\n        const pu = this.predecessors[u];\n        const pv = this.predecessors[v];\n        if (!this.hasCrossWeights) {\n            return {\n                cuv: this.CountOnArrays(su, sv) + this.CountOnArrays(pu, pv),\n                cvu: this.CountOnArrays(sv, su) + this.CountOnArrays(pv, pu),\n            };\n        }\n        else {\n            const uOutCrossCounts = this.outCrossingCount[u];\n            const vOutCrossCounts = this.outCrossingCount[v];\n            const uInCrossCounts = this.inCrossingCount[u];\n            const vInCrossCounts = this.inCrossingCount[v];\n            return {\n                cuv: this.CountOnArraysUV(su, sv, uOutCrossCounts, vOutCrossCounts) + this.CountOnArraysUV(pu, pv, uInCrossCounts, vInCrossCounts),\n                cvu: this.CountOnArraysUV(sv, su, vOutCrossCounts, uOutCrossCounts) + this.CountOnArraysUV(pv, pu, vInCrossCounts, uInCrossCounts),\n            };\n        }\n    }\n    // Sweep layer from left to right and fill S,P arrays as we go.\n    // The arrays P and S will be sorted according to X. Note that we will not keep them sorted\n    // as we doing adjacent swaps. Initial sorting only needed to calculate initial clr,crl values.\n    InitPsArraysForLayer(layer) {\n        for (const l of layer) {\n            for (const p of this.properLayeredGraph.Pred(l)) {\n                const so = this.sOrder[p];\n                const sHasNow = so.size;\n                this.successors[p][sHasNow] = l; //l takes the first available slot in S[p]\n                so.set(l, sHasNow);\n            }\n            for (const s of this.properLayeredGraph.Succ(l)) {\n                const po = this.pOrder[s];\n                const pHasNow = po.size;\n                this.predecessors[s][pHasNow] = l; //l take the first available slot in P[s]\n                po.set(l, pHasNow);\n            }\n        }\n    }\n    CountOnArrays(unbs, vnbs) {\n        let ret = 0;\n        const vl = vnbs.length - 1;\n        let j = -1; //the right most position of vnbs to the left from the current u neighbor\n        let vnbsSeenAlready = 0;\n        for (const uNeighbor of unbs) {\n            const xu = this.X[uNeighbor];\n            for (; j < vl && this.X[vnbs[j + 1]] < xu; j++)\n                vnbsSeenAlready++;\n            ret += vnbsSeenAlready;\n        }\n        return ret;\n    }\n    // every inversion between unbs and vnbs gives an intersecton\n    CountOnArraysUV(unbs, vnbs, uCrossingCounts, vCrossingCount) {\n        let ret = 0;\n        const vl = vnbs.length - 1;\n        let j = -1; //the right most position of vnbs to the left from the current u neighbor\n        let vCrossingNumberSeenAlready = 0;\n        for (const uNeib of unbs) {\n            const xu = this.X[uNeib];\n            let vnb;\n            for (; j < vl && this.X[(vnb = vnbs[j + 1])] < xu; j++)\n                vCrossingNumberSeenAlready += vCrossingCount.get(vnb);\n            ret += vCrossingNumberSeenAlready * uCrossingCounts.get(uNeib);\n        }\n        return ret;\n    }\n    AdjExchangeLayer(i) {\n        const layer = this.layers[i];\n        const gain = this.ExchangeWithGainWithNoDisturbance(layer);\n        if (gain)\n            return true;\n        this.DisturbLayer(layer);\n        return this.ExchangeWithGainWithNoDisturbance(layer);\n    }\n    //in this routine u and v are adjacent, and u is to the left of v before the swap\n    Swap(u, v) {\n        const left = this.X[u];\n        const right = this.X[v];\n        const ln = this.layering[u]; //layer number\n        const layer = this.layers[ln];\n        layer[left] = v;\n        layer[right] = u;\n        this.X[u] = right;\n        this.X[v] = left;\n        //update sorted arrays POrders and SOrders\n        //an array should be updated only in case it contains both u and v.\n        // More than that, v has to follow u in an the array.\n        this.UpdateSsContainingUv(u, v);\n        this.UpdatePsContainingUv(u, v);\n    }\n    UpdatePsContainingUv(u, v) {\n        if (this.successors[u].length <= this.successors[v].length)\n            for (const a of this.successors[u]) {\n                const porder = this.pOrder[a];\n                //of course porder contains u, let us see if it contains v\n                if (porder.has(v)) {\n                    const vOffset = porder.get(v);\n                    //swap u and v in the array P[coeff]\n                    const p = this.predecessors[a];\n                    p[vOffset - 1] = v;\n                    p[vOffset] = u;\n                    //update sorder itself\n                    porder.set(v, vOffset - 1);\n                    porder.set(u, vOffset);\n                }\n            }\n        else\n            for (const a of this.successors[v]) {\n                const porder = this.pOrder[a];\n                //of course porder contains u, let us see if it contains v\n                if (porder.has(u)) {\n                    const vOffset = porder.get(v);\n                    //swap u and v in the array P[coeff]\n                    const p = this.predecessors[a];\n                    p[vOffset - 1] = v;\n                    p[vOffset] = u;\n                    //update sorder itself\n                    porder.set(v, vOffset - 1);\n                    porder.set(u, vOffset);\n                }\n            }\n    }\n    UpdateSsContainingUv(u, v) {\n        if (this.predecessors[u].length <= this.predecessors[v].length)\n            for (const a of this.predecessors[u]) {\n                const sorder = this.sOrder[a];\n                //of course sorder contains u, let us see if it contains v\n                if (sorder.has(v)) {\n                    const vOffset = sorder.get(v);\n                    //swap u and v in the array S[coeff]\n                    const s = this.successors[a];\n                    s[vOffset - 1] = v;\n                    s[vOffset] = u;\n                    //update sorder itself\n                    sorder.set(v, vOffset - 1);\n                    sorder.set(u, vOffset);\n                }\n            }\n        else\n            for (const a of this.predecessors[v]) {\n                const sorder = this.sOrder[a];\n                //of course sorder contains u, let us see if it contains v\n                if (sorder.has(u)) {\n                    const vOffset = sorder.get(v);\n                    //swap u and v in the array S[coeff]\n                    const s = this.successors[a];\n                    s[vOffset - 1] = v;\n                    s[vOffset] = u;\n                    //update sorder itself\n                    sorder.set(v, vOffset - 1);\n                    sorder.set(u, vOffset);\n                }\n            }\n    }\n    DisturbLayer(layer) {\n        for (let i = 0; i < layer.length - 1; i++)\n            this.AdjacentSwapToTheRight(layer, i);\n    }\n    ExchangeWithGainWithNoDisturbance(layer) {\n        let wasGain = false;\n        let gain;\n        do {\n            gain = this.ExchangeWithGain(layer);\n            wasGain = wasGain || gain;\n        } while (gain);\n        return wasGain;\n    }\n    ExchangeWithGain(layer) {\n        //find a first pair giving some gain\n        for (let i = 0; i < layer.length - 1; i++)\n            if (this.SwapWithGain(layer[i], layer[i + 1])) {\n                this.SwapToTheLeft(layer, i);\n                this.SwapToTheRight(layer, i + 1);\n                return true;\n            }\n        return false;\n    }\n    SwapToTheLeft(layer, i) {\n        for (let j = i - 1; j >= 0; j--)\n            this.AdjacentSwapToTheRight(layer, j);\n    }\n    SwapToTheRight(layer, i) {\n        for (let j = i; j < layer.length - 1; j++)\n            this.AdjacentSwapToTheRight(layer, j);\n    }\n    // swaps i-th element with i+1\n    AdjacentSwapToTheRight(layer, i) {\n        const u = layer[i];\n        const v = layer[i + 1];\n        const gain = this.SwapGain(u, v);\n        if (gain > 0 || (gain === 0 && HeadOfTheCoin()))\n            this.Swap(u, v);\n    }\n    SwapGain(u, v) {\n        const r = this.CalcPair(u, v);\n        return r.cuv - r.cvu;\n    }\n    UvAreOfSameKind(u, v) {\n        return (u < this.startOfVirtNodes && v < this.startOfVirtNodes) || (u >= this.startOfVirtNodes && v >= this.startOfVirtNodes);\n    }\n    NeighborsForbidTheSwap(u, v) {\n        return this.UpperNeighborsForbidTheSwap(u, v) || this.LowerNeighborsForbidTheSwap(u, v);\n    }\n    LowerNeighborsForbidTheSwap(u, v) {\n        let uCount;\n        let vCount;\n        if ((uCount = this.properLayeredGraph.OutEdgesCount(u)) === 0 || (vCount = this.properLayeredGraph.OutEdgesCount(v)) === 0)\n            return false;\n        return this.X[this.successors[u][uCount >> 1]] < this.X[this.successors[v][vCount >> 1]];\n    }\n    UpperNeighborsForbidTheSwap(u, v) {\n        const uCount = this.properLayeredGraph.InEdgesCount(u);\n        const vCount = this.properLayeredGraph.InEdgesCount(v);\n        if (uCount === 0 || vCount === 0)\n            return false;\n        return this.X[this.predecessors[u][uCount >> 1]] < this.X[this.predecessors[v][vCount >> 1]];\n    }\n    CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(layer, separatorPosition, separator) {\n        const kind = this.GetKindDelegate(separator);\n        let leftGroupSize = 0;\n        for (let i = separatorPosition - 1; i >= 0 && !kind(layer[i]); i--)\n            leftGroupSize++;\n        let rightGroupSize = 0;\n        for (let i = separatorPosition + 1; i < layer.length && !kind(layer[i]); i++)\n            rightGroupSize++;\n        return leftGroupSize - rightGroupSize;\n    }\n    IsOriginal(v) {\n        return v < this.startOfVirtNodes;\n    }\n    IsVirtual(v) {\n        return v >= this.startOfVirtNodes;\n    }\n    GetKindDelegate(v) {\n        return this.IsVirtual(v) ? this.IsVirtual : this.IsOriginal;\n    }\n    // swaps two vertices only if reduces the number of intersections\n    SwapWithGain(u, v) {\n        const gain = this.SwapGain(u, v);\n        if (gain > 0) {\n            this.Swap(u, v);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=ordering.js.map","export class OrderingMeasure {\n    constructor(layerArraysPar, numOfCrossings, virtualVertexStart) {\n        this.numberOfCrossings = numOfCrossings;\n        this.la = layerArraysPar;\n        this.virtVertexStart = virtualVertexStart;\n    }\n    LayerGroupDisbalance(l, origGroupOptSize, virtGroupOptSize) {\n        if (origGroupOptSize === 1)\n            return this.LayerGroupDisbalanceWithOrigSeparators(l, virtGroupOptSize);\n        else\n            return this.LayerGroupDisbalanceWithVirtSeparators(l, origGroupOptSize);\n    }\n    LayerGroupDisbalanceWithVirtSeparators(l, origGroupOptSize) {\n        let ret = 0;\n        for (let i = 0; i < l.length;) {\n            const r = this.CurrentOrigGroupDelta(i, l, origGroupOptSize);\n            i = r.i;\n            ret += r.ret;\n        }\n        return ret;\n    }\n    CurrentOrigGroupDelta(i, l, origGroupOptSize) {\n        let groupSize = 0;\n        let j = i;\n        for (; j < l.length && l[j] < this.virtVertexStart; j++)\n            groupSize++;\n        i = j + 1;\n        return { ret: Math.abs(origGroupOptSize - groupSize), i };\n    }\n    LayerGroupDisbalanceWithOrigSeparators(l, virtGroupOptSize) {\n        let ret = 0;\n        for (let i = 0; i < l.length;) {\n            const r = this.CurrentVirtGroupDelta(i, l, virtGroupOptSize);\n            ret += r.ret;\n            i = r.i;\n        }\n        return ret;\n    }\n    CurrentVirtGroupDelta(i, l, virtGroupOptSize) {\n        let groupSize = 0;\n        let j = i;\n        for (; j < l.length && l[j] >= this.virtVertexStart; j++)\n            groupSize++;\n        i = j + 1;\n        return { ret: Math.abs(virtGroupOptSize - groupSize), i: i };\n    }\n    static less(a, b) {\n        return a.numberOfCrossings < b.numberOfCrossings;\n    }\n    static greater(a, b) {\n        return a.numberOfCrossings > b.numberOfCrossings;\n    }\n    IsPerfect() {\n        return this.numberOfCrossings === 0;\n    }\n}\n//# sourceMappingURL=orderingMeasure.js.map","import { LayerEdge } from './layerEdge';\nimport { LineSegment } from '../../math/geometry/lineSegment';\nimport { Curve } from '../../math/geometry/curve';\nimport { Point } from '../../math/geometry/point';\nclass Routing {\n    static FindClosestPoints(segmentInFrontOfLabel, labelSide) {\n        const minDistOutput = Curve.minDistWithinIntervals(segmentInFrontOfLabel, labelSide, segmentInFrontOfLabel.parStart, segmentInFrontOfLabel.parEnd, labelSide.parStart, labelSide.parEnd, (segmentInFrontOfLabel.parStart + segmentInFrontOfLabel.parEnd) / 2, (labelSide.parStart + labelSide.parEnd) / 2);\n        if (minDistOutput) {\n            return {\n                curveClosestPoint: minDistOutput.aX,\n                labelSideClosest: minDistOutput.bX,\n            };\n        }\n        return;\n    }\n    static GetSegmentInFrontOfLabel(edgeCurve, labelY) {\n        if (edgeCurve instanceof Curve) {\n            for (const seg of edgeCurve.segs)\n                if ((seg.start.y - labelY) * (seg.end.y - labelY) <= 0)\n                    return seg;\n        }\n        else {\n            /*Assert.assert(false)*/\n        }\n        return null;\n    }\n    static ShiftLabel(e, curveClosestPoint, labelSideClosest) {\n        const w = e.lineWidth / 2;\n        const shift = curveClosestPoint.sub(labelSideClosest);\n        const shiftLength = shift.length;\n        //  SugiyamaLayoutSettings.Show(e.Curve, shiftLength > 0 ? new LineSegment(curveClosestPoint, labelSideClosest) : null, PolyFromBox(e.label.boundingBox));\n        if (shiftLength > w)\n            e.label.positionCenter(e.label.center.add(shift.div(shiftLength * (shiftLength - w))));\n    }\n    static updateLabel(e, anchor) {\n        let labelSide = null;\n        if (anchor.labelIsToTheRightOfTheSpline) {\n            e.label.positionCenter(new Point(anchor.x + anchor.rightAnchor / 2, anchor.y));\n            labelSide = LineSegment.mkPP(e.label.boundingBox.leftTop, e.label.boundingBox.leftBottom);\n        }\n        else if (anchor.labelIsToTheLeftOfTheSpline) {\n            e.label.positionCenter(new Point(anchor.x - anchor.leftAnchor / 2, anchor.y));\n            labelSide = LineSegment.mkPP(e.label.boundingBox.rightTop, e.label.boundingBox.rightBottom);\n        }\n        const segmentInFrontOfLabel = Routing.GetSegmentInFrontOfLabel(e.curve, e.label.center.y);\n        if (segmentInFrontOfLabel == null)\n            return;\n        if (Curve.getAllIntersections(e.curve, Curve.polyFromBox(e.label.boundingBox), false).length === 0) {\n            const t = Routing.FindClosestPoints(segmentInFrontOfLabel, labelSide);\n            if (t) {\n                //shift the label if needed\n                Routing.ShiftLabel(e, t.curveClosestPoint, t.labelSideClosest);\n            }\n            else {\n                let curveClosestPoint;\n                let labelSideClosest;\n                //assume that the distance is reached at the ends of labelSideClosest\n                const u = segmentInFrontOfLabel.closestParameter(labelSide.start);\n                const v = segmentInFrontOfLabel.closestParameter(labelSide.end);\n                if (segmentInFrontOfLabel.value(u).sub(labelSide.start).length < segmentInFrontOfLabel.value(v).sub(labelSide.end).length) {\n                    curveClosestPoint = segmentInFrontOfLabel.value(u);\n                    labelSideClosest = labelSide.start;\n                }\n                else {\n                    curveClosestPoint = segmentInFrontOfLabel.value(v);\n                    labelSideClosest = labelSide.end;\n                }\n                Routing.ShiftLabel(e, curveClosestPoint, labelSideClosest);\n            }\n        }\n    }\n}\n// An edge with source and target represented as integers,\n// they point to the array of Nodes of the graph\nexport class PolyIntEdge {\n    get CrossingWeight() {\n        return 1;\n    }\n    constructor(source, target, geomEdge, weight = 1, separation = 1) {\n        this.reversed = false;\n        this.source = source;\n        this.target = target;\n        this.edge = geomEdge;\n        this.weight = weight;\n        this.separation = separation;\n    }\n    get hasLabel() {\n        return this.edge.label != null;\n    }\n    get labelWidth() {\n        return this.edge.label.width;\n    }\n    get labelHeight() {\n        return this.edge.label.height;\n    }\n    // This function changes the edge by swapping source and target.\n    reverse() {\n        const t = this.source;\n        this.source = this.target;\n        this.target = t;\n        this.reversed = !this.reversed;\n    }\n    toString() {\n        return 'edge(' + this.source + '->' + this.target + ')';\n    }\n    get curve() {\n        return this.edge.curve;\n    }\n    set curve(value) {\n        this.edge.curve = value;\n    }\n    get underlyingPolyline() {\n        return this.edge.smoothedPolyline;\n    }\n    get LayerSpan() {\n        return this.LayerEdges != null ? this.LayerEdges.length : 0;\n    }\n    isSelfEdge() {\n        return this.source === this.target;\n    }\n    reversedClone() {\n        const ret = new PolyIntEdge(this.target, this.source, this.edge);\n        if (this.LayerEdges != null) {\n            const len = this.LayerEdges.length;\n            ret.LayerEdges = new Array(len);\n            for (let i = 0; i < len; i++) {\n                const le = this.LayerEdges[len - 1 - i];\n                ret.LayerEdges[i] = new LayerEdge(le.Target, le.Source, le.CrossingWeight);\n            }\n            ret.LayerEdges[0].Source = this.target;\n            ret.LayerEdges[this.LayerEdges.length - 1].Target = this.source;\n        }\n        return ret;\n    }\n    get count() {\n        return this.LayerEdges.length;\n    }\n    getNode(i) {\n        if (i >= 0) {\n            if (i < this.LayerEdges.length)\n                return this.LayerEdges[i].Source;\n            if (i === this.LayerEdges.length)\n                return this.LayerEdges[i - 1].Target;\n        }\n        throw new Error('wrong index ' + i);\n    }\n    updateEdgeLabelPosition(anchors) {\n        if (this.edge.label != null) {\n            const m = this.LayerEdges.length / 2;\n            const layerEdge = this.LayerEdges[m];\n            Routing.updateLabel(this.edge, anchors[layerEdge.Source]);\n        }\n    }\n    [Symbol.iterator]() {\n        return this.nodes();\n    }\n    // enumerates over virtual virtices corresponding to the original edge\n    *nodes() {\n        yield this.LayerEdges[0].Source;\n        for (const le of this.LayerEdges)\n            yield le.Target;\n    }\n}\n//# sourceMappingURL=polyIntEdge.js.map","import { Curve } from '../../math/geometry/curve';\nimport { LineSegment } from '../../math/geometry/lineSegment';\nimport { Point } from '../../math/geometry/point';\nimport { Rectangle } from '../../math/geometry/rectangle';\nimport { SmoothedPolyline } from '../../math/geometry/smoothedPolyline';\nimport { Algorithm } from './../../utils/algorithm';\nimport { SugiyamaLayoutSettings } from './sugiyamaLayoutSettings';\n//import { FlatEdgeRouter } from './FlatEdgeRouter'\nimport { CornerSite } from '../../math/geometry/cornerSite';\nimport { NodeKind } from './NodeKind';\nimport { Arrowhead } from '../core/arrowhead';\nimport { SmoothedPolylineCalculator } from './smoothedPolylineCalculator';\nimport { SplineRouter } from '../../routing/splineRouter';\nimport { EdgeLabelPlacement } from '../edgeLabelPlacement';\n// The class responsible for the routing of splines\nexport class Routing extends Algorithm {\n    constructor(settings, originalGraph, dbP, yLayerArrays, properLayeredGraph, intGraph) {\n        super(null); // todo: init with the not null canceltoken\n        this.settings = settings;\n        this.OriginalGraph = originalGraph;\n        this.Database = dbP;\n        this.ProperLayeredGraph = properLayeredGraph;\n        this.LayerArrays = yLayerArrays;\n        this.IntGraph = intGraph;\n    }\n    // Executes the actual algorithm.\n    run() {\n        this.createSplines();\n    }\n    // The method does the main work.\n    createSplines() {\n        this.createRegularSplines();\n        this.createSelfSplines();\n        if (this.IntGraph != null) {\n            this.RouteFlatEdges();\n        }\n        if (this.OriginalGraph.graph.parent == null) {\n            // TODO: just creating straigh line edges for missing ones, hook up SplineRouter\n            this.RouteUnroutedEdges();\n        }\n    }\n    RouteUnroutedEdges() {\n        const edgesToRoute = [];\n        for (const e of this.OriginalGraph.deepEdges) {\n            if (!e.curve)\n                edgesToRoute.push(e);\n        }\n        if (edgesToRoute.length == 0) {\n            return;\n        }\n        const sugSettings = this.OriginalGraph.layoutSettings ? this.OriginalGraph.layoutSettings : new SugiyamaLayoutSettings();\n        const ers = sugSettings.commonSettings.edgeRoutingSettings;\n        const sr = new SplineRouter(this.OriginalGraph, edgesToRoute, ers.padding, ers.polylinePadding, ers.coneAngle, ers.bundlingSettings, this.cancelToken);\n        sr.run();\n        const elp = EdgeLabelPlacement.constructorGA(this.OriginalGraph, edgesToRoute);\n        elp.run();\n    }\n    RouteFlatEdges() {\n        // throw new Error('not implemented')\n        // const flatEdgeRouter = new FlatEdgeRouter(this.settings, this)\n        // flatEdgeRouter.run()\n    }\n    createRegularSplines() {\n        for (const intEdgeList of this.Database.RegularMultiedges()) {\n            if (betterRouteAsSplines(intEdgeList))\n                continue;\n            // Here we try to optimize multi-edge routing\n            const m = intEdgeList.length;\n            const optimizeShortEdges = m === 1 && this.MayOptimizeEdge(intEdgeList[0]);\n            for (let i = Math.floor(m / 2); i < m; i++) {\n                this.createSplineForNonSelfEdge(intEdgeList[i], optimizeShortEdges);\n            }\n            for (let i = Math.floor(m / 2) - 1; i >= 0; i--) {\n                this.createSplineForNonSelfEdge(intEdgeList[i], optimizeShortEdges);\n            }\n        }\n    }\n    MayOptimizeEdge(intEdge) {\n        return !(this.ProperLayeredGraph.OutDegreeIsMoreThanOne(intEdge.source) ||\n            this.ProperLayeredGraph.InDegreeIsMoreThanOne(intEdge.target) ||\n            hasSelfEdge(intEdge.edge.source) ||\n            hasSelfEdge(intEdge.edge.target));\n    }\n    createSelfSplines() {\n        for (const [k, v] of this.Database.Multiedges.keyValues()) {\n            const ip = k;\n            if (ip.x === ip.y) {\n                const anchor = this.Database.Anchors[ip.x];\n                let offset = anchor.leftAnchor;\n                for (const intEdge of v) {\n                    const dx = this.settings.NodeSeparation + (this.settings.MinNodeWidth + offset);\n                    const dy = anchor.bottomAnchor / 2;\n                    const p0 = anchor.origin;\n                    const p1 = p0.add(new Point(0, dy));\n                    const p2 = p0.add(new Point(dx, dy));\n                    const p3 = p0.add(new Point(dx, -dy));\n                    const p4 = p0.add(new Point(0, -dy));\n                    let s = CornerSite.mkSiteP(p0);\n                    const polyline = new SmoothedPolyline(s);\n                    s = CornerSite.mkSiteSP(s, p1);\n                    s = CornerSite.mkSiteSP(s, p2);\n                    s = CornerSite.mkSiteSP(s, p3);\n                    s = CornerSite.mkSiteSP(s, p4);\n                    CornerSite.mkSiteSP(s, p0);\n                    const c = polyline.createCurve();\n                    intEdge.curve = c;\n                    offset = dx;\n                    if (intEdge.edge.label != null) {\n                        offset += intEdge.edge.label.width;\n                        const curveMiddle = c.value((c.parStart + c.parEnd) / 2);\n                        const center = new Point(curveMiddle.x + intEdge.labelWidth / 2, anchor.y);\n                        const del = new Point(intEdge.edge.label.width / 2, intEdge.edge.label.height / 2);\n                        const box = Rectangle.mkPP(center.add(del), center.sub(del));\n                        intEdge.edge.label.width = box.width;\n                        intEdge.edge.label.height = box.height;\n                        intEdge.edge.label.positionCenter(center);\n                    }\n                    Arrowhead.trimSplineAndCalculateArrowheadsII(intEdge.edge, intEdge.edge.source.boundaryCurve, intEdge.edge.target.boundaryCurve, c, false);\n                }\n            }\n        }\n    }\n    createSplineForNonSelfEdge(es, optimizeShortEdges) {\n        if (es.LayerEdges != null) {\n            this.drawSplineBySmothingThePolyline(es, optimizeShortEdges);\n            if (!es.IsVirtualEdge) {\n                es.updateEdgeLabelPosition(this.Database.Anchors);\n                Arrowhead.trimSplineAndCalculateArrowheadsII(es.edge, es.edge.source.boundaryCurve, es.edge.target.boundaryCurve, es.curve, true);\n            }\n        }\n    }\n    drawSplineBySmothingThePolyline(edgePath, optimizeShortEdges) {\n        const scalc = new SmoothedPolylineCalculator(edgePath, this.Database.Anchors, this.OriginalGraph, this.settings, this.LayerArrays, this.ProperLayeredGraph, this.Database);\n        const spline = scalc.getSpline(optimizeShortEdges);\n        if (edgePath.reversed) {\n            edgePath.curve = spline.reverse();\n        }\n        else {\n            edgePath.curve = spline;\n        }\n    }\n    // void UpdateEdgeLabelPosition(LayerEdge[][] list, int i) {\n    //    IntEdge e;\n    //    int labelNodeIndex;\n    //    if (Engine.GetLabelEdgeAndVirtualNode(list, i, out e, out labelNodeIndex)) {\n    //        UpdateLabel(e, labelNodeIndex, db.Anchors);\n    //    }\n    // }\n    static UpdateLabel(e, anchor) {\n        let labelSide = null;\n        if (anchor.labelIsToTheRightOfTheSpline) {\n            e.label.positionCenter(new Point(anchor.x + anchor.rightAnchor / 2, anchor.y));\n            labelSide = LineSegment.mkPP(e.label.boundingBox.leftTop, e.label.boundingBox.leftBottom);\n        }\n        else if (anchor.labelIsToTheLeftOfTheSpline) {\n            e.label.positionCenter(new Point(anchor.x - anchor.leftAnchor / 2, anchor.y));\n            labelSide = LineSegment.mkPP(e.label.boundingBox.rightTop, e.label.boundingBox.rightBottom);\n        }\n        const segmentInFrontOfLabel = Routing.GetSegmentInFrontOfLabel(e.curve, e.label.center.y);\n        if (segmentInFrontOfLabel == null) {\n            return;\n        }\n        if (Curve.getAllIntersections(e.curve, Curve.polyFromBox(e.label.boundingBox), false).length === 0) {\n            const t = {\n                curveClosestPoint: undefined,\n                labelSideClosest: undefined,\n            };\n            if (Routing.FindClosestPoints(t, segmentInFrontOfLabel, labelSide)) {\n                // shift the label if needed\n                Routing.ShiftLabel(e, t);\n            }\n            else {\n                // assume that the distance is reached at the ends of labelSideClosest\n                const u = segmentInFrontOfLabel.closestParameter(labelSide.start);\n                const v = segmentInFrontOfLabel.closestParameter(labelSide.end);\n                if (segmentInFrontOfLabel.value(u).sub(labelSide.start).length < segmentInFrontOfLabel.value(v).sub(labelSide.end).length) {\n                    t.curveClosestPoint = segmentInFrontOfLabel.value(u);\n                    t.labelSideClosest = labelSide.start;\n                }\n                else {\n                    t.curveClosestPoint = segmentInFrontOfLabel.value(v);\n                    t.labelSideClosest = labelSide.end;\n                }\n                Routing.ShiftLabel(e, t);\n            }\n        }\n    }\n    static ShiftLabel(e, t) {\n        const w = e.lineWidth / 2;\n        const shift = t.curveClosestPoint.sub(t.labelSideClosest);\n        const shiftLength = shift.length;\n        //   SugiyamaLayoutSettings.Show(e.Curve, shiftLength > 0 ? new LineSegment(curveClosestPoint, labelSideClosest) : null, PolyFromBox(e.label.boundingBox));\n        if (shiftLength > w) {\n            e.label.positionCenter(e.label.center.add(shift.div(shiftLength * (shiftLength - w))));\n        }\n    }\n    static FindClosestPoints(t, segmentInFrontOfLabel, labelSide) {\n        const di = Curve.minDistWithinIntervals(segmentInFrontOfLabel, labelSide, segmentInFrontOfLabel.parStart, segmentInFrontOfLabel.parEnd, labelSide.parStart, labelSide.parEnd, (segmentInFrontOfLabel.parStart + segmentInFrontOfLabel.parEnd) / 2, (labelSide.parStart + labelSide.parEnd) / 2);\n        if (di) {\n            t.curveClosestPoint = di.aX;\n            t.labelSideClosest = di.bX;\n            return true;\n        }\n        return false;\n    }\n    static GetSegmentInFrontOfLabel(edgeCurve, labelY) {\n        if (edgeCurve instanceof Curve) {\n            const curve = edgeCurve;\n            for (const seg of curve.segs) {\n                if ((seg.start.y - labelY) * (seg.end.y - labelY) <= 0) {\n                    return seg;\n                }\n            }\n        }\n        else {\n            /*Assert.assert(false)*/\n        }\n        // not implemented\n        return null;\n    }\n    static GetNodeKind(vertexOffset, edgePath) {\n        return vertexOffset === 0 ? NodeKind.Top : vertexOffset < edgePath.count ? NodeKind.Internal : NodeKind.Bottom;\n    }\n}\nfunction betterRouteAsSplines(intEdgeList) {\n    if (intEdgeList.length < 4)\n        return false;\n    for (const pie of intEdgeList)\n        if (pie.edge.label)\n            return false;\n    return true;\n}\nfunction hasSelfEdge(geomNode) {\n    return geomNode.node.selfEdges.size > 0;\n}\n//# sourceMappingURL=routing.js.map","import { CornerSite } from '../../math/geometry/cornerSite';\nimport { Curve } from '../../math/geometry/curve';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { LineSegment } from '../../math/geometry/lineSegment';\nimport { Parallelogram } from '../../math/geometry/parallelogram';\nimport { Point, TriangleOrientation } from '../../math/geometry/point';\nimport { SmoothedPolyline } from '../../math/geometry/smoothedPolyline';\nimport { HierarchyCalculator } from './HierarchyCalculator';\nimport { Routing } from './routing';\nimport { NodeKind } from './NodeKind';\nimport { RefinerBetweenTwoLayers } from './RefinerBetweenTwoLayers';\nimport { closeDistEps } from '../../utils/compare';\nexport class SmoothedPolylineCalculator {\n    // Creates a smoothed polyline\n    constructor(edgePathPar, anchorsP, origGraph, settings, la, layerGraph, databaseP) {\n        this.thinRightNodes = new Array();\n        this.thinWestNodes = new Array();\n        this.database = databaseP;\n        this.edgePath = edgePathPar;\n        this.anchors = anchorsP;\n        this.layerArrays = la;\n        this.originalGraph = origGraph;\n        this.settings = settings;\n        this.layeredGraph = layerGraph;\n        this.eastHierarchy = this.BuildEastHierarchy();\n        this.westHierarchy = this.BuildWestHierarchy();\n    }\n    BuildEastHierarchy() {\n        const boundaryAnchorsCurves = this.FindEastBoundaryAnchorCurves();\n        const l = new Array();\n        for (const c of boundaryAnchorsCurves) {\n            l.push(c.pNodeOverICurve());\n        }\n        this.thinEastHierarchy = HierarchyCalculator.Calculate(this.thinRightNodes);\n        return HierarchyCalculator.Calculate(l);\n    }\n    BuildWestHierarchy() {\n        const boundaryAnchorCurves = this.FindWestBoundaryAnchorCurves();\n        const l = new Array();\n        for (const a of boundaryAnchorCurves) {\n            l.push(a.pNodeOverICurve());\n        }\n        this.thinWestHierarchy = HierarchyCalculator.Calculate(this.thinWestNodes);\n        return HierarchyCalculator.Calculate(l);\n    }\n    FindEastBoundaryAnchorCurves() {\n        const ret = new Array();\n        let uOffset = 0;\n        for (const u of this.edgePath) {\n            let westMostAnchor = null;\n            for (const v of this.EastBoundaryNodesOfANode(u, Routing.GetNodeKind(uOffset, this.edgePath))) {\n                const a = this.anchors[v];\n                if (westMostAnchor == null || westMostAnchor.origin.x > a.origin.x) {\n                    westMostAnchor = a;\n                }\n                ret.push(a.polygonalBoundary);\n            }\n            if (westMostAnchor != null) {\n                this.thinRightNodes.push(LineSegment.mkLinePXY(westMostAnchor.origin, this.originalGraph.right, westMostAnchor.y).pNodeOverICurve());\n            }\n            uOffset++;\n        }\n        // if (Routing.db) {\n        //    var l = new Array<DebugCurve>();\n        //       l.AddRange(db.Anchors.Select(a=>new DebugCurve(100,1,\"red\", a.PolygonalBoundary)));\n        //    l.AddRange(thinRightNodes.Select(n=>n.parallelogram).Select(p=>new Polyline(p.Vertex(VertexId.Corner), p.Vertex(VertexId.VertexA),\n        //        p.Vertex(VertexId.OtherCorner), p.Vertex(VertexId.VertexB))).Select(c=>new DebugCurve(100,3,\"brown\", c)));\n        //    foreach (var le of this.edgePath.LayerEdges)\n        //        l. push(new DebugCurve(100, 1, \"blue\", LineSegment.mkPP(db.anchors[le.Source].Origin, db.anchors[le.Target].Origin)));\n        //   LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n        //    // Database(db, thinRightNodes.Select(p=>new Polyline(p.parallelogram.Vertex(VertexId.Corner), p.parallelogram.Vertex(VertexId.VertexA),\n        //        //p.parallelogram.Vertex(VertexId.OtherCorner), p.parallelogram.Vertex(VertexId.VertexB)){Closed=true}).ToArray());\n        // }\n        return ret;\n    }\n    FindWestBoundaryAnchorCurves() {\n        const ret = [];\n        let uOffset = 0;\n        for (const u of this.edgePath.nodes()) {\n            let eastMost = -1;\n            for (const v of this.LeftBoundaryNodesOfANode(u, Routing.GetNodeKind(uOffset, this.edgePath))) {\n                if (eastMost === -1 || this.layerArrays.x[v] > this.layerArrays.x[eastMost]) {\n                    eastMost = v;\n                }\n                ret.push(this.anchors[v].polygonalBoundary);\n            }\n            if (eastMost !== -1) {\n                const a = this.anchors[eastMost];\n                this.thinWestNodes.push(LineSegment.mkLinePXY(a.origin, this.originalGraph.left, a.origin.y).pNodeOverICurve());\n            }\n            uOffset++;\n        }\n        return ret;\n    }\n    *FillRightTopAndBottomVerts(layer, vPosition, nodeKind) {\n        let b = 0;\n        let t = 0;\n        if (nodeKind === NodeKind.Bottom) {\n            b = Number.MAX_VALUE;\n            // we don't have bottom boundaries here since they will be cut off\n        }\n        else if (nodeKind === NodeKind.Top) {\n            t = Number.MAX_VALUE;\n            // we don't have top boundaries here since they will be cut off\n        }\n        const v = layer[vPosition];\n        for (let i = vPosition + 1; i < layer.length; i++) {\n            const u = layer[i];\n            const anchor = this.anchors[u];\n            if (anchor.topAnchor > t) {\n                if (!this.NodeUCanBeCrossedByNodeV(u, v)) {\n                    t = anchor.topAnchor;\n                    if (anchor.bottomAnchor > b) {\n                        b = anchor.bottomAnchor;\n                    }\n                    yield u;\n                }\n            }\n            else if (anchor.bottomAnchor > b) {\n                if (!this.NodeUCanBeCrossedByNodeV(u, v)) {\n                    b = anchor.bottomAnchor;\n                    if (anchor.topAnchor > t) {\n                        t = anchor.topAnchor;\n                    }\n                    yield u;\n                }\n            }\n        }\n    }\n    *FillLeftTopAndBottomVerts(layer, vPosition, nodeKind) {\n        let b = 0;\n        let t = 0;\n        if (nodeKind === NodeKind.Top) {\n            t = Number.MAX_VALUE; // there are no top vertices - they are cut down by the top boundaryCurve curve\n        }\n        else if (nodeKind === NodeKind.Bottom) {\n            b = Number.MAX_VALUE; // there are no bottom vertices - they are cut down by the top boundaryCurve curve\n        }\n        const v = layer[vPosition];\n        for (let i = vPosition - 1; i >= 0; i--) {\n            const u = layer[i];\n            const anchor = this.anchors[u];\n            if (anchor.topAnchor > t + GeomConstants.distanceEpsilon) {\n                if (!this.NodeUCanBeCrossedByNodeV(u, v)) {\n                    t = anchor.topAnchor;\n                    b = Math.max(b, anchor.bottomAnchor);\n                    yield u;\n                }\n            }\n            else if (anchor.bottomAnchor > b + GeomConstants.distanceEpsilon) {\n                if (!this.NodeUCanBeCrossedByNodeV(u, v)) {\n                    t = Math.max(t, anchor.topAnchor);\n                    b = anchor.bottomAnchor;\n                    yield u;\n                }\n            }\n        }\n    }\n    IsVirtualVertex(v) {\n        return v >= this.originalGraph.shallowNodeCount;\n    }\n    IsLabel(u) {\n        return this.anchors[u].hasLabel;\n    }\n    NodeUCanBeCrossedByNodeV(u, v) {\n        if (this.IsLabel(u)) {\n            return false;\n        }\n        if (this.IsLabel(v)) {\n            return false;\n        }\n        if (this.IsVirtualVertex(u) && this.IsVirtualVertex(v) && this.EdgesIntersectSomewhere(u, v)) {\n            return true;\n        }\n        return false;\n    }\n    EdgesIntersectSomewhere(u, v) {\n        if (this.UVAreMiddlesOfTheSameMultiEdge(u, v)) {\n            return false;\n        }\n        return this.IntersectAbove(u, v) || this.IntersectBelow(u, v);\n    }\n    UVAreMiddlesOfTheSameMultiEdge(u, v) {\n        if (this.database.MultipleMiddles.has(u) &&\n            this.database.MultipleMiddles.has(v) &&\n            this.SourceOfTheOriginalEdgeContainingAVirtualNode(u) === this.SourceOfTheOriginalEdgeContainingAVirtualNode(v)) {\n            return true;\n        }\n        return false;\n    }\n    SourceOfTheOriginalEdgeContainingAVirtualNode(u) {\n        while (this.IsVirtualVertex(u)) {\n            u = this.IncomingEdge(u).Source;\n        }\n        return u;\n    }\n    IntersectBelow(u, v) {\n        do {\n            const eu = this.OutcomingEdge(u);\n            const ev = this.OutcomingEdge(v);\n            if (this.Intersect(eu, ev)) {\n                return true;\n            }\n            u = eu.Target;\n            v = ev.Target;\n        } while (this.IsVirtualVertex(u) && this.IsVirtualVertex(v));\n        return u === v;\n    }\n    IntersectAbove(u, v) {\n        do {\n            const eu = this.IncomingEdge(u);\n            const ev = this.IncomingEdge(v);\n            if (this.Intersect(eu, ev)) {\n                return true;\n            }\n            u = eu.Source;\n            v = ev.Source;\n        } while (this.IsVirtualVertex(u) && this.IsVirtualVertex(v));\n        return u === v;\n    }\n    Intersect(e, m) {\n        const a = this.layerArrays.x[e.Source] - this.layerArrays.x[m.Source];\n        const b = this.layerArrays.x[e.Target] - this.layerArrays.x[m.Target];\n        return (a > 0 && b < 0) || (a < 0 && b > 0);\n        // return (layerArrays.x[e.Source] - layerArrays.x[m.Source]) * (layerArrays.x[e.Target] - layerArrays.x[m.Target]) < 0;\n    }\n    IncomingEdge(u) {\n        return this.layeredGraph.InEdgeOfVirtualNode(u);\n    }\n    // here u is a virtual vertex\n    OutcomingEdge(u) {\n        return this.layeredGraph.OutEdgeOfVirtualNode(u);\n    }\n    EastBoundaryNodesOfANode(i, nodeKind) {\n        return this.FillRightTopAndBottomVerts(this.NodeLayer(i), this.layerArrays.x[i], nodeKind);\n    }\n    NodeLayer(i) {\n        return this.layerArrays.Layers[this.layerArrays.y[i]];\n    }\n    LeftBoundaryNodesOfANode(i, nodeKind) {\n        return this.FillLeftTopAndBottomVerts(this.NodeLayer(i), this.layerArrays.x[i], nodeKind);\n    }\n    getSpline(optimizeShortEdges) {\n        this.createRefinedPolyline(optimizeShortEdges);\n        return this.createSmoothedPolyline();\n    }\n    // Poly(): Curve {\n    //  const c: Curve = new Curve()\n    //  for (let s = this.headSite; s.next != null; s = s.next) {\n    //    c.addSegment(\n    //      new BezierSeg(s.point, Point.convSum(1 / 3, s.point, s.next.point), Point.convSum(2 / 3, s.point, s.next.point), s.next.point),\n    //    )\n    //  }\n    //  return c\n    // }\n    get GetPolyline() {\n        /*Assert.assert(this.headSite != null)*/\n        return new SmoothedPolyline(this.headSite);\n    }\n    LineSegIntersectBound(a, b) {\n        const l = LineSegment.mkPP(a, b);\n        return (SmoothedPolylineCalculator.CurveIntersectsHierarchy(l, this.westHierarchy) ||\n            SmoothedPolylineCalculator.CurveIntersectsHierarchy(l, this.thinWestHierarchy) ||\n            SmoothedPolylineCalculator.CurveIntersectsHierarchy(l, this.eastHierarchy) ||\n            SmoothedPolylineCalculator.CurveIntersectsHierarchy(l, this.thinEastHierarchy));\n    }\n    SegIntersectWestBound(a, b) {\n        return (SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.westHierarchy) ||\n            SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.thinWestHierarchy));\n    }\n    SegIntersectEastBound(a, b) {\n        return (SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.eastHierarchy) ||\n            SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.thinEastHierarchy));\n    }\n    TryToRemoveInflectionCorner(t) {\n        if (!t.s.next ||\n            !t.s.prev ||\n            (t.s.turn === TriangleOrientation.Counterclockwise && this.SegIntersectEastBound(t.s.prev, t.s.next)) ||\n            (t.s.turn === TriangleOrientation.Clockwise && this.SegIntersectWestBound(t.s.prev, t.s.next))) {\n            t.cut = false;\n            t.s = t.s.next;\n            return;\n        }\n        // we have a cut\n        const nextS = t.s.next;\n        t.s.prev.next = nextS;\n        // forget about s\n        nextS.prev = t.s.prev;\n        t.s = nextS;\n        t.cut = true;\n    }\n    static SegIntersectsBound(a, b, hierarchy) {\n        return SmoothedPolylineCalculator.CurveIntersectsHierarchy(LineSegment.mkPP(a.point, b.point), hierarchy);\n    }\n    static CurveIntersectsHierarchy(lineSeg, hierarchy) {\n        if (hierarchy == null) {\n            return false;\n        }\n        if (!Parallelogram.intersect(lineSeg.pNodeOverICurve().parallelogram, hierarchy.parallelogram)) {\n            return false;\n        }\n        if (hierarchy.node.hasOwnProperty('children')) {\n            const n = hierarchy.node;\n            const ret = SmoothedPolylineCalculator.CurveIntersectsHierarchy(lineSeg, n.children[0]) ||\n                SmoothedPolylineCalculator.CurveIntersectsHierarchy(lineSeg, n.children[1]);\n            return ret;\n        }\n        return Curve.intersectionOne(lineSeg, hierarchy.seg, false) != null;\n    }\n    static Flat(i) {\n        return Point.getTriangleOrientation(i.prev.point, i.point, i.next.point) === TriangleOrientation.Collinear;\n    }\n    Reverse() {\n        const ret = new SmoothedPolylineCalculator(this.edgePath, this.anchors, this.originalGraph, this.settings, this.layerArrays, this.layeredGraph, this.database);\n        let site = this.headSite;\n        let v = null;\n        while (site != null) {\n            ret.headSite = site.clone();\n            ret.headSite.next = v;\n            if (v != null) {\n                v.prev = ret.headSite;\n            }\n            v = ret.headSite;\n            site = site.next;\n        }\n        return ret;\n    }\n    createRefinedPolyline(optimizeShortEdges) {\n        this.CreateInitialListOfSites();\n        let topSite = this.headSite;\n        let bottomSite;\n        for (let i = 0; i < this.edgePath.count; i++) {\n            bottomSite = topSite.next;\n            this.RefineBeetweenNeighborLayers(topSite, this.EdgePathNode(i), this.EdgePathNode(i + 1));\n            topSite = bottomSite;\n        }\n        this.TryToRemoveInflections();\n        if (optimizeShortEdges) {\n            this.OptimizeShortPath();\n        }\n        //Assert.assert(this.)\n    }\n    RefineBeetweenNeighborLayers(topSite, topNode, bottomNode) {\n        RefinerBetweenTwoLayers.Refine(topNode, bottomNode, topSite, this.anchors, this.layerArrays, this.layeredGraph, this.originalGraph, this.settings.LayerSeparation);\n    }\n    CreateInitialListOfSites() {\n        let currentSite = (this.headSite = CornerSite.mkSiteP(this.EdgePathPoint(0)));\n        for (let i = 1; i <= this.edgePath.count; i++) {\n            currentSite = CornerSite.mkSiteSP(currentSite, this.EdgePathPoint(i));\n        }\n    }\n    get TailSite() {\n        let s = this.headSite;\n        while (s.next != null) {\n            s = s.next;\n        }\n        return s;\n    }\n    OptimizeForThreeSites() {\n        /*Assert.assert(this.edgePath.LayerEdges.length === 2)*/\n        const top = this.EdgePathNode(0);\n        const bottom = this.EdgePathNode(2);\n        const a = this.anchors[top];\n        const b = this.anchors[bottom];\n        if (closeDistEps(a.x, b.x)) {\n            return;\n        }\n        const t = { ax: a.x, bx: b.x, sign: 0 };\n        if (!this.FindLegalPositions(a, b, t)) {\n            return;\n        }\n        const ratio = (a.y - b.y) / (a.bottom - b.top);\n        const xc = 0.5 * (t.ax + t.bx);\n        const half = t.sign * ((t.ax - t.bx) * 0.5);\n        t.ax = xc + ratio * (half * t.sign);\n        t.bx = xc - ratio * (half * t.sign);\n        this.headSite.point = new Point(t.ax, a.y);\n        const ms = this.headSite.next;\n        const mY = ms.point.y;\n        ms.point = new Point(this.MiddlePos(t.ax, t.bx, a, b, mY), mY);\n        ms.next.point = new Point(t.bx, b.y);\n        const ma = this.anchors[this.EdgePathNode(1)];\n        ma.x = ms.point.x;\n    }\n    OptimizeForTwoSites() {\n        /*Assert.assert(this.edgePath.LayerEdges.length === 1)*/\n        const top = this.EdgePathNode(0);\n        const bottom = this.EdgePathNode(1);\n        const a = this.anchors[top];\n        const b = this.anchors[bottom];\n        if (closeDistEps(a.x, b.x)) {\n            return;\n        }\n        const t = { ax: a.x, bx: b.x, sign: 0 };\n        if (!this.FindPositions(a, b, t)) {\n            return;\n        }\n        const ratio = (a.y - b.y) / (a.bottom - b.top);\n        const xc = 0.5 * (t.ax + t.bx);\n        const half = t.sign * ((t.ax - t.bx) * 0.5);\n        t.ax = xc + ratio * (half * t.sign);\n        t.bx = xc - ratio * (half * t.sign);\n        this.headSite.point = new Point(t.ax, a.y);\n        this.headSite.next.point = new Point(t.bx, b.y);\n    }\n    FindLegalPositions(a, b, t) {\n        if (!this.FindPositions(a, b, t)) {\n            return false;\n        }\n        return this.PositionsAreLegal(t.ax, t.bx, t.sign, a, b, this.EdgePathNode(1));\n    }\n    FindPositions(a, b, t) {\n        let overlapMax;\n        let overlapMin;\n        if (t.ax < t.bx) {\n            t.sign = 1;\n            overlapMin = Math.max(t.ax, b.left);\n            overlapMax = Math.min(a.right, t.bx);\n        }\n        else {\n            t.sign = -1;\n            overlapMin = Math.max(a.left, t.bx);\n            overlapMax = Math.min(b.right, t.ax);\n        }\n        if (overlapMin <= overlapMax) {\n            t.bx = 0.5 * (overlapMin + overlapMax);\n            t.ax = 0.5 * (overlapMin + overlapMax);\n        }\n        else {\n            if (this.OriginToOriginSegCrossesAnchorSide(a, b)) {\n                return false;\n            }\n            if (t.sign === 1) {\n                t.ax = a.right - 0.1 * a.rightAnchor;\n                t.bx = b.left;\n            }\n            else {\n                t.ax = a.left + 0.1 * a.leftAnchor;\n                t.bx = b.right;\n            }\n        }\n        return true;\n    }\n    OriginToOriginSegCrossesAnchorSide(a, b) {\n        /*Assert.assert(a.y > b.y)*/\n        const seg = LineSegment.mkPP(a.origin, b.origin);\n        return ((a.x < b.x && Curve.CurvesIntersect(seg, LineSegment.mkPP(a.rightBottom, a.rightTop))) ||\n            Curve.CurvesIntersect(seg, LineSegment.mkPP(b.leftBottom, a.leftTop)) ||\n            (a.x > b.x && Curve.CurvesIntersect(seg, LineSegment.mkPP(a.leftBottom, a.leftTop))) ||\n            Curve.CurvesIntersect(seg, LineSegment.mkPP(b.rightBottom, a.rightTop)));\n    }\n    OptimizeShortPath() {\n        if (this.edgePath.count > 2) {\n            return;\n        }\n        if (this.edgePath.count === 2 &&\n            this.headSite.next.next != null &&\n            this.headSite.next.next.next == null &&\n            this.anchors[this.EdgePathNode(1)].node == null) {\n            this.OptimizeForThreeSites();\n        }\n        else if (this.edgePath.count === 1) {\n            this.OptimizeForTwoSites();\n        }\n    }\n    PositionsAreLegal(sax, sbx, sign, a, b, middleNodeIndex) {\n        if (!closeDistEps(sax, sbx) && (sax - sbx) * sign > 0) {\n            return false;\n        }\n        const mAnchor = this.anchors[middleNodeIndex];\n        const mx = this.MiddlePos(sax, sbx, a, b, mAnchor.y);\n        if (!this.MiddleAnchorLegal(mx, middleNodeIndex, mAnchor)) {\n            return false;\n        }\n        return !this.LineSegIntersectBound(new Point(sax, a.bottom), new Point(sbx, b.top));\n    }\n    MiddleAnchorLegal(mx, middleNodeIndex, mAnchor) {\n        const mLayer = this.NodeLayer(middleNodeIndex);\n        const pos = this.layerArrays.x[middleNodeIndex];\n        const shift = mx - mAnchor.x;\n        if (pos > 0) {\n            const l = this.anchors[mLayer[pos - 1]];\n            if (l.right > shift + mAnchor.left) {\n                return false;\n            }\n        }\n        if (pos < mLayer.length - 1) {\n            const r = this.anchors[mLayer[pos + 1]];\n            if (r.left < shift + mAnchor.right) {\n                return false;\n            }\n        }\n        return true;\n    }\n    MiddlePos(sax, sbx, a, b, mY) {\n        const u = a.y - mY;\n        const l = mY - b.y;\n        /*Assert.assert(u >= 0 && l >= 0)*/\n        return (sax * u + sbx * l) / (u + l);\n    }\n    TryToRemoveInflections() {\n        if (this.TurningAlwaySameDirection()) {\n            return;\n        }\n        let progress = true;\n        while (progress) {\n            progress = false;\n            for (const t = { s: this.headSite, cut: false }; t.s;) {\n                this.TryToRemoveInflectionCorner(t);\n                progress = t.cut || progress;\n            }\n        }\n    }\n    TurningAlwaySameDirection() {\n        let sign = 0;\n        // undecided\n        for (let s = this.headSite.next; s != null && s.next != null; s = s.next) {\n            const nsign = s.turn;\n            if (sign === 0) {\n                // try to set the sign\n                if (nsign > 0) {\n                    sign = 1;\n                }\n                else if (nsign < 0) {\n                    sign = -1;\n                }\n            }\n            else if (sign * nsign < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    EdgePathPoint(i) {\n        return this.anchors[this.EdgePathNode(i)].origin;\n    }\n    EdgePathNode(i) {\n        return i === this.edgePath.count ? this.edgePath.LayerEdges[this.edgePath.count - 1].Target : this.edgePath.LayerEdges[i].Source;\n    }\n    createSmoothedPolyline() {\n        this.RemoveVerticesWithNoTurns();\n        let curve = new Curve();\n        const a = this.headSite;\n        const t = Curve.findCorner(a);\n        // the corner other end\n        if (t !== undefined) {\n            this.createFilletCurve(curve, { a: a, b: t.b, c: t.c });\n            curve = this.ExtendCurveToEndpoints(curve);\n        }\n        else {\n            curve.addSegment(LineSegment.mkPP(this.headSite.point, this.TailSite.point));\n        }\n        /*Assert.assert(this.curveIsLegal(curve))*/\n        return curve;\n    }\n    curveIsLegal(curve) {\n        return true;\n        for (const n of this.layeredGraph.BaseGraph.nodes) {\n            let i = this.edgePath.getNode(0);\n            if (n === this.layeredGraph.BaseGraph.nodes[i])\n                continue;\n            i = this.edgePath.getNode(this.edgePath.LayerEdges.length);\n            if (n === this.layeredGraph.BaseGraph.nodes[i])\n                continue;\n            const nc = n.boundaryCurve;\n            if (Curve.CurvesIntersect(nc, curve)) {\n                //  SvgDebugWriter.dumpICurves('./tmp/cross.svg', [nc, curve])\n                return false;\n            }\n        }\n        return true;\n    }\n    RemoveVerticesWithNoTurns() {\n        while (this.RemoveVerticesWithNoTurnsOnePass()) { }\n    }\n    RemoveVerticesWithNoTurnsOnePass() {\n        let ret = false;\n        for (let s = this.headSite; s.next != null && s.next.next != null; s = s.next) {\n            if (SmoothedPolylineCalculator.Flat(s.next)) {\n                ret = true;\n                s.next = s.next.next;\n                // crossing out s.next\n                s.next.prev = s;\n            }\n        }\n        return ret;\n    }\n    ExtendCurveToEndpoints(curve) {\n        let p = this.headSite.point;\n        if (!Point.closeDistEps(p, curve.start)) {\n            const nc = new Curve();\n            nc.addSegs([LineSegment.mkPP(p, curve.start), curve]);\n            curve = nc;\n        }\n        p = this.TailSite.point;\n        if (!Point.closeDistEps(p, curve.end)) {\n            curve.addSegment(LineSegment.mkPP(curve.end, p));\n        }\n        return curve;\n    }\n    createFilletCurve(curve, t) {\n        for (; true;) {\n            this.AddSmoothedCorner(t.a, t.b, t.c, curve);\n            t.a = t.b;\n            t.b = t.c;\n            if (t.b.next != null) {\n                t.c = t.b.next;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    AddSmoothedCorner(a, b, c, curve) {\n        let k = 0.5;\n        let seg;\n        do {\n            seg = Curve.createBezierSeg(k, k, a, b, c);\n            // SvgDebugWriter.dumpDebugCurves(\n            //  './tmp/' + ++SmoothedPolylineCalculator.count + 'sm.svg',\n            //  this.getDebugCurvesForCorner(a, b, c),\n            // )\n            b.previouisBezierCoefficient = k;\n            k /= 2;\n        } while (this.BezierSegIntersectsBoundary(seg));\n        k *= 2;\n        // that was the last k\n        if (k < 0.5) {\n            // one time try a smoother seg\n            k = 0.5 * (k + k * 2);\n            const nseg = Curve.createBezierSeg(k, k, a, b, c);\n            if (!this.BezierSegIntersectsBoundary(nseg)) {\n                b.nextBezierCoefficient = k;\n                b.previouisBezierCoefficient = k;\n                seg = nseg;\n            }\n        }\n        if (curve.segs.length > 0 && !Point.closeDistEps(curve.end, seg.start)) {\n            curve.addSegment(LineSegment.mkPP(curve.end, seg.start));\n        }\n        curve.addSegment(seg);\n    }\n    // getDebugCurvesForCorner(\n    //  a: CornerSite,\n    //  b: CornerSite,\n    //  c: CornerSite,\n    // ): //import{('../../math/geometry/debugCurve').}DebugCurve[] {\n    //  let r = []\n    //  r = r.concat(getHierDC(this.thinWestHierarchy, 'Red'))\n    //  r = r.concat(getHierDC(this.westHierarchy, 'Orange'))\n    //  r = r.concat(getHierDC(this.eastHierarchy, 'Blue'))\n    //  r = r.concat(getHierDC(this.thinEastHierarchy, 'Green'))\n    //  for (const a of this.anchors) {\n    //    r.push(DebugCurve.mkDebugCurveTWCI(100, 0.3, 'Gray', a.polygonalBoundary))\n    //  }\n    //  r.push(\n    //    DebugCurve.mkDebugCurveTWCI(\n    //      100,\n    //      2,\n    //      'Blue',\n    //      LineSegment.mkPP(a.point, b.point),\n    //    ),\n    //  )\n    //  r.push(\n    //    DebugCurve.mkDebugCurveTWCI(\n    //      100,\n    //      2,\n    //      'Blue',\n    //      LineSegment.mkPP(b.point, c.point),\n    //    ),\n    //  )\n    //  const p = new Polyline()\n    //  for (let i = 0; i <= this.edgePath.count; i++) {\n    //    p.addPoint(this.EdgePathPoint(i))\n    //  }\n    //  r.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Yellow', p))\n    //  return r\n    // }\n    BezierSegIntersectsBoundary(seg) {\n        const side = Point.signedDoubledTriangleArea(seg.B(0), seg.B(1), seg.B(2));\n        if (side < 0) {\n            return this.BezierSegIntersectsTree(seg, this.thinWestHierarchy) || this.BezierSegIntersectsTree(seg, this.westHierarchy);\n        }\n        else {\n            return this.BezierSegIntersectsTree(seg, this.thinEastHierarchy) || this.BezierSegIntersectsTree(seg, this.eastHierarchy);\n        }\n    }\n    BezierSegIntersectsTree(seg, tree) {\n        if (tree == null)\n            return false;\n        if (Parallelogram.intersect(seg.pNodeOverICurve().parallelogram, tree.parallelogram)) {\n            if (tree.node.hasOwnProperty('children')) {\n                const n = tree.node;\n                return this.BezierSegIntersectsTree(seg, n.children[0]) || this.BezierSegIntersectsTree(seg, n.children[1]);\n            }\n            else {\n                return SmoothedPolylineCalculator.BezierSegIntersectsBoundary(seg, tree.seg);\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    static BezierSegIntersectsBoundary(seg, ic) {\n        for (const x of Curve.getAllIntersections(seg, ic, false)) {\n            if (ic instanceof Curve) {\n                const c = ic;\n                if (Curve.realCutWithClosedCurve(x, c, false)) {\n                    return true;\n                }\n            }\n            else {\n                // curve is from a thin hierarchy that's forbidden to touch\n                return true;\n            }\n        }\n        return false;\n    }\n}\n// function getHierDC(hierarchy: PN, color: string): DebugCurve[] {\n//  if (hierarchy == null  || hierarchy.node == null ) return []\n//  if (hierarchy.node.hasOwnProperty('children')) {\n//    const n = hierarchy.node as PNInternal\n//    return getHierDC(n.children[0], color).concat(\n//      getHierDC(n.children[1], color),\n//    )\n//  }\n//  return [DebugCurve.mkDebugCurveTWCI(100, 0.5, color, hierarchy.seg)]\n// }\n//# sourceMappingURL=smoothedPolylineCalculator.js.map","import { VerticalConstraintsForSugiyama } from './verticalConstraintsForSugiyama';\nimport { HorizontalConstraintsForSugiyama } from './HorizontalConstraintsForSugiyama';\nimport { LayerDirectionEnum } from './layerDirectionEnum';\nimport { PlaneTransformation } from '../../math/geometry/planeTransformation';\nimport { closeDistEps } from '../../utils/compare';\nimport { EdgeRoutingMode } from '../../routing/EdgeRoutingMode';\nimport { CommonLayoutSettings } from '../commonLayoutSettings';\nexport var SnapToGridByY;\n(function (SnapToGridByY) {\n    SnapToGridByY[SnapToGridByY[\"None\"] = 0] = \"None\";\n    SnapToGridByY[SnapToGridByY[\"Top\"] = 1] = \"Top\";\n    SnapToGridByY[SnapToGridByY[\"Bottom\"] = 2] = \"Bottom\";\n})(SnapToGridByY || (SnapToGridByY = {}));\n/** Settings for layered layout: it specifies if the direction of the layers, distance between the layers, etc*/\nexport class SugiyamaLayoutSettings {\n    get NodeSeparation() {\n        return this.commonSettings.NodeSeparation;\n    }\n    get edgeRoutingSettings() {\n        return this.commonSettings.edgeRoutingSettings;\n    }\n    set edgeRoutingSettings(value) {\n        this.commonSettings.edgeRoutingSettings = value;\n    }\n    toJSON() {\n        const r = {};\n        if (this.sameRanks)\n            r.sameRanks = this.sameRanks;\n        if (this.verticalConstraints)\n            r.verticalConstraints = this.verticalConstraints;\n        if (this.horizontalConstraints)\n            r.horizontalConstraints = this.horizontalConstraints;\n        if (this.NoGainAdjacentSwapStepsBound != 5)\n            r.horizontalConstraints = this.horizontalConstraints;\n        if (this.NoGainStepsForOrderingMultiplier != 1)\n            r.RepetitionCoefficientForOrdering = this.NoGainStepsForOrderingMultiplier;\n        if (this.AspectRatio)\n            r.AspectRatio = this.AspectRatio;\n        if (this.MaxNumberOfPassesInOrdering != 24)\n            r.MaxNumberOfPassesInOrdering = this.MaxNumberOfPassesInOrdering;\n        if (this.BrandesThreshold != 600)\n            r.BrandesThreshold = this.BrandesThreshold;\n        if (this.LabelCornersPreserveCoefficient != 0.1)\n            r.LabelCornersPreserveCoefficient = this.LabelCornersPreserveCoefficient;\n        if (this.MinNodeHeight != (72 * 0.5) / 4)\n            r.MinNodeHeight = this.MinNodeHeight;\n        if (this.MinNodeWidth != (72 * 0.75) / 4)\n            r.MinNodeWidth = this.MinNodeWidth;\n        if (this.SnapToGridByY != SnapToGridByY.None)\n            r.SnapToGridByY = this.SnapToGridByY;\n        if (this.yLayerSep != 10 * 3)\n            r.yLayerSep = this.yLayerSep;\n        if (this.transform)\n            r.transform = this.transform.elements;\n        if (this.GridSizeByY)\n            r.GridSizeByY = this.GridSizeByY;\n        if (this.GridSizeByX)\n            r.GridSizeByX = this.GridSizeByX;\n        r.commonLayoutSettings = this.commonSettings.toJSON();\n        return r;\n    }\n    static fromJSON(s) {\n        const r = new SugiyamaLayoutSettings();\n        if (s.sameRanks)\n            r.sameRanks = s.sameRanks;\n        if (s.verticalConstraints)\n            r.verticalConstraints = s.verticalConstraints;\n        if (s.horizontalConstraints)\n            r.horizontalConstraints = s.horizontalConstraints;\n        if (s.NoGainAdjacentSwapStepsBound)\n            r.horizontalConstraints = s.horizontalConstraints;\n        if (s.RepetitionCoefficientForOrdering)\n            r.NoGainStepsForOrderingMultiplier = s.RepetitionCoefficientForOrdering;\n        if (s.AspectRatio)\n            r.AspectRatio = s.AspectRatio;\n        if (s.MaxNumberOfPassesInOrdering)\n            r.MaxNumberOfPassesInOrdering = s.MaxNumberOfPassesInOrdering;\n        if (s.BrandesThreshold)\n            r.BrandesThreshold = s.BrandesThreshold;\n        if (s.LabelCornersPreserveCoefficient)\n            r.LabelCornersPreserveCoefficient = s.LabelCornersPreserveCoefficient;\n        if (s.MinNodeHeight)\n            r.MinNodeHeight = s.MinNodeHeight;\n        if (s.MinNodeWidth)\n            r.MinNodeWidth = r.MinNodeWidth;\n        if (s.SnapToGridByY)\n            r.SnapToGridByY = s.SnapToGridByY;\n        if (s.yLayerSep)\n            r.yLayerSep = s.yLayerSep;\n        if (s.transform)\n            r.transform = new PlaneTransformation(s.transform[0][0], s.transform[0][1], s.transform[0][2], s.transform[1][0], s.transform[1][1], s.transform[1][2]);\n        if (s.GridSizeByY)\n            r.GridSizeByY = s.GridSizeByY;\n        if (s.GridSizeByX)\n            r.GridSizeByX = s.GridSizeByX;\n        if (s.commonLayoutSettings)\n            r.commonSettings = CommonLayoutSettings.fromJSON(s.commonLayoutSettings);\n        return r;\n    }\n    /** the minimum distance between two layer horizontal lines passing througt the node centers */\n    get LayerSeparation() {\n        return this.yLayerSep;\n    }\n    set LayerSeparation(value) {\n        this.yLayerSep = Math.max(10 * 3, value);\n    }\n    ActualLayerSeparation(layersAreDoubled) {\n        return layersAreDoubled ? this.LayerSeparation / 2.0 : this.LayerSeparation;\n    }\n    constructor() {\n        this.commonSettings = new CommonLayoutSettings();\n        this.verticalConstraints = new VerticalConstraintsForSugiyama();\n        this.horizontalConstraints = new HorizontalConstraintsForSugiyama();\n        this.NoGainAdjacentSwapStepsBound = 5;\n        /** the adjacent swaps will proceed by NoGainAdjacentSwapStepsBound*NoGainStepsForOrderingMultiplier  */\n        this.NoGainStepsForOrderingMultiplier = 1;\n        /**  Aspect ratio of the layout. Ignored it zero.*/\n        this.AspectRatio = 0;\n        /** the maximum number of going up and down through the layers to untangle the edges */\n        this.MaxNumberOfPassesInOrdering = 24;\n        /**  When the number of vertices in the proper layered graph\n         is at least threshold  we switch to a fast, but not so accurate,\n         method for x-coordinates calculations. */\n        this.BrandesThreshold = 600;\n        /**  The coefficient for the label corners preserve heuristic,\n         * that allows for an edge to pass through the bounding box of a label, close to its corner*/\n        this.LabelCornersPreserveCoefficient = 0.1;\n        /** the minimal node size */\n        this.MinNodeHeight = (72 * 0.5) / 4;\n        this.MinNodeWidth = (72 * 0.75) / 4;\n        /**  The grid snapping mode: snap up, down on neither */\n        this.SnapToGridByY = SnapToGridByY.None;\n        /** the minimum distance between two layer horizontal lines passing througt the node centers */\n        this.yLayerSep = 10 * 3;\n        /** the transform can be an identity, or rotation on Pi/2, -Pi/2, or Pi */\n        this.transform = PlaneTransformation.getIdentity();\n        this.GridSizeByY = 0;\n        this.GridSizeByX = 0;\n        this.commonSettings.edgeRoutingSettings.EdgeRoutingMode = EdgeRoutingMode.SugiyamaSplines;\n    }\n    transformIsRotation(ang) {\n        const p = PlaneTransformation.rotation(ang);\n        for (let i = 0; i < 2; i++) {\n            for (let j = 0; j < 3; j++)\n                if (!closeDistEps(p.elements[i][j], this.transform.elements[i][j]))\n                    return false;\n        }\n        return true;\n    }\n    get layerDirection() {\n        if (this.transformIsRotation(0))\n            return LayerDirectionEnum.TB;\n        if (this.transformIsRotation(Math.PI / 2))\n            return LayerDirectionEnum.LR;\n        if (this.transformIsRotation(-Math.PI / 2))\n            return LayerDirectionEnum.RL;\n        if (this.transformIsRotation(Math.PI))\n            return LayerDirectionEnum.BT;\n        throw new Error('unexpected layout direction');\n    }\n    set layerDirection(value) {\n        switch (value) {\n            case LayerDirectionEnum.TB:\n                this.transform = PlaneTransformation.getIdentity();\n                break;\n            case LayerDirectionEnum.LR:\n                this.transform = PlaneTransformation.rotation(Math.PI / 2);\n                break;\n            case LayerDirectionEnum.RL:\n                this.transform = PlaneTransformation.rotation(-Math.PI / 2);\n                break;\n            case LayerDirectionEnum.BT:\n                this.transform = PlaneTransformation.rotation(Math.PI);\n                break;\n            default:\n                throw new Error('unexpected layout direction');\n        }\n    }\n}\n//# sourceMappingURL=sugiyamaLayoutSettings.js.map","import { mkGraphOnEdgesN } from '../../structs/basicGraphOnEdges';\nimport { IntPair } from '../../utils/IntPair';\nimport { CycleRemoval } from './CycleRemoval';\nimport { PolyIntEdge } from './polyIntEdge';\nimport { IntPairSet } from '../../utils/IntPairSet';\nimport { GetConnectedComponents } from '../../math/graphAlgorithms/ConnectedComponentCalculator';\nexport class VerticalConstraintsForSugiyama {\n    constructor() {\n        /*  getFeedbackSet(\n            intGraph: BasicGraph<Node, PolyIntEdge>,\n            nodeIdToIndex: Map<string, number>,\n          ): import('../../structs/iedge').IEdge[] {\n            throw new Error('Method not implemented.')\n          }\n          */\n        // nodes that are pinned to the max layer\n        this.maxLayerOfGeomGraph = new Set();\n        // nodes that are pinned to the min layer\n        this.minLayerOfGeomGraph = new Set();\n        // set of couple of nodes belonging to the same layer\n        this.sameLayerConstraints = new Array();\n        this.upDownConstraints = new Array();\n        this.gluedUpDownIntConstraints = new IntPairSet();\n        // Maps each node participating in same layer relation to its representative on the layer.\n        this.sameLayerDictionaryOfRepresentatives = new Map();\n        this.representativeToItsLayer = new Map();\n        this.maxLayerInt = new Array();\n        this.minLayerInt = new Array();\n        this.sameLayerInts = new Array();\n        // contains also pinned max and min pairs\n        this.upDownInts = new Array();\n    }\n    getFeedbackSetExternal(intGraph, nodeIdToIndex) {\n        throw new Error('Method not implemented.');\n    }\n    // pins a node to max layer\n    pinNodeToMaxLayer(node) {\n        this.maxLayerOfGeomGraph.add(node);\n    }\n    // pins a node to min layer\n    pinNodeToMinLayer(node) {\n        this.minLayerOfGeomGraph.add(node);\n    }\n    get isEmpty() {\n        return (this.maxLayerOfGeomGraph.size === 0 &&\n            this.minLayerOfGeomGraph.size === 0 &&\n            this.sameLayerConstraints.length === 0 &&\n            this.upDownConstraints.length === 0);\n    }\n    clear() {\n        this.maxLayerOfGeomGraph.clear();\n        this.minLayerOfGeomGraph.clear();\n        this.sameLayerConstraints = [];\n        this.upDownConstraints = [];\n    }\n    getFeedbackSetImp(intGraph, nodeIdToIndex) {\n        this.nodeIdToIndex = nodeIdToIndex;\n        this.intGraph = intGraph;\n        this.maxRepresentative = -1;\n        this.minRepresentative = -1;\n        this.createIntegerConstraints();\n        this.glueTogetherSameConstraintsMaxAndMin();\n        this.addMaxMinConstraintsToGluedConstraints();\n        this.removeCyclesFromGluedConstraints();\n        return this.getFeedbackSet();\n    }\n    removeCyclesFromGluedConstraints() {\n        const graph = mkGraphOnEdgesN(Array.from(this.gluedUpDownIntConstraints.values()), this.intGraph.nodeCount);\n        const feedbackSet = CycleRemoval.getFeedbackSetWithConstraints(graph, null);\n        //feedbackSet contains all glued constraints making constraints cyclic\n        for (const p of feedbackSet) {\n            this.gluedUpDownIntConstraints.remove(p);\n        }\n    }\n    addMaxMinConstraintsToGluedConstraints() {\n        if (this.maxRepresentative !== -1)\n            for (let i = 0; i < this.intGraph.nodeCount; i++) {\n                const j = this.nodeToRepr(i);\n                if (j !== this.maxRepresentative)\n                    this.gluedUpDownIntConstraints.add(new IntPair(this.maxRepresentative, j));\n            }\n        if (this.minRepresentative !== -1)\n            for (let i = 0; i < this.intGraph.nodeCount; i++) {\n                const j = this.nodeToRepr(i);\n                if (j !== this.minRepresentative)\n                    this.gluedUpDownIntConstraints.add(new IntPair(j, this.minRepresentative));\n            }\n    }\n    glueTogetherSameConstraintsMaxAndMin() {\n        this.createDictionaryOfSameLayerRepresentatives();\n        const array = this.upDownInts.map(this.gluedIntPairNN);\n        this.gluedUpDownIntConstraints = new IntPairSet();\n    }\n    gluedIntPairNN(p) {\n        return new IntPair(this.nodeToRepr(p[0]), this.nodeToRepr(p[1]));\n    }\n    gluedIntPairI(p) {\n        return new IntPair(this.nodeToRepr(p.source), this.nodeToRepr(p.target));\n    }\n    gluedIntPair(p) {\n        return new IntPair(this.nodeToRepr(p.source), this.nodeToRepr(p.target));\n    }\n    gluedIntEdge(intEdge) {\n        const sourceRepr = this.nodeToRepr(intEdge.source);\n        const targetRepr = this.nodeToRepr(intEdge.target);\n        const ie = new PolyIntEdge(sourceRepr, targetRepr, intEdge.edge);\n        ie.separation = intEdge.separation;\n        ie.weight = 0;\n        return ie;\n    }\n    nodeToRepr(node) {\n        const repr = this.sameLayerDictionaryOfRepresentatives.get(node);\n        return repr ? repr : node;\n    }\n    createDictionaryOfSameLayerRepresentatives() {\n        const graphOfSameLayers = this.createGraphOfSameLayers();\n        for (const comp of GetConnectedComponents(graphOfSameLayers))\n            this.glueSameLayerNodesOfALayer(comp);\n    }\n    createGraphOfSameLayers() {\n        return mkGraphOnEdgesN(this.createEdgesOfSameLayers(), this.intGraph.nodeCount);\n    }\n    createEdgesOfSameLayers() {\n        const ret = new Array();\n        if (this.maxRepresentative !== -1) {\n            this.maxLayerInt\n                .filter((v) => v !== this.maxRepresentative)\n                .map((v) => new IntPair(this.maxRepresentative, v))\n                .forEach((p) => ret.push(p));\n        }\n        if (this.minRepresentative !== -1) {\n            this.minLayerInt\n                .filter((v) => v !== this.minRepresentative)\n                .map((v) => new IntPair(this.minRepresentative, v))\n                .forEach((p) => ret.push(p));\n        }\n        this.sameLayerInts.forEach((t) => ret.push(new IntPair(t[0], t[1])));\n        return ret;\n    }\n    // maps all nodes of the component to one random representative\n    glueSameLayerNodesOfALayer(sameLayerNodes) {\n        if (sameLayerNodes.length > 1) {\n            let representative = -1;\n            if (this.componentsIsMaxLayer(sameLayerNodes)) {\n                for (const v of sameLayerNodes)\n                    this.sameLayerDictionaryOfRepresentatives.set(v, (representative = this.maxRepresentative));\n            }\n            else if (this.componentIsMinLayer(sameLayerNodes)) {\n                for (const v of sameLayerNodes)\n                    this.sameLayerDictionaryOfRepresentatives.set(v, (representative = this.minRepresentative));\n            }\n            else {\n                for (const v of sameLayerNodes) {\n                    if (representative === -1)\n                        representative = v;\n                    this.sameLayerDictionaryOfRepresentatives.set(v, representative);\n                }\n            }\n            this.representativeToItsLayer.set(representative, sameLayerNodes);\n        }\n    }\n    componentIsMinLayer(component) {\n        return component.findIndex((p) => this.minRepresentative === p) >= 0;\n    }\n    componentsIsMaxLayer(component) {\n        return component.findIndex((p) => this.maxRepresentative === p) >= 0;\n    }\n    createIntegerConstraints() {\n        this.createMaxIntConstraints();\n        this.createMinIntConstraints();\n        this.createUpDownConstraints();\n        this.createSameLayerConstraints();\n    }\n    createSameLayerConstraints() {\n        this.sameLayerInts = this.createIntConstraintsFromStringCouples(this.sameLayerConstraints);\n    }\n    createUpDownConstraints() {\n        this.upDownInts = this.createIntConstraintsFromStringCouples(this.upDownConstraints);\n    }\n    createIntConstraintsFromStringCouples(list) {\n        return list.map((couple) => [this.nodeIndex(couple[0]), this.nodeIndex(couple[1])]).filter((t) => t[0] !== -1 && t[1] !== -1);\n    }\n    createMinIntConstraints() {\n        this.minLayerInt = this.createIntConstraintsFromExtremeLayer(this.minLayerOfGeomGraph);\n        if (this.minLayerInt.length > 0)\n            this.minRepresentative = this.minLayerInt[0];\n    }\n    createMaxIntConstraints() {\n        this.maxLayerInt = this.createIntConstraintsFromExtremeLayer(this.maxLayerOfGeomGraph);\n        if (this.maxLayerInt.length > 0)\n            this.maxRepresentative = this.maxLayerInt[0];\n    }\n    createIntConstraintsFromExtremeLayer(setOfNodes) {\n        //return new Array<number>(from node in setOfNodes let index = NodeIndex(node) where index !== -1 select index);\n        return Array.from(setOfNodes)\n            .map((n) => this.nodeIndex(n))\n            .filter((i) => i !== -1);\n    }\n    nodeIndex(node) {\n        const index = this.nodeIdToIndex.get(node.node.id);\n        return index ? index : -1;\n    }\n    getFeedbackSet() {\n        this.gluedIntGraph = this.createGluedGraph();\n        return Array.from(this.unglueIntPairs(CycleRemoval.getFeedbackSetWithConstraints(this.gluedIntGraph, this.gluedUpDownIntConstraints)));\n    }\n    *unglueIntPairs(gluedEdges) {\n        for (const gluedEdge of gluedEdges)\n            for (const ungluedEdge of this.unglueEdge(gluedEdge))\n                yield ungluedEdge;\n    }\n    *unglueEdge(gluedEdge) {\n        for (const source of this.unglueNode(gluedEdge.source))\n            for (const edge of this.intGraph.outEdges[source])\n                if (this.nodeToRepr(edge.target) === gluedEdge.target)\n                    yield edge;\n    }\n    createGluedGraph() {\n        const set = new IntPairSet();\n        this.intGraph.edges.forEach((e) => set.add(this.gluedIntPairI(e)));\n        return mkGraphOnEdgesN(Array.from(set.values()), this.intGraph.nodeCount);\n        //return new BasicGraphOnEdges<IntPair>(new Set<IntPair>(from edge in this.intGraph.Edges select GluedIntPair(edge)), this.intGraph.NodeCount);\n    }\n    unglueNode(node) {\n        const layer = this.representativeToItsLayer.get(node);\n        if (layer)\n            return layer;\n        return [node];\n    }\n    getGluedNodeCounts() {\n        const ret = new Array(this.nodeIdToIndex.size).fill(0);\n        for (let node = 0; node < ret.length; node++)\n            ret[this.nodeToRepr(node)]++;\n        return ret;\n    }\n}\n//# sourceMappingURL=verticalConstraintsForSugiyama.js.map","// The implementation follows\n// \"Fast and Simple Horizontal Coordinate Assignment\" of Ulrik Brandes and Boris Kopf\n// The paper has two serious bugs that this code resolves.\nimport { TopologicalSort } from '../../math/graphAlgorithms/topologicalSort';\nimport { mkGraphOnEdgesN } from '../../structs/basicGraphOnEdges';\nimport { IntPair } from '../../utils/IntPair';\nimport { IntPairSet } from '../../utils/IntPairSet';\nimport { PolyIntEdge } from './polyIntEdge';\nexport class XCoordsWithAlignment {\n    get CurrentEnumRightUp() {\n        return (this.LR ? 0 : 1) + 2 * (this.BT ? 0 : 1);\n    }\n    // Returns true if v is a virtual vertex\n    IsVirtual(v) {\n        return v >= this.nOfOriginalVertices;\n    }\n    Source(edge) {\n        return this.BT ? edge.Source : edge.Target;\n    }\n    Target(edge) {\n        return this.BT ? edge.Target : edge.Source;\n    }\n    static CalculateXCoordinates(layerArrays, layeredGraph, nOfOriginalVs, anchors, nodeSeparation) {\n        const x = new XCoordsWithAlignment(layerArrays, layeredGraph, nOfOriginalVs, anchors, nodeSeparation);\n        x.Calculate();\n    }\n    Calculate() {\n        this.SortInAndOutEdges();\n        this.RightUpSetup();\n        this.CalcBiasedAlignment();\n        this.LeftUpSetup();\n        this.CalcBiasedAlignment();\n        this.RightDownSetup();\n        this.CalcBiasedAlignment();\n        this.LeftDownSetup();\n        this.CalcBiasedAlignment();\n        this.HorizontalBalancing();\n    }\n    // We need to find a median of a vertex neighbors from a specific layer. That is, if we have a vertex v and edges (v,coeff), (v,side1), (v,cornerC)\n    // going down, and X[coeff]<X[side1]<X[cornerC], then side1 is the median.\n    // There is an algorithm that finds the median with expected linear number of steps,\n    // see for example http://www.ics.uci.edu/~eppstein/161/960125.html. However, I think we are better off\n    // with sorting, since we are taking median at least twice.\n    // Notice, that the sorting should be done only for original vertices since dummy vertices\n    // have only one incoming edge and one outcoming edge.\n    // Consider here reusing the sorting that comes from the ordering step,\n    // if it is not broken by layer insertions.\n    SortInAndOutEdges() {\n        this.FillLowMedians();\n        this.FillUpperMedins();\n    }\n    FillUpperMedins() {\n        this.upperMedians = new Array(this.graph.NodeCount);\n        for (let i = 0; i < this.graph.NodeCount; i++) {\n            this.FillUpperMediansForNode(i);\n        }\n    }\n    CompareByX(a, b) {\n        return this.la.x[a] - this.la.x[b];\n    }\n    FillUpperMediansForNode(i) {\n        let count = this.graph.InEdgesCount(i);\n        if (count > 0) {\n            const predecessors = new Array(count);\n            count = 0;\n            for (const e of this.graph.InEdges(i)) {\n                predecessors[count++] = e.Source;\n            }\n            predecessors.sort((a, b) => this.CompareByX(a, b));\n            const m = Math.floor(count / 2);\n            if (m * 2 === count) {\n                this.upperMedians[i] = new IntPair(predecessors[m - 1], predecessors[m]);\n            }\n            else {\n                this.upperMedians[i] = predecessors[m];\n            }\n        }\n        else {\n            this.upperMedians[i] = -1;\n        }\n    }\n    FillLowMedians() {\n        this.lowMedians = new Array(this.graph.NodeCount);\n        for (let i = 0; i < this.graph.NodeCount; i++) {\n            this.FillLowMediansForNode(i);\n        }\n    }\n    FillLowMediansForNode(i) {\n        let count = this.graph.OutEdgesCount(i);\n        if (count > 0) {\n            const successors = new Array(count);\n            count = 0;\n            for (const e of this.graph.OutEdges(i)) {\n                successors[count++] = e.Target;\n            }\n            successors.sort((a, b) => this.CompareByX(a, b));\n            const m = Math.floor(count / 2);\n            if (m * 2 === count) {\n                this.lowMedians[i] = new IntPair(successors[m - 1], successors[m]);\n            }\n            else {\n                this.lowMedians[i] = successors[m];\n            }\n        }\n        else {\n            this.lowMedians[i] = -1;\n        }\n    }\n    HorizontalBalancing() {\n        let leastWidthAssignment = -1;\n        const a = new Array(4);\n        const b = new Array(4);\n        let leastWidth = Number.MAX_VALUE;\n        for (let i = 0; i < 4; i++) {\n            const t = { a: 0, b: 0 };\n            this.AssignmentBounds(i, t);\n            a[i] = t.a;\n            b[i] = t.b;\n            const w = b[i] - a[i];\n            if (w < leastWidth) {\n                leastWidthAssignment = i;\n                leastWidth = w;\n            }\n        }\n        for (let i = 0; i < 4; i++) {\n            let delta;\n            if (XCoordsWithAlignment.IsLeftMostAssignment(i)) {\n                delta = a[leastWidthAssignment] - a[i];\n            }\n            else {\n                delta = b[leastWidthAssignment] - b[i];\n            }\n            this.x = this.xCoords[i];\n            if (delta !== 0) {\n                for (let j = 0; j < this.nOfVertices; j++) {\n                    this.x[j] = this.x[j] + delta;\n                }\n            }\n        }\n        const arr = new Array(4);\n        for (let v = 0; v < this.nOfVertices; v++) {\n            arr[0] = this.xCoords[0][v];\n            arr[1] = this.xCoords[1][v];\n            arr[2] = this.xCoords[2][v];\n            arr[3] = this.xCoords[3][v];\n            arr.sort((a, b) => a - b);\n            this.anchors[v].x = (arr[1] + arr[2]) / 2;\n        }\n        //    Layout.ShowDataBase(dataBase);\n    }\n    static IsLeftMostAssignment(i) {\n        return i === 0 || i === 2;\n    }\n    AssignmentBounds(i, t) {\n        if (this.nOfVertices === 0) {\n            t.a = 0;\n            t.b = 0;\n        }\n        else {\n            this.x = this.xCoords[i];\n            t.a = t.b = this.x[0];\n            for (let j = 1; j < this.nOfVertices; j++) {\n                const r = this.x[j];\n                if (r < t.a) {\n                    t.a = r;\n                }\n                else if (r > t.b) {\n                    t.b = r;\n                }\n            }\n        }\n    }\n    CalcBiasedAlignment() {\n        this.ConflictElimination();\n        this.Align();\n    }\n    LeftUpSetup() {\n        this.LR = false;\n        this.BT = true;\n    }\n    LeftDownSetup() {\n        this.LR = false;\n        this.BT = false;\n    }\n    RightDownSetup() {\n        this.LR = true;\n        this.BT = false;\n    }\n    RightUpSetup() {\n        this.LR = true;\n        this.BT = true;\n    }\n    // The code is written as if we go left up, but in fact the settings define the directions.\n    //\n    // We need to create a subgraph for alignment:\n    // where no edge segments intersect, and every vertex has\n    // at most one incoming and at most one outcoming edge.\n    // This function marks edges to resolve conflicts with only one inner segment.\n    // An inner segment is a segment between two dummy nodes.\n    // We mark edges that later will not participate in the alignment.\n    // Inner segments are preferred to other ones. So, in a conflict with one inner and one\n    // non-inner edges we leave the inner edge to participate in the alignment.\n    // At the moment we mark as not participating both of the two intersecting inner segments\n    ConflictElimination() {\n        this.RemoveMarksFromEdges();\n        this.MarkConflictingEdges();\n    }\n    // iterator\n    *UpperEdgeMedians(target) {\n        const medians = this.BT ? this.upperMedians[target] : this.lowMedians[target];\n        const isIp = !(typeof medians === 'number');\n        if (isIp) {\n            const ip = medians;\n            if (this.LR) {\n                yield ip.x;\n                yield ip.y;\n            }\n            else {\n                yield ip.y;\n                yield ip.x;\n            }\n        }\n        else {\n            const i = medians;\n            if (i >= 0) {\n                yield i;\n            }\n        }\n    }\n    // here we eliminate all constraints\n    MarkConflictingEdges() {\n        let i = this.LowerOf(0, this.h - 1);\n        const lowest = i;\n        const upperBound = this.UpperOf(0, this.h - 1);\n        const nextBelowUpperBound = this.NextLower(upperBound);\n        // our top layer has index h-1, our bottom layer has index 0\n        // inner segments can appear only between layers with indices i+1 and i where i>0 and i<h-1\n        for (; this.IsBelow(i, upperBound); i = this.NextUpper(i)) {\n            if (this.IsBelow(lowest, i) && this.IsBelow(i, nextBelowUpperBound)) {\n                this.ConflictsWithAtLeastOneInnerEdgeForALayer(i);\n            }\n        }\n    }\n    // parameterized next upper\n    NextUpper(i) {\n        return this.BT ? i + 1 : i - 1;\n    }\n    // parameterized next lower\n    NextLower(i) {\n        return this.BT ? i - 1 : i + 1;\n    }\n    // parameterize highest of two numbers\n    UpperOf(i, j) {\n        return this.BT ? Math.max(i, j) : Math.min(i, j);\n    }\n    // parameterized lowest of a pair\n    LowerOf(i, j) {\n        return this.BT ? Math.min(i, j) : Math.max(i, j);\n    }\n    // returns parameterized below\n    IsBelow(i, j) {\n        return this.BT ? i < j : j < i;\n    }\n    // returns the \"parameterized\" left of the two positions\n    LeftMost(pos0, pos1) {\n        return this.LR ? Math.min(pos0, pos1) : Math.max(pos0, pos1);\n    }\n    // returns the \"parameterized\" right of the two positions\n    RightMost(pos0, pos1) {\n        return this.LR ? Math.max(pos0, pos1) : Math.min(pos0, pos1);\n    }\n    // Return true if i is to the left or equal to pos in a \"parameterized\" fasion\n    IsNotRightFrom(i, pos) {\n        return this.LR ? i <= pos : pos <= i;\n    }\n    // Parameterized left relation\n    IsLeftFrom(i, j) {\n        return this.LR ? i < j : j < i;\n    }\n    // parameterized next right\n    NextRight(i) {\n        return this.LR ? i + 1 : i - 1;\n    }\n    // parameterized next left\n    NextLeft(i) {\n        return this.LR ? i - 1 : i + 1;\n    }\n    // // Eliminates conflicts with at least one inner edge inside of one layer\n    // // <\n    ConflictsWithAtLeastOneInnerEdgeForALayer(layerIndex) {\n        if (layerIndex >= 0 && layerIndex < this.la.Layers.length) {\n            const lowerLayer = this.la.Layers[layerIndex];\n            let innerEdge = null;\n            // start looking for the first inner edge from the left of lowerLayer\n            let targetPos = this.LeftMost(0, lowerLayer.length - 1);\n            const lastTargetPos = this.RightMost(0, lowerLayer.length - 1);\n            for (; this.IsNotRightFrom(targetPos, lastTargetPos) && innerEdge == null; targetPos = this.NextRight(targetPos)) {\n                innerEdge = this.InnerEdgeByTarget(lowerLayer[targetPos]);\n            }\n            // now targetPos points to the right of the innerEdge target at lowerLayer\n            if (innerEdge != null) {\n                const positionOfInnerEdgeSource = this.Pos(this.Source(innerEdge));\n                // We are still not in the main loop.\n                // We mark conflicting edges with targets to the left of targetPos,\n                // That of course means\n                // that the sources of conflicting edges lie to the right of Source(innerEdge)\n                for (let j = this.LeftMost(0, lowerLayer.length - 1); this.IsLeftFrom(j, targetPos); j = this.NextRight(j)) {\n                    for (const ie of this.InEdges(lowerLayer[j])) {\n                        if (this.IsLeftFrom(positionOfInnerEdgeSource, this.Pos(this.Source(ie)))) {\n                            this.MarkEdge(ie);\n                        }\n                    }\n                }\n                let innerSourcePos = this.Pos(this.Source(innerEdge));\n                // starting the main loop\n                while (this.IsNotRightFrom(targetPos, lastTargetPos)) {\n                    // Now we look for the next inner edge in the alignment to the right of the current innerEdge,\n                    // and we mark the conflicts later. Marking the conflicts later makes sense.\n                    // We would have to go through positions between innerEdge and newInnerEdge targets\n                    // again anyway to resolve conflicts with not inner edges and newInnerEdge\n                    const newInnerEdge = this.AlignmentToTheRightOfInner(lowerLayer, targetPos, positionOfInnerEdgeSource);\n                    targetPos = this.NextRight(targetPos);\n                    if (newInnerEdge != null) {\n                        const newInnerSourcePos = this.Pos(this.Source(newInnerEdge));\n                        this.MarkEdgesBetweenInnerAndNewInnerEdges(lowerLayer, innerEdge, newInnerEdge, innerSourcePos, newInnerSourcePos);\n                        innerEdge = newInnerEdge;\n                        innerSourcePos = newInnerSourcePos;\n                    }\n                }\n                // look for conflicting edges with targets to the right from the target of innerEdge\n                for (let k = this.NextRight(this.Pos(this.Target(innerEdge))); this.IsNotRightFrom(k, lastTargetPos); k = this.NextRight(k)) {\n                    for (const ie of this.InEdges(lowerLayer[k])) {\n                        if (this.IsLeftFrom(this.Pos(this.Source(ie)), this.Pos(this.Source(innerEdge)))) {\n                            this.MarkEdge(ie);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    InEdgeOfVirtualNode(v) {\n        return this.BT ? this.graph.InEdgeOfVirtualNode(v) : this.graph.OutEdgeOfVirtualNode(v);\n    }\n    InEdges(v) {\n        return this.BT ? this.graph.InEdges(v) : this.graph.OutEdges(v);\n    }\n    // // This function marks conflicting edges with targets positioned between innerEdge and newInnerEdge targets.\n    // // <\n    MarkEdgesBetweenInnerAndNewInnerEdges(lowerLayer, innerEdge, newInnerEdge, innerEdgeSourcePos, newInnerEdgeSourcePos) {\n        let u = this.NextRight(this.Pos(this.Target(innerEdge)));\n        for (; this.IsLeftFrom(u, this.Pos(this.Target(newInnerEdge))); u = this.NextRight(u)) {\n            for (const ie of this.InEdges(lowerLayer[u])) {\n                const ieSourcePos = this.Pos(this.Source(ie));\n                if (this.IsLeftFrom(ieSourcePos, innerEdgeSourcePos)) {\n                    this.MarkEdge(ie);\n                }\n                else if (this.IsLeftFrom(newInnerEdgeSourcePos, ieSourcePos)) {\n                    this.MarkEdge(ie);\n                }\n            }\n        }\n    }\n    // // Returns the inner non-conflicting edge incoming into i-th position\n    // // of the layer or null if there is no such edge\n    // // <\n    AlignmentToTheRightOfInner(lowLayer, i, posInnerSource) {\n        const numOfInEdges = this.NumberOfInEdges(lowLayer[i]);\n        if (numOfInEdges === 1) {\n            let ie = null;\n            for (const e of this.InEdges(lowLayer[i])) {\n                ie = e;\n            }\n            if (this.IsInnerEdge(ie) && this.IsLeftFrom(posInnerSource, this.Pos(ie.Source))) {\n                return ie;\n            }\n            return null;\n        }\n        return null;\n    }\n    NumberOfInEdges(v) {\n        return this.BT ? this.graph.InEdgesCount(v) : this.graph.OutEdgesCount(v);\n    }\n    Pos(v) {\n        return this.la.x[v];\n    }\n    InnerEdgeByTarget(v) {\n        if (this.IsVirtual(v)) {\n            const ie = this.InEdgeOfVirtualNode(v);\n            // there is exactly one edge entering in to the dummy node\n            if (this.IsVirtual(this.Source(ie))) {\n                return ie;\n            }\n        }\n        return null;\n    }\n    IsInnerEdge(e) {\n        return this.IsVirtual(e.Source) && this.IsVirtual(e.Target);\n    }\n    RemoveMarksFromEdges() {\n        this.markedEdges.clear();\n    }\n    // // private constructor\n    // // <\n    constructor(layerArrays, layeredGraph, nOfOriginalVs, anchorsP, ns) {\n        // four arrays for four different direction combinations\n        this.xCoords = new Array(4);\n        this.la = layerArrays;\n        this.graph = layeredGraph;\n        this.nOfOriginalVertices = nOfOriginalVs;\n        this.nOfVertices = this.graph.NodeCount;\n        this.markedEdges = new IntPairSet();\n        this.h = this.la.Layers.length;\n        this.root = new Array(this.nOfVertices);\n        this.align = new Array(this.nOfVertices);\n        // this.sink = new int[nOfVertices];\n        // this.shift = new double[nOfVertices];\n        this.anchors = anchorsP;\n        this.nodeSep = ns;\n    }\n    // Calculate the alignment based on the marked edges and greedily resolve the remaining conflicts on the fly, without marking\n    Align() {\n        this.CreateBlocks();\n        this.AssignCoordinatesByLongestPath();\n    }\n    AssignCoordinatesByLongestPath() {\n        this.x = this.xCoords[this.CurrentEnumRightUp] = new Array(this.nOfVertices);\n        // create the graph first\n        const edges = new Array();\n        for (let v = 0; v < this.nOfVertices; v++) {\n            if (v === this.root[v]) {\n                //v is a root\n                let w = v; //w will be running over the block\n                do {\n                    const rn = { neighbor: 0 };\n                    if (this.TryToGetRightNeighbor(w, rn))\n                        edges.push(new PolyIntEdge(v, this.root[rn.neighbor], null));\n                    w = this.align[w];\n                } while (w !== v);\n            }\n        }\n        const blockGraph = mkGraphOnEdgesN(edges, this.nOfVertices);\n        // sort the graph in the topological order\n        const topoSort = TopologicalSort.getOrderOnGraph(blockGraph);\n        // start placing the blocks according to the order\n        for (const v of topoSort) {\n            if (v === this.root[v]) {\n                let vx = 0;\n                let vIsLeftMost = true;\n                let w = v;\n                // w is running over the block\n                do {\n                    const wLn = { neighbor: 0 };\n                    if (this.TryToGetLeftNeighbor(w, wLn)) {\n                        if (vIsLeftMost) {\n                            vx = this.x[this.root[wLn.neighbor]] + this.DeltaBetweenVertices(wLn.neighbor, w);\n                            vIsLeftMost = false;\n                        }\n                        else {\n                            vx = this.RightMost(vx, this.x[this.root[wLn.neighbor]] + this.DeltaBetweenVertices(wLn.neighbor, w));\n                        }\n                    }\n                    w = this.align[w];\n                } while (w !== v);\n                this.x[v] = vx;\n            }\n        }\n        // push the roots of the graph maximally to the right\n        for (const v of topoSort) {\n            if (v === this.root[v]) {\n                if (blockGraph.inEdges[v].length === 0) {\n                    let w = v;\n                    // w runs over the block\n                    let xLeftMost = this.RightMost(-XCoordsWithAlignment.infinity, XCoordsWithAlignment.infinity);\n                    const xl = xLeftMost;\n                    do {\n                        const wRn = { neighbor: 0 };\n                        if (this.TryToGetRightNeighbor(w, wRn)) {\n                            xLeftMost = this.LeftMost(xLeftMost, this.x[this.root[wRn.neighbor]] - this.DeltaBetweenVertices(w, wRn.neighbor));\n                        }\n                        w = this.align[w];\n                    } while (w !== v);\n                    if (xl !== xLeftMost) {\n                        this.x[v] = xLeftMost;\n                    }\n                }\n            }\n        }\n        for (let v = 0; v < this.nOfVertices; v++) {\n            if (v !== this.root[v]) {\n                this.x[v] = this.x[this.root[v]];\n            }\n        }\n    }\n    // returns true is u has a right neighbor on its layer\n    TryToGetRightNeighbor(u, t) {\n        const neighborPos = this.NextRight(this.Pos(u));\n        const layer = this.la.Layers[this.la.y[u]];\n        if (neighborPos >= 0 && neighborPos < layer.length) {\n            t.neighbor = layer[neighborPos];\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    // returns true is u has a right neighbor on its layer\n    TryToGetLeftNeighbor(u, t) {\n        const neighborPos = this.NextLeft(this.Pos(u));\n        const layer = this.la.Layers[this.la.y[u]];\n        if (neighborPos >= 0 && neighborPos < layer.length) {\n            t.neighbor = layer[neighborPos];\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    // Organizes the vertices into blocks. A block is a maximal path in the alignment subgraph.\n    // The alignment is defined by array align. Every vertex is connected to the top vertex of\n    // the block by using root array. The alignment is cyclic. If we start from a root vertex v and\n    // apply align then we return to v at some point.\n    CreateBlocks() {\n        for (let v = 0; v < this.nOfVertices; v++) {\n            this.root[v] = this.align[v] = v;\n        }\n        const lowBound = this.LowerOf(0, this.h - 1);\n        // i points to the last layer before the highest one\n        for (let i = this.NextLower(this.UpperOf(0, this.h - 1)); !this.IsBelow(i, lowBound); i = this.NextLower(i)) {\n            const layer = this.la.Layers[i];\n            let r = this.LeftMost(-1, this.la.Layers[this.NextUpper(i)].length);\n            // We align vertices of the layer above the i-th one only if their positions are\n            // to the right of r. This moves us forward on the layer above the current and resolves the conflicts.\n            const rightBound = this.RightMost(0, layer.length - 1);\n            for (let k = this.LeftMost(0, layer.length - 1); this.IsNotRightFrom(k, rightBound); k = this.NextRight(k)) {\n                const vk = layer[k];\n                for (const upperNeighborOfVk of this.UpperEdgeMedians(vk)) {\n                    if (!this.IsMarked(vk, upperNeighborOfVk)) {\n                        if (this.IsLeftFrom(r, this.Pos(upperNeighborOfVk))) {\n                            this.align[upperNeighborOfVk] = vk;\n                            this.root[vk] = this.root[upperNeighborOfVk];\n                            this.align[vk] = this.root[upperNeighborOfVk];\n                            r = this.Pos(upperNeighborOfVk);\n                            break;\n                            // done with the alignement for vk\n                        }\n                    }\n                }\n            }\n        }\n    }\n    IsMarked(source, target) {\n        if (this.BT) {\n            return this.markedEdges.hasxy(target, source);\n        }\n        else {\n            return this.markedEdges.hasxy(source, target);\n        }\n    }\n    MarkEdge(ie) {\n        this.markedEdges.addNN(ie.Source, ie.Target);\n    }\n    // Calculates the minimum separation between two neighboring vertices: if u is to the left of v on the same layer return positive\n    // number, otherwise negative.\n    DeltaBetweenVertices(u, v) {\n        let sign;\n        if (this.Pos(u) > this.Pos(v)) {\n            // swap u and v\n            const t = u;\n            u = v;\n            v = t;\n            sign = -1;\n        }\n        else {\n            sign = 1;\n        }\n        return (this.anchors[u].rightAnchor + this.anchors[v].leftAnchor + this.nodeSep) * sign;\n    }\n}\n// Assigning xcoords starting from roots\nXCoordsWithAlignment.infinity = 10000000;\n//# sourceMappingURL=xCoordsWithAlignment.js.map","// Follows the idea from Gansner etc 93, creating a special graph\n// for x-coordinates calculation\nimport { BasicGraphOnEdges } from '../../structs/basicGraphOnEdges';\nexport class XLayoutGraph extends BasicGraphOnEdges {\n    // weight multiplier for edges with two virtual nodes\n    /* internal */ constructor(graph, layeredGraph, layerArrays, edges, nov) {\n        super();\n        // we have 0,,,virtualVerticesStart-1 - usual vertices\n        // virtualVerticesStart,...,virtualVerticesEnd -virtual vertices\n        // and virtualVirticesEnd+1, ...NumberOfVertices - nvertices\n        this.weightMultiplierOfOriginalOriginal = 1;\n        // weight multiplier for edges with Defaults or n end and start\n        this.weightMultOfOneVirtual = 3;\n        // weight multiplier for edges with only one virtual node\n        this.weightMultiplierOfTwoVirtual = 8;\n        this.SetEdges(edges, nov);\n        this.virtualVerticesStart = graph.nodeCount;\n        this.virtualVerticesEnd = layeredGraph.NodeCount - 1;\n        this.layeredGraph = layeredGraph;\n        this.layerArrays = layerArrays;\n    }\n    // following Gansner etc 93 returning weight multplier bigger if there are virtual nodes\n    EdgeWeightMultiplier(edge) {\n        const s = edge.source;\n        const t = edge.target;\n        if (s < this.layeredGraph.NodeCount &&\n            this.layerArrays.y[s] === this.layerArrays.y[t] &&\n            this.layerArrays.x[s] === this.layerArrays.x[t] + 1) {\n            return 0;\n        }\n        // this edge needed only for separation vertices in the same layer\n        let k = 0;\n        /*Assert.assert(s >= this.layeredGraph.NodeCount)*/\n        // check the graph on correctness`\n        //    throw new Error();//\"XLayout graph is incorrect\");\n        // here (s0,t0) is the edge of underlying graph\n        let t0 = -1;\n        let s0 = -1;\n        // t0 is set to -1 to only avoid the warning\n        // there are only two edges in graph.OutEdges(s)\n        for (const intEdge of this.outEdges[s]) {\n            if (s0 === -1) {\n                s0 = intEdge.target;\n            }\n            else {\n                t0 = intEdge.target;\n            }\n        }\n        if (s0 >= this.virtualVerticesStart && s0 <= this.virtualVerticesEnd) {\n            k++;\n        }\n        if (t0 >= this.virtualVerticesStart && t0 <= this.virtualVerticesEnd) {\n            k++;\n        }\n        const ret = k === 0 ? this.weightMultiplierOfOriginalOriginal : k === 1 ? this.weightMultOfOneVirtual : this.weightMultiplierOfTwoVirtual;\n        return ret;\n    }\n    // caching edges weights\n    SetEdgeWeights() {\n        for (const intEdge of this.edges) {\n            intEdge.weight = intEdge.weight * this.EdgeWeightMultiplier(intEdge);\n        }\n    }\n}\n//# sourceMappingURL=xLayoutGraph.js.map","import { Algorithm } from '../../utils/algorithm';\nimport { SingleSourceDistances } from './SingleSourceDistances';\n// Algorithm for computing the distance between every pair of nodes in a graph.\nexport class AllPairsDistances extends Algorithm {\n    // The resulting distances between every pair of nodes in the graph.\n    get Result() {\n        return this.result;\n    }\n    set Result(value) {\n        this.result = value;\n    }\n    // Computes distances between every pair of nodes in a graph.\n    // Distances are symmetric if the graph is undirected.\n    constructor(graph, length) {\n        super(null);\n        this.graph = graph;\n        this.length = length;\n    }\n    // Executes the algorithm.\n    run() {\n        this.result = new Array(this.graph.shallowNodeCount);\n        let i = 0;\n        for (const source of this.graph.shallowNodes) {\n            const distances = new SingleSourceDistances(this.graph, source, this.length);\n            distances.run();\n            this.Result[i++] = distances.Result;\n        }\n    }\n    // Computes the \"stress\" of the current layout of the given graph:\n    //\n    //   stress = sum_{(u,v) in V}  (d(u,v) - D(u,v))^2/(D(u,v)^2)\n    //\n    // where:\n    //   V is the set of nodes\n    //   d(u,v) is the euclidean distance between the centers of nodes u and v\n    //   D(u,v) is the graph-theoretic path length between u and v - scaled by average edge length.\n    //\n    // Small stress in graph layout correlated with immediate neighbors to be closer\n    // together than nodes that are a few hops apart (i.e. that have path length>1).  More generally\n    // the distance between nodes in the drawing should be proportional to the path length between them.\n    // The lower the stress of a particular graph layout the better it conforms to this ideal.\n    //\n    static Stress(graph, length) {\n        let stress = 0;\n        if (graph.edgeCount === 0) {\n            return stress;\n        }\n        const apd = new AllPairsDistances(graph, length);\n        apd.run();\n        const D = apd.Result;\n        let l = 0;\n        for (const e of graph.shallowEdges) {\n            l += length(e);\n        }\n        l /= graph.edgeCount; // average of lengths\n        let i = 0;\n        for (const u of graph.shallowNodes) {\n            let j = 0;\n            for (const v of graph.shallowNodes) {\n                if (i !== j) {\n                    const duv = u.center.sub(v.center).length;\n                    const Duv = l * D[i][j];\n                    const d = Duv - duv;\n                    stress += (d * d) / (Duv * Duv);\n                }\n                j++;\n            }\n            i++;\n        }\n        return stress;\n    }\n}\n//# sourceMappingURL=AllPairsDistances.js.map","import { GenericBinaryHeapPriorityQueue } from '../../structs/genericBinaryHeapPriorityQueue';\nimport { Algorithm } from '../../utils/algorithm';\n// Provides functionality for computing distances in a graph.\nexport class SingleSourceDistances extends Algorithm {\n    // Dijkstra algorithm. Computes graph-theoretic distances from a node to\n    // all other nodes in a graph with nonnegative edge lengths.\n    // The distance between a node and itself is 0; the distance between a pair of\n    // nodes for which no connecting path exists is Number.POSITIVE_INFINITY.\n    constructor(graph, source, length) {\n        super(null); // todo: pass the canceltoken\n        this.graph = graph;\n        this.source = source;\n        this.length = length;\n    }\n    // An array of distances from the source node to all shallow nodes.\n    // Nodes are indexed when iterating over them.\n    get Result() {\n        return this.result;\n    }\n    // Executes the algorithm.\n    run() {\n        const q = new GenericBinaryHeapPriorityQueue((a, b) => a - b);\n        const d = new Map();\n        for (const node of this.graph.shallowNodes) {\n            const dist = node === this.source ? 0 : Number.POSITIVE_INFINITY;\n            q.Enqueue(node, dist);\n            d.set(node, dist);\n        }\n        while (q.count > 0) {\n            const t = { priority: 0 };\n            const u = q.DequeueAndGetPriority(t);\n            d.set(u, t.priority);\n            const distU = d.get(u);\n            for (const vu of u.inEdges()) {\n                const v = vu.source;\n                // relaxation step\n                const nl = distU + this.length(vu);\n                if (d.get(v) > nl) {\n                    d.set(v, nl);\n                    q.DecreasePriority(v, nl);\n                }\n            }\n            for (const uv of u.outEdges()) {\n                const v = uv.target;\n                // relaxation step\n                const nl = distU + this.length(uv);\n                if (d.get(v) > nl) {\n                    d.set(v, nl);\n                    q.DecreasePriority(v, nl);\n                }\n            }\n        }\n        this.result = new Array(this.graph.shallowNodeCount);\n        let i = 0;\n        for (const v of this.graph.shallowNodes) {\n            const dist = d.get(v);\n            if (dist !== undefined) {\n                this.result[i++] = dist;\n            }\n            else {\n                this.result[i++] = Number.POSITIVE_INFINITY;\n            }\n        }\n    }\n}\n//# sourceMappingURL=SingleSourceDistances.js.map","export class Transform {\n    // Rotates a 2D configuration clockwise by a given angle\n    // The angle is given in degrees\n    static Rotate(x, y, angle) {\n        const sin = Math.sin(angle * (Math.PI / 180));\n        const cos = Math.cos(angle * (Math.PI / 180));\n        for (let i = 0; i < x.length; i++) {\n            const t = cos * x[i] + sin * y[i];\n            y[i] = cos * y[i] - sin * x[i];\n            x[i] = t;\n        }\n    }\n}\n//# sourceMappingURL=Transform.js.map","import { Point } from '../../math/geometry/point';\nimport { Rectangle } from '../../math/geometry/rectangle';\nimport { AllPairsDistances } from './AllPairsDistances';\nimport { PivotDistances } from './pivotDistances';\nimport { Transform } from './Transform';\nimport { Algorithm } from '../../utils/algorithm';\nimport { MultidimensionalScaling } from './multiDimensionalScaling';\nimport { OptimalRectanglePacking } from '../../math/geometry/rectanglePacking/OptimalRectanglePacking';\nimport { GTreeOverlapRemoval } from '../gTreeOverlapRemoval/gTreeOverlapRemoval';\n// Class for graph layout with multidimensional scaling.\nexport class MdsGraphLayout extends Algorithm {\n    // Constructs the multidimensional scaling algorithm.\n    constructor(settings, geometryGraph, cancelToken, length) {\n        super(cancelToken);\n        this.settings = settings;\n        this.graph = geometryGraph;\n        this.length = length;\n    }\n    // Executes the algorithm\n    run() {\n        this.LayoutConnectedGraphWithMds();\n        this.graph.pumpTheBoxToTheGraphWithMargins();\n    }\n    // Scales a configuration such that the average edge length in the drawing\n    // equals the average of the given edge lengths.\n    static ScaleToAverageEdgeLength(g, x, y, length) {\n        const index = new Map();\n        let c = 0;\n        for (const node of g.shallowNodes) {\n            index.set(node, c);\n            c++;\n        }\n        let avgLength = 0;\n        let avgSum = 0;\n        for (const edge of g.shallowEdges) {\n            const i = index.get(edge.source);\n            const j = index.get(edge.target);\n            avgSum += Math.sqrt(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2));\n            avgLength += length(edge);\n        }\n        if (avgLength > 0) {\n            avgSum /= avgLength;\n        }\n        if (avgSum > 0) {\n            for (let i = 0; i < x.length; i++) {\n                x[i] /= avgSum;\n                y[i] /= avgSum;\n            }\n        }\n    }\n    // Layouts a connected graph with Multidimensional Scaling, using\n    // shortest-path distances as Euclidean target distances.\n    static LayoutGraphWithMds(geometryGraph, settings, arrays, length) {\n        arrays.x = new Array(geometryGraph.shallowNodeCount);\n        arrays.y = new Array(geometryGraph.shallowNodeCount);\n        if (arrays.x.length === 0) {\n            return;\n        }\n        if (arrays.x.length === 1) {\n            arrays.x[0] = arrays.y[0] = 0;\n            return;\n        }\n        const k = Math.min(settings.PivotNumber, geometryGraph.shallowNodeCount);\n        const iter = settings.GetNumberOfIterationsWithMajorization(geometryGraph.shallowNodeCount);\n        const exponent = settings.Exponent;\n        const pivotArray = new Array(k);\n        const pivotDistances = new PivotDistances(geometryGraph, pivotArray, length);\n        pivotDistances.run();\n        const c = pivotDistances.Result;\n        MultidimensionalScaling.LandmarkClassicalScaling(c, arrays, pivotArray);\n        MdsGraphLayout.ScaleToAverageEdgeLength(geometryGraph, arrays.x, arrays.y, length);\n        if (iter > 0) {\n            const apd = new AllPairsDistances(geometryGraph, length);\n            apd.run();\n            const d = apd.Result;\n            const w = MultidimensionalScaling.ExponentialWeightMatrix(d, exponent);\n            // MultidimensionalScaling.DistanceScaling(d, x, y, w, iter);\n            MultidimensionalScaling.DistanceScalingSubset(d, arrays.x, arrays.y, w, iter);\n        }\n    }\n    LayoutConnectedGraphWithMds() {\n        const arrays = { x: [], y: [] };\n        MdsGraphLayout.LayoutGraphWithMds(this.graph, this.settings, arrays, this.length);\n        if (this.settings.RotationAngle !== 0) {\n            Transform.Rotate(arrays.x, arrays.y, this.settings.RotationAngle);\n        }\n        let index = 0;\n        for (const node of this.graph.shallowNodes) {\n            if (node.boundingBox) {\n                node.center = new Point(arrays.x[index] * this.settings.ScaleX, arrays.y[index] * this.settings.ScaleY);\n            }\n            index++;\n        }\n        if (this.settings.removeOverlaps) {\n            GTreeOverlapRemoval.RemoveOverlaps(Array.from(this.graph.shallowNodes), this.settings.NodeSeparation);\n        }\n        this.graph.pumpTheBoxToTheGraphWithMargins();\n    }\n    ScaleNodes(nodes, scale) {\n        for (const node of nodes) {\n            node.center = node.center.mul(scale);\n        }\n    }\n    //  static UpdateTree(tree: RectangleNode<Node, Point>) {\n    //    if (tree.IsLeaf) {\n    //      tree.irect = tree.UserData.BoundingBox\n    //    } else {\n    //      MdsGraphLayout.UpdateTree(tree.Left)\n    //      MdsGraphLayout.UpdateTree(tree.Right)\n    //      tree.rectangle = tree.Left.rectangle\n    //      tree.rectangle.Add(tree.Right.rectangle)\n    //    }\n    //  }\n    //  static NumberOfHits(\n    //    numberOfChecks: number,\n    //    random: Random,\n    //    tree: RectangleNode<Node, Point>,\n    //    maxNumberOfHits: number,\n    //  ): number {\n    //    //  var l = new Array<Point>();\n    //    let numberOfHits = 0\n    //    for (let i = 0; i < numberOfChecks; i++) {\n    //      const point: Point = MdsGraphLayout.RandomPointFromBox(\n    //        random,\n    //        <Rectangle>tree.rectangle,\n    //      )\n    //      //    l.Add(point);\n    //      HitTestBehavior.Stop\n    //      null\n    //      numberOfHits++\n    //      if (numberOfHits === maxNumberOfHits) {\n    //        return maxNumberOfHits\n    //      }\n    //    }\n    //    // LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(Getdc(tree, l));\n    //    return numberOfHits\n    //  }\n    //  static BuildNodeTree(nodes: IList<Node>): RectangleNode<Node, Point> {\n    //    return RectangleNode.CreateRectangleNodeOnListOfNodes(\n    //      nodes.Select(() => {}, new RectangleNode<Node, Point>(n, n.BoundingBox)),\n    //    )\n    //  }\n    //  static RandomPointFromBox(random: Random, boundingBox: Rectangle): Point {\n    //    const x = random.NextDouble()\n    //    const y = random.NextDouble()\n    //    const p = new Point(\n    //      boundingBox.left + boundingBox.width * x,\n    //      boundingBox.bottom + boundingBox.height * y,\n    //    )\n    //    return p\n    //  }\n    // Pack the given graph components to the specified aspect ratio\n    static PackGraphs(graphs, settings) {\n        if (graphs.length === 0) {\n            return Rectangle.mkEmpty();\n        }\n        if (graphs.length === 1)\n            return graphs[0].boundingBox;\n        const rectangles = graphs.map((g) => g.boundingBox);\n        const originalLeftBottoms = new Array();\n        for (const g of graphs) {\n            originalLeftBottoms.push({ g: g, lb: g.boundingBox.leftBottom.clone() });\n        }\n        const packing = new OptimalRectanglePacking(rectangles, settings.PackingAspectRatio);\n        packing.run();\n        for (const { g, lb } of originalLeftBottoms) {\n            const delta = g.boundingBox.leftBottom.sub(lb);\n            g.translate(delta);\n        }\n        return new Rectangle({\n            left: 0,\n            bottom: 0,\n            right: packing.PackedWidth,\n            top: packing.PackedHeight,\n        });\n    }\n}\n//# sourceMappingURL=mDSGraphLayout.js.map","import { CommonLayoutSettings } from '../commonLayoutSettings';\n/** Settings for multi-dimensional scaling */\nexport class MdsLayoutSettings {\n    constructor() {\n        this.commonSettings = new CommonLayoutSettings();\n        // the setting of Multi-Dimensional Scaling layout\n        // private double epsilon = Math.Pow(10,-8);\n        this.pivotNumber = 50;\n        this.iterationsWithMajorization = 30;\n        this.scaleX = 100;\n        this.scaleY = 100;\n        this.exponent = -2;\n        this.rotationAngle = 0;\n        this._removeOverlaps = true;\n        /** do not call iterations with majorization, the local layout improvement heuristic, for graph with at least 2000 nodes */\n        this._callIterationsWithMajorizationThreshold = 2000;\n        this.adjustScale = false;\n    }\n    static fromJSON(s) {\n        const ret = new MdsLayoutSettings();\n        if (s.pivotNumber)\n            ret.pivotNumber = s.pivotNumber;\n        if (s.iterationsWithMajorization)\n            ret.iterationsWithMajorization = s.iterationsWithMajorization;\n        if (s.scaleX)\n            ret.scaleX = s.scaleX;\n        if (s.scaleY)\n            ret.scaleY = s.scaleY;\n        if (s.exponent)\n            ret.exponent = s.exponent;\n        if (s.rotationAngle)\n            ret.rotationAngle = s.rotationAngle;\n        if (s.removeOverlaps != undefined)\n            ret._removeOverlaps = s.removeOverlaps;\n        if (s._callIterationsWithMajorizationThreshold)\n            ret._callIterationsWithMajorizationThreshold = s._callIterationsWithMajorizationThreshold;\n        return ret;\n    }\n    toJSON() {\n        const ret = {};\n        if (this.pivotNumber != 50)\n            ret.pivotNumber = this.pivotNumber;\n        if (this.iterationsWithMajorization != 30)\n            ret.iterationsWithMajorization = this.iterationsWithMajorization;\n        if (this.scaleX != 200)\n            ret.scaleX = this.scaleX;\n        if (this.scaleY != 200)\n            ret.scaleY = this.scaleY;\n        if (this.exponent != -2)\n            ret.exponent = this.exponent;\n        if (this.rotationAngle != 0)\n            ret.rotationAngle = this.rotationAngle;\n        if (!this._removeOverlaps)\n            ret.removeOverlaps = this._removeOverlaps;\n        if (this._callIterationsWithMajorizationThreshold != 3000)\n            ret._callIterationsWithMajorizationThreshold = this._callIterationsWithMajorizationThreshold;\n        return ret;\n    }\n    get NodeSeparation() {\n        return this.commonSettings.NodeSeparation;\n    }\n    set NodeSeparation(value) {\n        this.commonSettings.NodeSeparation = value;\n    }\n    get edgeRoutingSettings() {\n        return this.commonSettings.edgeRoutingSettings;\n    }\n    set edgeRoutingSettings(value) {\n        this.commonSettings.edgeRoutingSettings = value;\n    }\n    // remove overlaps between node boundaries\n    get removeOverlaps() {\n        return this._removeOverlaps;\n    }\n    set removeOverlaps(value) {\n        this._removeOverlaps = value;\n    }\n    // Number of pivots in Landmark Scaling (between 3 and number of objects).\n    get PivotNumber() {\n        return this.pivotNumber;\n    }\n    set PivotNumber(value) {\n        this.pivotNumber = value;\n    }\n    /** Number of iterations in distance scaling: these iterations beautify the layout locally. This heuristic is optional , and the property has to be set to zero for a large graph, because each iteration has O(n*n) time, where n is the number of nodes in the graph */\n    get IterationsWithMajorization() {\n        return this.iterationsWithMajorization;\n    }\n    set IterationsWithMajorization(value) {\n        this.iterationsWithMajorization = value;\n    }\n    // X Scaling Factor.\n    get ScaleX() {\n        return this.scaleX;\n    }\n    set ScaleX(value) {\n        this.scaleX = value;\n    }\n    // Y Scaling Factor.\n    get ScaleY() {\n        return this.scaleY;\n    }\n    set ScaleY(value) {\n        /*Assert.assert(!isNaN(value))*/\n        this.scaleY = value;\n    }\n    // Weight matrix exponent.\n    get Exponent() {\n        return this.exponent;\n    }\n    set Exponent(value) {\n        this.exponent = value;\n    }\n    // rotation angle\n    get RotationAngle() {\n        return this.rotationAngle;\n    }\n    set RotationAngle(value) {\n        this.rotationAngle = value % 360;\n    }\n    // Adjust the scale of the graph if there is not enough whitespace between nodes\n    get AdjustScale() {\n        return this.adjustScale;\n    }\n    set AdjustScale(value) {\n        this.adjustScale = value;\n    }\n    GetNumberOfIterationsWithMajorization(nodeCount) {\n        if (nodeCount > this.CallIterationsWithMajorizationThreshold) {\n            return 0;\n        }\n        return this.IterationsWithMajorization;\n    }\n    get CallIterationsWithMajorizationThreshold() {\n        return this._callIterationsWithMajorizationThreshold;\n    }\n    set CallIterationsWithMajorizationThreshold(value) {\n        this._callIterationsWithMajorizationThreshold = value;\n    }\n}\n//# sourceMappingURL=mDSLayoutSettings.js.map","import { random } from '../../utils/random';\nexport class MultidimensionalScaling {\n    // Double-centers a matrix of such a way that the center of gravity is zero.\n    // After number-centering, each row and each column sums up to zero.\n    static DoubleCenter(matrix) {\n        const rowMean = new Array(matrix.length).fill(0);\n        const colMean = new Array(matrix[0].length).fill(0);\n        let mean = 0;\n        for (let i = 0; i < matrix.length; i++) {\n            for (let j = 0; j < matrix[0].length; j++) {\n                rowMean[i] += matrix[i][j];\n                colMean[j] += matrix[i][j];\n                mean += matrix[i][j];\n            }\n        }\n        for (let i = 0; i < matrix.length; i++)\n            rowMean[i] /= matrix.length;\n        for (let j = 0; j < matrix[0].length; j++)\n            colMean[j] /= matrix[0].length;\n        mean /= matrix.length;\n        mean /= matrix[0].length;\n        for (let i = 0; i < matrix.length; i++) {\n            for (let j = 0; j < matrix[0].length; j++) {\n                matrix[i][j] -= rowMean[i] + colMean[j] - mean;\n            }\n        }\n    }\n    // Squares all entries of a matrix.\n    static SquareEntries(matrix) {\n        for (let i = 0; i < matrix.length; i++) {\n            for (let j = 0; j < matrix[0].length; j++) {\n                matrix[i][j] = Math.pow(matrix[i][j], 2);\n            }\n        }\n    }\n    // Multiplies a matrix with a scalar factor.\n    static Multiply(matrix, factor) {\n        for (let i = 0; i < matrix.length; i++) {\n            for (let j = 0; j < matrix[0].length; j++) {\n                matrix[i][j] *= factor;\n            }\n        }\n    }\n    // Multiply a square matrix and a vector.\n    // Note that matrix width and vector length\n    // have to be equal, otherwise null is returned.\n    static MultiplyX(A, x) {\n        if (A[0].length !== x.length)\n            return null;\n        const y = new Array(x.length).fill(0);\n        for (let i = 0; i < A.length; i++) {\n            for (let j = 0; j < A[0].length; j++) {\n                y[i] += A[i][j] * x[j];\n            }\n        }\n        return y;\n    }\n    // Gives the norm of a vector, that is, its length in\n    // vector.length dimensional Euclidean space.\n    static Norm(x) {\n        let norm = 0;\n        for (let i = 0; i < x.length; i++) {\n            norm += Math.pow(x[i], 2);\n        }\n        return Math.sqrt(norm);\n    }\n    // Normalizes a vector to unit length (1.0) in\n    // vector.length dimensional Euclidean space.\n    // If the vector is the 0-vector, nothing is done.\n    static Normalize(x) {\n        const lambda = MultidimensionalScaling.Norm(x);\n        if (lambda <= 0)\n            return 0;\n        for (let i = 0; i < x.length; i++) {\n            x[i] /= lambda;\n        }\n        return lambda;\n    }\n    // Gives a random unit Euclidean length vector of a given size.\n    static RandomUnitLengthVector(n) {\n        const result = new Array(n);\n        for (let i = 0; i < n; i++) {\n            result[i] = random();\n        }\n        MultidimensionalScaling.Normalize(result);\n        return result;\n    }\n    // Computes the two dominant eigenvectors and eigenvalues of a symmetric\n    // square matrix.\n    static SpectralDecomposition(A, t) {\n        MultidimensionalScaling.SpectralDecompositionIE(A, t, 30, 1e-6);\n    }\n    // Computes the two dominant eigenvectors and eigenvalues of a symmetric\n    // square matrix.\n    static SpectralDecompositionIE(A, t, maxIterations, epsilon) {\n        const n = A[0].length;\n        t.u1 = MultidimensionalScaling.RandomUnitLengthVector(n);\n        t.lambda1 = 0;\n        t.u2 = MultidimensionalScaling.RandomUnitLengthVector(n);\n        t.lambda2 = 0;\n        let r = 0;\n        const limit = 1.0 - epsilon;\n        // iterate until convergence but at most 30 steps\n        for (let i = 0; i < maxIterations && r < limit; i++) {\n            const x1 = MultidimensionalScaling.MultiplyX(A, t.u1);\n            const x2 = MultidimensionalScaling.MultiplyX(A, t.u2);\n            t.lambda1 = MultidimensionalScaling.Normalize(x1);\n            t.lambda2 = MultidimensionalScaling.Normalize(x2);\n            MultidimensionalScaling.MakeOrthogonal(x2, x1);\n            MultidimensionalScaling.Normalize(x2);\n            // convergence is assumed if the inner product of\n            // two consecutive (unit length) iterates is close to 1\n            r = Math.min(MultidimensionalScaling.DotProduct(t.u1, x1), MultidimensionalScaling.DotProduct(t.u2, x2));\n            t.u1 = x1;\n            t.u2 = x2;\n        }\n    }\n    // Gives the inner product of two vectors of the same size.\n    static DotProduct(x, y) {\n        if (x.length !== y.length)\n            return 0;\n        let result = 0;\n        for (let i = 0; i < x.length; i++) {\n            result += x[i] * y[i];\n        }\n        return result;\n    }\n    // Orthogonalizes a vector against another vector, so that\n    // their scalar product is 0.\n    static MakeOrthogonal(x, y) {\n        if (x.length !== y.length)\n            return;\n        const prod = MultidimensionalScaling.DotProduct(x, y) / MultidimensionalScaling.DotProduct(y, y);\n        for (let i = 0; i < x.length; i++) {\n            x[i] -= prod * y[i];\n        }\n    }\n    // Classical multidimensional scaling.  Computes two-dimensional coordinates\n    // for a given distance matrix by computing the two largest eigenvectors\n    // and eigenvalues of a matrix assiciated with the distance matrix (called\n    // \"fitting inner products\").\n    static ClassicalScaling(d, t) {\n        const b = new Array(d.length);\n        for (let i = 0; i < d.length; i++) {\n            b[i] = d[i].slice();\n        }\n        MultidimensionalScaling.SquareEntries(b);\n        MultidimensionalScaling.DoubleCenter(b);\n        MultidimensionalScaling.Multiply(b, -0.5);\n        MultidimensionalScaling.SpectralDecomposition(b, t);\n        t.lambda1 = Math.sqrt(Math.abs(t.lambda1));\n        t.lambda2 = Math.sqrt(Math.abs(t.lambda2));\n        for (let i = 0; i < t.u1.length; i++) {\n            t.u1[i] *= t.lambda1;\n            t.u2[i] *= t.lambda2;\n        }\n    }\n    // Multidimensional scaling.  Computes two-dimensional coordinates\n    // for a given distance matrix by fitting the coordinates to these distances\n    // iteratively by majorization (called \"distance fitting\").\n    // Only objects that have rows of the distance/weight matrix\n    // is subject to iterative relocation.\n    static DistanceScalingSubset(d, x, y, w, numberOfIterations) {\n        const n = x.length;\n        const k = d.length;\n        const index = new Array(k);\n        for (let i = 0; i < k; i++) {\n            for (let j = 0; j < n; j++) {\n                if (d[i][j] === 0) {\n                    index[i] = j;\n                }\n            }\n        }\n        const wSum = new Array(k).fill(0);\n        for (let i = 0; i < k; i++) {\n            for (let j = 0; j < n; j++) {\n                if (index[i] !== j) {\n                    wSum[i] += w[i][j];\n                }\n            }\n        }\n        for (let c = 0; c < numberOfIterations; c++) {\n            for (let i = 0; i < k; i++) {\n                let xNew = 0;\n                let yNew = 0;\n                for (let j = 0; j < n; j++) {\n                    if (i !== j) {\n                        let inv = Math.sqrt(Math.pow(x[index[i]] - x[j], 2) + Math.pow(y[index[i]] - y[j], 2));\n                        if (inv > 0)\n                            inv = 1 / inv;\n                        xNew += w[i][j] * (x[j] + d[i][j] * (x[index[i]] - x[j]) * inv);\n                        yNew += w[i][j] * (y[j] + d[i][j] * (y[index[i]] - y[j]) * inv);\n                    }\n                }\n                x[index[i]] = xNew / wSum[i];\n                y[index[i]] = yNew / wSum[i];\n            }\n        }\n    }\n    // Multidimensional scaling.  Computes two-dimensional coordinates\n    // for a given distance matrix by fitting the coordinates to these distances\n    // iteratively by majorization (called \"distance fitting\").\n    // (McGee, Kamada-Kawai)\n    static DistanceScaling(d, x, y, w, iter) {\n        const n = x.length;\n        const wSum = new Array(n).fill(0);\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (i !== j)\n                    wSum[i] += w[i][j];\n            }\n        }\n        for (let c = 0; c < iter; c++) {\n            for (let i = 0; i < n; i++) {\n                let xNew = 0;\n                let yNew = 0;\n                for (let j = 0; j < n; j++) {\n                    if (i !== j) {\n                        let inv = Math.sqrt(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2));\n                        if (inv > 0)\n                            inv = 1 / inv;\n                        xNew += w[i][j] * (x[j] + d[i][j] * (x[i] - x[j]) * inv);\n                        yNew += w[i][j] * (y[j] + d[i][j] * (y[i] - y[j]) * inv);\n                    }\n                }\n                x[i] = xNew / wSum[i];\n                y[i] = yNew / wSum[i];\n            }\n        }\n    }\n    // Convenience method for generating a weight matrix from a distance matrix.\n    // Each output entry is the corresponding input entry powered by a constant\n    // exponent.\n    static ExponentialWeightMatrix(d, exponent) {\n        const w = new Array(d.length);\n        for (let i = 0; i < d.length; i++) {\n            w[i] = new Array(d[i].length).fill(0);\n            for (let j = 0; j < d[i].length; j++) {\n                if (d[i][j] > 0)\n                    w[i][j] = Math.pow(d[i][j], exponent);\n            }\n        }\n        return w;\n    }\n    // Convenience method for all Euclidean distances within two-dimensional\n    // positions.\n    static EuclideanDistanceMatrix(x, y) {\n        const d = new Array(x.length);\n        for (let i = 0; i < x.length; i++) {\n            d[i] = new Array(x.length);\n            for (let j = 0; j < x.length; j++) {\n                d[i][j] = Math.sqrt(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2));\n            }\n        }\n        return d;\n    }\n    // Approximation to classical multidimensional scaling.\n    // Computes two-dimensional coordinates\n    // for a given rectangular distance matrix.\n    static LandmarkClassicalScaling(d, t, pivotArray) {\n        const c = new Array(d.length);\n        for (let i = 0; i < d.length; i++) {\n            c[i] = new Array(d.length);\n            for (let j = 0; j < d.length; j++) {\n                c[i][j] = d[i][pivotArray[j]];\n            }\n        }\n        MultidimensionalScaling.SquareEntries(c);\n        const mean = new Array(d.length).fill(0);\n        for (let i = 0; i < d.length; i++) {\n            for (let j = 0; j < d.length; j++) {\n                mean[i] += c[i][j];\n            }\n            mean[i] /= d.length;\n        }\n        MultidimensionalScaling.DoubleCenter(c);\n        MultidimensionalScaling.Multiply(c, -0.5);\n        const tt = {\n            u1: new Array(),\n            u2: new Array(),\n            lambda1: 0,\n            lambda2: 0,\n        };\n        MultidimensionalScaling.SpectralDecomposition(c, tt);\n        tt.lambda1 = Math.sqrt(Math.abs(tt.lambda1));\n        tt.lambda2 = Math.sqrt(Math.abs(tt.lambda2));\n        // place non-pivots by weighted barycenter\n        t.x = new Array(d[0].length).fill(0);\n        t.y = new Array(d[0].length).fill(0);\n        for (let i = 0; i < t.x.length; i++) {\n            for (let j = 0; j < c.length; j++) {\n                const c = (Math.pow(d[j][i], 2) - mean[j]) / 2;\n                t.x[i] -= tt.u1[j] * c;\n                t.y[i] -= tt.u2[j] * c;\n            }\n        }\n    }\n}\n//# sourceMappingURL=multiDimensionalScaling.js.map","import { Algorithm } from '../../utils/algorithm';\nimport { SingleSourceDistances } from './SingleSourceDistances';\n// An algorithm for computing the distances between a selected set of nodes and all nodes.\nexport class PivotDistances extends Algorithm {\n    // A square matrix with shortest path distances.\n    get Result() {\n        return this.result;\n    }\n    // Computes distances between a selected set of nodes and all nodes.\n    // Pivot nodes are selected with maxmin strategy (first at random, later\n    // ones to maximize distances to all previously selected ones).\n    constructor(graph, pivotArray, length) {\n        super(null); // todo: pass the canceltoken\n        this.graph = graph;\n        this.pivotArray = pivotArray;\n        this.length = length;\n    }\n    // Executes the algorithm.\n    run() {\n        this.result = new Array(this.pivotArray.length);\n        const nodes = Array.from(this.graph.shallowNodes);\n        const min = new Array(this.graph.shallowNodeCount).fill(Number.POSITIVE_INFINITY);\n        let pivot = nodes[0];\n        this.pivotArray[0] = 0;\n        for (let i = 0;; i++) {\n            const ssd = new SingleSourceDistances(this.graph, pivot, this.length);\n            ssd.run();\n            this.Result[i] = ssd.Result;\n            if (i + 1 < this.pivotArray.length) {\n                // looking for the next pivot\n                let argmax = 0;\n                for (let j = 0; j < this.Result[i].length; j++) {\n                    min[j] = Math.min(min[j], this.Result[i][j]);\n                    if (min[j] > min[argmax]) {\n                        argmax = j;\n                    }\n                }\n                pivot = nodes[argmax];\n                this.pivotArray[i + 1] = argmax;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\n//# sourceMappingURL=pivotDistances.js.map","import { Algorithm } from '../../utils/algorithm';\nimport { optimalPackingRunner } from '../core/geomGraph';\nimport { routeEdges, enforceLayoutSettings, layoutGeomGraphDetailed } from '../driver';\nimport { MdsGraphLayout } from './mDSGraphLayout';\nimport { MdsLayoutSettings } from './mDSLayoutSettings';\nexport function layoutGraphWithMds(geomGraph, cancelToken = null) {\n    const mdsSettings = geomGraph.layoutSettings instanceof MdsLayoutSettings ? geomGraph.layoutSettings : new MdsLayoutSettings();\n    enforceLayoutSettings(geomGraph, mdsSettings);\n    layoutGeomGraphDetailed(geomGraph, cancelToken, mdsLayoutRunner, routeEdges, optimalPackingRunner);\n}\n// Initial layout using PivotMDS method for a graph with subgraphs\nexport class PivotMDS extends Algorithm {\n    get scaleX() {\n        return this.settings.ScaleX;\n    }\n    set scaleX(value) {\n        /*Assert.assert(!isNaN(value))*/\n        this.settings.ScaleX = value;\n    }\n    // scales the final layout by the specified factor on Y\n    get scaleY() {\n        return this.settings.ScaleY;\n    }\n    set scaleY(value) {\n        /*Assert.assert(!isNaN(value))*/\n        this.settings.ScaleY = value;\n    }\n    // Layout graph by the PivotMds method.  Uses spectral techniques to obtain a layout in\n    // O(n^2) time when iterations with majorization are used, otherwise it is more like O(PivotNumber*n).\n    constructor(graph, cancelToken, length, settings) {\n        super(cancelToken);\n        this.graph = graph;\n        this.length = length;\n        this.settings = settings;\n        this.settings.ScaleX = this.settings.ScaleY = 200;\n    }\n    // Executes the actual algorithm.\n    run() {\n        // with 0 majorization iterations we just do PivotMDS\n        const mdsLayout = new MdsGraphLayout(this.settings, this.graph, this.cancelToken, this.length);\n        mdsLayout.run();\n    }\n}\n// returns the map of pairs (new lifted GeomEdge, existing GeomEdge)\nfunction mdsLayoutRunner(geomG, cancelToken) {\n    const pmd = new PivotMDS(geomG, cancelToken, () => 1, geomG.layoutSettings);\n    pmd.run();\n}\n//# sourceMappingURL=pivotMDS.js.map","export var RBColor;\n(function (RBColor) {\n    RBColor[RBColor[\"Red\"] = 0] = \"Red\";\n    RBColor[RBColor[\"Black\"] = 1] = \"Black\";\n})(RBColor || (RBColor = {}));\n//# sourceMappingURL=rbColor.js.map","export class RBNode {\n    constructor(color, item, parent, left, right) {\n        this.color = color;\n        if (item !== undefined)\n            this.item = item;\n        if (parent !== undefined)\n            this.parent = parent;\n        if (left !== undefined)\n            this.left = left;\n        if (right !== undefined)\n            this.right = right;\n    }\n    toString() {\n        return this.item.toString();\n    }\n}\n//# sourceMappingURL=rbNode.js.map","import { RBNode } from './rbNode';\nimport { RBColor } from './rbColor';\nexport class RBTree {\n    [Symbol.iterator]() {\n        return this.allNodes();\n    }\n    constructor(comparer) {\n        this.comparer = comparer;\n        this.count = 0;\n        this.root = this.nil = new RBNode(RBColor.Black);\n    }\n    clear() {\n        this.root = this.nil = new RBNode(RBColor.Black);\n    }\n    toNull(y) {\n        return y !== this.nil ? y : null;\n    }\n    isEmpty() {\n        return this.root === this.nil;\n    }\n    getComparer() {\n        return this.comparer;\n    }\n    getRoot() {\n        return this.root;\n    }\n    find(i, x = this.root) {\n        let compareResult;\n        while (x !== this.nil && (compareResult = this.comparer(i, x.item)) !== 0)\n            x = compareResult < 0 ? x.left : x.right;\n        return this.toNull(x);\n    }\n    findFirst(predicate, n = this.root) {\n        if (n === this.nil)\n            return null;\n        let good = null;\n        while (n !== this.nil) {\n            n = predicate(n.item) ? (good = n).left : n.right;\n        }\n        return good;\n    }\n    findLast(predicate, n = this.root) {\n        if (n === this.nil)\n            return null;\n        let good = null;\n        while (n !== this.nil)\n            n = predicate(n.item) ? (good = n).right : n.left;\n        return good;\n    }\n    treeMinimum(x = this.root) {\n        while (x.left !== this.nil)\n            x = x.left;\n        return this.toNull(x);\n    }\n    treeMaximum(x = this.root) {\n        while (x.right !== this.nil)\n            x = x.right;\n        return this.toNull(x);\n    }\n    next(x) {\n        if (x.right !== this.nil)\n            return this.treeMinimum(x.right);\n        let y = x.parent;\n        while (y !== this.nil && x === y.right) {\n            x = y;\n            y = y.parent;\n        }\n        return this.toNull(y);\n    }\n    previous(x) {\n        if (x.left !== this.nil)\n            return this.treeMaximum(x.left);\n        let y = x.parent;\n        while (y !== this.nil && x === y.left) {\n            x = y;\n            y = y.parent;\n        }\n        return this.toNull(y);\n    }\n    leftRotate(x) {\n        const y = x.right;\n        x.right = y.left;\n        if (y.left !== this.nil)\n            y.left.parent = x;\n        y.parent = x.parent;\n        if (x.parent === this.nil)\n            this.root = y;\n        else if (x === x.parent.left)\n            x.parent.left = y;\n        else\n            x.parent.right = y;\n        y.left = x;\n        x.parent = y;\n    }\n    rightRotate(x) {\n        const y = x.left;\n        x.left = y.right;\n        if (y.right !== this.nil)\n            y.right.parent = x;\n        y.parent = x.parent;\n        if (x.parent === this.nil)\n            this.root = y;\n        else if (x === x.parent.right)\n            x.parent.right = y;\n        else\n            x.parent.left = y;\n        y.right = x;\n        x.parent = y;\n    }\n    deleteFixup(x) {\n        while (x !== this.root && x.color === RBColor.Black) {\n            if (x === x.parent.left) {\n                let w = x.parent.right;\n                if (w.color === RBColor.Red) {\n                    w.color = RBColor.Black;\n                    x.parent.color = RBColor.Red;\n                    this.leftRotate(x.parent);\n                    w = x.parent.right;\n                }\n                if (w.left.color === RBColor.Black && w.right.color === RBColor.Black) {\n                    w.color = RBColor.Red;\n                    x = x.parent;\n                }\n                else {\n                    if (w.right.color === RBColor.Black) {\n                        w.left.color = RBColor.Black;\n                        w.color = RBColor.Red;\n                        this.rightRotate(w);\n                        w = x.parent.right;\n                    }\n                    w.color = x.parent.color;\n                    x.parent.color = RBColor.Black;\n                    w.right.color = RBColor.Black;\n                    this.leftRotate(x.parent);\n                    x = this.root;\n                }\n            }\n            else {\n                let w = x.parent.left;\n                if (w.color === RBColor.Red) {\n                    w.color = RBColor.Black;\n                    x.parent.color = RBColor.Red;\n                    this.rightRotate(x.parent);\n                    w = x.parent.left;\n                }\n                if (w.right.color === RBColor.Black && w.left.color === RBColor.Black) {\n                    w.color = RBColor.Red;\n                    x = x.parent;\n                }\n                else {\n                    if (w.left.color === RBColor.Black) {\n                        w.right.color = RBColor.Black;\n                        w.color = RBColor.Red;\n                        this.leftRotate(w);\n                        w = x.parent.left;\n                    }\n                    w.color = x.parent.color;\n                    x.parent.color = RBColor.Black;\n                    w.left.color = RBColor.Black;\n                    this.rightRotate(x.parent);\n                    x = this.root;\n                }\n            }\n        }\n        x.color = RBColor.Black;\n    }\n    deleteSubTree(z) {\n        //Assert.assert(z !== nil);\n        /*Assert.assert(z !== this.nil, 'root of subtree to delete must not be null.')*/\n        let y;\n        if (z.left === this.nil || z.right === this.nil) {\n            /* y has a nil node as a child */\n            y = z;\n        }\n        else {\n            /* find tree successor with a nilnode as a child */\n            y = z.right;\n            while (y.left !== this.nil)\n                y = y.left;\n        }\n        /* x is y's only child */\n        const x = y.left !== this.nil ? y.left : y.right;\n        x.parent = y.parent;\n        if (y.parent === this.nil)\n            this.root = x;\n        else {\n            if (y === y.parent.left)\n                y.parent.left = x;\n            else\n                y.parent.right = x;\n        }\n        if (y !== z)\n            z.item = y.item;\n        if (y.color === RBColor.Black)\n            this.deleteFixup(x);\n        return this.toNull(z);\n    }\n    deleteNodeInternal(x) {\n        this.count--;\n        this.deleteSubTree(x);\n    }\n    remove(i) {\n        const n = this.find(i);\n        if (n != null) {\n            this.count--;\n            return this.deleteSubTree(n);\n        }\n        return null;\n    }\n    insert(v) {\n        const x = this.treeInsert(v);\n        this.insertPrivate(x);\n        return this.toNull(x);\n    }\n    treeInsert(z) {\n        let y = this.nil;\n        let x = this.root;\n        let compareRes = 0;\n        while (x !== this.nil) {\n            y = x;\n            //#if SHARPKIT //https://code.google.com/p/sharpkit/issues/detail?id=368\n            // compareRes = Comparer.Compare(z, x.Item);\n            // x = compareRes < 0 ? x.left : x.right;\n            compareRes = this.comparer(z, x.item);\n            x = compareRes < 0 ? x.left : x.right;\n            // #else\n            //    x = (compareRes = Comparer.Compare(z, x.Item)) < 0 ? x.left : x.right;\n            // #endif\n        }\n        const nz = new RBNode(RBColor.Black, z, y, this.nil, this.nil);\n        if (y === this.nil)\n            this.root = nz;\n        else if (compareRes < 0)\n            y.left = nz;\n        else\n            y.right = nz;\n        return this.toNull(nz);\n    }\n    insertPrivate(x) {\n        this.count++;\n        x.color = RBColor.Red;\n        while (x !== this.root && x.parent.color === RBColor.Red) {\n            if (x.parent === x.parent.parent.left) {\n                const y = x.parent.parent.right;\n                if (y.color === RBColor.Red) {\n                    x.parent.color = RBColor.Black;\n                    y.color = RBColor.Black;\n                    x.parent.parent.color = RBColor.Red;\n                    x = x.parent.parent;\n                }\n                else {\n                    if (x === x.parent.right) {\n                        x = x.parent;\n                        this.leftRotate(x);\n                    }\n                    x.parent.color = RBColor.Black;\n                    x.parent.parent.color = RBColor.Red;\n                    this.rightRotate(x.parent.parent);\n                }\n            }\n            else {\n                const y = x.parent.parent.left;\n                if (y.color === RBColor.Red) {\n                    x.parent.color = RBColor.Black;\n                    y.color = RBColor.Black;\n                    x.parent.parent.color = RBColor.Red;\n                    x = x.parent.parent;\n                }\n                else {\n                    if (x === x.parent.left) {\n                        x = x.parent;\n                        this.rightRotate(x);\n                    }\n                    x.parent.color = RBColor.Black;\n                    x.parent.parent.color = RBColor.Red;\n                    this.leftRotate(x.parent.parent);\n                }\n            }\n        }\n        this.root.color = RBColor.Black;\n    }\n    *allNodes() {\n        if (this.isEmpty())\n            return;\n        let c = this.treeMinimum();\n        while (c != null) {\n            yield c.item;\n            c = this.next(c);\n        }\n        return;\n    }\n    toString() {\n        let ret = '{';\n        let i = 0;\n        for (const node of this.allNodes()) {\n            ret += node.toString();\n            if (i !== this.count - 1) {\n                ret += '\\n';\n            }\n            i++;\n        }\n        return ret + '}';\n    }\n}\n//# sourceMappingURL=rbTree.js.map","import { GeomConstants } from '../../math/geometry/geomConstants';\nexport class Interval {\n    // constructor\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    add(n) {\n        this.add_d(n);\n    }\n    add_rect(rectangle) {\n        const r = rectangle;\n        const ret = this.clone();\n        ret.add_d(r.start);\n        ret.add_d(r.end);\n        return ret;\n    }\n    clone() {\n        return new Interval(this.start, this.end);\n    }\n    contains_point(n) {\n        return this.contains_d(n);\n    }\n    contains_rect(rect) {\n        const r = rect;\n        return this.contains_d(r.start) && this.contains_d(r.end);\n    }\n    intersection_rect(rectangle) {\n        const r = rectangle;\n        return new Interval(Math.max(this.start, r.start), Math.min(this.end, r.end));\n    }\n    intersects_rect(rectangle) {\n        const r = rectangle;\n        return this.intersects(r);\n    }\n    contains_point_radius(p, radius) {\n        return this.contains_d(p - radius) && this.contains_d(p + radius);\n    }\n    //\n    static mkInterval(a, b) {\n        const i = new Interval(a.start, a.end);\n        i.add_d(b.start);\n        i.add_d(b.end);\n        return i;\n    }\n    // expanding the range to hold v\n    add_d(v) {\n        if (this.start > v) {\n            this.start = v;\n        }\n        if (this.end < v) {\n            this.end = v;\n        }\n    }\n    get Start() {\n        return this.start;\n    }\n    set Start(value) {\n        this.start = value;\n    }\n    // the length\n    get Length() {\n        return this.end - this.start;\n    }\n    // return true if the value is inside the range\n    contains_d(v) {\n        return this.start <= v && v <= this.end;\n    }\n    // bringe v into the range\n    GetInRange(v) {\n        return v < this.start ? this.start : v > this.end ? this.end : v;\n    }\n    // returns true if and only if two intervals are intersecting\n    intersects(other) {\n        if (other.start > this.end + GeomConstants.distanceEpsilon) {\n            return false;\n        }\n        return !(other.end < this.start - GeomConstants.distanceEpsilon);\n    }\n}\n//# sourceMappingURL=Interval.js.map","//continue or stop the hit tree traversal\nexport var HitTestBehavior;\n(function (HitTestBehavior) {\n    HitTestBehavior[HitTestBehavior[\"Continue\"] = 0] = \"Continue\";\n    HitTestBehavior[HitTestBehavior[\"Stop\"] = 1] = \"Stop\";\n})(HitTestBehavior || (HitTestBehavior = {}));\n//# sourceMappingURL=hitTestBehavior.js.map","import { RectangleNode, mkRectangleNode, CreateRectNodeOnArrayOfRectNodes as CreateRectNodeOnArrayOfRectNodes } from './rectangleNode';\n// A search tree for rapid lookup of T objects keyed by rectangles inside a given rectangular region\n// It is very similar to \"R-TREES. A DYNAMIC INDEX STRUCTURE FOR SPATIAL SEARCHING\" by Antonin Guttman\n// Create the query tree for a given enumerable of T keyed by Rectangles\nexport function mkRTree(rectsAndData) {\n    return new BinaryRTree(CreateRectNodeOnArrayOfRectNodes(rectsAndData.map(([k, v]) => mkRectangleNode(v, k))));\n}\nfunction TransferFromSibling(parent, sibling) {\n    parent.UserData = sibling.UserData;\n    parent.Left = sibling.Left;\n    parent.Right = sibling.Right;\n    parent.Count--;\n    parent.irect = sibling.irect;\n}\nfunction UpdateParent(parent) {\n    for (let node = parent.Parent; node != null; node = node.Parent) {\n        node.Count--;\n        node.irect = node.Left.irect.add_rect(node.Right.irect);\n    }\n}\nfunction RebuildUnderNodeWithoutLeaf(nodeForRebuild, leaf) {\n    /*Assert.assert(leaf.IsLeaf)*/\n    /*Assert.assert(!nodeForRebuild.IsLeaf)*/\n    const t = new Array();\n    for (const n of nodeForRebuild.GetAllLeafNodes()) {\n        if (n !== leaf) {\n            t.push(n);\n        }\n    }\n    const newNode = CreateRectNodeOnArrayOfRectNodes(t);\n    nodeForRebuild.Count = newNode.Count;\n    nodeForRebuild.Left = newNode.Left;\n    nodeForRebuild.Right = newNode.Right;\n    nodeForRebuild.irect = newNode.Left.irect.add_rect(newNode.Right.irect);\n}\nfunction FindTopUnbalancedNode(node) {\n    for (let parent = node.Parent; parent != null; parent = parent.Parent)\n        if (!Balanced(parent))\n            return parent;\n    return null;\n}\nfunction Balanced(rectangleNode) {\n    return 2 * rectangleNode.Left.Count >= rectangleNode.Right.Count && 2 * rectangleNode.Right.Count >= rectangleNode.Left.Count;\n}\nfunction NumberOfIntersectedIsLessThanBoundOnNode(node, rect, t, conditionFunc) {\n    /*Assert.assert(t.bound > 0)*/\n    if (!node.irect.intersects_rect(rect))\n        return true;\n    if (node.IsLeaf) {\n        if (conditionFunc(node.UserData))\n            return --t.bound !== 0;\n        return true;\n    }\n    return (NumberOfIntersectedIsLessThanBoundOnNode(node.Left, rect, t, conditionFunc) &&\n        NumberOfIntersectedIsLessThanBoundOnNode(node.Right, rect, t, conditionFunc));\n}\nexport class BinaryRTree {\n    // Removes everything from the tree\n    // <\n    clear() {\n        this.RootNode = null;\n    }\n    NumberOfIntersectedIsLessThanBound(rect, bound, conditionFunc) {\n        return NumberOfIntersectedIsLessThanBoundOnNode(this._rootNode, rect, { bound: bound }, conditionFunc);\n    }\n    get RootNode() {\n        return this._rootNode;\n    }\n    set RootNode(value) {\n        this._rootNode = value;\n    }\n    // Create a query tree for a given root node\n    constructor(rootNode) {\n        this._rootNode = rootNode;\n    }\n    *GetAllLeaves() {\n        if (this._rootNode != null && this.Count > 0) {\n            for (const l of this._rootNode.GetAllLeaves())\n                yield l;\n        }\n    }\n    // The number of data elements of the tree (number of leaf nodes)\n    get Count() {\n        return this._rootNode == null ? 0 : this._rootNode.Count;\n    }\n    Add(key, value) {\n        this.AddNode(mkRectangleNode(value, key));\n    }\n    AddNode(node) {\n        if (this._rootNode == null)\n            this._rootNode = node;\n        else if (this.Count <= 2)\n            this._rootNode = CreateRectNodeOnArrayOfRectNodes(Array.from(this._rootNode.GetAllLeafNodes()).concat([node]));\n        else\n            this.AddNodeToTreeRecursive(node, this._rootNode);\n    }\n    Rebuild() {\n        this._rootNode = CreateRectNodeOnArrayOfRectNodes(Array.from(this._rootNode.GetAllLeafNodes()));\n    }\n    AddNodeToTreeRecursive(newNode, existingNode) {\n        if (existingNode.IsLeaf) {\n            existingNode.Left = mkRectangleNode(existingNode.UserData, existingNode.irect);\n            existingNode.Right = newNode;\n            existingNode.Count = 2;\n        }\n        else {\n            existingNode.Count++;\n            let leftBox;\n            let rightBox;\n            if (2 * existingNode.Left.Count < existingNode.Right.Count) {\n                // keep the balance\n                this.AddNodeToTreeRecursive(newNode, existingNode.Left);\n                existingNode.Left.irect = existingNode.Left.irect.add_rect(newNode.irect);\n            }\n            else if (2 * existingNode.Right.Count < existingNode.Left.Count) {\n                // keep the balance\n                this.AddNodeToTreeRecursive(newNode, existingNode.Right);\n                existingNode.Right.irect = existingNode.Right.irect.add_rect(newNode.irect);\n            }\n            else {\n                // decide basing on the boxes\n                leftBox = existingNode.Left.irect.add_rect(newNode.irect);\n                const delLeft = leftBox.area - existingNode.Left.irect.area;\n                rightBox = existingNode.Right.irect.add_rect(newNode.irect);\n                const delRight = rightBox.area - existingNode.Right.irect.area;\n                if (delLeft < delRight) {\n                    this.AddNodeToTreeRecursive(newNode, existingNode.Left);\n                    existingNode.Left.irect = leftBox;\n                }\n                else if (delLeft > delRight) {\n                    this.AddNodeToTreeRecursive(newNode, existingNode.Right);\n                    existingNode.Right.irect = rightBox;\n                }\n                else {\n                    // the deltas are the same; add to the smallest\n                    if (leftBox.area < rightBox.area) {\n                        this.AddNodeToTreeRecursive(newNode, existingNode.Left);\n                        existingNode.Left.irect = leftBox;\n                    }\n                    else {\n                        this.AddNodeToTreeRecursive(newNode, existingNode.Right);\n                        existingNode.Right.irect = rightBox;\n                    }\n                }\n            }\n        }\n        existingNode.irect = existingNode.Left.irect.add_rect(existingNode.Right.irect);\n    }\n    GetAllIntersecting(queryRegion) {\n        return this._rootNode == null || this.Count === 0 ? [] : Array.from(this._rootNode.GetNodeItemsIntersectingRectangle(queryRegion));\n    }\n    OneIntersecting(queryRegion) {\n        if (this._rootNode == null || this.Count === 0) {\n            return;\n        }\n        const ret = this._rootNode.FirstIntersectedNode(queryRegion);\n        if (ret == null) {\n            return;\n        }\n        return { intersectedLeaf: ret.UserData };\n    }\n    // Get all leaf nodes with rectangles intersecting the specified rectangular region\n    GetAllLeavesIntersectingRectangle(queryRegion) {\n        return this._rootNode == null || this.Count === 0 ? [] : this._rootNode.GetLeafRectangleNodesIntersectingRectangle(queryRegion);\n    }\n    // Does minimal work to determine if any objects of the tree intersect with the query region\n    IsIntersecting(queryRegion) {\n        if (this._rootNode == null || this.Count === 0)\n            return false;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const _ of this._rootNode.GetNodeItemsIntersectingRectangle(queryRegion)) {\n            return true;\n        }\n        return false;\n    }\n    // return true iff there is a node with the rectangle and UserData that equals to the parameter \"userData\"\n    Contains(rectangle, userData) {\n        if (this._rootNode == null) {\n            return false;\n        }\n        for (const node of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(rectangle)) {\n            if (node.UserData === userData)\n                return true;\n        }\n        return false;\n    }\n    Remove(rectangle, userData) {\n        if (this._rootNode == null) {\n            return;\n        }\n        let ret = undefined;\n        for (const node of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(rectangle)) {\n            if (node.UserData === userData) {\n                ret = node;\n            }\n        }\n        if (ret == null) {\n            return;\n        }\n        if (this.RootNode.Count === 1) {\n            this.RootNode = null;\n        }\n        else {\n            this.RemoveLeaf(ret);\n        }\n        return ret.UserData;\n    }\n    RemoveLeaf(leaf) {\n        /*Assert.assert(leaf.IsLeaf)*/\n        const unbalancedNode = FindTopUnbalancedNode(leaf);\n        if (unbalancedNode != null) {\n            RebuildUnderNodeWithoutLeaf(unbalancedNode, leaf);\n            UpdateParent(unbalancedNode);\n        }\n        else {\n            //replace the parent with the sibling and update bounding boxes and counts\n            const parent = leaf.Parent;\n            if (parent == null) {\n                /*Assert.assert(this._rootNode === leaf)*/\n                this._rootNode = new RectangleNode();\n            }\n            else {\n                TransferFromSibling(parent, leaf.IsLeftChild ? parent.Right : parent.Left);\n                UpdateParent(parent);\n            }\n        }\n        //  Assert.assert(TreeIsCorrect(RootNode));\n    }\n    UnbalancedNode(node) {\n        for (let parent = node.Parent; parent != null; parent = parent.Parent) {\n            if (!Balanced(parent)) {\n                return parent;\n            }\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=rTree.js.map","import { Stack } from 'stack-typescript';\nimport { HitTestBehavior } from './hitTestBehavior';\nfunction DivideNodes(nodes, seed0, seed1, gr0, gr1, t) {\n    const groupSplitThreshold = 2;\n    for (let i = 0; i < nodes.length; i++) {\n        if (i === seed0 || i === seed1)\n            continue;\n        // ReSharper disable InconsistentNaming\n        const box0_ = t.box0.add_rect(nodes[i].irect);\n        const delta0 = box0_.area - t.box0.area;\n        const box1_ = t.box1.add_rect(nodes[i].irect);\n        const delta1 = box1_.area - t.box1.area;\n        // ReSharper restore InconsistentNaming\n        //keep the tree roughly balanced\n        if (gr0.length * groupSplitThreshold < gr1.length) {\n            gr0.push(nodes[i]);\n            t.box0 = box0_;\n        }\n        else if (gr1.length * groupSplitThreshold < gr0.length) {\n            gr1.push(nodes[i]);\n            t.box1 = box1_;\n        }\n        else if (delta0 < delta1) {\n            gr0.push(nodes[i]);\n            t.box0 = box0_;\n        }\n        else if (delta1 < delta0) {\n            gr1.push(nodes[i]);\n            t.box1 = box1_;\n        }\n        else if (t.box0.area < t.box1.area) {\n            gr0.push(nodes[i]);\n            t.box0 = box0_;\n        }\n        else {\n            gr1.push(nodes[i]);\n            t.box1 = box1_;\n        }\n    }\n}\n/**  calculates an RTree with the leaves in the given nodes */\nexport function CreateRectNodeOnArrayOfRectNodes(nodes) {\n    if (nodes.length === 0)\n        return null;\n    if (nodes.length === 1)\n        return nodes[0];\n    //Finding the seeds\n    const t = { b0: nodes[0].irect, seed0: 1 };\n    const seed1 = ChooseSeeds(nodes, t);\n    //We have two seeds at hand. Build two groups.\n    const gr0 = [];\n    const gr1 = [];\n    gr0.push(nodes[t.seed0]);\n    gr1.push(nodes[seed1]);\n    //divide nodes on two groups\n    const p = { box0: nodes[t.seed0].irect, box1: nodes[seed1].irect };\n    DivideNodes(nodes, t.seed0, seed1, gr0, gr1, p);\n    const ret = mkRectangleNodeWithCount(nodes.length);\n    ret.irect = p.box0.add_rect(p.box1);\n    ret.Left = CreateRectNodeOnArrayOfRectNodes(gr0);\n    ret.Right = CreateRectNodeOnArrayOfRectNodes(gr1);\n    return ret;\n}\nfunction areaoftwo(a, b) {\n    return a.add_rect(b).area;\n}\nfunction ChooseSeeds(nodes, t) {\n    let area = areaoftwo(t.b0, nodes[t.seed0].irect);\n    for (let i = 2; i < nodes.length; i++) {\n        const area0 = areaoftwo(t.b0, nodes[i].irect);\n        if (area0 > area) {\n            t.seed0 = i;\n            area = area0;\n        }\n    }\n    //Got the first seed seed0\n    //Now looking for a seed for the second group\n    let seed1;\n    //init seed1\n    for (let i = 0; i < nodes.length; i++) {\n        if (i !== t.seed0) {\n            seed1 = i;\n            break;\n        }\n    }\n    area = nodes[t.seed0].irect.add_rect(nodes[seed1].irect).area;\n    //Now try to improve the second seed\n    for (let i = 0; i < nodes.length; i++) {\n        if (i === t.seed0)\n            continue;\n        const area1 = nodes[t.seed0].irect.add_rect(nodes[i].irect).area;\n        if (area1 > area) {\n            seed1 = i;\n            area = area1;\n        }\n    }\n    return seed1;\n}\n//calculates a tree based on the given nodes\nexport function createRectangleNodeOnData(dataEnumeration, rectangleDelegate) {\n    if (dataEnumeration == null || rectangleDelegate == null)\n        return null;\n    const nodeList = Array.from(dataEnumeration).map((d) => mkRectangleNode(d, rectangleDelegate(d)));\n    return CreateRectNodeOnArrayOfRectNodes(nodeList);\n}\nexport function mkRectangleNodeWithCount(count) {\n    const r = new RectangleNode();\n    r.Count = count;\n    return r;\n}\nexport function mkRectangleNode(data, rect) {\n    const r = new RectangleNode();\n    r.UserData = data;\n    r.irect = rect;\n    r.Count = 1;\n    return r;\n}\n// it should be a static function of a class but declaring it such creates an error\nfunction VisitTreeStatic(rectangleNode, hitTest, hitRectangle) {\n    if (rectangleNode.irect.intersects_rect(hitRectangle)) {\n        if (hitTest(rectangleNode.UserData) === HitTestBehavior.Continue) {\n            if (rectangleNode.Left != null) {\n                // If rectangleNode.Left is not null, rectangleNode.Right won't be either.\n                if (VisitTreeStatic(rectangleNode.Left, hitTest, hitRectangle) === HitTestBehavior.Continue &&\n                    VisitTreeStatic(rectangleNode.Right, hitTest, hitRectangle) === HitTestBehavior.Continue) {\n                    return HitTestBehavior.Continue;\n                }\n                return HitTestBehavior.Stop;\n            }\n            return HitTestBehavior.Continue;\n        }\n        return HitTestBehavior.Stop;\n    }\n    return HitTestBehavior.Continue;\n}\n// Represents a node containing a box and some user data.\n// Is used of curve intersections routines.\nexport class RectangleNode {\n    toString() {\n        return this.IsLeaf ? this.Count.toString() + ' ' + this.UserData : this.Count.toString();\n    }\n    // false if it is an internal node and true if it is a leaf\n    get IsLeaf() {\n        return this.left == null; /*&& right==null*/\n    } //if left is a null then right is also a null\n    //\n    get Left() {\n        return this.left;\n    }\n    set Left(value) {\n        if (this.left != null && this.left.Parent === this)\n            this.left.Parent = null;\n        this.left = value;\n        if (this.left != null)\n            this.left.Parent = this;\n    }\n    get Right() {\n        return this.right;\n    }\n    set Right(value) {\n        if (this.right != null && this.right.Parent === this)\n            this.right.Parent = null;\n        this.right = value;\n        if (this.right != null)\n            this.right.Parent = this;\n    }\n    get IsLeftChild() {\n        /*Assert.assert(this.Parent != null)*/\n        return this === this.Parent.Left;\n    }\n    // brings the first leaf which rectangle was intersected\n    FirstIntersectedNode(r) {\n        var _a;\n        if (r.intersects_rect(this.irect)) {\n            if (this.IsLeaf)\n                return this;\n            return (_a = this.Left.FirstIntersectedNode(r)) !== null && _a !== void 0 ? _a : this.Right.FirstIntersectedNode(r);\n        }\n        return null;\n    }\n    FirstHitNodeWithPredicate(point, hitTest) {\n        var _a;\n        if (!this.irect.contains_point(point))\n            return null;\n        if (this.IsLeaf) {\n            return hitTest(point, this.UserData) === HitTestBehavior.Stop ? this : null;\n        }\n        return (_a = this.Left.FirstHitNodeWithPredicate(point, hitTest)) !== null && _a !== void 0 ? _a : this.Right.FirstHitNodeWithPredicate(point, hitTest);\n    }\n    FirstHitByRectWithPredicate(rect, hitTest) {\n        var _a;\n        if (!this.irect.intersects_rect(rect))\n            return null;\n        if (this.IsLeaf) {\n            return hitTest(this.UserData) === HitTestBehavior.Stop ? this : null;\n        }\n        return (_a = this.Left.FirstHitByRectWithPredicate(rect, hitTest)) !== null && _a !== void 0 ? _a : this.Right.FirstHitByRectWithPredicate(rect, hitTest);\n    }\n    // brings the first leaf which rectangle was hit and the delegate is happy with the object\n    FirstHitNode(point) {\n        var _a;\n        if (this.irect.contains_point(point)) {\n            if (this.IsLeaf)\n                return this;\n            return (_a = this.Left.FirstHitNode(point)) !== null && _a !== void 0 ? _a : this.Right.FirstHitNode(point);\n        }\n        return null;\n    }\n    // returns all leaf nodes for which the rectangle was hit and the delegate is happy with the object\n    *AllHitItems(rectanglePar, hitTestAccept = null) {\n        const stack = new Stack();\n        stack.push(this);\n        while (stack.size > 0) {\n            const node = stack.pop();\n            if (node.irect.intersects_rect(rectanglePar)) {\n                if (node.IsLeaf) {\n                    if (hitTestAccept == null || hitTestAccept(node.UserData)) {\n                        yield node.UserData;\n                    }\n                }\n                else {\n                    stack.push(node.left);\n                    stack.push(node.right);\n                }\n            }\n        }\n    }\n    // returns all items for which the rectangle contains the point\n    *AllHitItems_(point) {\n        const stack = new Stack();\n        stack.push(this);\n        while (stack.size > 0) {\n            const node = stack.pop();\n            if (node.irect.contains_point(point)) {\n                if (node.IsLeaf)\n                    yield node.UserData;\n                else {\n                    stack.push(node.left);\n                    stack.push(node.right);\n                }\n            }\n        }\n    }\n    // Returns all leaves whose rectangles intersect hitRectangle (or all leaves before hitTest returns false).\n    VisitTree(hitTest, hitRectangle) {\n        VisitTreeStatic(this, hitTest, hitRectangle);\n    }\n    //\n    Clone() {\n        const ret = mkRectangleNodeWithCount(this.Count);\n        ret.UserData = this.UserData;\n        ret.irect = this.irect;\n        if (this.Left != null)\n            ret.Left = this.Left.Clone();\n        if (this.Right != null)\n            ret.Right = this.Right.Clone();\n        return ret;\n    }\n    // yields all leaves which rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.\n    *GetNodeItemsIntersectingRectangle(rectanglePar) {\n        for (const n of this.GetLeafRectangleNodesIntersectingRectangle(rectanglePar))\n            yield n.UserData;\n    }\n    // yields all leaves whose rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.\n    *GetLeafRectangleNodesIntersectingRectangle(rectanglePar) {\n        const stack = new Stack();\n        stack.push(this);\n        while (stack.size > 0) {\n            const node = stack.pop();\n            if (node.irect.intersects_rect(rectanglePar)) {\n                if (node.IsLeaf) {\n                    yield node;\n                }\n                else {\n                    stack.push(node.left);\n                    stack.push(node.right);\n                }\n            }\n        }\n    }\n    // Walk the tree and return the data from all leaves\n    *GetAllLeaves() {\n        for (const n of this.GetAllLeafNodes())\n            yield n.UserData;\n    }\n    *GetAllLeafNodes() {\n        //return this.EnumRectangleNodes(true /*leafOnly*/)\n        for (const p of this.EnumRectangleNodes(true))\n            yield p;\n    }\n    *EnumRectangleNodes(leafOnly) {\n        const stack = new Stack();\n        stack.push(this);\n        while (stack.size > 0) {\n            const node = stack.pop();\n            if (node.IsLeaf || !leafOnly) {\n                yield node;\n            }\n            if (!node.IsLeaf) {\n                stack.push(node.left);\n                stack.push(node.right);\n            }\n        }\n    }\n    //\n    // Walk the tree from node down and apply visitor to all nodes\n    TraverseHierarchy(node, visitor) {\n        visitor(node);\n        if (node.Left != null)\n            this.TraverseHierarchy(node.Left, visitor);\n        if (node.Right != null)\n            this.TraverseHierarchy(node.Right, visitor);\n    }\n}\n//# sourceMappingURL=rectangleNode.js.map","export function CrossRectangleNodes(a, b, action) {\n    if (!a.irect.intersects_rect(b.irect))\n        return;\n    if (a.Left == null) {\n        //a is a leat\n        if (b.Left == null)\n            //b is a leaf\n            action(a.UserData, b.UserData);\n        else {\n            CrossRectangleNodes(a, b.Left, action);\n            CrossRectangleNodes(a, b.Right, action);\n        }\n    }\n    else {\n        //a is not a leaf\n        if (b.Left != null) {\n            CrossRectangleNodes(a.Left, b.Left, action);\n            CrossRectangleNodes(a.Left, b.Right, action);\n            CrossRectangleNodes(a.Right, b.Left, action);\n            CrossRectangleNodes(a.Right, b.Right, action);\n        }\n        else {\n            // b is a leaf\n            CrossRectangleNodes(a.Left, b, action);\n            CrossRectangleNodes(a.Right, b, action);\n        }\n    }\n}\nexport function CrossRectangleNodesSameType(a, b, action) {\n    if (!a.irect.intersects_rect(b.irect))\n        return;\n    if (a === b)\n        HandleEquality(a, action);\n    else if (a.Left == null) {\n        if (b.Left == null) {\n            action(a.UserData, b.UserData);\n        }\n        else {\n            CrossRectangleNodesSameType(a, b.Left, action);\n            CrossRectangleNodesSameType(a, b.Right, action);\n        }\n    }\n    else {\n        if (b.Left != null) {\n            CrossRectangleNodesSameType(a.Left, b.Left, action);\n            CrossRectangleNodesSameType(a.Left, b.Right, action);\n            CrossRectangleNodesSameType(a.Right, b.Left, action);\n            CrossRectangleNodesSameType(a.Right, b.Right, action);\n        }\n        else {\n            CrossRectangleNodesSameType(a.Left, b, action);\n            CrossRectangleNodesSameType(a.Right, b, action);\n        }\n    }\n}\n// returns true if \"property\" holds for some pair\nexport function FindIntersectionWithProperty(a, b, property) {\n    if (!a.irect.intersects_rect(b.irect))\n        return false;\n    if (a === b)\n        return HandleEqualityCheck(a, property);\n    if (a.Left == null) {\n        if (b.Left == null)\n            return property(a.UserData, b.UserData);\n        if (FindIntersectionWithProperty(a, b.Left, property))\n            return true;\n        if (FindIntersectionWithProperty(a, b.Right, property))\n            return true;\n    }\n    else {\n        if (b.Left != null) {\n            if (FindIntersectionWithProperty(a.Left, b.Left, property))\n                return true;\n            if (FindIntersectionWithProperty(a.Left, b.Right, property))\n                return true;\n            if (FindIntersectionWithProperty(a.Right, b.Left, property))\n                return true;\n            if (FindIntersectionWithProperty(a.Right, b.Right, property))\n                return true;\n        }\n        else {\n            if (FindIntersectionWithProperty(a.Left, b, property))\n                return true;\n            if (FindIntersectionWithProperty(a.Right, b, property))\n                return true;\n        }\n    }\n    return false;\n}\nfunction HandleEqualityCheck(a, func) {\n    if (a.Left == null)\n        return false; //we don't do anything for two equal leafs\n    return (FindIntersectionWithProperty(a.Left, a.Left, func) ||\n        FindIntersectionWithProperty(a.Left, a.Right, func) ||\n        FindIntersectionWithProperty(a.Right, a.Right, func));\n}\n// we need to avoid calling action twice for the same pair\nfunction HandleEquality(a, action) {\n    if (a.Left == null)\n        return; //we don't do anything for two equal leafs\n    CrossRectangleNodesSameType(a.Left, a.Left, action);\n    CrossRectangleNodesSameType(a.Left, a.Right, action);\n    CrossRectangleNodesSameType(a.Right, a.Right, action);\n}\n//# sourceMappingURL=rectangleNodeUtils.js.map","import { Rectangle } from './rectangle';\nimport { ParallelogramNode } from './parallelogramNode';\nimport { Point } from './point';\nimport { GeomConstants } from './geomConstants';\nimport { ClosestPointOnCurve } from './closestPointOnCurve';\n/** the standard implementation of a cubic bezier curve */\nexport class BezierSeg {\n    toJSON() {\n        return { b: this.b.map((p) => p.toJSON()) };\n    }\n    static fromJSON(bData) {\n        return BezierSeg.mkBezier(bData.b.map(Point.fromJSON));\n    }\n    leftDerivative(t) {\n        return this.derivative(t);\n    }\n    rightDerivative(t) {\n        return this.derivative(t);\n    }\n    /** get a control point */\n    B(controlPointIndex) {\n        return this.b[controlPointIndex];\n    }\n    /** A tree of ParallelogramNodes covering the curve.\n     This tree is used in curve intersections routines. */\n    pNodeOverICurve() {\n        if (this.pBoxNode != null)\n            return this.pBoxNode;\n        return (this.pBoxNode = ParallelogramNode.createParallelogramNodeForCurveSegDefaultOffset(this));\n    }\n    /** Returns the point on the curve corresponding to parameter t */\n    value(t) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        //   return l * t3 + e * t2 + c * t + b[0];\n        return this.l.mul(t3).add(this.e.mul(t2).add(this.c.mul(t)).add(this.b[0]));\n    }\n    static adjustParamTo01(u) {\n        if (u > 1)\n            return 1;\n        else if (u < 0)\n            return 0;\n        return u;\n    }\n    /**throw away the segments [0,u] and [v,1] of the segment,\n    Returns the trimmed curve */\n    trim(u, v) {\n        u = BezierSeg.adjustParamTo01(u);\n        v = BezierSeg.adjustParamTo01(v);\n        if (u > v)\n            return this.trim(v, u);\n        if (u > 1.0 - GeomConstants.tolerance)\n            return new BezierSeg(this.b[3], this.b[3], this.b[3], this.b[3]);\n        const b1 = new Array(3);\n        const b2 = new Array(2);\n        const pv = this.casteljau(u, b1, b2);\n        //this will be the trim to [v,1]\n        const trimByU = new BezierSeg(pv, b2[1], b1[2], this.b[3]);\n        //1-v is not zero here because we have handled already the case v=1\n        const pu = trimByU.casteljau((v - u) / (1.0 - u), b1, b2);\n        return new BezierSeg(trimByU.b[0], b1[0], b2[0], pu);\n    }\n    // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.\n    trimWithWrap(start, end) {\n        throw 'NotImplementedException()';\n        return null;\n    }\n    //array for casteljau method\n    casteljau(t, b1, b2) {\n        const f = 1.0 - t;\n        for (let i = 0; i < 3; i++)\n            b1[i] = Point.mkPoint(f, this.b[i], t, this.b[i + 1]);\n        for (let i = 0; i < 2; i++)\n            b2[i] = Point.mkPoint(f, b1[i], t, b1[i + 1]);\n        return Point.mkPoint(f, b2[0], t, b2[1]);\n    }\n    // first derivative\n    derivative(t) {\n        return this.l\n            .mul(3 * t * t)\n            .add(this.e.mul(2 * t))\n            .add(this.c);\n    }\n    // second derivative\n    secondDerivative(t) {\n        return Point.mkPoint(6 * t, this.l, 2, this.e);\n    }\n    // third derivative\n    thirdDerivative(t) {\n        return this.l.mul(6);\n    }\n    // the constructor\n    constructor(b0, b1, b2, b3) {\n        /** control points */\n        this.b = new Array(4);\n        this.parStart = 0;\n        this.parEnd = 1;\n        this.b[0] = b0;\n        this.b[1] = b1;\n        this.b[2] = b2;\n        this.b[3] = b3;\n        this.c = this.b[1].sub(this.b[0]).mul(3);\n        this.e = this.b[2].sub(this.b[1]).mul(3).sub(this.c);\n        this.l = this.b[3].sub(this.b[0]).sub(this.c).sub(this.e);\n    }\n    get start() {\n        return this.b[0];\n    }\n    get end() {\n        return this.b[3];\n    }\n    // this[Reverse[t]]=this[ParEnd+ParStart-t]\n    reverse() {\n        return new BezierSeg(this.b[3], this.b[2], this.b[1], this.b[0]);\n    }\n    // mutable! changes \"this\"\n    // Returns the curved moved by delta\n    translate(delta) {\n        this.b[0] = this.b[0].add(delta);\n        this.b[1] = this.b[1].add(delta);\n        this.b[2] = this.b[2].add(delta);\n        this.b[3] = this.b[3].add(delta);\n        this.c = this.b[1].sub(this.b[0]).mul(3);\n        this.e = this.b[2].sub(this.b[1]).mul(3).sub(this.c);\n        this.l = this.b[3].sub(this.b[0]).sub(this.c).sub(this.e);\n        if (this.bbox)\n            this.bbox = Rectangle.translate(this.bbox, delta);\n        this.pBoxNode = null;\n    }\n    // Returns the curved scaled by x and y\n    scaleFromOrigin(xScale, yScale) {\n        return new BezierSeg(this.b[0].scale(xScale, yScale), this.b[1].scale(xScale, yScale), this.b[2].scale(xScale, yScale), this.b[3].scale(xScale, yScale));\n    }\n    // Offsets the curve in the direction of dir\n    offsetCurve(offset, dir) {\n        return null;\n    }\n    // return length of the curve segment [start,end]\n    lengthPartial(start, end) {\n        return this.trim(start, end).length;\n    }\n    // Get the length of the curve\n    get length() {\n        return BezierSeg.lengthOnControlPolygon(this.b[0], this.b[1], this.b[2], this.b[3]);\n    }\n    //\n    static lengthOnControlPolygon(b0, b1, b2, b3) {\n        const innerCordLength = b3.sub(b0).length;\n        const controlPointPolygonLength = b1.sub(b0).length + b2.sub(b1).length + b3.sub(b2).length;\n        if (controlPointPolygonLength - innerCordLength > GeomConstants.lineSegmentThreshold) {\n            const mb0 = Point.middle(b0, b1);\n            const mb1 = Point.middle(b1, b2);\n            const mb2 = Point.middle(b2, b3);\n            const mmb0 = Point.middle(mb0, mb1);\n            const mmb1 = Point.middle(mb2, mb1);\n            const mmmb0 = Point.middle(mmb0, mmb1);\n            //               LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve(100, 2, \"blue\", new BezierSeg(b0, b1, b2, b3)), new DebugCurve(100, 1, \"red\", new BezierSeg(b0, mb0, mmb0, mmmb0)), new DebugCurve(100, 1, \"green\", new BezierSeg(mmmb0, mmb1, mb2, b3)));\n            return BezierSeg.lengthOnControlPolygon(b0, mb0, mmb0, mmmb0) + BezierSeg.lengthOnControlPolygon(mmmb0, mmb1, mb2, b3);\n        }\n        return (controlPointPolygonLength + innerCordLength) / 2;\n    }\n    // the segment bounding box\n    get boundingBox() {\n        if (this.bbox) {\n            return this.bbox;\n        }\n        return (this.bbox = Rectangle.mkOnPoints(this.b));\n    }\n    // Return the transformed curve\n    transform(transformation) {\n        return new BezierSeg(transformation.multiplyPoint(this.b[0]), transformation.multiplyPoint(this.b[1]), transformation.multiplyPoint(this.b[2]), transformation.multiplyPoint(this.b[3]));\n    }\n    // returns a parameter t such that the distance between curve[t] and targetPoint is minimal\n    // and t belongs to the closed segment [low,high]\n    closestParameterWithinBounds(targetPoint, low, high) {\n        /*Assert.assert(high <= 1 && low >= 0)*/\n        /*Assert.assert(low <= high)*/\n        const t = (high - low) / 8;\n        let closest = 0;\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 9; i++) {\n            const p = targetPoint.sub(this.value(i * t + low));\n            const d = p.dot(p);\n            if (d < minDist) {\n                minDist = d;\n                closest = i * t + low;\n            }\n        }\n        return ClosestPointOnCurve.closestPoint(this, targetPoint, closest, low, high);\n    }\n    // clones the curve.\n    clone() {\n        return new BezierSeg(this.b[0], this.b[1], this.b[2], this.b[3]);\n    }\n    static mkBezier(b) {\n        return new BezierSeg(b[0], b[1], b[2], b[3]);\n    }\n    // the signed curvature of the segment at t\n    curvature(t) {\n        /*Assert.assert(t >= this.parStart && t <= this.parEnd)*/\n        const den = this.G(t);\n        /*Assert.assert(Math.abs(den) > 0.00001)*/\n        return this.F(t) / den;\n    }\n    F(t) {\n        return this.Xp(t) * this.Ypp(t) - this.Yp(t) * this.Xpp(t);\n    }\n    // G(t) is the denomenator of the curvature\n    G(t) {\n        const xp = this.Xp(t);\n        const yp = this.Yp(t);\n        const den = xp * xp + yp * yp;\n        return Math.sqrt(den * den * den);\n    }\n    // the first derivative of x-coord\n    Xp(t) {\n        return 3 * this.l.x * t * t + 2 * this.e.x * t + this.c.x;\n    }\n    // the second derivativ of y-coordinate\n    Ypp(t) {\n        return 6 * this.l.y * t + 2 * this.e.y;\n    }\n    // the first derivative of y-coord\n    Yp(t) {\n        return 3 * this.l.y * t * t + 2 * this.e.y * t + this.c.y;\n    }\n    // the seconde derivative of x coord\n    Xpp(t) {\n        return 6 * this.l.x * t + 2 * this.e.x;\n    }\n    // the third derivative of x coordinate\n    Xppp(t) {\n        return 6 * this.l.x;\n    }\n    // the third derivative of y coordinate\n    Yppp(t) {\n        return 6 * this.l.y;\n    }\n    // the derivative of the curvature at t\n    curvatureDerivative(t) {\n        // we need to calculate the derivative of f/g where f=xp* ypp-yp*xpp and g=(xp*xp+yp*yp)^(3/2)\n        const h = this.G(t);\n        return (this.Fp(t) * h - this.Gp(t) * this.F(t)) / (h * h);\n    }\n    Fp(t) {\n        return this.Xp(t) * this.Yppp(t) - this.Yp(t) * this.Xppp(t);\n    }\n    Fpp(t) {\n        return (this.Xpp(t) * this.Yppp(t) - // + Xp(t) * Ypppp(t)=0\n            this.Ypp(t) * this.Xppp(t)); //- Yp(t) * Xpppp(t)=0\n    }\n    // returns a parameter t such that the distance between curve[t] and a is minimal\n    closestParameter(targetPoint) {\n        const t = 1.0 / 8;\n        let closest = 0;\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 9; i++) {\n            const p = targetPoint.sub(this.value(i * t));\n            const d = p.dot(p);\n            if (d < minDist) {\n                minDist = d;\n                closest = i * t;\n            }\n        }\n        return ClosestPointOnCurve.closestPoint(this, targetPoint, closest, 0, 1);\n    }\n    //\n    curvatureSecondDerivative(t) {\n        const g = this.G(t);\n        return (this.Qp(t) * g - 2 * this.Q(t) * this.Gp(t)) / (g * g * g);\n    }\n    Q(t) {\n        return this.Fp(t) * this.G(t) - this.Gp(t) * this.F(t);\n    }\n    Qp(t) {\n        return this.Fpp(t) * this.G(t) - this.Gpp(t) * this.F(t);\n    }\n    Gpp(t) {\n        const xp = this.Xp(t);\n        const yp = this.Yp(t);\n        const xpp = this.Xpp(t);\n        const ypp = this.Ypp(t);\n        const xppp = this.Xppp(t);\n        const yppp = this.Yppp(t);\n        const u = Math.sqrt(xp * xp + yp * yp);\n        const v = xp * xpp + yp * ypp;\n        return 3 * ((v * v) / u + u * (xpp * xpp + xp * xppp + ypp * ypp + yp * yppp));\n    }\n    Gp(t) {\n        const xp = this.Xp(t);\n        const yp = this.Yp(t);\n        const xpp = this.Xpp(t);\n        const ypp = this.Ypp(t);\n        return 3 * Math.sqrt(xp * xp + yp * yp) * (xp * xpp + yp * ypp);\n    }\n    getParameterAtLength(length) {\n        let low = 0;\n        let upper = 1;\n        while (upper - low > GeomConstants.tolerance) {\n            const middle = (upper + low) / 2;\n            const err = this.evaluateError(length, middle);\n            if (err > 0)\n                upper = middle;\n            else if (err < 0)\n                low = middle;\n            else\n                return middle;\n        }\n        return (low + upper) / 2;\n    }\n    evaluateError(length, t) {\n        //todo: this is a slow version!\n        const f = 1 - t;\n        const mb0 = Point.mkPoint(f, this.b[0], t, this.b[1]);\n        const mb1 = Point.mkPoint(f, this.b[1], t, this.b[2]);\n        const mb2 = Point.mkPoint(f, this.b[2], t, this.b[3]);\n        const mmb0 = Point.mkPoint(f, mb0, t, mb1);\n        const mmb1 = Point.mkPoint(f, mb1, t, mb2);\n        const mmmb0 = Point.mkPoint(f, mmb0, t, mmb1);\n        const lengthAtT = BezierSeg.lengthOnControlPolygon(this.b[0], mb0, mmb0, mmmb0);\n        if (lengthAtT > length + GeomConstants.distanceEpsilon)\n            return 1;\n        if (lengthAtT < length - GeomConstants.distanceEpsilon)\n            return -1;\n        return 0;\n    }\n}\n//# sourceMappingURL=bezierSeg.js.map","import { GeomConstants } from './geomConstants';\nexport class ClosestPointOnCurve {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static closestPoint(curve, a, hint, low, high) {\n        const numberOfIterationsMax = 5;\n        const numberOfOverShootsMax = 5;\n        let t = hint;\n        let numberOfIteration = 0;\n        let numberOfOvershoots = 0;\n        let dt;\n        let abort = false;\n        do {\n            const c = curve.value(t);\n            const ct = curve.derivative(t);\n            const ctt = curve.secondDerivative(t);\n            const secondDerivative = ct.dot(ct) + c.sub(a).dot(ctt);\n            if (Math.abs(secondDerivative) < GeomConstants.tolerance)\n                return t;\n            dt = c.sub(a).dot(ct.div(secondDerivative));\n            t -= dt;\n            if (t > high + GeomConstants.tolerance) {\n                t = high;\n                numberOfOvershoots++;\n            }\n            else if (t < low - GeomConstants.tolerance) {\n                t = low;\n                numberOfOvershoots++;\n            }\n            numberOfIteration++;\n        } while (Math.abs(dt) > GeomConstants.tolerance &&\n            !(abort = numberOfIteration >= numberOfIterationsMax || numberOfOvershoots >= numberOfOverShootsMax));\n        //may be the initial value was just fine\n        if (abort && curve.value(hint).sub(a).length < GeomConstants.distanceEpsilon)\n            t = hint;\n        return t;\n    }\n}\n//# sourceMappingURL=closestPointOnCurve.js.map","import { PointComparer } from '../../routing/rectilinear/PointComparer';\nimport { Direction } from './direction';\nimport { Point } from './point';\nexport class CompassVector {\n    constructor(direction) {\n        this.Dir = direction;\n    }\n    get Right() {\n        return new CompassVector(CompassVector.RotateRight(this.Dir));\n    }\n    static RotateRight(direction) {\n        switch (direction) {\n            case Direction.North:\n                return Direction.East;\n                break;\n            case Direction.East:\n                return Direction.South;\n                break;\n            case Direction.South:\n                return Direction.West;\n                break;\n            case Direction.West:\n                return Direction.North;\n                break;\n            default:\n                throw new Error();\n                break;\n        }\n    }\n    static RotateLeft(direction) {\n        switch (direction) {\n            case Direction.North:\n                return Direction.West;\n                break;\n            case Direction.West:\n                return Direction.South;\n                break;\n            case Direction.South:\n                return Direction.East;\n                break;\n            case Direction.East:\n                return Direction.North;\n                break;\n            default:\n                throw new Error();\n                break;\n        }\n    }\n    static ToIndex(direction) {\n        switch (direction) {\n            case Direction.North:\n                return 0;\n                break;\n            case Direction.East:\n                return 1;\n                break;\n            case Direction.South:\n                return 2;\n                break;\n            case Direction.West:\n                return 3;\n                break;\n            default:\n                throw new Error();\n                break;\n        }\n    }\n    static VectorDirection(d) {\n        let r = Direction.None;\n        if (d.x > PointComparer.DifferenceEpsilon) {\n            r = Direction.East;\n        }\n        else if (d.x < -PointComparer.DifferenceEpsilon) {\n            r = Direction.West;\n        }\n        if (d.y > PointComparer.DifferenceEpsilon) {\n            r = r | Direction.North;\n        }\n        else if (d.y < -PointComparer.DifferenceEpsilon) {\n            r = r | Direction.South;\n        }\n        return r;\n    }\n    static VectorDirectionPP(a, b) {\n        let r = Direction.None;\n        // This method is called a lot as part of rectilinear layout.\n        // Try to keep it quick.\n        const horizontalDiff = b.x - a.x;\n        const verticalDiff = b.y - a.y;\n        if (horizontalDiff > PointComparer.DifferenceEpsilon) {\n            r = Direction.East;\n        }\n        else if (-horizontalDiff > PointComparer.DifferenceEpsilon) {\n            r = Direction.West;\n        }\n        if (verticalDiff > PointComparer.DifferenceEpsilon) {\n            r |= Direction.North;\n        }\n        else if (-verticalDiff > PointComparer.DifferenceEpsilon) {\n            r |= Direction.South;\n        }\n        return r;\n    }\n    static DirectionFromPointToPoint(a, b) {\n        return CompassVector.VectorDirectionPP(a, b);\n    }\n    static OppositeDir(dir) {\n        switch (dir) {\n            case Direction.North:\n                return Direction.South;\n                break;\n            case Direction.West:\n                return Direction.East;\n                break;\n            case Direction.South:\n                return Direction.North;\n                break;\n            case Direction.East:\n                return Direction.West;\n                break;\n            default:\n                return Direction.None;\n                break;\n        }\n    }\n    static IsPureDirection(dir) {\n        switch (dir) {\n            case Direction.North:\n                return true;\n                break;\n            case Direction.East:\n                return true;\n                break;\n            case Direction.South:\n                return true;\n                break;\n            case Direction.West:\n                return true;\n                break;\n            default:\n                return false;\n                break;\n        }\n    }\n    static IsPureDirectionPP(a, b) {\n        return CompassVector.IsPureDirection(CompassVector.DirectionFromPointToPoint(a, b));\n    }\n    static DirectionsAreParallel(a, b) {\n        return a === b || a === CompassVector.OppositeDir(b);\n    }\n    // Translates the CompassVector's direction into a new Point.\n    ToPoint() {\n        let x = 0, y = 0;\n        if ((this.Dir & Direction.East) === Direction.East) {\n            x++;\n        }\n        if ((this.Dir & Direction.North) === Direction.North) {\n            y++;\n        }\n        if ((this.Dir & Direction.West) === Direction.West) {\n            x--;\n        }\n        if ((this.Dir & Direction.South) === Direction.South) {\n            y--;\n        }\n        return new Point(x, y);\n    }\n    // Translates a direction into a Point.\n    static toPoint(dir) {\n        return new CompassVector(dir).ToPoint();\n    }\n    //  the negation operator\n    static negate(directionVector) {\n        return new CompassVector(CompassVector.OppositeDir(directionVector.Dir));\n    }\n}\n//# sourceMappingURL=compassVector.js.map","// Creates the convex hull of a set of points following \"Computational Geometry, second edition\" of O'Rourke\nimport { GeomConstants } from './geomConstants';\nimport { Point, TriangleOrientation } from './point';\nimport { Polyline } from './polyline';\nexport class ConvexHull {\n    constructor(bodyPoints) {\n        this.stamp = 0;\n        this.SetPivotAndAllocateHullPointsArray(bodyPoints);\n    }\n    SetPivotAndAllocateHullPointsArray(bodyPoints) {\n        this.pivot = new Point(0, Number.MAX_SAFE_INTEGER);\n        // set Y to a very big value\n        let pivotIndex = -1;\n        let n = 0;\n        for (const point of bodyPoints) {\n            if (point.y < this.pivot.y) {\n                this.pivot = point;\n                pivotIndex = n;\n            }\n            else if (point.y === this.pivot.y) {\n                if (point.x > this.pivot.x) {\n                    this.pivot = point;\n                    pivotIndex = n;\n                }\n            }\n            n++;\n        }\n        if (n >= 1) {\n            this.hullPoints = new Array(n - 1);\n            // we will not copy the pivot into the hull points\n            n = 0;\n            for (const point of bodyPoints) {\n                if (n !== pivotIndex) {\n                    this.hullPoints[n++] = {\n                        point: point,\n                        deleted: false,\n                        stamp: this.stamp++,\n                    };\n                }\n                else {\n                    pivotIndex = -1;\n                }\n            }\n            // forget where the pivot was\n        }\n    }\n    get StackTopPoint() {\n        return this.stack.point;\n    }\n    get StackSecondPoint() {\n        return this.stack.next.point;\n    }\n    // calculates the convex hull of the given set of points\n    static *CalculateConvexHull(pointsOfTheBody) {\n        const convexHull = new ConvexHull(pointsOfTheBody);\n        for (const p of convexHull.Calculate())\n            yield p;\n    }\n    *Calculate() {\n        if (this.pivot.y === Number.MAX_SAFE_INTEGER) {\n            return;\n        }\n        if (this.hullPoints.length === 0) {\n            yield this.pivot;\n            return;\n        }\n        this.SortAllPointsWithoutPivot();\n        this.Scan();\n        for (const p of this.EnumerateStack()) {\n            yield p;\n        }\n    }\n    *EnumerateStack() {\n        let stackCell = this.stack;\n        while (stackCell != null) {\n            yield stackCell.point;\n            stackCell = stackCell.next;\n        }\n    }\n    Scan() {\n        let i = 0;\n        while (this.hullPoints[i].deleted) {\n            i++;\n        }\n        this.stack = { point: this.pivot, next: null };\n        this.Push(i++);\n        if (i < this.hullPoints.length) {\n            if (!this.hullPoints[i].deleted) {\n                this.Push(i++);\n            }\n            else {\n                i++;\n            }\n        }\n        while (i < this.hullPoints.length) {\n            if (!this.hullPoints[i].deleted) {\n                if (this.LeftTurn(i)) {\n                    this.Push(i++);\n                }\n                else {\n                    this.Pop();\n                }\n            }\n            else {\n                i++;\n            }\n        }\n        // cleanup the end\n        while (this.StackHasMoreThanTwoPoints() && !this.LeftTurnToPivot()) {\n            this.Pop();\n        }\n    }\n    LeftTurnToPivot() {\n        return Point.getTriangleOrientation(this.StackSecondPoint, this.StackTopPoint, this.pivot) === TriangleOrientation.Counterclockwise;\n    }\n    StackHasMoreThanTwoPoints() {\n        return this.stack.next != null && this.stack.next.next != null;\n    }\n    Pop() {\n        this.stack = this.stack.next;\n    }\n    LeftTurn(i) {\n        if (this.stack.next == null) {\n            return true;\n        }\n        // there is only one point in the stack\n        const orientation = Point.getTriangleOrientationWithIntersectionEpsilon(this.StackSecondPoint, this.StackTopPoint, this.hullPoints[i].point);\n        if (orientation === TriangleOrientation.Counterclockwise) {\n            return true;\n        }\n        if (orientation === TriangleOrientation.Clockwise) {\n            return false;\n        }\n        return this.BackSwitchOverPivot(this.hullPoints[i].point);\n    }\n    BackSwitchOverPivot(point) {\n        // we know here that there at least two points in the stack but it has to be exaclty two\n        if (this.stack.next.next != null) {\n            return false;\n        }\n        /*Assert.assert(this.StackSecondPoint === this.pivot)*/\n        return this.StackTopPoint.x > this.pivot.x + GeomConstants.distanceEpsilon && point.x < this.pivot.x - GeomConstants.distanceEpsilon;\n    }\n    Push(p) {\n        this.stack = { point: this.hullPoints[p].point, next: this.stack };\n    }\n    SortAllPointsWithoutPivot() {\n        this.hullPoints.sort(hullPointComparer(this.pivot));\n    }\n    static createConvexHullAsClosedPolyline(points) {\n        const convexHull = Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(points)));\n        // #if (TEST_MSAGL)\n        // for (let point of points) {\n        //    if ((Curve.PointRelativeToCurveLocation(point, convexHull) === PointLocation.Outside)) {\n        //        let hullPoint = convexHull[convexHull.closestParameter(point)];\n        //        //  This can be too restrictive if very close points are put into the hull.  It is probably\n        //        //  better to clean up in the caller before doing this, but this assert can also be relaxed.\n        //        Assert.assert(ApproximateComparer.Close(point, hullPoint, (ApproximateComparer.IntersectionEpsilon * 20)), String.Format(\"not CloseIntersections: initial point {0}, hull point {1}\", point, hullPoint));\n        //    }\n        // }\n        // #endif\n        // // TEST_MSAGL\n        return convexHull;\n    }\n}\n// note that this function can change \"deleted\" member for collinear points\nfunction hullPointComparer(pivot) {\n    return (i, j) => {\n        if (i === j) {\n            return 0;\n        }\n        if (i == null) {\n            return -1;\n        }\n        if (j == null) {\n            return 1;\n        }\n        switch (Point.getTriangleOrientationWithIntersectionEpsilon(pivot, i.point, j.point)) {\n            case TriangleOrientation.Counterclockwise:\n                return -1;\n                break;\n            case TriangleOrientation.Clockwise:\n                return 1;\n                break;\n            case TriangleOrientation.Collinear:\n                // because of the double point error pi and pj can be on different sizes of the pivot on the horizontal line passing through the pivot, or rather just above it\n                const piDelX = i.point.x - pivot.x;\n                const pjDelX = j.point.x - pivot.x;\n                if (piDelX > GeomConstants.distanceEpsilon && pjDelX < -GeomConstants.distanceEpsilon) {\n                    return -1;\n                }\n                if (piDelX < -GeomConstants.distanceEpsilon && pjDelX > GeomConstants.distanceEpsilon) {\n                    return 1;\n                }\n                // here i and j cannot be on the different sides of the pivot because of the choice of the pivot\n                // delete the one that is closer to the pivot.\n                const pi = i.point.sub(pivot);\n                const pj = j.point.sub(pivot);\n                const iMinJ = pi.l1 - pj.l1;\n                if (iMinJ < 0) {\n                    i.deleted = true;\n                    return -1;\n                }\n                if (iMinJ > 0) {\n                    j.deleted = true;\n                    return 1;\n                }\n                // points are the same, leave the one with the smallest stamp\n                if (i.stamp > j.stamp) {\n                    i.deleted = true;\n                }\n                else {\n                    j.deleted = true;\n                }\n                return 0;\n        }\n        throw new Error();\n    };\n}\n//# sourceMappingURL=convexHull.js.map","import { Point } from './point';\nexport class CornerSite {\n    constructor() {\n        // the coeffiecient used to calculate the first and the second control points of the\n        // Bezier segment for the fillet at the site\n        this.previouisBezierCoefficient = 0.5;\n        // the coeffiecient used to calculate the third and the fourth control points of the\n        // Bezier segment for the fillet at the site\n        this.nextBezierCoefficient = 0.5;\n        // the coefficient tells how tight the segment fits to the segment after the site; the formula is kNext * c + (1 - kNext) * b\n        this.previousTangentCoefficient = 1.0 / 3;\n        this.nextTangentCoefficient = 1.0 / 3;\n    }\n    static mkSiteP(sitePoint) {\n        const s = new CornerSite();\n        s.point = sitePoint;\n        return s;\n    }\n    static mkSiteSP(previousSite, sitePoint) {\n        const s = new CornerSite();\n        s.point = sitePoint;\n        s.prev = previousSite;\n        previousSite.next = s;\n        return s;\n    }\n    static mkSiteSPS(previousSite, sitePoint, nextSite) {\n        const s = new CornerSite();\n        s.prev = previousSite;\n        s.point = sitePoint;\n        s.next = nextSite;\n        previousSite.next = s;\n        nextSite.prev = s;\n        return s;\n    }\n    get turn() {\n        if (this.next == null || this.prev == null)\n            return 0;\n        return Point.getTriangleOrientation(this.prev.point, this.point, this.next.point);\n    }\n    clone() {\n        const s = new CornerSite();\n        s.previouisBezierCoefficient = this.previouisBezierCoefficient;\n        s.point = this.point;\n        return s;\n    }\n}\n//# sourceMappingURL=cornerSite.js.map","import { ParallelogramNode } from './parallelogramNode';\nimport { Point } from './point';\nimport { LineSegment } from './lineSegment';\nimport { IntersectionInfo } from './intersectionInfo';\nimport { Parallelogram } from './parallelogram';\nimport { Ellipse } from './ellipse';\nimport { Polyline } from './polyline';\nimport { GeomConstants } from './geomConstants';\nimport { LinearSystem2 } from './linearSystem';\nimport { MinDistCurveCurve } from './minDistCurveCurve';\nimport { Rectangle } from './rectangle';\nimport { BezierSeg } from './bezierSeg';\nimport { closeDistEps } from '../../utils/compare';\nfunction segParamValue(sp) {\n    return sp.seg.value(sp.par);\n}\nfunction segParamDerivative(sp) {\n    return sp.seg.derivative(sp.par);\n}\nfunction segParamSecondDerivative(sp) {\n    return sp.seg.secondDerivative(sp.par);\n}\nfunction segParamThirdDerivative(sp) {\n    return sp.seg.thirdDerivative(sp.par);\n}\nexport var PointLocation;\n(function (PointLocation) {\n    PointLocation[PointLocation[\"Outside\"] = 0] = \"Outside\";\n    PointLocation[PointLocation[\"Boundary\"] = 1] = \"Boundary\";\n    PointLocation[PointLocation[\"Inside\"] = 2] = \"Inside\";\n})(PointLocation || (PointLocation = {}));\nfunction getJSONforSeg(seg) {\n    if (seg instanceof Ellipse) {\n        return { tag: 'ellipse', segData: seg.toJSON() };\n    }\n    if (seg instanceof LineSegment) {\n        return { tag: 'lineSegment', segData: seg.toJSON() };\n    }\n    if (seg instanceof BezierSeg) {\n        return { tag: 'bezier', segData: seg.toJSON() };\n    }\n    throw new Error('not implemented');\n}\nexport class Curve {\n    static fromJSON(eData) {\n        const curve = new Curve();\n        for (const p of eData.segs) {\n            switch (p.tag) {\n                case 'bezier':\n                    curve.addSegment(BezierSeg.fromJSON(p.segData));\n                    break;\n                case 'ellipse':\n                    curve.addSegment(Ellipse.fromJSON(p.segData));\n                    break;\n                case 'lineSegment':\n                    curve.addSegment(LineSegment.fromJSON(p.segData));\n                    break;\n                default:\n                    throw new Error('not implemented');\n            }\n        }\n        return curve;\n    }\n    toJSON() {\n        return { segs: this.segs.map((seg) => getJSONforSeg(seg)) };\n    }\n    static CurvesIntersect(curve1, curve2) {\n        return curve1 === curve2 || Curve.intersectionOne(curve1, curve2, false) != null;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static lengthWithInterpolationAndThreshold(_seg, _eps) {\n        throw new Error('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static lengthWithInterpolation(_seg) {\n        throw 'not implemented';\n    }\n    get parStart() {\n        return 0;\n    }\n    get parEnd() {\n        return this.parEnd_;\n    }\n    lengthPartial(start, end) {\n        const params = {\n            start: start,\n            end: end,\n        };\n        this.adjustStartEndEndParametersToDomain(params);\n        const si = this.getSegIndexParam(start);\n        const ej = this.getSegIndexParam(end);\n        if (si.segIndex < ej.segIndex) {\n            let seg = this.segs[si.segIndex];\n            let ret = seg.lengthPartial(si.par, seg.parEnd);\n            for (let k = si.segIndex + 1; k < ej.segIndex; k++)\n                ret += this.segs[k].length;\n            seg = this.segs[ej.segIndex];\n            return ret + seg.lengthPartial(seg.parStart, ej.par);\n        }\n        else {\n            throw new Error('not implemented.');\n        }\n    }\n    // this[Reverse[t]]=this[ParEnd+ParStart-t]\n    reverse() {\n        const ret = new Curve();\n        for (let i = this.segs.length - 1; i >= 0; i--)\n            ret.addSegment(this.segs[i].reverse());\n        return ret;\n    }\n    // Constructs the curve for a given number of segments\n    constructor() {\n        this.segs = [];\n        this.parEnd_ = 0;\n    }\n    mkCurveWithSegs(segs) {\n        this.segs = segs;\n        for (const s of segs)\n            this.parEnd_ += Curve.paramSpan(s);\n    }\n    get start() {\n        return this.segs[0].start;\n    }\n    get end() {\n        return this.segs[this.segs.length - 1].end;\n    }\n    scaleFromOrigin(xScale, yScale) {\n        const c = new Curve();\n        for (const s of this.segs)\n            c.addSegment(s.scaleFromOrigin(xScale, yScale));\n        return c;\n    }\n    // Returns the trimmed curve\n    trim(start, end) {\n        const params = {\n            start: start,\n            end: end,\n        };\n        this.adjustStartEndEndParametersToDomain(params);\n        const s = this.getSegIndexParam(params.start);\n        const e = this.getSegIndexParam(params.end);\n        if (s.segIndex === e.segIndex)\n            return this.segs[s.segIndex].trim(s.par, e.par);\n        let c = new Curve();\n        if (s.par < this.segs[s.segIndex].parEnd)\n            c = c.addSegment(this.segs[s.segIndex].trim(s.par, this.segs[s.segIndex].parEnd));\n        for (let i = s.segIndex + 1; i < e.segIndex; i++)\n            c = c.addSegment(this.segs[i]);\n        if (this.segs[e.segIndex].parStart < e.par)\n            c = c.addSegment(this.segs[e.segIndex].trim(this.segs[e.segIndex].parStart, e.par));\n        return c;\n    }\n    translate(delta) {\n        for (const s of this.segs)\n            s.translate(delta);\n        if (this.boundingBox_) {\n            this.boundingBox_ = Rectangle.translate(this.boundingBox_, delta);\n        }\n        this.pBNode = null;\n    }\n    adjustStartEndEndParametersToDomain(params) {\n        if (params.start > params.end) {\n            const t = params.start;\n            params.start = params.end;\n            params.end = t;\n        }\n        if (params.start < this.parStart)\n            params.start = this.parStart;\n        if (params.end > this.parEnd)\n            params.end = this.parEnd;\n    }\n    // Returns the trimmed curve, wrapping around the end if start is greater than end.\n    trimWithWrap(start, end) {\n        /*Assert.assert(start >= this.parStart && start <= this.parEnd)*/\n        /*Assert.assert(end >= this.parStart && end <= this.parEnd)*/\n        if (start < end)\n            return this.trim(start, end); // Curve must be closed to wrap\n        /*Assert.assert(Point.closeDistEps(this.start, this.end))*/ const c = new Curve();\n        c.addSegment(this.trim(start, this.parEnd));\n        c.addSegment(this.trim(this.parStart, end));\n        return c;\n    }\n    addSegs(segs) {\n        for (const s of segs)\n            this.addSegment(s);\n        return this;\n    }\n    // Adds a segment to the curve\n    addSegment(curve) {\n        if (curve == null)\n            return this; //nothing happens\n        this.boundingBox_ = null;\n        /*Assert.assert(\n          this.segs.length === 0 || Point.close(this.end, curve.start, 0.001),\n        )*/\n        if (!(curve instanceof Curve)) {\n            this.segs.push(curve);\n            this.parEnd_ += Curve.paramSpan(curve);\n        }\n        else {\n            for (const cc of curve.segs) {\n                this.segs.push(cc);\n                this.parEnd_ += Curve.paramSpan(cc);\n            }\n        }\n        return this;\n    }\n    // A tree of ParallelogramNodes covering the curve.\n    // This tree is used in curve intersections routines.\n    pNodeOverICurve() {\n        if (this.pBNode != null)\n            return this.pBNode;\n        const parallelograms = [];\n        const childrenNodes = [];\n        for (const curveSeg of this.segs) {\n            const pBoxNode = curveSeg.pNodeOverICurve();\n            parallelograms.push(pBoxNode.parallelogram);\n            childrenNodes.push(pBoxNode);\n        }\n        this.pBNode = {\n            parallelogram: Parallelogram.getParallelogramOfAGroup(parallelograms),\n            seg: this,\n            leafBoxesOffset: GeomConstants.defaultLeafBoxesOffset,\n            node: { children: childrenNodes },\n        };\n        return this.pBNode;\n    }\n    // finds an intersection between to curves,\n    static intersectionOne(curve0, curve1, liftIntersection) {\n        /*Assert.assert(curve0 !== curve1)*/\n        //           number c0S = curve0.parStart, c1S = curve1.parStart;\n        //           if (CurvesAreCloseAtParams(curve0, curve1, c0S, c1S)) {\n        //               number mc0 = 0.5 * (curve0.parStart + curve0.parEnd);\n        //               number mc1 = 0.5 * (curve1.parStart + curve1.parEnd);\n        //               number c0E = curve0.parEnd;\n        //               if (CurvesAreCloseAtParams(curve0, curve1, mc0, mc1)) {\n        //                   number c1E = curve1.parEnd;\n        //                   CurvesAreCloseAtParams(curve0, curve1, c0E, c1E);\n        //                   throw new Error();\n        //               }\n        //           }\n        //recurse down to find all PBLeaf pairs which intesect and try to cross their segments\n        let ret = Curve.curveCurveXWithParallelogramNodesOne(curve0.pNodeOverICurve(), curve1.pNodeOverICurve());\n        if (liftIntersection && ret != null)\n            ret = Curve.liftIntersectionToCurves(curve0, curve1, ret);\n        return ret;\n    }\n    /**\n     *   Calculates all intersections between curve0 and curve1.\n     *  If liftIntersections is true then the intersections parameters\n     *  recalculated, lifted, to the curve parameter domain. Otherwise they * stay in the segment domains\n     */\n    static getAllIntersections(curve0, curve1, liftIntersections) {\n        //           var c0S = curve0.parStart;\n        //           var c1S = curve1.parStart;\n        //           var c0E = curve0.parEnd;\n        //           var c1E = curve1.parEnd;\n        //           if (CurvesAreCloseAtParams(curve0, curve1, c0S, c1S)) {\n        //               if (CurvesAreCloseAtParams(curve0, curve1, c0E, c1E)) {\n        //                   var mc0 = 0.5*(curve0.parStart + curve0.parEnd);\n        //                   var mc1 = 0.5*(curve1.parStart + curve1.parEnd);\n        //                   if (CurvesAreCloseAtParams(curve0, curve1, mc0, mc1))\n        //                       throw new Error();\n        //               }\n        //           }\n        if (curve0 instanceof LineSegment) {\n            return Curve.getAllIntersectionsOfLineAndICurve(curve0, curve1, liftIntersections);\n        }\n        return Curve.getAllIntersectionsInternal(curve0, curve1, liftIntersections);\n    }\n    static getAllIntersectionsInternal(curve0, curve1, liftIntersections) {\n        //recurse down to find all PBLeaf pairs which intesect and try to cross their segments\n        const intersections = [];\n        Curve.curveCurveXWithParallelogramNodes(curve0.pNodeOverICurve(), curve1.pNodeOverICurve(), intersections);\n        if (liftIntersections)\n            for (let i = 0; i < intersections.length; i++) {\n                intersections[i] = Curve.liftIntersectionToCurves(curve0, curve1, intersections[i]);\n            }\n        return intersections;\n    }\n    static getAllIntersectionsOfLineAndICurve(lineSeg, iCurve, liftIntersections) {\n        if (iCurve instanceof Polyline)\n            return Curve.getAllIntersectionsOfLineAndPolyline(lineSeg, iCurve);\n        if (iCurve instanceof Curve)\n            return Curve.getAllIntersectionsOfLineAndCurve(lineSeg, iCurve, liftIntersections);\n        if (iCurve instanceof Ellipse && iCurve.isArc())\n            return Curve.getAllIntersectionsOfLineAndArc(lineSeg, iCurve);\n        return Curve.getAllIntersectionsInternal(lineSeg, iCurve, liftIntersections);\n    }\n    static getAllIntersectionsOfLineAndCurve(lineSeg, curve, liftIntersections) {\n        const ret = [];\n        const lineParallelogram = lineSeg.pNodeOverICurve();\n        const curveParallelogramRoot = curve.pNodeOverICurve();\n        if (Parallelogram.intersect(lineParallelogram.parallelogram, curveParallelogramRoot.parallelogram) === false)\n            return ret;\n        let parOffset = 0.0;\n        for (const seg of curve.segs) {\n            const iiList = Curve.getAllIntersections(lineSeg, seg, false);\n            if (liftIntersections) {\n                for (const intersectionInfo of iiList) {\n                    intersectionInfo.par1 += parOffset - seg.parStart;\n                    intersectionInfo.seg1 = curve;\n                }\n                parOffset += seg.parEnd - seg.parStart;\n            }\n            for (const intersectionInfo of iiList) {\n                if (!Curve.alreadyInside(ret, intersectionInfo))\n                    ret.push(intersectionInfo);\n            }\n        }\n        return ret;\n    }\n    static closeIntersections(x, y) {\n        return Point.close(x.x, y.x, GeomConstants.intersectionEpsilon);\n    }\n    static closeIntersectionPoints(x, y) {\n        return Point.close(x, y, GeomConstants.intersectionEpsilon);\n    }\n    static alreadyInside(ret, intersectionInfo) {\n        for (let i = 0; i < ret.length; i++) {\n            const ii = ret[i];\n            if (Curve.closeIntersections(ii, intersectionInfo))\n                return true;\n        }\n        return false;\n    }\n    static getAllIntersectionsOfLineAndArc(lineSeg, ellipse) {\n        /*Assert.assert(ellipse.isArc())*/\n        let lineDir = lineSeg.end.sub(lineSeg.start);\n        const ret = [];\n        const segLength = lineDir.length;\n        // the case of a very short LineSegment\n        if (segLength < GeomConstants.distanceEpsilon) {\n            const lsStartMinCen = lineSeg.start.sub(ellipse.center);\n            if (closeDistEps(lsStartMinCen.length, ellipse.aAxis.length)) {\n                let angle = Point.angle(ellipse.aAxis, lsStartMinCen);\n                if (ellipse.parStart - GeomConstants.tolerance <= angle) {\n                    angle = Math.max(angle, ellipse.parStart);\n                    if (angle <= ellipse.parEnd + GeomConstants.tolerance) {\n                        angle = Math.min(ellipse.parEnd, angle);\n                        ret.push(new IntersectionInfo(0, angle, lineSeg.start, lineSeg, ellipse));\n                    }\n                }\n            }\n            return ret;\n        }\n        const perp = lineDir.rotate90Ccw().div(segLength);\n        const segProjection = lineSeg.start.sub(ellipse.center).dot(perp);\n        const closestPointOnLine = ellipse.center.add(perp.mul(segProjection));\n        const rad = ellipse.aAxis.length;\n        const absSegProj = Math.abs(segProjection);\n        if (rad < absSegProj - GeomConstants.distanceEpsilon)\n            return ret; //we don't have an intersection\n        lineDir = perp.rotate90Cw();\n        if (closeDistEps(rad, absSegProj)) {\n            Curve.tryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, closestPointOnLine, segLength, lineDir);\n        }\n        else {\n            /*Assert.assert(rad > absSegProj)*/\n            const otherLeg = Math.sqrt(rad * rad - segProjection * segProjection);\n            const d = lineDir.mul(otherLeg);\n            Curve.tryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, closestPointOnLine.add(d), segLength, lineDir);\n            Curve.tryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, closestPointOnLine.sub(d), segLength, lineDir);\n        }\n        return ret;\n    }\n    static tryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, point, segLength, lineDir) {\n        const ds = point.sub(lineSeg.start);\n        let t = ds.dot(lineDir);\n        if (t < -GeomConstants.distanceEpsilon)\n            return;\n        t = Math.max(t, 0);\n        if (t > segLength + GeomConstants.distanceEpsilon)\n            return;\n        t = Math.min(t, segLength);\n        t /= segLength;\n        let angle = Point.angle(ellipse.aAxis, point.sub(ellipse.center));\n        if (ellipse.parStart - GeomConstants.tolerance <= angle) {\n            angle = Math.max(angle, ellipse.parStart);\n            if (angle <= ellipse.parEnd + GeomConstants.tolerance) {\n                angle = Math.min(ellipse.parEnd, angle);\n                ret.push(new IntersectionInfo(t, angle, point, lineSeg, ellipse));\n            }\n        }\n    }\n    static getAllIntersectionsOfLineAndPolyline(lineSeg, poly) {\n        const ret = [];\n        let offset = 0.0;\n        let polyPoint = poly.startPoint;\n        for (; polyPoint != null && polyPoint.getNext() != null; polyPoint = polyPoint.getNext()) {\n            const sol = Curve.crossTwoLineSegs(lineSeg.start, lineSeg.end, polyPoint.point, polyPoint.getNext().point, 0, 1, 0, 1);\n            if (sol) {\n                Curve.adjustSolution(lineSeg.start, lineSeg.end, polyPoint.point, polyPoint.getNext().point, sol);\n                if (!Curve.oldIntersection(ret, sol.x))\n                    ret.push(new IntersectionInfo(sol.aSol, offset + sol.bSol, sol.x, lineSeg, poly));\n            }\n            offset++;\n        }\n        if (poly.closed) {\n            const sol = Curve.crossTwoLineSegs(lineSeg.start, lineSeg.end, polyPoint.point, poly.start, 0, 1, 0, 1);\n            if (sol) {\n                Curve.adjustSolution(lineSeg.start, lineSeg.end, polyPoint.point, poly.start, sol);\n                if (!Curve.oldIntersection(ret, sol.x))\n                    ret.push(new IntersectionInfo(sol.aSol, offset + sol.bSol, sol.x, lineSeg, poly));\n            }\n        }\n        return ret;\n    }\n    static adjustSolution(aStart, aEnd, bStart, bEnd, sol) {\n        //adjust the intersection if it is close to the ends of the segs\n        if (Curve.closeIntersectionPoints(sol.x, aStart)) {\n            sol.x = aStart;\n            sol.aSol = 0;\n        }\n        else if (Curve.closeIntersectionPoints(sol.x, aEnd)) {\n            sol.x = aEnd;\n            sol.aSol = 1;\n        }\n        if (Curve.closeIntersectionPoints(sol.x, bStart)) {\n            sol.x = bStart;\n            sol.bSol = Math.floor(sol.bSol);\n        }\n        else if (Curve.closeIntersectionPoints(sol.x, bEnd)) {\n            sol.x = bEnd;\n            sol.bSol = Math.ceil(sol.bSol);\n        }\n    }\n    static curveCurveXWithParallelogramNodesOne(n0, n1) {\n        if (!Parallelogram.intersect(n0.parallelogram, n1.parallelogram))\n            return null;\n        const n0Pb = n0.node;\n        const n1Pb = n1.node;\n        const n0Internal = n0Pb.hasOwnProperty('children');\n        const n1Internal = n1Pb.hasOwnProperty('children');\n        if (n0Internal && n1Internal)\n            for (const n00 of n0Pb.children)\n                for (const n11 of n1Pb.children) {\n                    const x = Curve.curveCurveXWithParallelogramNodesOne(n00, n11);\n                    if (x != null)\n                        return x;\n                }\n        else if (n1Internal)\n            for (const n of n1Pb.children) {\n                const x = Curve.curveCurveXWithParallelogramNodesOne(n0, n);\n                if (x != null)\n                    return x;\n            }\n        else if (n0Internal)\n            for (const n of n0Pb.children) {\n                const x = Curve.curveCurveXWithParallelogramNodesOne(n, n1);\n                if (x != null)\n                    return x;\n            }\n        else\n            return Curve.crossOverIntervalsOne(n0, n1);\n        return null;\n    }\n    static curveCurveXWithParallelogramNodes(n0, n1, intersections) {\n        if (!Parallelogram.intersect(n0.parallelogram, n1.parallelogram)) {\n            // Boxes n0.Box and n1.Box do not intersect\n            return;\n        }\n        const isInternal0 = n0.node.hasOwnProperty('children');\n        const isInternal1 = n1.node.hasOwnProperty('children');\n        if (isInternal0 && isInternal1)\n            for (const n00 of n0.node.children)\n                for (const n11 of n1.node.children)\n                    Curve.curveCurveXWithParallelogramNodes(n00, n11, intersections);\n        else if (isInternal1)\n            for (const n of n1.node.children)\n                Curve.curveCurveXWithParallelogramNodes(n0, n, intersections);\n        else if (isInternal0)\n            for (const n of n0.node.children)\n                Curve.curveCurveXWithParallelogramNodes(n, n1, intersections);\n        else\n            intersections = Curve.crossOverLeaves(n0, n1, intersections);\n    }\n    static crossOverIntervalsOne(n0, n1) {\n        //both are leafs\n        const l0 = n0.node;\n        const l1 = n1.node;\n        const d0 = (l0.high - l0.low) / 2;\n        const d1 = (l1.high - l1.low) / 2;\n        for (let i = 1; i < 2; i++) {\n            const p0 = i * d0 + l0.low;\n            for (let j = 1; j < 2; j++) {\n                const p1 = j * d1 + l1.low;\n                let sol;\n                if (l0.chord == null && l1.chord == null)\n                    sol = Curve.crossWithinIntervalsWithGuess(n0.seg, n1.seg, l0.low, l0.high, l1.low, l1.high, p0, p1);\n                else if (l0.chord != null && l1.chord == null) {\n                    sol = Curve.crossWithinIntervalsWithGuess(l0.chord, n1.seg, 0, 1, l1.low, l1.high, 0.5 * i, p1);\n                }\n                else if (l0.chord == null) {\n                    sol = Curve.crossWithinIntervalsWithGuess(n0.seg, l1.chord, l0.low, l0.high, 0, 1, p0, 0.5 * j);\n                    if (sol) {\n                        sol.bSol = l1.low + sol.bSol * (l1.high - l1.low);\n                    }\n                } //if (l0.chord != null && l1.chord != null)\n                else {\n                    sol = Curve.crossWithinIntervalsWithGuess(l0.chord, l1.chord, 0, 1, 0, 1, 0.5 * i, 0.5 * j);\n                    if (sol) {\n                        sol.aSol = l0.low + sol.aSol * (l0.high - l0.low);\n                        sol.bSol = l1.low + sol.bSol * (l1.high - l1.low);\n                    }\n                }\n                if (sol) {\n                    return Curve.createIntersectionOne(n0, n1, sol.aSol, sol.bSol, sol.x);\n                }\n            }\n        }\n        return Curve.goDeeperOne(n0, n1);\n    }\n    static crossOverLeaves(n0, n1, intersections) {\n        //both are leafs\n        const l0 = n0.node;\n        const l1 = n1.node;\n        let found = false;\n        const p0 = (l0.high - l0.low) / 2 + l0.low;\n        const p1 = (l1.high - l1.low) / 2 + l1.low;\n        let sol;\n        if (l0.chord == null && l1.chord == null)\n            sol = Curve.crossWithinIntervalsWithGuess(n0.seg, n1.seg, l0.low, l0.high, l1.low, l1.high, p0, p1);\n        else if (l0.chord != null && l1.chord == null) {\n            sol = Curve.crossWithinIntervalsWithGuess(l0.chord, n1.seg, 0, 1, l1.low, l1.high, 0.5, p1);\n            if (sol)\n                sol.aSol = l0.low + sol.aSol * (l0.high - l0.low);\n        }\n        else if (l0.chord == null) {\n            //&& l1.chord != null)\n            sol = Curve.crossWithinIntervalsWithGuess(n0.seg, l1.chord, l0.low, l0.high, 0, 1, p0, 0.5);\n            if (sol)\n                sol.bSol = l1.low + sol.bSol * (l1.high - l1.low);\n        } //if (l0.chord != null && l1.chord != null)\n        else {\n            sol = Curve.crossWithinIntervalsWithGuess(l0.chord, l1.chord, 0, 1, 0, 1, 0.5, 0.5);\n            if (sol) {\n                sol.bSol = l1.low + sol.bSol * (l1.high - l1.low);\n                sol.aSol = l0.low + sol.aSol * (l0.high - l0.low);\n            }\n        }\n        if (sol) {\n            Curve.addIntersection(n0, n1, intersections, sol);\n            found = true;\n        }\n        if (!found)\n            Curve.goDeeper(intersections, n0, n1);\n        return intersections;\n    }\n    static addIntersection(n0, n1, intersections, sol) {\n        const l0 = n0.node;\n        //adjust the intersection if it is close to the ends of the segs\n        if (Curve.closeIntersectionPoints(sol.x, n0.seg.value(l0.low))) {\n            sol.x = n0.seg.value(l0.low);\n            sol.aSol = l0.low;\n        }\n        else if (Curve.closeIntersectionPoints(sol.x, n0.seg.value(l0.high))) {\n            sol.x = n0.seg.value(l0.high);\n            sol.aSol = l0.high;\n        }\n        const l1 = n1.node;\n        if (Curve.closeIntersectionPoints(sol.x, n1.seg.value(l1.low))) {\n            sol.x = n1.seg.value(l1.low);\n            sol.bSol = l1.low;\n        }\n        else if (Curve.closeIntersectionPoints(sol.x, n1.seg.value(l1.high))) {\n            sol.x = n1.seg.value(l1.high);\n            sol.bSol = l1.high;\n        }\n        const oldIntersection = Curve.oldIntersection(intersections, sol.x);\n        if (!oldIntersection) {\n            const xx = new IntersectionInfo(sol.aSol, sol.bSol, sol.x, n0.seg, n1.seg);\n            intersections.push(xx);\n        }\n        return;\n    }\n    // returns true if the intersection exists already\n    static oldIntersection(intersections, x) {\n        //we don't expect many intersections so it's ok just go through all of them\n        for (const ii of intersections)\n            if (x.sub(ii.x).length < GeomConstants.distanceEpsilon * 100) {\n                //please no close intersections\n                return true;\n            }\n        return false;\n    }\n    static createIntersectionOne(n0, n1, aSol, bSol, x) {\n        //adjust the intersection if it is close to the ends of the segs\n        const l0 = n0.node;\n        const l1 = n1.node;\n        if (Curve.closeIntersectionPoints(x, n0.seg.value(l0.low))) {\n            x = n0.seg.value(l0.low);\n            aSol = l0.low;\n        }\n        else if (Curve.closeIntersectionPoints(x, n0.seg.value(l0.high))) {\n            x = n0.seg.value(l0.high);\n            aSol = l0.high;\n        }\n        if (Curve.closeIntersectionPoints(x, n1.seg.value(l1.low))) {\n            x = n1.seg.value(l1.low);\n            bSol = l1.low;\n        }\n        else if (Curve.closeIntersectionPoints(x, n1.seg.value(l1.high))) {\n            x = n1.seg.value(l1.high);\n            bSol = l1.high;\n        }\n        return new IntersectionInfo(aSol, bSol, x, n0.seg, n1.seg);\n    }\n    static liftIntersectionToCurves_(c0, c1, aSol, bSol, x, seg0, seg1) {\n        const a = c0 instanceof Curve ? Curve.liftParameterToCurve(c0, aSol - seg0.parStart, seg0) : aSol;\n        const b = c1 instanceof Curve ? Curve.liftParameterToCurve(c1, bSol - seg1.parStart, seg1) : bSol;\n        return new IntersectionInfo(a, b, x, c0, c1);\n    }\n    static DropIntersectionToSegs(xx) {\n        let seg0;\n        let par0;\n        if (xx.seg0 instanceof Curve) {\n            const sp = xx.seg0.getSegParam(xx.par0);\n            seg0 = sp.seg;\n            par0 = sp.par;\n        }\n        else {\n            par0 = xx.par0;\n            seg0 = xx.seg0;\n        }\n        let seg1;\n        let par1;\n        if (xx.seg1 instanceof Curve) {\n            const sp = xx.seg1.getSegParam(xx.par1);\n            par1 = sp.par;\n            seg1 = sp.seg;\n        }\n        else {\n            par1 = xx.par1;\n            seg1 = xx.seg1;\n        }\n        return new IntersectionInfo(par0, par1, xx.x, seg0, seg1);\n    }\n    static liftIntersectionToCurves(c0, c1, xx) {\n        return Curve.liftIntersectionToCurves_(c0, c1, xx.par0, xx.par1, xx.x, xx.seg0, xx.seg1);\n    }\n    static liftParameterToCurve(curve, par, seg) {\n        if (curve === seg)\n            return par;\n        if (!curve.hasOwnProperty('segs'))\n            return;\n        const c = curve;\n        let offset = 0;\n        for (const s of c.segs) {\n            if (s === seg)\n                return par + offset;\n            offset += Curve.paramSpan(s);\n        }\n        throw 'bug in liftParameterToCurve';\n    }\n    static paramSpan(s) {\n        return s.parEnd - s.parStart;\n    }\n    static goDeeperOne(nl0, nl1) {\n        // did not find an intersection yet\n        const l0 = nl0.node;\n        const l1 = nl1.node;\n        if (nl0.leafBoxesOffset > GeomConstants.distanceEpsilon && nl1.leafBoxesOffset > GeomConstants.distanceEpsilon) {\n            // going deeper on both with offset l0.LeafBoxesOffset / 2, l1.LeafBoxesOffset / 2\n            const nn0 = ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low, l0.high, nl0.seg, nl0.leafBoxesOffset / 2);\n            const nn1 = ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low, l1.high, nl1.seg, nl1.leafBoxesOffset / 2);\n            return Curve.curveCurveXWithParallelogramNodesOne(nn0, nn1);\n        }\n        if (nl0.leafBoxesOffset > GeomConstants.distanceEpsilon) {\n            // go deeper on the left\n            const nn0 = ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low, l0.high, nl0.seg, nl0.leafBoxesOffset / 2);\n            return Curve.curveCurveXWithParallelogramNodesOne(nn0, nl1);\n        }\n        if (nl1.leafBoxesOffset > GeomConstants.distanceEpsilon) {\n            // go deeper on the right\n            const nn1 = ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low, l1.high, nl1.seg, nl1.leafBoxesOffset / 2);\n            return Curve.curveCurveXWithParallelogramNodesOne(nl0, nn1);\n        }\n        //just cross LineSegs and adjust the solutions if the segments are not straight lines\n        const l0Low = nl0.seg.value(l0.low);\n        const l0High = nl0.seg.value(l0.high);\n        if (!Point.closeDistEps(l0Low, l0High)) {\n            const l1Low = nl1.seg.value(l1.low);\n            const l1High = nl1.seg.value(l1.high);\n            if (!Point.closeDistEps(l1Low, l1High)) {\n                const ls0 = nl0.seg instanceof LineSegment ? nl0.seg : LineSegment.mkPP(l0Low, l0High);\n                const ls1 = nl1.seg instanceof LineSegment ? nl1.seg : LineSegment.mkPP(l1Low, l1High);\n                const sol = Curve.crossWithinIntervalsWithGuess(ls0, ls1, 0, 1, 0, 1, 0.5, 0.5);\n                if (sol) {\n                    Curve.adjustParameters(nl0, ls0, nl1, ls1, sol);\n                    return Curve.createIntersectionOne(nl0, nl1, sol.aSol, sol.bSol, sol.x);\n                }\n            }\n        }\n        return null;\n    }\n    static goDeeper(intersections, nl0, nl1) {\n        const l0 = nl0.node;\n        const l1 = nl1.node;\n        // did not find an intersection\n        const n0Large = nl0.leafBoxesOffset > GeomConstants.distanceEpsilon;\n        const n1Large = nl1.leafBoxesOffset > GeomConstants.distanceEpsilon;\n        if (n0Large && n1Large) {\n            // going deeper on both with offset l0.leafBoxesOffset / 2, l1.leafBoxesOffset / 2\n            const nn0 = ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low, l0.high, nl0.seg, nl0.leafBoxesOffset / 2);\n            const nn1 = ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low, l1.high, nl1.seg, nl1.leafBoxesOffset / 2);\n            Curve.curveCurveXWithParallelogramNodes(nn0, nn1, intersections);\n        }\n        else if (n0Large) {\n            // go deeper on the left\n            const nn0 = ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low, l0.high, nl0.seg, nl0.leafBoxesOffset / 2);\n            Curve.curveCurveXWithParallelogramNodes(nn0, nl1, intersections);\n        }\n        else if (n1Large) {\n            // go deeper on the right\n            const nn1 = ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low, l1.high, nl1.seg, nl1.leafBoxesOffset / 2);\n            Curve.curveCurveXWithParallelogramNodes(nl0, nn1, intersections);\n        }\n        else {\n            //just cross LineSegs since the parallelograms are so thin\n            const l0Low = nl0.seg.value(l0.low);\n            const l0High = nl0.seg.value(l0.high);\n            if (!Point.closeDistEps(l0Low, l0High)) {\n                const l1Low = nl1.seg.value(l1.low);\n                const l1High = nl1.seg.value(l1.high);\n                if (!Point.closeDistEps(l1Low, l1High)) {\n                    const ls0 = nl0.seg instanceof LineSegment ? nl0.seg : LineSegment.mkPP(l0Low, l0High);\n                    const ls1 = nl1.seg instanceof LineSegment ? nl1.seg : LineSegment.mkPP(l1Low, l1High);\n                    const sol = Curve.crossWithinIntervalsWithGuess(ls0, ls1, 0, 1, 0, 1, 0.5, 0.5);\n                    if (sol) {\n                        Curve.adjustParameters(nl0, ls0, nl1, ls1, sol);\n                        Curve.addIntersection(nl0, nl1, intersections, sol);\n                    }\n                }\n            }\n        }\n    }\n    static adjustParameters(l0, ls0, l1, ls1, sol) {\n        if (ls0 !== l0.seg && l0.seg instanceof Polyline === false)\n            //l0.seg is not a LineSegment and not a polyline\n            sol.aSol = l0.seg.closestParameter(sol.x);\n        //we need to find the correct parameter\n        else {\n            const leaf0 = l0.node;\n            sol.aSol = leaf0.low + sol.aSol * (leaf0.high - leaf0.low);\n        }\n        if (ls1 !== l1.seg && l1.seg instanceof Polyline === false)\n            //l1.seg is not a LineSegment and not a polyline\n            sol.bSol = l1.seg.closestParameter(sol.x);\n        //we need to find the correct parameter\n        else {\n            const leaf1 = l1.node;\n            sol.bSol = leaf1.low + sol.bSol * (leaf1.high - leaf1.low);\n        }\n    }\n    // returns the segment correspoinding to t and the segment parameter\n    getSegParam(t) {\n        let u = this.parStart; //u is the sum of param domains\n        for (const sg of this.segs) {\n            const nextu = u + sg.parEnd - sg.parStart;\n            if (t >= u && t <= nextu) {\n                return {\n                    par: t - u + sg.parStart,\n                    seg: sg,\n                };\n            }\n            u = nextu;\n        }\n        const lastSeg = this.segs[this.segs.length - 1];\n        return {\n            seg: lastSeg,\n            par: lastSeg.parEnd,\n        };\n    }\n    /** return the segment index and the parameter inside of the segment */\n    getSegIndexParam(t) {\n        // because of this implementation we alwais should have seg.parStart >= 0: otherwise the function can return a wrong segment\n        let u = 0; //u is the sum of param domains\n        const segLen = this.segs.length;\n        for (let i = 0; i < segLen; i++) {\n            const sg = this.segs[i];\n            const nextu = u + sg.parEnd - sg.parStart;\n            if (t >= u && t <= nextu) {\n                return {\n                    segIndex: i,\n                    par: t - u + sg.parStart,\n                };\n            }\n            u = nextu;\n        }\n        const lastSeg = this.segs[segLen - 1];\n        return {\n            segIndex: segLen - 1,\n            par: lastSeg.parEnd,\n        };\n    }\n    // Returns the point on the curve corresponding to parameter t\n    value(t) {\n        return segParamValue(this.getSegParam(t));\n    }\n    // first derivative at t\n    derivative(t) {\n        return segParamDerivative(this.getSegParam(t));\n    }\n    // second derivative\n    secondDerivative(t) {\n        return segParamSecondDerivative(this.getSegParam(t));\n    }\n    // third derivative\n    thirdDerivative(t) {\n        return segParamThirdDerivative(this.getSegParam(t));\n    }\n    // For curves A(s) and B(t), when we have some evidence that\n    // there is at most one intersection point, and we have a guess for the parameters (s0, t0)...\n    // You are trying to bring to (0,0) the vector F(s,t) = A(s) - B(t).  To minimize the length of F(s,t)\n    // we solve the system of equations:\n    //F*Fs + (F*Fss + Fs*Fs)ds + (F*Fst + Fs*Ft)dt = 0\n    //F*Ft + (F*Fst + Fs*Ft)ds + (F*Ftt + Ft*Ft)dt = 0\n    //\n    //Where F = F(si,ti), Fs and Ft are the first partials at si, ti, Fxx are the second partials,\n    //   and s(i+1) = si+ds, t(i+1) = ti+dt.\n    //We adjust ds and dt to stay in the domain.\n    static crossWithinIntervalsWithGuess(a, b, amin, amax, bmin, bmax, aGuess, bGuess) {\n        if (a instanceof LineSegment && b instanceof LineSegment) {\n            const r = Curve.crossTwoLineSegs(a.start, a.end, b.start, b.end, amin, amax, bmin, bmax);\n            if (r !== undefined)\n                return r;\n        }\n        const mdout = Curve.minDistWithinIntervals(a, b, amin, amax, bmin, bmax, aGuess, bGuess);\n        if (mdout == null)\n            return;\n        const aMinusB = mdout.aX.sub(mdout.bX);\n        return aMinusB.dot(aMinusB) >= GeomConstants.distanceEpsilon\n            ? undefined\n            : {\n                aSol: mdout.aSol,\n                bSol: mdout.bSol,\n                x: Point.middle(mdout.aX, mdout.bX),\n            };\n    }\n    static crossTwoLineSegs(aStart, aEnd, bStart, bEnd, amin, amax, bmin, bmax) {\n        const u = aEnd.sub(aStart);\n        const v = bStart.sub(bEnd);\n        const w = bStart.sub(aStart);\n        const sol = LinearSystem2.solve(u.x, v.x, w.x, u.y, v.y, w.y);\n        if (sol == null)\n            return;\n        let aSol = sol.x;\n        let bSol = sol.y;\n        const x = aStart.add(u.mul(aSol));\n        if (aSol < amin - GeomConstants.tolerance)\n            return;\n        aSol = Math.max(aSol, amin);\n        if (aSol > amax + GeomConstants.tolerance)\n            return;\n        aSol = Math.min(aSol, amax);\n        if (bSol < bmin - GeomConstants.tolerance)\n            return;\n        bSol = Math.max(bSol, bmin);\n        if (bSol > bmax + GeomConstants.tolerance)\n            return;\n        bSol = Math.min(bSol, bmax);\n        /*Assert.assert(Point.closeDistEps(x, Point.convSum(bSol, bStart, bEnd)))*/\n        return {\n            aSol: aSol,\n            bSol: bSol,\n            x: x,\n        };\n    }\n    // Decides if the point lies inside, outside or on the curve\n    static PointRelativeToCurveLocation(point, curve) {\n        if (!curve.boundingBox.contains(point)) {\n            return PointLocation.Outside;\n        }\n        const l = 2 * curve.boundingBox.diagonal;\n        // l should be big enough for the line to exit outside of the curve\n        const degree = Math.PI / 180;\n        let inside = 0;\n        for (let i = 13; i < 360; i += 13) {\n            const lineDir = new Point(Math.cos(i * degree), Math.sin(i * degree));\n            const ls = LineSegment.mkPP(point, point.add(lineDir.mul(l)));\n            const intersections = this.getAllIntersectionsOfLineAndICurve(ls, curve, true);\n            // SugiyamaLayoutSettings.Show(ls, curve);\n            // CurveSerializer.Serialize(\"cornerC:\\\\tmp\\\\ls\",ls);\n            // CurveSerializer.Serialize(\"cornerC:\\\\tmp\\\\pol\",curve);\n            if (Curve.AllIntersectionsAreGood(intersections, curve)) {\n                for (const xx of intersections) {\n                    if (Point.closeDistEps(xx.x, point)) {\n                        return PointLocation.Boundary;\n                    }\n                }\n                const insideThisTime = intersections.length % 2 === 1;\n                // to be on the safe side we need to get the same result at least twice\n                if (insideThisTime) {\n                    inside++;\n                }\n                else {\n                    inside--;\n                }\n                if (inside >= 2) {\n                    return PointLocation.Inside;\n                }\n                if (inside <= -2) {\n                    return PointLocation.Outside;\n                }\n            }\n        }\n        // if all intersections are not good then we probably have the point on the boundaryCurve\n        return PointLocation.Boundary;\n    }\n    static AllIntersectionsAreGood(intersections, polygon) {\n        // If this isn't a Curve, try a Polyline.\n        //TODO: fix this to avoid the cast\n        const isCurve = polygon.hasOwnProperty('segs');\n        let curve = null;\n        if (!isCurve) {\n            const isPolyLine = polygon instanceof Polyline;\n            if (isPolyLine)\n                curve = polygon.toCurve();\n        }\n        if (curve)\n            for (const xx of intersections)\n                if (!Curve.RealCut(Curve.DropIntersectionToSegs(xx), curve, false))\n                    return false;\n        return true;\n    }\n    static RealCut(xx, polyline, onlyFromInsideCuts) {\n        const sseg = xx.seg0;\n        const pseg = xx.seg1;\n        const spar = xx.par0;\n        const ppar = xx.par1;\n        const x = xx.x;\n        // normalised tangent to spline\n        const ts = sseg.derivative(spar).normalize();\n        const pn = pseg\n            .derivative(ppar)\n            .normalize()\n            .rotate(Math.PI / 2);\n        if (Point.closeDistEps(x, pseg.end)) {\n            // so pseg enters the spline\n            let exitSeg = null;\n            for (let i = 0; i < polyline.segs.length - 1; i++) {\n                if (polyline.segs[i] === pseg) {\n                    exitSeg = polyline.segs[i + 1];\n                    break;\n                }\n            }\n            if (exitSeg == null) {\n                return false;\n            }\n            // hit the end of the polyline\n            const tsn = ts.rotate(Math.PI / 2);\n            const touch = tsn.dot(pseg.derivative(pseg.parEnd)) * tsn.dot(exitSeg.derivative(exitSeg.parStart)) < GeomConstants.tolerance;\n            return !touch;\n        }\n        if (Point.closeDistEps(x, pseg.start)) {\n            // so pseg exits the spline\n            let enterSeg = null;\n            for (let i = polyline.segs.length - 1; i > 0; i--) {\n                if (polyline.segs[i] === pseg) {\n                    enterSeg = polyline.segs[i - 1];\n                    break;\n                }\n            }\n            if (enterSeg == null) {\n                return false;\n            }\n            const tsn = ts.rotate(Math.PI / 2);\n            const touch = tsn.dot(pseg.derivative(pseg.parStart)) * tsn.dot(enterSeg.derivative(enterSeg.parEnd)) < GeomConstants.tolerance;\n            return !touch;\n        }\n        const d = ts.dot(pn);\n        if (onlyFromInsideCuts) {\n            return d > GeomConstants.distanceEpsilon;\n        }\n        return Math.abs(d) > GeomConstants.distanceEpsilon;\n    }\n    //   static boolean debug;\n    // Returns true if curves do not touch in the intersection point\n    // only when the second curve cuts the first one from the inside</param>\n    static realCutWithClosedCurve(xx, polygon, onlyFromInsideCuts) {\n        const sseg = xx.seg0;\n        const pseg = xx.seg1;\n        const spar = xx.par0;\n        const ppar = xx.par1;\n        const x = xx.x;\n        // normalised tangent to spline\n        const ts = sseg.derivative(spar).normalize();\n        const pn = pseg\n            .derivative(ppar)\n            .normalize()\n            .rotate(Math.PI / 2);\n        if (Point.closeDistEps(x, pseg.end)) {\n            // so pseg enters the spline\n            let exitSeg = null;\n            for (let i = 0; i < polygon.segs.length; i++) {\n                if (polygon.segs[i] === pseg) {\n                    exitSeg = polygon.segs[(i + 1) % polygon.segs.length];\n                    break;\n                }\n            }\n            if (exitSeg == null) {\n                throw new Error();\n            }\n            const tsn = ts.rotate(Math.PI / 2);\n            const touch = tsn.dot(pseg.derivative(pseg.parEnd)) * tsn.dot(exitSeg.derivative(exitSeg.parStart)) < GeomConstants.tolerance;\n            return !touch;\n        }\n        if (Point.closeDistEps(x, pseg.start)) {\n            // so pseg exits the spline\n            let enterSeg = null;\n            for (let i = 0; i < polygon.segs.length; i++) {\n                if (polygon.segs[i] === pseg) {\n                    enterSeg = polygon.segs[i > 0 ? i - 1 : polygon.segs.length - 1];\n                    break;\n                }\n            }\n            const tsn = ts.rotate(Math.PI / 2);\n            const touch = tsn.dot(pseg.derivative(pseg.parStart)) * tsn.dot(enterSeg.derivative(enterSeg.parEnd)) < GeomConstants.tolerance;\n            return !touch;\n        }\n        const d = ts.dot(pn);\n        if (onlyFromInsideCuts) {\n            return d > GeomConstants.distanceEpsilon;\n        }\n        return Math.abs(d) > GeomConstants.distanceEpsilon;\n    }\n    /*\n    \n    if (Point.closeDistEps(x, pseg.start)) {\n    //so pseg exits the spline\n    ICurve enterSeg = null;\n    for (int i = polyline.segs.length - 1; i > 0; i--)\n    if (polyline.segs[i] === pseg) {\n    enterSeg = polyline.segs[i - 1];\n    break;\n    }\n    if (enterSeg == null )\n    return false;\n    Point tsn = ts.rotate((Math.PI/2));\n    boolean touch = (tsn*pseg.derivative(pseg.Parstart))*\n    (tsn*enterSeg.derivative(enterSeg.parEnd)) < GeomConstants.tolerance;\n    \n    return !touch;\n    }\n    \n    number d = ts*pn;\n    if (onlyFromInsideCuts)\n    return d > GeomConstants.distanceEpsilon;\n    return Math.Abs(d) > GeomConstants.distanceEpsilon;\n    }\n    */\n    static minDistWithinIntervals(a, b, aMin, aMax, bMin, bMax, aGuess, bGuess) {\n        const md = new MinDistCurveCurve(a, b, aMin, aMax, bMin, bMax, aGuess, bGuess);\n        md.solve();\n        return md.success\n            ? {\n                aSol: md.aSolution,\n                bSol: md.bSolution,\n                aX: md.aPoint,\n                bX: md.bPoint,\n            }\n            : undefined;\n    }\n    /*\n        #if DEBUGCURVES\n        public override string ToString()\n        {\n        boolean poly = true;\n        for (ICurve s of segs)\n        if (s is LineSeg === false)\n        {\n        poly = false;\n        break;\n        }\n        \n        string ret;\n        if (!poly)\n        {\n        ret = \"{\";\n        \n        for (ICurve seg of Segs)\n        {\n        ret += seg + \",\";\n        }\n        \n        \n        return ret + \"}\";\n        }\n        ret = \"{\";\n        if (segs.length > 0)\n        ret += segs[0].start.x.ToString() + \",\" + segs[0].start.y.ToString()+\" \";\n        for(LineSeg s of segs)\n        ret += s.end.x.ToString() + \",\" + s.end.y.ToString() + \" \";\n        return ret + \"}\";\n        }\n        #endif\n     */\n    // Offsets the curve in the direction of dir\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    offsetCurve(offset, dir) {\n        throw new Error('Method not implemented.');\n        return null;\n    }\n    /**\n     * The bounding rectangle of the curve\n     */\n    get boundingBox() {\n        if (this.boundingBox_)\n            return this.boundingBox_;\n        if (this.segs.length === 0) {\n            this.boundingBox_ = Rectangle.mkEmpty();\n        }\n        else {\n            const b = this.segs[0].boundingBox.clone();\n            for (let i = 1; i < this.segs.length; i++)\n                b.addRecSelf(this.segs[i].boundingBox);\n            return (this.boundingBox_ = b);\n        }\n    }\n    /**  clones the curve */\n    clone() {\n        const c = new Curve();\n        for (const seg of this.segs)\n            c.addSegment(seg.clone());\n        if (this.boundingBox_ != null) {\n            c.boundingBox_ = this.boundingBox_.clone();\n        }\n        return c;\n    }\n    getParameterAtLength(length) {\n        let parSpan = 0.0;\n        for (const seg of this.segs) {\n            const segL = seg.length;\n            if (segL >= length)\n                return parSpan + seg.getParameterAtLength(length);\n            length -= segL;\n            parSpan += seg.parEnd - seg.parStart;\n        }\n        return this.parEnd;\n    }\n    get length() {\n        let r = 0;\n        for (const s of this.segs)\n            r += s.length;\n        return r;\n    }\n    /** returns a new curve */\n    transform(transformation) {\n        const c = new Curve();\n        for (const s of this.segs) {\n            c.addSegment(s.transform(transformation));\n        }\n        if (this.boundingBox_) {\n            c.boundingBox_ = this.boundingBox_.transform(transformation);\n        }\n        return c;\n    }\n    // returns a parameter t such that the distance between curve[t] and targetPoint is minimal\n    // and t belongs to the closed segment [low,high]\n    closestParameterWithinBounds(targetPoint, low, high) {\n        let par = 0;\n        let dist = Number.MAX_VALUE;\n        let offset = 0;\n        for (const seg of this.segs) {\n            if (offset > high)\n                break; //we are out of the [low, high] segment\n            const segparamSpan = Curve.paramSpan(seg);\n            const segEnd = offset + segparamSpan;\n            if (segEnd >= low) {\n                //we are in business\n                const segLow = Math.max(seg.parStart, seg.parStart + (low - offset));\n                const segHigh = Math.min(seg.parEnd, seg.parStart + (high - offset));\n                /*Assert.assert(segHigh >= segLow)*/\n                const t = seg.closestParameterWithinBounds(targetPoint, segLow, segHigh);\n                const d = targetPoint.sub(seg.value(t));\n                const dd = d.dot(d);\n                if (dd < dist) {\n                    par = offset + t - seg.parStart;\n                    dist = dd;\n                }\n            }\n            offset += segparamSpan;\n        }\n        return par;\n    }\n    // returns a parameter t such that the distance between curve[t] and a is minimal\n    closestParameter(targetPoint) {\n        let par = 0;\n        let dist = Number.MAX_VALUE;\n        let offset = 0;\n        for (const c of this.segs) {\n            const t = c.closestParameter(targetPoint);\n            const d = targetPoint.sub(c.value(t));\n            const dd = d.dot(d);\n            if (dd < dist) {\n                par = offset + t - c.parStart;\n                if (dd === 0) {\n                    break; // cannot beat 0!\n                }\n                dist = dd;\n            }\n            offset += Curve.paramSpan(c);\n        }\n        return par;\n    }\n    static addLineSegment(curve, pointA, pointB) {\n        return curve.addSegment(LineSegment.mkPP(pointA, pointB));\n    }\n    static addLineSegmentCNNP(c, x, y, b) {\n        return Curve.addLineSegment(c, new Point(x, y), b);\n    }\n    // adds a line segment to the curve\n    static addLineSegmentCNNNN(curve, x0, y0, x1, y1) {\n        Curve.addLineSegment(curve, new Point(x0, y0), new Point(x1, y1));\n    }\n    // adds a line segment to the curve\n    static continueWithLineSegmentNN(c, x, y) {\n        Curve.addLineSegment(c, c.end, new Point(x, y));\n    }\n    // adds a line segment to the curve\n    static continueWithLineSegmentP(c, x) {\n        Curve.addLineSegment(c, c.end, x);\n    }\n    static closeCurve(curve) {\n        Curve.continueWithLineSegmentP(curve, curve.start);\n        return curve;\n    }\n    // left derivative at t\n    leftDerivative(t) {\n        const seg = this.tryToGetLeftSegment(t);\n        if (seg != null)\n            return seg.derivative(seg.parEnd);\n        return this.derivative(t);\n    }\n    // right derivative at t\n    rightDerivative(t) {\n        const seg = this.tryToGetRightSegment(t);\n        if (seg != null)\n            return seg.derivative(seg.parStart);\n        return this.derivative(t);\n    }\n    tryToGetLeftSegment(t) {\n        if (Math.abs(t - this.parStart) < GeomConstants.tolerance) {\n            if (this.start.equal(this.end))\n                return this.segs[this.segs.length - 1];\n            return null;\n        }\n        for (const seg of this.segs) {\n            t -= Curve.paramSpan(seg);\n            if (Math.abs(t) < GeomConstants.tolerance)\n                return seg;\n        }\n        return null;\n    }\n    tryToGetRightSegment(t) {\n        if (Math.abs(t - this.parEnd) < GeomConstants.tolerance) {\n            if (this.start === this.end)\n                return this.segs[0];\n            return null;\n        }\n        for (const seg of this.segs) {\n            if (Math.abs(t) < GeomConstants.tolerance)\n                return seg;\n            t -= Curve.paramSpan(seg);\n        }\n        return null;\n    }\n    /*\n         // gets the closest point together with its parameter\n         public static number closestParameterWithPoint(ICurve curve, Point location, out Point pointOnCurve) {\n  \n         number t = curve.closestParameter(location);\n         pointOnCurve = curve[t];\n         return t;\n         }\n         */\n    // gets the point on the curve that is closest to the given point\n    static ClosestPoint(curve, location) {\n        return curve.value(curve.closestParameter(location));\n    }\n    // Tests whether the first curve is inside the second.\n    // We suppose that the curves are convex and they are\n    // not degenerated into a point\n    static CurveIsInsideOther(innerCurve, outerCurve) {\n        if (!outerCurve.boundingBox.containsRect(innerCurve.boundingBox)) {\n            return false;\n        }\n        const xx = Curve.getAllIntersections(innerCurve, outerCurve, true);\n        if (xx.length === 0) {\n            return Curve.NonIntersectingCurveIsInsideOther(innerCurve, outerCurve);\n        }\n        if (xx.length === 1)\n            //it has to be a touch\n            return !innerCurve.start.equal(xx[0].x)\n                ? Curve.PointRelativeToCurveLocation(innerCurve.start, outerCurve) === PointLocation.Inside\n                : Curve.PointRelativeToCurveLocation(innerCurve.value((innerCurve.parStart + innerCurve.parEnd) / 2), outerCurve) ==\n                    PointLocation.Inside;\n        for (const p of Curve.PointsBetweenIntersections(innerCurve, xx)) {\n            if (Curve.PointRelativeToCurveLocation(p, outerCurve) === PointLocation.Outside) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Return points between but not including the intersections.\n    static *PointsBetweenIntersections(a, xx) {\n        xx.sort((x, y) => x.par0 - y.par0);\n        for (let i = 0; i < xx.length - 1; i++) {\n            yield a.value((xx[i].par0 + xx[i + 1].par0) / 2);\n        }\n        // take care of the last interval\n        const start = xx[xx.length - 1].par0;\n        const end = xx[0].par0;\n        const len = a.parEnd - start + (end - a.parStart);\n        let middle = start + len / 2;\n        if (middle > a.parEnd) {\n            middle = a.parStart + (middle - a.parEnd);\n        }\n        yield a.value(middle);\n    }\n    static NonIntersectingCurveIsInsideOther(a, b) {\n        // Due to rounding, even curves with 0 intersections may return Boundary.\n        for (let par = a.parStart; par < a.parEnd; par += 0.5) {\n            // continue as long as we have boundary points.\n            const parLoc = Curve.PointRelativeToCurveLocation(a.value(par), b);\n            if (PointLocation.Boundary !== parLoc) {\n                return PointLocation.Inside === parLoc;\n            }\n        }\n        // All points so far were on border so it is not considered inside; test the End.\n        return PointLocation.Outside !== Curve.PointRelativeToCurveLocation(a.end, b);\n    }\n    // Tests whether the interiors of two closed convex curves intersect\n    static ClosedCurveInteriorsIntersect(c1, c2) {\n        if (!c2.boundingBox.intersects(c1.boundingBox)) {\n            return false;\n        }\n        const xx = Curve.getAllIntersections(c1, c2, true);\n        if (xx.length === 0) {\n            return Curve.NonIntersectingCurveIsInsideOther(c1, c2) || Curve.NonIntersectingCurveIsInsideOther(c2, c1);\n        }\n        if (xx.length === 1) {\n            //it is a touch\n            return !c1.start.equal(xx[0].x)\n                ? Curve.PointRelativeToCurveLocation(c1.start, c2) === PointLocation.Inside\n                : Curve.PointRelativeToCurveLocation(c1.value((c1.parStart + c1.parEnd) / 2), c2) === PointLocation.Inside ||\n                    !c2.start.equal(xx[0].x)\n                    ? Curve.PointRelativeToCurveLocation(c2.start, c1) === PointLocation.Inside\n                    : Curve.PointRelativeToCurveLocation(c2.value((c2.parStart + c2.parEnd) / 2), c1) === PointLocation.Inside;\n        }\n        for (const p of Curve.PointsBetweenIntersections(c1, xx)) {\n            if (Curve.PointRelativeToCurveLocation(p, c2) === PointLocation.Inside) {\n                return true;\n            }\n        }\n        return true;\n    }\n    // ICurve Members\n    curvature(t) {\n        const sp = this.getSegParam(t);\n        return sp.seg.curvature(sp.par);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    curvatureDerivative(t) {\n        throw new Error('Not implemente');\n    }\n    //\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    curvatureSecondDerivative(t) {\n        throw new Error('Not implemented');\n    }\n    /*  #endregion\n         \n         public static boolean CurvesIntersect(ICurve curve1, ICurve curve2) {\n         return curve1 === curve2 || (CurveCurveIntersectionOne(curve1, curve2, false) != null);\n         }\n         */\n    static createBezierSeg(kPrev, kNext, a, b, c) {\n        const s = Point.mkPoint(kPrev, a.point, 1 - kPrev, b.point);\n        const e = Point.mkPoint(kNext, c.point, 1 - kNext, b.point);\n        const t = b.point.mul(2.0 / 3.0);\n        return new BezierSeg(s, s.div(3.0).add(t), t.add(e.div(3.0)), e);\n    }\n    static createBezierSegN(a, b, perp, i) {\n        const d = perp.mul(i);\n        return new BezierSeg(a, a.add(d), b.add(d), b);\n    }\n    static findCorner(a) {\n        const b = a.next;\n        if (b.next == null)\n            return; //no corner has been found\n        const c = b.next;\n        if (c == null)\n            return;\n        return { b: b, c: c };\n    }\n    static trimEdgeSplineWithNodeBoundaries(sourceBoundary, targetBoundary, spline, narrowestInterval) {\n        let start = spline.parStart;\n        let end = spline.parEnd;\n        if (sourceBoundary != null)\n            start = Curve.findNewStart(spline, start, sourceBoundary, narrowestInterval);\n        if (targetBoundary != null)\n            end = Curve.findNewEnd(spline, targetBoundary, narrowestInterval, end);\n        const st = Math.min(start, end);\n        const en = Math.max(start, end);\n        return st < en ? spline.trim(st, en) : spline;\n    }\n    static findNewEnd(spline, targetBoundary, narrowestInterval, end) {\n        //SugiyamaLayoutSettings.Show(c, spline);\n        const intersections = Curve.getAllIntersections(spline, targetBoundary, true);\n        if (intersections.length === 0) {\n            end = spline.parEnd;\n            return end;\n        }\n        if (narrowestInterval) {\n            end = spline.parEnd;\n            for (const xx of intersections)\n                if (xx.par0 < end)\n                    end = xx.par0;\n        }\n        else {\n            //looking for the last intersection\n            end = spline.parStart;\n            for (const xx of intersections)\n                if (xx.par0 > end)\n                    end = xx.par0;\n        }\n        return end;\n    }\n    static findNewStart(spline, start, sourceBoundary, narrowestInterval) {\n        const intersections = Curve.getAllIntersections(spline, sourceBoundary, true);\n        if (intersections.length === 0) {\n            start = spline.parStart;\n            return;\n        }\n        if (narrowestInterval) {\n            start = spline.parStart;\n            for (const xx of intersections)\n                if (xx.par0 > start)\n                    start = xx.par0;\n        }\n        else {\n            start = spline.parEnd;\n            for (const xx of intersections)\n                if (xx.par0 < start)\n                    start = xx.par0;\n        }\n        return start;\n    }\n    static polylineAroundClosedCurve(curve) {\n        if (curve instanceof Ellipse)\n            return Curve.refineEllipse(curve);\n        if (curve instanceof Polyline)\n            return curve;\n        if (curve instanceof Curve && Curve.allSegsAreLines(curve)) {\n            const ret = new Polyline();\n            for (const ls of curve.segs)\n                ret.addPoint(ls.start);\n            ret.closed = true;\n            if (!ret.isClockwise())\n                return ret.reverse();\n        }\n        return curve.boundingBox.perimeter();\n    }\n    static allSegsAreLines(c) {\n        for (const s of c.segs)\n            if (!(s instanceof LineSegment))\n                return false;\n        return true;\n    }\n    // this code only works for the standard ellipse\n    static refineEllipse(ellipse) {\n        const rect = ellipse.boundingBox.perimeter();\n        const a = Math.PI / 4;\n        const w = ellipse.boundingBox.width;\n        const h = ellipse.boundingBox.height;\n        const l = Math.sqrt(w * w + h * h);\n        const xs = [];\n        for (let i = 0; i < 4; i++) {\n            const t = a + (i * Math.PI) / 2; // parameter\n            const p = ellipse.value(t); //point on the ellipse\n            const tan = ellipse.derivative(t).normalize().mul(l); //make it long enough\n            const ls = LineSegment.mkPP(p.sub(tan), p.add(tan));\n            for (const x of Curve.getAllIntersections(rect, ls, true))\n                xs.push(x);\n        }\n        /*Assert.assert(xs.length > 0)*/\n        xs.sort((a, b) => (a.par0 < b.par0 ? -1 : a.par0 > b.par0 ? 1 : 0));\n        const ret = new Polyline();\n        xs.forEach((x) => ret.addPoint(x.x));\n        ret.closed = true;\n        return ret;\n    }\n    // Create a closed Polyline from a rectangle\n    static polyFromBox(rectangle) {\n        const p = new Polyline();\n        p.addPoint(rectangle.leftTop);\n        p.addPoint(rectangle.rightTop);\n        p.addPoint(rectangle.rightBottom);\n        p.addPoint(rectangle.leftBottom);\n        p.closed = true;\n        return p;\n    }\n}\n// a, b are parameters of the curve\nfunction isCloseToLineSeg(a, ap, b, bp, s, e) {\n    /*Assert.assert(Point.closeDistEps(s.value(a), ap))*/\n    /*Assert.assert(Point.closeDistEps(s.value(b), bp))*/\n    if (s instanceof LineSegment)\n        return true;\n    for (const x of [1 / 3, 0.5, 2 / 3]) {\n        const p = a * x + b * (1 - x); // the parameter on the curve s\n        const pointsAreClose = Point.closeSquare(s.value(p), Point.mkPoint(x, ap, 1 - x, bp), e * e);\n        if (pointsAreClose === false) {\n            return false;\n        }\n    }\n    return true;\n}\n// interpolates the curve between parameters 'a' and 'b' by a sequence of line segments\nfunction interpolate(a, ap, b, bp, s, eps) {\n    /*Assert.assert(Point.closeDistEps(s.value(a), ap))*/\n    /*Assert.assert(Point.closeDistEps(s.value(b), bp))*/\n    let r = [];\n    if (isCloseToLineSeg(a, ap, b, bp, s, eps)) {\n        r.push(ap);\n        r.push(bp);\n    }\n    else {\n        const m = 0.5 * (a + b);\n        const mp = s.value(m);\n        r = interpolate(a, ap, m, mp, s, eps);\n        const tail = interpolate(m, mp, b, bp, s, eps).slice(1);\n        r = r.concat(tail);\n    }\n    return r;\n}\nexport function interpolateICurve(s, eps) {\n    return interpolate(s.parStart, s.start, s.parEnd, s.end, s, eps);\n}\n/** Iterate over all icurve subsegments that intersect the given rectangle.\n * The function might return subsegments that are running outside of the rectangle\n *  but still close to its border.\n *\n * Should be removed\n */\nexport function* clipWithRectangle(curve, rect) {\n    if (rect.containsRectWithPadding(curve.boundingBox, 1)) {\n        yield curve;\n        return;\n    }\n    const perimeter = rect.perimeter();\n    const x = Curve.getAllIntersections(curve, perimeter, true);\n    if (x.length == 0) {\n        if (rect.contains(curve.start))\n            yield curve;\n        return;\n    }\n    x.sort((x, y) => x.par0 - y.par0);\n    const xs = [curve.parStart];\n    let i = 0;\n    for (; i < x.length; i++) {\n        const ii = x[i];\n        if (ii.par0 > xs[xs.length - 1] + GeomConstants.distanceEpsilon) {\n            xs.push(ii.par0);\n        }\n    }\n    if (curve.parEnd > xs[xs.length - 1] + GeomConstants.distanceEpsilon) {\n        xs.push(curve.parEnd);\n    }\n    for (i = 0; i < xs.length - 1; i++) {\n        if (segmentShouldBeIncluded(curve, xs[i], xs[i + 1], rect)) {\n            const seg = curve.trim(xs[i], xs[i + 1]);\n            yield seg;\n        }\n    }\n}\n/** Looking for all subsegments of of 'curve' intersecting 'rect'\n *  For each such a segment return {start:a, end:b} such that segment = curve.trim(a,b)\n */\nexport function* clipWithRectangleInsideInterval(curve, rect) {\n    if (curve == null)\n        return;\n    if (rect.containsRect(curve.boundingBox)) {\n        yield curve;\n        return;\n    }\n    const xs = Curve.getAllIntersections(curve, rect.perimeter(), true);\n    // // debug\n    // for (const x of xs) {\n    //   Assert.assert(Point.closeDistEps(x.x, curve.value(x.par0)))\n    //   // Assert.assert(Point.closeDistEps(x.x, origCurvDebug.value(x.par0)))\n    // }\n    if (xs.length == 0) {\n        if (rect.contains(curve.start))\n            yield curve;\n        return;\n    }\n    xs.sort((x, y) => x.par0 - y.par0);\n    const filteredXs = [curve.parStart];\n    let i = 0;\n    for (; i < xs.length; i++) {\n        const ii = xs[i];\n        if (ii.par0 > filteredXs[filteredXs.length - 1] + GeomConstants.distanceEpsilon) {\n            filteredXs.push(ii.par0);\n        }\n    }\n    if (curve.parEnd > filteredXs[filteredXs.length - 1] + GeomConstants.distanceEpsilon) {\n        filteredXs.push(curve.parEnd);\n    }\n    for (i = 0; i < filteredXs.length - 1; i++) {\n        if (segmentShouldBeIncluded(curve, filteredXs[i], filteredXs[i + 1], rect)) {\n            const tr = curve.trim(filteredXs[i], filteredXs[i + 1]);\n            if (tr)\n                yield tr;\n        }\n    }\n}\n/** Check the points curve[a+(b-a)/5],[a+2*(b-a)/5], [a+3*(b-a)/5], [a+4*(b-a)/5]\n *  If at least one of them is inside of the rect return true, otherwise return false\n */\nfunction segmentShouldBeIncluded(curve, a, b, rect) {\n    const del = (b - a) / 5;\n    for (let i = 1; i < 5; i++) {\n        const t = a + del * i;\n        if (rect.contains(curve.value(t)))\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=curve.js.map","import { Ellipse } from './ellipse';\nimport { Curve } from './curve';\nimport { Point } from './point';\nimport { LineSegment } from './lineSegment';\nimport { PlaneTransformation } from './planeTransformation';\nimport { Polyline } from '.';\nexport class CurveFactory {\n    static mkEllipse(rx, ry, center) {\n        return Ellipse.mkFullEllipseNNP(rx, ry, center);\n    }\n    static createParallelogram(width, height, center) {\n        const h = height / 2;\n        const w = width / 2;\n        const x = center.x;\n        const y = center.y;\n        const angle = (80 * Math.PI) / 180;\n        const deltax = h / Math.tan(angle);\n        const poly = Polyline.mkClosedFromPoints([\n            new Point(-w - deltax + x, -h + y),\n            new Point(w + x, -h + y),\n            new Point(w + x + deltax, h + y),\n            new Point(-w + x, h + y),\n        ]);\n        return poly;\n    }\n    static createHexagon(width, height, center) {\n        const h = height / 2;\n        const w = width / 2;\n        const x = center.x;\n        const y = center.y;\n        const poly = Polyline.mkClosedFromPoints([\n            new Point(-w + x, -h + y),\n            new Point(w + x, -h + y),\n            new Point(w + (h + x), 0 + y),\n            new Point(w + x, h + y),\n            new Point(-w + x, h + y),\n            new Point(-(w - h) + x, 0 + y),\n        ]);\n        return poly;\n    }\n    static createOctagon(width, height, center) {\n        const w = width / 2;\n        const h = height / 2;\n        const ps = new Array(8);\n        // Pad out horizontally\n        ps[0] = new Point(w + CurveFactory.octagonPad * w, h - h * CurveFactory.octagonPad);\n        ps[3] = new Point(ps[0].x * -1, ps[0].y);\n        ps[4] = new Point(ps[3].x, ps[3].y * -1);\n        ps[7] = new Point(ps[0].x, ps[0].y * -1);\n        // Pad out vertically\n        ps[1] = new Point(w - w * CurveFactory.octagonPad, h + h * CurveFactory.octagonPad);\n        ps[2] = new Point(ps[1].x * -1, ps[1].y);\n        ps[6] = new Point(ps[1].x, ps[1].y * -1);\n        ps[5] = new Point(ps[2].x, ps[2].y * -1);\n        for (let i = 0; i < 8; i++) {\n            ps[i] = ps[i].add(center);\n        }\n        return Polyline.mkClosedFromPoints(ps);\n    }\n    static createInvertedHouse(width, height, center) {\n        const shape = CurveFactory.createHouse(width, height, center);\n        return CurveFactory.rotateCurveAroundCenterByDegree(shape, center, 180);\n    }\n    static createHouse(width, height, center) {\n        const w = width / 2;\n        const h = height / 2;\n        const x = center.x;\n        const y = center.y;\n        const c = new Curve();\n        Curve.addLineSegmentCNNNN(c, x - w, y - h, x + w, y - h);\n        Curve.continueWithLineSegmentNN(c, x + w, y + h);\n        Curve.continueWithLineSegmentNN(c, x, y + 2 * h);\n        Curve.continueWithLineSegmentNN(c, x - w, y + h);\n        return Curve.closeCurve(c);\n    }\n    static mkDiamond(width, height, center) {\n        const w = width;\n        const h = height;\n        const x = center.x;\n        const y = center.y;\n        const c = new Curve();\n        const p = [new Point(x, y - h), new Point(x + w, y), new Point(x, y + h), new Point(x - w, y)];\n        c.addSegs([LineSegment.mkPP(p[0], p[1]), LineSegment.mkPP(p[1], p[2]), LineSegment.mkPP(p[2], p[3]), LineSegment.mkPP(p[3], p[0])]);\n        return c;\n    }\n    static rotateCurveAroundCenterByDegree(curve, center, angle) {\n        return CurveFactory.rotateCurveAroundCenterByRadian(curve, center, (angle * Math.PI) / 180);\n    }\n    static rotateCurveAroundCenterByRadian(curve, center, angle) {\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        const transform = new PlaneTransformation(1, 0, center.x, 0, 1, center.y)\n            .multiply(new PlaneTransformation(c, -s, 0, s, c, 0))\n            .multiply(new PlaneTransformation(1, 0, -center.x, 0, 1, -center.y));\n        return curve.transform(transform);\n    }\n    static mkCircle(radius, center) {\n        return Ellipse.mkCircle(radius, center);\n    }\n    static createRectangle(width, height, center) {\n        const w = width / 2;\n        const h = height / 2;\n        const x = center.x;\n        const y = center.y;\n        const c = new Curve();\n        const p = [new Point(x - w, y - h), new Point(x + w, y - h), new Point(x + w, y + h), new Point(x - w, y + h)];\n        c.addSegs([LineSegment.mkPP(p[0], p[1]), LineSegment.mkPP(p[1], p[2]), LineSegment.mkPP(p[2], p[3]), LineSegment.mkPP(p[3], p[0])]);\n        return c;\n    }\n    static isRoundedRect(ic) {\n        if (!(ic instanceof Curve))\n            return;\n        const segs = ic.segs;\n        if (segs.length !== 8 && segs.length !== 4)\n            return;\n        const full = segs.length === 8 ? true : false;\n        let radX;\n        let radY;\n        for (let k = 0; k < 4; k++) {\n            const i = full ? 2 * k + 1 : k;\n            if (k === 0) {\n                if (!(segs[i] instanceof Ellipse)) {\n                    return;\n                }\n                const el = segs[i];\n                radX = el.aAxis.length;\n                radY = el.bAxis.length;\n            }\n            else {\n                if (!(segs[i] instanceof Ellipse)) {\n                    return;\n                }\n                const el = segs[i];\n                if (radX !== el.aAxis.length || radY !== el.bAxis.length)\n                    return;\n            }\n            // some more checks are missing!\n        }\n        return {\n            radX: radX,\n            radY: radY,\n        };\n    }\n    static mkRectangleWithRoundedCorners(width, height, radX, radY, center = new Point(0, 0)) {\n        if (radX === 0 || radY === 0) {\n            return CurveFactory.createRectangle(width, height, center);\n        }\n        const c = new Curve();\n        const w = width / 2;\n        if (radX > w / 2)\n            radX = w / 2;\n        const h = height / 2;\n        if (radY > h / 2)\n            radY = h / 2;\n        const x = center.x;\n        const y = center.y;\n        const ox = w - radX;\n        const oy = h - radY;\n        const top = y + h;\n        const bottom = y - h;\n        const left = x - w;\n        const right = x + w;\n        //ellipse's axises\n        const a = new Point(radX, 0);\n        const b = new Point(0, radY);\n        if (ox > 0)\n            c.addSegment(LineSegment.mkPP(new Point(x - ox, bottom), new Point(x + ox, bottom)));\n        c.addSegment(Ellipse.mkEllipse(1.5 * Math.PI, 2 * Math.PI, a, b, x + ox, y - oy));\n        if (oy > 0)\n            c.addSegment(LineSegment.mkPP(new Point(right, y - oy), new Point(right, y + oy)));\n        c.addSegment(Ellipse.mkEllipse(0, 0.5 * Math.PI, a, b, x + ox, y + oy));\n        if (ox > 0)\n            c.addSegment(LineSegment.mkPP(new Point(x + ox, top), new Point(x - ox, top)));\n        c.addSegment(Ellipse.mkEllipse(0.5 * Math.PI, Math.PI, a, b, x - ox, y + oy));\n        if (oy > 0)\n            c.addSegment(LineSegment.mkPP(new Point(left, y + oy), new Point(left, y - oy)));\n        c.addSegment(Ellipse.mkEllipse(Math.PI, 1.5 * Math.PI, a, b, x - ox, y - oy));\n        return c;\n    }\n}\n// This adds the padding to the edges around the inscribed rectangle of an octagon.\nCurveFactory.octagonPad = 1.0 / 4;\n//# sourceMappingURL=curveFactory.js.map","// define a reference to a function that will be set by the caller\n// to dump the debug curves to a file\nexport const DebugObject = {\n    dumpDebugCurves: null,\n};\nexport class DebugCurve {\n    clone() {\n        const r = new DebugCurve();\n        r.transparency = this.transparency;\n        r.width = this.width;\n        r.color = this.color;\n        r.icurve = this.icurve.clone();\n        r.label = this.label;\n        r.dashArray = this.dashArray;\n        r.drawPN = this.drawPN;\n        return r;\n    }\n    static mkDebugCurveTWCILD(transparency, width, color, curve, label, dashArray, drawPN = false) {\n        const r = new DebugCurve();\n        r.transparency = transparency;\n        r.width = width;\n        r.color = color;\n        r.icurve = curve;\n        r.label = label;\n        r.dashArray = dashArray;\n        r.drawPN = drawPN;\n        return r;\n    }\n    static mkDebugCurveTWCI(transparency, width, color, curve) {\n        return DebugCurve.mkDebugCurveTWCILD(transparency, width, color, curve, null, null);\n    }\n    static mkDebugCurveWCI(width, color, curve) {\n        return DebugCurve.mkDebugCurveTWCI(255, width, color, curve);\n    }\n    static mkDebugCurveCI(color, curve) {\n        return DebugCurve.mkDebugCurveWCI(1, color, curve);\n    }\n    static mkDebugCurveI(curve) {\n        return DebugCurve.mkDebugCurveCI('Black', curve);\n    }\n}\n// color strings for debugging\nDebugCurve.colors = [\n    'DeepSkyBlue',\n    'IndianRed',\n    'Orange',\n    'Gold',\n    'DarkRed',\n    'Plum',\n    'Red',\n    'Violet',\n    'Indigo',\n    'Yellow',\n    'OrangeRed',\n    'Tomato',\n    'Purple',\n    'SaddleBrown',\n    'Green',\n    'Navy',\n    'Aqua',\n    'Pink',\n    'Bisque',\n    'Black',\n    'BlanchedAlmond',\n    'Blue',\n    'BlueViolet',\n    'Brown',\n    'Lime',\n    'BurlyWood',\n    'Chocolate',\n    'Coral',\n    'CornflowerBlue',\n    'Cornsilk',\n    'Crimson',\n    'Cyan',\n    'CadetBlue',\n    'Chartreuse',\n    'DarkBlue',\n    'DarkCyan',\n    'DarkGoldenrod',\n    'DarkGray',\n    'DarkGreen',\n    'DarkKhaki',\n    'DarkMagenta',\n    'DarkOliveGreen',\n    'DarkOrange',\n    'DarkOrchid',\n    'DarkSalmon',\n    'DarkSeaGreen',\n    'DarkSlateBlue',\n    'DarkSlateGray',\n    'DarkTurquoise',\n    'DarkViolet',\n    'DeepPink',\n    'DimGray',\n    'DodgerBlue',\n    'Firebrick',\n    'FloralWhite',\n    'ForestGreen',\n    'Fuchsia',\n    'CodeAnalysis',\n    'Gainsboro',\n    'GhostWhite',\n    'Goldenrod',\n    'Gray',\n    'GreenYellow',\n    'Honeydew',\n    'HotPink',\n    'Ivory',\n    'Lavender',\n    'LavenderBlush',\n    'LawnGreen',\n    'LemonChiffon',\n    'LightBlue',\n    'LightCoral',\n    'LightCyan',\n    'LightGoldenrodYellow',\n    'LightGray',\n    'LightGreen',\n    'LightPink',\n    'LightSalmon',\n    'LightSeaGreen',\n    'LightSkyBlue',\n    'LightSlateGray',\n    'LightSteelBlue',\n    'LightYellow',\n    'LimeGreen',\n    'Linen',\n    'Magenta',\n    'Maroon',\n    'MediumAquamarine',\n    'MediumBlue',\n    'MediumOrchid',\n    'MediumPurple',\n    'MediumSeaGreen',\n    'MediumSlateBlue',\n    'MediumSpringGreen',\n    'MediumTurquoise',\n    'MediumVioletRed',\n    'MidnightBlue',\n    'MintCream',\n    'MistyRose',\n    'Moccasin',\n    'NavajoWhite',\n    'OldLace',\n    'Olive',\n    'OliveDrab',\n    'Orchid',\n    'PaleGoldenrod',\n    'PaleGreen',\n    'PaleTurquoise',\n    'PaleVioletRed',\n    'PapayaWhip',\n    'PeachPuff',\n    'Peru',\n    'PowderBlue',\n    'RosyBrown',\n    'RoyalBlue',\n    'Salmon',\n    'SandyBrown',\n    'SeaGreen',\n    'CodeAnalysis',\n    'SeaShell',\n    'Sienna',\n    'Silver',\n    'SkyBlue',\n    'SlateBlue',\n    'SlateGray',\n    'Snow',\n    'SpringGreen',\n    'SteelBlue',\n    'Tan',\n    'Teal',\n    'Thistle',\n    'Transparent',\n    'Turquoise',\n    'Aquamarine',\n    'Azure',\n    'Beige',\n    'Wheat',\n    'White',\n    'WhiteSmoke',\n    'YellowGreen',\n    'Khaki',\n    'AntiqueWhite',\n];\n//# sourceMappingURL=debugCurve.js.map","// enumerates the compass directions\nexport var Direction;\n(function (Direction) {\n    Direction[Direction[\"None\"] = 0] = \"None\";\n    Direction[Direction[\"North\"] = 1] = \"North\";\n    Direction[Direction[\"East\"] = 2] = \"East\";\n    Direction[Direction[\"South\"] = 4] = \"South\";\n    Direction[Direction[\"West\"] = 8] = \"West\";\n})(Direction || (Direction = {}));\n//# sourceMappingURL=direction.js.map","import { Curve } from './curve';\nimport { Rectangle } from './rectangle';\nimport { ParallelogramNode } from './parallelogramNode';\nimport { Point } from './point';\nimport { GeomConstants } from './geomConstants';\nimport { ClosestPointOnCurve } from './closestPointOnCurve';\nimport { closeDistEps } from '../../utils/compare';\nexport class Ellipse {\n    isFullEllipse() {\n        return this.parEnd === Math.PI * 2 && this.parStart === 0;\n    }\n    static fromJSON(eData) {\n        return new Ellipse(eData.parStart, eData.parEnd, Point.fromJSON(eData.axis0), Point.fromJSON(eData.axis1), Point.fromJSON(eData.center));\n    }\n    toJSON() {\n        return {\n            parStart: this.parStart,\n            parEnd: this.parEnd,\n            axis0: this.aAxis.toJSON(),\n            axis1: this.bAxis.toJSON(),\n            center: this.center.toJSON(),\n        };\n    }\n    /** offsets the curve in the given direction */\n    offsetCurve(offset, dir) {\n        /**is dir inside or outside of the ellipse */\n        const d = dir.sub(this.center);\n        const angle = Point.angle(this.aAxis, d);\n        const s = this.aAxis.mul(Math.cos(angle)).add(this.bAxis.mul(Math.sin(angle)));\n        if (s.length < d.length) {\n            const al = this.aAxis.length;\n            const bl = this.bAxis.length;\n            return Ellipse.mkEllipsePPP(this.aAxis.normalize().mul(al + offset), this.bAxis.normalize().mul(bl + offset), this.center);\n        }\n        {\n            const al = this.aAxis.length;\n            const bl = this.bAxis.length;\n            return Ellipse.mkEllipsePPP(this.aAxis.normalize().mul(al - offset), this.bAxis.normalize().mul(bl - offset), this.center);\n        }\n    }\n    /** Reverse the ellipe: not implemented. */\n    reverse() {\n        return null; // throw new Exception(\"not implemented\");\n    }\n    static mkEllipsePPP(a, b, center) {\n        return new Ellipse(0, Math.PI * 2, a, b, center);\n    }\n    constructor(parStart, parEnd, axis0, axis1, center) {\n        //   assert(parStart <= parEnd);\n        this.parStart = parStart;\n        this.parEnd = parEnd;\n        this.aAxis = axis0;\n        this.bAxis = axis1;\n        this.center = center;\n        this.pNode = null;\n        this.setBoundingBox();\n        // this.parStart has to be nonnegative because of the way curve searches for the segment of a parameter\n        while (this.parStart < 0) {\n            this.parStart += Math.PI * 2;\n            this.parEnd += Math.PI * 2;\n        }\n    }\n    get start() {\n        return this.value(this.parStart);\n    }\n    get end() {\n        return this.value(this.parEnd);\n    }\n    /** Trims the curve */\n    trim(start, end) {\n        // Assert.assert(start <= end);\n        // Assert.assert(start >= ParStart - GeomConstants.tolerance);\n        // Assert.assert(end <= ParEnd + GeomConstants.tolerance);\n        return new Ellipse(Math.max(start, this.parStart), Math.min(end, this.parEnd), this.aAxis, this.bAxis, this.center);\n    }\n    // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    trimWithWrap(start, end) {\n        return null;\n    }\n    /** The bounding box of the ellipse */\n    get boundingBox() {\n        return this.box;\n    }\n    /** Returns the point on the curve corresponding to parameter t */\n    value(t) {\n        return this.center.add(Point.mkPoint(Math.cos(t), this.aAxis, Math.sin(t), this.bAxis));\n    }\n    /** first derivative */\n    derivative(t) {\n        return Point.mkPoint(-Math.sin(t), this.aAxis, Math.cos(t), this.bAxis);\n    }\n    /** second derivative */\n    secondDerivative(t) {\n        return Point.mkPoint(-Math.cos(t), this.aAxis, -Math.sin(t), this.bAxis);\n    }\n    /** third derivative */\n    thirdDerivative(t) {\n        return Point.mkPoint(Math.sin(t), this.aAxis, -Math.cos(t), this.bAxis);\n    }\n    /** a tree of ParallelogramNodes covering the edge */\n    pNodeOverICurve() {\n        if (this.pNode != null)\n            return this.pNode;\n        return (this.pNode = ParallelogramNode.createParallelogramNodeForCurveSegDefaultOffset(this));\n    }\n    setBoundingBox() {\n        if (closeDistEps(this.parStart, 0) && closeDistEps(this.parEnd, Math.PI * 2))\n            this.box = this.fullBox();\n        else {\n            // the idea is that the box of an arc staying in one quadrant is just the box of the start and the end point of the arc\n            this.box = Rectangle.mkPP(this.start, this.end);\n            //now Start and End are in the box, we need just add all k*P/2 that are in between\n            let t;\n            for (let i = Math.ceil(this.parStart / (Math.PI / 2)); (t = (i * Math.PI) / 2) < this.parEnd; i++)\n                if (t > this.parStart)\n                    this.box.add(this.value(t));\n        }\n    }\n    static mkEllipse(parStart, parEnd, axis0, axis1, centerX, centerY) {\n        return new Ellipse(parStart, parEnd, axis0, axis1, new Point(centerX, centerY));\n    }\n    /** Construct a full ellipse by two axes */\n    static mkFullEllipsePPP(axis0, axis1, center) {\n        return new Ellipse(0, Math.PI * 2, axis0, axis1, center);\n    }\n    /** Constructs a full ellipse with axes aligned to X and Y directions */\n    static mkFullEllipseNNP(axisA, axisB, center) {\n        return new Ellipse(0, Math.PI * 2, new Point(axisA, 0), new Point(0, axisB), center);\n    }\n    /** creates a circle by a given radius and the center */\n    static mkCircle(radius, center) {\n        return Ellipse.mkFullEllipseNNP(radius, radius, center);\n    }\n    /** Moves the ellipse to the delta vector */\n    translate(delta) {\n        this.center = this.center.add(delta);\n        this.box.center = this.box.center.add(delta);\n        this.pNode = null;\n    }\n    /** Scales the ellipse by x and by y */\n    scaleFromOrigin(xScale, yScale) {\n        return new Ellipse(this.parStart, this.parEnd, this.aAxis.mul(xScale), this.bAxis.mul(yScale), this.center.scale(xScale, yScale));\n    }\n    //\n    getParameterAtLength(length) {\n        //todo: slow version!\n        const eps = 0.001;\n        let l = this.parStart;\n        let u = this.parEnd;\n        const lenplus = length + eps;\n        const lenminsu = length - eps;\n        while (u - l > GeomConstants.distanceEpsilon) {\n            const m = 0.5 * (u + l);\n            const len = this.lengthPartial(this.parStart, m);\n            if (len > lenplus)\n                u = m;\n            else if (len < lenminsu)\n                l = m;\n            else\n                return m;\n        }\n        return (u + l) / 2;\n    }\n    /** Transforms the ellipse */\n    transform(transformation) {\n        if (transformation != null) {\n            const ap = transformation.multiplyPoint(this.aAxis).sub(transformation.offset());\n            const bp = transformation.multiplyPoint(this.bAxis).sub(transformation.offset());\n            return new Ellipse(this.parStart, this.parEnd, ap, bp, transformation.multiplyPoint(this.center));\n        }\n        return this.clone();\n    }\n    /** returns a parameter t such that the distance between curve[t] and targetPoint is minimal\n     * and t belongs to the closed segment [low,high] */\n    closestParameterWithinBounds(targetPoint, low, high) {\n        const numberOfTestPoints = 8;\n        const t = (high - low) / (numberOfTestPoints + 1);\n        let closest = low;\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i <= numberOfTestPoints; i++) {\n            const par = low + i * t;\n            const p = targetPoint.sub(this.value(par));\n            const d = p.dot(p);\n            if (d < minDist) {\n                minDist = d;\n                closest = par;\n            }\n        }\n        if (closest === 0 && high === Math.PI * 2)\n            low = -Math.PI;\n        let ret = ClosestPointOnCurve.closestPoint(this, targetPoint, closest, low, high);\n        if (ret < 0)\n            ret += 2 * Math.PI;\n        return ret;\n    }\n    // return length of the curve segment [start,end] : not implemented\n    lengthPartial(start, end) {\n        return Curve.lengthWithInterpolationAndThreshold(this.trim(start, end), GeomConstants.lineSegmentThreshold / 100);\n    }\n    get length() {\n        return ((this.aAxis.length + this.bAxis.length) * Math.abs(this.parEnd - this.parStart)) / 2;\n    }\n    /** clones the ellipse . */\n    clone() {\n        return new Ellipse(this.parStart, this.parEnd, this.aAxis.clone(), this.bAxis.clone(), this.center.clone());\n    }\n    /** returns a parameter t such that the distance between curve[t] and a is minimal */\n    closestParameter(targetPoint) {\n        let savedParStart = 0;\n        const numberOfTestPoints = 8;\n        const t = (this.parEnd - this.parStart) / (numberOfTestPoints + 1);\n        let closest = this.parStart;\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i <= numberOfTestPoints; i++) {\n            const par = this.parStart + i * t;\n            const p = targetPoint.sub(this.value(par));\n            const d = p.dot(p);\n            if (d < minDist) {\n                minDist = d;\n                closest = par;\n            }\n        }\n        let parStartWasChanged = false;\n        if (closest === 0 && this.parEnd === Math.PI * 2) {\n            parStartWasChanged = true;\n            savedParStart = this.parStart;\n            this.parStart = -Math.PI;\n        }\n        let ret = ClosestPointOnCurve.closestPoint(this, targetPoint, closest, this.parStart, this.parEnd);\n        if (ret < 0)\n            ret += 2 * Math.PI;\n        if (parStartWasChanged)\n            this.parStart = savedParStart;\n        return ret;\n    }\n    // left derivative at t\n    leftDerivative(t) {\n        return this.derivative(t);\n    }\n    // right derivative at t\n    rightDerivative(t) {\n        return this.derivative(t);\n    }\n    //\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    curvature(t) {\n        throw 'NotImplementedException()';\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    curvatureDerivative(t) {\n        throw 'NotImplementedException();';\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    curvatureSecondDerivative(t) {\n        throw 'NotImplementedException()';\n        return 0;\n    }\n    // returns true if the ellipse goes counterclockwise\n    orientedCounterclockwise() {\n        return Point.crossProduct(this.aAxis, this.bAxis) > 0;\n    }\n    //returns the box of the ellipse that this ellipse is a part of\n    fullBox() {\n        const del = this.aAxis.add(this.bAxis);\n        return Rectangle.mkPP(this.center.add(del), this.center.sub(del));\n    }\n    /**is it a proper arc? meaning that it just a part of a circle */\n    isArc() {\n        return (Math.abs(this.aAxis.dot(this.bAxis)) < GeomConstants.tolerance &&\n            Math.abs(this.aAxis.length - this.bAxis.length) < GeomConstants.tolerance &&\n            Point.closeDistEps(this.aAxis.rotate90Ccw(), this.bAxis));\n    }\n}\n//# sourceMappingURL=ellipse.js.map","export class GeomConstants {\n}\nGeomConstants.distanceEpsilonPrecision = 6;\nGeomConstants.mult = Math.pow(10, 6);\nGeomConstants.defaultLeafBoxesOffset = 0.5;\nGeomConstants.lineSegmentThreshold = 0.05;\nGeomConstants.intersectionEpsilon = 0.0001;\nGeomConstants.distanceEpsilon = Math.pow(10, -GeomConstants.distanceEpsilonPrecision);\nGeomConstants.squareOfDistanceEpsilon = Math.pow(10, -GeomConstants.distanceEpsilonPrecision * 2);\nGeomConstants.tolerance = 1.0e-8;\n//# sourceMappingURL=geomConstants.js.map","import { Ellipse } from './ellipse';\nimport { Curve } from './curve';\nimport { LineSegment } from './lineSegment';\nimport { BezierSeg } from './bezierSeg';\nimport { Polyline } from './polyline';\nexport function parameterSpan(curve) {\n    return curve.parEnd - curve.parStart;\n}\nexport function JSONToICurve(json) {\n    switch (json.type) {\n        case 'ellipse':\n            return Ellipse.fromJSON(json.data);\n        case 'curve':\n            return Curve.fromJSON(json.data);\n        case 'lineSegment':\n            return LineSegment.fromJSON(json.data);\n        case 'bezier':\n            return BezierSeg.fromJSON(json.data);\n        case 'polyline':\n            return Polyline.fromJSON(json.data);\n    }\n}\nfunction getICurveType(bc) {\n    if (bc instanceof Ellipse) {\n        return 'ellipse';\n    }\n    else if (bc instanceof Curve) {\n        return 'curve';\n    }\n    else if (bc instanceof LineSegment) {\n        return 'lineSegment';\n    }\n    else if (bc instanceof BezierSeg) {\n        return 'bezier';\n    }\n    else if (bc instanceof Polyline) {\n        return 'polyline';\n    }\n    else {\n        throw new Error('not implemented');\n    }\n}\nexport function iCurveToJSON(bc) {\n    return { type: getICurveType(bc), data: bc.toJSON() };\n}\n//# sourceMappingURL=icurve.js.map","export { interpolateICurve, Curve, PointLocation } from './curve';\nexport { CurveFactory } from './curveFactory';\nexport { Point } from './point';\nexport { parameterSpan } from './icurve';\nexport { Rectangle, Size } from './rectangle';\nexport { Polyline } from './polyline';\nexport { CompassVector } from './compassVector';\nexport { Direction } from './direction';\nexport { LineSegment } from './lineSegment';\nexport { GeomConstants } from './geomConstants';\n//# sourceMappingURL=index.js.map","// Contains the result of the intersection of two ICurves.\nexport class IntersectionInfo {\n    // the constructor\n    constructor(pr0, pr1, x, s0, s1) {\n        this.par0 = pr0;\n        this.par1 = pr1;\n        this.x = x;\n        this.seg0 = s0;\n        this.seg1 = s1;\n        /*Assert.assert(\n          Point.close(x, s0.value(pr0), GeomConstants.intersectionEpsilon * 10),\n        )*/\n        //,\n        //  String.Format(\n        //    'intersection not at curve[param]; x = {0}, s0[pr0] = {1}, diff = {2}',\n        //    x,\n        //    s0.value(pr0),\n        //    x.sub(s0.value(pr0)),\n        //  ),\n        // )\n        /*Assert.assert(\n          Point.close(x, s1.value(pr1), GeomConstants.intersectionEpsilon * 10),\n        )*/\n        //,\n        //  String.Format(\n        //    'intersection not at curve[param]; x = {1}, s1[pr1] = {1}, diff = {2}',\n        //    x,\n        //    s1.value(pr1),\n        //    x.sub(s1.value(pr1)),\n        //  ),\n        // )\n    }\n}\n//# sourceMappingURL=intersectionInfo.js.map","import { Point, TriangleOrientation } from './point';\nimport { Parallelogram } from './parallelogram';\nimport { Rectangle } from './rectangle';\nimport { GeomConstants } from './geomConstants';\nexport class LineSegment {\n    static fromJSON(lineData) {\n        return LineSegment.mkPP(Point.fromJSON(lineData.start), Point.fromJSON(lineData.end));\n    }\n    toJSON() {\n        return { start: this.start.toJSON(), end: this.end.toJSON() };\n    }\n    // Offsets the curve in the direction of dir\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    offsetCurve(offset, dir) {\n        return null;\n    }\n    constructor(x, y, x1, y1) {\n        this.parStart = 0;\n        this.parEnd = 1;\n        this.start = new Point(x, y);\n        this.end = new Point(x1, y1);\n    }\n    // Returns the trim curve\n    trim(start, end) {\n        start = Math.max(this.parStart, start);\n        end = Math.min(this.parEnd, end);\n        if (start > end)\n            throw 'wrong params in trimming';\n        const p1 = this.value(start);\n        const p2 = this.value(end);\n        if (Point.close(p1, p2, GeomConstants.distanceEpsilon)) {\n            return null;\n        }\n        return LineSegment.mkPP(p1, p2);\n    }\n    value(t) {\n        return this.start.add(this.end.sub(this.start).mul(t));\n    }\n    // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    trimWithWrap(start, end) {\n        return null;\n    } // not implemented\n    // A tree of ParallelogramNodes covering the curve.\n    // This tree is used in curve intersections routines.\n    // <value></value>\n    pNodeOverICurve() {\n        const side = this.end.sub(this.start).mul(0.5);\n        return {\n            parallelogram: Parallelogram.parallelogramByCornerSideSide(this.start, side, side),\n            seg: this,\n            leafBoxesOffset: 0,\n            node: {\n                low: 0,\n                high: 1,\n                chord: this,\n            },\n        };\n    }\n    normal() {\n        let t = this.start.sub(this.end);\n        t = t.div(t.length);\n        return new Point(-t.y, t.x);\n    }\n    // construct a line segment\n    static mkPP(start, end) {\n        return new LineSegment(start.x, start.y, end.x, end.y);\n    }\n    // constructs a line segment\n    static mkLinePXY(p, x, y) {\n        return new LineSegment(p.x, p.y, x, y);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    derivative(t) {\n        return this.end.sub(this.start);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    secondDerivative(t) {\n        return new Point(0, 0);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    thirdDerivative(t) {\n        return new Point(0, 0);\n    }\n    reverse() {\n        return LineSegment.mkPP(this.end, this.start);\n    }\n    /*\n  static internal IntersectionInfo Cross(LineSeg coeff, LineSeg side1){\n  IntersectionInfo xx=CrossTwoLines(coeff.start, coeff.End-coeff.start,side1.start, side1.End-side1.start);\n  if (xx == null )\n  {\n  //parallel segs\n  Point adir=coeff.d1(0);\n  Point bdir=side1.d1(0);\n  \n  if (adir.length > bdir.length)\n  {\n  if (adir.length > Curve.DistEps)\n  {\n  adir = adir.normalize();\n  if(Math.Abs((coeff-side1)*adir<Curve.DistEps)){\n  \n  }\n  }\n  }\n  return null;\n  }\n  \n  if(xx.Par0>1){\n  if (Point.closeDistEps(coeff.End, xx.x))\n  {\n  xx.x = coeff.End;\n  xx.Par0 = 1;\n  }\n  else\n  return null;\n  }\n  else if(xx.Par0<0){\n  if(Point.closeDistEps(coeff.start,xx.x)){\n  xx.x=coeff.start;\n  xx.Par0=1;\n  }\n  else\n  return null;\n  }\n  \n  if (xx.Par1 > 1)\n  {\n  if (Point.closeDistEps(side1.End, xx.x))\n  {\n  xx.x = coeff.End;\n  xx.Par1 = 1;\n  }\n  else\n  return null;\n  }\n  else if (xx.Par1 < 0)\n  {\n  if (Point.closeDistEps(side1.start, xx.x))\n  {\n  xx.x = coeff.start;\n  xx.Par1 = 1;\n  }\n  else\n  return null;\n  }\n  \n  return xx;\n  }\n  * */\n    // mutable! changes this\n    // Returns the curved moved by delta\n    translate(delta) {\n        this.start = this.start.add(delta);\n        this.end = this.end.add(delta);\n    }\n    // Scale (multiply) from origin by x and y\n    scaleFromOrigin(xScale, yScale) {\n        return LineSegment.mkPP(this.start.scale(xScale, yScale), this.end.scale(xScale, yScale));\n    }\n    // gets the parameter at a specific length from the start along the curve\n    getParameterAtLength(length) {\n        const len = this.end.sub(this.start).length;\n        if (len < GeomConstants.tolerance)\n            return 0;\n        const t = length / len;\n        return t > 1 ? 1 : t < 0 ? 0 : t;\n    }\n    // Return the transformed curve\n    transform(transformation) {\n        return LineSegment.mkPP(transformation.multiplyPoint(this.start), transformation.multiplyPoint(this.end));\n    }\n    // returns a parameter t such that the distance between curve[t] and targetPoint is minimal\n    // and t belongs to the closed segment [low,high]\n    closestParameterWithinBounds(targetPoint, low, high) {\n        let t = this.closestParameter(targetPoint);\n        if (t < low)\n            t = low;\n        if (t > high)\n            t = high;\n        return t;\n    }\n    // return length of the curve segment [start,end]\n    lengthPartial(start, end) {\n        return this.value(end).sub(this.value(start)).length;\n    }\n    // Get the length of the curve\n    get length() {\n        return this.start.sub(this.end).length;\n    }\n    // The bounding box of the line\n    get boundingBox() {\n        return Rectangle.mkPP(this.start, this.end);\n    }\n    // clones the curve.\n    clone() {\n        return LineSegment.mkPP(this.start.clone(), this.end.clone());\n    }\n    static closestParameterOnLineSegment(point, segmentStart, segmentEnd) {\n        const bc = segmentEnd.sub(segmentStart);\n        const ba = point.sub(segmentStart);\n        const c1 = bc.dot(ba);\n        if (c1 <= 0.0 + GeomConstants.tolerance)\n            return 0;\n        const c2 = bc.dot(bc);\n        if (c2 <= c1 + GeomConstants.tolerance)\n            return 1;\n        return c1 / c2;\n    }\n    // returns a parameter t such that the distance between curve[t] and a is minimal\n    closestParameter(targetPoint) {\n        return LineSegment.closestParameterOnLineSegment(targetPoint, this.start, this.end);\n    }\n    // left derivative at t\n    leftDerivative(t) {\n        return this.derivative(t);\n    }\n    // right derivative at t\n    rightDerivative(t) {\n        return this.derivative(t);\n    }\n    // returns true if segments are not parallel and are intesecting\n    static IntersectPPPP(a, b, c, d) {\n        const r = Point.lineLineIntersection(a, b, c, d);\n        if (r == null)\n            return;\n        if (pointIsOnSegment(r, a, b) && pointIsOnSegment(r, c, d)) {\n            return r;\n        }\n        else {\n            return undefined;\n        }\n    }\n    //\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    curvature(t) {\n        return 0;\n    }\n    //\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    curvatureDerivative(t) {\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    curvatureSecondDerivative(_) {\n        return 0;\n    }\n    // [a,b] and [c,d] are the segments. u and v are the corresponding closest point params\n    // see http://www.geometrictools.com/Documentation/DistanceLine3Line3.pdf\n    static minDistBetweenLineSegments(a, b, c, d) {\n        const u = b.sub(a);\n        const v = d.sub(c);\n        const w = a.sub(c);\n        const D = Point.crossProduct(u, v);\n        const uu = u.dot(u); // always >= 0\n        const uv = u.dot(v);\n        const vv = v.dot(v); // always >= 0\n        const uw = u.dot(w);\n        const vw = v.dot(w);\n        let sN, tN;\n        const absD = Math.abs(D);\n        let sD = absD, tD = absD;\n        // compute the line parameters of the two closest points\n        if (absD < GeomConstants.tolerance) {\n            // the lines are almost parallel\n            sN = 0.0; // force using point a on segment [a..b]\n            sD = 1.0; // to prevent possible division by 0.0 later\n            tN = vw;\n            tD = vv;\n        }\n        else {\n            // get the closest points on the infinite lines\n            sN = Point.crossProduct(v, w);\n            tN = Point.crossProduct(u, w);\n            if (D < 0) {\n                sN = -sN;\n                tN = -tN;\n            }\n            if (sN < 0.0) {\n                // parab < 0 => the s=0 edge is visible\n                sN = 0.0;\n                tN = vw;\n                tD = vv;\n            }\n            else if (sN > sD) {\n                // parab > 1 => the s=1 edge is visible\n                sN = sD = 1;\n                tN = vw + uv;\n                tD = vv;\n            }\n        }\n        if (tN < 0.0) {\n            // tc < 0 => the t=0 edge is visible\n            tN = 0.0;\n            // recompute parab for this edge\n            if (-uw < 0.0)\n                sN = 0.0;\n            else if (-uw > uu)\n                sN = sD;\n            else {\n                sN = -uw;\n                sD = uu;\n            }\n        }\n        else if (tN > tD) {\n            // tc > 1 => the t=1 edge is visible\n            tN = tD = 1;\n            // recompute parab for this edge\n            if (-uw + uv < 0.0)\n                sN = 0;\n            else if (-uw + uv > uu)\n                sN = sD;\n            else {\n                sN = -uw + uv;\n                sD = uu;\n            }\n        }\n        const parab_ = Math.abs(sN) < GeomConstants.tolerance ? 0.0 : sN / sD;\n        const parcd_ = Math.abs(tN) < GeomConstants.tolerance ? 0.0 : tN / tD;\n        // finally do the division to get parameters\n        return {\n            parab: parab_,\n            parcd: parcd_,\n            // get the difference of the two closest points\n            //           const dP = w + (parab * u) - (parcd * v),\n            dist: w.add(u.mul(parab_).sub(v.mul(parcd_))).length, // return the closest distance\n        };\n    }\n}\n/** a - is the point to test\n * [c,b] - is the segment\n * The function actually checks that a is inside of the bounding box of [c,b].\n * ! Use it only when a,b,c are collinear !\n */\nexport function pointIsOnSegment(a, b, c) {\n    return (a.x >= Math.min(b.x, c.x) - GeomConstants.distanceEpsilon &&\n        a.y >= Math.min(b.y, c.y) - GeomConstants.distanceEpsilon &&\n        a.x <= Math.max(b.x, c.x) + GeomConstants.distanceEpsilon &&\n        a.y <= Math.max(b.y, c.y) + GeomConstants.distanceEpsilon);\n}\n/** returns true if segments intersect */\nexport function segmentsIntersect(a, b, c, d) {\n    const abc = Point.getTriangleOrientation(a, b, c);\n    const abd = Point.getTriangleOrientation(a, b, d);\n    const cda = Point.getTriangleOrientation(c, d, a);\n    const cdb = Point.getTriangleOrientation(c, d, b);\n    // if abc != abd then ab separates c and d\n    // if cda != cdb then cd separates b and a\n    if (abc != abd && cda != cdb)\n        return true;\n    // If the orientations are collinear and the points lie on the segments,\n    // the segments intersect\n    if (abc == TriangleOrientation.Collinear && pointIsOnSegment(c, a, b))\n        return true;\n    if (abd == TriangleOrientation.Collinear && pointIsOnSegment(d, a, b))\n        return true;\n    if (cda == TriangleOrientation.Collinear && pointIsOnSegment(a, c, d))\n        return true;\n    if (cdb == TriangleOrientation.Collinear && pointIsOnSegment(b, c, d))\n        return true;\n    // Otherwise, the segments do not intersect\n    return false;\n}\n//# sourceMappingURL=lineSegment.js.map","// solves a linear system of two equations with two unknown variables\nexport class LinearSystem2 {\n    static solve(a00, a01, b0, a10, a11, b1) {\n        const d = a00 * a11 - a10 * a01;\n        if (Math.abs(d) < LinearSystem2.eps) {\n            return;\n        }\n        return {\n            x: (b0 * a11 - b1 * a01) / d,\n            y: (a00 * b1 - a10 * b0) / d,\n        };\n    }\n}\nLinearSystem2.eps = 1.0e-8;\n//# sourceMappingURL=linearSystem.js.map","import { LineSegment } from './lineSegment';\nimport { GeomConstants } from './geomConstants';\n// For curves A(s) and B(t), when we have some evidence that\n// there is at most one intersection point, and we have a guess for the parameters (s0, t0),\n// we try to bring to (0,0) vector F(s,t) = A(s) - B(t).  To minimize the length of F(s,t)\n// we solve the system of equations:\n// F*Fs + (F*Fss + Fs*Fs)ds + (F*Fst + Fs*Ft)dt = 0\n// F*Ft + (F*Fst + Fs*Ft)ds + (F*Ftt + Ft*Ft)dt = 0\n//\n// Where F = F(si,ti), Fs and Ft are the first partials at si, ti, Fxx are the second partials,\n// and s(i+1) = si+ds, t(i+1) = ti+dt.\n// We adjust ds and dt to stay in the domain.\nexport class MinDistCurveCurve {\n    initValues() {\n        this.a = this.curveA.value(this.si);\n        this.b = this.curveB.value(this.ti);\n        this.a_b = this.a.sub(this.b);\n        this.ad = this.curveA.derivative(this.si);\n        this.add = this.curveA.secondDerivative(this.si);\n        this.bd = this.curveB.derivative(this.ti);\n        this.bdd = this.curveB.secondDerivative(this.ti);\n    }\n    // curveAPar\">first curve</param>\n    // curveBPar\">second curve</param>\n    // lowBound0\">the first curve minimal parameter</param>\n    // upperBound0\">the first curve maximal parameter</param>\n    // lowBound1\">the second curve minimal parameter</param>\n    // upperBound1\">the first curve maximal parameter</param>\n    // guess0\"></param>\n    // guess1\"></param>\n    constructor(curveA, curveB, aMin, aMax, bMin, mBax, aGuess, bGuess) {\n        this.curveA = curveA;\n        this.curveB = curveB;\n        this.aMin = aMin;\n        this.bMin = bMin;\n        this.aMax = aMax;\n        this.bMax = mBax;\n        this.aGuess = aGuess;\n        this.bGuess = bGuess;\n        this.si = aGuess;\n        this.ti = bGuess;\n    }\n    //we ignore the mulitplier 2 here fore efficiency reasons\n    Fs() {\n        return /*2**/ this.a_b.dot(this.ad);\n    }\n    Fss() {\n        return /*2**/ this.a_b.dot(this.add) + this.ad.dot(this.ad);\n    }\n    Fst() {\n        //equals to Fts\n        return -( /*2**/this.bd.dot(this.ad));\n    }\n    Ftt() {\n        return /*2**/ -this.a_b.dot(this.bdd) + this.bd.dot(this.bd);\n    }\n    Ft() {\n        return -( /*2**/this.a_b.dot(this.bd));\n    }\n    // xy - the first row\n    // uw - the second row\n    delta(x, y, u, w) {\n        return x * w - u * y;\n    }\n    //Fs + Fss*ds + Fst*dt = 0\n    //Ft + Fst*ds + Ftt*dt = 0\n    solve() {\n        let numberOfBoundaryCrossings = 0;\n        const maxNumberOfBoundaryCrossings = 10;\n        let numberOfTotalReps = 0;\n        const maxNumberOfTotalReps = 100;\n        let abort = false;\n        this.initValues();\n        if (this.curveA instanceof LineSegment && this.curveB instanceof LineSegment) {\n            let bd1 = this.curveB.derivative(0);\n            bd1 = bd1.div(bd1.length);\n            const an = this.curveA.normal();\n            const del = Math.abs(an.dot(bd1));\n            if (Math.abs(del) < GeomConstants.distanceEpsilon ||\n                this.delta(this.Fss(), this.Fst(), this.Fst(), this.Ftt()) < GeomConstants.tolerance) {\n                this.success = true;\n                this.parallelLineSegLineSegMinDist();\n                return;\n            }\n        }\n        let d;\n        do {\n            const delta = this.delta(this.Fss(), this.Fst(), this.Fst(), this.Ftt());\n            if (Math.abs(delta) < GeomConstants.tolerance) {\n                this.success = false;\n                abort = true;\n                break;\n            }\n            d = {\n                s: this.delta(-this.Fs(), this.Fst(), -this.Ft(), this.Ftt()) / delta,\n                t: this.delta(this.Fss(), -this.Fs(), this.Fst(), -this.Ft()) / delta,\n            };\n            const nsi = this.si + d.s;\n            const nti = this.ti + d.t;\n            let bc;\n            if (nsi > this.aMax + GeomConstants.distanceEpsilon ||\n                nsi < this.aMin - GeomConstants.distanceEpsilon ||\n                nti > this.bMax + GeomConstants.distanceEpsilon ||\n                nti < this.bMin - GeomConstants.distanceEpsilon) {\n                numberOfBoundaryCrossings++;\n                this.chopDsDt(d);\n                this.si += d.s;\n                this.ti += d.t;\n                bc = true;\n            }\n            else {\n                bc = false;\n                this.si = nsi;\n                this.ti = nti;\n                if (this.si > this.aMax)\n                    this.si = this.aMax;\n                else if (this.si < this.aMin)\n                    this.si = this.aMin;\n                if (this.ti > this.bMax)\n                    this.ti = this.bMax;\n                else if (this.ti < this.bMin)\n                    this.ti = this.bMin;\n            }\n            this.initValues();\n            numberOfTotalReps++;\n            abort =\n                numberOfBoundaryCrossings >= maxNumberOfBoundaryCrossings ||\n                    numberOfTotalReps >= maxNumberOfTotalReps ||\n                    (d.s === 0 && d.t === 0 && bc);\n        } while ((Math.abs(d.s) >= GeomConstants.tolerance || Math.abs(d.t) >= GeomConstants.tolerance) && !abort);\n        if (abort) {\n            //may be the initial values were just OK\n            const t = this.curveA.value(this.aGuess).sub(this.curveB.value(this.bGuess));\n            if (t.dot(t) < GeomConstants.distanceEpsilon * GeomConstants.distanceEpsilon) {\n                this.aSolution = this.aGuess;\n                this.bSolution = this.bGuess;\n                this.aPoint = this.curveA.value(this.aGuess);\n                this.bPoint = this.curveB.value(this.bGuess);\n                this.success = true;\n                return;\n            }\n        }\n        this.aSolution = this.si;\n        this.bSolution = this.ti;\n        this.aPoint = this.a;\n        this.bPoint = this.b;\n        this.success = !abort;\n    }\n    // d is is {s:number; d:number}\n    chopDsDt(d) {\n        if (d.s !== 0 && d.t !== 0) {\n            let k1 = 1; //we are looking for a chopped vector of the form k(ds, dt)\n            if (this.si + d.s > this.aMax)\n                //we have si+k*ds=aMax\n                k1 = (this.aMax - this.si) / d.s;\n            else if (this.si + d.s < this.aMin)\n                k1 = (this.aMin - this.si) / d.s;\n            let k2 = 1;\n            if (this.ti + d.t > this.bMax)\n                //we need to have ti+k*d.t=bMax  or ti+k*d.t=bMin\n                k2 = (this.bMax - this.ti) / d.t;\n            else if (this.ti + d.t < this.bMin)\n                k2 = (this.bMin - this.ti) / d.t;\n            const k = Math.min(k1, k2);\n            d.s *= k;\n            d.t *= k;\n        }\n        else if (d.s === 0) {\n            if (this.ti + d.t > this.bMax)\n                d.t = this.bMax - this.ti;\n            else if (this.ti + d.t < this.bMin)\n                d.t = this.bMin - this.ti;\n        }\n        else {\n            //d.t==0)\n            if (this.si + d.s > this.aMax)\n                d.s = this.aMax - this.si;\n            else if (this.si + d.s < this.aMin)\n                d.s = this.aMin - this.si;\n        }\n    }\n    parallelLineSegLineSegMinDist() {\n        const l0 = this.curveA;\n        const l1 = this.curveB;\n        const v0 = l0.start;\n        const v1 = l0.end;\n        const v2 = l1.start;\n        const v3 = l1.end;\n        let d0 = v1.sub(v0);\n        const nd0 = d0.length;\n        let r0 = 0;\n        let r1, r2, r3;\n        if (nd0 > GeomConstants.distanceEpsilon) {\n            //v0 becomes the zero point\n            d0 = d0.div(nd0);\n            r1 = d0.dot(v1.sub(v0));\n            r2 = d0.dot(v2.sub(v0));\n            r3 = d0.dot(v3.sub(v0));\n            let swapped = false;\n            if (r2 > r3) {\n                swapped = true;\n                const t = r2;\n                r2 = r3;\n                r3 = t;\n            }\n            if (r3 < r0) {\n                this.aSolution = 0;\n                this.bSolution = swapped ? 0 : 1;\n            }\n            else if (r2 > r1) {\n                this.aSolution = 1;\n                this.bSolution = swapped ? 1 : 0;\n            }\n            else {\n                const r = Math.min(r1, r3);\n                this.aSolution = r / (r1 - r0);\n                this.bSolution = (r - r2) / (r3 - r2);\n                if (swapped)\n                    this.bSolution = 1 - this.bSolution;\n            }\n        }\n        else {\n            let d1 = v3.sub(v2);\n            const nd1 = d1.length;\n            if (nd1 > GeomConstants.distanceEpsilon) {\n                //v2 becomes the zero point\n                d1 = d1.div(nd1);\n                r0 = 0; //v2 position\n                r1 = d1.dot(v3.sub(v2)); //v3 position\n                r2 = d1.dot(v0.sub(v2)); //v0 position - here v0 and v1 are indistinguishable\n                if (r2 < r0) {\n                    this.bSolution = 0;\n                    this.aSolution = 1;\n                }\n                else if (r2 > r1) {\n                    this.bSolution = 1;\n                    this.aSolution = 0;\n                }\n                else {\n                    const r = Math.min(r1, r2);\n                    this.bSolution = r / (r1 - r0);\n                    this.aSolution = 0;\n                }\n            }\n            else {\n                this.aSolution = 0;\n                this.bSolution = 0;\n            }\n        }\n        this.aPoint = this.curveA.value(this.aSolution);\n        this.bPoint = this.curveB.value(this.bSolution);\n    }\n}\n//# sourceMappingURL=minDistCurveCurve.js.map","import { Point } from './point';\nimport { GeomConstants } from './geomConstants';\nexport var VertexId;\n(function (VertexId) {\n    VertexId[VertexId[\"Corner\"] = 0] = \"Corner\";\n    VertexId[VertexId[\"VertexA\"] = 1] = \"VertexA\";\n    VertexId[VertexId[\"otherCorner\"] = 2] = \"otherCorner\";\n    VertexId[VertexId[\"VertexB\"] = 3] = \"VertexB\";\n})(VertexId || (VertexId = {}));\nexport class Parallelogram {\n    // Return true if the parallelogram contains the point\n    contains(point) {\n        const g = point.sub(this.corner);\n        const e = GeomConstants.distanceEpsilon;\n        const gbRot = g.dot(this.bRot);\n        if (gbRot > this.abRot + e || gbRot < -e)\n            return false;\n        const gaRot = g.dot(this.aRot);\n        return gaRot <= this.baRot + e && gaRot >= -e;\n    }\n    get area() {\n        return Math.abs(this.a.x * this.b.y - this.a.y * this.b.x);\n    }\n    vertex(vertexPar) {\n        switch (vertexPar) {\n            case VertexId.Corner:\n                return this.corner;\n            case VertexId.VertexA:\n                return this.aPlusCorner;\n            case VertexId.otherCorner:\n                return this.otherCorner;\n            case VertexId.VertexB:\n                return this.bPlusCorner;\n            default:\n                return undefined;\n        }\n    }\n    static parallelogramOfTwo(box0, box1) {\n        const result = new Parallelogram();\n        const v = box0.corner;\n        const mm = {\n            minx: v.x,\n            maxx: v.x,\n            miny: v.y,\n            maxy: v.y,\n        };\n        Parallelogram.pumpMinMax(mm, box0.aPlusCorner);\n        Parallelogram.pumpMinMax(mm, box0.otherCorner);\n        Parallelogram.pumpMinMax(mm, box0.bPlusCorner);\n        Parallelogram.pumpMinMax(mm, box1.corner);\n        Parallelogram.pumpMinMax(mm, box1.aPlusCorner);\n        Parallelogram.pumpMinMax(mm, box1.otherCorner);\n        Parallelogram.pumpMinMax(mm, box1.bPlusCorner);\n        result.corner = new Point(mm.minx, mm.miny);\n        result.a = new Point(0, mm.maxy - mm.miny);\n        result.b = new Point(mm.maxx - mm.minx, 0);\n        result.aPlusCorner = result.a.add(result.corner);\n        result.otherCorner = result.b.add(result.aPlusCorner);\n        result.bPlusCorner = result.b.add(result.corner);\n        result.aRot = new Point(-result.a.y, result.a.x);\n        if (result.aRot.length > 0.5)\n            result.aRot = result.aRot.normalize();\n        result.bRot = new Point(-result.b.y, result.b.x);\n        if (result.bRot.length > 0.5)\n            result.bRot = result.bRot.normalize();\n        result.abRot = result.a.dot(result.bRot);\n        result.baRot = result.b.dot(result.aRot);\n        if (result.abRot < 0) {\n            result.abRot = -result.abRot;\n            result.bRot = result.bRot.neg();\n        }\n        if (result.baRot < 0) {\n            result.baRot = -result.baRot;\n            result.aRot = result.aRot.neg();\n        }\n        result.isSeg = result.a.sub(result.b).length < GeomConstants.distanceEpsilon;\n        return result;\n    }\n    static pumpMinMax(mm, p) {\n        if (p.x < mm.minx) {\n            mm.minx = p.x;\n        }\n        else if (p.x > mm.maxx) {\n            mm.maxx = p.x;\n        }\n        if (p.y < mm.miny) {\n            mm.miny = p.y;\n        }\n        else if (p.y > mm.maxy) {\n            mm.maxy = p.y;\n        }\n    }\n    // returns true if parallelograms intersect\n    static intersect(parallelogram0, parallelogram1) {\n        // It can be shown that two parallelograms do not intersect if and only if\n        // they are separated with one of the parallelogram sides\n        const ret = !(Parallelogram.separByA(parallelogram0, parallelogram1) ||\n            Parallelogram.separByA(parallelogram1, parallelogram0) ||\n            Parallelogram.separByB(parallelogram0, parallelogram1) ||\n            Parallelogram.separByB(parallelogram1, parallelogram0));\n        if (ret === false)\n            return false;\n        if (!(parallelogram0.isSeg && parallelogram1.isSeg))\n            return true;\n        if (!Point.parallelWithinEpsilon(parallelogram0.otherCorner.sub(parallelogram0.corner), parallelogram1.otherCorner.sub(parallelogram1.corner), 1.0e-5))\n            return true;\n        //here we know that the segs are parallel\n        return Parallelogram.ParallelSegsIntersect(parallelogram1, parallelogram0);\n    }\n    static ParallelSegsIntersect(p0, p1) {\n        const v0 = p0.corner;\n        const v1 = p0.otherCorner;\n        const v2 = p1.corner;\n        const v3 = p1.otherCorner;\n        const d = v1.sub(v0);\n        //const us imagine that v0 is at zero\n        const r0 = 0; // position of v0\n        const r1 = d.dot(d); //offset of v1\n        //offset of v2\n        let r2 = v2.sub(v0).dot(d);\n        //offset of v3\n        let r3 = v3.sub(v0).dot(d);\n        // we need to check if [r0,r1] intersects [r2,r3]\n        if (r2 > r3) {\n            const t = r2;\n            r2 = r3;\n            r3 = t;\n        }\n        return !(r3 < r0 - GeomConstants.distanceEpsilon || r2 > r1 + GeomConstants.distanceEpsilon);\n    }\n    static separByB(p0, p1) {\n        const eps = GeomConstants.distanceEpsilon;\n        const p1a = p1.vertex(0).sub(p0.corner).dot(p0.bRot);\n        const list = [VertexId.VertexA, VertexId.otherCorner, VertexId.VertexB];\n        if (p1a > p0.abRot + eps) {\n            for (const i of list) {\n                if (p1.vertex(i).sub(p0.corner).dot(p0.bRot) <= p0.abRot + eps)\n                    return false;\n            }\n            return true;\n        }\n        else if (p1a < -eps) {\n            for (const i of list) {\n                if (p1.vertex(i).sub(p0.corner).dot(p0.bRot) >= -eps)\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    static separByA(p0, p1) {\n        const eps = GeomConstants.distanceEpsilon;\n        let t = p1.corner.sub(p0.corner);\n        const p1a = Point.dot(t, p0.aRot);\n        if (p1a > p0.baRot + eps) {\n            t = p1.aPlusCorner.sub(p0.corner);\n            if (Point.dot(t, p0.aRot) <= p0.baRot + eps)\n                return false;\n            t = p1.bPlusCorner.sub(p0.corner);\n            if (Point.dot(t, p0.aRot) <= p0.baRot + eps)\n                return false;\n            t = p1.otherCorner.sub(p0.corner);\n            if (Point.dot(t, p0.aRot) <= p0.baRot + eps)\n                return false;\n            return true;\n        }\n        else if (p1a < -eps) {\n            t = p1.aPlusCorner.sub(p0.corner);\n            if (Point.dot(t, p0.aRot) >= -eps)\n                return false;\n            t = p1.bPlusCorner.sub(p0.corner);\n            if (Point.dot(t, p0.aRot) >= -eps)\n                return false;\n            t = p1.otherCorner.sub(p0.corner);\n            if (Point.dot(t, p0.aRot) >= -eps)\n                return false;\n            return true;\n        }\n        return false;\n    }\n    static parallelogramByCornerSideSide(corner, sideA, sideB) {\n        const result = new Parallelogram();\n        result.corner = corner;\n        result.a = sideA;\n        result.b = sideB;\n        result.aRot = new Point(-sideA.y, sideA.x);\n        if (result.aRot.length > 0.5)\n            result.aRot = result.aRot.normalize();\n        result.bRot = new Point(-sideB.y, sideB.x);\n        if (result.bRot.length > 0.5)\n            result.bRot = result.bRot.normalize();\n        result.abRot = result.bRot.dot(sideA);\n        result.baRot = sideB.dot(result.aRot);\n        if (result.abRot < 0) {\n            result.abRot = -result.abRot;\n            result.bRot = result.bRot.neg();\n        }\n        if (result.baRot < 0) {\n            result.baRot = -result.baRot;\n            result.aRot = result.aRot.neg();\n        }\n        result.isSeg = sideA.sub(sideB).length < GeomConstants.distanceEpsilon;\n        result.aPlusCorner = sideA.add(corner);\n        result.otherCorner = sideB.add(result.aPlusCorner);\n        result.bPlusCorner = sideB.add(corner);\n        return result;\n    }\n    static getParallelogramOfAGroup(boxes) {\n        let minx = 0, maxx = 0, miny = 0, maxy = 0;\n        let firstTime = true;\n        for (const b of boxes) {\n            const verts = allVerticesOfParall(b);\n            for (const v of verts) {\n                const x = v.x;\n                const y = v.y;\n                if (firstTime) {\n                    firstTime = false;\n                    minx = maxx = x;\n                    miny = maxy = y;\n                }\n                else {\n                    if (x < minx) {\n                        minx = x;\n                    }\n                    else if (x > maxx) {\n                        maxx = x;\n                    }\n                    if (y < miny) {\n                        miny = y;\n                    }\n                    else if (y > maxy) {\n                        maxy = y;\n                    }\n                }\n            }\n        }\n        return Parallelogram.parallelogramByCornerSideSide(new Point(minx, miny), new Point(0, maxy - miny), new Point(maxx - minx, 0));\n    }\n}\nexport function* allVerticesOfParall(p) {\n    yield p.corner;\n    yield p.aPlusCorner;\n    yield p.otherCorner;\n    yield p.bPlusCorner;\n}\n//# sourceMappingURL=parallelogram.js.map","import { Point } from './point';\nimport { LineSegment } from './lineSegment';\nimport { Parallelogram } from './parallelogram';\nimport { GeomConstants } from './geomConstants';\nexport function createPNLeaf(start, end, box, seg, eps) {\n    return {\n        parallelogram: box,\n        seg: seg,\n        leafBoxesOffset: eps,\n        node: {\n            low: start,\n            high: end,\n            chord: null, // create a cord only the segment and the chord are within intersectionEpsilon\n        },\n    };\n}\nexport class ParallelogramNode {\n    static distToSegm(p, s, e) {\n        const l = e.sub(s);\n        if (l.length < GeomConstants.intersectionEpsilon)\n            return p.sub(s.add(e).div(2)).length;\n        let perp = new Point(-l.y, l.x);\n        perp = perp.mul(1 / perp.length);\n        return Math.abs(p.sub(s).dot(perp));\n    }\n    static createParallelogramOnSubSeg(start, end, seg) {\n        let tan1 = seg.derivative(start);\n        const tan2 = seg.derivative(end);\n        const tan2Perp = new Point(-tan2.y, tan2.x);\n        const corner = seg.value(start);\n        const e = seg.value(end);\n        const p = e.sub(corner);\n        const numerator = p.dot(tan2Perp);\n        const denumerator = tan1.dot(tan2Perp);\n        //x  = (p * tan2Perp) / (tan1 * tan2Perp);\n        // x*tan1 will be a side of the parallelogram\n        const numeratorTiny = Math.abs(numerator) < GeomConstants.distanceEpsilon;\n        if (!numeratorTiny && Math.abs(denumerator) < GeomConstants.distanceEpsilon) {\n            //it is degenerated; the adjacent sides would be parallel, but\n            //since p * tan2Perp is big the parallelogram would not contain e\n            return;\n        }\n        const x = numeratorTiny ? 0 : numerator / denumerator;\n        tan1 = tan1.mul(x);\n        return Parallelogram.parallelogramByCornerSideSide(corner, tan1, e.sub(corner).sub(tan1));\n    }\n    static createParallelogramNodeForCurveSeg(start, end, seg, eps) {\n        const closedSeg = start === seg.parStart && end === seg.parEnd && Point.close(seg.start, seg.end, GeomConstants.distanceEpsilon);\n        if (closedSeg)\n            return ParallelogramNode.createNodeWithSegmentSplit(start, end, seg, eps);\n        const s = seg.value(start);\n        const e = seg.value(end);\n        const w = e.sub(s);\n        const middle = seg.value((start + end) / 2);\n        if (ParallelogramNode.distToSegm(middle, s, e) <= GeomConstants.intersectionEpsilon &&\n            w.dot(w) < GeomConstants.lineSegmentThreshold * GeomConstants.lineSegmentThreshold &&\n            end - start < GeomConstants.lineSegmentThreshold) {\n            const ls = LineSegment.mkPP(s, e);\n            const pn = ls.pNodeOverICurve();\n            pn.seg = seg;\n            const leaf = pn.node;\n            leaf.low = start;\n            leaf.high = end;\n            leaf.chord = ls;\n            return pn;\n        }\n        if (ParallelogramNode.WithinEpsilon(seg, start, end, eps)) {\n            const box = ParallelogramNode.createParallelogramOnSubSeg(start, end, seg);\n            if (box !== undefined)\n                return createPNLeaf(start, end, box, seg, eps);\n        }\n        return ParallelogramNode.createNodeWithSegmentSplit(start, end, seg, eps);\n    }\n    static WithinEpsilon(seg, start, end, eps) {\n        const n = 3; //hack !!!! but maybe can be proven for Bezier curves and other regular curves\n        const d = (end - start) / n;\n        const s = seg.value(start);\n        const e = seg.value(end);\n        const d0 = ParallelogramNode.distToSegm(seg.value(start + d), s, e);\n        if (d0 > eps)\n            return false;\n        const d1 = ParallelogramNode.distToSegm(seg.value(start + d * (n - 1)), s, e);\n        return d1 <= eps;\n    }\n    static createParallelogramNodeForCurveSegDefaultOffset(seg) {\n        return ParallelogramNode.createParallelogramNodeForCurveSeg(seg.parStart, seg.parEnd, seg, GeomConstants.defaultLeafBoxesOffset);\n    }\n    static createNodeWithSegmentSplit(start, end, ell, eps) {\n        const pBNode = {\n            parallelogram: null,\n            seg: ell,\n            leafBoxesOffset: 1,\n            node: { children: [] },\n        };\n        const intNode = pBNode.node;\n        intNode.children.push(ParallelogramNode.createParallelogramNodeForCurveSeg(start, 0.5 * (start + end), ell, eps));\n        intNode.children.push(ParallelogramNode.createParallelogramNodeForCurveSeg(0.5 * (start + end), end, ell, eps));\n        pBNode.parallelogram = Parallelogram.parallelogramOfTwo(intNode.children[0].parallelogram, intNode.children[1].parallelogram);\n        return pBNode;\n    }\n}\n//# sourceMappingURL=parallelogramNode.js.map","import { closeDistEps } from '../../utils/compare';\nimport { Point } from './point';\n// 2 by 3 matrix of plane affine transformations\nexport class PlaneTransformation {\n    // the matrix elements\n    get Elements() {\n        return this.elements;\n    }\n    // i,j th element\n    getElem(i, j) {\n        return this.elements[i][j];\n    }\n    setElem(i, j, v) {\n        this.elements[i][j] = v;\n    }\n    // Divid matrix by a matrix\n    static Divide(m0, m1) {\n        return m0.multiply(m1.inverse());\n    }\n    isIdentity() {\n        return (closeDistEps(this.elements[0][0], 1) &&\n            closeDistEps(this.elements[0][1], 0) &&\n            closeDistEps(this.elements[0][2], 0) &&\n            closeDistEps(this.elements[1][0], 0) &&\n            closeDistEps(this.elements[1][1], 1) &&\n            closeDistEps(this.elements[1][2], 0));\n    }\n    // returns the point of the matrix offset\n    offset() {\n        return new Point(this.getElem(0, 2), this.getElem(1, 2));\n    }\n    static getIdentity() {\n        return new PlaneTransformation(1, 0, 0, 0, 1, 0);\n    }\n    constructor(m00, m01, m02, m10, m11, m12) {\n        this.elements = [\n            [m00, m01, m02],\n            [m10, m11, m12],\n        ];\n    }\n    // Rotation matrix - rotates counterclockwise by 'angle'\n    static rotation(angle) {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        return new PlaneTransformation(cos, -sin, 0, sin, cos, 0);\n    }\n    static scaleAroundCenterTransformation(xScale, yScale, center) {\n        /*var toOrigin = new PlaneTransformation(1, 0, -center.x, 0, 1, -center.y);\n      var scaconstr = new PlaneTransformation(scale, 0, 0,\n      0, scale, 0);\n      var toCenter = new PlaneTransformation(1, 0, center.x, 0, 1, center.y);\n      var t = toCenter*scaconstr*toOrigin;\n      return t;*/\n        const dX = 1 - xScale;\n        const dY = 1 - yScale;\n        return new PlaneTransformation(xScale, 0, dX * center.x, 0, yScale, dY * center.y);\n    }\n    // Point by matrix multiplication\n    multiplyPoint(p) {\n        return new Point(this.getElem(0, 0) * p.x + this.getElem(0, 1) * p.y + this.getElem(0, 2), this.getElem(1, 0) * p.x + this.getElem(1, 1) * p.y + this.getElem(1, 2));\n    }\n    // matrix matrix multiplication\n    multiply(b) {\n        if (b != null)\n            return new PlaneTransformation(this.getElem(0, 0) * b.getElem(0, 0) + this.getElem(0, 1) * b.getElem(1, 0), this.getElem(0, 0) * b.getElem(0, 1) + this.getElem(0, 1) * b.getElem(1, 1), this.getElem(0, 0) * b.getElem(0, 2) + this.getElem(0, 1) * b.getElem(1, 2) + this.getElem(0, 2), this.getElem(1, 0) * b.getElem(0, 0) + this.getElem(1, 1) * b.getElem(1, 0), this.getElem(1, 0) * b.getElem(0, 1) + this.getElem(1, 1) * b.getElem(1, 1), this.getElem(1, 0) * b.getElem(0, 2) + this.getElem(1, 1) * b.getElem(1, 2) + this.getElem(1, 2));\n        return null;\n    }\n    // returns the inversed matrix\n    inverse() {\n        const det = this.getElem(0, 0) * this.getElem(1, 1) - this.getElem(1, 0) * this.getElem(0, 1);\n        const a00 = this.getElem(1, 1) / det;\n        const a01 = -this.getElem(0, 1) / det;\n        const a10 = -this.getElem(1, 0) / det;\n        const a11 = this.getElem(0, 0) / det;\n        const a02 = -a00 * this.getElem(0, 2) - a01 * this.getElem(1, 2);\n        const a12 = -a10 * this.getElem(0, 2) - a11 * this.getElem(1, 2);\n        return new PlaneTransformation(a00, a01, a02, a10, a11, a12);\n    }\n}\n//# sourceMappingURL=planeTransformation.js.map","import { LinearSystem2 } from './linearSystem';\nimport { GeomConstants } from './geomConstants';\nimport { compareNumbers } from '../../utils/compare';\n//import {Assert} from '../../utils/assert'\nexport var TriangleOrientation;\n(function (TriangleOrientation) {\n    TriangleOrientation[TriangleOrientation[\"Clockwise\"] = 0] = \"Clockwise\";\n    TriangleOrientation[TriangleOrientation[\"Counterclockwise\"] = 1] = \"Counterclockwise\";\n    TriangleOrientation[TriangleOrientation[\"Collinear\"] = 2] = \"Collinear\";\n})(TriangleOrientation || (TriangleOrientation = {}));\nexport function distPP(a, b) {\n    return a.sub(b).length;\n}\n/** represents a point with two coordinates on the plane */\nexport class Point {\n    static RoundPoint(point) {\n        return new Point(Point.RoundDouble(point.x), Point.RoundDouble(point.y));\n    }\n    static RoundDouble(num) {\n        return Math.round(num * GeomConstants.mult) / GeomConstants.mult;\n    }\n    toJSON() {\n        return { x: this.x, y: this.y };\n    }\n    static fromJSON(pData) {\n        return new Point(pData.x, pData.y);\n    }\n    /** c is projected to line through a, b */\n    static ProjectionToLine(a, b, c) {\n        let d = b.sub(a);\n        const dLen = d.length;\n        if (dLen < GeomConstants.distanceEpsilon) {\n            return a;\n        }\n        d = d.div(dLen);\n        const pr = c.sub(a).dot(d);\n        // projection\n        const ret = a.add(d.mul(pr));\n        //Assert.assert(Math.abs(c.sub(ret).dot(d)) < GeomConstants.distanceEpsilon)\n        return ret;\n    }\n    static RayIntersectsRayInteriors(aOrig, aDir, bOrig, bDir) {\n        const x = Point.lineLineIntersection(aOrig, aOrig.add(aDir), bOrig, bOrig.add(bDir));\n        if (!x)\n            return undefined;\n        if (x.sub(aOrig).dot(aDir.div(aDir.l1)) > GeomConstants.distanceEpsilon &&\n            x.sub(bOrig).dot(bDir.div(bDir.l1)) > GeomConstants.distanceEpsilon)\n            return x;\n        return undefined;\n    }\n    static IntervalIntersectsRay(segStart, segEnd, rayOrigin, rayDirection) {\n        const x = Point.lineLineIntersection(segStart, segEnd, rayOrigin, rayOrigin.add(rayDirection));\n        if (!x) {\n            return;\n        }\n        const ds = segStart.sub(x);\n        const de = x.sub(segEnd);\n        if (ds.dot(de) <= 0) {\n            return;\n        }\n        if (x.sub(rayOrigin).dot(rayDirection) < 0) {\n            return;\n        }\n        if (ds.dot(ds) > GeomConstants.squareOfDistanceEpsilon && de.dot(de) >= GeomConstants.squareOfDistanceEpsilon)\n            return x;\n    }\n    static PointToTheLeftOfLineOrOnLine(point, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(point, linePoint0, linePoint1) >= 0;\n    }\n    // returns true if \"point\" lies to the left of the line linePoint0, linePoint1\n    static PointToTheLeftOfLine(point, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(point, linePoint0, linePoint1) > 0;\n    }\n    static PointIsInsideCone(p, apex, leftSideConePoint, rightSideConePoint) {\n        return (Point.PointToTheRightOfLineOrOnLine(p, apex, leftSideConePoint) && Point.PointToTheLeftOfLineOrOnLine(p, apex, rightSideConePoint));\n    }\n    static PointToTheRightOfLineOrOnLine(point, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, point) <= 0;\n    }\n    static PointToTheRightOfLine(point, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, point) < 0;\n    }\n    static closeIntersections(a, b) {\n        return Point.close(a, b, GeomConstants.intersectionEpsilon);\n    }\n    get l1() {\n        return Math.abs(this.x_) + Math.abs(this.y_);\n    }\n    dot(a) {\n        return this.x * a.x + this.y * a.y;\n    }\n    get x() {\n        return this.x_;\n    }\n    get y() {\n        return this.y_;\n    }\n    compareTo(other) {\n        const r = compareNumbers(this.x, other.x);\n        if (r !== 0)\n            return r;\n        return compareNumbers(this.y, other.y);\n    }\n    toString() {\n        return '(' + this.x + ',' + this.y + ')';\n    }\n    static close(a, b, tol) {\n        return a.sub(b).length <= tol;\n    }\n    static closeSquare(a, b, tol) {\n        const d = b.sub(a);\n        return d.dot(d) <= tol;\n    }\n    static closeDistEps(a, b, eps = GeomConstants.distanceEpsilon) {\n        return a.sub(b).length <= eps;\n    }\n    normalize() {\n        const l = this.length;\n        return new Point(this.x / l, this.y / l);\n    }\n    get length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    get lengthSquared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    constructor(x, y) {\n        // Assert.assert(!(isNaN(x) || isNaN(y)))\n        this.x_ = x;\n        this.y_ = y;\n    }\n    static middle(a, b) {\n        return a.add(b).div(2);\n    }\n    scale(sx, sy) {\n        return new Point(this.x * sx, this.y * sy);\n    }\n    add(a) {\n        return new Point(this.x + a.x, this.y + a.y);\n    }\n    sub(a) {\n        return new Point(this.x - a.x, this.y - a.y);\n    }\n    mul(c) {\n        return new Point(this.x * c, this.y * c);\n    }\n    div(c) {\n        return new Point(this.x / c, this.y / c);\n    }\n    equal(a) {\n        return a.x === this.x && a.y === this.y;\n    }\n    neg() {\n        return new Point(-this.x, -this.y);\n    }\n    static lineLineIntersection(a, b, c, d) {\n        //look for the solution of the form a+u*(b-a)=c+v*(d-c)\n        const ba = b.sub(a);\n        const cd = c.sub(d);\n        const ca = c.sub(a);\n        const ret = LinearSystem2.solve(ba.x, cd.x, ca.x, ba.y, cd.y, ca.y);\n        if (ret !== undefined) {\n            return a.add(ba.mul(ret.x));\n        }\n        else {\n            return;\n        }\n    }\n    static segSegIntersection(a, b, c, d) {\n        //look for the solution of the form a+u*(b-a)=c+v*(d-c)\n        const ba = b.sub(a);\n        const cd = c.sub(d);\n        const ca = c.sub(a);\n        const eps = GeomConstants.tolerance;\n        const ret = LinearSystem2.solve(ba.x, cd.x, ca.x, ba.y, cd.y, ca.y);\n        if (ret !== undefined && ret.x > -eps && ret.x < 1.0 + eps && ret.y > -eps && ret.y < 1.0 + eps) {\n            return a.add(ba.mul(ret.x));\n        }\n        else {\n            return;\n        }\n    }\n    static parallelWithinEpsilon(a, b, eps) {\n        const alength = a.length;\n        const blength = b.length;\n        if (alength < eps || blength < eps)\n            return true;\n        a = a.div(alength);\n        b = b.div(blength);\n        return Math.abs(-a.x * b.y + a.y * b.x) < eps;\n    }\n    static crossProduct(point0, point1) {\n        return point0.x * point1.y - point0.y * point1.x;\n    }\n    static dot(a, b) {\n        return a.x * b.x + a.y * b.y;\n    }\n    static add(a, b) {\n        return a.add(b);\n    }\n    rotate90Ccw() {\n        return new Point(-this.y, this.x);\n    }\n    rotate90Cw() {\n        return new Point(this.y, -this.x);\n    }\n    clone() {\n        return new Point(this.x, this.y);\n    }\n    // returns this rotated by the angle counterclockwise; does not change \"this\" value\n    rotate(angle) {\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        return new Point(c * this.x - s * this.y, s * this.x + c * this.y);\n    }\n    static mkPoint(x, a, y, b) {\n        return a.mul(x).add(b.mul(y));\n    }\n    static convSum(x, a, b) {\n        return a.add(b.sub(a).mul(x));\n    }\n    static anglePCP(point1, center, point3) {\n        return Point.angle(point1.sub(center), point3.sub(center));\n    }\n    // The angle you need to turn \"side0\" counterclockwise to make it collinear with \"side1\"\n    static angle(side0, side1) {\n        const ax = side0.x;\n        const ay = side0.y;\n        const bx = side1.x;\n        const by = side1.y;\n        const cross = ax * by - ay * bx;\n        const dot = ax * bx + ay * by;\n        if (Math.abs(dot) < GeomConstants.tolerance) {\n            if (Math.abs(cross) < GeomConstants.tolerance)\n                return 0;\n            if (cross < -GeomConstants.tolerance)\n                return (3 * Math.PI) / 2;\n            return Math.PI / 2;\n        }\n        if (Math.abs(cross) < GeomConstants.tolerance) {\n            if (dot < -GeomConstants.tolerance)\n                return Math.PI;\n            return 0.0;\n        }\n        const atan2 = Math.atan2(cross, dot);\n        if (cross >= -GeomConstants.tolerance)\n            return atan2;\n        return Math.PI * 2.0 + atan2;\n    }\n    static signedDoubledTriangleArea(a, b, c) {\n        return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);\n    }\n    static getTriangleOrientation(cornerA, cornerB, cornerC) {\n        const area = Point.signedDoubledTriangleArea(cornerA, cornerB, cornerC);\n        if (area > GeomConstants.distanceEpsilon)\n            return TriangleOrientation.Counterclockwise;\n        if (area < -GeomConstants.distanceEpsilon)\n            return TriangleOrientation.Clockwise;\n        return TriangleOrientation.Collinear;\n    }\n    static getTriangleOrientationWithIntersectionEpsilon(cornerA, cornerB, cornerC) {\n        const area = Point.signedDoubledTriangleArea(cornerA, cornerB, cornerC);\n        if (area > GeomConstants.intersectionEpsilon)\n            return TriangleOrientation.Counterclockwise;\n        if (area < -GeomConstants.intersectionEpsilon)\n            return TriangleOrientation.Clockwise;\n        return TriangleOrientation.Collinear;\n    }\n    static ClosestPointAtLineSegment(point, segmentStart, segmentEnd) {\n        const bc = segmentEnd.sub(segmentStart);\n        const ba = point.sub(segmentStart);\n        const c1 = bc.dot(ba);\n        const c2 = bc.dot(bc);\n        if (c1 <= 0.0 + GeomConstants.tolerance)\n            return segmentStart;\n        if (c2 <= c1 + GeomConstants.tolerance)\n            return segmentEnd;\n        return segmentStart.add(bc.mul(c1 / c2));\n    }\n    static pointToTheLeftOfLineOrOnLine(point, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(point, linePoint0, linePoint1) >= 0;\n    }\n    // returns true if \"point\" lies to the left of the line linePoint0, linePoint1\n    static pointToTheLeftOfLine(point, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(point, linePoint0, linePoint1) > 0;\n    }\n    // returns true if \"point\" lies to the right of the line linePoint0, linePoint1\n    static pointToTheRightOfLineOrOnLine(point, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, point) <= 0;\n    }\n    static pointToTheRightOfLine(point, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, point) < 0;\n    }\n    static canProject(point, segmentStart, segmentEnd) {\n        const bc = segmentEnd.sub(segmentStart);\n        const ba = point.sub(segmentStart);\n        if (ba.dot(bc) < 0)\n            // point belongs to the halfplane before the segment\n            return false;\n        const ca = point.sub(segmentEnd);\n        if (ca.dot(bc) > 0)\n            //point belongs to the halfplane after the segment\n            return false;\n        return true;\n    }\n    static distToLineSegment(a, b, c) {\n        const bc = c.sub(b);\n        const ba = a.sub(b);\n        let c1, c2;\n        if ((c1 = bc.dot(ba)) <= GeomConstants.tolerance) {\n            return { par: 0, dist: ba.length };\n        }\n        if ((c2 = bc.dot(bc)) <= c1 + GeomConstants.tolerance) {\n            return { par: 1, dist: a.sub(c).length };\n        }\n        const p = c1 / c2;\n        return { par: p, dist: b.add(bc.mul(p)).length };\n    }\n}\n//# sourceMappingURL=point.js.map","import { comparePointsYFirst as comparePointsYX } from '../../utils/compare';\nimport { distPP } from './point';\n/** An unordered pair of points */\nexport class PointPair {\n    constructor(first, second) {\n        if (comparePointsYX(first, second) < 0) {\n            this._first = first;\n            this._second = second;\n        }\n        else {\n            this._first = second;\n            this._second = first;\n        }\n    }\n    get first() {\n        return this._first;\n    }\n    get second() {\n        return this._second;\n    }\n    get Length() {\n        return distPP(this._first, this._second);\n    }\n    CompareTo(other) {\n        const cr = comparePointsYX(this._first, other._first);\n        if (cr !== 0) {\n            return cr;\n        }\n        return comparePointsYX(this._second, other._second);\n    }\n    static equal(pair0, pair1) {\n        return pair0._first.equal(pair1._first) && pair0._second.equal(pair1._second);\n    }\n    toString() {\n        return this._first + (' ' + this._second);\n    }\n}\n//# sourceMappingURL=pointPair.js.map","import { Point, TriangleOrientation } from './point';\nimport { Rectangle } from './rectangle';\nimport { PolylinePoint } from './polylinePoint';\nimport { Parallelogram } from './parallelogram';\nimport { LineSegment } from './lineSegment';\nimport { Curve } from './curve';\n/** the curve corresponding to the sequence of lines, could be closed when the start coincides with the end */\nexport class Polyline {\n    constructor() {\n        this.initIsRequired = true;\n        this.isClosed_ = false;\n    }\n    toJSON() {\n        return { points: Array.from(this).map((p) => p.toJSON()) };\n    }\n    static fromJSON(data) {\n        return Polyline.mkFromPoints(data.points.map((p) => Point.fromJSON(p)));\n    }\n    RemoveStartPoint() {\n        const p = this.startPoint.next;\n        p.prev = null;\n        this.startPoint = p;\n        this.setInitIsRequired();\n    }\n    RemoveEndPoint() {\n        const p = this.endPoint.prev;\n        p.next = null;\n        this.endPoint = p;\n        this.setInitIsRequired();\n    }\n    setInitIsRequired() {\n        this.initIsRequired = true;\n    }\n    addPointXY(x, y) {\n        this.addPoint(new Point(x, y));\n    }\n    /** should true, by internal assumptions,  in general for convex polylines */\n    isClockwise() {\n        return (Point.getTriangleOrientation(this.startPoint.point, this.startPoint.next.point, this.startPoint.next.next.point) ==\n            TriangleOrientation.Clockwise);\n    }\n    /**  adds a point to the polyline */\n    addPoint(p) {\n        // Assert.assert(\n        //  this.endPoint == null  || !Point.closeDistEps(p, this.endPoint.point),\n        // )\n        const pp = new PolylinePoint();\n        pp.polyline = this;\n        pp.point = p.clone();\n        if (this.endPoint != null) {\n            // if (!ApproximateComparer.Close(point, this.endPoint.Point)) {\n            this.endPoint.next = pp;\n            pp.prev = this.endPoint;\n            this.endPoint = pp;\n            // }\n        }\n        else {\n            this.startPoint = this.endPoint = pp;\n        }\n        this.setInitIsRequired();\n    }\n    PrependPoint(p) {\n        // Assert.assert(this.endPoint == null  || !Point.closeDistEps(p, this.endPoint.point))\n        const pp = PolylinePoint.mkFromPoint(p);\n        pp.polyline = this;\n        if (this.startPoint != null) {\n            if (!Point.closeDistEps(p, this.startPoint.point)) {\n                this.startPoint.prev = pp;\n                pp.next = this.startPoint;\n                this.startPoint = pp;\n            }\n        }\n        else {\n            this.endPoint = pp;\n            this.startPoint = pp;\n        }\n        this.setInitIsRequired();\n    }\n    *[Symbol.iterator]() {\n        for (let s = this.startPoint; s != null; s = s.next)\n            yield s.point;\n    }\n    *polylinePoints() {\n        for (let s = this.startPoint; s != null; s = s.next)\n            yield s;\n    }\n    *skip(skipCount) {\n        for (let s = this.startPoint; s != null; s = s.next) {\n            if (skipCount > 0)\n                skipCount--;\n            else\n                yield s;\n        }\n    }\n    static parallelogramOfLineSeg(a, b) {\n        const side = b.sub(a).div(2);\n        return Parallelogram.parallelogramByCornerSideSide(a, side, side);\n    }\n    static mkFromPoints(ps) {\n        const r = new Polyline();\n        for (const p of ps) {\n            r.addPoint(p);\n        }\n        return r;\n    }\n    static mkClosedFromPoints(ps) {\n        const r = Polyline.mkFromPoints(ps);\n        r.closed = true;\n        return r;\n    }\n    calculatePbNode() {\n        const parallelograms = [];\n        const children = [];\n        let pp = this.startPoint;\n        let offset = 0;\n        while (pp.next != null) {\n            const parallelogram = Polyline.parallelogramOfLineSeg(pp.point, pp.next.point);\n            parallelograms.push(parallelogram);\n            children.push({\n                parallelogram: parallelogram,\n                seg: this,\n                leafBoxesOffset: 0,\n                node: {\n                    low: offset,\n                    high: offset + 1,\n                    chord: LineSegment.mkPP(pp.point, pp.next.point),\n                },\n            });\n            pp = pp.next;\n            offset++;\n        }\n        if (this.isClosed_) {\n            const parallelogram = Polyline.parallelogramOfLineSeg(this.endPoint.point, this.startPoint.point);\n            parallelograms.push(parallelogram);\n            children.push({\n                parallelogram: parallelogram,\n                seg: this,\n                leafBoxesOffset: 0,\n                node: {\n                    low: offset,\n                    high: offset + 1,\n                    chord: LineSegment.mkPP(this.endPoint.point, this.startPoint.point),\n                },\n            });\n        }\n        this.pBNode = {\n            parallelogram: Parallelogram.getParallelogramOfAGroup(parallelograms),\n            seg: this,\n            leafBoxesOffset: 0,\n            node: {\n                children: children,\n            },\n        };\n    }\n    init() {\n        this.bBox = Rectangle.rectangleOnPoint(this.startPoint.point);\n        for (const p of this.skip(1)) {\n            this.bBox.add(p.point);\n        }\n        this.updateCount();\n        this.calculatePbNode();\n        this.initIsRequired = false;\n    }\n    updateCount() {\n        this.count_ = 0;\n        for (let pp = this.startPoint; pp != null; pp = pp.next) {\n            this.count_++;\n        }\n    }\n    get count() {\n        if (this.initIsRequired)\n            this.init();\n        return this.count_;\n    }\n    get closed() {\n        return this.isClosed_;\n    }\n    set closed(value) {\n        this.isClosed_ = value;\n    }\n    value(t) {\n        if (this.initIsRequired)\n            this.init();\n        const p = this.getAdjustedParamAndStartEndPoints(t);\n        return Point.convSum(p.t, p.a, p.b);\n    }\n    getAdjustedParamAndStartEndPoints(t) {\n        /*Assert.assert(t >= -GeomConstants.tolerance)*/\n        /*Assert.assert(this.startPoint != null)*/\n        let s = this.startPoint;\n        while (s.next != null) {\n            if (t <= 1) {\n                return {\n                    a: s.point,\n                    b: s.next.point,\n                    t: t,\n                };\n            }\n            s = s.next;\n            t -= 1;\n        }\n        if (this.closed) {\n            if (t <= 1) {\n                return {\n                    a: this.endPoint.point,\n                    b: this.startPoint.point,\n                    t: t,\n                };\n            }\n        }\n        throw new Error('out of the parameter domain');\n    }\n    derivative(t) {\n        const ap = this.getAdjustedParamAndStartEndPoints(t);\n        return ap.b.sub(ap.a);\n    }\n    secondDerivative(t) {\n        return new Point(0, 0);\n    }\n    thirdDerivative(t) {\n        return new Point(0, 0);\n    }\n    pNodeOverICurve() {\n        if (this.initIsRequired)\n            this.init();\n        return this.pBNode;\n    }\n    get boundingBox() {\n        if (this.initIsRequired)\n            this.init();\n        return this.bBox;\n    }\n    get parStart() {\n        return 0;\n    }\n    get parEnd() {\n        if (this.initIsRequired)\n            this.init();\n        return this.closed ? this.count_ : this.count_ - 1;\n    }\n    static polylineFromCurve(curve) {\n        const ret = new Polyline();\n        ret.addPoint(curve.start);\n        for (const ls of curve.segs)\n            ret.addPoint(ls.end);\n        ret.closed = curve.start === curve.end;\n        return ret;\n    }\n    trim(start, end) {\n        //this is a very lazy version!\n        let curve = this.toCurve();\n        curve = curve.trim(start, end);\n        /* always convert to Polyline */\n        if (curve instanceof Curve)\n            return Polyline.polylineFromCurve(curve);\n        else\n            return Polyline.mkFromPoints([curve.start, curve.end]);\n    }\n    trimWithWrap(start, end) {\n        throw new Error('Method not implemented.');\n    }\n    translate(delta) {\n        let p = this.startPoint;\n        do {\n            p.point = p.point.add(delta);\n            if (p === this.endPoint)\n                break;\n            p = p.getNext();\n        } while (true);\n        this.setInitIsRequired();\n    }\n    scaleFromOrigin(xScale, yScale) {\n        throw new Error('Method not implemented.');\n    }\n    get start() {\n        return this.startPoint.point;\n    }\n    get end() {\n        return this.endPoint.point;\n    }\n    reverse() {\n        const r = new Polyline();\n        r.closed = this.closed;\n        let p = this.endPoint;\n        do {\n            r.addPoint(p.point);\n            if (p === this.startPoint)\n                break;\n            p = p.getPrev();\n        } while (true);\n        return r;\n    }\n    offsetCurve(offset, dir) {\n        throw new Error('Method not implemented.');\n    }\n    lengthPartial(start, end) {\n        throw new Error('Method not implemented.');\n    }\n    get length() {\n        throw new Error('Method not implemented.');\n    }\n    getParameterAtLength(length) {\n        throw new Error('Method not implemented.');\n    }\n    transform(transformation) {\n        const ret = new Polyline();\n        for (const p of this.polylinePoints()) {\n            ret.addPoint(transformation.multiplyPoint(p.point));\n        }\n        ret.closed = this.closed;\n        return ret;\n    }\n    closestParameterWithinBounds(targetPoint, low, high) {\n        throw new Error('Method not implemented.');\n    }\n    closestParameter(targetPoint) {\n        let ret = 0;\n        let dist = Number.MAX_VALUE;\n        let offset = 0;\n        let pp = this.startPoint;\n        while (pp.next != null) {\n            const ls = LineSegment.mkPP(pp.point, pp.next.point);\n            const t = ls.closestParameter(targetPoint);\n            const delta = ls.value(t).sub(targetPoint);\n            const newDist = delta.dot(delta);\n            if (newDist < dist) {\n                dist = newDist;\n                ret = t + offset;\n            }\n            pp = pp.next;\n            offset++;\n        }\n        if (this.closed) {\n            const ls = LineSegment.mkPP(this.endPoint.point, this.startPoint.point);\n            const t = ls.closestParameter(targetPoint);\n            const delta = ls.value(t).sub(targetPoint);\n            const newDist = delta.dot(delta);\n            if (newDist < dist) {\n                ret = t + offset;\n            }\n        }\n        return ret;\n    }\n    clone() {\n        const r = new Polyline();\n        r.closed = this.closed;\n        let p = this.startPoint;\n        do {\n            r.addPoint(p.point);\n            if (p === this.endPoint)\n                break;\n            p = p.getNext();\n        } while (true);\n        return r;\n    }\n    leftDerivative(t) {\n        throw new Error('Method not implemented.');\n    }\n    rightDerivative(t) {\n        throw new Error('Method not implemented.');\n    }\n    curvature(t) {\n        throw new Error('Method not implemented.');\n    }\n    curvatureDerivative(t) {\n        throw new Error('Method not implemented.');\n    }\n    curvatureSecondDerivative(t) {\n        throw new Error('Method not implemented.');\n    }\n    next(a) {\n        var _a;\n        return (_a = a.next) !== null && _a !== void 0 ? _a : (this.closed ? this.startPoint : null);\n    }\n    prev(a) {\n        var _a;\n        return (_a = a.prev) !== null && _a !== void 0 ? _a : (this.closed ? this.endPoint : null);\n    }\n    toCurve() {\n        const c = new Curve();\n        Curve.addLineSegment(c, this.startPoint.point, this.startPoint.next.point);\n        let p = this.startPoint.next;\n        while ((p = p.next) != null)\n            Curve.continueWithLineSegmentP(c, p.point);\n        if (this.closed)\n            Curve.continueWithLineSegmentP(c, this.startPoint.point);\n        return c;\n    }\n    RemoveCollinearVertices() {\n        for (let pp = this.startPoint.next; pp.next != null; pp = pp.next) {\n            if (Point.getTriangleOrientation(pp.prev.point, pp.point, pp.next.point) === TriangleOrientation.Collinear) {\n                pp.prev.next = pp.next;\n                pp.next.prev = pp.prev;\n            }\n        }\n        this.setInitIsRequired();\n        return this;\n    }\n}\n//# sourceMappingURL=polyline.js.map","export class PolylinePoint {\n    constructor() {\n        this._next = null;\n        this.prev = null;\n    }\n    get point() {\n        return this._point;\n    }\n    set point(value) {\n        this._point = value;\n    }\n    get next() {\n        return this._next;\n    }\n    set next(value) {\n        this._next = value;\n    }\n    get nextOnPolyline() {\n        return this.polyline.next(this);\n    }\n    get prevOnPolyline() {\n        return this.polyline.prev(this);\n    }\n    //\n    getNext() {\n        return this.next;\n    }\n    setNext(nVal) {\n        this.next = nVal;\n        if (this.polyline != null)\n            this.polyline.setInitIsRequired();\n    }\n    //\n    getPrev() {\n        return this.prev;\n    }\n    setPrev(prevVal) {\n        this.prev = prevVal;\n        if (this.polyline != null)\n            this.polyline.setInitIsRequired();\n    }\n    static mkFromPoint(p) {\n        const pp = new PolylinePoint();\n        pp.point = p;\n        return pp;\n    }\n}\n//# sourceMappingURL=polylinePoint.js.map","import { Point } from './point';\nimport { Polyline } from './polyline';\nimport { GeomConstants } from './geomConstants';\nimport { closeDistEps } from '../../utils/compare';\nexport class Size {\n    pad(padW) {\n        this.width += padW * 2;\n    }\n    /** creates a square if called with width only */\n    constructor(width, height = width) {\n        this.width = width;\n        this.height = height;\n    }\n}\nexport class Rectangle {\n    /** this function will not work correctly for transformations that are not translations, or rotations by n*90, or a combination of those */\n    transform(m) {\n        return Rectangle.mkPP(m.multiplyPoint(this.leftTop), m.multiplyPoint(this.rightBottom));\n    }\n    translate(m) {\n        return Rectangle.mkSizeCenter(this.size, this.center.add(m));\n    }\n    /** Returns true iff the rectangles are geometrically identical */\n    equal(bbox) {\n        return this.left_ === bbox.left && this.right_ === bbox.right && this.top_ === bbox.top && this.bottom_ === bbox.bottom;\n    }\n    /** Returns true iff the rectangles are distEpsilon close */\n    equalEps(bbox) {\n        return (closeDistEps(this.left_, bbox.left) &&\n            closeDistEps(this.right_, bbox.right) &&\n            closeDistEps(this.top_, bbox.top) &&\n            closeDistEps(this.bottom_, bbox.bottom));\n    }\n    /** make a rectangle with the given size and center */\n    static mkSizeCenter(size, center) {\n        const w = size.width / 2;\n        const h = size.height / 2;\n        return new Rectangle({\n            left: center.x - w,\n            right: center.x + w,\n            bottom: center.y - h,\n            top: center.y + h,\n        });\n    }\n    constructor(t) {\n        this.left_ = t.left;\n        this.right_ = t.right;\n        this.top_ = t.top;\n        this.bottom = t.bottom;\n    }\n    add_rect(rectangle) {\n        return this.addRec(rectangle);\n    }\n    contains_point(point) {\n        return this.contains(point);\n    }\n    contains_rect(rect) {\n        return this.containsRect(rect);\n    }\n    intersection_rect(rectangle) {\n        return this.intersection(rectangle);\n    }\n    intersects_rect(rectangle) {\n        return this.intersects(rectangle);\n    }\n    unite(b) {\n        return Rectangle.rectangleOfTwo(this, b);\n    }\n    contains_point_radius(p, radius) {\n        return this.containsWithPadding(p, radius);\n    }\n    // returns true if r intersect this rectangle\n    intersects(rectangle) {\n        return this.intersectsOnX(rectangle) && this.intersectsOnY(rectangle);\n    }\n    // intersection (possibly empty) of rectangles\n    intersection(rectangle) {\n        if (!this.intersects(rectangle)) {\n            const intersection = Rectangle.mkEmpty();\n            intersection.setToEmpty();\n            return intersection;\n        }\n        const l = Math.max(this.left, rectangle.left);\n        const r = Math.min(this.right, rectangle.right);\n        const b = Math.max(this.bottom, rectangle.bottom);\n        const t = Math.min(this.top, rectangle.top);\n        return new Rectangle({ left: l, bottom: b, right: r, top: t });\n    }\n    // the center of the bounding box\n    get center() {\n        return this.leftTop.add(this.rightBottom).mul(0.5);\n    }\n    set center(value) {\n        const cen = this.leftTop.add(this.rightBottom).mul(0.5);\n        const shift = value.sub(cen);\n        this.leftTop = this.leftTop.add(shift);\n        this.rightBottom = this.rightBottom.add(shift);\n    }\n    intersectsOnY(r) {\n        if (r.bottom_ > this.top_ + GeomConstants.distanceEpsilon)\n            return false;\n        if (r.top_ < this.bottom_ - GeomConstants.distanceEpsilon)\n            return false;\n        return true;\n    }\n    intersectsOnX(r) {\n        if (r.left > this.right_ + GeomConstants.distanceEpsilon)\n            return false;\n        if (r.right < this.left_ - GeomConstants.distanceEpsilon)\n            return false;\n        return true;\n    }\n    // creates an empty rectangle\n    static mkEmpty() {\n        return new Rectangle({ left: 0, right: -1, bottom: 0, top: -1 });\n    }\n    get left() {\n        return this.left_;\n    }\n    set left(value) {\n        this.left_ = value;\n        this.onUpdated();\n    }\n    get right() {\n        return this.right_;\n    }\n    set right(value) {\n        this.right_ = value;\n        this.onUpdated();\n    }\n    get top() {\n        return this.top_;\n    }\n    set top(value) {\n        this.top_ = value;\n        this.onUpdated();\n    }\n    get bottom() {\n        return this.bottom_;\n    }\n    set bottom(value) {\n        this.bottom_ = value;\n        this.onUpdated();\n    }\n    get leftBottom() {\n        return new Point(this.left_, this.bottom_);\n    }\n    set leftBottom(value) {\n        this.left_ = value.x;\n        this.bottom = value.y;\n    }\n    get rightTop() {\n        return new Point(this.right_, this.top_);\n    }\n    set rightTop(value) {\n        this.right_ = value.x;\n        this.top_ = value.y;\n    }\n    get leftTop() {\n        return new Point(this.left_, this.top_);\n    }\n    set leftTop(value) {\n        this.left_ = value.x;\n        this.top_ = value.y;\n    }\n    get rightBottom() {\n        return new Point(this.right_, this.bottom_);\n    }\n    set rightBottom(value) {\n        this.right_ = value.x;\n        this.bottom = value.y;\n    }\n    /* eslint-disable  @typescript-eslint/no-empty-function */\n    onUpdated() { }\n    // create a box of two points\n    static mkPP(point0, point1) {\n        const r = new Rectangle({\n            left: point0.x,\n            right: point0.x,\n            top: point0.y,\n            bottom: point0.y,\n        });\n        r.add(point1);\n        return r;\n    }\n    // create rectangle from a point\n    static rectangleOnPoint(p) {\n        return new Rectangle({ left: p.x, right: p.x, top: p.y, bottom: p.y });\n    }\n    static mkLeftBottomSize(left, bottom, sizeF) {\n        const right = left + sizeF.width;\n        const top = bottom + sizeF.height;\n        return new Rectangle({ left: left, right: right, top: top, bottom: bottom });\n    }\n    // create a box on points (x0,y0), (x1,y1)\n    static getRectangleOnCoords(x0, y0, x1, y1) {\n        const r = new Rectangle({ left: x0, bottom: y0, right: x0, top: y0 });\n        r.add(new Point(x1, y1));\n        return r;\n    }\n    // Create rectangle that is the bounding box of the given points\n    static mkOnPoints(points) {\n        const r = Rectangle.mkEmpty();\n        for (const p of points) {\n            r.add(p);\n        }\n        return r;\n    }\n    // Create rectangle that is the bounding box of the given Rectangles\n    static mkOnRectangles(rectangles) {\n        const r = Rectangle.mkEmpty();\n        for (const p of rectangles) {\n            r.addRecSelf(p);\n        }\n        return r;\n    }\n    // the width of the rectangle\n    get width() {\n        return this.right_ - this.left_;\n    }\n    set width(value) {\n        const hw = value / 2.0;\n        const cx = (this.left_ + this.right_) / 2.0;\n        this.left_ = cx - hw;\n        this.right_ = cx + hw;\n    }\n    // returns true if the rectangle has negative width\n    isEmpty() {\n        return this.right < this.left;\n    }\n    // makes the rectangle empty\n    setToEmpty() {\n        this.left = 0;\n        this.right = -1;\n    }\n    // height of the rectangle\n    get height() {\n        return this.top_ - this.bottom_;\n    }\n    set height(value) {\n        const hw = value / 2.0;\n        const cx = (this.top_ + this.bottom_) / 2.0;\n        this.top_ = cx + hw;\n        this.bottom = cx - hw;\n    }\n    // rectangle containing both a and b\n    static rectangleOfTwo(a, b) {\n        const r = new Rectangle({\n            left: a.left_,\n            right: a.right_,\n            top: a.top_,\n            bottom: a.bottom_,\n        });\n        r.addRecSelf(b);\n        return r;\n    }\n    // contains with padding\n    containsWithPadding(point, padding) {\n        return (this.left_ - padding - GeomConstants.distanceEpsilon <= point.x &&\n            point.x <= this.right_ + padding + GeomConstants.distanceEpsilon &&\n            this.bottom_ - padding - GeomConstants.distanceEpsilon <= point.y &&\n            point.y <= this.top_ + padding + GeomConstants.distanceEpsilon);\n    }\n    // Rectangle area\n    get area() {\n        return (this.right_ - this.left_) * (this.top_ - this.bottom_);\n    }\n    // adding a point to the rectangle\n    add(point) {\n        if (!this.isEmpty()) {\n            if (this.left_ > point.x)\n                this.left_ = point.x;\n            if (this.top_ < point.y)\n                this.top_ = point.y;\n            if (this.right_ < point.x)\n                this.right_ = point.x;\n            if (this.bottom_ > point.y)\n                this.bottom = point.y;\n        }\n        else {\n            this.left_ = this.right_ = point.x;\n            this.top_ = this.bottom = point.y;\n        }\n    }\n    // adding rectangle\n    addRecSelf(rectangle) {\n        this.add(rectangle.leftTop);\n        this.add(rectangle.rightBottom);\n    }\n    // adding rectangle\n    addRec(rectangle) {\n        const ret = this.clone();\n        ret.add(rectangle.leftTop);\n        ret.add(rectangle.rightBottom);\n        return ret;\n    }\n    /**  Returns the translated clone of the specified rectangle */\n    static translate(rectangle, delta) {\n        const r = rectangle.clone();\n        r.center = rectangle.center.add(delta);\n        return r;\n    }\n    /**  Returns a new Rectangle which is the transform the input rectangle */\n    static transform(rectangle, m) {\n        return Rectangle.mkPP(m.multiplyPoint(rectangle.leftTop), m.multiplyPoint(rectangle.rightBottom));\n    }\n    // returns true if the rectangle contains the point\n    contains(point) {\n        return this.containsWithPadding(point, 0);\n    }\n    // returns true if this rectangle compconstely contains the specified rectangle\n    containsRect(rect) {\n        return this.contains(rect.leftTop) && this.contains(rect.rightBottom);\n    }\n    // returns true if this rectangle compconstely contains the specified rectangle\n    containsRectWithPadding(rect, padding) {\n        return this.containsWithPadding(rect.leftTop, padding) && this.containsWithPadding(rect.rightBottom, padding);\n    }\n    // return the length of the diagonal\n    get diagonal() {\n        return Math.sqrt(this.width * this.width + this.height * this.height);\n    }\n    // pad the rectangle horizontally by the given padding\n    padWidth(padding) {\n        this.left -= padding;\n        this.right += padding;\n    }\n    // pad the rectangle vertically by the given padding\n    padHeight(padding) {\n        this.top += padding;\n        this.bottom -= padding;\n    }\n    // pad the rectangle by the given padding\n    pad(padding) {\n        if (padding < -this.width / 2)\n            padding = -this.width / 2;\n        if (padding < -this.height / 2)\n            padding = -this.height / 2;\n        this.padWidth(padding);\n        this.padHeight(padding);\n    }\n    // Pad the rectangle by the given amount on each side\n    padEverywhere(margins) {\n        this.left -= margins.left;\n        this.right += margins.right;\n        this.bottom -= margins.bottom;\n        this.top += margins.top;\n    }\n    // Returns the intersection of two rectangles.\n    static intersect(rect1, rect2) {\n        if (rect1.intersects(rect2))\n            return Rectangle.mkPP(new Point(Math.max(rect1.left, rect2.left), Math.max(rect1.bottom, rect2.bottom)), new Point(Math.min(rect1.right, rect2.right), Math.min(rect1.top, rect2.top)));\n        return Rectangle.mkEmpty();\n    }\n    perimeter() {\n        const poly = new Polyline();\n        poly.addPoint(this.leftTop);\n        poly.addPoint(this.rightTop);\n        poly.addPoint(this.rightBottom);\n        poly.addPoint(this.leftBottom);\n        poly.closed = true;\n        return poly;\n    }\n    scaleAroundCenter(scale) {\n        this.width = this.width * scale;\n        this.height = this.height * scale;\n    }\n    clone() {\n        return new Rectangle({ left: this.left, right: this.right, top: this.top, bottom: this.bottom });\n    }\n    // gets or sets the Size\n    get size() {\n        return new Size(this.width, this.height);\n    }\n    set size(value) {\n        this.width = value.width;\n        this.height = value.height;\n    }\n    // constructor with Size and center\n    static creatRectangleWithSize(size, center) {\n        const w = size.width / 2;\n        const left = center.x - w;\n        const right = center.x + w;\n        const h = size.height / 2;\n        const bottom = center.y - h;\n        const top = center.y + h;\n        return new Rectangle({ left: left, right: right, top: top, bottom: bottom });\n    }\n    // adding a point with a Size\n    addPointWithSize(size, point) {\n        const w = size.width / 2;\n        const h = size.height / 2;\n        this.add(new Point(point.x - w, point.y - h));\n        this.add(new Point(point.x + w, point.y - h));\n        this.add(new Point(point.x - w, point.y + h));\n        this.add(new Point(point.x + w, point.y + h));\n    }\n}\n//# sourceMappingURL=rectangle.js.map","import { Algorithm } from '../../../utils/algorithm';\nimport { PackingConstants } from './PackingConstants';\n// Pack rectangles (without rotation) into a given aspect ratio\nexport class OptimalPacking extends Algorithm {\n    constructor(rectangles, aspectRatio) {\n        super(null);\n        this.desiredAspectRatio = 1.2;\n        this.bestPacking = null;\n        this.cachedCosts = new Map();\n        this.rectangles = rectangles;\n        this.desiredAspectRatio = aspectRatio;\n    }\n    // The width of the widest row in the packed solution\n    get PackedWidth() {\n        if (this.bestPacking != null) {\n            return this.bestPacking.PackedWidth;\n        }\n        return 0;\n    }\n    // The height of the bounding box of the packed solution\n    get PackedHeight() {\n        if (this.bestPacking != null) {\n            return this.bestPacking.PackedHeight;\n        }\n        return 0;\n    }\n    Pack(lowerBound, upperBound, minGranularity) {\n        const c0 = OptimalPacking.GetGoldenSectionStep(lowerBound, upperBound);\n        // the worst case time complexity is O(n log(n)) where we have to do a full traversal of the\n        // golden section search tree because it each stage the two candidate split points we chose had\n        // the same cost.\n        // the following calculation for precision limits the worst case time by making max(n) = MaxSteps.\n        const precision = Math.max(minGranularity / 10, (upperBound - lowerBound) / OptimalPacking.MaxSteps);\n        // need to overshoot upperbound when it is optimal\n        upperBound += precision;\n        this.bestPackingCost = Number.MAX_VALUE;\n        if (this.rectangles.length === 1) {\n            // the trivial solution for just one rectangle is widthLowerBound\n            this.PackLimit(lowerBound);\n        }\n        else if (this.rectangles.length === 2) {\n            // if we have 2 rectangles just try the two possibilities\n            this.PackLimit(lowerBound);\n            this.PackLimit(upperBound);\n        }\n        else if (this.rectangles.length > 2) {\n            OptimalPacking.GoldenSectionSearch((l) => this.PackLimit(l), lowerBound, c0, upperBound, precision);\n        }\n        const newRects = this.bestPacking.getRects();\n        for (let i = 0; i < this.rectangles.length; i++)\n            this.rectangles[i] = newRects[i];\n    }\n    PackLimit(limit) {\n        let cost = this.cachedCosts.get(limit);\n        if (cost == null) {\n            const packing = this.createPacking(this.rectangles, limit);\n            packing.run();\n            this.cachedCosts.set(limit, (cost = Math.abs(packing.PackedAspectRatio - this.desiredAspectRatio)));\n            if (cost < this.bestPackingCost) {\n                this.bestPackingCost = cost;\n                this.bestPacking = packing;\n            }\n        }\n        return cost;\n    }\n    // recursively searches a weakly unimodal function f(x) between x1 and x3 for the minimum.  It is assumed x2 \\le x1 and x2 \\le x3\n    // and x2-x1=a \\lt b=x3-x2.  The recursion generates a fourth point x4-x1=b \\gt a=x3-x4 where x4-x2=c and b=a+c and:\n    // if f(x4) \\lt f(x2) we search in the range [x2, x3]\n    // else if f(x2) \\lt f(x4) we search in the range [x1, x4]\n    // else\n    // f(x2)==f(x4) and we know that f is only weakly unimodal (not strongly unimodal) and we must search both branches.\n    static GoldenSectionSearch(f, x1, x2, x3, precision) {\n        // check termination\n        if (Math.abs(x1 - x3) < precision) {\n            return f(x1) < f(x3) ? x1 : x3;\n        }\n        // x2 must be between x1 and x3\n        /*Assert.assert(\n          (x1 < x2 && x2 < x3) || (x3 < x2 && x2 < x1),\n          'x2 not bounded by x1 and x3',\n        )*/\n        // x4 will be our new midpoint candidate\n        const x4 = OptimalPacking.GetGoldenSectionStep(x2, x3);\n        // now we have two candidates (x2,x4) both between x1 and x3: choose the bracket that most reduces f\n        const fx2 = f(x2);\n        const fx4 = f(x4);\n        const leftSearch = () => OptimalPacking.GoldenSectionSearch(f, x4, x2, x1, precision);\n        const rightSearch = () => OptimalPacking.GoldenSectionSearch(f, x2, x4, x3, precision);\n        if (fx4 < fx2) {\n            /*Assert.assert(\n              Math.abs(x2 - x3) < Math.abs(x1 - x3),\n              'Search region not narrowing!',\n            )*/\n            return rightSearch();\n        }\n        if (fx4 > fx2) {\n            /*Assert.assert(\n              Math.abs(x4 - x1) < Math.abs(x1 - x3),\n              'Search region not narrowing!',\n            )*/\n            return leftSearch();\n        }\n        // Doh! f(x2) === f(x4)!  Have to search both branches.\n        const right = rightSearch();\n        const left = leftSearch();\n        return f(left) < f(right) ? left : right;\n    }\n    static GetGoldenSectionStep(x1, x2) {\n        if (x1 < x2) {\n            return x1 + PackingConstants.GoldenRatioRemainder * (x2 - x1);\n        }\n        return x1 - PackingConstants.GoldenRatioRemainder * (x1 - x2);\n    }\n}\n// controls the maximum number of steps we are allowed to take in our golden section search\n// (actually worst case is O (n log n) for n=MaxSteps)\nOptimalPacking.MaxSteps = 1000;\n//# sourceMappingURL=OptimalPacking.js.map","import { OptimalPacking } from './OptimalPacking';\nimport { GreedyRectanglePacking } from './RectanglePacking';\n// Pack rectangles (without rotation) into a given aspect ratio\nexport class OptimalRectanglePacking extends OptimalPacking {\n    // Constructor for packing, call Run to do the actual pack.\n    // Each RectangleToPack.Rectangle is updated in place.\n    // Performs a Golden Section Search on packing width for the\n    // closest aspect ratio to the specified desired aspect ratio\n    constructor(rectangles, aspectRatio) {\n        super(GreedyRectanglePacking.SortRectangles(rectangles), aspectRatio);\n        /*Assert.assert(\n          rectangles.length > 0,\n          'Expected at least one rectangle in rectangles packing',\n        )*/\n        /*Assert.assert(aspectRatio > 0, 'aspect ratio should be greater than 0')*/\n        this.createPacking = (rs, width) => new GreedyRectanglePacking(rs, width, true);\n    }\n    // Performs a Golden Section Search on packing width for the\n    // closest aspect ratio to the specified desired aspect ratio\n    run() {\n        let minRectWidth = Number.MAX_VALUE;\n        let maxRectWidth = 0;\n        let totalWidth = 0;\n        // initial widthLowerBound is the width of a perfect packing for the desired aspect ratio\n        for (const r of this.rectangles) {\n            /*Assert.assert(r.width > 0, 'Width must be greater than 0')*/\n            /*Assert.assert(r.height > 0, 'Height must be greater than 0')*/\n            const width = r.width;\n            totalWidth += width;\n            minRectWidth = Math.min(minRectWidth, width);\n            maxRectWidth = Math.max(maxRectWidth, width);\n        }\n        this.Pack(maxRectWidth, totalWidth, minRectWidth);\n    }\n}\n//# sourceMappingURL=OptimalRectanglePacking.js.map","import { Algorithm } from '../../../utils/algorithm';\n// Algorithm to pack rectangles\nexport class Packing extends Algorithm {\n    get PackedWidth() {\n        return this.packedWidth;\n    }\n    set PackedWidth(value) {\n        this.packedWidth = value;\n    }\n    get PackedHeight() {\n        return this.packedHeight;\n    }\n    set PackedHeight(value) {\n        this.packedHeight = value;\n    }\n    // Aspect ratio of the bounding box of the packed solution\n    get PackedAspectRatio() {\n        return this.PackedWidth / this.PackedHeight;\n    }\n    getRects() {\n        const ret = [];\n        for (const [r, center] of this.rectsToCenters) {\n            r.center = center;\n            ret.push(r);\n        }\n        return ret;\n    }\n}\n//# sourceMappingURL=Packing.js.map","// Constants used by OptimalRectanglePacking\nexport class PackingConstants {\n}\n// The greeks thought the GoldenRatio was a good aspect ratio: Phi = (1 + Math.Sqrt(5)) / 2\n// <remarks>we also use this internally in our golden section search</remarks>\nPackingConstants.GoldenRatio = (1 + Math.sqrt(5)) / 2;\n// equiv to 1 - (1/Phi) where Phi is the Golden Ratio: i.e. the smaller of the two sections\n// if you divide a unit length by the golden ratio\nPackingConstants.GoldenRatioRemainder = 2 - PackingConstants.GoldenRatio;\n//# sourceMappingURL=PackingConstants.js.map","import { Stack } from 'stack-typescript';\nimport { Point } from '../point';\nimport { Packing } from './Packing';\n// Greedily pack rectangles (without rotation) into a given aspect ratio\nexport class GreedyRectanglePacking extends Packing {\n    // Constructor for packing, call Run to do the actual pack.\n    // Each RectangleToPack.Rectangle is updated in place.\n    // Pack rectangles tallest to shortest, left to right until wrapWidth is reached,\n    // then wrap to right-most rectangle still with vertical space to fit the next rectangle\n    constructor(rectangles, wrapWidth, rectanglesPresorted = false) {\n        super(null);\n        this.rectsToCenters = new Map();\n        this.rectanglesByDescendingHeight = rectanglesPresorted ? rectangles : GreedyRectanglePacking.SortRectangles(rectangles);\n        this.wrapWidth = wrapWidth;\n    }\n    // Sort rectangles by height\n    static SortRectangles(rectangles) {\n        rectangles.sort((a, b) => b.height - a.height);\n        return rectangles;\n    }\n    // Pack rectangles tallest to shortest, left to right until wrapWidth is reached,\n    // then wrap to right-most rectangle still with vertical space to fit the next rectangle\n    run() {\n        this.Pack();\n    }\n    // Traverses the rectangleEnumerator and places rectangles at the next available slot beneath the current parent,\n    // until the parent is filled or until maxRowWidth is reached.  Each successfully placed rectangle is pushed onto\n    // a stack, when there is no room for the rectangle we pop the stack for a new parent and try again.\n    Pack() {\n        this.PackedWidth = 0;\n        this.PackedHeight = 0;\n        // get next rectangle\n        const stack = new Stack();\n        let wrap = false;\n        let verticalPosition = 0;\n        let packedWidth = 0;\n        let packedHeight = 0;\n        const rects = this.rectanglesByDescendingHeight;\n        for (let i = 0; wrap || i < rects.length;) {\n            const r = rects[i];\n            const parent = stack.length > 0 ? stack.top : null;\n            if (parent == null || (parent.right + r.width <= this.wrapWidth && verticalPosition + r.height <= parent.top)) {\n                const leftBottom = new Point(parent ? parent.right : 0, verticalPosition);\n                const center = leftBottom.add(new Point(r.width / 2, r.height / 2));\n                r.center = center;\n                this.rectsToCenters.set(r, center);\n                packedWidth = Math.max(packedWidth, r.right);\n                packedHeight = Math.max(packedHeight, r.top);\n                stack.push(r);\n                wrap = false;\n            }\n            else {\n                verticalPosition = parent.top;\n                stack.pop();\n                wrap = true;\n            }\n            if (!wrap)\n                i++;\n        }\n        this.PackedWidth = packedWidth;\n        this.PackedHeight = packedHeight;\n    }\n}\n//# sourceMappingURL=RectanglePacking.js.map","import { CornerSite } from './cornerSite';\nimport { Point } from './../../math/geometry/point';\nimport { Curve } from './../../math/geometry/curve';\nimport { BezierSeg } from './../../math/geometry/bezierSeg';\nexport class SmoothedPolyline {\n    // creates the polyline from corner points\n    static mkFromPoints(points) {\n        let ret = null;\n        let site = null;\n        for (const p of points) {\n            if (site == null) {\n                site = CornerSite.mkSiteP(p);\n                ret = new SmoothedPolyline(site);\n            }\n            else {\n                const s = CornerSite.mkSiteP(p);\n                s.prev = site;\n                site.next = s;\n                site = s;\n            }\n        }\n        return ret;\n    }\n    clone() {\n        let s = this.headSite; //the old site\n        let prev = null;\n        let h;\n        let headOfTheClone = null;\n        while (s != null) {\n            h = s.clone();\n            h.prev = prev;\n            if (prev != null)\n                prev.next = h;\n            else\n                headOfTheClone = h;\n            s = s.next;\n            prev = h;\n        }\n        return new SmoothedPolyline(headOfTheClone);\n    }\n    constructor(head) {\n        this.headSite = head;\n    }\n    // the last site of the polyline\n    // <\n    get lastSite() {\n        let ret = this.headSite;\n        while (ret.next != null)\n            ret = ret.next;\n        return ret;\n    }\n    *[Symbol.iterator]() {\n        let s0 = this.headSite;\n        while (s0 != null) {\n            yield s0.point;\n            s0 = s0.next;\n        }\n    }\n    /** Creates a curve by using the underlying polyline*/\n    createCurve() {\n        const curve = new Curve();\n        let a = this.headSite; //the corner start\n        let b; //the corner origin\n        do {\n            const corner = Curve.findCorner(a);\n            if (corner == null)\n                break;\n            const bezierSeg = SmoothedPolyline.createBezierSegOnSite(corner.b);\n            if (curve.segs.length === 0) {\n                if (!Point.closeDistEps(a.point, bezierSeg.start))\n                    Curve.addLineSegment(curve, a.point, bezierSeg.start);\n            }\n            else if (!Point.closeDistEps(curve.end, bezierSeg.start))\n                Curve.continueWithLineSegmentP(curve, bezierSeg.start);\n            curve.addSegment(bezierSeg);\n            a = corner.b;\n        } while (true);\n        /*Assert.assert(a.next.next == null )*/\n        if (curve.segs.length === 0) {\n            if (!Point.closeDistEps(a.point, a.next.point)) {\n                Curve.addLineSegment(curve, a.point, a.next.point);\n            }\n            else {\n                const w = 5;\n                curve.segs.push(new BezierSeg(a.point, a.point.add(new Point(w, w)), a.point.add(new Point(-w, w)), b.point));\n            }\n        }\n        else if (!Point.closeDistEps(curve.end, a.next.point))\n            Curve.continueWithLineSegmentP(curve, a.next.point);\n        return curve;\n    }\n    static createBezierSegOnSite(b) {\n        const kPrev = b.previouisBezierCoefficient;\n        const kNext = b.nextBezierCoefficient;\n        const a = b.prev;\n        const c = b.next;\n        //   s = kPrev*a.point + (1 - kPrev)*b.point;\n        const s = a.point.mul(kPrev).add(b.point.mul(1 - kPrev));\n        //   const e = kNext * c.point + (1 - kNext) * b.point;\n        const e = c.point.mul(kNext).add(b.point.mul(1 - kNext));\n        //  u = s*b.PreviousTangentCoefficient + (1 - b.PreviousTangentCoefficient)*b.point;\n        const u = s.mul(b.previousTangentCoefficient).add(b.point.mul(1 - b.previousTangentCoefficient));\n        //const v = e * b.nextTangentCoefficient + (1 - b.nextTangentCoefficient) * b.point;\n        const v = e.mul(b.nextTangentCoefficient).add(b.point.mul(1 - b.nextTangentCoefficient));\n        return BezierSeg.mkBezier([s, u, v, e]);\n    }\n}\n//# sourceMappingURL=smoothedPolyline.js.map","import { Queue } from 'queue-typescript';\nexport function* GetConnectedComponents(graph) {\n    const enqueueed = new Array(graph.nodeCount).fill(false);\n    const queue = new Queue();\n    for (let i = 0; i < graph.nodeCount; i++) {\n        if (!enqueueed[i]) {\n            const nodes = new Array();\n            Enqueue(i, queue, enqueueed);\n            while (queue.length > 0) {\n                const s = queue.dequeue();\n                nodes.push(s);\n                for (const neighbor of Neighbors(graph, s)) {\n                    Enqueue(neighbor, queue, enqueueed);\n                }\n            }\n            yield nodes;\n        }\n    }\n}\nfunction* Neighbors(graph, s) {\n    for (const e of graph.outEdges[s]) {\n        yield e.target;\n    }\n    for (const e of graph.inEdges[s]) {\n        yield e.source;\n    }\n}\nfunction Enqueue(i, q, enqueueed) {\n    if (enqueueed[i] === false) {\n        q.enqueue(i);\n        enqueueed[i] = true;\n    }\n}\n//# sourceMappingURL=ConnectedComponentCalculator.js.map","import { BinaryHeapPriorityQueue } from '../../structs/BinaryHeapPriorityQueue';\nexport class MinimumSpanningTreeByPrim {\n    constructor(graph, weight, root) {\n        this.treeNodes = new Set();\n        // map of neighbors of the tree to the edges connected them to the tree\n        this.hedgehog = new Map();\n        this.graph = graph;\n        this.weight = weight;\n        this.root = root;\n        this.q = new BinaryHeapPriorityQueue(this.graph.nodeCount);\n    }\n    NodeIsInTree(i) {\n        return this.treeNodes.has(i);\n    }\n    GetTreeEdges() {\n        const ret = new Array();\n        this.Init();\n        while (ret.length < this.graph.nodeCount - 1 && this.q.Count > 0)\n            //some nodes might have no edges\n            this.AddEdgeToTree(ret);\n        return ret;\n    }\n    AddEdgeToTree(ret) {\n        const v = this.q.Dequeue();\n        const e = this.hedgehog.get(v);\n        this.treeNodes.add(v);\n        ret.push(e);\n        this.UpdateOutEdgesOfV(v);\n        this.UpdateInEdgesOfV(v);\n    }\n    UpdateOutEdgesOfV(v) {\n        for (const outEdge of this.graph.outEdges[v]) {\n            const u = outEdge.target;\n            if (this.NodeIsInTree(u)) {\n                continue;\n            }\n            const oldEdge = this.hedgehog.get(u);\n            if (oldEdge) {\n                const oldWeight = this.weight(oldEdge);\n                const newWeight = this.weight(outEdge);\n                if (newWeight < oldWeight) {\n                    this.q.DecreasePriority(u, newWeight);\n                    this.hedgehog.set(u, outEdge);\n                }\n            }\n            else {\n                this.q.Enqueue(u, this.weight(outEdge));\n                this.hedgehog.set(u, outEdge);\n            }\n        }\n    }\n    UpdateInEdgesOfV(v) {\n        for (const inEdge of this.graph.inEdges[v]) {\n            const u = inEdge.source;\n            if (this.NodeIsInTree(u)) {\n                continue;\n            }\n            const oldEdge = this.hedgehog.get(u);\n            if (oldEdge) {\n                const oldWeight = this.weight(oldEdge);\n                const newWeight = this.weight(inEdge);\n                if (newWeight < oldWeight) {\n                    this.q.DecreasePriority(u, newWeight);\n                    this.hedgehog.set(u, inEdge);\n                }\n            }\n            else {\n                this.q.Enqueue(u, this.weight(inEdge));\n                this.hedgehog.set(u, inEdge);\n            }\n        }\n    }\n    Init() {\n        this.treeNodes.add(this.root);\n        for (const outEdge of this.graph.outEdges[this.root]) {\n            const w = this.weight(outEdge);\n            this.q.Enqueue(outEdge.target, w);\n            this.hedgehog.set(outEdge.target, outEdge);\n        }\n        for (const inEdge of this.graph.inEdges[this.root]) {\n            const w = this.weight(inEdge);\n            this.q.Enqueue(inEdge.source, w);\n            this.hedgehog.set(inEdge.source, inEdge);\n        }\n    }\n}\n//# sourceMappingURL=MinimumSpanningTreeByPrim.js.map","import { IntPair } from './../../utils/IntPair';\nimport { mkGraphOnEdgesN } from './../../structs/basicGraphOnEdges';\nimport { Stack } from 'stack-typescript';\nexport function hasCycle(g) {\n    const visited = new Array(g.nodeCount).fill(false);\n    const reachableFromU = new Array(g.nodeCount).fill(false);\n    for (let u = 0; u < g.nodeCount; u++) {\n        if (hasCycleUnder(g, u, visited, reachableFromU))\n            return true;\n    }\n    return false;\n}\nexport class TopologicalSort {\n    // Topological sort of a list of int edge tuples\n    static getOrder(numberOfVertices, edges) {\n        const dag = mkGraphOnEdgesN(edges.map(([u, v]) => new IntPair(u, v)), numberOfVertices);\n        //Assert.assert(!hasCycle(dag), 'no cycles')\n        return TopologicalSort.getOrderOnGraph(dag);\n    }\n    // The function returns an array arr such that\n    // every edge points forward in the array. The input has to be a DAG\n    static getOrderOnGraph(graph) {\n        // Assert.assert(!hasCycle(graph))\n        const visited = new Array(graph.nodeCount).fill(false);\n        //no recursion! So we have to organize a stack\n        const se = new Stack();\n        const order = [];\n        let en;\n        for (let u = 0; u < graph.nodeCount; u++) {\n            if (visited[u])\n                continue;\n            let cu = u;\n            visited[cu] = true;\n            let i = 0;\n            en = graph.outEdges[u];\n            do {\n                for (; i < en.length; i++) {\n                    const v = en[i].target;\n                    if (!visited[v]) {\n                        visited[v] = true;\n                        se.push({ edges: en, index: i + 1, current_u: cu });\n                        cu = v;\n                        en = graph.outEdges[cu];\n                        i = -1;\n                    }\n                }\n                order.push(cu);\n                if (se.length > 0) {\n                    const t = se.pop();\n                    en = t.edges;\n                    i = t.index;\n                    cu = t.current_u;\n                }\n                else\n                    break;\n            } while (true);\n        }\n        return order.reverse();\n    }\n}\nfunction hasCycleUnder(g, u, visited, reachableFromU) {\n    if (reachableFromU[u]) {\n        return true;\n    }\n    if (visited[u])\n        return false;\n    reachableFromU[u] = true;\n    visited[u] = true;\n    for (const e of g.outEdges[u]) {\n        if (hasCycleUnder(g, e.target, visited, reachableFromU)) {\n            return true;\n        }\n    }\n    reachableFromU[u] = false;\n    return false;\n}\n//# sourceMappingURL=topologicalSort.js.map","import { Stack } from 'stack-typescript';\nimport { String } from 'typescript-string-operations';\nimport { Constraint } from './Constraint';\nimport { DfDvNode } from './DfDvNode';\n// For Path traversal of Expand.\nclass ConstraintDirectionPair {\n    constructor(constraint, isLeftToRight) {\n        this.Constraint = constraint;\n        this.IsForward = isLeftToRight;\n    }\n}\n// A Block is essentially a collection of Variables, which of turn contain\n// a collection of Constraints.\nexport class Block {\n    constructor(initialVariable, allConstraints) {\n        this.Variables = new Array();\n        // On initialization, each variable is put into its own block.  If this was called from Block.Split\n        // initialVariable will be null.\n        if (null != initialVariable) {\n            this.AddVariable(initialVariable);\n        }\n        this.allConstraints = allConstraints;\n    }\n    // Generate a string representation of the Block.\n    // <returns>A string representation of the Block.</returns>\n    toString() {\n        return String.Format('[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]', this.Variables.length, this.ReferencePos, this.Scale);\n    }\n    ComputeDfDv(initialVarToEval) {\n        // Compute the derivative of the spanning tree (comprised of our active constraints) at the\n        // point of variableToEval (with \"change\" being the difference between \"Desired\" position and the calculated\n        // position for the current pass), for all paths that do not include the edge variableToEval->variableDoneEval.\n        // Recursiteratively process all outgoing paths from variableToEval to its right (i.e. where it is constraint.Left),\n        // but don't include variableDoneEval because it's already been evaluated.\n        // At each variable on the rightward traversal, we'll also process leftward paths (incoming to) that\n        // variable (via the following constraint loop) before returning here.\n        // variableToEval and variableDoneEval (if not null) are guaranteed to be of this Block, since they're co-located\n        // of an active Constraint of this Block.\n        //\n        // For Expand, we want to find the constraint path from violatedConstraint.Left to violatedConstraint.Right;\n        // the latter is of pathTargetVariable.  This is ComputePath from the doc.  The logic there is:\n        //    Do the iterations of ComputeDvDv\n        //    If we find the target, then traverse the parent chain to populate the list bottom-up\n        /*Assert.assert(\n          0 === this.allConstraints.DfDvStack.length,\n          'Leftovers of ComputeDfDvStack',\n        )*/\n        this.allConstraints.DfDvStack = new Stack();\n        // Variables for initializing the first node.\n        const dummyConstraint = new Constraint(initialVarToEval);\n        this.dfDvDummyParentNode = new DfDvNode(dummyConstraint);\n        const firstNode = this.GetDfDvNode(this.dfDvDummyParentNode, dummyConstraint, initialVarToEval, null);\n        this.allConstraints.DfDvStack.push(firstNode);\n        // Iteratively recurse, processing all children of a constraint before the constraint itself.\n        // Loop termination is by testing for completion based on node==firstNode which is faster than\n        // (non-inlined) Stack.length.\n        for (;;) {\n            // Leave the node on the stack until we've processed all of its children.\n            const node = this.allConstraints.DfDvStack.top;\n            const prevStackCount = this.allConstraints.DfDvStack.length;\n            if (!node.ChildrenHaveBeenPushed) {\n                node.ChildrenHaveBeenPushed = true;\n                for (const constraint of node.VariableToEval.LeftConstraints) {\n                    // Direct violations (a -> b -> a) are not caught by the constraint-based cycle detection\n                    // because VariableDoneEval prevents them from being entered (b -> a is not entered because a is\n                    // VariableDoneEval).  These cycles should be caught by the null-minLagrangian IsUnsatisfiable\n                    // setting of Block.Expand (but assert with IsActive not IsUnsatisfiable, as the constraint\n                    // may not have been encountered yet).  Test_Unsatisfiable_Cycle_InDirect_With_SingleConstraint_Var.\n                    /*Assert.assert(\n                      !constraint.IsActive ||\n                        !(\n                          node.IsLeftToRight && constraint.Right === node.VariableDoneEval\n                        ),\n                      'this cycle should not happen',\n                    )*/\n                    if (constraint.IsActive && constraint.Right !== node.VariableDoneEval) {\n                        // variableToEval is now considered \"done\"\n                        const childNode = this.GetDfDvNode(node, constraint, constraint.Right, node.VariableToEval);\n                        // If the node has no constraints other than the one we're now processing, it's a leaf\n                        // and we don't need the overhead of pushing to and popping from the stack.\n                        if (1 === constraint.Right.ActiveConstraintCount) {\n                            this.ProcessDfDvLeafNodeDirectly(childNode);\n                        }\n                        else {\n                            this.PushDfDvNode(childNode);\n                        }\n                    }\n                }\n                for (const constraint of node.VariableToEval.RightConstraints) {\n                    // See comments of .LeftConstraints.\n                    /*Assert.assert(\n                      !constraint.IsActive ||\n                        !(\n                          !node.IsLeftToRight && constraint.Left === node.VariableDoneEval\n                        ),\n                      'this cycle should not happen',\n                    )*/\n                    if (constraint.IsActive && constraint.Left !== node.VariableDoneEval) {\n                        const childNode = this.GetDfDvNode(node, constraint, constraint.Left, node.VariableToEval);\n                        if (1 === constraint.Left.ActiveConstraintCount) {\n                            this.ProcessDfDvLeafNodeDirectly(childNode);\n                        }\n                        else {\n                            this.PushDfDvNode(childNode);\n                        }\n                    }\n                }\n                // If we just pushed one or more nodes, loop back up and \"recurse\" into them.\n                if (this.allConstraints.DfDvStack.length > prevStackCount) {\n                    continue;\n                }\n            }\n            // endif !node.ChildrenHaveBeenPushed\n            // We are at a non-leaf node and have \"recursed\" through all its descendents; therefore pop it off\n            // the stack and process it.  If it's the initial node, we've already updated DummyConstraint.Lagrangian\n            // from all child nodes, and it's of the DummyParentNode as well so this will add the final dfdv.\n            /*Assert.assert(\n              this.allConstraints.DfDvStack.top === node,\n              \"DfDvStack.top should be 'node'\",\n            )*/\n            this.allConstraints.DfDvStack.pop();\n            this.ProcessDfDvLeafNode(node);\n            if (node === firstNode) {\n                /*Assert.assert(\n                  0 === this.allConstraints.DfDvStack.length,\n                  'Leftovers of DfDvStack on completion of loop',\n                )*/\n                break;\n            }\n        }\n        // endwhile stack is not empty\n    }\n    // end ComputeDfDv()\n    ProcessDfDvLeafNode(node) {\n        const dfdv = node.VariableToEval.DfDv;\n        // Add dfdv to constraint.Lagrangian if we are going left-to-right, else subtract it (\"negative slope\");\n        // similarly, add it to or subtract it from the parent's Lagrangian.\n        if (node.IsLeftToRight) {\n            node.ConstraintToEval.Lagrangian = node.ConstraintToEval.Lagrangian + dfdv;\n            node.Parent.ConstraintToEval.Lagrangian = node.Parent.ConstraintToEval.Lagrangian + node.ConstraintToEval.Lagrangian;\n        }\n        else {\n            // Any child constraints have already put their values into the current constraint\n            // according to whether they were left-to-right or right-to-left.  This is the equivalent\n            // to the sum of return values of the recursive approach of the paper.  However, the paper\n            // negates this return value when setting it into a right-to-left parent's Lagrangian;\n            // we're that right-to-left parent now so do that first (negate the sum of children).\n            node.ConstraintToEval.Lagrangian = (node.ConstraintToEval.Lagrangian + dfdv) * -1;\n            node.Parent.ConstraintToEval.Lagrangian = node.Parent.ConstraintToEval.Lagrangian - node.ConstraintToEval.Lagrangian;\n        }\n        // See if this node found the target variable.\n        this.CheckForConstraintPathTarget(node);\n        // If this active constraint is violated, record it.\n        this.Debug_CheckForViolatedActiveConstraint(node.ConstraintToEval);\n        // We're done with this node.\n        this.allConstraints.RecycleDfDvNode(node);\n    }\n    Debug_CheckForViolatedActiveConstraint(constraint) {\n        // Test is: Test_Unsatisfiable_Direct_Inequality(); it should not encounter this.\n        if (constraint.Violation > this.allConstraints.SolverParameters.GapTolerance) {\n            /*Assert.assert(\n              false,\n              'Violated active constraint should never be encountered',\n            )*/\n        }\n    }\n    // Directly evaluate a leaf node rather than defer it to stack push/pop.\n    ProcessDfDvLeafNodeDirectly(node) {\n        // this.Debug_MarkForCycleCheck(node.ConstraintToEval)\n        this.ProcessDfDvLeafNode(node);\n    }\n    GetDfDvNode(parent, constraintToEval, variableToEval, variableDoneEval) {\n        const node = this.allConstraints.DfDvRecycleStack.size > 0\n            ? this.allConstraints.DfDvRecycleStack.pop().Set(parent, constraintToEval, variableToEval, variableDoneEval)\n            : DfDvNode.constructorDCVV(parent, constraintToEval, variableToEval, variableDoneEval);\n        node.Depth = node.Parent.Depth + 1;\n        if (this.allConstraints.MaxConstraintTreeDepth < node.Depth) {\n            this.allConstraints.MaxConstraintTreeDepth = node.Depth;\n        }\n        return node;\n    }\n    // Called by ComputeDfDv.\n    PushDfDvNode(node) {\n        this.PushOnDfDvStack(node);\n    }\n    // Called by RecurseGetConnectedVariables.\n    AddVariableAndPushDfDvNode(lstVars, node) {\n        // this.Debug_CycleCheck(node.ConstraintToEval)\n        lstVars.push(node.VariableToEval);\n        this.PushOnDfDvStack(node);\n    }\n    PushOnDfDvStack(node) {\n        // this.Debug_MarkForCycleCheck(node.ConstraintToEval)\n        this.allConstraints.DfDvStack.push(node);\n    }\n    CheckForConstraintPathTarget(node) {\n        if (this.pathTargetVariable === node.VariableToEval) {\n            // Add every variable from pathTargetVariable up the callchain up to but not including initialVarToEval.\n            while (node.Parent !== this.dfDvDummyParentNode) {\n                this.constraintPath.push(new ConstraintDirectionPair(node.ConstraintToEval, node.IsLeftToRight));\n                node = node.Parent;\n            }\n            this.pathTargetVariable = null;\n            // Path is complete\n        }\n    }\n    Expand(violatedConstraint) {\n        // Debug_ClearDfDv(false)\n        // Calculate the derivative at the point of each constraint.\n        // violatedConstraint's edge may be the minimum so pass null for variableDoneEval.\n        //\n        // We also want to find the path along the active constraint tree from violatedConstraint.Left\n        // to violatedConstraint.Right, and find the constraint on that path with the lowest Langragian\n        // multiplier. The ActiveConstraints form a spanning tree so there will be no more than\n        // one path. violatedConstraint is not yet active so it will not appear of this list.\n        if (this.constraintPath == null) {\n            this.constraintPath = new Array();\n        }\n        this.constraintPath = [];\n        this.pathTargetVariable = violatedConstraint.Right;\n        this.ComputeDfDv(violatedConstraint.Left);\n        // Now find the forward non-equality constraint on the path that has the minimal Lagrangina.\n        // Both variables of the constraint are of the same block so a path should always be found.\n        let minLagrangianConstraint = null;\n        if (this.constraintPath.length > 0) {\n            // We found an existing path so must remove an edge from our active list so that all\n            // connected variables from its varRight onward can move to the right; this will\n            // make the \"active\" status false for that edge.  The active non-Equality constraint\n            // with the minimal Lagrangian *that points rightward* is our split point (do *not*\n            // split Equality constraints).\n            for (const pathItem of this.constraintPath) {\n                if (pathItem.IsForward &&\n                    (minLagrangianConstraint == null || pathItem.Constraint.Lagrangian < minLagrangianConstraint.Lagrangian)) {\n                    if (!pathItem.Constraint.IsEquality) {\n                        minLagrangianConstraint = pathItem.Constraint;\n                    }\n                }\n            }\n            if (null != minLagrangianConstraint) {\n                // Deactivate this constraint as we are splitting on it.\n                this.allConstraints.DeactivateConstraint(minLagrangianConstraint);\n            }\n        }\n        this.constraintPath = [];\n        this.pathTargetVariable = null;\n        if (minLagrangianConstraint == null) {\n            // If no forward non-equality edge was found, violatedConstraint would have created a cycle.\n            /*Assert.assert(\n              !violatedConstraint.IsUnsatisfiable,\n              'An already-unsatisfiable constraint should not have been attempted',\n            )*/\n            violatedConstraint.IsUnsatisfiable = true;\n            this.allConstraints.NumberOfUnsatisfiableConstraints++;\n            return;\n        }\n        // Note: for perf, expand in-place (as of Ipsep) rather than Split/Merge (as of the Scaling paper).\n        // Adjust the offset of each variable at and past the right-hand side of violatedConstraint of the\n        // active spanning tree.  Because we've removed minLagrangianConstraint, this will widen the\n        // gap between minLagrangianConstraint.Left and .Right.  Note that this must include not only\n        // violatedConstraint.Right and those to its right, but also those to its left that are connected\n        // to it by active constraints - because the definition of an active constraint is that the\n        // gap matches exactly with the actual position, so all will move as a unit.\n        const lstConnectedVars = new Array();\n        // We consider .Left \"already evaluated\" because we don't want the path evaluation to back\n        // up to it (because we're splitting .Right off from it by deactivating the constraint).\n        this.GetConnectedVariables(lstConnectedVars, violatedConstraint.Right, violatedConstraint.Left);\n        const violation = violatedConstraint.Violation;\n        const cConnectedVars = lstConnectedVars.length;\n        for (let ii = 0; ii < cConnectedVars; ii++) {\n            lstConnectedVars[ii].OffsetInBlock = lstConnectedVars[ii].OffsetInBlock + violation;\n        }\n        // Now make the (no-longer-) violated constraint active.\n        this.allConstraints.ActivateConstraint(violatedConstraint);\n        // Clear the DfDv values.  For TEST_MSAGL, the new constraint came of from outside this block\n        // so this will make sure it doesn't have a stale cycle-detection flag.\n        violatedConstraint.ClearDfDv();\n        // Update this block's reference position.\n        this.UpdateReferencePos();\n    }\n    // end Expand()\n    Split(isQpsc) {\n        if (isQpsc) {\n            // of the Qpsc case, we've modified current positions of PreProject() so need to update them here.\n            this.UpdateReferencePos();\n        }\n        // If there is only one variable there's nothing to split.\n        if (this.Variables.length < 2) {\n            return null;\n        }\n        let minLagrangianConstraint = null;\n        // Debug_ClearDfDv(false)\n        // Pick a variable from the active constraint list - it doesn't matter which; any variable in\n        // the block is active (except for the initial one-var-per-block case), so ComputeDfDv will evaluate\n        // it along the active path.  Eventually all variables needing to be repositioned will be part of\n        // active constraints; even if SplitBlocks eventually happens, if the variable must be repositioned\n        // again (via the global-constraint-maxviolation check) its constraint will be reactivated.\n        // By the same token, ExpandBlock and SplitBlocks implicitly address/optimize all situations\n        // (or close enough) where an Active (i.e. === Gap) constraint would be better made inactive\n        // and the gap grown.\n        this.ComputeDfDv(this.Variables[0]);\n        // We only split the block if it has a non-equality constraint with a Lagrangian that is more than a\n        // rounding error below 0.0.\n        let minLagrangian = this.allConstraints.SolverParameters.Advanced.MinSplitLagrangianThreshold;\n        const numVars = this.Variables.length;\n        // cache for perf\n        for (let ii = 0; ii < numVars; ii++) {\n            for (const constraint of this.Variables[ii].LeftConstraints) {\n                if (constraint.IsActive && !constraint.IsEquality && constraint.Lagrangian < minLagrangian) {\n                    minLagrangianConstraint = constraint;\n                    minLagrangian = constraint.Lagrangian;\n                }\n            }\n        }\n        // If we have no satisfying constraint, we're done.\n        if (minLagrangianConstraint == null) {\n            return null;\n        }\n        return this.SplitOnConstraint(minLagrangianConstraint);\n    }\n    SplitOnConstraint(constraintToSplit) {\n        // We have a split point.  Remove that constraint from our active list and transfer it and all\n        // variables to its right to a new block.  As mentioned above, all variables and associated\n        // constraints of the block are active, and the block split and recalc of reference positions\n        // doesn't change the actual positions of any variables.\n        this.allConstraints.DeactivateConstraint(constraintToSplit);\n        let newSplitBlock = new Block(null, this.allConstraints);\n        // Transfer the connected variables.  This has the side-effect of moving the associated active\n        // constraints as well (because they are carried of the variables' LeftConstraints).\n        // This must include not only minLagrangianConstraint.Right and those to its right, but also\n        // those to its left that are connected to it by active constraints - because connected variables\n        // must be within a single a block.  Since we are splitting the constraint, there will be at least\n        // one variable (minLagrangianConstraint.Left) of the current block when we're done.  Because the active\n        // constraints form a tree, we won't have a situation where minLagrangianConstraint.Left is\n        // also the .Right of a constraint of a variable to the left of varRight.\n        // minLagrangianConstraint.Left is \"already evaluated\" because we don't want the path evaluation to\n        // back up to it (because we're splitting minLagrangianConstraint by deactivating it).\n        // this.DebugVerifyBlockConnectivity()\n        this.TransferConnectedVariables(newSplitBlock, constraintToSplit.Right, constraintToSplit.Left);\n        if (newSplitBlock.Variables.length > 0) {\n            // We may have removed the first variable so fully recalculate the reference position.\n            this.UpdateReferencePos();\n            // The new block's sums were not updated as its variables were added directly to its\n            // variables list, so fully recalculate.\n            newSplitBlock.UpdateReferencePos();\n            // this.DebugVerifyBlockConnectivity()\n            // newSplitBlock.DebugVerifyBlockConnectivity()\n        }\n        else {\n            // If there were unsatisfiable constraints, we may have tried to transfer all variables;\n            // of that case we simply ignored the transfer operation and left all variables of 'this' block.\n            // Return NULL so Solver.SplitBlocks knows we didn't split.\n            newSplitBlock = null;\n        }\n        return newSplitBlock;\n    }\n    // end Split()\n    AddVariable(variable) {\n        // Don't recalculate position yet; that will be done after all Block.AddVariable calls and then\n        // block-merge processing are done.\n        this.Variables.push(variable);\n        variable.Block = this;\n        if (1 === this.Variables.length) {\n            // The block's information is set to that of the initial variable's \"actual\" state; we won't\n            // call UpdateReferencePosFromSums.\n            this.Scale = variable.Scale;\n            this.ReferencePos = variable.ActualPos;\n            this.sumAd = variable.ActualPos * variable.Weight;\n            this.sumAb = 0;\n            this.sumA2 = variable.Weight;\n            variable.OffsetInBlock = 0;\n        }\n        else {\n            // Don't update ReferencePos yet because this is called from MergeBlocks or SplitBlock\n            // for a number of variables and we'll call UpdateReferencePosFromSums when they're all added.\n            this.AddVariableToBlockSums(variable);\n        }\n    }\n    UpdateReferencePos() {\n        // Make sure we're using the first variable's scale, of case the previous first-variable\n        // has been removed.\n        this.Scale = this.Variables[0].Scale;\n        // Note:  This does not keep the variables at their current positions; rather, it pulls them\n        // closer to their desired positions (this is easily seen by running through the math for a\n        // single variable).  However the relative positions are preserved.  This helps the solution\n        // remain minimal.\n        this.sumAd = 0;\n        this.sumAb = 0;\n        this.sumA2 = 0;\n        const numVars = this.Variables.length;\n        // cache for perf\n        for (let ii = 0; ii < numVars; ii++) {\n            this.AddVariableToBlockSums(this.Variables[ii]);\n        }\n        this.UpdateReferencePosFromSums();\n    }\n    AddVariableToBlockSums(variable) {\n        // a and b are from the scaling paper - with calculations modified for weights.\n        const a = this.Scale / variable.Scale;\n        const b = variable.OffsetInBlock / variable.Scale;\n        const aw = a * variable.Weight;\n        this.sumAd += aw * variable.DesiredPos;\n        this.sumAb += aw * b;\n        this.sumA2 += aw * a;\n    }\n    UpdateReferencePosFromSums() {\n        // This is called from Solver.MergeBlocks as well as internally.\n        if (!(Number.isFinite(this.sumAd) && Number.isFinite(this.sumAb) && Number.isFinite(this.sumA2))) {\n            throw new Error('infinite numbers');\n        }\n        this.ReferencePos = (this.sumAd - this.sumAb) / this.sumA2;\n        this.UpdateVariablePositions();\n    }\n    UpdateVariablePositions() {\n        const scaledReferencePos = this.Scale * this.ReferencePos;\n        const numVars = this.Variables.length;\n        // iteration is faster than foreach for Array\n        for (let ii = 0; ii < numVars; ii++) {\n            const v = this.Variables[ii];\n            // The derivation on this is from the paper:  a_i * YB + b_i\n            //      a_i === this.Scale / v.Scale\n            //      YB  === this.ReferencePos\n            //      b_i === v.OffsetInBlock / v.Scale\n            // Thus\n            //      ((this.Scale / v.Scale) * this.ReferencePos) + (v.OffsetInBlock / v.Scale)\n            // reorganizes to...\n            //      ((this.Scale * this.ReferencePos) / v.Scale) + (v.OffsetInBlock / v.Scale)\n            // which simplifies to...\n            v.ActualPos = (scaledReferencePos + v.OffsetInBlock) / v.Scale;\n        }\n    }\n    GetConnectedVariables(lstVars, varToEval, varDoneEval) {\n        // First set up cycle-detection of TEST_MSAGL mode.\n        // Debug_ClearDfDv(false)\n        this.RecurseGetConnectedVariables(lstVars, varToEval, varDoneEval);\n    }\n    RecurseGetConnectedVariables(lstVars, initialVarToEval, initialVarDoneEval) {\n        // Get all the vars at and to the right of 'var', including backtracking to get all\n        // variables that are connected from the left.  This is just like ComputeDfDv except\n        // that of this case we start with the variableDoneEval being the Left variable.\n        /*Assert.assert(\n          0 === this.allConstraints.DfDvStack.length,\n          'Leftovers of ComputeDfDvStack',\n        )*/\n        this.allConstraints.DfDvStack = new Stack();\n        /*Assert.assert(0 === lstVars.length, 'Leftovers of lstVars')*/\n        // Variables for initializing the first node.\n        const dummyConstraint = new Constraint(initialVarToEval);\n        this.dfDvDummyParentNode = new DfDvNode(dummyConstraint);\n        this.allConstraints.DfDvStack.push(this.GetDfDvNode(this.dfDvDummyParentNode, dummyConstraint, initialVarToEval, initialVarDoneEval));\n        lstVars.push(initialVarToEval);\n        // Do a pre-order tree traversal (process the constraint before its children), for consistency\n        // with prior behaviour.\n        while (this.allConstraints.DfDvStack.length > 0) {\n            // Leave the node on the stack until we've processed all of its children.\n            const node = this.allConstraints.DfDvStack.top;\n            const prevStackCount = this.allConstraints.DfDvStack.length;\n            if (!node.ChildrenHaveBeenPushed) {\n                node.ChildrenHaveBeenPushed = true;\n                for (const constraint of node.VariableToEval.LeftConstraints) {\n                    if (constraint.IsActive && constraint.Right !== node.VariableDoneEval) {\n                        // If the node has no constraints other than the one we're now processing, it's a leaf\n                        // and we don't need the overhead of pushing to and popping from the stack.\n                        if (1 === constraint.Right.ActiveConstraintCount) {\n                            //  this.Debug_CycleCheck(constraint)\n                            //  this.Debug_MarkForCycleCheck(constraint)\n                            lstVars.push(constraint.Right);\n                        }\n                        else {\n                            // variableToEval is now considered \"done\"\n                            this.AddVariableAndPushDfDvNode(lstVars, this.GetDfDvNode(node, constraint, constraint.Right, node.VariableToEval));\n                        }\n                    }\n                }\n                for (const constraint of node.VariableToEval.RightConstraints) {\n                    if (constraint.IsActive && constraint.Left !== node.VariableDoneEval) {\n                        // See comments of .LeftConstraints\n                        if (1 === constraint.Left.ActiveConstraintCount) {\n                            //  this.Debug_CycleCheck(constraint)\n                            //  this.Debug_MarkForCycleCheck(constraint)\n                            lstVars.push(constraint.Left);\n                        }\n                        else {\n                            this.AddVariableAndPushDfDvNode(lstVars, this.GetDfDvNode(node, constraint, constraint.Left, node.VariableToEval));\n                        }\n                    }\n                }\n            }\n            // endif !node.ChildrenHaveBeenPushed\n            // If we just pushed one or more nodes, loop back up and \"recurse\" into them.\n            if (this.allConstraints.DfDvStack.length > prevStackCount) {\n                continue;\n            }\n            // We are at a non-leaf node and have \"recursed\" through all its descendents, so we're done with it.\n            /*Assert.assert(\n              this.allConstraints.DfDvStack.top === node,\n              \"DfDvStack.top should be 'node'\",\n            )*/\n            this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.pop());\n        }\n        // endwhile stack is not empty\n    }\n    TransferConnectedVariables(newSplitBlock, varToEval, varDoneEval) {\n        this.GetConnectedVariables(newSplitBlock.Variables, varToEval, varDoneEval);\n        const numVarsToMove = newSplitBlock.Variables.length;\n        // cache for perf\n        // The constraints transferred to the new block need to have any stale cycle-detection values cleared out.\n        // newSplitBlock.Debug_ClearDfDv(true)\n        // Avoid the creation of an inner loop on Array<T>.Remove (which does linear scan and shift\n        // to preserve the order of members).  We don't care about variable ordering within the block\n        // so we can just repeatedly swap of the end one over whichever we're removing.\n        for (let moveIndex = 0; moveIndex < numVarsToMove; moveIndex++) {\n            newSplitBlock.Variables[moveIndex].Block = newSplitBlock;\n        }\n        // Now iterate from the end and swap of the last one we'll keep over the ones we'll remove.\n        let lastKeepIndex = this.Variables.length - 1;\n        for (let currentIndex = this.Variables.length - 1; currentIndex >= 0; currentIndex--) {\n            const currentVariable = this.Variables[currentIndex];\n            if (currentVariable.Block === newSplitBlock) {\n                if (currentIndex < lastKeepIndex) {\n                    // Swap of the one from the end.\n                    this.Variables[currentIndex] = this.Variables[lastKeepIndex];\n                }\n                lastKeepIndex--;\n            }\n        }\n        // end for each var to keep\n        // Now remove the end slots we're not keeping.  lastKeepIndex is -1 if we are removing all variables.\n        /*Assert.assert(\n          numVarsToMove === this.Variables.length - lastKeepIndex - 1,\n          'variable should not be found twice (probable cycle-detection problem',\n        )*/\n        this.Variables = this.Variables.slice(0, lastKeepIndex + 1);\n        if (0 === this.Variables.length) {\n            // This is probably due to unsatisfiable constraints; we've transferred all the variables,\n            // so just don't split at all; move the variables back into the current block rather than\n            // leaving an empty block of the list.  Caller will detect the empty newSplitBlock and ignore it.\n            for (let moveIndex = 0; moveIndex < numVarsToMove; moveIndex++) {\n                const variableToMove = newSplitBlock.Variables[moveIndex];\n                this.Variables.push(variableToMove);\n                variableToMove.Block = this;\n            }\n            newSplitBlock.Variables = [];\n        }\n    }\n}\n//# sourceMappingURL=Block.js.map","export class BlockVector {\n    get Count() {\n        return this.Vector.length;\n    }\n    item(index) {\n        return this.Vector[index];\n    }\n    constructor() {\n        this.Vector = new Array();\n    }\n    Add(block) {\n        block.VectorIndex = this.Vector.length;\n        this.Vector.push(block);\n        /*Assert.assert(\n          this.Vector[block.VectorIndex] === block,\n          'Inconsistent block.VectorIndex',\n        )*/\n    }\n    Remove(block) {\n        /*Assert.assert(\n          this.Vector[block.VectorIndex] === block,\n          'Inconsistent block.VectorIndex',\n        )*/\n        const swapBlock = this.Vector[this.Vector.length - 1];\n        this.Vector[block.VectorIndex] = swapBlock;\n        swapBlock.VectorIndex = block.VectorIndex;\n        this.Vector.pop();\n    }\n    toString() {\n        return this.Vector.toString();\n    }\n}\n//# sourceMappingURL=BlockVector.js.map","import { String } from 'typescript-string-operations';\nimport { compareNumbers } from '../../utils/compare';\nexport class Constraint {\n    SetActiveState(activeState, newVectorIndex) {\n        // Note: newVectorIndex may be the same as the old one if we are changing the state\n        // of the last inactive or first active constraint.\n        /*Assert.assert(\n          this.IsActive !== activeState,\n          'Constraint is already set to activationState',\n        )*/\n        this.IsActive = activeState;\n        this.VectorIndex = newVectorIndex;\n        if (this.IsActive) {\n            this.Left.ActiveConstraintCount++;\n            this.Right.ActiveConstraintCount++;\n        }\n        else {\n            this.Left.ActiveConstraintCount--;\n            this.Right.ActiveConstraintCount--;\n        }\n    }\n    SetVectorIndex(vectorIndex) {\n        // This is separate from set_VectorIndex because we can't restrict the caller to a specific\n        // class and we only want ConstraintVector to be able to call this.\n        this.VectorIndex = vectorIndex;\n    }\n    Reinitialize() {\n        // Called by Qpsc or equivalence-constraint-regapping initial block restructuring.\n        // All variables have been moved to their own blocks again, so reset solution states.\n        this.IsActive = false;\n        this.IsUnsatisfiable = false;\n        this.ClearDfDv();\n    }\n    // This is an  function, not a propset, because we only want it called by the Solver.\n    UpdateGap(newGap) {\n        this.Gap = newGap;\n    }\n    // The Constraint constructor takes the two variables and their required distance.\n    // The constraints will be generated either manually or by ConstraintGenerator,\n    // both of which know about the sizes when the constraints are generated (as\n    // well as any necessary padding), so the sizes are accounted for at that time\n    // and ProjectionSolver classes are not aware of Variable sizes.\n    static constructorVVNB(left, right, gap, isEquality) {\n        const v = new Constraint(left);\n        v.Left = left;\n        v.Right = right;\n        v.Gap = gap;\n        v.IsEquality = isEquality;\n        v.Lagrangian = 0;\n        v.IsActive = false;\n        return v;\n    }\n    // For Solver.ComputeDfDv's DummyParentNode's constraint only.\n    constructor(variable) {\n        this.Right = variable;\n        this.Left = variable;\n    }\n    // Generates a string representation of the Constraint.\n    // <returns>A string representation of the Constraint.</returns>\n    ToString() {\n        return String.Format('  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv', this.Left, this.Right, this.IsEquality ? '==' : '>=', this.Gap, this.Violation, this.Lagrangian, this.Lagrangian * 2, this.IsActive ? '+' : this.IsUnsatisfiable ? '!' : '-');\n    }\n    get Violation() {\n        return this.Left.ActualPos * this.Left.Scale + (this.Gap - this.Right.ActualPos * this.Right.Scale);\n    }\n    ClearDfDv() {\n        this.Lagrangian = 0;\n    }\n    // Compare this Constraint to rhs by their Variables in ascending order (this === lhs, other === rhs).\n    // The object being compared to.\n    // <returns>-1 if this.Left/Right are \"less\"; +1 if this.Left/Right are \"greater\"; 0 if this.Left/Right\n    //         and rhs.Left/Right are equal.</returns>\n    CompareTo(other) {\n        let cmp = this.Left.CompareTo(other.Left);\n        if (0 === cmp) {\n            cmp = this.Right.CompareTo(other.Right);\n        }\n        if (0 === cmp) {\n            cmp = compareNumbers(this.Gap, other.Gap);\n        }\n        return cmp;\n    }\n}\n//# sourceMappingURL=Constraint.js.map","import { Stack } from 'stack-typescript';\nexport class ConstraintVector {\n    constructor() {\n        this.nextConstraintIndex = 0;\n        // The node stack for \"recursive iteration\" of constraint trees, and the recycled node stack\n        // to reduce inner-loop alloc/GC overhead.\n        this.DfDvStack = new Stack();\n        this.DfDvRecycleStack = new Stack();\n    }\n    get IsEmpty() {\n        return this.Vector == null;\n    }\n    Create(numConstraints) {\n        this.Vector = new Array(numConstraints);\n        // Initialize this to out of range.\n        this.firstActiveConstraintIndex = numConstraints;\n    }\n    Add(constraint) {\n        /*Assert.assert(!constraint.IsActive, 'Constraint should not be active')*/\n        constraint.SetVectorIndex(this.nextConstraintIndex);\n        this.Vector[this.nextConstraintIndex++] = constraint;\n    }\n    ActivateConstraint(constraint) {\n        /*Assert.assert(!constraint.IsActive, 'Constraint is already active')*/\n        // Swap it from the inactive region to the start of the active region of the Vector.\n        /*Assert.assert(\n          this.firstActiveConstraintIndex > 0,\n          'All constraints are already active',\n        )*/\n        this.firstActiveConstraintIndex--;\n        /*Assert.assert(\n          !this.Vector[this.firstActiveConstraintIndex].IsActive,\n          'Constraint in inactive region is active',\n        )*/\n        this.SwapConstraint(constraint);\n        // Debug_AssertConsistency();\n    }\n    DeactivateConstraint(constraint) {\n        /*Assert.assert(constraint.IsActive, 'Constraint is not active')*/\n        // Swap it from the active region to the end of the inactive region of the Vector.\n        /*Assert.assert(\n          this.firstActiveConstraintIndex < this.Vector.length,\n          'All constraints are already inactive',\n        )*/\n        /*Assert.assert(\n          this.Vector[this.firstActiveConstraintIndex].IsActive,\n          'Constraint in active region is not active',\n        )*/\n        this.SwapConstraint(constraint);\n        this.firstActiveConstraintIndex++;\n        // Debug_AssertConsistency();\n    }\n    SwapConstraint(constraint) {\n        // Swap out the constraint at the current active/inactive border index (which has been updated\n        // according to the direction we're moving it).\n        const swapConstraint = this.Vector[this.firstActiveConstraintIndex];\n        swapConstraint.SetVectorIndex(constraint.VectorIndex);\n        this.Vector[constraint.VectorIndex] = swapConstraint;\n        // Toggle the state of the constraint being updated.\n        this.Vector[this.firstActiveConstraintIndex] = constraint;\n        constraint.SetActiveState(!constraint.IsActive, this.firstActiveConstraintIndex);\n    }\n    Reinitialize() {\n        // Qpsc requires reinitializing the block structure\n        if (this.Vector == null) {\n            return;\n        }\n        for (const constraint of this.Vector) {\n            constraint.Reinitialize();\n        }\n        this.firstActiveConstraintIndex = this.Vector.length;\n    }\n    RecycleDfDvNode(node) {\n        // In the case of long constraint chains make sure this does not end up as big as the number of constraints in the block.\n        if (this.DfDvRecycleStack.length < 1024) {\n            this.DfDvRecycleStack.push(node);\n        }\n    }\n    toString() {\n        return this.Vector.toString();\n    }\n}\n//# sourceMappingURL=ConstraintVector.js.map","import { String } from 'typescript-string-operations';\n// variableDoneEval is NULL if we are starting an evaluation; if recursive, it's the variable\n// on that side from the parent call, which was already processed.\nexport class DfDvNode {\n    static constructorDCVV(parent, constraintToEval, variableToEval, variableDoneEval) {\n        const ret = new DfDvNode(constraintToEval);\n        ret.Set(parent, constraintToEval, variableToEval, variableDoneEval);\n        return ret;\n    }\n    // For DummyParentNode only.\n    constructor(dummyConstraint) {\n        this.ConstraintToEval = dummyConstraint;\n        this.Depth = -1;\n        // The first real node adds 1, so it starts at 0.\n    }\n    Set(parent, constraintToEval, variableToEval, variableDoneEval) {\n        this.Parent = parent;\n        this.ConstraintToEval = constraintToEval;\n        this.VariableToEval = variableToEval;\n        this.VariableDoneEval = variableDoneEval;\n        this.Depth = 0;\n        this.ChildrenHaveBeenPushed = false;\n        constraintToEval.Lagrangian = 0;\n        return this;\n    }\n    get IsLeftToRight() {\n        return this.VariableToEval === this.ConstraintToEval.Right;\n    }\n    toString() {\n        return String.Format('{0} {1}{2} - {3}{4} ({5})', '', this.IsLeftToRight ? '' : '*', this.ConstraintToEval.Left.Name, this.IsLeftToRight ? '*' : '', this.ConstraintToEval.Right.Name, this.Depth);\n    }\n}\n//# sourceMappingURL=DfDvNode.js.map","// Per-instance parameters for ProjectionSolver.Solver.Solve().\nexport class Parameters {\n    // Constructor.\n    constructor() {\n        this.GapTolerance = 0.0001;\n        this.QpscConvergenceEpsilon = 1e-5;\n        this.QpscConvergenceQuotient = 1e-6;\n        this.OuterProjectIterationsLimit = -1;\n        this.InnerProjectIterationsLimit = -1;\n        this.TimeLimit = -1;\n        this.Advanced = new AdvancedParameters();\n    }\n    // Deep-copy the AdvancedParameters.\n    Clone() {\n        const newParams = this.MemberwiseClone();\n        newParams.Advanced = this.Advanced.Clone();\n        return newParams;\n    }\n    MemberwiseClone() {\n        const par = new Parameters();\n        par.GapTolerance = this.GapTolerance;\n        par.QpscConvergenceEpsilon = this.QpscConvergenceEpsilon;\n        par.QpscConvergenceQuotient = this.QpscConvergenceQuotient;\n        par.OuterProjectIterationsLimit = this.OuterProjectIterationsLimit;\n        par.InnerProjectIterationsLimit = this.InnerProjectIterationsLimit;\n        par.TimeLimit = this.TimeLimit;\n        return par;\n    }\n}\n// end struct Parameters\n// Parameter specification for advanced options.\nexport class AdvancedParameters {\n    // Constructor.\n    constructor() {\n        this.ForceQpsc = false;\n        this.ScaleInQpsc = true;\n        this.MinSplitLagrangianThreshold = -1e-7;\n        this.UseViolationCache = true;\n        this.ViolationCacheMinBlocksDivisor = 10;\n        this.ViolationCacheMinBlocksCount = 100;\n    }\n    // Shallow-copy the object (there is nothing requiring deep-copy).\n    Clone() {\n        const ret = new AdvancedParameters();\n        ret.ForceQpsc = this.ForceQpsc;\n        ret.ScaleInQpsc = this.ScaleInQpsc;\n        ret.MinSplitLagrangianThreshold = this.MinSplitLagrangianThreshold;\n        ret.UseViolationCache = this.UseViolationCache;\n        ret.ViolationCacheMinBlocksDivisor = this.ViolationCacheMinBlocksDivisor;\n        ret.ViolationCacheMinBlocksCount = this.ViolationCacheMinBlocksCount;\n        return ret;\n    }\n}\n//# sourceMappingURL=Parameters.js.map","// Store original weight to be restored when done.  With the ability to re-Solve() after\n// updating constraint gaps, we must restore DesiredPos as well.\nexport class QpscVar {\n    constructor(v) {\n        this.Variable = v;\n        this.OrigWeight = v.Weight;\n        this.OrigScale = v.Scale;\n        this.OrigDesiredPos = this.Variable.DesiredPos;\n    }\n}\nclass MatrixCell {\n    constructor(w, index) {\n        this.Value = w;\n        this.Column = index;\n    }\n}\nexport class Qpsc {\n    constructor(solverParameters, cVariables) {\n        // Array of variables, for perf (avoid nested block/variable Array<> iteration)\n        this.newMatrixRow = new Array();\n        // If true we're on our first call to Project\n        // Holds the value of f(x) = yQ'y + b'y as computed on the last iteration; used to test for\n        // convergence and updated before HasConverged() returns.\n        this.previousFunctionValue = Number.MAX_VALUE;\n        this.solverParameters = solverParameters;\n        this.matrixQ = new Array(cVariables).fill(0);\n        this.vectorWiDi = new Array(cVariables).fill(0);\n        this.vectorQpscVars = new Array(cVariables).fill(0);\n        this.gradientVector = new Array(cVariables).fill(0);\n        this.vectorQg = new Array(cVariables).fill(0);\n        this.vectorPrevY = new Array(cVariables).fill(0);\n        this.vectorCurY = new Array(cVariables).fill(0);\n    }\n    //\n    // solver.SolveQpsc drives the Qpsc instance as follows:\n    // Initialization:\n    //    Qpsc qpsc = new Qpsc(numVariables);\n    //    foreach (variable in (foreach block))\n    //       qpsc.AddVariable(variable)\n    //    qpsc.VariablesComplete()\n    // Per iteration:\n    //    if (!qpsc.PreProject()) break;\n    //    solver.SplitBlocks()\n    //    solver.Project()\n    //    if (!qpsc.PostProject()) break;\n    // Done:\n    //    qpsc.ProjectComplete()\n    AddVariable(variable) {\n        /*Assert.assert(\n          this.matrixQ[variable.Ordinal] == null  &&\n            this.vectorQpscVars[variable.Ordinal].Variable == null ,\n          'variable.Ordinal already exists',\n        )*/\n        this.isFirstProjectCall = true;\n        // This is the weight times desired position, multiplied by 2.0 per the partial derivative.\n        // We'll use this to keep as close as possible to the desired position on each iteration.\n        this.vectorWiDi[variable.Ordinal] = 2 * (variable.Weight * variable.DesiredPos) * -1;\n        // Temporarily hijack vectorPrevY for use as scratch storage, to handle duplicate\n        // neighbor pairs (take the highest weight).\n        // Sum the weight for cell i,i (the diagonal).\n        this.vectorPrevY[variable.Ordinal] = variable.Weight;\n        if (null != variable.Neighbors) {\n            for (const neighborWeightPair of variable.Neighbors) {\n                // We should already have verified this in AddNeighbourPair.\n                /*Assert.assert(\n                  neighborWeightPair.Neighbor.Ordinal !== variable.Ordinal,\n                  'self-neighbors are not allowed',\n                )*/\n                // For the neighbor KeyValuePairs, Key === neighboring variable and Value === relationship\n                // weight.  If we've already encountered this pair then we'll sum the relationship weights, under\n                // the assumption the caller will be doing something like creating edges for different reasons,\n                // and multiple edges should be like rubber bands, the sum of the strengths.  Mathematica also\n                // sums duplicate weights.\n                // Per above comments:\n                //     First the diagonal entries: A[i][i] = wi + Sum(wij for every neighbor j of i).\n                this.vectorPrevY[variable.Ordinal] = this.vectorPrevY[variable.Ordinal] + neighborWeightPair.Weight;\n                //     Then the off diagonal entries: A[i][j] = -Sum(wij for time j is a neighbor of i).\n                this.vectorPrevY[neighborWeightPair.Neighbor.Ordinal] =\n                    this.vectorPrevY[neighborWeightPair.Neighbor.Ordinal] - neighborWeightPair.Weight;\n            }\n        }\n        // endif null !=  variable.Neighbors\n        // Add the sparse row to the matrix (all non-zero slots of vectorPrevY are weights to that neighbor).\n        for (let ii = 0; ii < this.vectorPrevY.length; ii++) {\n            if (0 !== this.vectorPrevY[ii]) {\n                // The diagonal must be > 0 and off-diagonal < 0.\n                /*Assert.assert(\n                  (ii === variable.Ordinal) === this.vectorPrevY[ii] > 0,\n                  'Diagonal must be > 0.0',\n                )*/\n                // All 'A' cells must be 2*(summed weights).\n                this.newMatrixRow.push(new MatrixCell(this.vectorPrevY[ii] * 2, ii));\n                this.vectorPrevY[ii] = 0;\n            }\n        }\n        this.matrixQ[variable.Ordinal] = Array.from(this.newMatrixRow);\n        this.newMatrixRow = [];\n        this.vectorQpscVars[variable.Ordinal] = new QpscVar(variable);\n        // For the non-Qpsc loop, we consider weights in block reference-position calculation.\n        // Here, we have that in vectorWiDi which we use in calculating gradient and alpha, which\n        // in turn we use to set the gradient-stepped desiredPos.  So turn it off for the duration\n        // of Qpsc - we restore it in QpscComplete().\n        variable.Weight = 1;\n    }\n    // end AddVariable()\n    VariablesComplete() {\n        for (const qvar of this.vectorQpscVars) {\n            const variable = qvar.Variable;\n            for (const cell of this.matrixQ[variable.Ordinal]) {\n                if (cell.Column === variable.Ordinal) {\n                    if (this.solverParameters.Advanced.ScaleInQpsc) {\n                        variable.Scale = 1 / Math.sqrt(Math.abs(cell.Value));\n                        if (!Number.isFinite(variable.Scale)) {\n                            variable.Scale = 1;\n                        }\n                        // This is the y = Sx step from the Scaling paper.\n                        variable.Scale;\n                        // This is the b' <- Sb step from the Scaling paper\n                        this.vectorWiDi[variable.Ordinal] = this.vectorWiDi[variable.Ordinal] * variable.Scale;\n                    }\n                    // This is needed for block re-initialization.\n                    this.vectorCurY[variable.Ordinal] = variable.ActualPos;\n                    variable.DesiredPos = variable.ActualPos;\n                }\n            }\n        }\n        if (!this.solverParameters.Advanced.ScaleInQpsc) {\n            return;\n        }\n        // Now convert mxQ to its scaled form S#QS (noting that the transform of a diagonal matrix S is S\n        // so this is optimized), and we've made the S matrix such that Q[i][i] is 1.  The result is in-place\n        // conversion of Q to scaledQ s.t.\n        //   for all ii\n        //      for all jj\n        //         if ii === jj, scaledQ[ii][jj] = 1\n        //         else         scaledQ[ii][jj] = Q[ii][jj] * var[ii].scale * var[jj].scale\n        // /\n        for (let rowNum = 0; rowNum < this.matrixQ.length; rowNum++) {\n            const row = this.matrixQ[rowNum];\n            for (let sparseCol = 0; sparseCol < row.length; sparseCol++) {\n                if (row[sparseCol].Column === rowNum) {\n                    row[sparseCol].Value = 1;\n                }\n                else {\n                    // Diagonal on left scales rows [SQ], on right scales columns [QS].\n                    row[sparseCol].Value =\n                        row[sparseCol].Value * (this.vectorQpscVars[rowNum].Variable.Scale * this.vectorQpscVars[row[sparseCol].Column].Variable.Scale);\n                }\n            }\n        }\n    }\n    // end VariablesComplete()\n    // Called by SolveQpsc before the split/project phase.  Returns false if the difference in the\n    // function value on the current vs. previous iteration is sufficiently small that we're done.\n    // @@PERF: Right now this is distinct matrix/vector operations.  Profiling shows most time\n    // in Qpsc is taken by MatrixVectorMultiply.  We could gain a bit of performance by combining\n    // some things but keep it simple unless that's needed.\n    PreProject() {\n        if (this.isFirstProjectCall) {\n            // Due to MergeEqualityConstraints we may have moved some of the variables.  This won't\n            // affect feasibility since QpscMakeFeasible would already have ensured that any unsatisfiable\n            // constraints are so marked.\n            for (const qvar of this.vectorQpscVars) {\n                this.vectorCurY[qvar.Variable.Ordinal] = qvar.Variable.ActualPos;\n            }\n        }\n        //\n        // Compute: g = Q'y + b' (in the Scaling paper terminology)\n        //\n        // g(radient) = Q'y...\n        this.MatrixVectorMultiply(this.vectorCurY, this.gradientVector);\n        // If we've minimized the goal function (far enough), we're done.\n        // This uses the Q'y value we've just put into gradientVector and tests the goal-function value\n        // to see if it is sufficiently close to the previous value to be considered converged.\n        if (this.HasConverged()) {\n            return false;\n        }\n        // ...g = Q'y + b'\n        Qpsc.VectorVectorAdd(this.gradientVector, this.vectorWiDi, this.gradientVector);\n        //\n        // Compute: alpha = g#g / g#Q'g  (# === transpose)\n        //\n        const alphaNumerator = Qpsc.VectorVectorMultiply(this.gradientVector, this.gradientVector);\n        // Compute numerator of stepsize\n        let alphaDenominator = 0;\n        if (0 !== alphaNumerator) {\n            this.MatrixVectorMultiply(this.gradientVector, this.vectorQg);\n            alphaDenominator = Qpsc.VectorVectorMultiply(this.vectorQg, this.gradientVector);\n        }\n        if (0 === alphaDenominator) {\n            return false;\n        }\n        const alpha = alphaNumerator / alphaDenominator;\n        //\n        // Store off the current position as the previous position (the paper's y^ (y-hat)),\n        // then calculate the new current position by subtracting the (gradient * alpha)\n        // from it and update the Variables' desired position.\n        //\n        Qpsc.VectorCopy(this.vectorPrevY, this.vectorCurY);\n        // Update d(esiredpos) = y - alpha*g\n        // Use vectorCurY as temp as it is not used again here and is updated at start of PostProject.\n        Qpsc.VectorScaledVectorSubtract(this.vectorPrevY, alpha, this.gradientVector, this.vectorCurY);\n        for (let ii = 0; ii < this.vectorCurY.length; ii++) {\n            this.vectorQpscVars[ii].Variable.DesiredPos = this.vectorCurY[ii];\n        }\n        return true;\n    }\n    // end PreProject()\n    // Called by SolveQpsc after the split/project phase.\n    PostProject() {\n        //\n        // Update our copy of current positions (y-bar from the paper) and deltaY (p in the Scaling paper; y-bar minus y-hat).\n        //\n        for (const qvar of this.vectorQpscVars) {\n            this.vectorCurY[qvar.Variable.Ordinal] = qvar.Variable.ActualPos;\n        }\n        // vectorCurY temporarily becomes the p-vector from the Scaling paper since we don't use the \"current\"\n        // position otherwise, until we reset it at the end.\n        Qpsc.VectorVectorSubtract(this.vectorPrevY, this.vectorCurY, this.vectorCurY);\n        //\n        // Compute: Beta = min(g#p / p#Qp, 1)\n        //\n        const betaNumerator = Qpsc.VectorVectorMultiply(this.gradientVector, this.vectorCurY);\n        // Compute numerator of stepsize\n        let beta = 0;\n        if (0 !== betaNumerator) {\n            // Calculate Qp first (matrix ops are associative so (AB)C === A(BC), so calculate the rhs first\n            // with MatrixVectorMultiply).  Temporarily hijack vectorQg for this operation.\n            this.MatrixVectorMultiply(this.vectorCurY, this.vectorQg);\n            // Now p#(Qp).\n            const betaDenominator = Qpsc.VectorVectorMultiply(this.vectorQg, this.vectorCurY);\n            // Dividing by almost-0 would yield a huge value which we'd cap at 1.0 below.\n            beta = 0 === betaDenominator ? 1 : betaNumerator / betaDenominator;\n            if (beta > 1) {\n                // Note:  With huge ranges, beta is >>1 here - like 50 or millions.  This is expected as\n                // we're dividing by p#Qp where p is potentially quite small.\n                beta = 1;\n            }\n            else if (beta < 0) {\n                // Setting it above 0.0 can move us away from convergence, so set it to 0.0 which leaves\n                // vectorCurY unchanged from vectorPrevY and we'll terminate if there are no splits/violations.\n                // If we were close to convergence in preProject, we could have a significantly negative\n                // beta here, which means we're basically done unless split/project still have stuff to do.\n                beta = 0;\n            }\n        }\n        // Beta numerator is nonzero\n        // Update the \"Qpsc-local\" copy of the current positions for use in the next loop's PreProject().\n        Qpsc.VectorScaledVectorSubtract(this.vectorPrevY, beta, this.vectorCurY, this.vectorCurY);\n        this.isFirstProjectCall = false;\n        return beta > 0;\n    }\n    // end PostProject()\n    QpscComplete() {\n        // Restore original desired position and unscale the actual position.\n        for (const qvar of this.vectorQpscVars) {\n            qvar.Variable.Weight = qvar.OrigWeight;\n            qvar.Variable.DesiredPos = qvar.OrigDesiredPos;\n            if (this.solverParameters.Advanced.ScaleInQpsc) {\n                // This multiplication essentially does what Constraint.Violation does, so the \"satisfied\" state\n                // of constraints won't be changed.\n                qvar.Variable.ActualPos = qvar.Variable.ActualPos * qvar.Variable.Scale;\n                qvar.Variable.Scale = qvar.OrigScale;\n            }\n        }\n        // This was updated to the final function value before HasConverged returned.\n        return this.previousFunctionValue;\n    }\n    HasConverged() {\n        //\n        // Compute the function value relative to the previous iteration to test convergence:\n        //     (x#Ax)/2 + bx + (w d).d       Note: final term is from Tim's Mathematica\n        // where the last term (w d).d is constant and, because we only test decreasing value,\n        // can therefore be omitted.\n        //\n        // We don't need to do the Ax operation as this is done as part of PreProject which has\n        // already put this into gradientVector.\n        //\n        const currentFunctionValue = this.GetFunctionValue(this.vectorCurY);\n        // If this is not our first PreProject call, test for convergence.\n        let fConverged = false;\n        if (!this.isFirstProjectCall) {\n            // Check for convergence.  We are monotonically decreasing so prev should be > cur\n            // with some allowance for rounding error.\n            const diff = this.previousFunctionValue - currentFunctionValue;\n            let quotient = 0;\n            if (diff !== 0) {\n                const divisor = 0 !== this.previousFunctionValue ? this.previousFunctionValue : currentFunctionValue;\n                quotient = Math.abs(diff / divisor);\n            }\n            if (Math.abs(diff) < this.solverParameters.QpscConvergenceEpsilon ||\n                Math.abs(quotient) < this.solverParameters.QpscConvergenceQuotient) {\n                fConverged = true;\n            }\n        }\n        // endif !isFirstProjectCall\n        this.previousFunctionValue = currentFunctionValue;\n        return fConverged;\n    }\n    GetFunctionValue(positions) {\n        // (x#Ax)/2...\n        const value = Qpsc.VectorVectorMultiply(this.gradientVector, positions) / 2;\n        // (x'Ax)/2 + bx...\n        return value + Qpsc.VectorVectorMultiply(this.vectorWiDi, positions);\n    }\n    // Returns the dot product of two column vectors (with an \"implicit transpose\").\n    static VectorVectorMultiply(lhs, rhs) {\n        // Do not use LINQ's Sum, it slows end-to-end by over 10%.\n        let sum = 0;\n        for (let ii = 0; ii < lhs.length; ii++) {\n            sum = sum + lhs[ii] * rhs[ii];\n        }\n        return sum;\n    }\n    // Multiplies matrixQ with the column vector rhs leaving the result in column vector in result[].\n    MatrixVectorMultiply(rhs, result) {\n        // The only matrix we have here is (sparse) matrixQ so it's not a parameter.\n        let rowIndex = 0;\n        for (const row of this.matrixQ) {\n            // Do not use LINQ's Sum, it slows end-to-end by over 10%.\n            let sum = 0;\n            for (const cell of row) {\n                sum = sum + cell.Value * rhs[cell.Column];\n            }\n            result[rowIndex++] = sum;\n        }\n    }\n    // Returns the addition result in result[] (which may be lhs or rhs or a different vector).\n    static VectorVectorAdd(lhs, rhs, result) {\n        for (let ii = 0; ii < lhs.length; ii++) {\n            result[ii] = lhs[ii] + rhs[ii];\n        }\n    }\n    // Returns the subtraction result in result[] (which may be lhs or rhs or a different vector).\n    static VectorVectorSubtract(lhs, rhs, result) {\n        for (let ii = 0; ii < lhs.length; ii++) {\n            result[ii] = lhs[ii] - rhs[ii];\n        }\n    }\n    // Same as VectorVectorSubtract except that rhs is multiplied by the scale value.\n    static VectorScaledVectorSubtract(lhs, scale, rhs, result) {\n        for (let ii = 0; ii < lhs.length; ii++) {\n            result[ii] = lhs[ii] - scale * rhs[ii];\n        }\n    }\n    // Copies src to dest\n    static VectorCopy(dest, src) {\n        for (let ii = 0; ii < src.length; ii++) {\n            dest[ii] = src[ii];\n        }\n    }\n}\n//# sourceMappingURL=QPSC.js.map","// Per-instance results from ProjectionSolver.Solver.Solve().\nexport class Solution {\n    constructor() {\n        // The only failure condition is if there are one or more unsatisfiable constraints, such as cycles\n        // or mutually exclusive equality constraints.\n        this.NumberOfUnsatisfiableConstraints = 0;\n        // The number of times the outer Project/Split loop was run.\n        this.OuterProjectIterations = 0;\n        // The number of times Project iterated internally; divide by OuterProjectIterations to get the average\n        // inner iterations per outer iteration; see also MinInnerProjectIterations and MaxInnerProjectIterations.\n        this.InnerProjectIterationsTotal = 0;\n        // The minimum number of times Project iterated internally for any outer Project iterations.\n        this.MinInnerProjectIterations = 0;\n        // The maximum number of times Project iterated internally for any outer Project iterations.\n        this.MaxInnerProjectIterations = 0;\n        // The maximum depth of a constraint tree.\n        this.MaxConstraintTreeDepth = 0;\n        // The final value of the goal function.\n        this.GoalFunctionValue = 0;\n        // If true, the function ended due to TimeLimit being exceeded.\n        this.TimeLimitExceeded = false;\n        // If true, the function ended due to OuterProjectIterationsLimit being exceeded.\n        this.OuterProjectIterationsLimitExceeded = false;\n        // If true, a call to Project ended early due to InnerProjectIterationsLimit being exceeded.\n        // The result may be nonfeasible.\n        this.InnerProjectIterationsLimitExceeded = false;\n    }\n    // Indicates whether one or more execution limits were exceeded.\n    get ExecutionLimitExceeded() {\n        return this.TimeLimitExceeded || this.OuterProjectIterationsLimitExceeded || this.InnerProjectIterationsLimitExceeded;\n    }\n    // Shallow-copy everything, including the contained list.\n    Clone() {\n        const r = new Solution();\n        r.GoalFunctionValue = this.GoalFunctionValue;\n        r.InnerProjectIterationsLimitExceeded = this.InnerProjectIterationsLimitExceeded;\n        r.InnerProjectIterationsTotal = this.InnerProjectIterationsTotal;\n        r.MaxConstraintTreeDepth = this.MaxConstraintTreeDepth;\n        r.OuterProjectIterations = this.OuterProjectIterations;\n        r.OuterProjectIterationsLimitExceeded = this.OuterProjectIterationsLimitExceeded;\n        r.AlgorithmUsed = this.AlgorithmUsed;\n        r.NumberOfUnsatisfiableConstraints = this.NumberOfUnsatisfiableConstraints;\n        r.MaxInnerProjectIterations = this.MaxInnerProjectIterations;\n        return r;\n    }\n}\n//# sourceMappingURL=Solution.js.map","// A Solver is the driving class that collects Variables and Constraints and then generates a\n// solution that minimally satisfies the constraints.\nimport { greaterDistEps } from '../../utils/compare';\nimport { flattenArray } from '../../utils/setOperations';\nimport { Block } from './Block';\nimport { BlockVector } from './BlockVector';\nimport { Constraint } from './Constraint';\nimport { ConstraintVector } from './ConstraintVector';\nimport { Parameters } from './Parameters';\nimport { Qpsc } from './QPSC';\nimport { Solution } from './Solution';\nimport { SolverAlgorithm } from './SolverAlgorithm';\nimport { Variable } from './Variable';\nimport { ViolationCache } from './ViolationCache';\nclass ConstraintListForVariable {\n    constructor(constraints, numberOfLeftConstraints) {\n        // The number of Constraints that are LeftConstraints for the variable keying this object.\n        this.NumberOfLeftConstraints = 0;\n        this.Constraints = constraints;\n        this.NumberOfLeftConstraints = numberOfLeftConstraints;\n    }\n}\nexport class Solver {\n    constructor() {\n        // Notes about hierarchy:\n        //  1.  Each Variable is initially assigned to its own block, and subsequently MergeBlocks()\n        //      and SplitBlocks() may change its block membership, but the variable is always in one\n        //      and only one block, so we enumerate variables by enumerating blocks and variables.\n        //  2.  The list of (active and inactive) constraints is within each block's variable list;\n        //      we simply enumerate each block's LeftConstraints.\n        this.allBlocks = new BlockVector();\n        // To speed up SearchAllConstraints, have a single Array in addition to the per-block\n        // variable Lists (Array indexing is faster than Array).\n        this.allConstraints = new ConstraintVector();\n        this.numberOfConstraints = 0;\n        // Updated on AddConstraint; used to create AllConstraints\n        this.numberOfVariables = 0;\n        // Also for speed, a separate list of Equality constraints (which we expect to be fairly rare).\n        this.equalityConstraints = new Array();\n        // Also for speed, store variables -> constraint list while we load, then convert this into\n        // arrays when we call Solve().  The members are Array of constraints, and number of Left constraints.\n        this.loadedVariablesAndConstraintLists = new Map();\n        // We bundle up the constraints first, so we can use Array rather than Array iteration for speed.\n        // To make the code cleaner (not having to check for NULL all over the place) use an empty Array/Array\n        // for Variables' constraint Lists/Arrays, and to help memory efficiency, use a single object.\n        this.emptyConstraintList = new Array(0);\n        // For long-lived Variable objects\n        // For UpdateConstraint(), we want to buffer up the changes so variable values are not changed\n        // by doing an immediate Block.Split which updates the Block's ReferencePos.\n        this.updatedConstraints = new Array();\n        // For caching violations to improve GetMaxViolatedConstraint performance.\n        this.violationCache = new ViolationCache();\n        this.violationCacheMinBlockCutoff = 0;\n        this.nextVariableOrdinal = 0;\n        // May be overridden by the caller's Parameters object passed to Solve.\n        this.solverParams = new Parameters();\n        // Solution results - will be cloned to return to caller.\n        this.solverSolution = new Solution();\n    }\n    get IsQpsc() {\n        return this.hasNeighbourPairs || this.solverParams.Advanced.ForceQpsc;\n    }\n    // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.\n    // a tag or other user data - can be null\n    // The position of the variable, such as the coordinate of a node along one axis.\n    // <returns>The created variable</returns>\n    AddVariableAN(userData, desiredPos) {\n        return this.AddVariableANNN(userData, desiredPos, 1, 1);\n    }\n    // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.\n    // a tag or other user data - can be null\n    // The position of the variable, such as the coordinate of a node along one axis.\n    // The weight of the variable (makes it less likely to move if the weight is high).\n    AddVariableANN(userData, desiredPos, weight) {\n        return this.AddVariableANNN(userData, desiredPos, weight, 1);\n    }\n    // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.\n    // a tag or other user data - can be null\n    // The position of the variable, such as the coordinate of a node along one axis.\n    // The weight of the variable (makes it less likely to move if the weight is high).\n    // The scale of the variable, for improving convergence.\n    // <returns>The created variable</returns>\n    AddVariableANNN(userData, desiredPos, weight, scale) {\n        // @@DCR \"Incremental Solving\": For now we disallow this; if we support it, we'll need to\n        // retain loadedVariablesAndConstraintLists, store up the added Variables (TryGetValue and if that fails add\n        // the existing variable, then iterate through variables with new Constraints and replace the arrays.\n        // Also remember to check for emptyConstraintList - don't add to it.\n        if (!this.allConstraints.IsEmpty) {\n            throw new Error('Cannot add Variables or Constraints once Solve() has been called');\n        }\n        const varNew = new Variable(this.nextVariableOrdinal++, userData, desiredPos, weight, scale);\n        const block = new Block(varNew, this.allConstraints);\n        varNew.Block = block;\n        this.allBlocks.Add(block);\n        this.numberOfVariables++;\n        // Initialize the variable in the dictionary with a null list and zero left constraints.\n        this.loadedVariablesAndConstraintLists.set(varNew, new ConstraintListForVariable(new Array(), 0));\n        return varNew;\n    }\n    // end AddVariable()\n    // Must be called before Solve() if the caller has updated variable Initial positions; this\n    // reconciles internals such as Block.ReferencePos.\n    UpdateVariables() {\n        // Although the name is \"UpdateVariables\", that's just for the caller to not need to know\n        // about the internals; this really is updating the blocks after the variables have already\n        // been updated one at a time. (This doesn't need to be called if constraints are re-gapped\n        // while variable positions are unchanged; Solve() checks for that).\n        for (const block of this.allBlocks.Vector) {\n            block.UpdateReferencePos();\n        }\n    }\n    // end UpdateVariables()\n    // This enumerates all Variables created by AddVariable.\n    get Variables() {\n        return flattenArray(this.allBlocks.Vector, (block) => block.Variables);\n    }\n    // The number of variables added to the Solver.\n    get VariableCount() {\n        return this.numberOfVariables;\n    }\n    // This enumerates all Constraints created by AddConstraint (which in turn may have\n    // been called from OverlapRemoval.ConstraintGenerator.Generate()).\n    *Constraints() {\n        if (!this.allConstraints.IsEmpty) {\n            // Solve() has been called.\n            for (const constraint of this.allConstraints.Vector) {\n                yield constraint;\n            }\n        }\n        else {\n            // Solve() has not yet been called.\n            for (const variable of this.loadedVariablesAndConstraintLists.keys()) {\n                const constraintsForVar = this.loadedVariablesAndConstraintLists.get(variable);\n                if (null != constraintsForVar.Constraints) {\n                    // Return all variables in the LeftConstraints list for each variable.\n                    const numConstraints = constraintsForVar.Constraints.length;\n                    // Cache for perf\n                    for (let ii = 0; ii < numConstraints; ii++) {\n                        const constraint = constraintsForVar.Constraints[ii];\n                        if (variable === constraint.Left) {\n                            yield;\n                            return constraint;\n                        }\n                    }\n                }\n            }\n        }\n        // endifelse (!AllConstraints.Empty)\n    }\n    // end Constraints property\n    // The number of constraints added to the Solver.\n    get ConstraintCount() {\n        return this.numberOfConstraints;\n    }\n    // Add a constraint 'left + gap' is equal to right\n    AddEqualityConstraint(left, right, gap) {\n        return this.AddConstraintVVNB(left, right, gap, true);\n    }\n    // Add a constraint 'left + gap' is less than or equal to 'right'\n    // The gap required between the variables.\n    // <returns>The new constraint.</returns>\n    AddConstraintVVNB(left, right, gap, isEquality) {\n        // @@DCR \"Incremental Solving\": See notes in AddVariable; for now, this is disallowed.\n        if (!this.allConstraints.IsEmpty) {\n            throw new Error('Cannot add Variables or Constraints once Solve() has been called');\n        }\n        if (left === right) {\n            throw new Error('Cannot add a constraint between a variable and itself');\n        }\n        // Get the dictionary entries so we can store these until Solve() is called.  kvp.Key === lstConstraints,\n        // kvp.Value === number of constraints in lstConstraints that are LeftConstraints for the variable.\n        // kvpConstraintsForVar(Left|Right) are bidirectional for that variable, but we're operating only on\n        // varLeft's LeftConstraints and varRight's RightConstraints; this is slightly more complicated logic\n        // than just having two Lists, but for large numbers of variables, having all constraints in a single\n        // list is more memory-efficient.\n        const constraintsForLeftVar = this.loadedVariablesAndConstraintLists.get(left);\n        const constraintsForRightVar = this.loadedVariablesAndConstraintLists.get(right);\n        // Now create the new constraint and update the structures.  For varLeft, we must also update the\n        // left-variable count and that requires another lookup to update the structure in the Map\n        // since it's a value type so a copy was returned by-value from Map lookup.\n        const constraint = Constraint.constructorVVNB(left, right, gap, isEquality);\n        // Structure update requires replacing the full structure.\n        this.loadedVariablesAndConstraintLists.set(left, new ConstraintListForVariable(constraintsForLeftVar.Constraints, constraintsForLeftVar.NumberOfLeftConstraints + 1));\n        constraintsForLeftVar.Constraints.push(constraint);\n        constraintsForRightVar.Constraints.push(constraint);\n        this.numberOfConstraints++;\n        if (isEquality) {\n            this.equalityConstraints.push(constraint);\n        }\n        return constraint;\n    }\n    // Add a constraint 'left + gap' is less than or equal to 'right'\n    // The gap required between the variables.\n    // <returns>The new constraint.</returns>\n    AddConstraint(left, right, gap) {\n        return this.AddConstraintVVNB(left, right, gap, false);\n    }\n    // Register an update to a constraint's gap; this defers the actual update until Solve() is called.\n    // The constraint to update\n    // The new gap\n    SetConstraintUpdate(constraint, gap) {\n        // Defer this to the Solve() call, so the variables' positions are not altered by doing a\n        // Block.Split here (which updates Block.ReferencePos, upon which Variable.(Scaled)ActualPos relies).\n        if (gap !== constraint.Gap) {\n            this.updatedConstraints.push([constraint, gap]);\n        }\n    }\n    // Add a pair of connected variables for goal functions of the form (x1-x2)^2.  These are\n    // minimally satisfied, along with the default (x-i)^2 goal function, while also satisfying\n    // all constraints.\n    // The first variable\n    // The second variable\n    // The weight of the relationship\n    AddNeighborPair(variable1, variable2, relationshipWeight) {\n        if (relationshipWeight <= 0 || Number.isNaN(relationshipWeight) || !Number.isFinite(relationshipWeight)) {\n            throw new Error('relationshipWeight');\n        }\n        if (variable1 === variable2) {\n            throw new Error();\n        }\n        variable1.AddNeighbor(variable2, relationshipWeight);\n        variable2.AddNeighbor(variable1, relationshipWeight);\n        this.hasNeighbourPairs = true;\n    }\n    // end AddNeighborPair()\n    // Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints\n    // along this axis.  This overload uses default solution parameter values.\n    // <returns>A Solution object.</returns>\n    Solve() {\n        return this.SolvePar(null);\n    }\n    // Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints\n    // along this axis.  This overload takes a parameter specification.\n    // Solution-generation options.\n    // <returns>The only failure condition is if there are one or more unsatisfiable constraints, such as cycles\n    //         or mutually exclusive equality constraints; if these are encountered, a list of lists of these\n    //         constraints is returned, where each list contains a single cycle, which may be of length one for\n    //         unsatisfiable equality constraints.  Otherwise, the return value is null.</returns>\n    SolvePar(solverParameters) {\n        if (solverParameters) {\n            this.solverParams = solverParameters.Clone();\n        }\n        // Reset some parameter defaults to per-solver-instance values.\n        if (this.solverParams.OuterProjectIterationsLimit < 0) {\n            // If this came in 0, it stays that way, and there is no limit.  Otherwise, set it to a value\n            // reflecting the expectation of convergence roughly log-linearly in the number of variables.\n            this.solverParams.OuterProjectIterationsLimit = 100 * (Math.floor(Math.log2(this.numberOfVariables)) + 1);\n        }\n        if (this.solverParams.InnerProjectIterationsLimit < 0) {\n            // If this came in 0, it stays that way, and there is no limit.  Otherwise, assume that for\n            // any pass, each constraint may be violated (most likely this happens only on the first pass),\n            // and add some extra based upon constraint count.  Now that we split and retry on unsatisfied\n            // constraints, assume that any constraint may be seen twice on a pass.\n            this.solverParams.InnerProjectIterationsLimit =\n                this.numberOfConstraints * 2 + 100 * (Math.max(0, Math.floor(Math.log2(this.numberOfConstraints))) + 1);\n        }\n        // ReSolving can be done for updated constraints.\n        const isReSolve = !this.allConstraints.IsEmpty;\n        this.CheckForUpdatedConstraints();\n        this.solverSolution = new Solution();\n        this.solverSolution.MinInnerProjectIterations = Number.MAX_VALUE;\n        this.allConstraints.MaxConstraintTreeDepth = 0;\n        this.allConstraints.SolverParameters = this.solverParams;\n        //\n        // First set up all the  stuff we'll use for solutions.\n        //\n        // If no constraints have been loaded, there's nothing to do.  Two distinct variables\n        // are required to create a constraint, so this also ensures a minimum number of variables.\n        if (this.numberOfConstraints === 0) {\n            // For Qpsc, we may have neighbours but no constraints.\n            if (!this.IsQpsc) {\n                return this.solverSolution.Clone();\n            }\n        }\n        else if (!isReSolve) {\n            this.SetupConstraints();\n        }\n        // This is the number of unsatisfiable constraints encountered.\n        this.allConstraints.NumberOfUnsatisfiableConstraints = 0;\n        // Merge Equality constraints first.  These do not do any constraint-splitting, and thus\n        // remain in the same blocks, always satisfied, regardless of whether we're solving the full\n        // Qpsc or the simpler loop.\n        this.MergeEqualityConstraints();\n        // Prepare for timeout checking.\n        //\n        // Done with initial setup.  Now if we have neighbour pairs, we do the full SolveQpsc logic\n        // complete with Gradient projection.  Otherwise, we have a much simpler Project/Split loop.\n        //\n        if (this.IsQpsc) {\n            this.SolveQpsc();\n        }\n        else {\n            this.SolveByStandaloneProject();\n            this.CalculateStandaloneProjectGoalFunctionValue();\n        }\n        // We initialized this to int.MaxValue so make sure it's sane if we didn't complete a Project iteration.\n        if (this.solverSolution.MinInnerProjectIterations > this.solverSolution.MaxInnerProjectIterations) {\n            // Probably this is 0.\n            this.solverSolution.MinInnerProjectIterations = this.solverSolution.MaxInnerProjectIterations;\n        }\n        // Done.  Caller will copy each var.ActualPos back to the Nodes.  If we had any unsatisfiable\n        // constraints, copy them back out to the caller.\n        this.solverSolution.NumberOfUnsatisfiableConstraints = this.allConstraints.NumberOfUnsatisfiableConstraints;\n        this.solverSolution.MaxConstraintTreeDepth = this.allConstraints.MaxConstraintTreeDepth;\n        return this.solverSolution.Clone();\n    }\n    // end Solve()\n    CheckForUpdatedConstraints() {\n        if (0 === this.updatedConstraints.length) {\n            return;\n        }\n        /*Assert.assert(\n          !this.allConstraints.IsEmpty,\n          'Cannot have updated constraints if AllConstraints is empty.',\n        )*/\n        // For Qpsc, all Block.ReferencePos values are based upon Variable.DesiredPos values, and the latter\n        // have been restored from what they were on the last Qpsc iteration to their initial values).\n        let mustReinitializeBlocks = this.IsQpsc;\n        for (const [key, value] of this.updatedConstraints) {\n            // Update the constraint, then split its block if it's active, so the next call to Solve()\n            // will start the merge/split cycle again.\n            const constraint = key;\n            constraint.UpdateGap(value);\n            if (!mustReinitializeBlocks && !constraint.IsEquality) {\n                this.SplitOnConstraintIfActive(constraint);\n                continue;\n            }\n            // Equality constraints must always be evaluated first and never split.\n            // If we have updated one we must reinitialize the block structure.\n            mustReinitializeBlocks = true;\n        }\n        this.updatedConstraints = [];\n        if (mustReinitializeBlocks) {\n            this.ReinitializeBlocks();\n        }\n    }\n    SplitOnConstraintIfActive(constraint) {\n        if (constraint.IsActive) {\n            // Similar handling as in SplitBlocks, except that we know which constraint we're splitting on.\n            const newSplitBlock = constraint.Left.Block.SplitOnConstraint(constraint);\n            if (null != newSplitBlock) {\n                this.allBlocks.Add(newSplitBlock);\n            }\n        }\n        // endif constraint.IsActive\n    }\n    SetupConstraints() {\n        // Optimize the lookup in SearchAllConstraints; create an array (which has faster\n        // iteration than Array).\n        this.allConstraints.Create(this.numberOfConstraints);\n        for (const variable of this.loadedVariablesAndConstraintLists.keys()) {\n            const constraintsForVar = this.loadedVariablesAndConstraintLists.get(variable);\n            const constraints = constraintsForVar.Constraints;\n            let numAllConstraints = 0;\n            let numLeftConstraints = 0;\n            let numRightConstraints = 0;\n            if (null != constraints) {\n                numAllConstraints = constraints.length;\n                numLeftConstraints = constraintsForVar.NumberOfLeftConstraints;\n                numRightConstraints = numAllConstraints - numLeftConstraints;\n            }\n            // Create the Variable's Constraint arrays, using the single emptyConstraintList for efficiency.\n            let leftConstraints = this.emptyConstraintList;\n            if (0 !== numLeftConstraints) {\n                leftConstraints = new Array(numLeftConstraints);\n            }\n            let rightConstraints = this.emptyConstraintList;\n            if (0 !== numRightConstraints) {\n                rightConstraints = new Array(numRightConstraints);\n            }\n            variable.SetConstraints(leftConstraints, rightConstraints);\n            // Now load the Variables' Arrays.  We're done with the loadedVariablesAndConstraintLists lists after this.\n            let leftConstraintIndex = 0;\n            let rightConstraintIndex = 0;\n            for (let loadedConstraintIndex = 0; loadedConstraintIndex < numAllConstraints; loadedConstraintIndex++) {\n                // numAllConstraints is 0 if null == constraints.\n                // ReSharper disable PossibleNullReferenceException\n                const loadedConstraint = constraints[loadedConstraintIndex];\n                // ReSharper restore PossibleNullReferenceException\n                if (variable === loadedConstraint.Left) {\n                    leftConstraints[leftConstraintIndex++] = loadedConstraint;\n                }\n                else {\n                    rightConstraints[rightConstraintIndex++] = loadedConstraint;\n                }\n            }\n            /*Assert.assert(\n              leftConstraintIndex === numLeftConstraints,\n              'leftConstraintIndex must === numLeftConstraints',\n            )*/\n            /*Assert.assert(\n              rightConstraintIndex === numRightConstraints,\n              'rightConstraintIndex must === numRightConstraints',\n            )*/\n            // Done with per-variable constraint loading.  Now load the big list of all constraints.\n            // All constraints are stored in a LeftConstraints array (and duplicated in a RightConstraints\n            // array), so just load the LeftConstraints into AllConstraints. Array.Foreach is optimized.\n            for (const constraint of variable.LeftConstraints) {\n                this.allConstraints.Add(constraint);\n            }\n        }\n        // this.allConstraints.Debug_AssertIsFull()\n        // Done with the dictionary now.\n        this.loadedVariablesAndConstraintLists.clear();\n        // If we don't have many blocks then the caching optimization's overhead may outweigh\n        // its benefit. Similarly, after blocks have merged past a certain point it's faster to\n        // just enumerate them all.  Initialize this to off.\n        this.violationCacheMinBlockCutoff = Number.MAX_VALUE;\n        if (this.solverParams.Advanced.UseViolationCache && this.solverParams.Advanced.ViolationCacheMinBlocksDivisor > 0) {\n            this.violationCacheMinBlockCutoff = Math.min(this.allBlocks.Count / this.solverParams.Advanced.ViolationCacheMinBlocksDivisor, this.solverParams.Advanced.ViolationCacheMinBlocksCount);\n        }\n    }\n    SolveByStandaloneProject() {\n        // Loop until we have no constraints with violations and no blocks are split.\n        // Note:  this functions differently from the loop-termination test in SolveQpsc, which tests the\n        // total movement resulting from Project() against some epsilon.  We do this differently here because\n        // we're not doing the Gradient portion of SolveQpsc, so we'll just keep going as long as we have any\n        // violations greater than the minimum violation we look for in GetMaxViolatedConstraint (and as long\n        // as we don't split any blocks whether or not we find such a violation).\n        for (;;) {\n            // Don't check the return of Project; defer the termination check to SplitBlocks.\n            // This also examines limits post-Project; because it happens pre-SplitBlocks it ensures\n            // a feasible stopping state.\n            if (!this.RunProject()) {\n                return;\n            }\n            // If SplitBlocks doesn't find anything to split then Project would do nothing.\n            if (!this.SplitBlocks()) {\n                break;\n            }\n        }\n    }\n    RunProject() {\n        this.solverSolution.OuterProjectIterations++;\n        this.Project();\n        // Examine limits post-Project but pre-SplitBlocks to ensure a feasible stopping state.\n        return !this.CheckForLimitsExceeded();\n    }\n    CheckForLimitsExceeded() {\n        // if (null !=  this.timeoutStopwatch) {\n        //  if (\n        //    this.timeoutStopwatch.ElapsedMilliseconds >= this.solverParams.TimeLimit\n        //  ) {\n        //    this.solverSolution.TimeLimitExceeded = true\n        //    return true\n        //  }\n        // }\n        if (this.solverParams.OuterProjectIterationsLimit > 0) {\n            if (this.solverSolution.OuterProjectIterations >= this.solverParams.OuterProjectIterationsLimit) {\n                this.solverSolution.OuterProjectIterationsLimitExceeded = true;\n                return true;\n            }\n        }\n        if (this.solverSolution.InnerProjectIterationsLimitExceeded) {\n            return true;\n        }\n        return false;\n    }\n    CalculateStandaloneProjectGoalFunctionValue() {\n        // Fill in the non-Qpsc Goal function value.  See Qpsc.HasConverged for details; this is a\n        // streamlined form of (x'Ax)/2 + bx here, where A has only the diagonals (as there are no\n        // neighbours) with 2*wi and b is a vector of -2*wi*di, and x is current position.\n        this.solverSolution.GoalFunctionValue = 0;\n        const numBlocks = this.allBlocks.Count;\n        // cache for perf\n        for (let i = 0; i < numBlocks; i++) {\n            const block = this.allBlocks.item(i);\n            const numVars = block.Variables.length;\n            for (let j = 0; j < numVars; j++) {\n                const variable = block.Variables[j];\n                // (x'Ax)/2\n                this.solverSolution.GoalFunctionValue += variable.Weight * (variable.ActualPos * variable.ActualPos);\n                // +bx\n                this.solverSolution.GoalFunctionValue -= 2 * (variable.Weight * (variable.DesiredPos * variable.ActualPos));\n            }\n        }\n    }\n    // Implements the full solve_QPSC from the Ipsep_Cola and Scaling papers.\n    SolveQpsc() {\n        this.solverSolution.AlgorithmUsed = this.solverParams.Advanced.ScaleInQpsc\n            ? SolverAlgorithm.QpscWithScaling\n            : SolverAlgorithm.QpscWithoutScaling;\n        if (!this.QpscMakeFeasible()) {\n            return;\n        }\n        // Initialize the Qpsc state, which also sets the scale for all variables (if we are scaling).\n        const qpsc = new Qpsc(this.solverParams, this.numberOfVariables);\n        for (const block of this.allBlocks.Vector) {\n            for (const variable of block.Variables) {\n                qpsc.AddVariable(variable);\n            }\n        }\n        qpsc.VariablesComplete();\n        this.ReinitializeBlocks();\n        this.MergeEqualityConstraints();\n        // this.VerifyConstraintsAreFeasible()\n        // Iterations\n        let foundSplit = false;\n        for (;;) {\n            //\n            // Calculate initial step movement.  We assume there will be some movement needed\n            // even on the first pass in the vast majority of cases.  This also tests convergence\n            // of the goal-function value; if it is sufficiently close to the previous iteration's\n            // result and the previous iteration did not split or encounter a violation, we're done.\n            //\n            if (!qpsc.PreProject() && !foundSplit) {\n                break;\n            }\n            //\n            // Split the blocks (if this the first time through the loop then all variables are in their\n            // own block except for any equality constraints, which we don't split; but we still need to\n            // have UpdateReferencePos called).\n            //\n            foundSplit = this.SplitBlocks();\n            // Examine limits post-Project to ensure a feasible stopping state.  We don't test for\n            // termination due to \"no violations found\" here, deferring that to the next iteration's PreProject().\n            if (!this.RunProject()) {\n                break;\n            }\n            //\n            // Calculate the new adjustment to the current positions based upon the amount of movement\n            // done by split/project.  If this returns false then it means that movement was zero and\n            // we're done if there was no split or constraint violation.\n            //\n            if (!qpsc.PostProject() && !foundSplit) {\n                break;\n            }\n        }\n        // end forever\n        this.solverSolution.GoalFunctionValue = qpsc.QpscComplete();\n    }\n    QpscMakeFeasible() {\n        // Start off with one Project pass so the initial Qpsc state is feasible (not in violation\n        // of constraints).  If this takes more than the max allowable time, we're done.\n        return this.RunProject();\n    }\n    ReinitializeBlocks() {\n        // For Qpsc we want to discard the previous block structure, because it did not consider\n        // neighbors, and the gradient may want to pull things in an entirely different way.\n        // We must also do this for a re-Solve that updated the gap of an equality constraint.\n        const oldBlocks = Array.from(this.allBlocks.Vector);\n        this.allBlocks.Vector = [];\n        for (const oldBlock of oldBlocks) {\n            for (const variable of oldBlock.Variables) {\n                variable.Reinitialize();\n                const newBlock = new Block(variable, this.allConstraints);\n                this.allBlocks.Add(newBlock);\n            }\n        }\n        this.allConstraints.Reinitialize();\n        this.violationCache.Clear();\n    }\n    MergeEqualityConstraints() {\n        // PerfNote: We only call this routine once so don't worry about Array-Enumerator overhead.\n        for (const constraint of this.equalityConstraints) {\n            if (constraint.Left.Block === constraint.Right.Block) {\n                // They are already in the same block and we are here on the first pass that merges blocks\n                // containing only equality constraints.  Thus we know that there is already a chain of equality\n                // constraints joining constraint.Left and constraint.Right, and that chain will always be\n                // moved as a unit because we never split or expand equality constraints, so this constraint\n                // will remain retain its current satisfied state and does not need to be activated (which\n                // would potentially lead to cycles; this is consistent with the non-equality constraint\n                // approach of not activating constraints that are not violated).\n                if (Math.abs(constraint.Violation) > this.solverParams.GapTolerance) {\n                    // This is an equivalence conflict, such as a + 3 === b; b + 3 === c; a + 9 === c.\n                    constraint.IsUnsatisfiable = true;\n                    this.allConstraints.NumberOfUnsatisfiableConstraints++;\n                }\n                continue;\n            }\n            this.MergeBlocks(constraint);\n        }\n    }\n    Project() {\n        if (this.numberOfConstraints === 0) {\n            // We are here for the neighbours-only case.\n            return false;\n        }\n        // Get the maximum violation (the Constraint with the biggest difference between the\n        // required gap between its two variables vs. their actual relative positions).\n        // If there is no violation, we're done (although SplitBlocks may change things so\n        // we have to go again).\n        this.violationCache.Clear();\n        this.lastModifiedBlock = null;\n        let useViolationCache = this.allBlocks.Count > this.violationCacheMinBlockCutoff;\n        // The first iteration gets the first violated constraint.\n        let cIterations = 1;\n        const t = { maxViolation: 0 };\n        let maxViolatedConstraint = this.GetMaxViolatedConstraint(t, useViolationCache);\n        if (!maxViolatedConstraint) {\n            return false;\n        }\n        // We have at least one violation, so process them until there are no more.\n        while (maxViolatedConstraint) {\n            /*Assert.assert(\n              !maxViolatedConstraint.IsUnsatisfiable,\n              'maxViolatedConstraint should not be unsatisfiable',\n            )*/\n            /*Assert.assert(\n              !maxViolatedConstraint.IsEquality,\n              'maxViolatedConstraint should not be equality',\n            )*/\n            // Perf note: Variables (and Blocks) use the default Object.Equals implementation, which is\n            // simply ReferenceEquals for reference types.\n            if (maxViolatedConstraint.Left.Block === maxViolatedConstraint.Right.Block) {\n                maxViolatedConstraint.Left.Block.Expand(maxViolatedConstraint);\n                if (maxViolatedConstraint.IsUnsatisfiable) {\n                    this.violationCache.Clear();\n                    // We're confusing the lineage of lastModifiedBlock\n                }\n                this.lastModifiedBlock = maxViolatedConstraint.Left.Block;\n            }\n            else {\n                // The variables are in different blocks so merge the blocks.\n                this.lastModifiedBlock = this.MergeBlocks(maxViolatedConstraint);\n            }\n            // Note that aborting here does not guarantee a feasible state.\n            if (this.solverParams.InnerProjectIterationsLimit > 0) {\n                if (cIterations >= this.solverParams.InnerProjectIterationsLimit) {\n                    this.solverSolution.InnerProjectIterationsLimitExceeded = true;\n                    break;\n                }\n            }\n            // Now we've potentially changed one or many variables' positions so recalculate the max violation.\n            useViolationCache = this.allBlocks.Count > this.violationCacheMinBlockCutoff;\n            if (!useViolationCache) {\n                this.violationCache.Clear();\n            }\n            cIterations++;\n            const t = { maxViolation: 0 };\n            maxViolatedConstraint = this.GetMaxViolatedConstraint(t, useViolationCache);\n        }\n        // endwhile violations exist\n        this.solverSolution.InnerProjectIterationsTotal = this.solverSolution.InnerProjectIterationsTotal + cIterations;\n        if (this.solverSolution.MaxInnerProjectIterations < cIterations) {\n            this.solverSolution.MaxInnerProjectIterations = cIterations;\n        }\n        if (this.solverSolution.MinInnerProjectIterations > cIterations) {\n            this.solverSolution.MinInnerProjectIterations = cIterations;\n        }\n        // If we got here, we had at least one violation.\n        // this.allConstraints.Debug_AssertConsistency()\n        return true;\n    }\n    // end Project()\n    MergeBlocks(violatedConstraint) {\n        // Start off evaluating left-to-right.\n        let blockTo = violatedConstraint.Left.Block;\n        let blockFrom = violatedConstraint.Right.Block;\n        /*Assert.assert(\n          blockTo !== blockFrom,\n          'Merging of constraints in the same block is not allowed',\n        )*/\n        // The violation amount is the needed distance to move to tightly satisfy the constraint.\n        // Calculate this based on offsets even though the vars are in different blocks; we'll normalize\n        // that when we recalculate the block reference position and the offsets in the Right block.\n        let distance = violatedConstraint.Left.OffsetInBlock + (violatedConstraint.Gap - violatedConstraint.Right.OffsetInBlock);\n        if (blockFrom.Variables.length > blockTo.Variables.length) {\n            // Reverse this so we minimize variable movement by moving stuff from the block with the least\n            // number of vars into the block with the greater number.\n            blockTo = violatedConstraint.Right.Block;\n            blockFrom = violatedConstraint.Left.Block;\n            distance = -distance;\n        }\n        // Move all vars from blockFrom to blockTo, and adjust their offsets by dist as\n        // mentioned above.  This has the side-effect of moving the associated active constraints\n        // as well (because they are carried in the variables' LeftConstraints); violatedConstraint\n        // is therefore also moved if it was in blockFrom.\n        const numVars = blockFrom.Variables.length;\n        // iteration is faster than foreach for Array<>s\n        for (let i = 0; i < numVars; i++) {\n            const variable = blockFrom.Variables[i];\n            variable.OffsetInBlock += distance;\n            blockTo.AddVariable(variable);\n        }\n        blockTo.UpdateReferencePosFromSums();\n        //blockTo.DebugVerifyReferencePos()\n        // Do any final bookkeeping necessary.\n        // blockTo.Debug_PostMerge(blockFrom)\n        // Make the (no-longer-) violated constraint active.\n        this.allConstraints.ActivateConstraint(violatedConstraint);\n        // We have no further use for blockFrom as nobody references it.\n        this.allBlocks.Remove(blockFrom);\n        return blockTo;\n    }\n    // end MergeBlocks()\n    SplitBlocks() {\n        // First enumerate all blocks and accumulate any new ones that we form by splitting off\n        // from an existing block.  Then add those to our block list in a second pass (to avoid\n        // a \"collection modified during enumeration\" exception).\n        const newBlocks = new Array();\n        const numBlocks = this.allBlocks.Count;\n        // Cache for perf\n        for (let i = 0; i < numBlocks; i++) {\n            const block = this.allBlocks.item(i);\n            /*Assert.assert(\n              0 !== block.Variables.length,\n              'block must have nonzero variable count',\n            )*/\n            const newSplitBlock = block.Split(this.IsQpsc);\n            if (null != newSplitBlock) {\n                newBlocks.push(newSplitBlock);\n            }\n        }\n        const numNewBlocks = newBlocks.length;\n        // cache for perf\n        for (let ii = 0; ii < numNewBlocks; ii++) {\n            const block = newBlocks[ii];\n            this.allBlocks.Add(block);\n        }\n        // The paper uses \"did not split\" for the return but \"did split\" seems more intuitive\n        return 0 !== newBlocks.length;\n    }\n    // end SplitBlocks\n    GetMaxViolatedConstraint(t, useViolationCache) {\n        // Get the most-violated constraint in the Solver.  Active constraints are calculated\n        // to keep their constraint minimally satisfied, so any nonzero active-constraint\n        // violation is due to rounding error; therefore just look for inactive constraints.\n        // Pass maxViolation to subroutines because it is initialized to a limiting value.\n        t.maxViolation = this.solverParams.GapTolerance;\n        const maxViolatedConstraint = this.SearchViolationCache(t.maxViolation);\n        if (null != maxViolatedConstraint) {\n            return maxViolatedConstraint;\n        }\n        // Nothing in ViolationCache or we've got too many Constraints in the block, so search\n        // the list of all constraints.\n        return this.SearchAllConstraints(t.maxViolation, useViolationCache);\n    }\n    // end GetMaxViolatedConstraint()\n    SearchViolationCache(maxViolation) {\n        // If we have any previously cached max violated constraints, then we'll first remove any\n        // that are incoming to or outgoing from the lastModifiedBlock on the current Project()\n        // iteration; these constraints are the only ones that may have changed violation values\n        // (due to block expansion or merging).  If any of the cached maxvio constraints remain after\n        // that, then we can use the largest of these if it's larger than any constraints in lastModifiedBlock.\n        // Even if no cached violations remain after filtering, we still know that the largest violations were\n        // most likely associated with lastModifiedBlock.  So we take a pass through lastModifiedBlock and put\n        // its top constraints into the cache and then take the largest constraint from the violation cache,\n        // which may or may not be associated with lastModifiedBlock.  (This would happen after filling the\n        // cache from multiple blocks in the first pass, or after Block.Split moved some variables (with\n        // cached inactive constraints) to the new block).\n        //\n        // This iteration is slower (relative to the number of constraints in the block) than\n        // SearchAllConstraints, due to two loops, so only do it if the block has a sufficiently small\n        // number of constraints.  Use the Variables as a proxy for the constraint count of the block.\n        // @@PERF: the block could keep a constraint count to make ViolationCache cutoff more accurate.\n        let maxViolatedConstraint = null;\n        if (this.lastModifiedBlock == null)\n            return;\n        if (this.lastModifiedBlock.Variables.length < this.numberOfVariables + 1 && this.violationCache.FilterBlock(this.lastModifiedBlock)) {\n            // Also removes unsatisfiables\n        }\n        // First evaluate all (inactive) outgoing constraints for all variables in the block; this gets\n        // both all intra-block constraints and all inter-block constraints where the lastModifiedBlock\n        // is the source.  Then evaluate incoming constraints where the source is outside the block.\n        const numVarsInBlock = this.lastModifiedBlock.Variables.length;\n        // cache for perf\n        for (let variableIndex = 0; variableIndex < numVarsInBlock; variableIndex++) {\n            const variable = this.lastModifiedBlock.Variables[variableIndex];\n            for (const constraint of variable.LeftConstraints) {\n                if (!constraint.IsActive && !constraint.IsUnsatisfiable) {\n                    const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);\n                    /*Assert.assert(\n                      closeDistEps(constraint.Violation, violation),\n                      'LeftConstraints: constraint.Violation must === violation',\n                    )*/\n                    if (greaterDistEps(violation, maxViolation)) {\n                        // Cache the previous high violation.  Pass the violation as a tiny perf optimization\n                        // to save re-doing the double operations in this inner loop.\n                        if (null != maxViolatedConstraint && maxViolation > this.violationCache.LowViolation) {\n                            this.violationCache.Insert(maxViolatedConstraint, maxViolation);\n                        }\n                        maxViolation = constraint.Violation;\n                        maxViolatedConstraint = constraint;\n                    }\n                }\n            }\n            // endfor each LeftConstraint\n            for (const constraint of variable.RightConstraints) {\n                if (!constraint.IsActive && !constraint.IsUnsatisfiable && constraint.Left.Block !== this.lastModifiedBlock) {\n                    const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);\n                    // Assert.assert(constraint.Violation === violation, \"LeftConstraints: constraint.Violation must === violation\");\n                    /*Assert.assert(\n                      closeDistEps(constraint.Violation, violation),\n                      'LeftConstraints: constraint.Violation must === violation',\n                    )*/\n                    // if (violation > maxViolation)\n                    if (greaterDistEps(violation, maxViolation)) {\n                        if (null != maxViolatedConstraint && maxViolation > this.violationCache.LowViolation) {\n                            this.violationCache.Insert(maxViolatedConstraint, maxViolation);\n                        }\n                        maxViolation = violation;\n                        maxViolatedConstraint = constraint;\n                    }\n                }\n            }\n            // endfor each RightConstraint\n        }\n        // endfor each var in lastModifiedBlock.Variables\n        // Now see if any of the cached maxvios are greater than we have now.  Don't remove\n        // it here; we'll wait until Expand/Merge set lastModifiedBlock and then the removal\n        // occurs above in ViolationCache.FilterBlock in this block when we come back in.\n        const cachedConstraint = this.violationCache.FindIfGreater(maxViolation);\n        if (null != cachedConstraint) {\n            // The cache had something more violated than maxViolatedConstraint, but maxViolatedConstraint\n            // may be larger than at least one cache element.\n            if (null != maxViolatedConstraint && maxViolation > this.violationCache.LowViolation) {\n                this.violationCache.Insert(maxViolatedConstraint, maxViolation);\n            }\n            maxViolatedConstraint = cachedConstraint;\n        }\n        // endif FilterBlock\n        return maxViolatedConstraint;\n        // Remains null if we don't find one\n    }\n    SearchAllConstraints(maxViolation, useViolationCache) {\n        // Iterate all constraints, finding the most-violated and populating the violation cache\n        // with the next-highest violations.\n        let maxViolatedConstraint = null;\n        this.violationCache.Clear();\n        for (const constraint of this.allConstraints.Vector) {\n            // The constraint vector is now organized with all inactive constraints first.\n            if (constraint.IsActive) {\n                break;\n            }\n            if (constraint.IsUnsatisfiable) {\n                continue;\n            }\n            // Note:  The docs have >= 0 for violation condition but it should be just > 0.\n            const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);\n            /*Assert.assert(\n              closeDistEps(constraint.Violation, violation),\n              'constraint.Violation must === violation',\n            )*/\n            let cacheInsertConstraint = null;\n            let cacheInsertViolation = 0;\n            if (greaterDistEps(violation, maxViolation)) {\n                if (maxViolation > this.violationCache.LowViolation) {\n                    cacheInsertConstraint = maxViolatedConstraint;\n                    cacheInsertViolation = maxViolation;\n                }\n                maxViolation = violation;\n                maxViolatedConstraint = constraint;\n            }\n            if (useViolationCache) {\n                // If constraint was a violation but not > maxViolation, then we'll look to insert it into the cache.\n                // (We already know that if the previous maxViolatedConstraint is to be inserted, then its violation is\n                // greater than any in the cache).  On the first iteration of \"for each constraint\", maxViolatedConstraint\n                // is null, hence the constraint !== maxViolatedConstraint test.\n                if (cacheInsertConstraint == null &&\n                    constraint !== maxViolatedConstraint &&\n                    (!this.violationCache.IsFull || violation > this.violationCache.LowViolation)) {\n                    // Either the cache isn't full or the new constraint is more violated than the lowest cached constraint.\n                    cacheInsertConstraint = constraint;\n                    cacheInsertViolation = violation;\n                }\n                if (null != cacheInsertConstraint && cacheInsertViolation > this.violationCache.LowViolation) {\n                    this.violationCache.Insert(cacheInsertConstraint, cacheInsertViolation);\n                }\n            }\n            // endif useViolationCache\n        }\n        // endfor each constraint\n        return maxViolatedConstraint;\n        // Remains null if we don't find one\n    }\n}\n//# sourceMappingURL=Solver.js.map","// --------------------------------------------------------------------------------------------------------------------\n// <copyright file=\"SolverAlgorithm.cs\" company=\"Microsoft\">\n//  (c) Microsoft Corporation.  All rights reserved.\n// </copyright>\n// MSAGL class for algorithm enumeration for Projection Solver.\n// --------------------------------------------------------------------------------------------------------------------\nexport var SolverAlgorithm;\n(function (SolverAlgorithm) {\n    // Iterative Project/Split only.\n    SolverAlgorithm[SolverAlgorithm[\"ProjectOnly\"] = 0] = \"ProjectOnly\";\n    // Diagonally-scaled gradient projection/Qpsc (Quadratic Programming for Separation Constraints).\n    SolverAlgorithm[SolverAlgorithm[\"QpscWithScaling\"] = 1] = \"QpscWithScaling\";\n    // Gradient projection/Qpsc (Quadratic Programming for Separation Constraints) without diagonal scaling.\n    SolverAlgorithm[SolverAlgorithm[\"QpscWithoutScaling\"] = 2] = \"QpscWithoutScaling\";\n})(SolverAlgorithm || (SolverAlgorithm = {}));\n//# sourceMappingURL=SolverAlgorithm.js.map","// just a convenient interface to the real solver\nimport { RealNumberSpan } from '../../utils/RealNumberSpan';\nimport { Solver } from './Solver';\nexport class SolverShell {\n    // Constructor.\n    constructor() {\n        this.variables = new Map();\n        this.fixedVars = new Map();\n        // if all active constraint gaps are less than this epsilon we should stop trying adjusting\n        this.FailToAdjustEpsilon = 0.001;\n        this.InitSolver();\n    }\n    // Add a node that we would like as close to position i as possible, with the requested weight.\n    // Caller's unique identifier for this node\n    // Desired position\n    // The weight of the corresponding term in the goal function\n    AddVariableWithIdealPositionNNN(id, position, weight) {\n        // This throws an ArgumentException if a variable with id is already there.\n        this.variables.set(id, this.solver.AddVariableANN(id, position, weight));\n    }\n    // Add a node that we would like as close to position i as possible, with the requested weight.\n    AddVariableWithIdealPositionNN(id, position) {\n        this.AddVariableWithIdealPositionNNN(id, position, 1);\n    }\n    // Add a constraint that leftNode+gap eq|leq RightNode.\n    // Caller's unique identifier for the left node\n    // Caller's unique identifier for the right node\n    // Required gap\n    // Gap is exact rather than minimum\n    AddLeftRightSeparationConstraintNNNB(idLeft, idRight, gap, isEquality) {\n        // The variables must already have been added by AddNodeWithDesiredPosition.\n        const varLeft = this.GetVariable(idLeft);\n        if (varLeft == null) {\n            return;\n        }\n        const varRight = this.GetVariable(idRight);\n        if (varRight == null) {\n            return;\n        }\n        this.solver.AddConstraintVVNB(varLeft, varRight, gap, isEquality);\n    }\n    // Add a constraint that leftNode+gap leq RightNode.\n    // Caller's unique identifier for the left node\n    // Caller's unique identifier for the right node\n    // Required minimal gap\n    AddLeftRightSeparationConstraintNNN(idLeft, idRight, gap) {\n        this.AddLeftRightSeparationConstraintNNNB(idLeft, idRight, gap, false);\n    }\n    // Add a goal that minimizes the distance between two nodes, i.e. weight*((id1-id2)^2).\n    // Caller's unique identifier for the first node.\n    // Caller's unique identifier for the second node.\n    // The weight of the corresponding term in the goal function\n    AddGoalTwoVariablesAreCloseNNN(id1, id2, weight) {\n        const var1 = this.GetVariable(id1);\n        if (var1 == null) {\n            return;\n        }\n        const var2 = this.GetVariable(id2);\n        if (var2 == null) {\n            return;\n        }\n        this.solver.AddNeighborPair(var1, var2, weight);\n    }\n    //\n    AddGoalTwoVariablesAreClose(id1, id2) {\n        this.AddGoalTwoVariablesAreCloseNNN(id1, id2, 1);\n    }\n    GetVariable(i) {\n        return this.variables.get(i);\n    }\n    // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.\n    Solve() {\n        this.SolveP(null);\n    }\n    // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.\n    // Parameter object class specific to the underlying solver\n    // <returns>Pass or fail</returns>\n    SolveP(parameters) {\n        const t = { executionLimitExceeded: false };\n        this.SolvePNS(parameters, t);\n    }\n    // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.\n    // Parameter object class specific to the underlying solver\n    //         or timeout were exceeded</param>\n    // <returns>Pass or fail</returns>\n    SolvePNS(parameters, t) {\n        let fixedVarsMoved;\n        do {\n            this.solution = null;\n            // Remove any stale solution in case parameters validation or Solve() throws.\n            let solverParameters = null;\n            if (null != parameters) {\n                solverParameters = parameters;\n                if (solverParameters == null) {\n                    throw new Error('parameters');\n                }\n            }\n            this.solution = this.solver.SolvePar(solverParameters);\n            t.executionLimitExceeded = this.solution.ExecutionLimitExceeded;\n            fixedVarsMoved = this.AdjustConstraintsForMovedFixedVars();\n        } while (fixedVarsMoved && this.solution.ExecutionLimitExceeded === false);\n        return this.solution.ExecutionLimitExceeded === false;\n    }\n    //        void DumpToFile(string fileName) {\n    //            var file = new StreamWriter(fileName);\n    //            file.WriteLine(\"digraph {\");\n    //            foreach (var v in solver.Variables) {\n    //                var s = v.Weight > 100 ? \"color=\\\"red\\\"\" : \"\";\n    //                file.WriteLine(v.UserData + \" [ label=\" + \"\\\"\" + v.UserData +\"\\\\n\" +\n    //                               v.DesiredPos + \"\\\" \" +s+ \"]\");\n    //\n    //            }\n    //\n    //            foreach (var cs in solver.Constraints) {\n    //                file.WriteLine(cs.Left.UserData + \" -> \" + cs.Right.UserData + \" [ label=\\\"\" + cs.Gap + \"\\\"]\");\n    //            }\n    //            file.WriteLine(\"}\");\n    //            file.Close();\n    //        }\n    AdjustConstraintsForMovedFixedVars() {\n        const movedFixedVars = new Set();\n        for (const [k, v] of this.fixedVars.entries()) {\n            if (SolverShell.Close(v, this.GetVariableResolvedPosition(k)))\n                continue;\n            movedFixedVars.add(k);\n        }\n        if (movedFixedVars.size === 0) {\n            return false;\n        }\n        return this.AdjustConstraintsForMovedFixedVarSet(movedFixedVars);\n    }\n    static Close(a, b) {\n        return Math.abs(a - b) < 0.0005;\n        // so if a fixed variable moved less than 0.0001 we do not care!\n    }\n    AdjustConstraintsForMovedFixedVarSet(movedFixedVars) {\n        while (movedFixedVars.size > 0) {\n            let fixedVar;\n            for (const t of movedFixedVars) {\n                fixedVar = t;\n                break;\n            }\n            if (!this.AdjustSubtreeOfFixedVar(fixedVar, movedFixedVars)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    AdjustSubtreeOfFixedVar(fixedVar, movedFixedVars) {\n        const t = { successInAdjusting: false };\n        const neighbors = this.AdjustConstraintsOfNeighborsOfFixedVariable(fixedVar, t);\n        if (!t.successInAdjusting) {\n            return false;\n        }\n        if (neighbors.length === 0) {\n            return false;\n        }\n        for (const i of neighbors) {\n            movedFixedVars.delete(i);\n        }\n        return true;\n    }\n    // returns the block of the fixed variable\n    AdjustConstraintsOfNeighborsOfFixedVariable(fixedVar, t) {\n        const nbs = this.variables.get(fixedVar).Block.Variables;\n        const currentSpan = new RealNumberSpan();\n        const idealSpan = new RealNumberSpan();\n        let scale = 1;\n        for (const u of nbs) {\n            if (!this.fixedVars.has(u.UserData)) {\n                continue;\n            }\n            currentSpan.AddValue(u.ActualPos);\n            idealSpan.AddValue(u.DesiredPos);\n            if (idealSpan.length > 0) {\n                scale = Math.max(scale, currentSpan.length / idealSpan.length);\n            }\n        }\n        if (scale === 1) {\n            scale = 2;\n        }\n        // just relax the constraints\n        t.successInAdjusting = this.FixActiveConstraints(nbs, scale);\n        return nbs.map((u) => u.UserData);\n    }\n    FixActiveConstraints(neighbs, scale) {\n        let ret = false;\n        for (const v of neighbs) {\n            for (const c of v.LeftConstraints) {\n                if (c.IsActive) {\n                    if (c.Gap > this.FailToAdjustEpsilon)\n                        ret = true;\n                    this.solver.SetConstraintUpdate(c, c.Gap / scale);\n                }\n            }\n        }\n        return ret;\n    }\n    // Obtain the solved position for a node.\n    // Caller's unique identifier for the node.\n    // <returns>The node's solved position.</returns>\n    GetVariableResolvedPosition(id) {\n        const v = this.GetVariable(id);\n        return v == null ? 0 : v.ActualPos;\n    }\n    //\n    InitSolver() {\n        this.solver = new Solver();\n        this.variables.clear();\n    }\n    // Add a variable with a known and unchanging position.\n    // Caller's unique identifier for the node\n    // Desired position.\n    AddFixedVariable(id, position) {\n        this.AddVariableWithIdealPositionNNN(id, position, SolverShell.FixedVarWeight);\n        this.fixedVars.set(id, position);\n    }\n    //\n    ContainsVariable(v) {\n        return this.variables.has(v);\n    }\n    // returns the ideal position of the node that had been set at the variable construction\n    GetVariableIdealPosition(v) {\n        return this.variables.get(v).DesiredPos;\n    }\n    // Returns the solution object class specific to the underlying solver, or null if there has\n    // been no call to Solve() or it threw an exception.\n    get Solution() {\n        return this.solution;\n    }\n}\n/* const */ SolverShell.FixedVarWeight = 1000000000;\n//# sourceMappingURL=SolverShell.js.map","import { CycleRemoval } from '../../layout/layered/CycleRemoval';\nimport { mkGraphOnEdgesN } from '../../structs/basicGraphOnEdges';\nimport { IntPair } from '../../utils/IntPair';\nimport { SolverShell } from './SolverShell';\nimport { UniformSolverVar } from './UniformSolverVar';\nexport class UniformOneDimensionalSolver {\n    // desired variable separation\n    constructor(variableSeparation) {\n        this.idealPositions = new Map();\n        this.varList = new Array();\n        this.constraints = new Set();\n        this.solverShell = new SolverShell();\n        this.boundsToInt = new Map();\n        this.varSepartion = variableSeparation;\n    }\n    //        delegate Array<NudgerConstraint> Edges(int i);\n    //\n    //        delegate int End(NudgerConstraint constraint);\n    //        Edges outEdgesDel;\n    //        Edges inEdgesDel;\n    //        End sourceDelegate;\n    //        End targetDelegate;\n    //        Supremum minDel;\n    //        Supremum maxDel;\n    SetLowBound(bound, id) {\n        const v = this.Var(id);\n        v.LowBound = Math.max(bound, v.LowBound);\n    }\n    Var(id) {\n        return this.varList[id];\n    }\n    SetUpperBound(id, bound) {\n        const v = this.Var(id);\n        v.UpperBound = Math.min(bound, v.UpperBound);\n    }\n    Solve() {\n        this.SolveByRegularSolver();\n    }\n    SolveByRegularSolver() {\n        this.CreateVariablesForBounds();\n        for (let i = 0; i < this.varList.length; i++) {\n            const v = this.varList[i];\n            if (v.IsFixed) {\n                this.solverShell.AddFixedVariable(i, v.Position);\n            }\n            else {\n                this.solverShell.AddVariableWithIdealPositionNN(i, this.idealPositions.get(i));\n                if (v.LowBound !== Number.NEGATIVE_INFINITY) {\n                    this.constraints.add(new IntPair(this.GetBoundId(v.LowBound), i));\n                }\n                if (v.UpperBound !== Number.POSITIVE_INFINITY) {\n                    this.constraints.add(new IntPair(i, this.GetBoundId(v.UpperBound)));\n                }\n            }\n        }\n        this.CreateGraphAndRemoveCycles();\n        for (const edge of this.graph.edges) {\n            let w = 0;\n            if (edge.x < this.varList.length) {\n                w += this.varList[edge.x].Width;\n            }\n            if (edge.y < this.varList.length) {\n                w += this.varList[edge.y].Width;\n            }\n            w /= 2;\n            this.solverShell.AddLeftRightSeparationConstraintNNN(edge.x, edge.y, this.varSepartion + w);\n        }\n        this.solverShell.Solve();\n        for (let i = 0; i < this.varList.length; i++) {\n            this.varList[i].Position = this.solverShell.GetVariableResolvedPosition(i);\n        }\n    }\n    GetBoundId(bound) {\n        return this.boundsToInt.get(bound);\n    }\n    CreateVariablesForBounds() {\n        for (const v of this.varList) {\n            if (v.IsFixed) {\n                continue;\n            }\n            if (v.LowBound !== Number.NEGATIVE_INFINITY) {\n                this.RegisterBoundVar(v.LowBound);\n            }\n            if (v.UpperBound !== Number.POSITIVE_INFINITY) {\n                this.RegisterBoundVar(v.UpperBound);\n            }\n        }\n    }\n    RegisterBoundVar(bound) {\n        if (!this.boundsToInt.has(bound)) {\n            const varIndex = this.varList.length + this.boundsToInt.size;\n            this.boundsToInt.set(bound, varIndex);\n            this.solverShell.AddFixedVariable(varIndex, bound);\n        }\n    }\n    CreateGraphAndRemoveCycles() {\n        // edges in the graph go from a smaller value to a bigger value\n        this.graph = mkGraphOnEdgesN(Array.from(this.constraints), this.varList.length + this.boundsToInt.size);\n        // removing cycles\n        const feedbackSet = CycleRemoval.getFeedbackSet(this.graph);\n        if (feedbackSet != null) {\n            for (const edge of feedbackSet) {\n                this.graph.removeEdge(edge);\n            }\n        }\n    }\n    GetVariablePosition(id) {\n        return this.varList[id].Position;\n    }\n    AddConstraint(i, j) {\n        this.constraints.add(new IntPair(i, j));\n    }\n    AddVariableNNNN(id, currentPosition, idealPosition, width) {\n        this.idealPositions.set(id, idealPosition);\n        this.AddVariableNNBN(id, currentPosition, false, width);\n    }\n    AddFixedVariable(id, position) {\n        this.AddVariableNNBN(id, position, true, 0);\n        // 0 for width\n    }\n    AddVariableNNBN(id, position, isFixed, width) {\n        /*Assert.assert(id === this.varList.length)*/\n        //new UniformSolverVar { IsFixed = isFixed, Position = position, Width=width\n        const v = new UniformSolverVar();\n        v.Position = position;\n        v.IsFixed = isFixed;\n        v.Width = width;\n        this.varList.push(v);\n    }\n}\n//# sourceMappingURL=UniformOneDimensionalSolver.js.map","export class UniformSolverVar {\n    constructor() {\n        this.lowBound = Number.NEGATIVE_INFINITY;\n        this.upperBound = Number.POSITIVE_INFINITY;\n    }\n    get Position() {\n        return this.position;\n    }\n    set Position(value) {\n        if (value < this.lowBound) {\n            this.position = this.lowBound;\n        }\n        else if (value > this.upperBound) {\n            this.position = this.upperBound;\n        }\n        else {\n            this.position = value;\n        }\n    }\n    get LowBound() {\n        return this.lowBound;\n    }\n    set LowBound(value) {\n        /*Assert.assert(value <= this.upperBound)*/\n        this.lowBound = value;\n    }\n    get UpperBound() {\n        return this.upperBound;\n    }\n    set UpperBound(value) {\n        /*Assert.assert(value >= this.LowBound)*/\n        this.upperBound = value;\n    }\n    toString() {\n        return this.lowBound + (' ' + (this.Position + (' ' + this.upperBound)));\n    }\n}\n//# sourceMappingURL=UniformSolverVar.js.map","import { String } from 'typescript-string-operations';\nimport { compareNumbers } from '../../utils/compare';\n// MSAGL class for Variables for Projection Solver.\nexport class NeighborAndWeight {\n    constructor(neighbor, weight) {\n        this.Neighbor = neighbor;\n        this.Weight = weight;\n    }\n}\n// A Variable is essentially a wrapper around a node, containing the node's initial and\n// current (Actual) positions along the current axis and a collection of Constraints.\nexport class Variable {\n    // The derivative value - essentially the weighted difference in position.\n    get DfDv() {\n        return (2 * (this.Weight * (this.ActualPos - this.DesiredPos))) / this.Scale;\n    }\n    constructor(ordinal, userData, desiredPos, weight, scale) {\n        this.ActiveConstraintCount = 0;\n        if (weight <= 0) {\n            throw new Error('weight');\n        }\n        if (scale <= 0) {\n            throw new Error('scale');\n        }\n        let check = desiredPos * weight;\n        if (!Number.isFinite(check) || Number.isNaN(check)) {\n            throw new Error('desiredPos');\n        }\n        check = desiredPos * scale;\n        if (!Number.isFinite(check) || Number.isNaN(check)) {\n            throw new Error('desiredPos');\n        }\n        this.Ordinal = ordinal;\n        this.UserData = userData;\n        this.DesiredPos = desiredPos;\n        this.Weight = weight;\n        this.Scale = scale;\n        this.OffsetInBlock = 0;\n        this.ActualPos = this.DesiredPos;\n    }\n    Reinitialize() {\n        // // Called by Qpsc or equivalence-constraint-regapping initial block restructuring.\n        this.ActiveConstraintCount = 0;\n        this.OffsetInBlock = 0.0;\n        // If we are in Qpsc, this simply repeats (in the opposite direction) what\n        // Qpsc.VariablesComplete did after (possibly) scaling.  If we're not in Qpsc,\n        // then we've reset all the blocks because we could not incrementally re-Solve\n        // due to changes to equality constraints, so this restores the initial state.\n        this.ActualPos = this.DesiredPos;\n    }\n    AddNeighbor(neighbor, weight) {\n        if (this.Neighbors == null) {\n            this.Neighbors = new Array();\n        }\n        this.Neighbors.push(new NeighborAndWeight(neighbor, weight));\n    }\n    // Gets a string representation of the Variable; calls UserData.ToString as part of this.\n    // <returns>A string representation of the variable.</returns>\n    toString() {\n        return String.Format('{0} {1:F5} ({2:F5}) {3:F5} {4:F5}', this.Name, this.ActualPos, this.DesiredPos, this.Weight, this.Scale);\n    }\n    // Gets the string representation of UserData.\n    // <returns>A string representation of Node.Object.</returns>\n    get Name() {\n        return this.UserData == null ? '-0-' : this.UserData.toString();\n    }\n    SetConstraints(leftConstraints, rightConstraints) {\n        this.LeftConstraints = leftConstraints;\n        this.RightConstraints = rightConstraints;\n    }\n    // Compare the Variables by their ordinals, in ascending order (this === lhs, other === rhs).\n    // The object being compared to.\n    // <returns>-1 if this.Ordinal is \"less\"; +1 if this.Ordinal is \"greater\"; 0 if this.Ordinal\n    //         and rhs are equal.</returns>\n    CompareTo(other) {\n        return compareNumbers(this.Ordinal, other.Ordinal);\n    }\n}\n//# sourceMappingURL=Variable.js.map","// The ViolationCache stores the top N maximum violations initially, allowing\n// a reduction in the number of times we do a full search of all constraints.\n// (It is not guaranteed to retain the max-N violations strictly after the first\n// block is processed following a cache fill, but the approximation is sufficient\n// to provide significant benefit).\nexport class ViolationCache {\n    get IsFull() {\n        return this.numConstraints === ViolationCache.MaxConstraints;\n    }\n    Clear() {\n        this.LowViolation = 0;\n        this.numConstraints = 0;\n        if (!this.constraints) {\n            this.constraints = new Array(ViolationCache.MaxConstraints);\n        }\n    }\n    FilterBlock(blockToFilter) {\n        // Note: The cache does not try to retain strict accordance with highest violation.\n        // Doing so lowers the hit rate, probably because if LastModifiedBlock has enough variables,\n        // then it has enough high violations to flush all other blocks out of the cache, and\n        // thus the next call to FilterBlock removes all for the current block (which per the following\n        // paragraph results in calling SearchAllConstraints).  As it turns out, it doesn't\n        // really matter what order we process the constraints in, other than the perf benefit of\n        // doing the largest violations first, so using the max violation in LastModifiedBlock in this\n        // situation seems to be good enough to win the tradeoff.\n        //\n        // If it becomes necessary to maintain strict \"cache always contains the highest violations\"\n        // compliance, then we would have to return false if the filtering removed all elements of\n        // the cache, because then we wouldn't know if there were any non-blockToFilter-related constraints\n        // with a higher violation (currently we return true in that case because it is good enough to know\n        // there is a good chance that this is true).  Also, SearchViolationCache would need a verification in\n        // at least VERIFY mode to verify there are no higher violations in allConstraints.\n        // Iterate in reverse to remove constraints belonging to LastModifiedBlock.\n        // Note:  Enumerators and .Where are not used because they are much slower.\n        this.LowViolation = Number.MAX_VALUE;\n        const fRet = this.numConstraints > 0;\n        for (let ii = this.numConstraints - 1; ii >= 0; ii--) {\n            const constraint = this.constraints[ii];\n            // Also remove any constraint that may have been activated by MergeBlocks or marked unsatisfiable\n            // by Block.Expand.\n            if (constraint.Left.Block === blockToFilter ||\n                constraint.Right.Block === blockToFilter ||\n                constraint.IsActive ||\n                constraint.IsUnsatisfiable) {\n                // If there are any items after this one, then they are ones we want to keep,\n                // so swap in the last one in the array before decrementing the count.\n                if (ii < this.numConstraints - 1) {\n                    this.constraints[ii] = this.constraints[this.numConstraints - 1];\n                }\n                this.numConstraints--;\n            }\n            else {\n                const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);\n                /*Assert.assert(\n                  constraint.Violation === violation,\n                  'LeftConstraints: constraint.Violation must === violation',\n                )*/\n                if (violation < this.LowViolation) {\n                    this.LowViolation = violation;\n                }\n            }\n        }\n        if (0 === this.numConstraints) {\n            this.LowViolation = 0;\n        }\n        return fRet;\n    }\n    // Find the highest constraint with a greater violation than targetViolation.\n    FindIfGreater(targetViolation) {\n        let maxViolatedConstraint = null;\n        for (let ii = 0; ii < this.numConstraints; ii++) {\n            const constraint = this.constraints[ii];\n            const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);\n            /*Assert.assert(\n              constraint.Violation === violation,\n              'constraint.Violation must === violation',\n            )*/\n            if (violation > targetViolation) {\n                targetViolation = violation;\n                maxViolatedConstraint = constraint;\n            }\n        }\n        // Remains null if none was found.\n        return maxViolatedConstraint;\n    }\n    Insert(constraintToInsert, insertViolation) {\n        // This should be checked by the caller (instead of here, for perf reasons).\n        /*Assert.assert(\n          constraintToInsert.Violation > this.LowViolation,\n          'constraintToInsert.Violation must be > LowViolation',\n        )*/\n        /*Assert.assert(\n          constraintToInsert.Violation === insertViolation,\n          'constraintToInsert.Violation must === insertViolation',\n        )*/\n        let indexOfLowestViolation = 0;\n        let lowViolation = insertViolation;\n        let nextLowViolation = insertViolation;\n        for (let ii = 0; ii < this.numConstraints; ii++) {\n            const constraint = this.constraints[ii];\n            const cacheViolation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);\n            /*Assert.assert(\n              constraint.Violation === cacheViolation,\n              'constraint.Violation must === cacheViolation',\n            )*/\n            if (cacheViolation < lowViolation) {\n                // If we don't replace an existing block pair, then we'll replace the lowest\n                // violation in the cache, so will need to know the next-lowest violation.\n                nextLowViolation = lowViolation;\n                indexOfLowestViolation = ii;\n                lowViolation = cacheViolation;\n            }\n            else if (cacheViolation < nextLowViolation) {\n                nextLowViolation = cacheViolation;\n            }\n        }\n        // endfor each constraint\n        // If the cache isn't full yet, add the new one, else replace the lowest violation in the list.\n        if (!this.IsFull) {\n            // Add to the cache.\n            this.constraints[this.numConstraints++] = constraintToInsert;\n            if (this.IsFull) {\n                this.LowViolation = lowViolation;\n            }\n        }\n        else {\n            // Replace in the cache.\n            this.constraints[indexOfLowestViolation] = constraintToInsert;\n            this.LowViolation = nextLowViolation;\n        }\n    }\n}\n// Must be >= 2 for Insert() dblNextLowVio logic; > 20 seems to yield little increase in hits.\nViolationCache.MaxConstraints = 20;\n//# sourceMappingURL=ViolationCache.js.map","export class BundlingSettings {\n    constructor() {\n        this.capacityOverflowCoefficient = BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier;\n        this.RotateBundles = false;\n        // the upper bound of the virtual node radius\n        this.MaxHubRadius = 50;\n        // the lower bound of the virtual node radius\n        this.MinHubRadius = 0.1;\n        this.CreateUnderlyingPolyline = false;\n        this.pathLengthImportance = BundlingSettings.DefaultPathLengthImportance;\n        this.inkImportance = BundlingSettings.DefaultInkImportance;\n        this.edgeSeparation = BundlingSettings.DefaultEdgeSeparation;\n        /** this could be different from bundlingSetting.EdgeSeparation\n         *    and could be a negative number\n         */\n        this._edgeWidthShrinkCoeff = 1;\n        this.useCubicBezierSegmentsInsideOfHubs = false;\n        this.angleThreshold = (Math.PI / 180) * 45;\n        this.hubRepulsionImportance = 100;\n        this.bundleRepulsionImportance = 100;\n        this.minimalRatioOfGoodCdtEdges = 0.9;\n        this.highestQuality = true;\n        // if set to true then the edges will be routed one on top of each other with no gap inside of a bundle\n        this.KeepOverlaps = false;\n        // calculates the routes that just follow the visibility graph\n        this.StopAfterShortestPaths = false;\n    }\n    toJSON() {\n        const ret = {};\n        if (this.capacityOverflowCoefficient != BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier)\n            ret.capacityOverflowCoefficient = this.capacityOverflowCoefficient;\n        if (this.RotateBundles)\n            ret.RotateBundles = this.RotateBundles;\n        if (this.MaxHubRadius != 50)\n            ret.MaxHubRadius = this.MaxHubRadius;\n        if (this.MinHubRadius != 0.1)\n            ret.MinHubRadius = this.MinHubRadius;\n        if (this.CreateUnderlyingPolyline)\n            ret.CreateUnderlyingPolyline = this.CreateUnderlyingPolyline;\n        if (this.pathLengthImportance != BundlingSettings.DefaultPathLengthImportance)\n            ret.pathLengthImportance = this.pathLengthImportance;\n        if (this.inkImportance != BundlingSettings.DefaultInkImportance)\n            ret.inkImportance = this.inkImportance;\n        if (this.edgeSeparation != BundlingSettings.DefaultEdgeSeparation)\n            ret.edgeSeparation = this.edgeSeparation;\n        if (this._edgeWidthShrinkCoeff != 1)\n            ret._edgeWidthShrinkCoeff = this._edgeWidthShrinkCoeff;\n        if (this.useCubicBezierSegmentsInsideOfHubs)\n            ret.useCubicBezierSegmentsInsideOfHubs = this.useCubicBezierSegmentsInsideOfHubs;\n        if (this.angleThreshold != (Math.PI / 180) * 45)\n            ret.angleThreshold = this.angleThreshold;\n        if (this.hubRepulsionImportance != 100)\n            ret.hubRepulsionImportance = this.hubRepulsionImportance;\n        if (this.bundleRepulsionImportance != 100)\n            ret.bundleRepulsionImportance = this.bundleRepulsionImportance;\n        if (this.minimalRatioOfGoodCdtEdges != 0.9)\n            ret.minimalRatioOfGoodCdtEdges = this.minimalRatioOfGoodCdtEdges;\n        if (!this.highestQuality)\n            ret.highestQuality = this.highestQuality;\n        if (this.KeepOverlaps)\n            ret.KeepOverlaps = this.KeepOverlaps;\n        if (this.StopAfterShortestPaths)\n            ret.StopAfterShortestPaths = this.StopAfterShortestPaths;\n        return ret;\n    }\n    static createFromJSON(s) {\n        const r = new BundlingSettings();\n        if (s.capacityOverflowCoefficient)\n            r.capacityOverflowCoefficient = s.capacityOverflowCoefficient;\n        if (s.RotateBundles)\n            r.RotateBundles = s.RotateBundles;\n        if (s.MaxHubRadius)\n            r.MaxHubRadius = s.MaxHubRadius;\n        if (s.MinHubRadius)\n            r.MinHubRadius = s.MinHubRadius;\n        if (s.CreateUnderlyingPolyline)\n            r.CreateUnderlyingPolyline = s.CreateUnderlyingPolyline;\n        if (s.pathLengthImportance)\n            r.pathLengthImportance = s.pathLengthImportance;\n        if (s.inkImportance)\n            r.inkImportance = s.inkImportance;\n        if (s.edgeSeparation)\n            r.edgeSeparation = s.edgeSeparation;\n        if (s._edgeWidthShrinkCoeff)\n            r._edgeWidthShrinkCoeff = s._edgeWidthShrinkCoeff;\n        if (s.useCubicBezierSegmentsInsideOfHubs)\n            r.useCubicBezierSegmentsInsideOfHubs = s.useCubicBezierSegmentsInsideOfHubs;\n        if (s.angleThreshold)\n            r.angleThreshold = s.angleThreshold;\n        if (s.hubRepulsionImportance)\n            r.hubRepulsionImportance = s.hubRepulsionImportance;\n        if (s.bundleRepulsionImportance)\n            r.bundleRepulsionImportance = s.bundleRepulsionImportance;\n        if (s.minimalRatioOfGoodCdtEdges)\n            r.minimalRatioOfGoodCdtEdges = s.minimalRatioOfGoodCdtEdges;\n        if (s.highestQuality)\n            r.HighestQuality = s.highestQuality;\n        if (s.KeepOverlaps)\n            r.KeepOverlaps = s.KeepOverlaps;\n        if (s.StopAfterShortestPaths)\n            r.StopAfterShortestPaths = s.StopAfterShortestPaths;\n        return r;\n    }\n    // this number is muliplied by the overflow penalty cost and by the sum of the LengthImportanceCoefficient\n    // and InkImportanceCoefficient, and added to the routing price\n    get CapacityOverflowCoefficient() {\n        return this.capacityOverflowCoefficient;\n    }\n    set CapacityOverflowCoefficient(value) {\n        this.capacityOverflowCoefficient = value;\n    }\n    // the importance of path lengths coefficient\n    get PathLengthImportance() {\n        return this.pathLengthImportance;\n    }\n    set PathLengthImportance(value) {\n        this.pathLengthImportance = value;\n    }\n    get InkImportance() {\n        return this.inkImportance;\n    }\n    set InkImportance(value) {\n        this.inkImportance = value;\n    }\n    /** Separation between the neighbor edges within a bundle */\n    get EdgeSeparation() {\n        return this.edgeSeparation;\n    }\n    set EdgeSeparation(value) {\n        this.edgeSeparation = value;\n    }\n    get edgeWidthShrinkCoeff() {\n        return this._edgeWidthShrinkCoeff;\n    }\n    set edgeWidthShrinkCoeff(value) {\n        this._edgeWidthShrinkCoeff = value;\n    }\n    ActualEdgeWidth(e, coeff = this.edgeWidthShrinkCoeff) {\n        return coeff * (this.edgeSeparation + e.lineWidth);\n    }\n    // if is set to true will be using Cubic Bezie Segments inside of hubs, otherwise will be using Biarcs\n    get UseCubicBezierSegmentsInsideOfHubs() {\n        return this.useCubicBezierSegmentsInsideOfHubs;\n    }\n    set UseCubicBezierSegmentsInsideOfHubs(value) {\n        this.useCubicBezierSegmentsInsideOfHubs = value;\n    }\n    // 45 degrees;\n    // min angle for gluing edges\n    get AngleThreshold() {\n        return this.angleThreshold;\n    }\n    set AngleThreshold(value) {\n        this.angleThreshold = value;\n    }\n    // the importance of hub repulsion coefficient\n    get HubRepulsionImportance() {\n        return this.hubRepulsionImportance;\n    }\n    set HubRepulsionImportance(value) {\n        this.hubRepulsionImportance = value;\n    }\n    // the importance of bundle repulsion coefficient\n    get BundleRepulsionImportance() {\n        return this.bundleRepulsionImportance;\n    }\n    set BundleRepulsionImportance(value) {\n        this.bundleRepulsionImportance = value;\n    }\n    // minimal ration of cdt edges with satisfied capacity needed to perform bundling\n    // (otherwise bundling will not be executed)\n    get MinimalRatioOfGoodCdtEdges() {\n        return this.minimalRatioOfGoodCdtEdges;\n    }\n    set MinimalRatioOfGoodCdtEdges(value) {\n        this.minimalRatioOfGoodCdtEdges = value;\n    }\n    // speed vs quality of the drawing\n    get HighestQuality() {\n        return this.highestQuality;\n    }\n    set HighestQuality(value) {\n        this.highestQuality = value;\n    }\n}\n// the default value of CapacityOverflowCoefficient\nBundlingSettings.DefaultCapacityOverflowCoefficientMultiplier = 1000;\n// the default path lenght importance coefficient\nBundlingSettings.DefaultPathLengthImportance = 500;\n// the default ink importance\nBundlingSettings.DefaultInkImportance = 0.01;\n/** default edge separation */\nBundlingSettings.DefaultEdgeSeparation = 0.5;\n//# sourceMappingURL=BundlingSettings.js.map","import { Point } from '../math/geometry';\nimport { RelativeFloatingPort } from '../layout/core/relativeFloatingPort';\nexport class ClusterBoundaryPort extends RelativeFloatingPort {\n    get LoosePolyline() {\n        return this.loosePolyline;\n    }\n    set LoosePolyline(value) {\n        this.loosePolyline = value;\n    }\n    // constructor\n    constructor(curveDelegate, centerDelegate, locationOffset = new Point(0, 0)) {\n        super(curveDelegate, centerDelegate, locationOffset);\n    }\n    // constructor\n    static mk(curveDelegate, centerDelegate) {\n        return new ClusterBoundaryPort(curveDelegate, centerDelegate);\n    }\n}\n//# sourceMappingURL=ClusterBoundaryPort.js.map","/*\nFollowing \"Sweep-line algorithm for constrained Delaunay triangulation\", by Domiter and Zalik\n*/\n//triangulates the space between point, line segment and polygons of the Delaunay fashion\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { Point, TriangleOrientation } from '../../math/geometry/point';\nimport { Rectangle } from '../../math/geometry/rectangle';\nimport { PointMap } from '../../utils/PointMap';\nimport { Algorithm } from './../../utils/algorithm';\nimport { CdtEdge } from './CdtEdge';\nimport { CdtSite } from './CdtSite';\nimport { CdtSweeper } from './CdtSweeper';\nimport { CreateRectNodeOnArrayOfRectNodes, mkRectangleNode } from '../../math/geometry/RTree/rectangleNode';\nexport class Cdt extends Algorithm {\n    // constructor\n    constructor(isolatedSites, obstacles, isolatedSegments) {\n        super(null);\n        this.isolatedSites = [];\n        this.obstacles = [];\n        this.PointsToSites = new PointMap();\n        this.simplifyObstacles = true;\n        this.rectangleNodeOnTriangles = null;\n        this.isolatedSites = isolatedSites;\n        this.obstacles = obstacles;\n        this.isolatedSegments = isolatedSegments;\n    }\n    // constructor\n    static constructor_(isolatedSitesWithObj) {\n        const r = new Cdt(null, null, null);\n        r.isolatedSitesWithObject = isolatedSitesWithObj;\n        return r;\n    }\n    FillAllInputSites() {\n        // for now suppose that the data is correct: no isolatedSites coincide with obstacles or isolatedSegments, obstacles are mutually disjoint, etc\n        if (this.isolatedSitesWithObject != null) {\n            for (const tuple of this.isolatedSitesWithObject) {\n                this.AddSite(tuple[0], tuple[1]);\n            }\n        }\n        if (this.isolatedSites != null) {\n            for (const isolatedSite of this.isolatedSites) {\n                this.AddSite(isolatedSite, null);\n            }\n        }\n        if (this.obstacles != null) {\n            for (const poly of this.obstacles) {\n                this.AddPolylineToAllInputSites(poly);\n            }\n        }\n        if (this.isolatedSegments != null) {\n            for (const isolatedSegment of this.isolatedSegments) {\n                this.AddConstrainedEdge(isolatedSegment.A, isolatedSegment.B, null);\n            }\n        }\n        this.AddP1AndP2();\n        this.allInputSites = Array.from(this.PointsToSites.values());\n    }\n    AddSite(point, relatedObject) {\n        let site;\n        if ((site = this.PointsToSites.get(point))) {\n            site.Owner = relatedObject;\n            // set the owner anyway\n        }\n        else {\n            site = CdtSite.mkSO(point, relatedObject);\n            this.PointsToSites.set(point, site);\n        }\n        return site;\n    }\n    AddP1AndP2() {\n        const box = Rectangle.mkEmpty();\n        for (const site of this.PointsToSites.keys()) {\n            box.add(site);\n        }\n        const delx = 10;\n        const dely = 10;\n        this.P1 = new CdtSite(box.leftBottom.add(new Point(-delx, -dely)));\n        this.P2 = new CdtSite(box.rightBottom.add(new Point(delx, -dely)));\n    }\n    AddPolylineToAllInputSites(poly) {\n        if (this.simplifyObstacles) {\n            for (let p = poly.startPoint; p != null;) {\n                const edgeStart = p.point;\n                p = p.next;\n                if (!p)\n                    break;\n                while (p.next && Point.getTriangleOrientation(edgeStart, p.point, p.next.point) === TriangleOrientation.Collinear) {\n                    p = p.next;\n                }\n                this.AddConstrainedEdge(edgeStart, p.point, poly);\n            }\n        }\n        else {\n            for (let pp = poly.startPoint; pp.next != null; pp = pp.next) {\n                this.AddConstrainedEdge(pp.point, pp.next.point, poly);\n            }\n        }\n        if (poly.closed) {\n            this.AddConstrainedEdge(poly.endPoint.point, poly.startPoint.point, poly);\n        }\n    }\n    AddConstrainedEdge(a, b, poly) {\n        const ab = Cdt.AbovePP(a, b);\n        /*Assert.assert(ab !== 0)*/\n        let upperPoint;\n        let lowerPoint;\n        if (ab > 0) {\n            // a is above b\n            upperPoint = this.AddSite(a, poly);\n            lowerPoint = this.AddSite(b, poly);\n        }\n        else {\n            /*Assert.assert(ab < 0)*/\n            upperPoint = this.AddSite(b, poly);\n            lowerPoint = this.AddSite(a, poly);\n        }\n        const edge = Cdt.CreateEdgeOnOrderedCouple(upperPoint, lowerPoint);\n        edge.constrained = true;\n        /*Assert.assert(this.EdgeIsCorrect(edge))*/\n    }\n    static GetOrCreateEdge(a, b) {\n        if (Cdt.AboveCC(a, b) === 1) {\n            const e = a.EdgeBetweenUpperSiteAndLowerSite(b);\n            if (e != null) {\n                return e;\n            }\n            return Cdt.CreateEdgeOnOrderedCouple(a, b);\n        }\n        else {\n            const e = b.EdgeBetweenUpperSiteAndLowerSite(a);\n            if (e != null) {\n                return e;\n            }\n            return Cdt.CreateEdgeOnOrderedCouple(b, a);\n        }\n    }\n    static CreateEdgeOnOrderedCouple(upperPoint, lowerPoint) {\n        /*Assert.assert(Cdt.AboveCC(upperPoint, lowerPoint) === 1)*/\n        return new CdtEdge(upperPoint, lowerPoint);\n    }\n    GetTriangles() {\n        return this.sweeper.triangles;\n    }\n    // Executes the actual algorithm.\n    run() {\n        this.Initialization();\n        this.SweepAndFinalize();\n    }\n    SweepAndFinalize() {\n        this.sweeper = new CdtSweeper(this.allInputSites, this.P1, this.P2, Cdt.GetOrCreateEdge);\n        this.sweeper.run();\n        this.cleanRemovedEdges();\n    }\n    cleanRemovedEdges() {\n        for (const site of this.PointsToSites.values()) {\n            site.cleanRemovedEdges();\n        }\n    }\n    Initialization() {\n        this.FillAllInputSites();\n        this.allInputSites.sort(Cdt.OnComparison);\n    }\n    static OnComparison(a, b) {\n        return Cdt.AboveCC(a, b);\n    }\n    // compare first y then -x coordinates\n    static AbovePP(a, b) {\n        let del = a.y - b.y;\n        if (del > 0) {\n            return 1;\n        }\n        if (del < 0) {\n            return -1;\n        }\n        del = a.x - b.x;\n        // for a horizontal edge return the point with the smaller X\n        return del > 0 ? -1 : del < 0 ? 1 : 0;\n    }\n    // compare first y then -x coordinates\n    static AboveCC(a, b) {\n        return Cdt.AbovePP(a.point, b.point);\n    }\n    RestoreEdgeCapacities() {\n        for (const site of this.allInputSites) {\n            for (const e of site.Edges) {\n                if (!e.constrained) {\n                    e.ResidualCapacity = e.Capacity;\n                }\n            }\n        }\n    }\n    SetInEdges() {\n        for (const site of this.PointsToSites.values()) {\n            for (const e of site.Edges) {\n                const oSite = e.lowerSite;\n                /*Assert.assert(oSite !== site)*/\n                oSite.AddInEdge(e);\n            }\n        }\n    }\n    FindSite(point) {\n        return this.PointsToSites.get(point);\n    }\n    static PointIsInsideOfTriangle(point, t) {\n        for (let i = 0; i < 3; i++) {\n            const a = t.Sites.getItem(i).point;\n            const b = t.Sites.getItem(i + 1).point;\n            if (Point.signedDoubledTriangleArea(point, a, b) < GeomConstants.distanceEpsilon * -1) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getRectangleNodeOnTriangles() {\n        if (this.rectangleNodeOnTriangles == null) {\n            this.rectangleNodeOnTriangles = CreateRectNodeOnArrayOfRectNodes(Array.from(this.GetTriangles().values()).map((t) => mkRectangleNode(t, t.BoundingBox())));\n        }\n        return this.rectangleNodeOnTriangles;\n    }\n}\nexport function createCDTOnPolylineRectNode(polylineHierarchy) {\n    const obstacles = Array.from(polylineHierarchy.GetAllLeaves());\n    const rectangle = polylineHierarchy.irect;\n    const del = rectangle.diagonal / 4;\n    const nRect = rectangle.clone();\n    nRect.pad(del);\n    return getConstrainedDelaunayTriangulation(obstacles.concat([nRect.perimeter()]));\n}\nfunction getConstrainedDelaunayTriangulation(obstacles) {\n    const constrainedDelaunayTriangulation = new Cdt(null, obstacles, null);\n    constrainedDelaunayTriangulation.run();\n    return constrainedDelaunayTriangulation;\n}\n//# sourceMappingURL=Cdt.js.map","import { String } from 'typescript-string-operations';\nimport { Cdt } from './Cdt';\nexport class CdtEdge {\n    constructor(a, b) {\n        // is an obstacle side, or a given segment\n        this.constrained = false;\n        // the amount of free space around the edge\n        this.Capacity = 1000000;\n        const above = Cdt.AbovePP(a.point, b.point);\n        if (above === 1) {\n            this.upperSite = a;\n            this.lowerSite = b;\n        }\n        else {\n            /*Assert.assert(above !== 0)*/\n            this.lowerSite = a;\n            this.upperSite = b;\n        }\n        this.upperSite.AddEdgeToSite(this);\n    }\n    get CcwTriangle() {\n        return this.ccwTriangle;\n    }\n    set CcwTriangle(value) {\n        /*Assert.assert(\n          value == null  ||\n            this.cwTriangle == null  ||\n            value.OppositeSite(this) !== this.cwTriangle.OppositeSite(this),\n        )*/\n        this.ccwTriangle = value;\n    }\n    get CwTriangle() {\n        return this.cwTriangle;\n    }\n    set CwTriangle(value) {\n        /*Assert.assert(\n          value == null  ||\n            this.ccwTriangle == null  ||\n            value.OppositeSite(this) !== this.ccwTriangle.OppositeSite(this),\n        )*/\n        this.cwTriangle = value;\n    }\n    // returns the trianlge on the edge opposite to the site\n    GetOtherTriangle_c(p) {\n        return this.cwTriangle.Contains(p) ? this.ccwTriangle : this.cwTriangle;\n    }\n    IsAdjacent(pi) {\n        return pi === this.upperSite || pi === this.lowerSite;\n    }\n    GetOtherTriangle_T(triangle) {\n        return this.ccwTriangle === triangle ? this.cwTriangle : this.ccwTriangle;\n    }\n    // A string that represents the current object.\n    toString() {\n        return String.Format('({0},{1})', this.upperSite, this.lowerSite);\n    }\n    OtherSite(site) {\n        /*Assert.assert(this.IsAdjacent(site))*/\n        return this.upperSite === site ? this.lowerSite : this.upperSite;\n    }\n}\n//# sourceMappingURL=CdtEdge.js.map","export class CdtFrontElement {\n    get x() {\n        return this.LeftSite.point.x;\n    }\n    constructor(leftSite, edge) {\n        /*Assert.assert(\n          (edge.upperSite.point.x !== edge.lowerSite.point.x &&\n            edge.upperSite.point.x < edge.lowerSite.point.x &&\n            leftSite === edge.upperSite) ||\n            (edge.upperSite.point.x > edge.lowerSite.point.x &&\n              leftSite === edge.lowerSite),\n        )*/\n        this.RightSite = edge.upperSite === leftSite ? edge.lowerSite : edge.upperSite;\n        this.LeftSite = leftSite;\n        this.Edge = edge;\n    }\n    toString() {\n        return '(' + this.LeftSite.toString() + ', ' + this.Edge.toString() + ',' + this.RightSite.toString() + ')';\n    }\n}\n//# sourceMappingURL=CdtFrontElement.js.map","export class CdtSite {\n    cleanRemovedEdges() {\n        for (const e of this.Edges) {\n            if (e.CcwTriangle === null && e.CwTriangle === null) {\n                this.Edges.splice(this.Edges.indexOf(e), 1);\n            }\n        }\n    }\n    constructor(isolatedSite) {\n        // Object to which this site refers to.\n        this.Owner = null;\n        this.InEdges = new Array();\n        this.point = isolatedSite;\n    }\n    static mkSO(isolatedSite, owner) {\n        const s = new CdtSite(isolatedSite);\n        s.Owner = owner;\n        return s;\n    }\n    AddEdgeToSite(edge) {\n        if (this.Edges == null) {\n            this.Edges = new Array();\n        }\n        this.Edges.push(edge);\n    }\n    // #if TEST_MSAGL && TEST_MSAGL\n    //         // Returns a <see cref=\"T:System.String\"/> that represents the current <see cref=\"T:System.Object\"/>.\n    //         // A <see cref=\"T:System.String\"/> that represents the current <see cref=\"T:System.Object\"/>.\n    //         // <filterpriority>2</filterpriority>\n    //         public override string ToString()\n    //         {\n    //             return Point.ToString();\n    //         }\n    // #endif\n    EdgeBetweenUpperSiteAndLowerSite(b) {\n        /*Assert.assert(Cdt.AboveCC(this, b) > 0)*/\n        if (this.Edges != null) {\n            for (const edge of this.Edges) {\n                if (edge.lowerSite === b) {\n                    return edge;\n                }\n            }\n        }\n        return null;\n    }\n    AddInEdge(e) {\n        this.InEdges.push(e);\n    }\n    *Triangles() {\n        // this function might not work correctly if InEdges are not set\n        let edge;\n        if (this.Edges != null && this.Edges.length > 0)\n            edge = this.Edges[0];\n        else if (this.InEdges != null && this.InEdges.length > 0)\n            edge = this.InEdges[0];\n        else\n            return;\n        //going counterclockwise around the site\n        let e = edge;\n        do {\n            const t = e.upperSite === this ? e.CcwTriangle : e.CwTriangle;\n            if (t == null) {\n                e = null;\n                break;\n            }\n            yield t;\n            e = t.Edges.getItem(t.Edges.index(e) + 2);\n        } while (e !== edge); //full circle\n        if (e !== edge) {\n            //we have not done the full circle, starting again with edge but now going clockwise around the site\n            e = edge;\n            do {\n                const t = e.upperSite === this ? e.CwTriangle : e.CcwTriangle;\n                if (t == null) {\n                    break;\n                }\n                yield t;\n                e = t.Edges.getItem(t.Edges.index(e) + 1);\n            } while (true); // we will hit a null triangle for the convex hull border edge\n        }\n    }\n    toString() {\n        return this.point.toString();\n    }\n}\n//# sourceMappingURL=CdtSite.js.map","import { Stack } from 'stack-typescript';\nimport { DebugCurve } from '../../math/geometry/debugCurve';\nimport { Ellipse } from '../../math/geometry/ellipse';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { LineSegment } from '../../math/geometry/lineSegment';\nimport { Point, TriangleOrientation } from '../../math/geometry/point';\nimport { RBTree } from '../../math/RBTree/rbTree';\nimport { Algorithm } from '../../utils/algorithm';\nimport { RealNumberSpan } from '../../utils/RealNumberSpan';\nimport { Cdt } from './Cdt';\nimport { CdtFrontElement } from './CdtFrontElement';\nimport { CdtTriangle } from './CdtTriangle';\nimport { PerimeterEdge } from './PerimeterEdge';\n// this class builds the triangulation by a sweep with a horizontal line\nexport class CdtSweeper extends Algorithm {\n    constructor(listOfSites, p_1, p_2, createEdgeDelegate) {\n        super(null);\n        this.front = new RBTree((a, b) => a.x - b.x);\n        this.triangles = new Set();\n        this.listOfSites = listOfSites;\n        if (this.listOfSites.length === 0) {\n            return;\n        }\n        this.p_1 = p_1;\n        this.p_2 = p_2;\n        this.createEdgeDelegate = createEdgeDelegate;\n        const firstTriangle = CdtTriangle.mkSSSD(p_1, p_2, this.listOfSites[0], createEdgeDelegate);\n        this.triangles.add(firstTriangle);\n        this.front.insert(new CdtFrontElement(p_1, firstTriangle.Edges.getItem(2)));\n        this.front.insert(new CdtFrontElement(this.listOfSites[0], firstTriangle.Edges.getItem(1)));\n        //this.Show('./tmp/front.svg')\n    }\n    run() {\n        if (this.listOfSites.length === 0) {\n            return;\n        }\n        for (let i = 1; i < this.listOfSites.length; i++) {\n            this.ProcessSite(this.listOfSites[i]);\n        }\n        this.FinalizeTriangulation();\n        // #if TEST_MSAGL && TEST_MSAGL\n        //             //TestTriangles();\n        //             //ShowFront(triangles,null,null,null);\n        // #endif\n    }\n    FinalizeTriangulation() {\n        this.RemoveP1AndP2Triangles();\n        if (this.triangles.size > 0)\n            this.MakePerimeterConvex();\n    }\n    MakePerimeterConvex() {\n        let firstPerimeterEdge = this.CreateDoubleLinkedListOfPerimeter();\n        do {\n            const concaveEdge = this.FindConcaveEdge(firstPerimeterEdge);\n            if (concaveEdge == null)\n                return;\n            firstPerimeterEdge = this.ShortcutTwoListElements(concaveEdge);\n        } while (true);\n    }\n    FindConcaveEdge(firstPerimeterEdge) {\n        let a = firstPerimeterEdge;\n        let b;\n        do {\n            b = a.Next;\n            if (Point.getTriangleOrientation(a.Start.point, a.End.point, b.End.point) === TriangleOrientation.Counterclockwise) {\n                return a;\n            }\n            else\n                a = b;\n        } while (b !== firstPerimeterEdge);\n        return null;\n    }\n    static FindPivot(firstPerimeterEdge) {\n        // eslint-disable-next-line no-var\n        let pivot = firstPerimeterEdge;\n        let e = firstPerimeterEdge;\n        do {\n            e = e.Next;\n            if (e.Start.point.x < pivot.Start.point.x || (e.Start.point.x === pivot.Start.point.x && e.Start.point.y < pivot.Start.point.y))\n                pivot = e;\n        } while (e !== firstPerimeterEdge);\n        return pivot;\n    }\n    FindFirsePerimeterEdge() {\n        for (const t of this.triangles) {\n            for (const e of t.Edges) {\n                if (e.GetOtherTriangle_T(t) == null)\n                    return e;\n            }\n        }\n        return null;\n    }\n    CreateDoubleLinkedListOfPerimeter() {\n        const firstEdge = this.FindFirsePerimeterEdge();\n        let edge = firstEdge;\n        let listStart = null;\n        let pe;\n        let prevPe = null;\n        const debugDC = new Array();\n        do {\n            pe = CdtSweeper.CreatePerimeterElementFromEdge(edge);\n            debugDC.push(LineSegment.mkPP(pe.Start.point, pe.End.point));\n            edge = CdtSweeper.FindNextEdgeOnPerimeter(edge);\n            if (prevPe != null) {\n                pe.Prev = prevPe;\n                prevPe.Next = pe;\n            }\n            else {\n                listStart = pe;\n            }\n            prevPe = pe;\n        } while (edge !== firstEdge);\n        listStart.Prev = pe;\n        pe.Next = listStart;\n        return listStart;\n    }\n    static FindNextEdgeOnPerimeter(e) {\n        var _a;\n        let t = (_a = e.CwTriangle) !== null && _a !== void 0 ? _a : e.CcwTriangle;\n        e = t.Edges.getItem(t.Edges.index(e) + 2);\n        while (e.CwTriangle != null && e.CcwTriangle != null) {\n            t = e.GetOtherTriangle_T(t);\n            e = t.Edges.getItem(t.Edges.index(e) + 2);\n        }\n        return e;\n    }\n    static CreatePerimeterElementFromEdge(edge) {\n        const pe = new PerimeterEdge(edge);\n        if (edge.CwTriangle != null) {\n            pe.Start = edge.upperSite;\n            pe.End = edge.lowerSite;\n        }\n        else {\n            pe.End = edge.upperSite;\n            pe.Start = edge.lowerSite;\n        }\n        return pe;\n    }\n    RemoveP1AndP2Triangles() {\n        const trianglesToRemove = new Set();\n        for (const t of this.triangles) {\n            if (t.Sites.has(this.p_1) || t.Sites.has(this.p_2)) {\n                trianglesToRemove.add(t);\n            }\n        }\n        for (const t of trianglesToRemove) {\n            CdtSweeper.RemoveTriangleWithEdges(this.triangles, t);\n        }\n    }\n    static RemoveTriangleWithEdges(cdtTriangles, t) {\n        cdtTriangles.delete(t);\n        for (const e of t.Edges) {\n            if (e.CwTriangle === t) {\n                e.CwTriangle = null;\n            }\n            else {\n                e.CcwTriangle = null;\n            }\n            if (e.CwTriangle == null && e.CcwTriangle == null) {\n                removeFromArray(e.upperSite.Edges, e);\n            }\n        }\n    }\n    static RemoveTriangleButLeaveEdges(cdtTriangles, t) {\n        cdtTriangles.delete(t);\n        for (const e of t.Edges) {\n            if (e.CwTriangle === t) {\n                e.CwTriangle = null;\n            }\n            else {\n                e.CcwTriangle = null;\n            }\n        }\n    }\n    ProcessSite(site) {\n        this.PointEvent(site);\n        for (let i = 0; i < site.Edges.length; i++) {\n            //console.log('i', i)\n            const edge = site.Edges[i];\n            if (edge.constrained) {\n                this.EdgeEvent(edge);\n            }\n        }\n        //throw new Error()\n        // TestThatFrontIsConnected();\n    }\n    // #if TEST_MSAGL && TEST_MSAGL\n    // void TestThatFrontIsConnected() {\n    //     CdtFrontElement p = null;\n    //     foreach(var cdtFrontElement of front) {\n    //         if (p != null)\n    //             Assert.assert(p.RightSite === cdtFrontElement.LeftSite);\n    //         p = cdtFrontElement;\n    //     }\n    // }\n    // #endif\n    EdgeEvent(edge) {\n        /*Assert.assert(edge.Constrained)*/\n        if (CdtSweeper.EdgeIsProcessed(edge)) {\n            return;\n        }\n        this.traversingEdge = edge;\n        this.runEdgeInserter();\n    }\n    static EdgeIsProcessed(edge) {\n        return edge.CwTriangle != null || edge.CcwTriangle != null;\n    }\n    ShowFrontWithSite(site, redCurves = null) {\n        const ls = new Array();\n        if (site.Edges != null) {\n            for (const e of site.Edges) {\n                ls.push(DebugCurve.mkDebugCurveTWCI(200, 0.8, e.constrained ? 'Pink' : 'Brown', LineSegment.mkPP(e.upperSite.point, e.lowerSite.point)));\n            }\n        }\n        ls.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Brown', Ellipse.mkFullEllipseNNP(0.5, 0.5, site.point)));\n        for (const t of this.triangles) {\n            for (let i = 0; i < 3; i++) {\n                const e = t.Edges.getItem(i);\n                ls.push(DebugCurve.mkDebugCurveTWCI(e.constrained ? 155 : 100, e.constrained ? 0.8 : 0.4, e.constrained ? 'Pink' : 'Navy', LineSegment.mkPP(e.upperSite.point, e.lowerSite.point)));\n            }\n        }\n        if (redCurves != null)\n            for (const c of redCurves) {\n                ls.push(DebugCurve.mkDebugCurveTWCI(100, 0.5, 'Red', c));\n            }\n        for (const frontElement of this.front) {\n            ls.push(DebugCurve.mkDebugCurveTWCI(100, 5.5, 'Green', LineSegment.mkPP(frontElement.Edge.upperSite.point, frontElement.Edge.lowerSite.point)));\n        }\n    }\n    Show(fn) {\n        CdtSweeper.ShowCdt(Array.from(this.triangles.values()), this.front, null, null, [], fn);\n    }\n    static ShowCdt(cdtTriangles, cdtFrontElements, redCurves, blueCurves, dc, fn) {\n        let ls = new Array();\n        if (redCurves != null) {\n            for (const c of redCurves) {\n                ls.push(DebugCurve.mkDebugCurveTWCI(200, 0.1, 'Red', c));\n            }\n        }\n        if (blueCurves != null) {\n            for (const c of blueCurves) {\n                ls.push(DebugCurve.mkDebugCurveTWCI(200, 0.1, 'Blue', c));\n            }\n        }\n        if (cdtFrontElements != null) {\n            for (const frontElement of cdtFrontElements) {\n                ls.push(DebugCurve.mkDebugCurveTWCI(200, 0.1, 'Green', LineSegment.mkPP(frontElement.Edge.upperSite.point, frontElement.Edge.lowerSite.point)));\n            }\n        }\n        for (const t of cdtTriangles) {\n            for (let i = 0; i < 3; i++) {\n                const e = t.Edges.getItem(i);\n                ls.push(CdtSweeper.GetDebugCurveOfCdtEdge(e));\n            }\n        }\n        ls = ls.concat(dc);\n        //   SvgDebugWriter.dumpDebugCurves(fn, ls)\n    }\n    static GetDebugCurveOfCdtEdge(e) {\n        if (e.CcwTriangle == null || e.CwTriangle == null)\n            return DebugCurve.mkDebugCurveTWCI(255, 0.5, e.constrained ? 'Brown' : 'Black', LineSegment.mkPP(e.upperSite.point, e.lowerSite.point));\n        return DebugCurve.mkDebugCurveTWCI(200, e.constrained ? 0.8 : 0.2, e.constrained ? 'Pink' : 'Navy', LineSegment.mkPP(e.upperSite.point, e.lowerSite.point));\n    }\n    PointEvent(pi) {\n        const hittedFrontElementNode = this.ProjectToFront(pi);\n        const t = { rightSite: null };\n        const leftSite = hittedFrontElementNode.item.x + GeomConstants.distanceEpsilon < pi.point.x\n            ? this.MiddleCase(pi, hittedFrontElementNode, t)\n            : this.LeftCase(pi, hittedFrontElementNode, t);\n        let piNode = this.InsertSiteIntoFront(leftSite, pi, t.rightSite);\n        this.TriangulateEmptySpaceToTheRight(piNode);\n        piNode = CdtSweeper.FindNodeInFrontBySite(this.front, leftSite);\n        this.TriangulateEmptySpaceToTheLeft(piNode);\n    }\n    // #if TEST_MSAGL && TEST_MSAGL\n    // void TestTriangles() {\n    //     var usedSites = new Set<CdtSite>();\n    //     foreach(var t of triangles)\n    //     usedSites.InsertRange(t.Sites);\n    //     foreach(var triangle of triangles) {\n    //         TestTriangle(triangle, usedSites);\n    //     }\n    // }\n    // void TestTriangle(CdtTriangle triangle, Set < CdtSite > usedSites) {\n    //     var tsites = triangle.Sites;\n    //     foreach(var site of usedSites) {\n    //         if (!tsites.Contains(site)) {\n    //             if (!SeparatedByConstrainedEdge(triangle, site) && InCircle(site, tsites[0], tsites[1], tsites[2])) {\n    //                 Array < ICurve > redCurves=new Array<ICurve>();\n    //                 redCurves.push(new Ellipse(2, 2, site.point));\n    //                 Array < ICurve > blueCurves = new Array<ICurve>();\n    //                 blueCurves.push(Circumcircle(tsites[0].point, tsites[1].point, tsites[2].point));\n    //                 ShowFront(triangles, front, redCurves, blueCurves);\n    //             }\n    //         }\n    //     }\n    // }\n    //         static bool SeparatedByConstrainedEdge(CdtTriangle triangle, CdtSite site) {\n    //     for (int i = 0; i < 3; i++)\n    //     if (SeparatedByEdge(triangle, i, site))\n    //         return true;\n    //     return false;\n    // }\n    //         static bool SeparatedByEdge(CdtTriangle triangle, int i, CdtSite site) {\n    //     var e = triangle.Edges[i];\n    //     var s = triangle.Sites.getItem(i + 2);\n    //     var a0 = ApproximateComparer.Sign(Point.SignedDoubledTriangleArea(s.point, e.upperSite.point, e.lowerSite.point));\n    //     var a1 = ApproximateComparer.Sign(Point.SignedDoubledTriangleArea(site.point, e.upperSite.point, e.lowerSite.point));\n    //     return a0 * a1 <= 0;\n    // }\n    // #endif\n    LeftCase(pi, hittedFrontElementNode, t) {\n        // left case\n        //                if(db)ShowFrontWithSite(pi, LineSegment.mkPP(pi.point, hittedFrontElementNode.Item.Edge.upperSite.point), LineSegment.mkPP(pi.point, hittedFrontElementNode.Item.Edge.lowerSite.point));\n        /*Assert.assert(closeDistEps(pi.point.x, hittedFrontElementNode.item.x))*/\n        const hittedFrontElement = hittedFrontElementNode.item;\n        this.InsertAndLegalizeTriangle(pi, hittedFrontElement);\n        const prevToHitted = this.front.previous(hittedFrontElementNode);\n        const leftSite = prevToHitted.item.LeftSite;\n        t.rightSite = hittedFrontElementNode.item.RightSite;\n        //                if(db)ShowFrontWithSite(pi, LineSegment.mkPP(pi.point, leftSite.point), LineSegment.mkPP(pi.point, prevToHitted.Item.RightSite.point));\n        this.InsertAndLegalizeTriangle(pi, prevToHitted.item);\n        this.front.deleteNodeInternal(prevToHitted);\n        const d = this.front.remove(hittedFrontElement);\n        /*Assert.assert(d != null)*/\n        return leftSite;\n    }\n    MiddleCase(pi, hittedFrontElementNode, t) {\n        //            if(db)\n        //                ShowFrontWithSite(pi, LineSegment.mkPP(pi.point, hittedFrontElementNode.Item.Edge.upperSite.point), LineSegment.mkPP(pi.point, hittedFrontElementNode.Item.Edge.lowerSite.point));\n        const leftSite = hittedFrontElementNode.item.LeftSite;\n        t.rightSite = hittedFrontElementNode.item.RightSite;\n        this.InsertAndLegalizeTriangle(pi, hittedFrontElementNode.item);\n        this.front.deleteNodeInternal(hittedFrontElementNode);\n        return leftSite;\n    }\n    TriangulateEmptySpaceToTheLeft(leftLegNode) {\n        const peakSite = leftLegNode.item.RightSite;\n        let previousNode = this.front.previous(leftLegNode);\n        while (previousNode != null) {\n            const prevElement = previousNode.item;\n            const rp = prevElement.LeftSite;\n            const r = prevElement.RightSite;\n            if (r.point.sub(peakSite.point).dot(rp.point.sub(r.point)) < 0) {\n                // see figures 9(a) and 9(b) of the paper\n                leftLegNode = this.ShortcutTwoFrontElements(previousNode, leftLegNode);\n                previousNode = this.front.previous(leftLegNode);\n            }\n            else {\n                this.TryTriangulateBasinToTheLeft(leftLegNode);\n                break;\n            }\n        }\n    }\n    ShortcutTwoListElements(a) {\n        var _a;\n        const b = a.Next;\n        /*Assert.assert(a.End === b.Start)*/\n        let t = CdtTriangle.mkSSSEE(a.Start, a.End, b.End, a.Edge, b.Edge, this.createEdgeDelegate);\n        this.triangles.add(t);\n        const newEdge = t.Edges.getItem(2);\n        /*Assert.assert(newEdge.IsAdjacent(a.Start) && newEdge.IsAdjacent(b.End))*/\n        this.LegalizeEdge(a.Start, t.OppositeEdge(a.Start));\n        t = (_a = newEdge.CcwTriangle) !== null && _a !== void 0 ? _a : newEdge.CwTriangle;\n        this.LegalizeEdge(b.End, t.OppositeEdge(b.End));\n        const c = new PerimeterEdge(newEdge);\n        c.Start = a.Start;\n        c.End = b.End;\n        a.Prev.Next = c;\n        c.Prev = a.Prev;\n        c.Next = b.Next;\n        b.Next.Prev = c;\n        return c;\n    }\n    // aNode is to the left of bNode, and they are consecutive\n    ShortcutTwoFrontElements(aNode, bNode) {\n        var _a;\n        const aElem = aNode.item;\n        const bElem = bNode.item;\n        /*Assert.assert(aElem.RightSite === bElem.LeftSite)*/\n        let t = CdtTriangle.mkSSSEED(aElem.LeftSite, aElem.RightSite, bElem.RightSite, aElem.Edge, bElem.Edge, this.createEdgeDelegate);\n        this.triangles.add(t);\n        this.front.deleteNodeInternal(aNode);\n        // now bNode might b not valid anymore\n        this.front.remove(bElem);\n        const newEdge = t.Edges.getItem(2);\n        /*Assert.assert(\n          newEdge.IsAdjacent(aElem.LeftSite) && newEdge.IsAdjacent(bElem.RightSite),\n        )*/\n        this.LegalizeEdge(aElem.LeftSite, t.OppositeEdge(aElem.LeftSite));\n        t = (_a = newEdge.CcwTriangle) !== null && _a !== void 0 ? _a : newEdge.CwTriangle;\n        this.LegalizeEdge(bElem.RightSite, t.OppositeEdge(bElem.RightSite));\n        return this.front.insert(new CdtFrontElement(aElem.LeftSite, newEdge));\n    }\n    TryTriangulateBasinToTheLeft(leftLegNode) {\n        if (!CdtSweeper.DropsSharpEnoughToTheLeft(leftLegNode.item)) {\n            return;\n        }\n        // ShowFrontWithSite(leftLegNode.Item.LeftSite);\n        const stack = new Stack();\n        stack.push(leftLegNode.item.LeftSite);\n        while (true) {\n            const site = stack.pop();\n            leftLegNode = CdtSweeper.FindNodeInFrontBySite(this.front, site);\n            const prev = this.front.previous(leftLegNode);\n            if (prev == null) {\n                return;\n            }\n            if (Point.getTriangleOrientation(prev.item.LeftSite.point, leftLegNode.item.LeftSite.point, leftLegNode.item.RightSite.point) ==\n                TriangleOrientation.Counterclockwise) {\n                stack.push(prev.item.LeftSite);\n                this.ShortcutTwoFrontElements(prev, leftLegNode);\n                //      ShowFrontWithSite(site);\n            }\n            else if (leftLegNode.item.LeftSite.point.y > leftLegNode.item.RightSite.point.y) {\n                stack.push(prev.item.LeftSite);\n            }\n            else {\n                if (prev.item.LeftSite.point.y <= prev.item.RightSite.point.y) {\n                    return;\n                }\n                stack.push(prev.item.LeftSite);\n            }\n        }\n    }\n    static DropsSharpEnoughToTheLeft(frontElement) {\n        const edge = frontElement.Edge;\n        if (frontElement.RightSite !== edge.upperSite) {\n            return false;\n        }\n        const d = edge.lowerSite.point.sub(edge.upperSite.point);\n        /*Assert.assert(d.x < 0 && d.y <= 0)*/\n        return d.x >= 0.5 * d.y;\n    }\n    InsertSiteIntoFront(leftSite, pi, rightSite) {\n        let rightEdge = null;\n        let leftEdge = null;\n        for (const edge of pi.Edges) {\n            if (leftEdge == null && edge.lowerSite === leftSite) {\n                leftEdge = edge;\n            }\n            if (rightEdge == null && edge.lowerSite === rightSite) {\n                rightEdge = edge;\n            }\n            if (leftEdge != null && rightEdge != null) {\n                break;\n            }\n        }\n        /*Assert.assert(leftEdge != null && rightEdge != null)*/\n        this.front.insert(new CdtFrontElement(leftSite, leftEdge));\n        return this.front.insert(new CdtFrontElement(pi, rightEdge));\n    }\n    TriangulateEmptySpaceToTheRight(piNode) {\n        const piSite = piNode.item.LeftSite;\n        const piPoint = piSite.point;\n        let piNext = this.front.next(piNode);\n        while (piNext != null) {\n            const frontElem = piNext.item;\n            const r = frontElem.LeftSite;\n            const rp = frontElem.RightSite;\n            if (r.point.sub(piPoint).dot(rp.point.sub(r.point)) < 0) {\n                // see figures 9(a) and 9(b) of the paper\n                piNode = this.ShortcutTwoFrontElements(piNode, piNext);\n                piNext = this.front.next(piNode);\n            }\n            else {\n                this.TryTriangulateBasinToTheRight(piNode);\n                break;\n            }\n        }\n    }\n    TryTriangulateBasinToTheRight(piNode) {\n        if (!CdtSweeper.DropsSharpEnoughToTheRight(piNode.item)) {\n            return;\n        }\n        // ShowFrontWithSite(piNode.Item.LeftSite);\n        const stack = new Stack();\n        stack.push(piNode.item.LeftSite);\n        while (true) {\n            const site = stack.pop();\n            piNode = CdtSweeper.FindNodeInFrontBySite(this.front, site);\n            const next = this.front.next(piNode);\n            if (next == null) {\n                return;\n            }\n            if (Point.getTriangleOrientation(piNode.item.LeftSite.point, piNode.item.RightSite.point, next.item.RightSite.point) ==\n                TriangleOrientation.Counterclockwise) {\n                this.ShortcutTwoFrontElements(piNode, next);\n                stack.push(site);\n            }\n            else if (piNode.item.LeftSite.point.y > piNode.item.RightSite.point.y) {\n                stack.push(piNode.item.RightSite);\n            }\n            else {\n                if (next.item.LeftSite.point.y >= next.item.RightSite.point.y) {\n                    return;\n                }\n                stack.push(piNode.item.RightSite);\n            }\n        }\n    }\n    static DropsSharpEnoughToTheRight(frontElement) {\n        const edge = frontElement.Edge;\n        if (frontElement.LeftSite !== edge.upperSite) {\n            return false;\n        }\n        const d = edge.lowerSite.point.sub(edge.upperSite.point);\n        /*Assert.assert(d.x > 0 && d.y <= 0)*/\n        return d.x <= -0.5 * d.y;\n    }\n    static FindNodeInFrontBySite(cdtFrontElements, piSite) {\n        return cdtFrontElements.findLast((x) => x.LeftSite.point.x <= piSite.point.x);\n    }\n    InsertAndLegalizeTriangle(pi, frontElement) {\n        var _a;\n        if (Point.getTriangleOrientation(pi.point, frontElement.LeftSite.point, frontElement.RightSite.point) !== TriangleOrientation.Collinear) {\n            const tr = CdtTriangle.mkSED(pi, frontElement.Edge, this.createEdgeDelegate);\n            this.triangles.add(tr);\n            this.LegalizeEdge(pi, tr.Edges.getItem(0));\n        }\n        else {\n            // we need to split the triangle below the element of to two triangles and legalize the old edges\n            // we also delete, that is forget, the frontElement.Edge\n            const e = frontElement.Edge;\n            removeFromArray(e.upperSite.Edges, e);\n            let t = (_a = e.CcwTriangle) !== null && _a !== void 0 ? _a : e.CwTriangle;\n            const oppositeSite = t.OppositeSite(e);\n            CdtSweeper.RemoveTriangleButLeaveEdges(this.triangles, t);\n            t = CdtTriangle.mkSSSD(frontElement.LeftSite, oppositeSite, pi, this.createEdgeDelegate);\n            const t1 = CdtTriangle.mkSSSD(frontElement.RightSite, oppositeSite, pi, this.createEdgeDelegate);\n            this.triangles.add(t);\n            this.triangles.add(t1);\n            this.LegalizeEdge(pi, t.OppositeEdge(pi));\n            this.LegalizeEdge(pi, t1.OppositeEdge(pi));\n        }\n    }\n    LegalizeEdge(pi, edge) {\n        /*Assert.assert(pi !== edge.upperSite && pi !== edge.lowerSite)*/\n        if (edge.constrained || edge.CcwTriangle == null || edge.CwTriangle == null) {\n            return;\n        }\n        if (edge.CcwTriangle.Contains(pi)) {\n            this.LegalizeEdgeForOtherCwTriangle(pi, edge);\n        }\n        else {\n            this.LegalizeEdgeForOtherCcwTriangle(pi, edge);\n        }\n    }\n    LegalizeEdgeForOtherCwTriangle(pi, edge) {\n        const i = edge.CwTriangle.Edges.index(edge);\n        //           if (i === -1)\n        //           {\n        //               Array<DebugCurve> ls = new Array<DebugCurve>();\n        //               ls.Add(new DebugCurve(new Ellipse(2, 2, pi.point)));\n        //               for (int j = 0; j < 3; j++)\n        //               {\n        //                   var ee = edge.CwTriangle.Edges[j];\n        //                   ls.Add(new DebugCurve(100,1, j === i ? \"red\" : \"blue\", new LineSegment(ee.upperSite.point, ee.lowerSite.point)));\n        //               }\n        //               ls.Add(new DebugCurve(\"purple\", new LineSegment(edge.upperSite.point, edge.lowerSite.point)));\n        //\n        //               LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);\n        //           }\n        /*Assert.assert(i >= 0)*/\n        if (IsIllegal(pi, edge.upperSite, edge.CwTriangle.Sites.getItem(i + 2), edge.lowerSite)) {\n            //ShowIllegalEdge(edge, i, pi);\n            const e = Flip(pi, edge);\n            this.LegalizeEdge(pi, e.CwTriangle.OppositeEdge(pi));\n            this.LegalizeEdge(pi, e.CcwTriangle.OppositeEdge(pi));\n        }\n    }\n    LegalizeEdgeForOtherCcwTriangle(pi, edge) {\n        const i = edge.CcwTriangle.Edges.index(edge);\n        if (IsIllegal(pi, edge.lowerSite, edge.CcwTriangle.Sites.getItem(i + 2), edge.upperSite)) {\n            const e = Flip(pi, edge);\n            this.LegalizeEdge(pi, e.CwTriangle.OppositeEdge(pi));\n            this.LegalizeEdge(pi, e.CcwTriangle.OppositeEdge(pi));\n        }\n    }\n    // #if TEST_MSAGL && TEST_MSAGL\n    // Array < DebugCurve > ShowIllegalEdge(CdtEdge edge, CdtSite pi, int i) {\n    //     Array < DebugCurve > ls = new Array<DebugCurve>();\n    //     ls.push(DebugCurve.mkDebugCurveTWCI(new Ellipse(2, 2, pi.point)));\n    //     for (int j = 0; j < 3; j++) {\n    //         var ee = edge.CcwTriangle.Edges[j];\n    //         ls.push(DebugCurve.mkDebugCurveTWCI(j === i ? \"red\" : \"blue\", LineSegment.mkPP(ee.upperSite.point, ee.lowerSite.point)));\n    //     }\n    //     ls.push(DebugCurve.mkDebugCurveTWCI(100, 1, \"black\", Circumcircle(edge.CcwTriangle.Sites.getItem(0].point, edge.CcwTriangle.Sites[1].point, edge.CcwTriangle.Sites[2).point)));\n    //     LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);\n    //     return ls;\n    // }\n    //         static Ellipse Circumcircle(Point a, Point b, Point c) {\n    //     var mab = 0.5 * (a + b);\n    //     var mbc = 0.5 * (c + b);\n    //     Point center;\n    //     Point.LineLineIntersection(mab, mab + (b - a).Rotate(Math.PI / 2), mbc, mbc + (b - c).Rotate(Math.PI / 2), out center);\n    //     var r = (center - a).Length;\n    //     return new Ellipse(r, r, center);\n    // }\n    // #endif\n    ProjectToFront(site) {\n        return this.front.findLast((s) => s.x <= site.point.x);\n    }\n    runEdgeInserter() {\n        this.initEdgeInserter();\n        this.TraceEdgeThroughTriangles();\n        this.TriangulatePolygon0(this.rightPolygon, this.traversingEdge.upperSite, this.traversingEdge.lowerSite, true);\n        this.TriangulatePolygon0(this.leftPolygon, this.traversingEdge.upperSite, this.traversingEdge.lowerSite, false);\n        this.UpdateFront();\n    }\n    initEdgeInserter() {\n        this.rightPolygon = new Array();\n        this.leftPolygon = new Array();\n        this.addedTriangles = new Array();\n        this.piercedEdge = null;\n        this.piercedTriangle = null;\n        this.piercedToTheLeftFrontElemNode = null;\n        this.piercedToTheRightFrontElemNode = null;\n    }\n    UpdateFront() {\n        const newFrontEdges = new Set();\n        for (const t of this.addedTriangles) {\n            for (const e of t.Edges)\n                if (e.CwTriangle == null || e.CcwTriangle == null) {\n                    if (e.lowerSite == this.p_2 && e.upperSite == this.p_1) {\n                        continue;\n                    }\n                    newFrontEdges.add(e);\n                }\n        }\n        for (const e of newFrontEdges)\n            this.AddEdgeToFront(e);\n    }\n    AddEdgeToFront(e) {\n        const leftSite = e.upperSite.point.x < e.lowerSite.point.x ? e.upperSite : e.lowerSite;\n        this.front.insert(new CdtFrontElement(leftSite, e));\n    }\n    TriangulatePolygon0(polygon, a, b, reverseTrangleWhenCompare) {\n        if (polygon.length > 0) {\n            this.TriangulatePolygon1(0, polygon.length - 1, polygon, a, b, reverseTrangleWhenCompare);\n        }\n    }\n    TriangulatePolygon1(start, end, polygon, a, b, reverseTrangleWhenCompare) {\n        //            if(CdtSweeper.db)\n        //               CdtSweeper.ShowFront(triangles,front, Enumerable.Range(start, end-start+1).Select(i=> new Ellipse(10,10,polygon[i].point)).ToArray(), new[]{new LineSegment(a.point,b.point)});\n        let c = polygon[start];\n        let cIndex = start;\n        for (let i = start + 1; i <= end; i++) {\n            const v = polygon[i];\n            if (localInCircle(v)) {\n                cIndex = i;\n                c = v;\n            }\n        }\n        const t = CdtTriangle.mkSSSD(a, b, c, this.createEdgeDelegate);\n        this.triangles.add(t);\n        this.addedTriangles.push(t);\n        if (start < cIndex) {\n            this.TriangulatePolygon1(start, cIndex - 1, polygon, a, c, reverseTrangleWhenCompare);\n        }\n        if (cIndex < end) {\n            this.TriangulatePolygon1(cIndex + 1, end, polygon, c, b, reverseTrangleWhenCompare);\n        }\n        function localInCircle(v) {\n            return reverseTrangleWhenCompare ? InCircle(v, a, c, b) : InCircle(v, a, b, c);\n        }\n    }\n    TraceEdgeThroughTriangles() {\n        this.initEdgeTracer();\n        this.Traverse();\n    }\n    Traverse() {\n        while (!this.BIsReached()) {\n            if (this.piercedToTheLeftFrontElemNode != null) {\n                this.ProcessLeftFrontPiercedElement();\n            }\n            else if (this.piercedToTheRightFrontElemNode != null) {\n                this.ProcessRightFrontPiercedElement();\n            }\n            else {\n                this.ProcessPiercedEdge();\n            }\n        }\n        if (this.piercedTriangle != null) {\n            this.removePiercedTriangle(this.piercedTriangle);\n        }\n        this.FindMoreRemovedFromFrontElements();\n        for (const elem of this.elementsToBeRemovedFromFront) {\n            this.front.remove(elem);\n        }\n    }\n    ProcessLeftFrontPiercedElement() {\n        // CdtSweeper.ShowFront(triangles, front,new []{new LineSegment(a.point, b.point),new LineSegment(piercedToTheLeftFrontElemNode.item.Edge.lowerSite.point,piercedToTheLeftFrontElemNode.item.Edge.upperSite.point)},null);\n        let v = this.piercedToTheLeftFrontElemNode;\n        do {\n            this.elementsToBeRemovedFromFront.push(v.item);\n            this.AddSiteToLeftPolygon(v.item.LeftSite);\n            v = this.front.previous(v);\n        } while (Point.pointToTheLeftOfLine(v.item.LeftSite.point, this.a.point, this.b.point)); //that is why we are adding to the left polygon\n        this.elementsToBeRemovedFromFront.push(v.item);\n        this.AddSiteToRightPolygon(v.item.LeftSite);\n        if (v.item.LeftSite === this.b) {\n            this.piercedToTheLeftFrontElemNode = v;\n            // this will stop the traversal\n            return;\n        }\n        this.FindPiercedTriangle(v);\n        this.piercedToTheLeftFrontElemNode = null;\n    }\n    FindPiercedTriangle(v) {\n        var _a;\n        const e = v.item.Edge;\n        const t = (_a = e.CcwTriangle) !== null && _a !== void 0 ? _a : e.CwTriangle;\n        const eIndex = t.Edges.index(e);\n        for (let i = 1; i <= 2; i++) {\n            const ei = t.Edges.getItem(i + eIndex);\n            const signedArea0 = RealNumberSpan.sign(Point.signedDoubledTriangleArea(ei.lowerSite.point, this.a.point, this.b.point));\n            const signedArea1 = RealNumberSpan.sign(Point.signedDoubledTriangleArea(ei.upperSite.point, this.a.point, this.b.point));\n            if (signedArea1 * signedArea0 <= 0) {\n                this.piercedTriangle = t;\n                this.piercedEdge = ei;\n                break;\n            }\n        }\n    }\n    FindMoreRemovedFromFrontElements() {\n        for (const triangle of this.removedTriangles) {\n            for (const e of triangle.Edges) {\n                if (e.CcwTriangle == null && e.CwTriangle == null) {\n                    const site = e.upperSite.point.x < e.lowerSite.point.x ? e.upperSite : e.lowerSite;\n                    const frontNode = CdtSweeper.FindNodeInFrontBySite(this.front, site);\n                    if (frontNode.item.Edge === e) {\n                        this.elementsToBeRemovedFromFront.push(frontNode.item);\n                    }\n                }\n            }\n        }\n    }\n    ProcessPiercedEdge() {\n        // if(CdtSweeper.db)\n        //          CdtSweeper.ShowFront(triangles, front, new[] { new LineSegment(a.point, b.point) },\n        //                      new[] { new LineSegment(piercedEdge.upperSite.point, piercedEdge.lowerSite.point) });\n        if (this.piercedEdge.CcwTriangle === this.piercedTriangle) {\n            this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite);\n            this.AddSiteToRightPolygon(this.piercedEdge.upperSite);\n        }\n        else {\n            this.AddSiteToLeftPolygon(this.piercedEdge.upperSite);\n            this.AddSiteToRightPolygon(this.piercedEdge.lowerSite);\n        }\n        this.removePiercedTriangle(this.piercedTriangle);\n        this.PrepareNextStateAfterPiercedEdge();\n    }\n    PrepareNextStateAfterPiercedEdge() {\n        var _a, _b;\n        const t = (_a = this.piercedEdge.CwTriangle) !== null && _a !== void 0 ? _a : this.piercedEdge.CcwTriangle;\n        const eIndex = t.Edges.index(this.piercedEdge);\n        for (let i = 1; i <= 2; i++) {\n            const e = t.Edges.getItem(i + eIndex);\n            const signedArea0 = RealNumberSpan.sign(Point.signedDoubledTriangleArea(e.lowerSite.point, this.a.point, this.b.point));\n            const signedArea1 = RealNumberSpan.sign(Point.signedDoubledTriangleArea(e.upperSite.point, this.a.point, this.b.point));\n            if (signedArea1 * signedArea0 <= 0) {\n                if (e.CwTriangle != null && e.CcwTriangle != null) {\n                    this.piercedTriangle = t;\n                    this.piercedEdge = e;\n                    break;\n                }\n                // e has to belong to the front, and its triangle has to be removed\n                this.piercedTriangle = null;\n                this.piercedEdge = null;\n                const leftSite = e.upperSite.point.x < e.lowerSite.point.x ? e.upperSite : e.lowerSite;\n                const frontElem = CdtSweeper.FindNodeInFrontBySite(this.front, leftSite);\n                /*Assert.assert(frontElem != null)*/\n                if (leftSite.point.x < this.a.point.x) {\n                    this.piercedToTheLeftFrontElemNode = frontElem;\n                }\n                else {\n                    this.piercedToTheRightFrontElemNode = frontElem;\n                }\n                this.removePiercedTriangle((_b = e.CwTriangle) !== null && _b !== void 0 ? _b : e.CcwTriangle);\n                break;\n            }\n        }\n    }\n    removePiercedTriangle(t) {\n        this.triangles.delete(t);\n        for (const e of t.Edges) {\n            if (e.CwTriangle === t) {\n                e.CwTriangle = null;\n            }\n            else {\n                e.CcwTriangle = null;\n            }\n            this.removedTriangles.push(t);\n        }\n    }\n    ProcessRightFrontPiercedElement() {\n        let v = this.piercedToTheRightFrontElemNode;\n        do {\n            this.elementsToBeRemovedFromFront.push(v.item);\n            this.AddSiteToRightPolygon(v.item.RightSite);\n            v = this.front.next(v);\n        } while (Point.pointToTheRightOfLine(v.item.RightSite.point, this.a.point, this.b.point)); //that is why we are adding to the right polygon\n        this.elementsToBeRemovedFromFront.push(v.item);\n        this.AddSiteToLeftPolygon(v.item.RightSite);\n        if (v.item.RightSite === this.b) {\n            this.piercedToTheRightFrontElemNode = v; //this will stop the traversal\n            return;\n        }\n        this.FindPiercedTriangle(v);\n        this.piercedToTheRightFrontElemNode = null;\n    }\n    AddSiteToLeftPolygon(site) {\n        this.AddSiteToPolygonWithCheck(site, this.leftPolygon);\n    }\n    AddSiteToPolygonWithCheck(site, list) {\n        if (site === this.b) {\n            return;\n        }\n        if (list.length === 0 || list[list.length - 1] !== site) {\n            list.push(site);\n        }\n    }\n    AddSiteToRightPolygon(site) {\n        this.AddSiteToPolygonWithCheck(site, this.rightPolygon);\n    }\n    BIsReached() {\n        var _a;\n        const node = (_a = this.piercedToTheLeftFrontElemNode) !== null && _a !== void 0 ? _a : this.piercedToTheRightFrontElemNode;\n        if (node != null) {\n            return node.item.Edge.IsAdjacent(this.b);\n        }\n        return this.piercedEdge.IsAdjacent(this.b);\n    }\n    initEdgeTracer() {\n        this.elementsToBeRemovedFromFront = [];\n        this.a = this.traversingEdge.upperSite;\n        this.b = this.traversingEdge.lowerSite;\n        this.removedTriangles = [];\n        //            if (CdtSweeper.D)\n        //                CdtSweeper.ShowFront(triangles, front, new[] {new LineSegment(a.point, b.point)},null);\n        // new[] {new LineSegment(piercedEdge.upperSite.point, piercedEdge.lowerSite.point)});\n        const frontElemNodeRightOfA = CdtSweeper.FindNodeInFrontBySite(this.front, this.a);\n        const frontElemNodeLeftOfA = this.front.previous(frontElemNodeRightOfA);\n        if (Point.pointToTheLeftOfLine(this.b.point, frontElemNodeLeftOfA.item.LeftSite.point, frontElemNodeLeftOfA.item.RightSite.point)) {\n            this.piercedToTheLeftFrontElemNode = frontElemNodeLeftOfA;\n        }\n        else if (Point.pointToTheRightOfLine(this.b.point, frontElemNodeRightOfA.item.RightSite.point, frontElemNodeRightOfA.item.LeftSite.point)) {\n            this.piercedToTheRightFrontElemNode = frontElemNodeRightOfA;\n        }\n        else {\n            for (const e of this.a.Edges) {\n                const t = e.CcwTriangle;\n                if (t == null) {\n                    continue;\n                }\n                if (Point.pointToTheLeftOfLine(this.b.point, e.lowerSite.point, e.upperSite.point)) {\n                    continue;\n                }\n                const eIndex = t.Edges.index(e);\n                const site = t.Sites.getItem(eIndex + 2);\n                if (Point.pointToTheLeftOfLineOrOnLine(this.b.point, site.point, e.upperSite.point)) {\n                    this.piercedEdge = t.Edges.getItem(eIndex + 1);\n                    this.piercedTriangle = t;\n                    // CdtSweeper.ShowFront(triangles, front, new[] { new LineSegment(e.upperSite.point, e.lowerSite.point) },\n                    // new[] { new LineSegment(piercedEdge.upperSite.point, piercedEdge.lowerSite.point) });\n                    break;\n                }\n            }\n        }\n    }\n}\nfunction removeFromArray(arr, item) {\n    if (arr.length === 0)\n        return;\n    const i = arr.findIndex((e) => item === e);\n    if (i >= 0) {\n        if (i !== arr.length - 1) {\n            arr[i] = arr[arr.length - 1]; // save the last element\n        }\n        arr.pop();\n    }\n}\nfunction IsIllegal(pi, a, b, c) {\n    return InCone(pi, a, b, c) && InCircle(pi, a, b, c);\n}\nfunction InCone(pi, a, b, c) {\n    /*Assert.assert(\n      Point.getTriangleOrientation(a.point, b.point, c.point) ==\n        TriangleOrientation.Counterclockwise,\n    )*/\n    return (Point.getTriangleOrientation(a.point, pi.point, b.point) === TriangleOrientation.Clockwise &&\n        Point.getTriangleOrientation(b.point, pi.point, c.point) === TriangleOrientation.Clockwise);\n}\n// Testing that d of inside of the circumcircle of (a,b,c).\n// The good explanation of this test is of\n// \"Guibas, Stolfi,\"Primitives for the Manipulation of General Subdivisions and the Computation of Voronoi Diagrams\n//\nexport function InCircle(d, a, b, c) {\n    /*Assert.assert(\n      Point.getTriangleOrientation(a.point, b.point, c.point) ==\n        TriangleOrientation.Counterclockwise,\n    )*/\n    const axdx = a.point.x - d.point.x;\n    const aydy = a.point.y - d.point.y;\n    const bxdx = b.point.x - d.point.x;\n    const bydy = b.point.y - d.point.y;\n    const cxdx = c.point.x - d.point.x;\n    const cydy = c.point.y - d.point.y;\n    const t0 = axdx * axdx + aydy * aydy;\n    const t1 = bxdx * bxdx + bydy * bydy;\n    const t2 = cxdx * cxdx + cydy * cydy;\n    return axdx * (bydy * t2 - cydy * t1) - bxdx * (aydy * t2 - cydy * t0) + cxdx * (aydy * t1 - bydy * t0) > GeomConstants.tolerance;\n}\nfunction TriangleIsCorrect(t) {\n    if (Point.getTriangleOrientation(t.Sites.getItem(0).point, t.Sites.getItem(1).point, t.Sites.getItem(2).point) !=\n        TriangleOrientation.Counterclockwise) {\n        return false;\n    }\n    for (let i = 0; i < 3; i++) {\n        const e = t.Edges.getItem(i);\n        const a = t.Sites.getItem(i);\n        const b = t.Sites.getItem(i + 1);\n        if (!e.IsAdjacent(a) || !e.IsAdjacent(b))\n            return false;\n        if (e.upperSite === a) {\n            if (e.CcwTriangle !== t)\n                return false;\n        }\n        else if (e.CwTriangle !== t)\n            return false;\n    }\n    return true;\n}\nfunction Flip(pi, edge) {\n    /*Assert.assert(!edge.IsAdjacent(pi))*/\n    /*Assert.assert(edge.CcwTriangle.Contains(pi) || edge.CwTriangle.Contains(pi))*/\n    //get surrounding data\n    let t;\n    let ot;\n    if (edge.CcwTriangle.Contains(pi)) {\n        t = edge.CcwTriangle;\n        ot = edge.CwTriangle;\n    }\n    else {\n        t = edge.CwTriangle;\n        ot = edge.CcwTriangle;\n    }\n    /*Assert.assert(t.Contains(pi))*/\n    const eIndex = t.Edges.index(edge);\n    const eOtherIndex = ot.Edges.index(edge);\n    /*Assert.assert(eIndex > -1 && eOtherIndex > -1)*/\n    const pl = ot.Sites.getItem(eOtherIndex + 2);\n    const edgeBeforPi = t.Edges.getItem(eIndex + 1);\n    const edgeBeforPl = ot.Edges.getItem(eOtherIndex + 1);\n    //changing t\n    const newEdge = Cdt.GetOrCreateEdge(pi, pl);\n    t.Sites.setItem(eIndex + 1, pl);\n    t.Edges.setItem(eIndex, edgeBeforPl);\n    t.Edges.setItem(eIndex + 1, newEdge);\n    //changing ot\n    ot.Sites.setItem(eOtherIndex + 1, pi);\n    ot.Edges.setItem(eOtherIndex, edgeBeforPi);\n    ot.Edges.setItem(eOtherIndex + 1, newEdge);\n    //orient the new edge and the two edges that move from one triangle to another\n    if (edgeBeforPl.lowerSite === pl)\n        edgeBeforPl.CcwTriangle = t;\n    else\n        edgeBeforPl.CwTriangle = t;\n    if (edgeBeforPi.lowerSite === pi)\n        edgeBeforPi.CcwTriangle = ot;\n    else\n        edgeBeforPi.CwTriangle = ot;\n    if (newEdge.upperSite === pi) {\n        newEdge.CcwTriangle = ot;\n        newEdge.CwTriangle = t;\n    }\n    else {\n        newEdge.CcwTriangle = t;\n        newEdge.CwTriangle = ot;\n    }\n    /*Assert.assert(TriangleIsCorrect(t))*/\n    /*Assert.assert(TriangleIsCorrect(t))*/\n    //ShowFlip(pi, t, ot);\n    removeFromArray(edge.upperSite.Edges, edge); //forget the edge\n    return newEdge;\n}\n// #if TEST_MSAGL && TEST_MSAGL\n//    static void ShowFlip(CdtSite pi, CdtTriangle t, CdtTriangle ot) {\n//        Array<DebugCurve> ls=new Array<DebugCurve>();\n//        ls.Add(new DebugCurve(new Ellipse(2,2, pi.point)));\n//        for(int i=0;i<3;i++) {\n//            var e=t.Edges[i];\n//            ls.Add(new DebugCurve(100, 1, \"red\", new LineSegment(e.upperSite.point,e.lowerSite.point)));\n//        }\n//        for (int i = 0; i < 3; i++)\n//        {\n//            var e = ot.Edges[i];\n//            ls.Add(new DebugCurve(100, 1, \"blue\", new LineSegment(e.upperSite.point, e.lowerSite.point)));\n//        }\n//        ls.Add(new DebugCurve(Circumcircle(t.Sites.getItem(0].point, t.Sites[1].point, t.Sites[2).point)));\n//        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);\n//    }\n// #endif\n//# sourceMappingURL=CdtSweeper.js.map","import { PointLocation, GeomConstants } from '../../math/geometry';\nimport { segmentsIntersect } from '../../math/geometry/lineSegment';\nimport { Point, TriangleOrientation } from '../../math/geometry/point';\nimport { Rectangle } from '../../math/geometry/rectangle';\nimport { ThreeArray } from './ThreeArray';\n// a trianlge oriented counterclockwise\nexport class CdtTriangle {\n    constructor() {\n        // the edges\n        this.Edges = new ThreeArray();\n        // the sites\n        this.Sites = new ThreeArray();\n    }\n    containsPoint(p) {\n        return CdtTriangle.PointLocationForTriangle(p, this) !== PointLocation.Outside;\n    }\n    static PointLocationForTriangle(p, triangle) {\n        let seenBoundary = false;\n        for (let i = 0; i < 3; i++) {\n            const area = Point.signedDoubledTriangleArea(p, triangle.Sites.getItem(i).point, triangle.Sites.getItem(i + 1).point);\n            if (area < -GeomConstants.distanceEpsilon) {\n                return PointLocation.Outside;\n            }\n            if (area < GeomConstants.distanceEpsilon) {\n                seenBoundary = true;\n            }\n        }\n        return seenBoundary ? PointLocation.Boundary : PointLocation.Inside;\n    }\n    /** extend by eps the triangles edges before the test */\n    intersectsLine(a, b, eps) {\n        if (CdtTriangle.PointLocationForTriangle(a, this) != PointLocation.Outside)\n            return true;\n        if (CdtTriangle.PointLocationForTriangle(b, this) != PointLocation.Outside)\n            return true;\n        for (const e of this.Edges) {\n            if (this.abIntersectsTrianglSide(a, b, e))\n                return true;\n        }\n        return false;\n    }\n    abIntersectsTrianglSide(a, b, e) {\n        return segmentsIntersect(a, b, e.lowerSite.point, e.upperSite.point);\n    }\n    static mkSSSD(a, b, c, createEdgeDelegate) {\n        const orientation = Point.getTriangleOrientation(a.point, b.point, c.point);\n        const r = new CdtTriangle();\n        switch (orientation) {\n            case TriangleOrientation.Counterclockwise:\n                r.FillCcwTriangle(a, b, c, createEdgeDelegate);\n                break;\n            case TriangleOrientation.Clockwise:\n                r.FillCcwTriangle(a, c, b, createEdgeDelegate);\n                break;\n            default:\n                throw new Error();\n                break;\n        }\n        return r;\n    }\n    static mkSED(pi, edge, createEdgeDelegate) {\n        const tri = new CdtTriangle();\n        switch (Point.getTriangleOrientation(edge.upperSite.point, edge.lowerSite.point, pi.point)) {\n            case TriangleOrientation.Counterclockwise:\n                edge.CcwTriangle = tri;\n                tri.Sites.setItem(0, edge.upperSite);\n                tri.Sites.setItem(1, edge.lowerSite);\n                break;\n            case TriangleOrientation.Clockwise:\n                edge.CwTriangle = tri;\n                tri.Sites.setItem(0, edge.lowerSite);\n                tri.Sites.setItem(1, edge.upperSite);\n                break;\n            default:\n                throw new Error();\n        }\n        tri.Edges.setItem(0, edge);\n        tri.Sites.setItem(2, pi);\n        tri.CreateEdge(1, createEdgeDelegate);\n        tri.CreateEdge(2, createEdgeDelegate);\n        return tri;\n    }\n    //\n    static mkSSSEE(aLeft, aRight, bRight, a, b, createEdgeDelegate) {\n        /*Assert.assert(\n          Point.getTriangleOrientation(aLeft.point, aRight.point, bRight.point) ==\n            TriangleOrientation.Counterclockwise,\n        )*/\n        const tri = CdtTriangle.mkSSSD(aLeft, aRight, bRight, createEdgeDelegate);\n        tri.Edges.setItem(0, a);\n        tri.Edges.setItem(1, b);\n        tri.BindEdgeToTriangle(aLeft, a);\n        tri.BindEdgeToTriangle(aRight, b);\n        tri.CreateEdge(2, createEdgeDelegate);\n        return tri;\n    }\n    // in the trianlge, which is always oriented counterclockwise, the edge starts at site\n    BindEdgeToTriangle(site, edge) {\n        if (site === edge.upperSite) {\n            edge.CcwTriangle = this;\n        }\n        else {\n            edge.CwTriangle = this;\n        }\n    }\n    // here a,b,c comprise a ccw triangle\n    FillCcwTriangle(a, b, c, createEdgeDelegate) {\n        this.Sites.setItem(0, a);\n        this.Sites.setItem(1, b);\n        this.Sites.setItem(2, c);\n        for (let i = 0; i < 3; i++) {\n            this.CreateEdge(i, createEdgeDelegate);\n        }\n    }\n    CreateEdge(i, createEdgeDelegate) {\n        const a = this.Sites.getItem(i);\n        const b = this.Sites.getItem(i + 1);\n        const edge = createEdgeDelegate(a, b);\n        this.Edges.setItem(i, edge);\n        this.BindEdgeToTriangle(a, edge);\n    }\n    Contains(cdtSite) {\n        return this.Sites.has(cdtSite);\n    }\n    OppositeEdge(pi) {\n        const index = this.Sites.index(pi);\n        /*Assert.assert(index !== -1)*/\n        return this.Edges.getItem(index + 1);\n    }\n    // #if TEST_MSAGL&&TEST_MSAGL\n    //         // Returns a <see cref=\"T:System.String\"/> that represents the current <see cref=\"T:System.Object\"/>.\n    //         // A <see cref=\"T:System.String\"/> that represents the current <see cref=\"T:System.Object\"/>.\n    //         // <filterpriority>2</filterpriority>\n    //         public override string ToString() {\n    //             return String.Format(\"({0},{1},{2}\", Sites[0], Sites[1], Sites[2]);\n    //         }\n    // #endif\n    OppositeSite(cdtEdge) {\n        const i = this.Edges.index(cdtEdge);\n        return this.Sites.getItem(i + 2);\n    }\n    BoundingBox() {\n        const rect = Rectangle.mkPP(this.Sites.getItem(0).point, this.Sites.getItem(1).point);\n        rect.add(this.Sites.getItem(2).point);\n        return rect;\n    }\n    static mkSSSEED(aLeft, aRight, bRight, a, b, createEdgeDelegate) {\n        const t = new CdtTriangle();\n        t.Sites.setItem(0, aLeft);\n        t.Sites.setItem(1, aRight);\n        t.Sites.setItem(2, bRight);\n        t.Edges.setItem(0, a);\n        t.Edges.setItem(1, b);\n        t.BindEdgeToTriangle(aLeft, a);\n        t.BindEdgeToTriangle(aRight, b);\n        t.CreateEdge(2, createEdgeDelegate);\n        return t;\n    }\n    toString() {\n        return this.Sites.getItem(0).toString() + ',' + this.Sites.getItem(1).toString() + ',' + this.Sites.getItem(2).toString();\n    }\n}\n//# sourceMappingURL=CdtTriangle.js.map","export class PerimeterEdge {\n    constructor(edge) {\n        /*Assert.assert(\n          edge.CcwTriangle == null  || edge.CwTriangle == null ,\n          'one of the edge triangles has to be null',\n        )*/\n        this.Edge = edge;\n    }\n}\n//# sourceMappingURL=PerimeterEdge.js.map","export class ThreeArray {\n    has(t) {\n        return t === this.item0 || t === this.item1 || t === this.item2;\n    }\n    index(t) {\n        if (t === this.item0) {\n            return 0;\n        }\n        if (t === this.item1) {\n            return 1;\n        }\n        if (t === this.item2) {\n            return 2;\n        }\n        return -1;\n    }\n    getItem(i) {\n        switch (i) {\n            case 0:\n            case 3:\n            case -3:\n                return this.item0;\n                break;\n            case 1:\n            case 4:\n            case -2:\n                return this.item1;\n                break;\n            case 2:\n            case 5:\n            case -1:\n                return this.item2;\n                break;\n            default:\n                throw new Error();\n                break;\n        }\n    }\n    setItem(i, value) {\n        switch (i) {\n            case 0:\n            case 3:\n            case -3:\n                this.item0 = value;\n                break;\n            case 1:\n            case 4:\n            case -2:\n                this.item1 = value;\n                break;\n            case 2:\n            case 5:\n            case -1:\n                this.item2 = value;\n                break;\n            default:\n                throw new Error();\n                break;\n        }\n    }\n    [Symbol.iterator]() {\n        return this.GetEnumerator();\n    }\n    // Returns an enumerator that iterates through the collection.\n    *GetEnumerator() {\n        yield this.item0;\n        yield this.item1;\n        yield this.item2;\n    }\n}\nexport function constructor(item0, item1, item2) {\n    const r = new ThreeArray();\n    r.item0 = item0;\n    r.item1 = item1;\n    r.item2 = item2;\n    return r;\n}\n//# sourceMappingURL=ThreeArray.js.map","// defines the way edges are routed\nexport var EdgeRoutingMode;\n(function (EdgeRoutingMode) {\n    EdgeRoutingMode[EdgeRoutingMode[\"Spline\"] = 0] = \"Spline\";\n    EdgeRoutingMode[EdgeRoutingMode[\"SplineBundling\"] = 1] = \"SplineBundling\";\n    EdgeRoutingMode[EdgeRoutingMode[\"StraightLine\"] = 2] = \"StraightLine\";\n    EdgeRoutingMode[EdgeRoutingMode[\"SugiyamaSplines\"] = 3] = \"SugiyamaSplines\";\n    EdgeRoutingMode[EdgeRoutingMode[\"Rectilinear\"] = 4] = \"Rectilinear\";\n    EdgeRoutingMode[EdgeRoutingMode[\"RectilinearToCenter\"] = 5] = \"RectilinearToCenter\";\n    EdgeRoutingMode[EdgeRoutingMode[\"None\"] = 6] = \"None\";\n})(EdgeRoutingMode || (EdgeRoutingMode = {}));\n//# sourceMappingURL=EdgeRoutingMode.js.map","import { BundlingSettings } from './BundlingSettings';\nimport { EdgeRoutingMode } from './EdgeRoutingMode';\nexport class EdgeRoutingSettings {\n    toJSON() {\n        const ret = {};\n        if (this.EdgeRoutingMode != EdgeRoutingMode.Spline)\n            ret.edgeRoutingMode = EdgeRoutingMode.Spline;\n        if (this.ConeAngle != 30 * (Math.PI / 180))\n            ret.coneAngle = this.ConeAngle;\n        if (this.padding != 3)\n            ret.padding = this.padding;\n        if (this.polylinePadding != 1.5)\n            ret.polylinePadding = this.polylinePadding;\n        if (this.bundlingSettings)\n            ret.bundlingSettingsJSON = this.bundlingSettings.toJSON();\n        return ret;\n    }\n    static fromJSON(source) {\n        const ret = new EdgeRoutingSettings();\n        if (source.edgeRoutingMode)\n            source.edgeRoutingMode = ret.edgeRoutingMode;\n        if (source.coneAngle)\n            ret.coneAngle = source.coneAngle;\n        // Amount of space to leave around nodes\n        if (source.padding)\n            ret.padding = source.padding;\n        if (source.polylinePadding)\n            ret.polylinePadding = source.polylinePadding;\n        // the settings for general edge bundling\n        if (source.bundlingSettingsJSON)\n            ret.bundlingSettings = BundlingSettings.createFromJSON(source.bundlingSettingsJSON);\n        if (source.routingToParentConeAngle)\n            ret.routingToParentConeAngle = source.routingToParentConeAngle;\n        if (source.simpleSelfLoopsForParentEdgesThreshold)\n            ret.simpleSelfLoopsForParentEdgesThreshold = source.simpleSelfLoopsForParentEdgesThreshold;\n        if (source.incrementalRoutingThreshold)\n            ret.incrementalRoutingThreshold = source.incrementalRoutingThreshold;\n        if (source.routeMultiEdgesAsBundles)\n            ret.routeMultiEdgesAsBundles = source.routeMultiEdgesAsBundles;\n        // if set to true the original spline is kept under the corresponding GeomEdge\n        if (source.KeepOriginalSpline)\n            ret.KeepOriginalSpline = source.KeepOriginalSpline;\n        return ret;\n    }\n    constructor() {\n        this.coneAngle = 30 * (Math.PI / 180);\n        // Amount of space to leave around nodes\n        this.padding = 2;\n        this.polylinePadding = 1;\n        this.routingToParentConeAngle = Math.PI / 6;\n        this.simpleSelfLoopsForParentEdgesThreshold = 200;\n        this.incrementalRoutingThreshold = 5000000;\n        // debugging\n        this.routeMultiEdgesAsBundles = true;\n        // if set to true the original spline is kept under the corresponding GeomEdge\n        this.KeepOriginalSpline = false;\n        this.EdgeRoutingMode = EdgeRoutingMode.Spline;\n    }\n    // defines the way edges are routed\n    get EdgeRoutingMode() {\n        return this.edgeRoutingMode;\n    }\n    set EdgeRoutingMode(value) {\n        if (value === EdgeRoutingMode.SplineBundling && this.bundlingSettings == null) {\n            if (this.bundlingSettings == null) {\n                this.bundlingSettings = new BundlingSettings();\n            }\n        }\n        this.edgeRoutingMode = value;\n    }\n    // the angle in degrees of the cones in the routing with the spanner\n    get ConeAngle() {\n        return this.coneAngle;\n    }\n    set ConeAngle(value) {\n        this.coneAngle = value;\n    }\n    // Amount of space to leave around nodes\n    get Padding() {\n        return this.padding;\n    }\n    set Padding(value) {\n        this.padding = value;\n    }\n    // Additional amount of padding to leave around nodes when routing with polylines\n    get PolylinePadding() {\n        return this.polylinePadding;\n    }\n    set PolylinePadding(value) {\n        this.polylinePadding = value;\n    }\n    // this is a cone angle to find a relatively close point on the parent boundary\n    get RoutingToParentConeAngle() {\n        return this.routingToParentConeAngle;\n    }\n    set RoutingToParentConeAngle(value) {\n        this.routingToParentConeAngle = value;\n    }\n    // if the number of the nodes participating in the routing of the parent edges is less than the threshold\n    // then the parent edges are routed avoiding the nodes\n    get SimpleSelfLoopsForParentEdgesThreshold() {\n        return this.simpleSelfLoopsForParentEdgesThreshold;\n    }\n    set SimpleSelfLoopsForParentEdgesThreshold(value) {\n        this.simpleSelfLoopsForParentEdgesThreshold = value;\n    }\n    // defines the size of the changed graph that could be routed fast with the standard spline routing when dragging\n    get IncrementalRoutingThreshold() {\n        return this.incrementalRoutingThreshold;\n    }\n    set IncrementalRoutingThreshold(value) {\n        this.incrementalRoutingThreshold = value;\n    }\n    // if set to true routes multi edges as ordered bundles, when routing in a spline mode\n    // <exception cref=\"NotImplementedException\"></exception>\n    get RouteMultiEdgesAsBundles() {\n        return this.routeMultiEdgesAsBundles;\n    }\n    set RouteMultiEdgesAsBundles(value) {\n        this.routeMultiEdgesAsBundles = value;\n    }\n}\n//# sourceMappingURL=EdgeRoutingSettings.js.map","import { Curve, PointLocation } from '../math/geometry';\nimport { HitTestBehavior } from '../math/geometry/RTree/hitTestBehavior';\nimport { createRectangleNodeOnData } from '../math/geometry/RTree/rectangleNode';\nimport { CrossRectangleNodesSameType } from '../math/geometry/RTree/rectangleNodeUtils';\nimport { GetConnectedComponents } from '../math/graphAlgorithms/ConnectedComponentCalculator';\nimport { mkGraphOnEdgesN } from '../structs/basicGraphOnEdges';\nimport { IntPair } from '../utils/IntPair';\nimport { PreGraph } from './PreGraph';\nimport { BundleRouter } from './spline/bundling/BundleRouter';\nimport { SdShortestPath } from './spline/bundling/SdShortestPath';\nexport class MultiEdgeRouter {\n    constructor(multiEdges, interactiveEdgeRouter, nodeBoundaryCurves, bundlingSettings, transparentShapeSetter) {\n        this.multiEdges = multiEdges;\n        this.interactiveEdgeRouter = interactiveEdgeRouter;\n        this.bundlingSettings = bundlingSettings;\n        this.bundlingSettings.edgeWidthShrinkCoeff = 1;\n        this.transparentShapeSetter = transparentShapeSetter;\n        this.nodeTree = createRectangleNodeOnData(nodeBoundaryCurves, (c) => c.boundingBox);\n    }\n    run() {\n        for (const graph of this.GetIndependantPreGraphs()) {\n            const br = new BundleRouter(graph.edges, new SdShortestPath(this.transparentShapeSetter, null, null), this.interactiveEdgeRouter.VisibilityGraph, this.bundlingSettings, this.interactiveEdgeRouter.LoosePadding, this.interactiveEdgeRouter.TightHierarchy, this.interactiveEdgeRouter.LooseHierarchy, null, null, null);\n            br.run();\n        }\n    }\n    GetPortCurve(port) {\n        const curve = this.nodeTree.FirstHitNodeWithPredicate(port.Location, (point, c) => Curve.PointRelativeToCurveLocation(point, c) !== PointLocation.Outside ? HitTestBehavior.Stop : HitTestBehavior.Continue).UserData;\n        return curve;\n    }\n    // creates a set of pregraphs suitable for bundle routing\n    GetIndependantPreGraphs() {\n        const preGraphs = this.CreateInitialPregraphs();\n        do {\n            const count = preGraphs.length;\n            const t = { preGraphs: preGraphs };\n            this.UniteConnectedPreGraphs(t);\n            if (count <= preGraphs.length)\n                break;\n        } while (true);\n        return preGraphs;\n    }\n    UniteConnectedPreGraphs(t) {\n        const intersectionGraph = MultiEdgeRouter.GetIntersectionGraphOfPreGraphs(t.preGraphs);\n        if (intersectionGraph == null)\n            return;\n        const connectedComponents = GetConnectedComponents(intersectionGraph);\n        const newPreGraphList = new Array();\n        for (const component of connectedComponents) {\n            let preGraph = null;\n            for (const i of component) {\n                if (preGraph == null) {\n                    preGraph = t.preGraphs[i];\n                    newPreGraphList.push(preGraph);\n                }\n                else {\n                    preGraph.AddGraph(t.preGraphs[i]);\n                }\n            }\n        }\n        t.preGraphs = newPreGraphList;\n        for (const pg of t.preGraphs)\n            this.AddIntersectingNodes(pg);\n    }\n    AddIntersectingNodes(pg) {\n        const rect = pg.boundingBox;\n        for (const curve of this.nodeTree.GetNodeItemsIntersectingRectangle(rect)) {\n            pg.AddNodeBoundary(curve);\n        }\n    }\n    static GetIntersectionGraphOfPreGraphs(preGraphs) {\n        const intersectingPairs = MultiEdgeRouter.EnumeratePairsOfIntersectedPreGraphs(preGraphs);\n        if (intersectingPairs.length) {\n            return mkGraphOnEdgesN(intersectingPairs, preGraphs.length);\n        }\n        return null;\n    }\n    static EnumeratePairsOfIntersectedPreGraphs(preGraphs) {\n        const arr = Array.from(Array(preGraphs.length).keys());\n        const rn = createRectangleNodeOnData(arr, (i) => preGraphs[i].boundingBox);\n        const list = new Array();\n        CrossRectangleNodesSameType(rn, rn, (i, j) => list.push(new IntPair(i, j)));\n        return list;\n    }\n    CreateInitialPregraphs() {\n        return this.multiEdges.map((a) => this.CreatePregraphFromSetOfEdgeGeometries(a));\n    }\n    CreatePregraphFromSetOfEdgeGeometries(egs) {\n        const nodeBoundaries = new Set();\n        const eg = egs[0];\n        const c = this.GetPortCurve(eg.sourcePort);\n        const rect = c.boundingBox;\n        nodeBoundaries.add(c);\n        nodeBoundaries.add(eg.targetPort.Curve);\n        rect.addRec(eg.targetPort.Curve.boundingBox);\n        const overlapped = this.nodeTree.GetNodeItemsIntersectingRectangle(rect);\n        for (const nodeBoundary of overlapped)\n            nodeBoundaries.add(nodeBoundary);\n        return PreGraph.constructorStatic(egs, nodeBoundaries);\n    }\n}\n//# sourceMappingURL=MultiEdgeRouter.js.map","import { GenericBinaryHeapPriorityQueue } from '../structs/genericBinaryHeapPriorityQueue';\nimport { TollFreeVisibilityEdge } from './visibility/TollFreeVisibilityEdge';\nexport class MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph {\n    constructor(sourceVisVertices, targetVisVertices, visibilityGraph) {\n        this.upperBound = Number.POSITIVE_INFINITY;\n        this._visGraph = visibilityGraph;\n        visibilityGraph.ClearPrevEdgesTable();\n        for (const v of visibilityGraph.Vertices())\n            v.Distance = Number.POSITIVE_INFINITY;\n        this.sources = sourceVisVertices;\n        this.targets = new Set(targetVisVertices);\n    }\n    // Returns  a  path\n    GetPath() {\n        const pq = new GenericBinaryHeapPriorityQueue();\n        for (const v of this.sources) {\n            v.Distance = 0;\n            pq.Enqueue(v, 0);\n        }\n        while (!pq.IsEmpty()) {\n            this._current = pq.Dequeue();\n            if (this.targets.has(this._current))\n                break;\n            for (const e of this._current.OutEdges)\n                if (this.PassableOutEdge(e))\n                    this.ProcessNeighbor(pq, e, e.Target);\n            for (const e of this._current.InEdges.filter(this.PassableInEdge.bind))\n                this.ProcessNeighbor(pq, e, e.Source);\n        }\n        return this._visGraph.PreviosVertex(this._current) == null ? null : this.CalculatePath();\n    }\n    PassableOutEdge(e) {\n        return this.targets.has(e.Target) || !MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e);\n    }\n    PassableInEdge(e) {\n        return this.targets.has(e.Source) || !MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e);\n    }\n    static IsForbidden(e) {\n        return ((e.IsPassable != null && !e.IsPassable()) || e) instanceof TollFreeVisibilityEdge;\n    }\n    ProcessNeighbor(pq, l, v) {\n        const len = l.Length;\n        const c = this._current.Distance + len;\n        if (c >= this.upperBound) {\n            return;\n        }\n        if (this.targets.has(v)) {\n            this.upperBound = c;\n            this.closestTarget = v;\n        }\n        if (this._visGraph.PreviosVertex(v) == null) {\n            v.Distance = c;\n            this._visGraph.SetPreviousEdge(v, l);\n            pq.Enqueue(v, c);\n        }\n        else if (c < v.Distance) {\n            // This condition should never hold for the dequeued nodes.\n            // However because of a very rare case of an epsilon error it might!\n            // In this case DecreasePriority will fail to find \"v\" and the algorithm will continue working.\n            // Since v is not in the queue changing its .Distance will not mess up the queue.\n            // Changing v.Prev is fine since we come up with a path with an insignificantly\n            // smaller distance.\n            v.Distance = c;\n            this._visGraph.SetPreviousEdge(v, l);\n            pq.DecreasePriority(v, c);\n        }\n    }\n    CalculatePath() {\n        if (this.closestTarget == null) {\n            return null;\n        }\n        const ret = new Array();\n        let v = this.closestTarget;\n        do {\n            ret.push(v);\n            v = this._visGraph.PreviosVertex(v);\n        } while (v.Distance > 0);\n        ret.push(v);\n        return ret.reverse();\n    }\n}\n//# sourceMappingURL=MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.js.map","import { Rectangle } from '..';\nimport { uniteSets } from '../utils/setOperations';\n// this class contains a set of edge geometries, and set of node boundaries, ICurves, that might obstruct the edge routing\nexport class PreGraph {\n    static constructorStatic(egs, nodeBoundaries) {\n        const pg = new PreGraph();\n        pg.edges = egs;\n        pg.nodeBoundaries = nodeBoundaries;\n        pg.boundingBox = Rectangle.mkEmpty();\n        for (const curve of pg.nodeBoundaries) {\n            pg.boundingBox = pg.boundingBox.addRec(curve.boundingBox);\n        }\n        return pg;\n    }\n    AddGraph(a) {\n        this.edges = this.edges.concat(a.edges);\n        this.nodeBoundaries = uniteSets(this.nodeBoundaries, a.nodeBoundaries);\n        this.boundingBox.addRec(a.boundingBox);\n    }\n    AddNodeBoundary(curve) {\n        this.nodeBoundaries.add(curve);\n        this.boundingBox.addRec(curve.boundingBox);\n    }\n}\n//# sourceMappingURL=PreGraph.js.map","// A shape wrapping an ICurve delegate, providing additional information.\nimport { Shape } from './shape';\nexport class RelativeShape extends Shape {\n    get BoundaryCurve() {\n        return this.node.boundaryCurve;\n    }\n    set BoundaryCurve(value) {\n        if (value)\n            throw new Error('Cannot set BoundaryCurve directly for RelativeShape');\n    }\n    // Constructor taking the ID and the curve delegate for the shape.\n    constructor(node) {\n        super(null);\n        this.node = node;\n    }\n}\n//# sourceMappingURL=RelativeShape.js.map","// Class for creating Shape elements from a Graph.\nimport { GeomGraph } from '../layout/core/geomGraph';\nimport { HookUpAnywhereFromInsidePort } from '../layout/core/hookUpAnywhereFromInsidePort';\nimport { RelativeFloatingPort } from '../layout/core/relativeFloatingPort';\nimport { ToAncestorEnum } from '../structs/edge';\n// import {Assert} from '../utils/assert'\nimport { ClusterBoundaryPort } from './ClusterBoundaryPort';\nimport { RelativeShape } from './RelativeShape';\nexport class ShapeCreator {\n    /**  For a given graph finds the obstacles for nodes and clusters, correctly parenting the obstacles\n         according to the cluster hierarchy\n         graph with edges to route and nodes/clusters to route around.\n         Returns the set of obstacles with correct cluster hierarchy and ports\n    */\n    static GetShapes(graph, edges = Array.from(graph.shallowEdges)) {\n        const nodesToShapes = new Map();\n        getShapesUnderGraph(graph, nodesToShapes);\n        for (const edge of edges) {\n            let shape = nodesToShapes.get(edge.source);\n            if (shape) {\n                if (edge.sourcePort != null) {\n                    shape.Ports.add(edge.sourcePort);\n                }\n            }\n            shape = nodesToShapes.get(edge.target);\n            if (shape) {\n                if (edge.targetPort != null) {\n                    shape.Ports.add(edge.targetPort);\n                }\n            }\n        }\n        return Array.from(nodesToShapes.values());\n    }\n    /**   Creates a shape with a RelativeFloatingPort for the node center, attaches it to the shape and all edges */\n    static CreateShapeWithCenterPort(node) {\n        // Assert.assert(ApproximateComparer.Close(node.BoundaryCurve.BoundingBox, node.BoundingBox), \"node's curve doesn't fit its bounds!\");\n        const shape = new RelativeShape(node);\n        const port = RelativeFloatingPort.mk(() => node.boundaryCurve, () => node.center);\n        shape.Ports.add(port);\n        for (const e of node.inEdges()) {\n            ShapeCreator.FixPortAtTarget(port, e);\n        }\n        for (const e of node.outEdges()) {\n            ShapeCreator.FixPortAtSource(port, e);\n        }\n        for (const e of node.selfEdges()) {\n            ShapeCreator.FixPortAtSource(port, e);\n            ShapeCreator.FixPortAtTarget(port, e);\n        }\n        return shape;\n    }\n    /**   Creates a ClusterBoundaryPort for the cluster boundary, attaches it to the shape and all edges */\n    static CreateShapeWithClusterBoundaryPort(cluster) {\n        // Assert.assert(ApproximateComparer.Close(node.BoundaryCurve.BoundingBox, node.BoundingBox), \"node's curve doesn't fit its bounds!\");\n        // Assert.assert(cluster instanceof GeomGraph)\n        const shape = new RelativeShape(cluster);\n        const port = ClusterBoundaryPort.mk(() => cluster.boundaryCurve, () => cluster.center);\n        shape.Ports.add(port);\n        let clusterPort = undefined;\n        for (const e of cluster.inEdges()) {\n            if (e.EdgeToAncestor() === ToAncestorEnum.ToAncestor) {\n                if (clusterPort == null) {\n                    clusterPort = new HookUpAnywhereFromInsidePort(() => cluster.boundaryCurve);\n                }\n                e.targetPort = clusterPort;\n            }\n            else {\n                ShapeCreator.FixPortAtTarget(port, e);\n            }\n        }\n        for (const e of cluster.outEdges()) {\n            if (e.EdgeToAncestor() === ToAncestorEnum.FromAncestor) {\n                if (clusterPort == null) {\n                    clusterPort = new HookUpAnywhereFromInsidePort(() => cluster.boundaryCurve);\n                }\n                e.sourcePort = clusterPort;\n            }\n            else {\n                ShapeCreator.FixPortAtSource(port, e);\n            }\n        }\n        for (const e of cluster.selfEdges()) {\n            ShapeCreator.FixPortAtSource(port, e);\n            ShapeCreator.FixPortAtTarget(port, e);\n        }\n        return shape;\n    }\n    static FixPortAtSource(port, e) {\n        if (e == null)\n            return;\n        if (e.sourcePort == null) {\n            e.sourcePort = port;\n        }\n    }\n    static FixPortAtTarget(port, e) {\n        if (e == null)\n            return;\n        if (e.targetPort == null) {\n            e.targetPort = port;\n        }\n    }\n}\nfunction getShapesUnderGraph(graph, nodesToShapes) {\n    for (const n of graph.shallowNodes) {\n        if (n instanceof GeomGraph) {\n            const nShape = ShapeCreator.CreateShapeWithClusterBoundaryPort(n);\n            nodesToShapes.set(n, nShape);\n            const ng = n;\n            if (!ng.isCollapsed) {\n                getShapesUnderGraph(ng, nodesToShapes);\n                for (const ch of ng.shallowNodes) {\n                    nShape.AddChild(nodesToShapes.get(ch));\n                }\n            }\n        }\n        else {\n            nodesToShapes.set(n, ShapeCreator.CreateShapeWithCenterPort(n));\n        }\n    }\n}\n//# sourceMappingURL=ShapeCreator.js.map","import { GeomGraph } from '../layout/core/geomGraph';\nimport { GeomObject } from '../layout/core/geomObject';\nimport { RelativeShape } from './RelativeShape';\nexport class ShapeCreatorForRoutingToParents {\n    static GetShapes(inParentEdges, outParentEdges) {\n        const nodesToShapes = new Map();\n        for (const edge of inParentEdges) {\n            ShapeCreatorForRoutingToParents.ProcessAncestorDescendantCouple(edge.target, edge.source, nodesToShapes);\n            ShapeCreatorForRoutingToParents.InsertEdgePortsToShapes(nodesToShapes, edge);\n        }\n        for (const edge of outParentEdges) {\n            ShapeCreatorForRoutingToParents.ProcessAncestorDescendantCouple(edge.source, edge.target, nodesToShapes);\n            ShapeCreatorForRoutingToParents.InsertEdgePortsToShapes(nodesToShapes, edge);\n        }\n        ShapeCreatorForRoutingToParents.BindShapes(nodesToShapes);\n        return Array.from(nodesToShapes.values());\n    }\n    static InsertEdgePortsToShapes(nodesToShapes, edge) {\n        nodesToShapes.get(edge.target).Ports.add(edge.targetPort);\n        nodesToShapes.get(edge.source).Ports.add(edge.sourcePort);\n    }\n    static BindShapes(nodesToShapes) {\n        for (const [key, shape] of nodesToShapes) {\n            if (!(key instanceof GeomGraph)) {\n                continue;\n            }\n            const cluster = key;\n            for (const child of Children(cluster)) {\n                const childShape = nodesToShapes.get(child);\n                if (childShape) {\n                    shape.AddChild(childShape);\n                }\n            }\n        }\n    }\n    static ProcessAncestorDescendantCouple(ancestor, geomNode, nodesToShapes) {\n        let parent = Parent(geomNode);\n        do {\n            for (const n of Children(parent))\n                ShapeCreatorForRoutingToParents.CreateShapeIfNeeeded(n, nodesToShapes);\n            if (parent === ancestor)\n                break;\n            parent = Parent(parent);\n        } while (true);\n        ShapeCreatorForRoutingToParents.CreateShapeIfNeeeded(parent, nodesToShapes);\n    }\n    static CreateShapeIfNeeeded(n, nodesToShapes) {\n        if (nodesToShapes.has(n)) {\n            return;\n        }\n        nodesToShapes.set(n, new RelativeShape(n));\n    }\n    static NumberOfActiveNodesIsUnderThreshold(inParentEdges, outParentEdges, threshold) {\n        const usedNodeSet = new Set();\n        for (const edge of inParentEdges) {\n            if (ShapeCreatorForRoutingToParents.SetOfActiveNodesIsLargerThanThreshold(edge.target, edge.source, usedNodeSet, threshold)) {\n                return false;\n            }\n        }\n        for (const edge of outParentEdges) {\n            if (ShapeCreatorForRoutingToParents.SetOfActiveNodesIsLargerThanThreshold(edge.source, edge.target, usedNodeSet, threshold)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static SetOfActiveNodesIsLargerThanThreshold(ancestor, node, usedNodeSet, threshold) {\n        let parent = Parent(node);\n        while (true) {\n            for (const n of Children(parent)) {\n                usedNodeSet.add(n);\n                if (usedNodeSet.size > threshold) {\n                    return true;\n                }\n            }\n            if (parent === ancestor) {\n                break;\n            }\n            parent = Parent(parent);\n        }\n        usedNodeSet.add(parent);\n        return usedNodeSet.size > threshold;\n    }\n}\nfunction Parent(geomNode) {\n    const p = geomNode.node.parent;\n    return GeomObject.getGeom(p);\n}\nfunction* Children(gg) {\n    for (const n of gg.graph.shallowNodes) {\n        yield GeomObject.getGeom(n);\n    }\n}\n//# sourceMappingURL=ShapeCreatorForRoutingToParents.js.map","// The class calculates obstacles under the shape.\n// We assume that the boundaries are not set for the shape children yet\nimport { Curve, PointLocation } from '../math/geometry';\nimport { ConvexHull } from '../math/geometry/convexHull';\nimport { Polyline } from '../math/geometry/polyline';\nimport { CreateRectNodeOnArrayOfRectNodes, mkRectangleNode } from '../math/geometry/RTree/rectangleNode';\nimport { CrossRectangleNodes } from '../math/geometry/RTree/rectangleNodeUtils';\nimport { initRandom } from '../utils/random';\nimport { flattenArray } from '../utils/setOperations';\nimport { InteractiveObstacleCalculator } from './interactiveObstacleCalculator';\nimport { Shape } from './shape';\nimport { TightLooseCouple } from './TightLooseCouple';\nexport class ShapeObstacleCalculator {\n    constructor(shape, tightPadding, loosePadding, shapesToTightLooseCouples) {\n        this.loosePolylinesToNodes = new Map();\n        this.MainShape = shape;\n        this.TightPadding = tightPadding;\n        this.LoosePadding = loosePadding;\n        this.ShapesToTightLooseCouples = shapesToTightLooseCouples;\n    }\n    Calculate(randomizationShift, maxPadding = Number.MAX_VALUE) {\n        initRandom(3); // keep it the same all the time, otherwise the path optimizer migth not work\n        if (this.MainShape.Children.length === 0) {\n            return;\n        }\n        this.CreateTightObstacles();\n        this.CreateTigthLooseCouples(randomizationShift);\n        if (this.OverlapsDetected) {\n            this.FillTheMapOfShapeToTightLooseCouples();\n        }\n    }\n    FillTheMapOfShapeToTightLooseCouples() {\n        const childrenShapeHierarchy = CreateRectNodeOnArrayOfRectNodes(this.MainShape.Children.map((s) => mkRectangleNode(s, s.BoundingBox)));\n        CrossRectangleNodes(childrenShapeHierarchy, this.coupleHierarchy, this.TryMapShapeToTightLooseCouple.bind(this));\n    }\n    TryMapShapeToTightLooseCouple(shape, tightLooseCouple) {\n        if (ShapeObstacleCalculator.ShapeIsInsideOfPoly(shape, tightLooseCouple.TightPolyline)) {\n            this.ShapesToTightLooseCouples.set(shape, tightLooseCouple);\n        }\n    }\n    // this test is valid in our situation where the tight polylines are disjoint and the shape can cross only one of them\n    static ShapeIsInsideOfPoly(shape, tightPolyline) {\n        return Curve.PointRelativeToCurveLocation(shape.BoundaryCurve.start, tightPolyline) === PointLocation.Inside;\n    }\n    CreateTigthLooseCouples(randomizationShift) {\n        const couples = new Array();\n        for (const tightPolyline of this.tightHierarchy.GetAllLeaves()) {\n            const distance = InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(this.tightHierarchy, tightPolyline, this.LoosePadding);\n            const loosePoly = InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline, distance, randomizationShift);\n            const looseShape = new Shape(loosePoly);\n            const cpl = TightLooseCouple.mk(tightPolyline, looseShape, distance);\n            this.ShapesToTightLooseCouples.set(this.tightToShape.get(tightPolyline), cpl);\n            couples.push(cpl);\n        }\n        this.coupleHierarchy = CreateRectNodeOnArrayOfRectNodes(couples.map((c) => mkRectangleNode(c, c.TightPolyline.boundingBox)));\n    }\n    CreateTightObstacles() {\n        this.tightToShape = new Map();\n        const tightObstacles = new Set(this.MainShape.Children.map(this.InitialTightPolyline.bind(this)));\n        const initialNumberOfTightObstacles = tightObstacles.size;\n        this.tightHierarchy = InteractiveObstacleCalculator.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacles);\n        this.OverlapsDetected = initialNumberOfTightObstacles > tightObstacles.size;\n    }\n    InitialTightPolyline(shape) {\n        let poly = InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(shape.BoundaryCurve, this.TightPadding);\n        const stickingPointsArray = flattenArray(this.LoosePolylinesUnderShape(shape), (p) => p).filter((p) => Curve.PointRelativeToCurveLocation(p, poly) === PointLocation.Outside);\n        if (stickingPointsArray.length == 0) {\n            if (this.tightToShape)\n                this.tightToShape.set(poly, shape);\n            return poly;\n        }\n        const pts = Array.from(poly).concat(stickingPointsArray);\n        poly = Polyline.mkClosedFromPoints(ConvexHull.CalculateConvexHull(pts));\n        if (this.tightToShape)\n            this.tightToShape.set(poly, shape);\n        return poly;\n    }\n    LoosePolylinesUnderShape(shape) {\n        return shape.Children.map((child) => this.ShapesToTightLooseCouples.get(child).LooseShape.BoundaryCurve);\n    }\n}\n//# sourceMappingURL=ShapeObstacleCalculator.js.map","import { GenericBinaryHeapPriorityQueue } from '../structs/genericBinaryHeapPriorityQueue';\nimport { compareNumbers } from '../utils/compare';\nimport { TollFreeVisibilityEdge } from './visibility/TollFreeVisibilityEdge';\nexport class SingleSourceMultipleTargetsShortestPathOnVisibilityGraph {\n    constructor(sourceVisVertex, targetVisVertices, visibilityGraph) {\n        this.upperBound = Number.POSITIVE_INFINITY;\n        this._visGraph = visibilityGraph;\n        this._visGraph.ClearPrevEdgesTable();\n        for (const v of visibilityGraph.Vertices())\n            v.Distance = Number.POSITIVE_INFINITY;\n        this.source = sourceVisVertex;\n        this.targets = new Set(targetVisVertices);\n        this.source.Distance = 0;\n    }\n    // Returns  a  path\n    GetPath() {\n        const pq = new GenericBinaryHeapPriorityQueue(compareNumbers);\n        this.source.Distance = 0;\n        pq.Enqueue(this.source, 0);\n        while (!pq.IsEmpty()) {\n            this.current = pq.Dequeue();\n            if (this.targets.has(this.current)) {\n                break;\n            }\n            for (const e of this.current.OutEdges)\n                if (this.PassableOutEdge(e))\n                    this.ProcessNeighbor(pq, e, e.Target);\n            for (const e of this.current.InEdges)\n                if (this.PassableInEdge(e))\n                    this.ProcessNeighbor(pq, e, e.Source);\n        }\n        return this._visGraph.PreviosVertex(this.current) == null ? null : this.CalculatePath();\n    }\n    PassableOutEdge(e) {\n        return (e.Source === this.source || this.targets.has(e.Target) || !SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e));\n    }\n    PassableInEdge(e) {\n        return (this.targets.has(e.Source) || e.Target === this.source || !SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e));\n    }\n    static IsForbidden(e) {\n        return (e.IsPassable != null && !e.IsPassable()) || e instanceof TollFreeVisibilityEdge;\n    }\n    ProcessNeighbor(pq, l, v) {\n        const len = l.Length;\n        const c = this.current.Distance + len;\n        if (c >= this.upperBound) {\n            return;\n        }\n        if (this.targets.has(v)) {\n            this.upperBound = c;\n            this.closestTarget = v;\n        }\n        if (v !== this.source && this._visGraph.PreviosVertex(v) == null) {\n            v.Distance = c;\n            this._visGraph.SetPreviousEdge(v, l);\n            pq.Enqueue(v, c);\n        }\n        else if (c < v.Distance) {\n            // This condition should never hold for the dequeued nodes.\n            // However because of a very rare case of an epsilon error it might!\n            // In this case DecreasePriority will fail to find \"v\" and the algorithm will continue working.\n            // Since v is not in the queue changing its .Distance will not mess up the queue.\n            // Changing v.Prev is fine since we come up with a path with an insignificantly\n            // smaller distance.\n            v.Distance = c;\n            this._visGraph.SetPreviousEdge(v, l);\n            pq.DecreasePriority(v, c);\n        }\n    }\n    CalculatePath() {\n        if (this.closestTarget == null) {\n            return null;\n        }\n        const ret = new Array();\n        let v = this.closestTarget;\n        do {\n            ret.push(v);\n            v = this._visGraph.PreviosVertex(v);\n        } while (v !== this.source);\n        ret.push(this.source);\n        return ret.reverse();\n    }\n}\n//# sourceMappingURL=SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.js.map","import { GenericBinaryHeapPriorityQueue } from '../structs/genericBinaryHeapPriorityQueue';\nimport { compareNumbers } from '../utils/compare';\nimport { TollFreeVisibilityEdge } from './visibility/TollFreeVisibilityEdge';\nexport class SingleSourceSingleTargetShortestPathOnVisibilityGraph {\n    get LengthMultiplier() {\n        return this._lengthMultiplier;\n    }\n    set LengthMultiplier(value) {\n        this._lengthMultiplier = value;\n    }\n    get LengthMultiplierForAStar() {\n        return this._lengthMultiplierForAStar;\n    }\n    set LengthMultiplierForAStar(value) {\n        this._lengthMultiplierForAStar = value;\n    }\n    constructor(visGraph, sourceVisVertex, targetVisVertex) {\n        this._lengthMultiplier = 1;\n        this._lengthMultiplierForAStar = 1;\n        this._visGraph = visGraph;\n        this._source = sourceVisVertex;\n        this._target = targetVisVertex;\n        this._source.Distance = 0;\n    }\n    // Returns  a  path\n    GetPath(shrinkEdgeLength) {\n        const pq = new GenericBinaryHeapPriorityQueue(compareNumbers);\n        this._source.Distance = 0;\n        this._target.Distance = Number.POSITIVE_INFINITY;\n        pq.Enqueue(this._source, this.H(this._source));\n        while (!pq.IsEmpty()) {\n            const hu = { priority: 0 };\n            const u = pq.DequeueAndGetPriority(hu);\n            if (hu.priority >= this._target.Distance) {\n                break;\n            }\n            for (const e of u.OutEdges) {\n                if (this.PassableOutEdge(e)) {\n                    const v = e.Target;\n                    this.ProcessNeighbor(pq, u, e, v);\n                }\n            }\n            for (const e of u.InEdges) {\n                if (this.PassableInEdge(e)) {\n                    const v = e.Source;\n                    this.ProcessNeighbor(pq, u, e, v);\n                }\n            }\n        }\n        return this._visGraph.PreviosVertex(this._target) == null ? null : this.CalculatePath(shrinkEdgeLength);\n    }\n    // private AssertEdgesPassable(path: Array<VisibilityEdge>) {\n    //  for (const edge of path) Assert.assert(this.PassableOutEdge(edge) || this.PassableInEdge(edge))\n    // }\n    PassableOutEdge(e) {\n        return e.Source === this._source || e.Target === this._target || !SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e);\n    }\n    PassableInEdge(e) {\n        return e.Source === this._target || e.Target === this._source || !SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e);\n    }\n    static IsForbidden(e) {\n        return (e.IsPassable != null && !e.IsPassable()) || e instanceof TollFreeVisibilityEdge;\n    }\n    ProcessNeighborN(pq, u, l, v, penalty) {\n        const len = l.Length + penalty;\n        const c = u.Distance + len;\n        if (v !== this._source && this._visGraph.PreviosVertex(v) == null) {\n            v.Distance = c;\n            this._visGraph.SetPreviousEdge(v, l);\n            if (v !== this._target) {\n                pq.Enqueue(v, this.H(v));\n            }\n        }\n        else if (v !== this._source && c < v.Distance) {\n            // This condition should never hold for the dequeued nodes.\n            // However because of a very rare case of an epsilon error it might!\n            // In this case DecreasePriority will fail to find \"v\" and the algorithm will continue working.\n            // Since v is not in the queue changing its .Distance will not influence other nodes.\n            // Changing v.Prev is fine since we come up with the path with an insignificantly\n            // smaller distance.\n            v.Distance = c;\n            this._visGraph.SetPreviousEdge(v, l);\n            if (v !== this._target) {\n                pq.DecreasePriority(v, this.H(v));\n            }\n        }\n    }\n    ProcessNeighbor(pq, u, l, v) {\n        const len = l.Length;\n        const c = u.Distance + len;\n        if (v !== this._source && this._visGraph.PreviosVertex(v) == null) {\n            v.Distance = c;\n            this._visGraph.SetPreviousEdge(v, l);\n            if (v !== this._target) {\n                pq.Enqueue(v, this.H(v));\n            }\n        }\n        else if (v !== this._source && c < v.Distance) {\n            // This condition should never hold for the dequeued nodes.\n            // However because of a very rare case of an epsilon error it might!\n            // In this case DecreasePriority will fail to find \"v\" and the algorithm will continue working.\n            // Since v is not in the queue changing its .Distance will not influence other nodes.\n            // Changing v.Prev is fine since we come up with the path with an insignificantly\n            // smaller distance.\n            v.Distance = c;\n            this._visGraph.SetPreviousEdge(v, l);\n            if (v !== this._target) {\n                pq.DecreasePriority(v, this.H(v));\n            }\n        }\n    }\n    H(visibilityVertex) {\n        return visibilityVertex.Distance + visibilityVertex.point.sub(this._target.point).length * this.LengthMultiplierForAStar;\n    }\n    CalculatePath(shrinkEdgeLength) {\n        const ret = new Array();\n        let v = this._target;\n        do {\n            ret.push(v);\n            if (shrinkEdgeLength) {\n                this._visGraph.ShrinkLengthOfPrevEdge(v, this.LengthMultiplier);\n            }\n            v = this._visGraph.PreviosVertex(v);\n        } while (v !== this._source);\n        ret.push(this._source);\n        return ret.reverse();\n    }\n}\n//# sourceMappingURL=SingleSourceSingleTargetShortestPathOnVisibilityGraph.js.map","// Basic geomedge router for producing straight edges.\nimport { Arrowhead } from '../layout/core/arrowhead';\nimport { CornerSite } from '../math/geometry/cornerSite';\nimport { Curve } from '../math/geometry/curve';\nimport { GeomConstants } from '../math/geometry/geomConstants';\nimport { LineSegment } from '../math/geometry/lineSegment';\nimport { Point } from '../math/geometry/point';\nimport { SmoothedPolyline } from '../math/geometry/smoothedPolyline';\nimport { Algorithm } from '../utils/algorithm';\nimport { SplineRouter } from './splineRouter';\nimport { RelativeFloatingPort } from '../layout/core/relativeFloatingPort';\nexport function straightLineEdgePatcher(geomGraph, edgesToRoute, cancelToken) {\n    if (edgesToRoute) {\n        for (const e of edgesToRoute) {\n            if (cancelToken && cancelToken.canceled) {\n                return;\n            }\n            StraightLineEdges.RouteEdge(e, geomGraph.padding);\n        }\n    }\n    else {\n        for (const n of geomGraph.nodesBreadthFirst) {\n            if (cancelToken && cancelToken.canceled) {\n                return;\n            }\n            for (const e of n.outEdges())\n                if (e.curve == null)\n                    StraightLineEdges.RouteEdge(e, geomGraph.padding);\n            for (const e of n.selfEdges())\n                if (e.curve == null)\n                    StraightLineEdges.RouteEdge(e, geomGraph.padding);\n        }\n    }\n}\nexport class StraightLineEdges extends Algorithm {\n    // Constructs a basic straight geomedge router.\n    constructor(edges, padding) {\n        super(null);\n        this.edges = edges;\n        this.padding = padding;\n    }\n    // Executes the algorithm.\n    run() {\n        SplineRouter.CreatePortsIfNeeded(this.edges);\n        for (const geomedge of this.edges) {\n            StraightLineEdges.RouteEdge(geomedge, this.padding);\n        }\n    }\n    // populate the geometry including curve and arrowhead positioning for the given geomedge using simple\n    // straight line routing style.  Self edges will be drawn as a loop, padding is used to control the\n    // size of the loop.\n    static RouteEdge(geomedge, padding) {\n        const eg = geomedge;\n        if (eg.sourcePort == null) {\n            eg.sourcePort = RelativeFloatingPort.mk(() => geomedge.source.boundaryCurve, () => geomedge.source.center);\n        }\n        if (eg.targetPort == null) {\n            eg.targetPort = RelativeFloatingPort.mk(() => geomedge.target.boundaryCurve, () => geomedge.target.center);\n        }\n        if (!StraightLineEdges.ContainmentLoop(eg, padding)) {\n            eg.curve = StraightLineEdges.GetEdgeLine(geomedge);\n        }\n        Arrowhead.trimSplineAndCalculateArrowheadsII(eg, eg.sourcePort.Curve, eg.targetPort.Curve, geomedge.curve, false);\n    }\n    static ContainmentLoop(eg, padding) {\n        const sourceCurve = eg.sourcePort.Curve;\n        const targetCurve = eg.targetPort.Curve;\n        if (sourceCurve == null || targetCurve == null) {\n            return false;\n        }\n        const targetBox = sourceCurve.boundingBox;\n        const sourceBox = targetCurve.boundingBox;\n        const targetInSource = targetBox.containsRect(sourceBox);\n        const sourceInTarget = !targetInSource && sourceBox.containsRect(targetBox);\n        if (targetInSource || sourceInTarget) {\n            eg.curve = StraightLineEdges.CreateLoop(targetBox, sourceBox, sourceInTarget, padding);\n            return true;\n        }\n        return false;\n    }\n    static CreateLoop(targetBox, sourceBox, sourceContainsTarget, padding) {\n        return sourceContainsTarget\n            ? StraightLineEdges.CreateLoop_(targetBox, sourceBox, padding, false)\n            : StraightLineEdges.CreateLoop_(sourceBox, targetBox, padding, true);\n    }\n    // creates a loop from sourceBox center to the closest point on the targetBox boundary\n    static CreateLoop_(sourceBox, targetBox, howMuchToStickOut, reverse) {\n        const center = sourceBox.center;\n        const closestPoint = StraightLineEdges.FindClosestPointOnBoxBoundary(sourceBox.center, targetBox);\n        let dir = closestPoint.sub(center);\n        const vert = Math.abs(dir.x) < GeomConstants.distanceEpsilon;\n        const maxWidth = (vert\n            ? Math.min(center.y - targetBox.bottom, targetBox.top - center.y)\n            : Math.min(center.x - targetBox.left, targetBox.right - center.x)) / 2; //divide over 2 to not miss the rect\n        const width = Math.min(howMuchToStickOut, maxWidth);\n        if (dir.length <= GeomConstants.distanceEpsilon) {\n            dir = new Point(1, 0);\n        }\n        const hookDir = dir.normalize();\n        const hookPerp = hookDir.rotate(Math.PI / 2);\n        const p1 = closestPoint.add(hookDir.mul(howMuchToStickOut));\n        const p2 = p1.add(hookPerp.mul(width));\n        const p3 = closestPoint.add(hookPerp.mul(width));\n        const end = center.add(hookPerp.mul(width));\n        const smoothedPoly = reverse\n            ? SmoothedPolyline.mkFromPoints([end, p3, p2, p1, closestPoint, center])\n            : SmoothedPolyline.mkFromPoints([center, closestPoint, p1, p2, p3, end]);\n        return smoothedPoly.createCurve();\n    }\n    static FindClosestPointOnBoxBoundary(c, targetBox) {\n        const x = c.x - targetBox.left < targetBox.right - c.x ? targetBox.left : targetBox.right;\n        const y = c.y - targetBox.bottom < targetBox.top - c.y ? targetBox.bottom : targetBox.top;\n        return Math.abs(x - c.x) < Math.abs(y - c.y) ? new Point(x, c.y) : new Point(c.x, y);\n    }\n    // Returns a line segment for the given geomedge.\n    static GetEdgeLine(geomedge) {\n        let sourcePoint;\n        let sourceBox;\n        if (geomedge.sourcePort == null) {\n            sourcePoint = geomedge.source.center;\n            sourceBox = geomedge.source.boundaryCurve;\n        }\n        else {\n            sourcePoint = geomedge.sourcePort.Location;\n            sourceBox = geomedge.sourcePort.Curve;\n        }\n        let targetPoint;\n        let targetBox;\n        if (geomedge.targetPort == null) {\n            targetPoint = geomedge.target.center;\n            targetBox = geomedge.target.boundaryCurve;\n        }\n        else {\n            targetPoint = geomedge.targetPort.Location;\n            targetBox = geomedge.targetPort.Curve;\n        }\n        let line = LineSegment.mkPP(sourcePoint, targetPoint);\n        let intersects = Curve.getAllIntersections(sourceBox, line, false);\n        if (intersects.length > 0) {\n            let c = line.trim(intersects[0].par1, 1);\n            if (c instanceof LineSegment) {\n                line = c;\n                intersects = Curve.getAllIntersections(targetBox, line, false);\n                if (intersects.length > 0) {\n                    c = line.trim(0, intersects[0].par1);\n                    if (c instanceof LineSegment) {\n                        line = c;\n                    }\n                }\n            }\n        }\n        return line;\n    }\n    // creates an geomedge curve based only on the source and target geometry\n    static CreateSimpleEdgeCurveWithUnderlyingPolyline(ge) {\n        const a = ge.sourcePort ? ge.sourcePort.Location : ge.source.center;\n        const b = ge.targetPort ? ge.targetPort.Location : ge.target.center;\n        if (ge.source === ge.target) {\n            const dx = 2 / (3 * ge.source.boundaryCurve.boundingBox.width);\n            const dy = ge.source.boundingBox.height / 4;\n            ge.smoothedPolyline = StraightLineEdges.CreateUnderlyingPolylineForSelfEdge(a, dx, dy);\n            ge.curve = ge.smoothedPolyline.createCurve();\n        }\n        else {\n            ge.smoothedPolyline = SmoothedPolyline.mkFromPoints([a, b]);\n            ge.curve = ge.smoothedPolyline.createCurve();\n        }\n        Arrowhead.trimSplineAndCalculateArrowheadsII(ge, ge.source.boundaryCurve, ge.target.boundaryCurve, ge.curve, false);\n    }\n    static CreateUnderlyingPolylineForSelfEdge(p0, dx, dy) {\n        const p1 = p0.add(new Point(0, dy));\n        const p2 = p0.add(new Point(dx, dy));\n        const p3 = p0.add(new Point(dx, dy * -1));\n        const p4 = p0.add(new Point(0, dy * -1));\n        let site = CornerSite.mkSiteP(p0);\n        const polyline = new SmoothedPolyline(site);\n        site = CornerSite.mkSiteSP(site, p1);\n        site = CornerSite.mkSiteSP(site, p2);\n        site = CornerSite.mkSiteSP(site, p3);\n        site = CornerSite.mkSiteSP(site, p4);\n        CornerSite.mkSiteSP(site, p0);\n        return polyline;\n    }\n    static SetStraightLineEdgesWithUnderlyingPolylines(graph) {\n        SplineRouter.CreatePortsIfNeeded(Array.from(graph.deepEdges));\n        for (const geomedge of graph.deepEdges) {\n            StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(geomedge);\n        }\n    }\n}\n//# sourceMappingURL=StraightLineEdges.js.map","// an utility class to keep different polylines created around a shape\nexport class TightLooseCouple {\n    get TightPolyline() {\n        return this.tightPoly;\n    }\n    set TightPolyline(value) {\n        this.tightPoly = value;\n    }\n    static mk(tightPolyline, looseShape, distance) {\n        const ret = new TightLooseCouple();\n        ret.TightPolyline = tightPolyline;\n        ret.LooseShape = looseShape;\n        ret.Distance = distance;\n        return ret;\n    }\n    toString() {\n        return ((this.TightPolyline == null ? 'null' : this.TightPolyline.toString().substring(0, 5)) +\n            ',' +\n            (this.LooseShape == null ? 'null' : this.LooseShape.toString().substring(0, 5)));\n    }\n}\n//# sourceMappingURL=TightLooseCouple.js.map","// the router between nodes\nimport { Rectangle, Point, GeomEdge, Assert } from '..';\nimport { CurvePort } from '../layout/core/curvePort';\nimport { FloatingPort } from '../layout/core/floatingPort';\nimport { HookUpAnywhereFromInsidePort } from '../layout/core/hookUpAnywhereFromInsidePort';\nimport { Polyline, LineSegment, Curve, PointLocation } from '../math/geometry';\nimport { Ellipse } from '../math/geometry/ellipse';\nimport { TriangleOrientation } from '../math/geometry/point';\nimport { HitTestBehavior } from '../math/geometry/RTree/hitTestBehavior';\nimport { SmoothedPolyline } from '../math/geometry/smoothedPolyline';\nimport { InteractiveObstacleCalculator } from './interactiveObstacleCalculator';\nimport { SingleSourceMultipleTargetsShortestPathOnVisibilityGraph } from './SingleSourceMultipleTargetsShortestPathOnVisibilityGraph';\nimport { SingleSourceSingleTargetShortestPathOnVisibilityGraph } from './SingleSourceSingleTargetShortestPathOnVisibilityGraph';\nimport { ConeSpanner } from './spline/coneSpanner/ConeSpanner';\nimport { Polygon } from './visibility/Polygon';\nimport { TollFreeVisibilityEdge } from './visibility/TollFreeVisibilityEdge';\nimport { VisibilityGraph } from './visibility/VisibilityGraph';\nimport { VisibilityKind } from './visibility/VisibilityKind';\nimport { Algorithm } from '../utils/algorithm';\nimport { InteractiveTangentVisibilityGraphCalculator } from './visibility/InteractiveTangentVisibilityGraphCalculator';\nimport { addRange } from '../utils/setOperations';\nimport { PointVisibilityCalculator } from './visibility/PointVisibilityCalculator';\n// import {Assert} from '../utils/assert'\nexport class InteractiveEdgeRouter extends Algorithm {\n    constructor() {\n        super(...arguments);\n        this.IgnoreTightPadding = true;\n        // RectangleNode<Polyline, Point> RootOfTightHierarchy {\n        //    get { return this.obstacleCalculator.RootOfTightHierararchy; }\n        // }\n        this.activeRectangle = Rectangle.mkEmpty();\n        // Array<Polyline> activeTightPolylines = new Array<Polyline>();\n        this.activePolygons = new Array();\n        this.alreadyAddedOrExcludedPolylines = new Set();\n        this.UseEdgeLengthMultiplier = false;\n        // if set to true the algorithm will try to shortcut a shortest polyline inner points\n        this.UseInnerPolylingShortcutting = true;\n        // if set to true the algorithm will try to shortcut a shortest polyline start and end\n        this.UsePolylineEndShortcutting = true;\n        this.AllowedShootingStraightLines = true;\n        this.LookForRoundedVertices = false;\n    }\n    rerouteEdge(edge) {\n        const poly = edge.smoothedPolyline\n            ? Polyline.mkFromPoints(edge.smoothedPolyline)\n            : Polyline.mkFromPoints(edge.getSmoothPolyPoints());\n        this.pathOptimizer.run(poly);\n        edge.curve = this.pathOptimizer.poly.toCurve();\n        // SvgDebugWriter.dumpDebugCurves('./tmp/edge' + debCount++ + '.svg', [\n        //   DebugCurve.mkDebugCurveCI('Red', edge.source.boundaryCurve),\n        //   DebugCurve.mkDebugCurveCI('Blue', edge.target.boundaryCurve),\n        //   DebugCurve.mkDebugCurveTWCI(100, 1, 'Black', poly),\n        //   DebugCurve.mkDebugCurveTWCI(100, 1, 'Red', loosePolyOfSource),\n        //   DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', loosePolyOfTarget),\n        //   DebugCurve.mkDebugCurveTWCI(200, 1.5, 'Magenta', edge.curve),\n        // ])\n    }\n    static constructorANNN(obstacles, padding, loosePadding, coneSpannerAngle) {\n        return InteractiveEdgeRouter.constructorANNNB(obstacles, padding, loosePadding, coneSpannerAngle, false);\n    }\n    get Obstacles() {\n        return this.obstacles_;\n    }\n    set Obstacles(value) {\n        this.obstacles_ = value;\n    }\n    get EnteringAngleBound() {\n        return this.enteringAngleBound_;\n    }\n    set EnteringAngleBound(value) {\n        this.enteringAngleBound_ = value;\n    }\n    get SourceTightPolyline() {\n        return this._sourceTightPolyline;\n    }\n    set SourceTightPolyline(value) {\n        this._sourceTightPolyline = value;\n    }\n    get TargetTightPolyline() {\n        return this.targetTightPolyline;\n    }\n    set TargetTightPolyline(value) {\n        this.targetTightPolyline = value;\n    }\n    get TargetLoosePolyline() {\n        return this.targetLoosePolyline;\n    }\n    set TargetLoosePolyline(value) {\n        this.targetLoosePolyline = value;\n    }\n    get VisibilityGraph() {\n        return this.visibilityGraph;\n    }\n    set VisibilityGraph(value) {\n        this.visibilityGraph = value;\n    }\n    // the port of the edge start\n    get SourcePort() {\n        return this.sourcePort;\n    }\n    set SourcePort(value) {\n        this.sourcePort = value;\n        if (this.sourcePort != null) {\n            this.SourceTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.Location, this.ObstacleCalculator.RootOfTightHierarchy);\n            if (this.sourcePort instanceof FloatingPort) {\n                this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline);\n                // we need to exclude the loose polyline around the source port from the tangent visibily graph\n                this.StartPointOfEdgeRouting = this.SourcePort.Location;\n            }\n            else {\n                const bp = this.sourcePort;\n                this.StartPointOfEdgeRouting = this.TakeBoundaryPortOutsideOfItsLoosePolyline(bp.Curve, bp.Parameter, this.SourceLoosePolyline);\n            }\n        }\n    }\n    // the port of the edge end\n    get TargetPort() {\n        return this.targetPort;\n    }\n    set TargetPort(value) {\n        this.targetPort = value;\n    }\n    // we further pad each node but not more than LoosePadding.\n    get LoosePadding() {\n        return this.loosePadding;\n    }\n    set LoosePadding(value) {\n        this.loosePadding = value;\n        if (this.ObstacleCalculator != null) {\n            this.ObstacleCalculator.LoosePadding = value;\n        }\n    }\n    get OffsetForPolylineRelaxing() {\n        return this.TightPadding * 0.75;\n    }\n    get StartPointOfEdgeRouting() {\n        return this.startPointOfRouting_;\n    }\n    set StartPointOfEdgeRouting(value) {\n        this.startPointOfRouting_ = value;\n    }\n    ExtendVisibilityGraphToLocation(location) {\n        if (this.VisibilityGraph == null) {\n            this.VisibilityGraph = new VisibilityGraph();\n        }\n        let addedPolygons = null;\n        if (!this.activeRectangle.contains(location)) {\n            if (this.activeRectangle.isEmpty) {\n                this.activeRectangle = Rectangle.mkPP(this.SourcePort.Location, location);\n            }\n            else {\n                this.activeRectangle.add(location);\n            }\n            addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();\n            for (const polygon of addedPolygons) {\n                this.VisibilityGraph.AddHole(polygon.Polyline);\n            }\n        }\n        if (addedPolygons == null || addedPolygons.length === 0) {\n            if (this.targetVV != null) {\n                this.VisibilityGraph.RemoveVertex(this.targetVV);\n            }\n            this.CalculateEdgeTargetVisibilityGraph(location);\n        }\n        else {\n            this.RemovePointVisibilityGraphs();\n            const visibilityGraphGenerator = new InteractiveTangentVisibilityGraphCalculator(addedPolygons, this.activePolygons, this.VisibilityGraph);\n            visibilityGraphGenerator.run();\n            addRange(this.activePolygons, addedPolygons);\n            this.CalculateEdgeTargetVisibilityGraph(location);\n            this.CalculateSourcePortVisibilityGraph();\n        }\n    }\n    RemovePointVisibilityGraphs() {\n        if (this.targetVV != null) {\n            this.VisibilityGraph.RemoveVertex(this.targetVV);\n        }\n        if (this.sourceVV != null) {\n            this.VisibilityGraph.RemoveVertex(this.sourceVV);\n        }\n    }\n    CalculateEdgeTargetVisibilityGraph(location) {\n        this.targetVV = PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()), this.VisibilityGraph, location, VisibilityKind.Tangent);\n    }\n    CalculateSourcePortVisibilityGraph() {\n        this.sourceVV = PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()), this.VisibilityGraph, this.StartPointOfEdgeRouting, VisibilityKind.Tangent);\n    }\n    TakeBoundaryPortOutsideOfItsLoosePolyline(nodeBoundary, parameter, loosePolyline) {\n        const location = nodeBoundary.value(parameter);\n        let tangent = nodeBoundary\n            .leftDerivative(parameter)\n            .normalize()\n            .add(nodeBoundary.rightDerivative(parameter).normalize())\n            .normalize();\n        if (Point.getTriangleOrientation(InteractiveEdgeRouter.PointInsideOfConvexCurve(nodeBoundary), location, location.add(tangent)) ==\n            TriangleOrientation.Counterclockwise) {\n            tangent = tangent.mul(-1);\n        }\n        tangent = tangent.rotate(Math.PI / 2);\n        const len = loosePolyline.boundingBox.diagonal;\n        let ls = LineSegment.mkPP(location, location.add(tangent.mul(len)));\n        const p = Curve.intersectionOne(ls, loosePolyline, false).x;\n        let del = tangent.mul(p.sub(location).length / 2);\n        // Point del = tangent * this.OffsetForPolylineRelaxing * 2;\n        while (true) {\n            ls = LineSegment.mkPP(location, p.add(del));\n            let foundIntersectionsOutsideOfSource = false;\n            for (const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfLooseHierarchy)) {\n                if (ii.seg1 !== loosePolyline) {\n                    del = del.div(1.5);\n                    foundIntersectionsOutsideOfSource = true;\n                    break;\n                }\n            }\n            if (!foundIntersectionsOutsideOfSource) {\n                break;\n            }\n        }\n        return ls.end;\n    }\n    static PointInsideOfConvexCurve(nodeBoundary) {\n        return nodeBoundary.value(0).add(nodeBoundary.value(1.5)).div(2);\n        // a hack !!!!!!!!!!!!!!!!!!!!!!\n    }\n    // Point TakeSourcePortOutsideOfLoosePolyline() {\n    //    CurvePort bp = SourcePort as CurvePort;\n    //    ICurve nodeBoundary = bp.Node.BoundaryCurve;\n    //    Point location = bp.Location;\n    //    Point tangent = (nodeBoundary.LeftDerivative(bp.Parameter).Normalize() + nodeBoundary.RightDerivative(bp.Parameter).Normalize()).Normalize();\n    //    if (Point.GetTriangleOrientation(bp.Node.Center, location, location + tangent) === TriangleOrientation.Counterclockwise)\n    //        tangent = -tangent;\n    //    tangent = tangent.Rotate(Math.PI / 2);\n    //    Number len = this.sourceLoosePolyline.BoundingBox.Diagonal;\n    //    Point portLocation = bp.Location;\n    //    LineSegment ls = LineSegment.mkPP(portLocation, portLocation + len * tangent);\n    //    Point p = Curve.GetAllIntersections(ls, this.SourceLoosePolyline, false)[0].x;\n    //    Point del = tangent * this.OffsetForPolylineRelaxing * 2;\n    //    while (true) {\n    //        ls = LineSegment.mkPP(portLocation, p + del);\n    //        bool foundIntersectionsOutsideOfSource = false;\n    //        foreach (IntersectionInfo ii in IntersectionsOfLineAndRectangleNodeOverPolyline(ls, this.obstacleCalculator.RootOfLooseHierarchy))\n    //            if (ii.seg1 !== this.SourceLoosePolyline) {\n    //                del /= 1.5;\n    //                foundIntersectionsOutsideOfSource = true;\n    //                break;\n    //            }\n    //        if (!foundIntersectionsOutsideOfSource)\n    //            break;\n    //    }\n    //    return ls.End;\n    // }\n    *GetActivePolylines() {\n        for (const polygon of this.activePolygons) {\n            yield polygon.Polyline;\n        }\n    }\n    GetAddedPolygonesAndMaybeExtendActiveRectangle() {\n        const rect = this.activeRectangle;\n        const addedPolygones = new Array();\n        let added;\n        do {\n            added = false;\n            for (const loosePoly of this.ObstacleCalculator.RootOfLooseHierarchy.GetNodeItemsIntersectingRectangle(this.activeRectangle)) {\n                if (!this.alreadyAddedOrExcludedPolylines.has(loosePoly)) {\n                    rect.addRec(loosePoly.boundingBox);\n                    addedPolygones.push(new Polygon(loosePoly));\n                    this.alreadyAddedOrExcludedPolylines.add(loosePoly);\n                    // we register the loose polyline in the set to not add it twice\n                    added = true;\n                }\n            }\n            if (added) {\n                this.activeRectangle = rect;\n            }\n        } while (added);\n        return addedPolygones;\n    }\n    PolylineSegmentIntersectsTightHierarchy(a, b) {\n        return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(a, b, this.ObstacleCalculator.RootOfTightHierarchy);\n    }\n    PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(a, b, rect) {\n        return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(LineSegment.mkPP(a, b), rect);\n    }\n    PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls, rect) {\n        if (!ls.boundingBox.intersects(rect.irect)) {\n            return false;\n        }\n        if (rect.UserData != null) {\n            for (const ii of Curve.getAllIntersections(ls, rect.UserData, false)) {\n                if (ii.seg1 !== this.SourceTightPolyline && ii.seg1 !== this.TargetTightPolyline) {\n                    return true;\n                }\n                if ((ii.seg1 === this.SourceTightPolyline && this.SourcePort) instanceof CurvePort) {\n                    return true;\n                }\n                if ((ii.seg1 === this.TargetTightPolyline && this.TargetPort) instanceof CurvePort) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls, rect.Left) ||\n            this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls, rect.Right));\n    }\n    static IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, rectNode) {\n        const ret = new Array();\n        InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls, rectNode, ret);\n        return ret;\n    }\n    static IntersectionsOfLineAndRectangleNodeOverPolyline(ls, rectNode, listOfIntersections) {\n        if (rectNode == null) {\n            return;\n        }\n        if (!ls.boundingBox.intersects(rectNode.irect)) {\n            return;\n        }\n        if (rectNode.UserData != null) {\n            addRange(listOfIntersections, Curve.getAllIntersections(ls, rectNode.UserData, true));\n            return;\n        }\n        InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls, rectNode.Left, listOfIntersections);\n        InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls, rectNode.Right, listOfIntersections);\n    }\n    LineCanBeAcceptedForRouting(ls) {\n        const sourceIsFloating = this.SourcePort instanceof FloatingPort;\n        const targetIsFloating = this.TargetPort instanceof FloatingPort;\n        if (!sourceIsFloating && !this.targetIsInsideOfSourceTightPolyline) {\n            if (!this.InsideOfTheAllowedConeOfBoundaryPort(ls.end, this.SourcePort)) {\n                return false;\n            }\n        }\n        if (!targetIsFloating && this.TargetPort != null && !this.sourceIsInsideOfTargetTightPolyline) {\n            if (!this.InsideOfTheAllowedConeOfBoundaryPort(ls.start, this.TargetPort)) {\n                return false;\n            }\n        }\n        const xx = InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfTightHierarchy);\n        for (const ii of xx) {\n            if (ii.seg1 === this.SourceTightPolyline) {\n                continue;\n            }\n            if (ii.seg1 === this.targetTightPolyline) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    InsideOfTheAllowedConeOfBoundaryPort(pointToTest, port) {\n        const boundaryCurve = port.Curve;\n        const curveIsClockwise = InteractiveObstacleCalculator.CurveIsClockwise(boundaryCurve, InteractiveEdgeRouter.PointInsideOfConvexCurve(boundaryCurve));\n        const portLocation = port.Location;\n        const pointOnTheRightConeSide = this.GetPointOnTheRightBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, port.Parameter);\n        const pointOnTheLeftConeSide = this.GetPointOnTheLeftBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, port.Parameter);\n        return (Point.getTriangleOrientation(portLocation, pointOnTheRightConeSide, pointToTest) !== TriangleOrientation.Clockwise &&\n            Point.getTriangleOrientation(portLocation, pointToTest, pointOnTheLeftConeSide) !== TriangleOrientation.Clockwise);\n    }\n    GetPointOnTheRightBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, portParam) {\n        const tan = curveIsClockwise ? boundaryCurve.rightDerivative(portParam) : boundaryCurve.leftDerivative(portParam).neg();\n        return portLocation.add(tan.rotate(this.EnteringAngleBound));\n    }\n    GetPointOnTheLeftBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, portParam) {\n        const tan = curveIsClockwise ? boundaryCurve.leftDerivative(portParam).neg() : boundaryCurve.rightDerivative(portParam);\n        return portLocation.add(tan.rotate(-this.EnteringAngleBound));\n    }\n    // ShowPolylineAndObstacles(params curves: ICurve[]) {\n    //    //  ReSharper restore UnusedMember.Local\n    //    let ls: Array<DebugCurve> = this.GetDebugCurves(curves);\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);\n    // }\n    // GetDebugCurves(params curves: ICurve[]): Array<DebugCurve> {\n    //    let ls = this.CreateListWithObstaclesAndPolyline(curves);\n    //    // ls.AddRange(this.VisibilityGraph.Edges.Select(e => new DebugCurve(100,0.1, e is TollFreeVisibilityEdge?\"red\":\"green\", LineSegment.mkPP(e.SourcePoint, e.TargetPoint))));\n    //    if ((this._sourceVisibilityVertex != null)) {\n    //        ls.Add(new DebugCurve(\"red\", CurveFactory.CreateDiamond(4, 4, this._sourceVisibilityVertex.point)));\n    //    }\n    //    if ((this.targetVisibilityVertex != null)) {\n    //        ls.Add(new DebugCurve(\"purple\", new Ellipse(4, 4, this.targetVisibilityVertex.Point)));\n    //    }\n    //    let anywerePort = (<HookUpAnywhereFromInsidePort>(this.targetPort));\n    //    if ((anywerePort != null)) {\n    //        ls.Add(new DebugCurve(\"purple\", anywerePort.LoosePolyline));\n    //    }\n    //    return ls;\n    // }\n    // CreateListWithObstaclesAndPolyline(params curves: ICurve[]): Array<DebugCurve> {\n    //    let ls = new Array<DebugCurve>(this.ObstacleCalculator.RootOfLooseHierarchy.GetAllLeaves().select(() => {  }, new DebugCurve(100, 0.01, \"green\", e)));\n    //    ls.AddRange(curves.Select(() => {  }, new DebugCurve(100, 0.01, \"red\", c)));\n    //    ls.AddRange(this.ObstacleCalculator.RootOfTightHierarchy.GetAllLeaves().select(() => {  }, new DebugCurve(100, 0.01, \"blue\", e)));\n    //    //  ls.AddRange(visibilityGraph.Edges.Select(e => (ICurve) LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));\n    //    if ((this._polyline != null)) {\n    //        ls.Add(new DebugCurve(100, 0.03, \"blue\", this._polyline));\n    //    }\n    //    return ls;\n    // }\n    // smoothing the corners of the polyline\n    SmoothenCorners(edgePolyline) {\n        let a = edgePolyline.headSite;\n        let corner = { b: null, c: null };\n        // the corner other end\n        while ((corner = Curve.findCorner(a))) {\n            a = this.SmoothOneCorner(a, corner.c, corner.b);\n        }\n    }\n    SmoothOneCorner(a, c, b) {\n        const mult = 1.5;\n        const kMin = 0.01;\n        let k = 0.5;\n        let seg;\n        let v;\n        let u;\n        if (a.prev == null) {\n            // this will allow to the segment to start from site \"a\"\n            u = 2;\n            v = 1;\n        }\n        else if (c.next == null) {\n            u = 1;\n            v = 2;\n            // this will allow to the segment to end at site \"c\"\n        }\n        else {\n            u = v = 1;\n        }\n        do {\n            seg = Curve.createBezierSeg(k * u, k * v, a, b, c);\n            b.previouisBezierCoefficient = k * u;\n            b.nextBezierCoefficient = k * v;\n            k /= mult;\n        } while (distFromCornerToSeg() > this.loosePadding && k > kMin);\n        k *= mult;\n        // that was the last k\n        if (k < 0.5 && k > kMin) {\n            // one time try a smoother seg\n            k = 0.5 * (k + k * mult);\n            seg = Curve.createBezierSeg(k * u, k * v, a, b, c);\n            if (distFromCornerToSeg() > this.loosePadding) {\n                b.previouisBezierCoefficient = k * u;\n                b.nextBezierCoefficient = k * v;\n            }\n        }\n        return b;\n        function distFromCornerToSeg() {\n            const t = seg.closestParameter(b.point);\n            return b.point.sub(seg.value(t)).length;\n        }\n    }\n    TryToRemoveInflectionsAndCollinearSegments(underlyingPolyline) {\n        let progress = true;\n        const t = { s: null };\n        while (progress) {\n            progress = false;\n            for (t.s = underlyingPolyline.headSite; t.s != null && t.s.next != null; t.s = t.s.next) {\n                if (t.s.turn * t.s.next.turn < 0) {\n                    progress = this.TryToRemoveInflectionEdge(t) || progress;\n                }\n            }\n        }\n    }\n    TryToRemoveInflectionEdge(t) {\n        if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point, t.s.next.point)) {\n            const a = t.s.prev;\n            // forget t.s\n            const b = t.s.next;\n            a.next = b;\n            b.prev = a;\n            t.s = a;\n            return true;\n        }\n        if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point, t.s.next.next.point)) {\n            // forget about t.s and t.s.Next\n            const a = t.s.prev;\n            const b = t.s.next.next;\n            a.next = b;\n            b.prev = a;\n            t.s = a;\n            return true;\n        }\n        if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.point, t.s.next.next.point)) {\n            // forget about t.s.Next\n            const b = t.s.next.next;\n            t.s.next = b;\n            b.prev = t.s;\n            return true;\n        }\n        return false;\n    }\n    // internal Point TargetPoint {\n    //    get {\n    //        CurvePort tp = this.TargetPort as CurvePort;\n    //        if (tp != null)\n    //            return this.Target.BoundaryCurve[tp.Parameter];\n    //        else\n    //            return (this.TargetPort as FloatingPort).Location;\n    //    }\n    // }\n    // internal Point SourcePoint {\n    //    get {\n    //        CurvePort sp = this.SourcePort as CurvePort;\n    //        if (sp != null)\n    //            return this.Source.BoundaryCurve[sp.Parameter];\n    //        else\n    //            return (this.SourcePort as FloatingPort).Location;\n    //    }\n    // }\n    GetShortestPolyline(sourceVisVertex, _targetVisVertex) {\n        this.CleanTheGraphForShortestPath();\n        const pathCalc = new SingleSourceSingleTargetShortestPathOnVisibilityGraph(this.visibilityGraph, sourceVisVertex, _targetVisVertex);\n        const path = pathCalc.GetPath(this.UseEdgeLengthMultiplier);\n        if (path == null) {\n            // ShowIsPassable(_sourceVisibilityVertex, _targetVisVertex);\n            return null;\n        }\n        // Assert.assert(path[0] === sourceVisVertex && path[path.length - 1] === _targetVisVertex)\n        let ret = Polyline.mkFromPoints(Array.from(path).map((p) => p.point)).RemoveCollinearVertices();\n        if (this.pathOptimizer) {\n            this.pathOptimizer.run(ret);\n            ret = this.pathOptimizer.poly;\n        }\n        return ret;\n    }\n    // private ShowIsPassable(sourceVisVertex: VisibilityVertex, targetVisVertex: VisibilityVertex) {\n    //    let dd = new Array<DebugCurve>(this.visibilityGraph.Edges.Select(() => {  }, new DebugCurve(100, 0.5, \"green\", LineSegment.mkPP(e.SourcePoint, e.TargetPoint))));\n    //    // TODO: Warning!!!, inline IF is not supported ?\n    //    ((e.IsPassable == null )\n    //                || e.IsPassable());\n    //    \"red\";\n    //    if ((sourceVisVertex != null)) {\n    //        dd.Add(new DebugCurve(CurveFactory.CreateDiamond(3, 3, sourceVisVertex.point)));\n    //    }\n    //    if ((targetVisVertex != null)) {\n    //        dd.Add(new DebugCurve(CurveFactory.CreateEllipse(3, 3, targetVisVertex.point)));\n    //    }\n    //    if ((this.Obstacles != null)) {\n    //        dd.AddRange(this.Obstacles.Select(() => {  }, new DebugCurve(o)));\n    //    }\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);\n    // }\n    CleanTheGraphForShortestPath() {\n        this.visibilityGraph.ClearPrevEdgesTable();\n    }\n    // returns true if the nodes overlap or just positioned too close\n    get OverlapsDetected() {\n        return this.ObstacleCalculator.OverlapsDetected;\n    }\n    get TightHierarchy() {\n        return this.ObstacleCalculator.RootOfTightHierarchy;\n    }\n    set TightHierarchy(value) {\n        this.ObstacleCalculator.RootOfTightHierarchy = value;\n    }\n    get LooseHierarchy() {\n        return this.ObstacleCalculator.RootOfLooseHierarchy;\n    }\n    set LooseHierarchy(value) {\n        this.ObstacleCalculator.RootOfLooseHierarchy = value;\n    }\n    CalculateObstacles() {\n        this.ObstacleCalculator = new InteractiveObstacleCalculator(this.Obstacles, this.TightPadding, this.LoosePadding, this.IgnoreTightPadding);\n        this.ObstacleCalculator.Calculate();\n    }\n    static constructorANNNB(obstacles, padding, loosePadding, coneSpannerAngle, ignoreTightPadding) {\n        const ier = new InteractiveEdgeRouter(null);\n        ier.IgnoreTightPadding = ignoreTightPadding;\n        ier.EnteringAngleBound = 80 * (Math.PI / 180);\n        ier.TightPadding = padding;\n        ier.LoosePadding = loosePadding;\n        if (coneSpannerAngle > 0) {\n            Assert.assert(coneSpannerAngle > Math.PI / 180);\n            Assert.assert(coneSpannerAngle <= 90 * (Math.PI / 180));\n            ier.UseSpanner = true;\n            ier.ExpectedProgressSteps = ConeSpanner.GetTotalSteps(coneSpannerAngle);\n        }\n        else {\n            ier.ExpectedProgressSteps = obstacles.length;\n        }\n        ier.ConeSpannerAngle = coneSpannerAngle;\n        ier.Obstacles = obstacles;\n        ier.CalculateObstacles();\n        return ier;\n    }\n    RouteEdgeToLocation(targetLocation) {\n        this.TargetPort = new FloatingPort(null, targetLocation);\n        // otherwise route edge to a port would be called\n        this.TargetTightPolyline = null;\n        this.TargetLoosePolyline = null;\n        const edge = new GeomEdge(null);\n        let ls = LineSegment.mkPP(this.SourcePort.Location, targetLocation);\n        if (this.LineCanBeAcceptedForRouting(ls)) {\n            this._polyline = new Polyline();\n            this._polyline.addPoint(ls.start);\n            this._polyline.addPoint(ls.end);\n            const smoothedPolyline = SmoothedPolyline.mkFromPoints(this._polyline);\n            edge.curve = smoothedPolyline.createCurve();\n            return edge;\n        }\n        // can we do with just two line segments?\n        if (this.SourcePort instanceof CurvePort) {\n            ls = LineSegment.mkPP(this.StartPointOfEdgeRouting, targetLocation);\n            if (InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfTightHierarchy).length ==\n                0) {\n                this._polyline = new Polyline();\n                this._polyline.addPoint(this.SourcePort.Location);\n                this._polyline.addPoint(ls.start);\n                this._polyline.addPoint(ls.end);\n                edge.curve = SmoothedPolyline.mkFromPoints(this._polyline).createCurve();\n                return edge;\n            }\n        }\n        this.ExtendVisibilityGraphToLocation(targetLocation);\n        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);\n        if (this.SourcePort instanceof CurvePort) {\n            this._polyline.PrependPoint(this.SourcePort.Location);\n        }\n        edge.curve = SmoothedPolyline.mkFromPoints(this._polyline).createCurve();\n        return edge;\n    }\n    // routes the edge to the port\n    //\n    RouteEdgeToPort(edgeTargetPort, portLoosePolyline, smooth, t) {\n        if (!this.ObstacleCalculator.IsEmpty()) {\n            this.TargetPort = edgeTargetPort;\n            this.TargetTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(edgeTargetPort.Location, this.ObstacleCalculator.RootOfTightHierarchy);\n            // Assert.assert(this.targetTightPolyline != null)\n            if (edgeTargetPort instanceof CurvePort) {\n                return this.RouteEdgeToBoundaryPort(portLoosePolyline, smooth, t);\n            }\n            return this.RouteEdgeToFloatingPortOfNode(portLoosePolyline, smooth, t);\n        }\n        if (this.sourcePort != null && this.targetPort != null) {\n            t.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(this.sourcePort.Location, this.targetPort.Location);\n            return LineSegment.mkPP(this.sourcePort.Location, this.targetPort.Location);\n        }\n        return null;\n    }\n    SmoothedPolylineFromTwoPoints(s, e) {\n        this._polyline = new Polyline();\n        this._polyline.addPoint(s);\n        this._polyline.addPoint(e);\n        return SmoothedPolyline.mkFromPoints(this._polyline);\n    }\n    RouteEdgeToFloatingPortOfNode(portLoosePolyline, smooth, t) {\n        if (this.sourcePort instanceof FloatingPort) {\n            return this.RouteFromFloatingPortToFloatingPort(portLoosePolyline, smooth, t);\n        }\n        return this.RouteFromBoundaryPortToFloatingPort(portLoosePolyline, smooth, t);\n    }\n    RouteFromBoundaryPortToFloatingPort(targetPortLoosePolyline, smooth, t) {\n        const sourcePortLocation = this.SourcePort.Location;\n        const targetPortLocation = this.targetPort.Location;\n        let ls = LineSegment.mkPP(sourcePortLocation, targetPortLocation);\n        if (this.LineCanBeAcceptedForRouting(ls)) {\n            t.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(ls.start, ls.end);\n            return ls;\n        }\n        if (!this.targetIsInsideOfSourceTightPolyline) {\n            // try a variant with two segments\n            const takenOutPoint = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve, this.SourcePort.Parameter, this.SourceLoosePolyline);\n            ls = LineSegment.mkPP(takenOutPoint, targetPortLocation);\n            if (this.LineAvoidsTightHierarchyLP(ls, targetPortLoosePolyline)) {\n                t.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(ls.start, ls.end);\n                return ls;\n            }\n        }\n        // we need to route throw the visibility graph\n        this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(targetPortLoosePolyline);\n        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);\n        const tmp = this.SourceTightPolyline;\n        if (!this.targetIsInsideOfSourceTightPolyline) {\n            this.SourceTightPolyline = null;\n        }\n        this.SourceTightPolyline = tmp;\n        this._polyline.PrependPoint(sourcePortLocation);\n        //  return this._polyline\n        return this.SmoothCornersAndReturnCurve(smooth, t);\n    }\n    SmoothCornersAndReturnCurve(smooth, t) {\n        t.smoothedPolyline = SmoothedPolyline.mkFromPoints(this._polyline);\n        if (smooth) {\n            this.SmoothenCorners(t.smoothedPolyline);\n        }\n        return t.smoothedPolyline.createCurve();\n    }\n    RouteFromFloatingPortToFloatingPort(portLoosePolyline, smooth, t) {\n        // route through the visibility graph\n        this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(portLoosePolyline);\n        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);\n        if (this._polyline == null) {\n            return null;\n        }\n        t.smoothedPolyline = SmoothedPolyline.mkFromPoints(this._polyline);\n        return this.SmoothCornersAndReturnCurve(smooth, t);\n    }\n    TryShortcutPolyPoint(pp) {\n        if (this.LineAvoidsTightHierarchyLPP(LineSegment.mkPP(pp.point, pp.next.next.point), this.SourceTightPolyline, this.targetTightPolyline)) {\n            // remove pp.Next\n            pp.next = pp.next.next;\n            pp.next.prev = pp;\n            return true;\n        }\n        return false;\n    }\n    ExtendVisibilityGraphToLocationOfTargetFloatingPort(portLoosePolyline) {\n        if (this.VisibilityGraph == null) {\n            this.VisibilityGraph = new VisibilityGraph();\n        }\n        let addedPolygons = null;\n        const targetLocation = this.targetPort.Location;\n        if (!this.activeRectangle.contains(targetLocation)) {\n            if (this.activeRectangle.isEmpty) {\n                this.activeRectangle = Rectangle.mkPP(this.SourcePort.Location, targetLocation);\n            }\n            else {\n                this.activeRectangle.add(targetLocation);\n            }\n            addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();\n            for (const polygon of addedPolygons) {\n                this.VisibilityGraph.AddHole(polygon.Polyline);\n            }\n        }\n        if (addedPolygons == null) {\n            if (this.targetVV != null) {\n                this.VisibilityGraph.RemoveVertex(this.targetVV);\n            }\n            this.CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation, portLoosePolyline);\n            if (this.sourceVV == null) {\n                this.CalculateSourcePortVisibilityGraph();\n            }\n        }\n        else {\n            this.RemovePointVisibilityGraphs();\n            const visibilityGraphGenerator = new InteractiveTangentVisibilityGraphCalculator(addedPolygons, this.activePolygons, this.VisibilityGraph);\n            visibilityGraphGenerator.run();\n            addRange(this.activePolygons, addedPolygons);\n            this.CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation, portLoosePolyline);\n            this.CalculateSourcePortVisibilityGraph();\n        }\n    }\n    CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation, targetLoosePoly) {\n        if (this.UseSpanner) {\n            this.targetVV = this.AddTransientVisibilityEdgesForPort(targetLocation, targetLoosePoly);\n        }\n        else {\n            this.targetVV = PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(targetLoosePoly), this.VisibilityGraph, targetLocation, VisibilityKind.Tangent);\n        }\n    }\n    AddTransientVisibilityEdgesForPort(point, loosePoly) {\n        let v = this.GetVertex(point);\n        if (v != null) {\n            return v;\n        }\n        v = this.visibilityGraph.AddVertexP(point);\n        if (loosePoly != null)\n            //if the edges have not been calculated do it in a quick and dirty mode\n            for (const p of loosePoly)\n                this.visibilityGraph.AddEdgeF(point, p, (a, b) => new TollFreeVisibilityEdge(a, b));\n        else {\n            v = PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylines(), this.VisibilityGraph, point, VisibilityKind.Tangent);\n            // Assert.assert(v != null)\n        }\n        return v;\n    }\n    GetVertex(point) {\n        let v = this.visibilityGraph.FindVertex(point);\n        if (v == null && this.LookForRoundedVertices) {\n            v = this.visibilityGraph.FindVertex(Point.RoundPoint(point));\n        }\n        return v;\n    }\n    *GetActivePolylinesWithException(targetLoosePoly) {\n        /*\n    return from polygon in activePolygons where polygon.Polyline !== targetLoosePoly select polygon.Polyline;\n          */\n        for (const polygon of this.activePolygons) {\n            if (polygon.Polyline !== targetLoosePoly)\n                yield polygon.Polyline;\n        }\n    }\n    RouteEdgeToBoundaryPort(portLoosePolyline, smooth, t) {\n        this.TargetLoosePolyline = portLoosePolyline;\n        if (this.sourcePort instanceof FloatingPort) {\n            return this.RouteFromFloatingPortToBoundaryPort(smooth, t);\n        }\n        return this.RouteFromBoundaryPortToBoundaryPort(smooth, t);\n    }\n    RouteFromBoundaryPortToBoundaryPort(smooth, t) {\n        const sourcePortLocation = this.SourcePort.Location;\n        let curve;\n        const targetPortLocation = this.targetPort.Location;\n        let ls = LineSegment.mkPP(sourcePortLocation, targetPortLocation);\n        if (this.LineCanBeAcceptedForRouting(ls)) {\n            this._polyline = new Polyline();\n            this._polyline.addPoint(ls.start);\n            this._polyline.addPoint(ls.end);\n            t.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(ls.start, ls.end);\n            curve = SmoothedPolyline.mkFromPoints(this._polyline).createCurve();\n        }\n        else {\n            // try three variants with two segments\n            const takenOutPoint = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.Curve, this.targetPort.Parameter, this.TargetLoosePolyline);\n            ls = LineSegment.mkPP(sourcePortLocation, takenOutPoint);\n            if (this.InsideOfTheAllowedConeOfBoundaryPort(takenOutPoint, this.SourcePort) &&\n                this.LineAvoidsTightHierarchyLP(ls, this._sourceTightPolyline)) {\n                this._polyline = new Polyline();\n                this._polyline.addPoint(ls.start);\n                this._polyline.addPoint(ls.end);\n                this._polyline.addPoint(targetPortLocation);\n                curve = this.SmoothCornersAndReturnCurve(smooth, t);\n            }\n            else {\n                ls = LineSegment.mkPP(this.StartPointOfEdgeRouting, targetPortLocation);\n                if (this.InsideOfTheAllowedConeOfBoundaryPort(this.StartPointOfEdgeRouting, this.TargetPort) &&\n                    this.LineAvoidsTightHierarchy(ls)) {\n                    this._polyline = new Polyline();\n                    this._polyline.addPoint(sourcePortLocation);\n                    this._polyline.addPoint(ls.start);\n                    this._polyline.addPoint(ls.end);\n                    curve = this.SmoothCornersAndReturnCurve(smooth, t);\n                }\n                else {\n                    // we still can make the polyline with two segs when the port sticking segs are intersecting\n                    let x;\n                    if ((x = LineSegment.IntersectPPPP(sourcePortLocation, this.StartPointOfEdgeRouting, targetPortLocation, takenOutPoint))) {\n                        this._polyline = new Polyline();\n                        this._polyline.addPoint(sourcePortLocation);\n                        this._polyline.addPoint(x);\n                        this._polyline.addPoint(targetPortLocation);\n                        curve = this.SmoothCornersAndReturnCurve(smooth, t);\n                    }\n                    else if (Point.closeDistEps(this.StartPointOfEdgeRouting, takenOutPoint)) {\n                        this._polyline = new Polyline();\n                        this._polyline.addPoint(sourcePortLocation);\n                        this._polyline.addPoint(takenOutPoint);\n                        this._polyline.addPoint(targetPortLocation);\n                        curve = this.SmoothCornersAndReturnCurve(smooth, t);\n                    }\n                    else if (this.LineAvoidsTightHierarchy(LineSegment.mkPP(this.StartPointOfEdgeRouting, takenOutPoint))) {\n                        // can we do three segments?\n                        this._polyline = new Polyline();\n                        this._polyline.addPoint(sourcePortLocation);\n                        this._polyline.addPoint(this.StartPointOfEdgeRouting);\n                        this._polyline.addPoint(takenOutPoint);\n                        this._polyline.addPoint(targetPortLocation);\n                        curve = this.SmoothCornersAndReturnCurve(smooth, t);\n                    }\n                    else {\n                        this.ExtendVisibilityGraphToTargetBoundaryPort(takenOutPoint);\n                        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);\n                        const r = { tmpTargetTight: null };\n                        const tmpSourceTight = this.HideSourceTargetTightsIfNeeded(r);\n                        this.RecoverSourceTargetTights(tmpSourceTight, r.tmpTargetTight);\n                        this._polyline.PrependPoint(sourcePortLocation);\n                        this._polyline.addPoint(targetPortLocation);\n                        curve = this.SmoothCornersAndReturnCurve(smooth, t);\n                    }\n                }\n            }\n        }\n        return curve;\n    }\n    RecoverSourceTargetTights(tmpSourceTight, tmpTargetTight) {\n        this.SourceTightPolyline = tmpSourceTight;\n        this.TargetTightPolyline = tmpTargetTight;\n    }\n    HideSourceTargetTightsIfNeeded(t) {\n        const tmpSourceTight = this.SourceTightPolyline;\n        t.tmpTargetTight = this.TargetTightPolyline;\n        this.TargetTightPolyline = null;\n        this.SourceTightPolyline = null;\n        return tmpSourceTight;\n    }\n    LineAvoidsTightHierarchy(lineSegment) {\n        return (InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(lineSegment, this.ObstacleCalculator.RootOfTightHierarchy)\n            .length === 0);\n    }\n    RouteFromFloatingPortToBoundaryPort(smooth, r) {\n        const targetPortLocation = this.targetPort.Location;\n        let ls;\n        if (this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.Location, this.targetPort)) {\n            ls = LineSegment.mkPP(this.SourcePort.Location, targetPortLocation);\n            if (this.LineCanBeAcceptedForRouting(ls)) {\n                r.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(ls.start, ls.end);\n                return ls;\n            }\n        }\n        const takenOutTargetPortLocation = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.TargetPort.Curve, this.TargetPort.Parameter, this.TargetLoosePolyline);\n        // can we do with just two line segments?\n        ls = LineSegment.mkPP(this.SourcePort.Location, takenOutTargetPortLocation);\n        if (this.LineAvoidsTightHierarchyLP(ls, this._sourceTightPolyline)) {\n            this._polyline = Polyline.mkFromPoints([ls.start, ls.end, targetPortLocation]);\n            r.smoothedPolyline = SmoothedPolyline.mkFromPoints(this._polyline);\n            return r.smoothedPolyline.createCurve();\n        }\n        this.ExtendVisibilityGraphToTargetBoundaryPort(takenOutTargetPortLocation);\n        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);\n        this._polyline.addPoint(targetPortLocation);\n        const t = { smoothedPolyline: null };\n        return this.SmoothCornersAndReturnCurve(smooth, t);\n    }\n    LineAvoidsTightHierarchyLP(ls, polylineToExclude) {\n        let lineIsGood = true;\n        for (const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfTightHierarchy)) {\n            if (ii.seg1 !== polylineToExclude) {\n                lineIsGood = false;\n                break;\n            }\n        }\n        return lineIsGood;\n    }\n    LineAvoidsTightHierarchyLPP(ls, polylineToExclude0, polylineToExclude1) {\n        let lineIsGood = true;\n        for (const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfTightHierarchy)) {\n            if (!(ii.seg1 === polylineToExclude0 || ii.seg1 === polylineToExclude1)) {\n                lineIsGood = false;\n                break;\n            }\n        }\n        return lineIsGood;\n    }\n    LineAvoidsTightHierarchyPPPP(a, b, polylineToExclude0, polylineToExclude1) {\n        return this.LineAvoidsTightHierarchyLPP(LineSegment.mkPP(a, b), polylineToExclude0, polylineToExclude1);\n    }\n    ExtendVisibilityGraphToTargetBoundaryPort(takenOutTargetPortLocation) {\n        let addedPolygons = null;\n        if (this.VisibilityGraph == null) {\n            this.VisibilityGraph = new VisibilityGraph();\n        }\n        if (!this.activeRectangle.contains(takenOutTargetPortLocation) ||\n            !this.activeRectangle.containsRect(this.TargetLoosePolyline.boundingBox)) {\n            if (this.activeRectangle.isEmpty) {\n                this.activeRectangle = this.TargetLoosePolyline.boundingBox.clone();\n                this.activeRectangle.add(this.SourcePort.Location);\n                this.activeRectangle.add(this.StartPointOfEdgeRouting);\n                this.activeRectangle.add(takenOutTargetPortLocation);\n            }\n            else {\n                this.activeRectangle.add(takenOutTargetPortLocation);\n                this.activeRectangle.addRec(this.TargetLoosePolyline.boundingBox);\n            }\n            addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();\n            for (const polygon of addedPolygons) {\n                this.VisibilityGraph.AddHole(polygon.Polyline);\n            }\n        }\n        if (addedPolygons == null) {\n            if (this.targetVV != null) {\n                this.VisibilityGraph.RemoveVertex(this.targetVV);\n            }\n            this.CalculateEdgeTargetVisibilityGraph(takenOutTargetPortLocation);\n        }\n        else {\n            this.RemovePointVisibilityGraphs();\n            const visibilityGraphGenerator = new InteractiveTangentVisibilityGraphCalculator(addedPolygons, this.activePolygons, this.VisibilityGraph);\n            visibilityGraphGenerator.run();\n            addRange(this.activePolygons, addedPolygons);\n            this.CalculateEdgeTargetVisibilityGraph(takenOutTargetPortLocation);\n            this.CalculateSourcePortVisibilityGraph();\n        }\n    }\n    // returns the hit object\n    GetHitLoosePolyline(point) {\n        if (this.ObstacleCalculator.IsEmpty() || this.ObstacleCalculator.RootOfLooseHierarchy == null) {\n            return null;\n        }\n        return InteractiveEdgeRouter.GetFirstHitPolyline(point, this.ObstacleCalculator.RootOfLooseHierarchy);\n    }\n    static GetFirstHitPolyline(point, rectangleNode) {\n        const rectNode = InteractiveEdgeRouter.GetFirstHitRectangleNode(point, rectangleNode);\n        return rectNode ? rectNode.UserData : null;\n    }\n    static GetFirstHitRectangleNode(point, rectangleNode) {\n        if (rectangleNode == null) {\n            return null;\n        }\n        return rectangleNode.FirstHitNodeWithPredicate(point, (pnt, polyline) => Curve.PointRelativeToCurveLocation(pnt, polyline) !== PointLocation.Outside ? HitTestBehavior.Stop : HitTestBehavior.Continue);\n    }\n    //\n    Clean() {\n        this.TargetPort = null;\n        this.SourcePort = null;\n        this.SourceTightPolyline = null;\n        this.SourceLoosePolyline = null;\n        this.TargetLoosePolyline = null;\n        this.targetTightPolyline = null;\n        this.VisibilityGraph = null;\n        this.targetVV = null;\n        this.sourceVV = null;\n        this.activePolygons = [];\n        this.alreadyAddedOrExcludedPolylines.clear();\n        this.activeRectangle.setToEmpty();\n    }\n    // setting source port and the loose polyline of the port\n    SetSourcePortAndSourceLoosePolyline(port, sourceLoosePolylinePar) {\n        this.SourceLoosePolyline = sourceLoosePolylinePar;\n        this.sourcePort = port;\n        if (this.sourcePort != null) {\n            this.SourceTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.Location, this.ObstacleCalculator.RootOfTightHierarchy);\n            if (this.sourcePort instanceof FloatingPort) {\n                this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline);\n                // we need to exclude the loose polyline around the source port from the tangent visibily graph\n                this.StartPointOfEdgeRouting = this.SourcePort.Location;\n            }\n            else {\n                this.StartPointOfEdgeRouting = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve, this.sourcePort.Parameter, this.SourceLoosePolyline);\n            }\n        }\n    }\n    run() {\n        this.CalculateWholeTangentVisibilityGraph();\n    }\n    CalculateWholeTangentVisibilityGraph() {\n        this.VisibilityGraph = new VisibilityGraph();\n        this.CalculateWholeVisibilityGraphOnExistingGraph();\n    }\n    CalculateWholeVisibilityGraphOnExistingGraph() {\n        this.activePolygons = Array.from(this.AllPolygons());\n        for (const polylineLocal of this.ObstacleCalculator.LooseObstacles) {\n            this.VisibilityGraph.AddHole(polylineLocal);\n        }\n        let visibilityGraphGenerator;\n        if (this.UseSpanner) {\n            visibilityGraphGenerator = new ConeSpanner(this.ObstacleCalculator.LooseObstacles, this.VisibilityGraph);\n        }\n        else {\n            visibilityGraphGenerator = new InteractiveTangentVisibilityGraphCalculator(new Array(), this.activePolygons, this.visibilityGraph);\n        }\n        visibilityGraphGenerator.run();\n    }\n    RouteSplineFromPortToPortWhenTheWholeGraphIsReady(sourcePortLocal, targetPortLocal, smooth, t) {\n        const reversed = (sourcePortLocal instanceof FloatingPort && targetPortLocal instanceof CurvePort) ||\n            sourcePortLocal instanceof HookUpAnywhereFromInsidePort;\n        if (reversed) {\n            const tmp = sourcePortLocal;\n            sourcePortLocal = targetPortLocal;\n            targetPortLocal = tmp;\n        }\n        this.sourcePort = sourcePortLocal;\n        this.targetPort = targetPortLocal;\n        this.FigureOutSourceTargetPolylinesAndActiveRectangle();\n        let curve = this.GetEdgeGeomByRouting(smooth, t);\n        if (curve == null) {\n            return null;\n        }\n        this.targetVV = null;\n        this.sourceVV = null;\n        if (reversed) {\n            curve = curve.reverse();\n        }\n        return curve;\n    }\n    GetEdgeGeomByRouting(smooth, t) {\n        this.sourceIsInsideOfTargetTightPolyline =\n            this.TargetTightPolyline == null ||\n                Curve.PointRelativeToCurveLocation(this.sourcePort.Location, this.TargetTightPolyline) === PointLocation.Inside;\n        let curve;\n        if (this.sourcePort instanceof CurvePort) {\n            const curvePort = this.sourcePort;\n            this.StartPointOfEdgeRouting = !this.targetIsInsideOfSourceTightPolyline\n                ? this.TakeBoundaryPortOutsideOfItsLoosePolyline(curvePort.Curve, curvePort.Parameter, this.SourceLoosePolyline)\n                : curvePort.Location;\n            this.CalculateSourcePortVisibilityGraph();\n            const t = { smoothedPolyline: null };\n            if (this.targetPort instanceof CurvePort) {\n                curve = this.RouteFromBoundaryPortToBoundaryPort(smooth, t);\n            }\n            else {\n                curve = this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline, smooth, t);\n            }\n        }\n        else if (this.targetPort instanceof FloatingPort) {\n            this.ExtendVisibilityGraphFromFloatingSourcePort();\n            // Assert.assert(this.sourceVV != null)\n            // the edge has to be reversed to route from CurvePort to FloatingPort\n            curve = this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline, smooth, t);\n        }\n        else {\n            // Assert.assert(this.targetPort instanceof HookUpAnywhereFromInsidePort)\n            curve = this.RouteFromFloatingPortToAnywherePort(this.targetPort.LoosePolyline, smooth, t, this.targetPort);\n        }\n        return curve;\n    }\n    RouteFromFloatingPortToAnywherePort(targetLoosePoly, smooth, t, port) {\n        if (!port.Curve.boundingBox.contains(this.sourcePort.Location)) {\n            t.smoothedPolyline = null;\n            return null;\n        }\n        this.sourceVV = this.GetVertex(this.sourcePort.Location);\n        this._polyline = this.GetShortestPolylineToMulitpleTargets(this.sourceVV, Array.from(this.Targets(targetLoosePoly)));\n        if (this._polyline == null) {\n            return null;\n        }\n        this.FixLastPolylinePointForAnywherePort(port);\n        if (port.HookSize > 0) {\n            this.BuildHook(port);\n        }\n        return this.SmoothCornersAndReturnCurve(smooth, t);\n    }\n    BuildHook(port) {\n        const curve = port.Curve;\n        // creating a hook\n        const ellipse = Ellipse.mkFullEllipseNNP(port.HookSize, port.HookSize, this._polyline.end);\n        const intersections = Curve.getAllIntersections(curve, ellipse, true);\n        // Assert.assert(intersections.length === 2)\n        if (Point.getTriangleOrientation(intersections[0].x, this._polyline.end, this._polyline.endPoint.prev.point) ==\n            TriangleOrientation.Counterclockwise) {\n            intersections.reverse();\n        }\n        // so the [0] point is to the left of the Polyline\n        const polylineTangent = this._polyline.end.sub(this._polyline.endPoint.prev.point).normalize();\n        const tan0 = curve.derivative(intersections[0].par0).normalize();\n        const prj0 = tan0.dot(polylineTangent);\n        if (Math.abs(prj0) < 0.2) {\n            this.ExtendPolyline(tan0, intersections[0], polylineTangent, port);\n        }\n        else {\n            const tan1 = curve.derivative(intersections[1].par0).normalize();\n            const prj1 = tan1.dot(polylineTangent);\n            if (prj1 < prj0) {\n                this.ExtendPolyline(tan1, intersections[1], polylineTangent, port);\n            }\n            else {\n                this.ExtendPolyline(tan0, intersections[0], polylineTangent, port);\n            }\n        }\n    }\n    ExtendPolyline(tangentAtIntersection, x, polylineTangent, port) {\n        let normal = tangentAtIntersection.rotate(Math.PI / 2);\n        if (normal.dot(polylineTangent) < 0) {\n            normal = normal.neg();\n        }\n        const pointBeforeLast = x.x.add(normal.mul(port.HookSize));\n        let pointAfterX;\n        if (!(pointAfterX = Point.lineLineIntersection(pointBeforeLast, pointBeforeLast.add(tangentAtIntersection), this._polyline.end, this._polyline.end.add(polylineTangent)))) {\n            return;\n        }\n        this._polyline.addPoint(pointAfterX);\n        this._polyline.addPoint(pointBeforeLast);\n        this._polyline.addPoint(x.x);\n    }\n    FixLastPolylinePointForAnywherePort(port) {\n        while (true) {\n            const lastPointInside = this.GetLastPointInsideOfCurveOnPolyline(port.Curve);\n            lastPointInside.next.next = null;\n            this._polyline.endPoint = lastPointInside.next;\n            let dir = lastPointInside.next.point.sub(lastPointInside.point);\n            dir = dir.normalize().mul(port.Curve.boundingBox.diagonal);\n            // make it a long vector\n            const dir0 = dir.rotate(port.AdjustmentAngle * -1);\n            const dir1 = dir.rotate(port.AdjustmentAngle);\n            const rx = Curve.intersectionOne(port.Curve, LineSegment.mkPP(lastPointInside.point, lastPointInside.point.add(dir0)), true);\n            const lx = Curve.intersectionOne(port.Curve, LineSegment.mkPP(lastPointInside.point, lastPointInside.point.add(dir1)), true);\n            if (rx == null || lx == null) {\n                return;\n            }\n            // this.ShowPolylineAndObstacles(Polyline, LineSegment.mkPP(lastPointInside.Point, lastPointInside.Point+dir0), LineSegment.mkPP(lastPointInside.Point, rerPoint+dir1), port.Curve);\n            const trimmedCurve = InteractiveEdgeRouter.GetTrimmedCurveForHookingUpAnywhere(port.Curve, lastPointInside, rx, lx);\n            const newLastPoint = trimmedCurve.value(trimmedCurve.closestParameter(lastPointInside.point));\n            if (!this.LineAvoidsTightHierarchyLPP(LineSegment.mkPP(lastPointInside.point, newLastPoint), this.SourceTightPolyline, null)) {\n                const xx = Curve.intersectionOne(port.Curve, LineSegment.mkPP(lastPointInside.point, lastPointInside.next.point), false);\n                if (xx == null) {\n                    return;\n                }\n                // this.ShowPolylineAndObstacles(Polyline, port.Curve);\n                this._polyline.endPoint.point = xx.x;\n                break;\n            }\n            this._polyline.endPoint.point = newLastPoint;\n            if (lastPointInside.prev == null || !this.TryShortcutPolyPoint(lastPointInside.prev)) {\n                break;\n            }\n        }\n    }\n    static GetTrimmedCurveForHookingUpAnywhere(curve, lastPointInside, x0, x1) {\n        const clockwise = Point.getTriangleOrientation(x1.x, x0.x, lastPointInside.point) === TriangleOrientation.Clockwise;\n        const rightX = x0.par0;\n        const leftX = x1.par0;\n        let tr1;\n        let tr0;\n        let ret;\n        if (clockwise) {\n            if (rightX < leftX) {\n                return curve.trim(rightX, leftX);\n            }\n            tr0 = curve.trim(rightX, curve.parEnd);\n            tr1 = curve.trim(curve.parStart, leftX);\n            ret = new Curve();\n            return ret.addSegs([tr0, tr1]);\n        }\n        if (leftX < rightX) {\n            return curve.trim(leftX, rightX);\n        }\n        tr0 = curve.trim(leftX, curve.parEnd);\n        tr1 = curve.trim(curve.parStart, rightX);\n        ret = new Curve();\n        return ret.addSegs([tr0, tr1]);\n    }\n    GetLastPointInsideOfCurveOnPolyline(curve) {\n        for (let p = this._polyline.endPoint.prev; p != null; p = p.prev) {\n            if (p.prev == null) {\n                return p;\n            }\n            if (Curve.PointRelativeToCurveLocation(p.point, curve) === PointLocation.Inside) {\n                return p;\n            }\n        }\n        throw new Error();\n    }\n    GetShortestPolylineToMulitpleTargets(sourceVisVertex, targets) {\n        this.CleanTheGraphForShortestPath();\n        // ShowPolylineAndObstacles(targets.Select(t=>new Ellipse(3,3,t.Point)).ToArray());\n        const pathCalc = new SingleSourceMultipleTargetsShortestPathOnVisibilityGraph(sourceVisVertex, targets, this.VisibilityGraph);\n        // { dd = ShowPolylineAndObstacles };\n        const path = pathCalc.GetPath();\n        if (path == null) {\n            return null;\n        }\n        // Assert.assert(((from(path).first() === sourceVisVertex)\n        //                && targets.contains(path.last())));\n        const ret = new Polyline();\n        for (const v of path) {\n            ret.addPoint(v.point);\n        }\n        return ret.RemoveCollinearVertices();\n    }\n    Targets(targetLoosePoly) {\n        return Array.from(targetLoosePoly).map((p) => this.visibilityGraph.FindVertex(p));\n    }\n    ExtendVisibilityGraphFromFloatingSourcePort() {\n        const fp = this.sourcePort;\n        // Assert.assert(this.sourcePort instanceof FloatingPort)\n        this.StartPointOfEdgeRouting = fp.Location;\n        if (this.UseSpanner) {\n            this.sourceVV = this.AddTransientVisibilityEdgesForPort(this.sourcePort.Location, this.SourceLoosePolyline);\n        }\n        else {\n            this.sourceVV = PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()).filter((p) => p !== this.SourceLoosePolyline), this.VisibilityGraph, this.StartPointOfEdgeRouting, VisibilityKind.Tangent);\n        }\n    }\n    FigureOutSourceTargetPolylinesAndActiveRectangle() {\n        let p = this.sourcePort.Curve.value(this.sourcePort.Curve.parStart);\n        this._sourceTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(p, this.ObstacleCalculator.RootOfTightHierarchy);\n        this.SourceLoosePolyline = InteractiveEdgeRouter.GetFirstHitPolyline(p, this.ObstacleCalculator.RootOfLooseHierarchy);\n        p = this.targetPort.Curve.value(this.targetPort.Curve.parStart);\n        this.targetTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(p, this.ObstacleCalculator.RootOfTightHierarchy);\n        this.targetLoosePolyline = InteractiveEdgeRouter.GetFirstHitPolyline(p, this.ObstacleCalculator.RootOfLooseHierarchy);\n        this.activeRectangle = Rectangle.mkPP(new Point(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY), new Point(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY));\n    }\n    *AllPolygons() {\n        for (const p of this.ObstacleCalculator.LooseObstacles) {\n            yield new Polygon(p);\n        }\n    }\n    //\n    GetVisibilityGraph() {\n        return this.VisibilityGraph;\n    }\n    // ShowObstaclesAndVisGraph() {\n    //    let obs = this.ObstacleCalculator.LooseObstacles.Select(() => {  }, new DebugCurve(100, 1, \"blue\", o));\n    //    let edges = this.visibilityGraph.Edges.Select(() => {  }, new DebugCurve(70, 1, (e instanceof  \"red\"), LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));\n    //    // TODO: Warning!!!, inline IF is not supported ?\n    //    TransientVisibilityEdge;\n    //    \"green\";\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(obs.Concat(edges));\n    // }\n    AddActivePolygons(polygons) {\n        addRange(this.activePolygons, polygons);\n    }\n    ClearActivePolygons() {\n        this.activePolygons = [];\n    }\n}\n//# sourceMappingURL=interactiveEdgeRouter.js.map","import { LineSegment } from '../math/geometry';\nimport { ConvexHull } from '../math/geometry/convexHull';\nimport { Curve, PointLocation } from '../math/geometry/curve';\nimport { GeomConstants } from '../math/geometry/geomConstants';\nimport { Point, TriangleOrientation } from '../math/geometry/point';\nimport { Polyline } from '../math/geometry/polyline';\nimport { CreateRectNodeOnArrayOfRectNodes, mkRectangleNode } from '../math/geometry/RTree/rectangleNode';\nimport { CrossRectangleNodesSameType } from '../math/geometry/RTree/rectangleNodeUtils';\nimport { GetConnectedComponents } from '../math/graphAlgorithms/ConnectedComponentCalculator';\nimport { mkGraphOnEdgesArray } from '../structs/basicGraphOnEdges';\nimport { IntPair } from '../utils/IntPair';\nimport { random } from '../utils/random';\nimport { flattenArray } from '../utils/setOperations';\nimport { Polygon } from './visibility/Polygon';\nexport class InteractiveObstacleCalculator {\n    ObstaclesIntersectLine(a, b) {\n        return this.ObstaclesIntersectICurve(LineSegment.mkPP(a, b));\n    }\n    static PadCorner(localpoly, p0, p1, p2, padding) {\n        const padInfo = InteractiveObstacleCalculator.GetPaddedCorner(p0, p1, p2, padding);\n        if (padInfo.numberOfPoints === -1) {\n            return false;\n        }\n        localpoly.addPoint(padInfo.a);\n        if (padInfo.numberOfPoints === 2) {\n            localpoly.addPoint(padInfo.b);\n        }\n        return true;\n    }\n    static CurveIsClockwise(iCurve, pointInside) {\n        return (Point.getTriangleOrientation(pointInside, iCurve.start, iCurve.start.add(iCurve.derivative(iCurve.parStart))) ==\n            TriangleOrientation.Clockwise);\n    }\n    static PaddedPolylineBoundaryOfNode(curve, padding, randomizePoints = false) {\n        return InteractiveObstacleCalculator.CreatePaddedPolyline(Curve.polylineAroundClosedCurve(curve), padding, randomizePoints);\n    }\n    /** surrounds the given polyline with the given offset, optionally randomizes the output */\n    static LoosePolylineWithFewCorners(tightPolyline, p, randomizationShift) {\n        if (p < GeomConstants.distanceEpsilon) {\n            return tightPolyline;\n        }\n        return InteractiveObstacleCalculator.CreateLoosePolylineOnBisectors(tightPolyline, p, randomizationShift);\n    }\n    static CreateLoosePolylineOnBisectors(tightPolyline, offset, randomizationShift) {\n        const ps = Array.from(InteractiveObstacleCalculator.BisectorPoints(tightPolyline, offset));\n        if (randomizationShift)\n            randomizePoints();\n        const convHull = ConvexHull.CalculateConvexHull(ps);\n        return Polyline.mkClosedFromPoints(convHull);\n        function randomizePoints() {\n            for (let i = 0; i < ps.length; i++) {\n                const p = ps[i];\n                ps[i] = new Point(p.x + (2 * random() - 1) * randomizationShift, p.y + (2 * random() - 1) * randomizationShift);\n            }\n        }\n    }\n    static CreateRectNodeOfPolyline(polyline) {\n        return mkRectangleNode(polyline, polyline.boundingBox);\n    }\n    CreateLooseObstacles() {\n        this.tightPolylinesToLooseDistances = new Map();\n        this.LooseObstacles = new Array();\n        for (const tightPolyline of this.TightObstacles) {\n            const distance = InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(this.RootOfTightHierarchy, tightPolyline, this.LoosePadding);\n            this.tightPolylinesToLooseDistances.set(tightPolyline, distance);\n            this.LooseObstacles.push(InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline, distance, this.randomizationShift));\n        }\n        this.RootOfLooseHierarchy = InteractiveObstacleCalculator.CalculateHierarchy(this.LooseObstacles);\n        // Assert.assert(\n        //  InteractiveObstacleCalculator.GetOverlappedPairSet(this.RootOfLooseHierarchy).size === 0,\n        //  'Overlaps are found in LooseObstacles',\n        // )\n    }\n    CreateTightObstacles() {\n        this.RootOfTightHierarchy = this.CreateTightObstacles_();\n        this.OverlapsDetected = this.TightObstacles.size < this.Obstacles.length;\n    }\n    Calculate() {\n        if (this.IgnoreTightPadding)\n            this.CreateTightObstaclesIgnoringTightPadding();\n        else\n            this.CreateTightObstacles();\n        if (!this.IsEmpty())\n            this.CreateLooseObstacles();\n    }\n    IsEmpty() {\n        return this.TightObstacles == null || this.TightObstacles.size === 0;\n    }\n    constructor(obstacles, tightPadding, loosePadding, ignoreTightPadding) {\n        /** if set to true the vertices of the loose polylines would be randomly shifted by a small amont */\n        this.randomizationShift = 0.01;\n        this.TightObstacles = new Set();\n        this.Obstacles = obstacles;\n        this.TightPadding = tightPadding;\n        this.LoosePadding = loosePadding;\n        this.IgnoreTightPadding = ignoreTightPadding;\n    }\n    ObstaclesIntersectICurve(curve) {\n        const rect = curve.boundingBox;\n        return InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, rect, this.RootOfTightHierarchy);\n    }\n    static CurveIntersectsRectangleNode(curve, curveBox, rectNode) {\n        if (!rectNode.irect.intersects(curveBox)) {\n            return false;\n        }\n        if (rectNode.UserData != null) {\n            const curveUnderTest = rectNode.UserData;\n            return (Curve.intersectionOne(curveUnderTest, curve, false) != null ||\n                InteractiveObstacleCalculator.PointIsInside(curveUnderTest.start, curve));\n        }\n        // Assert.assert(rectNode.Left != null && rectNode.Right != null)\n        return (InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, curveBox, rectNode.Left) ||\n            InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, curveBox, rectNode.Right));\n    }\n    static PointIsInside(point, curve) {\n        return Curve.PointRelativeToCurveLocation(point, curve) === PointLocation.Inside;\n    }\n    CreateTightObstaclesIgnoringTightPadding() {\n        const polysWithoutPadding = this.Obstacles.map((o) => Curve.polylineAroundClosedCurve(o));\n        const polylineHierarchy = InteractiveObstacleCalculator.CalculateHierarchy(polysWithoutPadding);\n        const overlappingPairSet = InteractiveObstacleCalculator.GetOverlappedPairSet(polylineHierarchy);\n        this.TightObstacles = new Set();\n        if (overlappingPairSet.size === 0) {\n            for (const polyline of polysWithoutPadding) {\n                const distance = InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(polylineHierarchy, polyline, this.TightPadding);\n                this.TightObstacles.add(InteractiveObstacleCalculator.LoosePolylineWithFewCorners(polyline, distance, this.randomizationShift));\n            }\n            this.RootOfTightHierarchy = InteractiveObstacleCalculator.CalculateHierarchy(Array.from(this.TightObstacles));\n        }\n        else {\n            for (const localpoly of polysWithoutPadding) {\n                this.TightObstacles.add(InteractiveObstacleCalculator.CreatePaddedPolyline(localpoly, this.TightPadding));\n            }\n            if (!this.IsEmpty()) {\n                this.RootOfTightHierarchy = InteractiveObstacleCalculator.CalculateHierarchy(Array.from(this.TightObstacles));\n                this.OverlapsDetected = false;\n                while (InteractiveObstacleCalculator.GetOverlappedPairSet(this.RootOfTightHierarchy).size > 0) {\n                    this.RootOfTightHierarchy = InteractiveObstacleCalculator.ReplaceTightObstaclesWithConvexHulls(this.TightObstacles, Array.from(overlappingPairSet));\n                    this.OverlapsDetected = true;\n                }\n            }\n        }\n    }\n    CreateTightObstacles_() {\n        if (this.Obstacles.length === 0) {\n            return null;\n        }\n        for (const curve of this.Obstacles) {\n            InteractiveObstacleCalculator.CalculateTightPolyline(this.TightObstacles, this.TightPadding, curve);\n        }\n        return InteractiveObstacleCalculator.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(this.TightObstacles);\n    }\n    static CalculateTightPolyline(tightObstacles, tightPadding, curve) {\n        const tightPoly = InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(curve, tightPadding);\n        tightObstacles.add(tightPoly);\n    }\n    static CalculateHierarchy(polylines) {\n        const rectNodes = polylines.map((polyline) => InteractiveObstacleCalculator.CreateRectNodeOfPolyline(polyline));\n        return CreateRectNodeOnArrayOfRectNodes(rectNodes);\n    }\n    static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacleSet) {\n        let hierarchy = InteractiveObstacleCalculator.CalculateHierarchy(Array.from(tightObstacleSet));\n        let overlappingPairSet;\n        while ((overlappingPairSet = InteractiveObstacleCalculator.GetOverlappedPairSet(hierarchy)).size > 0) {\n            hierarchy = InteractiveObstacleCalculator.ReplaceTightObstaclesWithConvexHulls(tightObstacleSet, Array.from(overlappingPairSet));\n        }\n        return hierarchy;\n    }\n    static MapToInt(objects) {\n        const ret = new Map();\n        for (let i = 0; i < objects.length; i++) {\n            ret.set(objects[i], i);\n        }\n        return ret;\n    }\n    static ReplaceTightObstaclesWithConvexHulls(tightObsts, overlappingPairSet) {\n        const overlapping = new Set();\n        for (const pair of overlappingPairSet) {\n            overlapping.add(pair[0]);\n            overlapping.add(pair[1]);\n        }\n        const intToPoly = Array.from(overlapping);\n        const polyToInt = InteractiveObstacleCalculator.MapToInt(intToPoly);\n        const graph = mkGraphOnEdgesArray(Array.from(overlappingPairSet).map((pair) => new IntPair(polyToInt.get(pair[0]), polyToInt.get(pair[1]))));\n        const connectedComponents = GetConnectedComponents(graph);\n        for (const component of connectedComponents) {\n            const polys = component.map((i) => intToPoly[i]);\n            const points = flattenArray(polys, (p) => p);\n            const convexHull = ConvexHull.createConvexHullAsClosedPolyline(points);\n            for (const localpoly of polys) {\n                tightObsts.delete(localpoly);\n            }\n            tightObsts.add(convexHull);\n        }\n        return InteractiveObstacleCalculator.CalculateHierarchy(Array.from(tightObsts));\n    }\n    static OneCurveLiesInsideOfOther(polyA, polyB) {\n        // Assert.assert(!Curve.CurvesIntersect(polyA, polyB), 'The curves should not intersect')\n        return (Curve.PointRelativeToCurveLocation(polyA.start, polyB) !== PointLocation.Outside ||\n            Curve.PointRelativeToCurveLocation(polyB.start, polyA) !== PointLocation.Outside);\n    }\n    static PolylinesIntersect(a, b) {\n        const ret = Curve.CurvesIntersect(a, b) || InteractiveObstacleCalculator.OneCurveLiesInsideOfOther(a, b);\n        return ret;\n    }\n    static GetOverlappedPairSet(rootOfObstacleHierarchy) {\n        const overlappingPairSet = new Set();\n        CrossRectangleNodesSameType(rootOfObstacleHierarchy, rootOfObstacleHierarchy, (a, b) => {\n            if (InteractiveObstacleCalculator.PolylinesIntersect(a, b)) {\n                overlappingPairSet.add([a, b]);\n            }\n        });\n        return overlappingPairSet;\n    }\n    static *BisectorPoints(tightPolyline, offset) {\n        for (let pp = tightPolyline.startPoint; pp != null; pp = pp.next) {\n            const t = { skip: false };\n            const currentSticking = InteractiveObstacleCalculator.GetStickingVertexOnBisector(pp, offset, t);\n            if (!t.skip) {\n                yield currentSticking;\n            }\n        }\n    }\n    static GetStickingVertexOnBisector(pp, p, t) {\n        const u = pp.polyline.prev(pp).point;\n        const v = pp.point;\n        const w = pp.polyline.next(pp).point;\n        let z = v.sub(u).normalize().add(v.sub(w).normalize());\n        const zLen = z.length;\n        if (zLen < GeomConstants.tolerance) {\n            t.skip = true;\n        }\n        else {\n            t.skip = false;\n            z = z.div(zLen);\n        }\n        return z.mul(p).add(v);\n    }\n    static FindMaxPaddingForTightPolyline(hierarchy, polyline, desiredPadding) {\n        let dist = desiredPadding;\n        const polygon = new Polygon(polyline);\n        const boundingBox = polyline.boundingBox.clone();\n        boundingBox.pad(2 * desiredPadding);\n        for (const localpoly of Array.from(hierarchy.GetNodeItemsIntersectingRectangle(boundingBox)).filter((p) => p !== polyline)) {\n            const separation = Polygon.Distance(polygon, new Polygon(localpoly)).dist;\n            dist = Math.min(dist, separation / InteractiveObstacleCalculator.LooseDistCoefficient);\n        }\n        return dist;\n    }\n    static GetPaddedCorner(first, second, third, padding) {\n        const u = first.point;\n        const v = second.point;\n        const w = third.point;\n        if (Point.getTriangleOrientation(u, v, w) === TriangleOrientation.Counterclockwise) {\n            return { a: undefined, b: undefined, numberOfPoints: -1 };\n        }\n        let uvPerp = v\n            .sub(u)\n            .rotate(Math.PI / 2)\n            .normalize();\n        if (InteractiveObstacleCalculator.CornerIsNotTooSharp(u, v, w)) {\n            // the angle is not too sharp: just continue the offset lines of the sides and return their intersection\n            uvPerp = uvPerp.mul(padding);\n            const vwPerp = w\n                .sub(v)\n                .normalize()\n                .mul(padding)\n                .rotate(Math.PI / 2);\n            const a = Point.lineLineIntersection(u.add(uvPerp), v.add(uvPerp), v.add(vwPerp), w.add(vwPerp));\n            /*Assert.assert(a !== undefined)*/\n            return { a: a, b: a, numberOfPoints: 1 };\n        }\n        const l = v.sub(u).normalize().add(v.sub(w).normalize());\n        if (l.length < GeomConstants.intersectionEpsilon) {\n            const a = v.add(uvPerp.mul(padding));\n            return { a: a, b: a, numberOfPoints: 1 };\n        }\n        const d = l.normalize().mul(padding);\n        const dp = d.rotate(Math.PI / 2);\n        // look for a in the form d+x*dp\n        // we have:  Padding=(d+x*dp)*uvPerp\n        const xp = (padding - d.dot(uvPerp)) / dp.dot(uvPerp);\n        const dpxp = dp.mul(xp);\n        return { a: d.add(dpxp).add(v), b: d.sub(dpxp).add(v), numberOfPoints: 2 };\n    }\n    static CornerIsNotTooSharp(u, v, w) {\n        const a = u\n            .sub(v)\n            .rotate(Math.PI / 4)\n            .add(v);\n        return Point.getTriangleOrientation(v, a, w) === TriangleOrientation.Counterclockwise;\n        //   return Point.Angle(u, v, w) > Math.PI / 4;\n    }\n    static CreatePaddedPolyline(poly, padding, randomizePoints = false) {\n        /*Assert.assert(\n          Point.getTriangleOrientation(\n            localpoly.start,\n            localpoly.startPoint.next.point,\n            localpoly.startPoint.next.next.point,\n          ) === TriangleOrientation.Clockwise,\n          'Unpadded polyline is not clockwise',\n        )*/\n        const ret = new Polyline();\n        const localPoly = randomizePoints ? getPolyRandom(poly) : poly;\n        if (!InteractiveObstacleCalculator.PadCorner(ret, localPoly.endPoint.prev, localPoly.endPoint, localPoly.startPoint, padding)) {\n            return InteractiveObstacleCalculator.CreatePaddedPolyline(Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(localPoly))), padding);\n        }\n        if (!InteractiveObstacleCalculator.PadCorner(ret, localPoly.endPoint, localPoly.startPoint, localPoly.startPoint.next, padding)) {\n            return InteractiveObstacleCalculator.CreatePaddedPolyline(Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(localPoly))), padding);\n        }\n        for (let pp = localPoly.startPoint; pp.next.next != null; pp = pp.next) {\n            if (!InteractiveObstacleCalculator.PadCorner(ret, pp, pp.next, pp.next.next, padding)) {\n                return InteractiveObstacleCalculator.CreatePaddedPolyline(Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(localPoly))), padding);\n            }\n        }\n        /*Assert.assert(\n          Point.getTriangleOrientation(\n            ret.start,\n            ret.startPoint.next.point,\n            ret.startPoint.next.next.point,\n          ) !== TriangleOrientation.Counterclockwise,\n          'Padded polyline is counterclockwise',\n        )*/\n        ret.closed = true;\n        return ret;\n    }\n}\nInteractiveObstacleCalculator.LooseDistCoefficient = 2.1;\nfunction getPolyRandom(poly) {\n    const ret = new Polyline();\n    const eps = 0.01;\n    for (let p = poly.startPoint; p; p = p.next) {\n        const x = p.point.x + eps * random();\n        const y = p.point.y + eps * random();\n        ret.addPointXY(x, y);\n    }\n    ret.closed = poly.closed;\n    return ret;\n}\n//# sourceMappingURL=interactiveObstacleCalculator.js.map","import { SweepEvent } from '../spline/coneSpanner/SweepEvent';\nexport class AxisCoordinateEvent extends SweepEvent {\n    constructor(p) {\n        super();\n        this.site = p;\n    }\n    get Site() {\n        return this.site;\n    }\n}\n//# sourceMappingURL=AxisCoordinateEvent.js.map","// BasicObstacleSide is base class for an obstacle side that is to the low or high end of the\n// scanline-parallel coordinate, and knows which direction to traverse to find the endVertex.\n// This is different from RightObstacleSide or LeftObstacleSide, where the class itself is the\n// determinant of traversal direction being with or opposite to the clockwise polyline direction;\nimport { ObstacleSide } from '../spline/coneSpanner/ObstacleSide';\nimport { StaticGraphUtility } from './StaticGraphUtility';\n// BasicObstacleSide uses the ctor arg traverseClockwise to manage that.\nexport class BasicObstacleSide extends ObstacleSide {\n    get Obstacle() {\n        return this.obstacle;\n    }\n    set Obstacle(value) {\n        this.obstacle = value;\n    }\n    constructor(obstacle, startVertex, scanDir, traverseClockwise) {\n        super(startVertex);\n        this.Slope = 0;\n        this.SlopeInverse = 0;\n        this.Obstacle = obstacle;\n        this.endVertex = traverseClockwise ? startVertex.nextOnPolyline : startVertex.prevOnPolyline;\n        if (!scanDir.IsPerpendicularPP(startVertex.point, this.endVertex.point)) {\n            this.Slope = StaticGraphUtility.Slope(startVertex.point, this.endVertex.point, scanDir);\n            this.SlopeInverse = 1 / this.Slope;\n        }\n    }\n    get EndVertex() {\n        return this.endVertex;\n    }\n}\nexport class LowObstacleSide extends BasicObstacleSide {\n    constructor(obstacle, startVertex, scanDir) {\n        super(obstacle, startVertex, scanDir, scanDir.IsHorizontal);\n    }\n}\nexport class HighObstacleSide extends BasicObstacleSide {\n    constructor(obstacle, startVertex, scanDir) {\n        super(obstacle, startVertex, scanDir, scanDir.IsVertical);\n    }\n}\n//# sourceMappingURL=BasicObstacleSide.js.map","import { VertexEvent } from '../spline/coneSpanner/VertexEvent';\nexport class BasicVertexEvent extends VertexEvent {\n    constructor(obstacle, p) {\n        super(p);\n        this.Obstacle = obstacle;\n    }\n}\n//# sourceMappingURL=BasicVertexEvent.js.map","// Wrap the tree of events.\nimport { BinaryHeapWithComparer } from '../../structs/BinaryHeapWithComparer';\nimport { BasicReflectionEvent } from './basicReflectionEvent';\nexport class EventQueue {\n    constructor() {\n        this.eventTree = new BinaryHeapWithComparer((a, b) => this.Compare(a, b));\n    }\n    Reset(scanDir) {\n        /*Assert.assert(0 === this.eventTree.Count, 'Stray events in EventQueue.Reset')*/\n        this.scanDirection = scanDir;\n    }\n    Enqueue(evt) {\n        this.eventTree.Enqueue(evt);\n    }\n    Dequeue() {\n        const evt = this.eventTree.Dequeue();\n        return evt;\n    }\n    get Count() {\n        return this.eventTree.Count;\n    }\n    Compare(lhs, rhs) {\n        if (lhs === rhs) {\n            return 0;\n        }\n        if (lhs == null) {\n            return -1;\n        }\n        if (rhs == null) {\n            return 1;\n        }\n        // First see if it's at the same scanline level (perpendicular coordinate).\n        let cmp = this.scanDirection.ComparePerpCoord(lhs.Site, rhs.Site);\n        if (cmp)\n            return cmp;\n        // Event sites are at the same scanline level. Make sure that any reflection events are lowest (come before\n        // any side events, which could remove the side the reflection event was queued for).  We may have two\n        // reflection events at same coordinate, because we enqueue in two situations: when a side is opened,\n        // and when a side that is within that side's scanline-parallel span is closed.\n        const lhsIsNotReflection = !(lhs instanceof BasicReflectionEvent) ? 1 : 0;\n        const rhsIsNotReflection = !(rhs instanceof BasicReflectionEvent) ? 1 : 0;\n        cmp = lhsIsNotReflection - rhsIsNotReflection;\n        // If the scanline-parallel coordinate is the same these events are at the same point.\n        if (cmp)\n            return cmp;\n        return this.scanDirection.CompareScanCoord(lhs.Site, rhs.Site);\n    }\n}\n//# sourceMappingURL=EventQueue.js.map","// This is a point on a path that is not associated with an obstacle, such as\n// a port for the end of a dragged path, or a waypoint.\nimport { CompassVector, Direction } from '../../math/geometry';\nimport { PointComparer } from './PointComparer';\nimport { ScanSegment } from './ScanSegment';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nexport class FreePoint {\n    get Point() {\n        return this.Vertex.point;\n    }\n    get InitialWeight() {\n        return this.IsOverlapped ? ScanSegment.OverlappedWeight : ScanSegment.NormalWeight;\n    }\n    get IsOutOfBounds() {\n        return Direction.None !== this.OutOfBoundsDirectionFromGraph;\n    }\n    // Called if we must create the vertex.\n    constructor(transUtil, point) {\n        this.maxVisibilitySegmentsAndCrossings = new Array(4);\n        this.OutOfBoundsDirectionFromGraph = Direction.None;\n        this.GetVertex(transUtil, point);\n    }\n    GetVertex(transUtil, point) {\n        this.Vertex = transUtil.FindOrAddVertex(point);\n    }\n    // Adds an edge from this.Vertex to a (possibly new) vertex at an intersection with an\n    // existing Edge that adjoins the point.  We take 'dir' as an input parameter for edge\n    // extension because we may be on the edge so can't calculate the direction.\n    AddEdgeToAdjacentEdge(transUtil, targetEdge, dirToExtend, limitRect) {\n        const targetIntersect = StaticGraphUtility.SegmentIntersectionEP(targetEdge, this.Point);\n        let targetVertex = transUtil.VisGraph.FindVertex(targetIntersect);\n        if (null != targetVertex) {\n            this.AddToAdjacentVertex(transUtil, targetVertex, dirToExtend, limitRect);\n        }\n        else {\n            targetVertex = transUtil.AddEdgeToTargetEdge(this.Vertex, targetEdge, targetIntersect);\n        }\n        this.ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect);\n        return targetVertex;\n    }\n    AddToAdjacentVertex(transUtil, targetVertex, dirToExtend, limitRect) {\n        if (!PointComparer.EqualPP(this.Point, targetVertex.point)) {\n            transUtil.FindOrAddEdge(this.Vertex, targetVertex, this.InitialWeight);\n        }\n        this.ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect);\n    }\n    ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect) {\n        // Extend the edge chain to the opposite side of the limit rectangle.\n        // StaticGraphUtility.Assert((PointComparer.Equal(this.Point, targetVertex.point)\n        //                || (PointComparer.GetPureDirectionVV(this.Point, targetVertex.point) === dirToExtend)), \"input dir does not match with to-targetVertex direction\", transUtil.ObstacleTree, transUtil.VisGraph);\n        let extendOverlapped = this.IsOverlapped;\n        if (extendOverlapped) {\n            // The initial vertex we connected to may be on the border of the enclosing obstacle,\n            // or of another also-overlapped obstacle.  If the former, we turn off overlap now.\n            extendOverlapped = transUtil.ObstacleTree.PointIsInsideAnObstaclePD(targetVertex.point, dirToExtend);\n        }\n        // If we're inside an obstacle's boundaries we'll never extend past the end of the obstacle\n        // due to encountering the boundary from the inside.  So start the extension at targetVertex.\n        const segmentAndCrossings = this.GetSegmentAndCrossings(this.IsOverlapped ? targetVertex : this.Vertex, dirToExtend, transUtil);\n        transUtil.ExtendEdgeChainVRLPB(targetVertex, limitRect, segmentAndCrossings[0], segmentAndCrossings[1], extendOverlapped);\n    }\n    GetSegmentAndCrossings(startVertex, dirToExtend, transUtil) {\n        const dirIndex = CompassVector.ToIndex(dirToExtend);\n        let segmentAndCrossings = this.maxVisibilitySegmentsAndCrossings[dirIndex];\n        if (segmentAndCrossings == null) {\n            const t = { pacList: null };\n            const maxVisibilitySegment = transUtil.ObstacleTree.CreateMaxVisibilitySegment(startVertex.point, dirToExtend, t);\n            segmentAndCrossings = [maxVisibilitySegment, t.pacList];\n            this.maxVisibilitySegmentsAndCrossings[dirIndex] = segmentAndCrossings;\n        }\n        else {\n            // For a waypoint this will be a target and then a source, so there may be a different lateral edge to\n            // connect to. In that case make sure we are consistent in directions - back up the start point if needed.\n            if (PointComparer.GetDirections(startVertex.point, segmentAndCrossings[0].start) === dirToExtend) {\n                segmentAndCrossings[0].start = startVertex.point;\n            }\n        }\n        return segmentAndCrossings;\n    }\n    MaxVisibilityInDirectionForNonOverlappedFreePoint(dirToExtend, transUtil) {\n        /*Assert.assert(\n          !this.IsOverlapped,\n          'Do not precalculate overlapped obstacle visibility as we should extend from the outer target vertex instead',\n        )*/\n        const segmentAndCrossings = this.GetSegmentAndCrossings(this.Vertex, dirToExtend, transUtil);\n        return segmentAndCrossings[0].end;\n    }\n    AddOobEdgesFromGraphCorner(transUtil, cornerPoint) {\n        const dirs = PointComparer.GetDirections(cornerPoint, this.Vertex.point);\n        const cornerVertex = transUtil.VisGraph.FindVertex(cornerPoint);\n        // For waypoints we want to be able to enter in both directions.\n        transUtil.ConnectVertexToTargetVertex(cornerVertex, this.Vertex, dirs & (Direction.North | Direction.South), ScanSegment.NormalWeight);\n        transUtil.ConnectVertexToTargetVertex(cornerVertex, this.Vertex, dirs & (Direction.East | Direction.West), ScanSegment.NormalWeight);\n    }\n    RemoveFromGraph() {\n        // Currently all transient removals and edge restorations are done by TransientGraphUtility itself.\n        this.Vertex = null;\n    }\n    toString() {\n        return this.Vertex.toString();\n    }\n}\n//# sourceMappingURL=FreePoint.js.map","// A Group is a Shape that has children.\n// This class defines a single crossing of a group boundary, from a point on the group boundary.\n// It is intended as the Value of a GroupBoundaryCrossingMap entry, or as an element in a VisiblityEdge.GroupCrossings\nimport { String } from 'typescript-string-operations';\nimport { CompassVector } from '../../math/geometry/compassVector';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { Point } from '../../math/geometry/point';\n// array, so the actual crossing coordinates are not included.\nexport class GroupBoundaryCrossing {\n    constructor(group, dirToInside) {\n        this.BoundaryWidth = GeomConstants.distanceEpsilon;\n        /*Assert.assert(\n          CompassVector.IsPureDirection(dirToInside),\n          'Impure direction',\n        )*/\n        this.Group = group;\n        this.DirectionToInside = dirToInside;\n    }\n    GetInteriorVertexPoint(outerVertex) {\n        return Point.RoundPoint(outerVertex.add(CompassVector.toPoint(this.DirectionToInside).mul(this.BoundaryWidth)));\n    }\n    toString() {\n        return String.Format('{0} {1}', this.DirectionToInside, this.Group);\n    }\n}\nGroupBoundaryCrossing.BoundaryWidth = GeomConstants.distanceEpsilon;\n//# sourceMappingURL=GroupBoundaryCrossing.js.map","import { String } from 'typescript-string-operations';\nimport { PointMap } from '../../utils/PointMap';\nimport { GroupBoundaryCrossing } from './GroupBoundaryCrossing';\nimport { PointAndCrossingsList } from './PointAndCrossingsList';\nimport { PointComparer } from './PointComparer';\n// A Group is a Shape that has children.\n// This class maps between intersection points on Group boundaries and the groups and crossing\n// directions at those intersection points.\nexport class GroupBoundaryCrossingMap {\n    constructor() {\n        // Note:  Like VisibilityGraph, this does not use PointComparer but assumes already-rounded key values.\n        this.pointCrossingMap = new PointMap();\n        this.pointList = new Array();\n    }\n    AddIntersection(intersection, group, dirToInside) {\n        let crossings = this.pointCrossingMap.get(intersection);\n        if (!crossings) {\n            crossings = new Array();\n            this.pointCrossingMap.set(intersection, crossings);\n        }\n        // We may hit the same point on neighbor traversal in multiple directions.  We will have more than one item\n        // in this list only if there are multiple group boundaries at this point, which should be unusual.\n        const crossingsCount = crossings.length;\n        // cache for perf\n        for (let ii = 0; ii < crossingsCount; ii++) {\n            const crossing = crossings[ii];\n            if (crossing.Group === group) {\n                // At a given location for a given group, there is only one valid dirToInside.\n                /*Assert.assert(\n                  dirToInside === crossing.DirectionToInside,\n                  'Mismatched dirToInside',\n                )*/\n                return crossing;\n            }\n        }\n        const newCrossing = new GroupBoundaryCrossing(group, dirToInside);\n        crossings.push(newCrossing);\n        return newCrossing;\n    }\n    Clear() {\n        this.pointCrossingMap.clear();\n    }\n    GetOrderedListBetween(start, end) {\n        if (this.pointCrossingMap.size === 0) {\n            return null;\n        }\n        if (PointComparer.ComparePP(start, end) > 0) {\n            const temp = start;\n            start = end;\n            end = temp;\n        }\n        // Start and end are inclusive.\n        this.pointList = [];\n        for (const intersection of this.pointCrossingMap.keys()) {\n            if (PointComparer.ComparePP(intersection, start) >= 0 && PointComparer.ComparePP(intersection, end) <= 0) {\n                this.pointList.push(intersection);\n            }\n        }\n        this.pointList.sort((a, b) => a.compareTo(b));\n        const pointAndCrossingList = new PointAndCrossingsList();\n        const numCrossings = this.pointList.length;\n        for (let ii = 0; ii < numCrossings; ii++) {\n            const intersect = this.pointList[ii];\n            pointAndCrossingList.Add(intersect, this.pointCrossingMap.get(intersect));\n        }\n        return pointAndCrossingList;\n    }\n    toString() {\n        return String.Format('{0}', this.pointCrossingMap.size);\n    }\n}\n//# sourceMappingURL=GroupBoundaryCrossingMap.js.map","import { BasicReflectionEvent } from './basicReflectionEvent';\nexport class HighReflectionEvent extends BasicReflectionEvent {\n    constructor(previousSite, targetSide, site) {\n        super(previousSite.ReflectingObstacle, targetSide.Obstacle, site);\n        this.Side = targetSide;\n    }\n}\n//# sourceMappingURL=HighReflectionEvent.js.map","// For lookahead points, we record the point of the intersection on the reflecting side, then\n// whenever we load a side, we check for active lookahead lines within this range.  Since we\n// are just intersecting rays, we only care about the X (H scan) or Y (V scan) coordinate.\nimport { RBTree } from '../../math/RBTree/rbTree';\nexport class LookaheadScan {\n    constructor(scanDir) {\n        this.staleSites = new Array();\n        this.scanDirection = scanDir;\n        this.eventTree = new RBTree((a, b) => this.CompareBB(a, b));\n        this.findFirstPred = (n) => this.CompareToFindFirstPoint(n.Site) >= 0;\n    }\n    Add(initialSite) {\n        // Assert we can't find it - subsumption should have taken care of that.\n        /*Assert.assert(\n          this.Find(initialSite.Site) == null ,\n          'Should not add the same Lookahead coordinate twice',\n        )*/\n        this.eventTree.insert(initialSite);\n    }\n    // Buffer up the events that are known to be stale - that is, will never queued as events because the\n    // event-load intersection is the same as the site.\n    MarkStaleSite(siteEvent) {\n        this.staleSites.push(siteEvent);\n    }\n    RemoveStaleSites() {\n        const cSites = this.staleSites.length;\n        // for (;;) is faster than IEnumerator for Lists\n        if (cSites > 0) {\n            for (let ii = 0; ii < cSites; ii++) {\n                this.RemoveExact(this.staleSites[ii]);\n            }\n            this.staleSites = [];\n        }\n    }\n    RemoveSitesForFlatBottom(low, high) {\n        for (let node = this.FindFirstInRange(low, high); null != node; node = this.FindNextInRange(node, high)) {\n            this.MarkStaleSite(node.item);\n        }\n        this.RemoveStaleSites();\n    }\n    Find(site) {\n        return this.FindFirstInRange(site, site);\n    }\n    RemoveExact(initialSite) {\n        const node = this.eventTree.find(initialSite);\n        if (null != node) {\n            if (node.item.Site === initialSite.Site) {\n                this.eventTree.deleteNodeInternal(node);\n                return true;\n            }\n        }\n        return false;\n    }\n    FindFirstInRange(low, high) {\n        // We only use FindFirstPoint in this routine, to find the first satisfying node,\n        // so we don't care that we leave leftovers in it.\n        this.findFirstPoint = low;\n        const nextNode = this.eventTree.findFirst(this.findFirstPred);\n        if (null != nextNode) {\n            // It's >= low; is it <= high?\n            if (this.Compare(nextNode.item.Site, high) <= 0) {\n                return nextNode;\n            }\n        }\n        return null;\n    }\n    CompareToFindFirstPoint(treeItem) {\n        return this.Compare(treeItem, this.findFirstPoint);\n    }\n    FindNextInRange(prev, high) {\n        const nextNode = this.eventTree.next(prev);\n        if (null != nextNode && this.Compare(nextNode.item.Site, high) <= 0) {\n            return nextNode;\n        }\n        return null;\n    }\n    // For ordering Points in the lookahead list.  We just care about the coordinate that changes\n    // parallel to the scanline, so for vertical sweep (sweeping up from bottom, scanning\n    // horizontally) then order points by X only, else by Y only.\n    CompareBB(lhs, rhs) {\n        return this.scanDirection.CompareScanCoord(lhs.Site, rhs.Site);\n    }\n    Compare(lhs, rhs) {\n        return this.scanDirection.CompareScanCoord(lhs, rhs);\n    }\n}\n//# sourceMappingURL=LookaheadScan.js.map","import { BasicReflectionEvent } from './basicReflectionEvent';\nexport class LowReflectionEvent extends BasicReflectionEvent {\n    constructor(previousSite, targetSide, site) {\n        super(previousSite.ReflectingObstacle, targetSide.obstacle, site);\n        this.Side = targetSide;\n    }\n}\n//# sourceMappingURL=LowReflectionEvent.js.map","import { BasicVertexEvent } from './BasicVertexEvent';\nexport class LowBendVertexEvent extends BasicVertexEvent {\n    constructor(obstacle, p) {\n        super(obstacle, p);\n    }\n}\nexport class HighBendVertexEvent extends BasicVertexEvent {\n    constructor(obstacle, p) {\n        super(obstacle, p);\n    }\n}\nexport class CloseVertexEvent extends BasicVertexEvent {\n    constructor(obstacle, p) {\n        super(obstacle, p);\n    }\n}\n//# sourceMappingURL=MiscVertexEvents.js.map","import { Point } from '../../math/geometry/point';\nimport { closeDistEps } from '../../utils/compare';\nimport { ScanSegment } from './ScanSegment';\nimport { SsstRectilinearPath } from './SsstRectilinearPath';\nexport class MsmtRectilinearPath {\n    constructor(bendPenalty) {\n        this.bendPenaltyAsAPercentageOfDistance = SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance;\n        // Temporary for accumulating target entries.\n        this.currentPassTargetEntries = new Array(4);\n        this.bendPenaltyAsAPercentageOfDistance = bendPenalty;\n    }\n    // Get the lowest-cost path from one of one or more sources to one of one or more targets, without waypoints.\n    // One or more source vertices\n    // One or more target vertices\n    // <returns>A single enumeration of path points.</returns>\n    GetPath(sources, targets) {\n        const t = { entry: this.GetPathStage(null, sources, null, targets) };\n        return SsstRectilinearPath.RestorePathV(t);\n    }\n    // Route a single stage of a possibly multi-stage (due to waypoints) path.\n    // The VertexEntry array that was in the source vertex if it was the target of a prior stage.\n    // The enumeration of source vertices; must be only one if sourceVertexEntries is non-null.\n    // The enumeration of target vertex entries; must be only one if targetVertexEntries is non-null.\n    // The VertexEntry array that is in the target at the end of the stage.\n    GetPathStage(sourceVertexEntries, sources, targetVertexEntries, targets) {\n        const ssstCalculator = new SsstRectilinearPath();\n        const t = {\n            bestEntry: null,\n            // This contains the best (lowest) path cost after normalizing origins to the center of the sources\n            // and targets.  This is used to avoid selecting a vertex pair whose path has more bends than another pair of\n            // vertices, but the bend penalty didn't total enough to offset the additional length between the \"better\" pair.\n            // This also plays the role of an upper bound on the path length; if a path cost is greater than adjustedMinCost\n            // then we stop exploring it, which saves considerable time after low-cost paths have been found.\n            bestCost: Number.MAX_VALUE / ScanSegment.OverlappedWeight,\n        };\n        let bestPathCostRatio = Number.POSITIVE_INFINITY;\n        // Calculate the bend penalty multiplier.  This is a percentage of the distance between the source and target,\n        // so that we have the same relative importance if we have objects of about size 20 that are about 100 apart\n        // as for objects of about size 200 that are about 1000 apart.\n        const sourceCenter = MsmtRectilinearPath.Barycenter(sources);\n        const targetCenter = MsmtRectilinearPath.Barycenter(targets);\n        const distance = SsstRectilinearPath.ManhattanDistance(sourceCenter, targetCenter);\n        ssstCalculator.BendsImportance = Math.max(0.001, distance * (this.bendPenaltyAsAPercentageOfDistance * 0.01));\n        // We'll normalize by adding (a proportion of) the distance (only; not bends) from the current endpoints to\n        // their centers. This is similar to routeToCenter, but routing multiple paths like this means we'll always\n        // get at least a tie for the best vertex pair, whereas routeToCenter can introduce extraneous bends\n        // if the sources/targets are not collinear with the center (such as an E-R diagram).\n        // interiorLengthAdjustment is a way to decrease the cost adjustment slightly to allow a bend if it saves moving\n        // a certain proportion of the distance parallel to the object before turning to it.\n        const interiorLengthAdjustment = ssstCalculator.LengthImportance;\n        // VertexEntries for the current pass of the current stage, if multistage.\n        const tempTargetEntries = targetVertexEntries != null ? this.currentPassTargetEntries : null;\n        // Process closest pairs first, so we can skip longer ones (jump out of SsstRectilinear sooner, often immediately).\n        // This means that we'll be consistent on tiebreaking for equal scores with differing bend counts (the shorter\n        // path will win).  In overlapped graphs the shortest path may have more higher-weight edges.\n        const stPairs = [];\n        for (const s of sources)\n            for (const t of targets)\n                stPairs.push([s, t]);\n        stPairs.sort(([a, b], [c, d]) => md(a, b) - md(c, d));\n        for (const [sv, tv] of stPairs) {\n            if (Point.closeDistEps(sv.point, tv.point)) {\n                continue;\n            }\n            const sourceCostAdjustment = mdP(sv, sourceCenter) * interiorLengthAdjustment;\n            const targetCostAdjustment = mdP(tv, targetCenter) * interiorLengthAdjustment;\n            let adjustedBestCost = t.bestCost;\n            if (targetVertexEntries != null) {\n                for (let i = 0; i < tempTargetEntries.length; i++) {\n                    tempTargetEntries[i] = null;\n                }\n                adjustedBestCost = ssstCalculator.MultistageAdjustedCostBound(t.bestCost);\n            }\n            const lastEntry = ssstCalculator.GetPathWithCost(sourceVertexEntries, sv, sourceCostAdjustment, tempTargetEntries, tv, targetCostAdjustment, adjustedBestCost);\n            if (tempTargetEntries != null) {\n                MsmtRectilinearPath.UpdateTargetEntriesForEachDirection(targetVertexEntries, tempTargetEntries, t);\n                continue;\n            }\n            // This is the final (or only) stage. Break ties by picking the lowest ratio of cost to ManhattanDistance between the endpoints.\n            if (lastEntry == null) {\n                continue;\n            }\n            const costRatio = lastEntry.Cost / md(sv, tv);\n            if (lastEntry.Cost < t.bestCost || (closeDistEps(lastEntry.Cost, t.bestCost) && costRatio < bestPathCostRatio)) {\n                t.bestCost = lastEntry.Cost;\n                t.bestEntry = lastEntry;\n                bestPathCostRatio = lastEntry.Cost / md(sv, tv);\n            }\n        }\n        return t.bestEntry;\n        function md(s, t) {\n            return SsstRectilinearPath.ManhattanDistance(s.point, t.point);\n        }\n        function mdP(s, t) {\n            return SsstRectilinearPath.ManhattanDistance(s.point, t);\n        }\n    }\n    static UpdateTargetEntriesForEachDirection(targetVertexEntries, tempTargetEntries, t) {\n        for (let ii = 0; ii < tempTargetEntries.length; ii++) {\n            const tempEntry = tempTargetEntries[ii];\n            if (tempEntry == null) {\n                continue;\n            }\n            if (targetVertexEntries[ii] == null || tempEntry.Cost < targetVertexEntries[ii].Cost) {\n                targetVertexEntries[ii] = tempEntry;\n                if (tempEntry.Cost < t.bestCost) {\n                    // This does not have the ratio tiebreaker because the individual stage path is only used as a success indicator.\n                    t.bestCost = tempEntry.Cost;\n                    t.bestEntry = tempEntry;\n                }\n            }\n        }\n        return;\n    }\n    static Barycenter(vertices) {\n        let center = new Point(0, 0);\n        for (const vertex of vertices) {\n            center = center.add(vertex.point);\n        }\n        return center.div(vertices.length);\n    }\n}\n//# sourceMappingURL=MsmtRectilinearPath.js.map","import { StaticGraphUtility } from './StaticGraphUtility';\nexport class NeighborSides {\n    // Dereferences the node if non-null to return the side Item.\n    get LowNeighborSide() {\n        return this.LowNeighbor == null ? null : this.LowNeighbor.item;\n    }\n    // Dereferences the node if non-null to return the side Item.\n    get HighNeighborSide() {\n        return this.HighNeighbor == null ? null : this.HighNeighbor.item;\n    }\n    Clear() {\n        this.LowNeighbor = null;\n        this.LowOverlapEnd = null;\n        this.GroupSideInterveningBeforeLowNeighbor = null;\n        this.HighNeighbor = null;\n        this.HighOverlapEnd = null;\n        this.GroupSideInterveningBeforeHighNeighbor = null;\n    }\n    SetSides(dir, neighborNode, overlapEndNode, interveningGroupSide) {\n        if (StaticGraphUtility.IsAscending(dir)) {\n            this.HighNeighbor = neighborNode;\n            this.HighOverlapEnd = overlapEndNode;\n            this.GroupSideInterveningBeforeHighNeighbor = interveningGroupSide;\n            return;\n        }\n        this.LowNeighbor = neighborNode;\n        this.LowOverlapEnd = overlapEndNode;\n        this.GroupSideInterveningBeforeLowNeighbor = interveningGroupSide;\n    }\n}\n//# sourceMappingURL=NeighborSides.js.map","import { Point, Rectangle } from '../../math/geometry';\nimport { ObstaclePortEntrance } from './ObstaclePortEntrance';\nexport class ObstaclePort {\n    constructor(port, obstacle) {\n        this.HasCollinearEntrances = false;\n        this.VisibilityRectangle = Rectangle.mkEmpty();\n        this.Port = port;\n        this.Obstacle = obstacle;\n        this.PortEntrances = new Array();\n        this.Location = Point.RoundPoint(this.Port.Location);\n    }\n    CreatePortEntrance(unpaddedBorderIntersect, outDir, obstacleTree) {\n        const entrance = new ObstaclePortEntrance(this, unpaddedBorderIntersect, outDir, obstacleTree);\n        this.PortEntrances.push(entrance);\n        this.VisibilityRectangle.add(entrance.MaxVisibilitySegment.end);\n        this.HasCollinearEntrances = this.HasCollinearEntrances || entrance.IsCollinearWithPort;\n    }\n    ClearVisibility() {\n        // Most of the retained PortEntrance stuff is about precalculated visibility.\n        this.PortEntrances = [];\n    }\n    AddToGraph(transUtil, routeToCenter) {\n        // We use only border vertices if !routeToCenter.\n        if (routeToCenter) {\n            this.CenterVertex = transUtil.FindOrAddVertex(this.Location);\n        }\n    }\n    RemoveFromGraph() {\n        this.CenterVertex = null;\n    }\n    // PortManager will recreate the Port if it detects this (this.Location has already been rounded).\n    get LocationHasChanged() {\n        return !Point.closeDistEps(this.Location, Point.RoundPoint(this.Port.Location));\n    }\n    // The curve associated with the port.\n    get PortCurve() {\n        return this.Port.Curve;\n    }\n    // The (unrounded) location of the port.\n    get PortLocation() {\n        return this.Port.Location;\n    }\n    toString() {\n        return this.Port + this.Obstacle.toString();\n    }\n}\n//# sourceMappingURL=ObstaclePort.js.map","import { String } from 'typescript-string-operations';\nimport { Point, Rectangle, CompassVector, Curve, PointLocation, Direction, LineSegment } from '../../math/geometry';\nimport { PointComparer } from './PointComparer';\nimport { ScanDirection } from './ScanDirection';\nimport { ScanSegment } from './ScanSegment';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nexport class ObstaclePortEntrance {\n    get Obstacle() {\n        return this.ObstaclePort.Obstacle;\n    }\n    get InitialWeight() {\n        return this.IsOverlapped ? ScanSegment.OverlappedWeight : ScanSegment.NormalWeight;\n    }\n    get IsCollinearWithPort() {\n        return CompassVector.IsPureDirection(PointComparer.GetDirections(this.VisibilityBorderIntersect, this.ObstaclePort.Location));\n    }\n    get IsVertical() {\n        return StaticGraphUtility.IsVertical(this.MaxVisibilitySegment);\n    }\n    // If the port has entrances that are collinear, don't do the optimization for non-collinear ones.\n    get WantVisibilityIntersection() {\n        return !this.IsOverlapped && this.CanExtend && (!this.ObstaclePort.HasCollinearEntrances || this.IsCollinearWithPort);\n    }\n    get CanExtend() {\n        return PointComparer.GetDirections(this.MaxVisibilitySegment.start, this.MaxVisibilitySegment.end) !== Direction.None;\n    }\n    constructor(oport, unpaddedBorderIntersect, outDir, obstacleTree) {\n        this.IsOverlapped = false;\n        this.unpaddedToPaddedBorderWeight = ScanSegment.NormalWeight;\n        this.ObstaclePort = oport;\n        this.UnpaddedBorderIntersect = unpaddedBorderIntersect;\n        this.OutwardDirection = outDir;\n        // Get the padded intersection.\n        const lineSeg = LineSegment.mkPP(this.UnpaddedBorderIntersect, StaticGraphUtility.RectangleBorderIntersect(oport.Obstacle.VisibilityBoundingBox, this.UnpaddedBorderIntersect, outDir));\n        const xxs = Curve.getAllIntersections(lineSeg, oport.Obstacle.VisibilityPolyline, true);\n        /*Assert.assert(1 === xxs.length, 'Expected one intersection')*/\n        this.VisibilityBorderIntersect = Point.RoundPoint(xxs[0].x);\n        const t = { pacList: null };\n        this.MaxVisibilitySegment = obstacleTree.CreateMaxVisibilitySegment(this.VisibilityBorderIntersect, this.OutwardDirection, t);\n        this.pointAndCrossingsList = t.pacList;\n        // Groups are never in a clump (overlapped) but they may still have their port entrance overlapped.\n        if (this.Obstacle.isOverlapped || (this.Obstacle.IsGroup && !this.Obstacle.IsInConvexHull)) {\n            this.IsOverlapped = obstacleTree.IntersectionIsInsideAnotherObstacle(null, this.Obstacle, this.VisibilityBorderIntersect, ScanDirection.GetInstance(this.OutwardDirection));\n            if (!this.Obstacle.IsGroup || this.IsOverlapped || this.InteriorEdgeCrossesObstacle(obstacleTree)) {\n                this.unpaddedToPaddedBorderWeight = ScanSegment.OverlappedWeight;\n            }\n        }\n        if (this.Obstacle.IsInConvexHull && this.unpaddedToPaddedBorderWeight === ScanSegment.NormalWeight) {\n            this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(obstacleTree);\n        }\n    }\n    SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(obstacleTree) {\n        if (this.Obstacle.IsGroup ? this.InteriorEdgeCrossesObstacle(obstacleTree) : this.InteriorEdgeCrossesConvexHullSiblings()) {\n            this.unpaddedToPaddedBorderWeight = ScanSegment.OverlappedWeight;\n        }\n    }\n    InteriorEdgeCrossesObstacle(obstacleTree) {\n        // File Test: Nudger_Overlap4\n        // Use the VisibilityBoundingBox for groups because those are what the tree consists of.\n        const rect = Rectangle.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);\n        return this.InteriorEdgeCrossesObstacleRFI(rect, (obs) => obs.VisibilityPolyline, Array.from(obstacleTree.Root.GetLeafRectangleNodesIntersectingRectangle(rect))\n            .filter((node) => !node.UserData.IsGroup && node.UserData !== this.Obstacle)\n            .map((node) => node.UserData));\n    }\n    InteriorEdgeCrossesConvexHullSiblings() {\n        // There is no RectangleNode tree that includes convex hull non-primary siblings, so we just iterate;\n        // this will only be significant to perf in extremely overlapped cases that we are not optimizing for.\n        const rect = Rectangle.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);\n        return this.InteriorEdgeCrossesObstacleRFI(rect, (obs) => obs.PaddedPolyline, this.Obstacle.ConvexHull.Obstacles.filter((obs) => obs !== this.Obstacle));\n    }\n    InteriorEdgeCrossesObstacleRFI(rect, whichPolylineToUse, candidates) {\n        let lineSeg = null;\n        for (const blocker of candidates) {\n            const blockerPolyline = whichPolylineToUse(blocker);\n            if (!StaticGraphUtility.RectangleInteriorsIntersect(rect, blockerPolyline.boundingBox)) {\n                continue;\n            }\n            lineSeg = lineSeg !== null && lineSeg !== void 0 ? lineSeg : LineSegment.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);\n            const xx = Curve.intersectionOne(lineSeg, blockerPolyline, /* liftIntersection:*/ false);\n            if (xx != null) {\n                return true;\n            }\n            if (PointLocation.Outside !== Curve.PointRelativeToCurveLocation(this.UnpaddedBorderIntersect, blockerPolyline)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    get HasGroupCrossings() {\n        return this.pointAndCrossingsList != null && this.pointAndCrossingsList.Count() > 0;\n    }\n    HasGroupCrossingBeforePoint(point) {\n        if (!this.HasGroupCrossings) {\n            return false;\n        }\n        const pac = StaticGraphUtility.IsAscending(this.OutwardDirection) ? this.pointAndCrossingsList.First : this.pointAndCrossingsList.Last;\n        return PointComparer.GetDirections(this.MaxVisibilitySegment.start, pac.Location) === PointComparer.GetDirections(pac.Location, point);\n    }\n    AddToAdjacentVertex(transUtil, targetVertex, limitRect, routeToCenter) {\n        let borderVertex = transUtil.VisGraph.FindVertex(this.VisibilityBorderIntersect);\n        if (borderVertex != null) {\n            this.ExtendEdgeChain(transUtil, borderVertex, borderVertex, limitRect, routeToCenter);\n            return;\n        }\n        // There is no vertex at VisibilityBorderIntersect, so create it and link it to targetVertex.\n        // Note: VisibilityBorderIntersect may === targetIntersect if that is on our border, *and*\n        // targetIntersect may be on the border of a touching obstacle, in which case this will splice\n        // into or across the adjacent obstacle, which is consistent with \"touching is overlapped\".\n        // So we don't use UnpaddedBorderIntersect as prevPoint when calling ExtendEdgeChain.\n        // VisibilityBorderIntersect may be rounded just one Curve.DistanceEpsilon beyond the ScanSegment's\n        // perpendicular coordinate; e.g. our X may be targetIntersect.X + Curve.DistanceEpsilon, thereby\n        // causing the direction from VisibilityBorderIntersect to targetIntersect to be W instead of E.\n        // So use the targetIntersect if they are close enough; they will be equal for flat borders, and\n        // otherwise the exact value we use only needs be \"close enough\" to the border.  (We can't use\n        // CenterVertex as the prevPoint because that could be an impure direction).\n        // Update: With the change to carry MaxVisibilitySegment within the PortEntrance, PortManager finds\n        // targetVertex between VisibilityBorderIntersect and MaxVisibilitySegment.End, so this should no longer\n        // be able to happen.\n        // See RectilinearTests.PaddedBorderIntersectMeetsIncomingScanSegment for an example of what happens\n        // when VisibilityBorderIntersect is on the incoming ScanSegment (it jumps out above with borderVertex found).\n        if (this.OutwardDirection === PointComparer.GetDirections(targetVertex.point, this.VisibilityBorderIntersect)) {\n            /*Assert.assert(\n              false,\n              'Unexpected reversed direction between VisibilityBorderIntersect and targetVertex',\n            )*/\n            // ReSharper disable HeuristicUnreachableCode\n            this.VisibilityBorderIntersect = targetVertex.point;\n            borderVertex = targetVertex;\n            // ReSharper restore HeuristicUnreachableCode\n        }\n        else {\n            borderVertex = transUtil.FindOrAddVertex(this.VisibilityBorderIntersect);\n            transUtil.FindOrAddEdge(borderVertex, targetVertex, this.InitialWeight);\n        }\n        this.ExtendEdgeChain(transUtil, borderVertex, targetVertex, limitRect, routeToCenter);\n    }\n    ExtendEdgeChain(transUtil, paddedBorderVertex, targetVertex, limitRect, routeToCenter) {\n        // Extend the edge chain to the opposite side of the limit rectangle.\n        transUtil.ExtendEdgeChainVRLPB(targetVertex, limitRect, this.MaxVisibilitySegment, this.pointAndCrossingsList, this.IsOverlapped);\n        // In order for Nudger to be able to map from the (near-) endpoint vertex to a PortEntry, we must\n        // always connect a vertex at UnpaddedBorderIntersect to the paddedBorderVertex, even if routeToCenter.\n        const unpaddedBorderVertex = transUtil.FindOrAddVertex(this.UnpaddedBorderIntersect);\n        transUtil.FindOrAddEdge(unpaddedBorderVertex, paddedBorderVertex, this.unpaddedToPaddedBorderWeight);\n        if (routeToCenter) {\n            // Link the CenterVertex to the vertex at UnpaddedBorderIntersect.\n            transUtil.ConnectVertexToTargetVertex(this.ObstaclePort.CenterVertex, unpaddedBorderVertex, this.OutwardDirection, this.InitialWeight);\n        }\n    }\n    toString() {\n        return String.Format('{0} {1}~{2} {3}', this.ObstaclePort.Location, this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect, this.OutwardDirection);\n    }\n}\n//# sourceMappingURL=ObstaclePortEntrance.js.map","import { Point } from '../..';\nimport { Curve, PointLocation, Direction, LineSegment, GeomConstants, CompassVector } from '../../math/geometry';\nimport { ConvexHull } from '../../math/geometry/convexHull';\nimport { HitTestBehavior } from '../../math/geometry/RTree/hitTestBehavior';\nimport { mkRectangleNode, CreateRectNodeOnArrayOfRectNodes } from '../../math/geometry/RTree/rectangleNode';\nimport { CrossRectangleNodesSameType, CrossRectangleNodes } from '../../math/geometry/RTree/rectangleNodeUtils';\nimport { GetConnectedComponents } from '../../math/graphAlgorithms/ConnectedComponentCalculator';\nimport { mkGraphOnEdges } from '../../structs/basicGraphOnEdges';\nimport { closeDistEps } from '../../utils/compare';\nimport { IntPair } from '../../utils/IntPair';\nimport { IntPairSet } from '../../utils/IntPairSet';\nimport { flattenArray } from '../../utils/setOperations';\nimport { GroupBoundaryCrossingMap } from './GroupBoundaryCrossingMap';\nimport { Obstacle } from './obstacle';\nimport { OverlapConvexHull } from './OverlapConvexHull';\nimport { PointComparer } from './PointComparer';\nimport { ScanDirection } from './ScanDirection';\nimport { SpliceUtility } from './SpliceUtility';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nexport class ObstacleTree {\n    constructor() {\n        // // The map of all group boundary crossings for the current RestrictSegmentWithObstacles call.\n        this.CurrentGroupBoundaryCrossingMap = new GroupBoundaryCrossingMap();\n        // For accreting obstacles for clumps or convex hulls.\n        this.overlapPairs = new IntPairSet();\n        // Indicates whether one or more obstacles overlap.\n        this.hasOverlaps = false;\n        // Member to avoid unnecessary class creation just to do a lookup.\n        this.lookupIntPair = new IntPair(-1, -1);\n    }\n    get GraphBox() {\n        return this.Root.irect;\n    }\n    //Create the tree hierarchy from the enumeration.\n    Init(obstacles, ancestorSets, idToObstacleMap) {\n        this.CreateObstacleListAndOrdinals(obstacles);\n        this.AncestorSets = ancestorSets;\n        this.CreateRoot();\n        this.shapeIdToObstacleMap = idToObstacleMap;\n    }\n    CreateObstacleListAndOrdinals(obstacles) {\n        this.allObstacles = Array.from(obstacles);\n        let scanlineOrdinal = Obstacle.FirstNonSentinelOrdinal;\n        for (const obstacle of this.allObstacles) {\n            obstacle.Ordinal = scanlineOrdinal++;\n        }\n    }\n    OrdinalToObstacle(index) {\n        /*Assert.assert(index >= Obstacle.FirstNonSentinelOrdinal, 'index too small')*/\n        /*Assert.assert(\n          index < this.allObstacles.length + Obstacle.FirstNonSentinelOrdinal,\n          'index too large',\n        )*/\n        return this.allObstacles[index - Obstacle.FirstNonSentinelOrdinal];\n    }\n    // Create the root with overlapping non-rectangular obstacles converted to their convex hulls, for more reliable calculations.\n    CreateRoot() {\n        this.Root = ObstacleTree.CalculateHierarchy(this.GetAllObstacles());\n        if (!this.OverlapsExist()) {\n            return;\n        }\n        this.AccreteClumps();\n        this.AccreteConvexHulls();\n        this.GrowGroupsToAccommodateOverlaps();\n        this.Root = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => obs.IsPrimaryObstacle));\n    }\n    OverlapsExist() {\n        if (this.Root == null) {\n            return false;\n        }\n        CrossRectangleNodesSameType(this.Root, this.Root, (a, b) => this.CheckForInitialOverlaps(a, b));\n        return this.hasOverlaps;\n    }\n    OverlapPairAlreadyFound(a, b) {\n        // If we already found it then we'll have enqueued it in the reverse order.\n        this.lookupIntPair.x = b.Ordinal;\n        this.lookupIntPair.y = a.Ordinal;\n        return this.overlapPairs.has(this.lookupIntPair);\n    }\n    CheckForInitialOverlaps(a, b) {\n        if (this.hasOverlaps) {\n            return;\n        }\n        const t = { bIsInsideA: false, aIsInsideB: false };\n        if (ObstacleTree.ObstaclesIntersect(a, b, t)) {\n            this.hasOverlaps = true;\n            return;\n        }\n        if (!t.aIsInsideB && !t.bIsInsideA) {\n            return;\n        }\n        // One obstacle is inside the other.  If they're both groups, or a non-group is inside a group, nothing\n        // further is needed; we process groups differently because we can go through their sides.\n        if (a.IsGroup && b.IsGroup) {\n            return;\n        }\n        if ((a.IsGroup && t.bIsInsideA) || (b.IsGroup && t.aIsInsideB)) {\n            return;\n        }\n        this.hasOverlaps = true;\n    }\n    AccreteClumps() {\n        // Clumps are only created once.  After that, as the result of convex hull creation, we may\n        // overlap an obstacle of a clump, in which case we enclose the clump in the convex hull as well.\n        // We only allow clumps of rectangular obstacles, to avoid angled sides in the scanline.\n        this.AccumulateObstaclesForClumps();\n        this.CreateClumps();\n    }\n    AccreteConvexHulls() {\n        // Convex-hull creation is transitive, because the created hull may overlap additional obstacles.\n        for (;;) {\n            this.AccumulateObstaclesForConvexHulls();\n            if (!this.CreateConvexHulls()) {\n                return;\n            }\n        }\n    }\n    static CalculateHierarchy(obstacles) {\n        const rectNodes = Array.from(obstacles).map((obs) => mkRectangleNode(obs, obs.VisibilityBoundingBox));\n        return CreateRectNodeOnArrayOfRectNodes(rectNodes);\n    }\n    AccumulateObstaclesForClumps() {\n        this.overlapPairs.clear();\n        const rectangularObstacles = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => !obs.IsGroup && obs.IsRectangle));\n        if (rectangularObstacles == null) {\n            return;\n        }\n        CrossRectangleNodes(rectangularObstacles, rectangularObstacles, (a, b) => this.EvaluateOverlappedPairForClump(a, b));\n    }\n    EvaluateOverlappedPairForClump(a, b) {\n        /*Assert.assert(!a.IsGroup && !b.IsGroup, 'Groups should not come here')*/\n        /*Assert.assert(\n          a.IsRectangle && b.IsRectangle,\n          'Only rectangles should come here',\n        )*/\n        if (a === b || this.OverlapPairAlreadyFound(a, b)) {\n            return;\n        }\n        const t = { bIsInsideA: false, aIsInsideB: false };\n        if (!ObstacleTree.ObstaclesIntersect(a, b, t) && !t.aIsInsideB && !t.bIsInsideA) {\n            return;\n        }\n        this.overlapPairs.add(new IntPair(a.Ordinal, b.Ordinal));\n    }\n    AccumulateObstaclesForConvexHulls() {\n        this.overlapPairs.clear();\n        const allPrimaryNonGroupObstacles = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => obs.IsPrimaryObstacle && !obs.IsGroup));\n        if (allPrimaryNonGroupObstacles == null) {\n            return;\n        }\n        CrossRectangleNodes(allPrimaryNonGroupObstacles, allPrimaryNonGroupObstacles, (a, b) => this.EvaluateOverlappedPairForConvexHull(a, b));\n    }\n    EvaluateOverlappedPairForConvexHull(a, b) {\n        /*Assert.assert(!a.IsGroup && !b.IsGroup, 'Groups should not come here')*/\n        if (a === b || this.OverlapPairAlreadyFound(a, b)) {\n            return;\n        }\n        const t = { bIsInsideA: false, aIsInsideB: false };\n        if (!ObstacleTree.ObstaclesIntersect(a, b, t) && !t.aIsInsideB && !t.bIsInsideA) {\n            return;\n        }\n        // If either is in a convex hull, those must be coalesced.\n        if (!a.IsInConvexHull && !b.IsInConvexHull) {\n            // If the obstacles are rectangles, we don't need to do anything (for this pair).\n            if (a.IsRectangle && b.IsRectangle) {\n                return;\n            }\n        }\n        this.overlapPairs.add(new IntPair(a.Ordinal, b.Ordinal));\n        this.AddClumpToConvexHull(a);\n        this.AddClumpToConvexHull(b);\n        this.AddConvexHullToConvexHull(a);\n        this.AddConvexHullToConvexHull(b);\n    }\n    GrowGroupsToAccommodateOverlaps() {\n        // Group growth is transitive, because the created hull may overlap additional obstacles.\n        for (;;) {\n            this.AccumulateObstaclesForGroupOverlaps();\n            if (!this.GrowGroupsToResolveOverlaps()) {\n                return;\n            }\n        }\n    }\n    AccumulateObstaclesForGroupOverlaps() {\n        const groupObstacles = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => obs.IsGroup));\n        const allPrimaryObstacles = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => obs.IsPrimaryObstacle));\n        if (groupObstacles == null || allPrimaryObstacles == null) {\n            return;\n        }\n        CrossRectangleNodes(groupObstacles, allPrimaryObstacles, (a, b) => this.EvaluateOverlappedPairForGroup(a, b));\n    }\n    EvaluateOverlappedPairForGroup(a, b) {\n        /*Assert.assert(a.IsGroup, 'Inconsistency in overlapping group enumeration')*/\n        if (a === b || this.OverlapPairAlreadyFound(a, b)) {\n            return;\n        }\n        const t = { bIsInsideA: false, aIsInsideB: false };\n        const curvesIntersect = ObstacleTree.ObstaclesIntersect(a, b, t);\n        if (!curvesIntersect && !t.aIsInsideB && !t.bIsInsideA) {\n            return;\n        }\n        if (a.IsRectangle && b.IsRectangle) {\n            // If these are already rectangles, we don't need to do anything here.  Non-group VisibilityPolylines\n            // will not change by the group operations; we'll just grow the group if needed (if it is already\n            // nonrectangular, either because it came in that way or because it has intersected a non-rectangle).\n            // However, SparseVg needs to know about the overlap so it will create interior scansegments if the\n            // obstacle is not otherwise overlapped.\n            if (!b.IsGroup) {\n                if (t.aIsInsideB || ObstacleTree.FirstRectangleContainsACornerOfTheOther(b.VisibilityBoundingBox, a.VisibilityBoundingBox)) {\n                    b.OverlapsGroupCorner = true;\n                }\n            }\n            return;\n        }\n        if (!curvesIntersect) {\n            // If the borders don't intersect, we don't need to do anything if both are groups or the\n            // obstacle or convex hull is inside the group.  Otherwise we have to grow group a to encompass b.\n            if (b.IsGroup || t.bIsInsideA) {\n                return;\n            }\n        }\n        this.overlapPairs.add(new IntPair(a.Ordinal, b.Ordinal));\n    }\n    static FirstRectangleContainsACornerOfTheOther(a, b) {\n        return a.contains(b.leftBottom) || a.contains(b.leftTop) || a.contains(b.rightTop) || a.contains(b.rightBottom);\n    }\n    static FirstPolylineStartIsInsideSecondPolyline(first, second) {\n        return Curve.PointRelativeToCurveLocation(first.start, second) !== PointLocation.Outside;\n    }\n    AddClumpToConvexHull(obstacle) {\n        if (obstacle.isOverlapped) {\n            for (const sibling of obstacle.clump.filter((sib) => sib.Ordinal !== obstacle.Ordinal)) {\n                this.overlapPairs.add(new IntPair(obstacle.Ordinal, sibling.Ordinal));\n            }\n            // Clear this now so any overlaps with other obstacles in the clump won't doubly insert.\n            obstacle.clump = [];\n        }\n    }\n    AddConvexHullToConvexHull(obstacle) {\n        if (obstacle.IsInConvexHull) {\n            for (const sibling of obstacle.ConvexHull.Obstacles.filter((sib) => sib.Ordinal !== obstacle.Ordinal)) {\n                this.overlapPairs.add(new IntPair(obstacle.Ordinal, sibling.Ordinal));\n            }\n            // Clear this now so any overlaps with other obstacles in the ConvexHull won't doubly insert.\n            obstacle.ConvexHull.Obstacles = [];\n        }\n    }\n    CreateClumps() {\n        const graph = mkGraphOnEdges(Array.from(this.overlapPairs.values()));\n        const connectedComponents = GetConnectedComponents(graph);\n        for (const component of connectedComponents) {\n            // GetComponents returns at least one self-entry for each index - including the < FirstNonSentinelOrdinal ones.\n            if (component.length === 1) {\n                continue;\n            }\n            const clump = component.map((i) => this.OrdinalToObstacle(i));\n            for (const obstacle of clump) {\n                obstacle.clump = clump;\n            }\n        }\n    }\n    CreateConvexHulls() {\n        let found = false;\n        const graph = mkGraphOnEdges(Array.from(this.overlapPairs.values()));\n        const connectedComponents = GetConnectedComponents(graph);\n        for (const component of connectedComponents) {\n            // GetComponents returns at least one self-entry for each index - including the < FirstNonSentinelOrdinal ones.\n            if (component.length === 1) {\n                continue;\n            }\n            found = true;\n            const obstacles = component.map(this.OrdinalToObstacle);\n            const points = flattenArray(obstacles, (p) => p.VisibilityPolyline);\n            const och = new OverlapConvexHull(ConvexHull.createConvexHullAsClosedPolyline(points), obstacles);\n            for (const obstacle of obstacles) {\n                obstacle.SetConvexHull(och);\n            }\n        }\n        return found;\n    }\n    GrowGroupsToResolveOverlaps() {\n        // This is one-at-a-time so not terribly efficient but there should be a very small number of such overlaps, if any.\n        let found = false;\n        for (const pair of this.overlapPairs.values()) {\n            found = true;\n            const a = this.OrdinalToObstacle(pair.x);\n            const b = this.OrdinalToObstacle(pair.y);\n            if (!ObstacleTree.ResolveGroupAndGroupOverlap(a, b)) {\n                ObstacleTree.ResolveGroupAndObstacleOverlap(a, b);\n            }\n        }\n        this.overlapPairs.clear();\n        return found;\n    }\n    static ResolveGroupAndGroupOverlap(a, b) {\n        // For simplicity, pick the larger group and make grow its convex hull to encompass the smaller.\n        if (!b.IsGroup) {\n            return false;\n        }\n        if (a.VisibilityPolyline.boundingBox.area > b.VisibilityPolyline.boundingBox.area) {\n            ObstacleTree.ResolveGroupAndObstacleOverlap(a, b);\n        }\n        else {\n            ObstacleTree.ResolveGroupAndObstacleOverlap(b, a);\n        }\n        return true;\n    }\n    static ResolveGroupAndObstacleOverlap(group, obstacle) {\n        // Create a convex hull for the group which goes outside the obstacle (which may also be a group).\n        // It must go outside the obstacle so we don't have coinciding angled sides in the scanline.\n        let loosePolyline = obstacle.looseVisibilityPolyline;\n        ObstacleTree.GrowGroupAroundLoosePolyline(group, loosePolyline);\n        // Due to rounding we may still report this to be close or intersecting; grow it again if so.\n        const t = { bIsInsideA: false, aIsInsideB: false };\n        while (ObstacleTree.ObstaclesIntersect(obstacle, group, t) || !t.aIsInsideB) {\n            loosePolyline = Obstacle.CreateLoosePolyline(loosePolyline);\n            ObstacleTree.GrowGroupAroundLoosePolyline(group, loosePolyline);\n        }\n    }\n    static GrowGroupAroundLoosePolyline(group, loosePolyline) {\n        const points = Array.from(group.VisibilityPolyline).concat(Array.from(loosePolyline));\n        group.SetConvexHull(new OverlapConvexHull(ConvexHull.createConvexHullAsClosedPolyline(points), [group]));\n    }\n    static ObstaclesIntersect(a, b, t) {\n        if (Curve.CurvesIntersect(a.VisibilityPolyline, b.VisibilityPolyline)) {\n            t.aIsInsideB = false;\n            t.bIsInsideA = false;\n            return true;\n        }\n        t.aIsInsideB = ObstacleTree.FirstPolylineStartIsInsideSecondPolyline(a.VisibilityPolyline, b.VisibilityPolyline);\n        t.bIsInsideA = !t.aIsInsideB && ObstacleTree.FirstPolylineStartIsInsideSecondPolyline(b.VisibilityPolyline, a.VisibilityPolyline);\n        if (a.IsRectangle && b.IsRectangle) {\n            // Rectangles do not require further evaluation.\n            return false;\n        }\n        if (ObstacleTree.ObstaclesAreCloseEnoughToBeConsideredTouching(a, b, t.aIsInsideB, t.bIsInsideA)) {\n            t.aIsInsideB = false;\n            t.bIsInsideA = false;\n            return true;\n        }\n        return false;\n    }\n    static ObstaclesAreCloseEnoughToBeConsideredTouching(a, b, aIsInsideB, bIsInsideA) {\n        // This is only called when the obstacle.VisibilityPolylines don't intersect, thus one is inside the other\n        // or both are outside. If both are outside then either one's LooseVisibilityPolyline may be used.\n        if (!aIsInsideB && !bIsInsideA) {\n            return Curve.CurvesIntersect(a.looseVisibilityPolyline, b.VisibilityPolyline);\n        }\n        // Otherwise see if the inner one is close enough to the outer border to consider them touching.\n        const innerLoosePolyline = aIsInsideB ? a.looseVisibilityPolyline : b.looseVisibilityPolyline;\n        const outerPolyline = aIsInsideB ? b.VisibilityPolyline : a.VisibilityPolyline;\n        for (const innerPoint of innerLoosePolyline) {\n            if (Curve.PointRelativeToCurveLocation(innerPoint, outerPolyline) === PointLocation.Outside) {\n                const outerParamPoint = Curve.ClosestPoint(outerPolyline, innerPoint);\n                if (!Point.closeIntersections(innerPoint, outerParamPoint)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    //Add ancestors that are spatial parents - they may not be in the hierarchy, but we need to be\n    //able to cross their boundaries if we're routing between obstacles on different sides of them.\n    AdjustSpatialAncestors() {\n        if (this.SpatialAncestorsAdjusted) {\n            return false;\n        }\n        // Add each group to the AncestorSet of any spatial children (duplicate Insert() is ignored).\n        for (const group of this.GetAllGroups()) {\n            const groupBox = group.VisibilityBoundingBox;\n            for (const obstacle of this.Root.GetNodeItemsIntersectingRectangle(groupBox)) {\n                if (obstacle !== group && Curve.ClosedCurveInteriorsIntersect(obstacle.VisibilityPolyline, group.VisibilityPolyline)) {\n                    if (obstacle.IsInConvexHull) {\n                        /*Assert.assert(\n                          obstacle.IsPrimaryObstacle,\n                          'Only primary obstacles should be in the hierarchy',\n                        )*/\n                        for (const sibling of obstacle.ConvexHull.Obstacles) {\n                            this.AncestorSets.get(sibling.InputShape).add(group.InputShape);\n                        }\n                    }\n                    this.AncestorSets.get(obstacle.InputShape).add(group.InputShape);\n                }\n            }\n        }\n        // Remove any hierarchical ancestors that are not spatial ancestors.  Otherwise, when trying to route to\n        // obstacles that *are* spatial children of such a non-spatial-but-hierarchical ancestor, we won't enable\n        // crossing the boundary the first time and will always go to the full \"activate all groups\" path.  By\n        // removing them here we not only get a better graph (avoiding some spurious crossings) but we're faster\n        // both in path generation and Nudging.\n        let nonSpatialGroups = new Array();\n        for (const child of this.Root.GetAllLeaves()) {\n            const childBox = child.VisibilityBoundingBox;\n            // This has to be two steps because we can't modify the Set during enumeration.\n            nonSpatialGroups = nonSpatialGroups.concat(Array.from(this.AncestorSets.get(child.InputShape)).filter((anc) => !childBox.intersects(this.shapeIdToObstacleMap.get(anc).VisibilityBoundingBox)));\n            for (const group of nonSpatialGroups) {\n                this.AncestorSets.get(child.InputShape).delete(group);\n            }\n            nonSpatialGroups = [];\n        }\n        this.SpatialAncestorsAdjusted = true;\n        return true;\n    }\n    GetAllGroups() {\n        return this.GetAllObstacles().filter((obs) => obs.IsGroup);\n    }\n    //Clear the internal state.\n    Clear() {\n        this.Root = null;\n        this.AncestorSets = null;\n    }\n    // Create a LineSegment that contains the max visibility from startPoint in the desired direction.\n    CreateMaxVisibilitySegment(startPoint, dir, t) {\n        const graphBoxBorderIntersect = StaticGraphUtility.RectangleBorderIntersect(this.GraphBox, startPoint, dir);\n        if (PointComparer.GetDirections(startPoint, graphBoxBorderIntersect) === Direction.None) {\n            t.pacList = null;\n            return LineSegment.mkPP(startPoint, startPoint);\n        }\n        const segment = this.RestrictSegmentWithObstacles(startPoint, graphBoxBorderIntersect);\n        // Store this off before other operations which overwrite it.\n        t.pacList = this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(segment.start, segment.end);\n        return segment;\n    }\n    // Convenience functions that call through to RectangleNode.\n    GetAllObstacles() {\n        return this.allObstacles;\n    }\n    // Returns a list of all primary obstacles - secondary obstacles inside a convex hull are not needed in the VisibilityGraphGenerator.\n    GetAllPrimaryObstacles() {\n        return this.Root.GetAllLeaves();\n    }\n    // Hit-testing.\n    IntersectionIsInsideAnotherObstacle(sideObstacle, eventObstacle, intersect, scanDirection) {\n        this.insideHitTestIgnoreObstacle1 = eventObstacle;\n        this.insideHitTestIgnoreObstacle2 = sideObstacle;\n        this.insideHitTestScanDirection = scanDirection;\n        const obstacleNode = this.Root.FirstHitNodeWithPredicate(intersect, this.InsideObstacleHitTest.bind(this));\n        return null != obstacleNode;\n    }\n    PointIsInsideAnObstaclePD(intersect, direction) {\n        return this.PointIsInsideAnObstacle(intersect, ScanDirection.GetInstance(direction));\n    }\n    PointIsInsideAnObstacle(intersect, scanDirection) {\n        this.insideHitTestIgnoreObstacle1 = null;\n        this.insideHitTestIgnoreObstacle2 = null;\n        this.insideHitTestScanDirection = scanDirection;\n        const obstacleNode = this.Root.FirstHitNodeWithPredicate(intersect, this.InsideObstacleHitTest.bind(this));\n        return null != obstacleNode;\n    }\n    InsideObstacleHitTest(location, obstacle) {\n        if (obstacle === this.insideHitTestIgnoreObstacle1 || obstacle === this.insideHitTestIgnoreObstacle2) {\n            // It's one of the two obstacles we already know about.\n            return HitTestBehavior.Continue;\n        }\n        if (obstacle.IsGroup) {\n            // Groups are handled differently from overlaps; we create ScanSegments (overlapped\n            // if within a non-group obstacle, else non-overlapped), and turn on/off access across\n            // the Group boundary vertices.\n            return HitTestBehavior.Continue;\n        }\n        if (!StaticGraphUtility.PointIsInRectangleInterior(location, obstacle.VisibilityBoundingBox)) {\n            // // The point is on the obstacle boundary, not inside it.\n            return HitTestBehavior.Continue;\n        }\n        // Note: There are rounding issues using Curve.PointRelativeToCurveLocation at angled\n        // obstacle boundaries, hence this function.\n        const high = StaticGraphUtility.RectangleBorderIntersect(obstacle.VisibilityBoundingBox, location, this.insideHitTestScanDirection.dir).add(this.insideHitTestScanDirection.DirectionAsPoint);\n        const low = StaticGraphUtility.RectangleBorderIntersect(obstacle.VisibilityBoundingBox, location, this.insideHitTestScanDirection.OppositeDirection).sub(this.insideHitTestScanDirection.DirectionAsPoint);\n        const testSeg = LineSegment.mkPP(low, high);\n        const xxs = Curve.getAllIntersections(testSeg, obstacle.VisibilityPolyline, true);\n        // If this is an extreme point it can have one intersection, in which case we're either on the border\n        // or outside; if it's a collinear flat boundary, there can be 3 intersections to this point which again\n        // means we're on the border (and 3 shouldn't happen anymore with the curve intersection fixes and\n        // PointIsInsideRectangle check above).  So the interesting case is that we have 2 intersections.\n        if (2 === xxs.length) {\n            const firstInt = Point.RoundPoint(xxs[0].x);\n            const secondInt = Point.RoundPoint(xxs[1].x);\n            // If we're on either intersection, we're on the border rather than inside.\n            if (!PointComparer.EqualPP(location, firstInt) &&\n                !PointComparer.EqualPP(location, secondInt) &&\n                location.compareTo(firstInt) !== location.compareTo(secondInt)) {\n                // We're inside.  However, this may be an almost-flat side, in which case rounding\n                // could have reported the intersection with the start or end of the same side and\n                // a point somewhere on the interior of that side.  Therefore if both intersections\n                // are on the same side (integral portion of the parameter), we consider location\n                // to be on the border.  testSeg is always xxs[*].Segment0.\n                /*Assert.assert(\n                  testSeg === xxs[0].seg0,\n                  'incorrect parameter ordering to GetAllIntersections',\n                )*/\n                if (!closeDistEps(Math.floor(xxs[0].par1), Math.floor(xxs[1].par1))) {\n                    return HitTestBehavior.Stop;\n                }\n            }\n        }\n        return HitTestBehavior.Continue;\n    }\n    SegmentCrossesAnObstacle(startPoint, endPoint) {\n        this.stopAtGroups = true;\n        this.wantGroupCrossings = false;\n        const obstacleIntersectSeg = this.RestrictSegmentPrivate(startPoint, endPoint);\n        return !PointComparer.EqualPP(obstacleIntersectSeg.end, endPoint);\n    }\n    SegmentCrossesANonGroupObstacle(startPoint, endPoint) {\n        this.stopAtGroups = false;\n        this.wantGroupCrossings = false;\n        const obstacleIntersectSeg = this.RestrictSegmentPrivate(startPoint, endPoint);\n        return !PointComparer.EqualPP(obstacleIntersectSeg.end, endPoint);\n    }\n    // TEST_MSAGL\n    RestrictSegmentWithObstacles(startPoint, endPoint) {\n        this.stopAtGroups = false;\n        this.wantGroupCrossings = true;\n        return this.RestrictSegmentPrivate(startPoint, endPoint);\n    }\n    RestrictSegmentPrivate(startPoint, endPoint) {\n        this.GetRestrictedIntersectionTestSegment(startPoint, endPoint);\n        this.currentRestrictedRay = LineSegment.mkPP(startPoint, endPoint);\n        this.restrictedRayLengthSquared = startPoint.sub(endPoint).lengthSquared;\n        this.CurrentGroupBoundaryCrossingMap.Clear();\n        this.RecurseRestrictRayWithObstacles(this.Root);\n        return this.currentRestrictedRay;\n    }\n    GetRestrictedIntersectionTestSegment(startPoint, endPoint) {\n        // Due to rounding issues use a larger line span for intersection calculations.\n        const segDir = PointComparer.GetDirections(startPoint, endPoint);\n        const startX = Direction.West === segDir ? this.GraphBox.right : Direction.East === segDir ? this.GraphBox.left : startPoint.x;\n        const endX = Direction.West === segDir ? this.GraphBox.left : Direction.East === segDir ? this.GraphBox.right : endPoint.x;\n        const startY = Direction.South === segDir ? this.GraphBox.top * 2 : Direction.North === segDir ? this.GraphBox.bottom : startPoint.y;\n        const endY = Direction.South === segDir ? this.GraphBox.bottom : Direction.North === segDir ? this.GraphBox.top : startPoint.y;\n        this.restrictedIntersectionTestSegment = LineSegment.mkPP(new Point(startX, startY), new Point(endX, endY));\n    }\n    RecurseRestrictRayWithObstacles(rectNode) {\n        // A lineSeg that moves along the boundary of an obstacle is not blocked by it.\n        if (!StaticGraphUtility.RectangleInteriorsIntersect(this.currentRestrictedRay.boundingBox, rectNode.irect)) {\n            return;\n        }\n        const obstacle = rectNode.UserData;\n        if (null != obstacle) {\n            // Leaf node. Get the interior intersections.  Use the full-length original segment for the intersection calculation.\n            const intersections = Curve.getAllIntersections(this.restrictedIntersectionTestSegment, obstacle.VisibilityPolyline, true);\n            if (!obstacle.IsGroup || this.stopAtGroups) {\n                this.LookForCloserNonGroupIntersectionToRestrictRay(intersections);\n                return;\n            }\n            if (this.wantGroupCrossings) {\n                this.AddGroupIntersectionsToRestrictedRay(obstacle, intersections);\n            }\n            /*Assert.assert(rectNode.IsLeaf, 'RectNode with UserData is not a Leaf')*/\n            return;\n        }\n        // Not a leaf; recurse into children.\n        this.RecurseRestrictRayWithObstacles(rectNode.Left);\n        this.RecurseRestrictRayWithObstacles(rectNode.Right);\n    }\n    LookForCloserNonGroupIntersectionToRestrictRay(intersections) {\n        let numberOfGoodIntersections = 0;\n        let closestIntersectionInfo = null;\n        let localLeastDistSquared = this.restrictedRayLengthSquared;\n        const testDirection = PointComparer.GetDirections(this.restrictedIntersectionTestSegment.start, this.restrictedIntersectionTestSegment.end);\n        for (const intersectionInfo of intersections) {\n            const intersect = Point.RoundPoint(intersectionInfo.x);\n            const dirToIntersect = PointComparer.GetDirections(this.currentRestrictedRay.start, intersect);\n            if (dirToIntersect === CompassVector.OppositeDir(testDirection)) {\n                continue;\n            }\n            numberOfGoodIntersections++;\n            if (Direction.None === dirToIntersect) {\n                localLeastDistSquared = 0;\n                closestIntersectionInfo = intersectionInfo;\n                continue;\n            }\n            const distSquared = intersect.sub(this.currentRestrictedRay.start).lengthSquared;\n            if (distSquared < localLeastDistSquared) {\n                // Rounding may falsely report two intersections as different when they are actually \"Close\",\n                // e.g. a horizontal vs. vertical intersection on a slanted edge.\n                const rawDistSquared = intersectionInfo.x.sub(this.currentRestrictedRay.start).lengthSquared;\n                if (rawDistSquared < GeomConstants.squareOfDistanceEpsilon) {\n                    continue;\n                }\n                localLeastDistSquared = distSquared;\n                closestIntersectionInfo = intersectionInfo;\n            }\n        }\n        if (null != closestIntersectionInfo) {\n            // If there was only one intersection and it is quite close to an end, ignore it.\n            // If there is more than one intersection, we have crossed the obstacle so we want it.\n            if (numberOfGoodIntersections === 1) {\n                const intersect = Point.RoundPoint(closestIntersectionInfo.x);\n                if (Point.closeIntersections(intersect, this.currentRestrictedRay.start) ||\n                    Point.closeIntersections(intersect, this.currentRestrictedRay.end)) {\n                    return;\n                }\n            }\n            this.restrictedRayLengthSquared = localLeastDistSquared;\n            this.currentRestrictedRay.end = SpliceUtility.MungeClosestIntersectionInfo(this.currentRestrictedRay.start, closestIntersectionInfo, !StaticGraphUtility.IsVerticalPP(this.currentRestrictedRay.start, this.currentRestrictedRay.end));\n        }\n    }\n    AddGroupIntersectionsToRestrictedRay(obstacle, intersections) {\n        // We'll let the lines punch through any intersections with groups, but track the location so we can enable/disable crossing.\n        for (const intersectionInfo of intersections) {\n            const intersect = Point.RoundPoint(intersectionInfo.x);\n            // Skip intersections that are past the end of the restricted segment (though there may still be some\n            // there if we shorten it later, but we'll skip them later).\n            const distSquared = intersect.sub(this.currentRestrictedRay.start).lengthSquared;\n            if (distSquared > this.restrictedRayLengthSquared) {\n                continue;\n            }\n            const dirTowardIntersect = PointComparer.GetDirections(this.currentRestrictedRay.start, this.currentRestrictedRay.end);\n            const polyline = intersectionInfo.seg1;\n            // this is the second arg to GetAllIntersections\n            const dirsOfSide = CompassVector.VectorDirection(polyline.derivative(intersectionInfo.par1));\n            // // The derivative is always clockwise, so if the side contains the rightward rotation of the\n            // direction from the ray origin, then we're hitting it from the inside; otherwise from the outside.\n            let dirToInsideOfGroup = dirTowardIntersect;\n            if (0 !== (dirsOfSide & CompassVector.RotateRight(dirTowardIntersect))) {\n                dirToInsideOfGroup = CompassVector.OppositeDir(dirToInsideOfGroup);\n            }\n            this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, obstacle, dirToInsideOfGroup);\n        }\n    }\n}\n//# sourceMappingURL=ObstacleTree.js.map","import { BasicVertexEvent } from './BasicVertexEvent';\nexport class OpenVertexEvent extends BasicVertexEvent {\n    constructor(obstacle, p) {\n        super(obstacle, p);\n    }\n}\n//# sourceMappingURL=OpenVertexEvent.js.map","// This stores the location and type of a Port.\nimport { Obstacle } from './obstacle';\nexport class OverlapConvexHull {\n    constructor(polyline, obstacles) {\n        this.Polyline = polyline;\n        this.Obstacles = Array.from(obstacles);\n        this.PrimaryObstacle = this.Obstacles[0];\n        Obstacle.RoundVerticesAndSimplify(this.Polyline);\n    }\n}\n//# sourceMappingURL=OverlapConvexHull.js.map","// MSAGL class for a Point and any Group boundary crossings at that Point, for Rectilinear Edge Routing.\nexport class PointAndCrossings {\n    constructor(loc, crossings) {\n        this.Crossings = [];\n        this.Location = loc;\n        this.Crossings = crossings;\n    }\n}\n//# sourceMappingURL=PointAndCrossings.js.map","// A Group is a Shape that has children.\n// This class maps between intersection points on Group boundaries and the groups and crossing\nimport { String } from 'typescript-string-operations';\nimport { PointAndCrossings } from './PointAndCrossings';\nimport { PointComparer } from './PointComparer';\n// directions at those intersection points.\nexport class PointAndCrossingsList {\n    Count() {\n        return this.ListOfPointsAndCrossings.length;\n    }\n    constructor() {\n        // Internal to allow testing.\n        this.ListOfPointsAndCrossings = [];\n        this.index = 0;\n        this.ListOfPointsAndCrossings = new Array();\n    }\n    Add(intersect, crossings) {\n        this.ListOfPointsAndCrossings.push(new PointAndCrossings(intersect, crossings));\n    }\n    Pop() {\n        // Next should only be called after CurrentIsBeforeOrAt returns true.\n        /*Assert.assert(\n          this.index < this.ListOfPointsAndCrossings.length,\n          'Unexpected call to Next()',\n        )*/\n        return this.ListOfPointsAndCrossings[this.index++];\n    }\n    CurrentIsBeforeOrAt(comparand) {\n        if (this.index >= this.ListOfPointsAndCrossings.length) {\n            return false;\n        }\n        return PointComparer.ComparePP(this.ListOfPointsAndCrossings[this.index].Location, comparand) <= 0;\n    }\n    get First() {\n        return this.ListOfPointsAndCrossings[0];\n    }\n    get Last() {\n        return this.ListOfPointsAndCrossings[this.ListOfPointsAndCrossings.length - 1];\n    }\n    Reset() {\n        this.index = 0;\n    }\n    MergeFrom(other) {\n        this.Reset();\n        if (other == null) {\n            return;\n        }\n        // Do the usual sorted-list merge.\n        const thisMax = this.ListOfPointsAndCrossings.length;\n        let thisIndex = 0;\n        const otherMax = other.ListOfPointsAndCrossings.length;\n        let otherIndex = 0;\n        const newCrossingsList = new Array(this.ListOfPointsAndCrossings.length);\n        while (thisIndex < thisMax || otherIndex < otherMax) {\n            if (thisIndex >= thisMax) {\n                newCrossingsList.push(other.ListOfPointsAndCrossings[otherIndex++]);\n                continue;\n            }\n            if (otherIndex >= otherMax) {\n                newCrossingsList.push(this.ListOfPointsAndCrossings[thisIndex++]);\n                continue;\n            }\n            const thisPac = this.ListOfPointsAndCrossings[thisIndex];\n            const otherPac = other.ListOfPointsAndCrossings[otherIndex];\n            const cmp = PointComparer.ComparePP(thisPac.Location, otherPac.Location);\n            if (0 === cmp) {\n                // No duplicates\n                newCrossingsList.push(thisPac);\n                ++thisIndex;\n                ++otherIndex;\n            }\n            else if (-1 === cmp) {\n                newCrossingsList.push(thisPac);\n                ++thisIndex;\n            }\n            else {\n                newCrossingsList.push(otherPac);\n                ++otherIndex;\n            }\n        }\n        this.ListOfPointsAndCrossings = newCrossingsList;\n    }\n    Trim(start, end) {\n        this.Reset();\n        if (this.ListOfPointsAndCrossings == null || 0 === this.ListOfPointsAndCrossings.length) {\n            return;\n        }\n        this.ListOfPointsAndCrossings = this.ListOfPointsAndCrossings.filter((pair) => PointComparer.ComparePP(pair.Location, start) >= 0 && PointComparer.ComparePP(pair.Location, end) <= 0);\n    }\n    // For a single vertex point, split its Array of crossings in both directions into an array in each (opposite)\n    // direction.  CLR Array iteration is much faster than Array.\n    static ToCrossingArray(crossings, dirToInside) {\n        // First find the number in each (opposite) direction, then create the arrays.\n        // We expect a very small number of groups to share a boundary point so this is not optimized.\n        let numInDir = 0;\n        const crossingsCount = crossings.length;\n        // cache for perf\n        for (let ii = 0; ii < crossingsCount; ii++) {\n            if (crossings[ii].DirectionToInside === dirToInside) {\n                numInDir++;\n            }\n        }\n        if (0 === numInDir) {\n            return null;\n        }\n        const vector = new Array(numInDir);\n        let jj = 0;\n        for (let ii = 0; ii < crossingsCount; ii++) {\n            if (crossings[ii].DirectionToInside === dirToInside) {\n                vector[jj++] = crossings[ii];\n            }\n        }\n        return vector;\n    }\n    ToString() {\n        return String.Format('{0} [{1}]', this.ListOfPointsAndCrossings.length, this.index);\n    }\n}\n//# sourceMappingURL=PointAndCrossingsList.js.map","import { CompassVector } from '../../math/geometry/compassVector';\nimport { Direction } from '../../math/geometry/direction';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nexport class PointComparer {\n    // ReSharper restore InconsistentNaming\n    static get DifferenceEpsilon() {\n        return PointComparer.differenceEpsilon;\n    }\n    // Determines whether the specified Points, which are assumed to have been Round()ed,\n    // are close enough to be considered equal.\n    // <returns>True if the inputs are close enough to be considered equal, else false</returns>\n    static EqualPP(a, b) {\n        return PointComparer.Equal(a.x, b.x) && PointComparer.Equal(a.y, b.y);\n    }\n    // Determines whether the specified double values, which are assumed to have been Round()ed,\n    // are close enough to be considered equal.\n    // <returns>True if the inputs are close enough to be considered equal, else false</returns>\n    static Equal(x, y) {\n        return PointComparer.Compare(x, y) === 0;\n    }\n    // The usual Compare operation, with inputs that are assumed to have been Round()ed.\n    //\n    //\n    // <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is\n    // less than rhs, else 1.</returns>\n    static Compare(lhs, rhs) {\n        // If the inputs are not rounded, then two numbers that are close together at the\n        // middle of the rounding range may Compare as 0 but Round to different values\n        // (e.g., with rounding to 6 digits, xxx.yyyyyy49 and xxx.yyyyyy51 will exhibit this).\n        // PointComparer.Assert_Rounded(lhs)\n        // PointComparer.Assert_Rounded(rhs)\n        let cmp = 0;\n        if (lhs + PointComparer.DifferenceEpsilon < rhs) {\n            cmp = -1;\n        }\n        else if (rhs + PointComparer.DifferenceEpsilon < lhs) {\n            cmp = 1;\n        }\n        // Just to be sure we're in sync with CompassVector\n        /*Assert.assert(\n          cmp < 0 ==\n            (Direction.East ==\n              CompassVector.VectorDirectionPP(\n                new Point(lhs, 0),\n                new Point(rhs, 0),\n              )),\n        )*/\n        /*Assert.assert(\n          (0 === cmp) ==\n            (Direction.None ==\n              CompassVector.VectorDirectionPP(\n                new Point(lhs, 0),\n                new Point(rhs, 0),\n              )),\n        )*/\n        return cmp;\n    }\n    // The usual Compare operation, with inputs that are assumed to have been Round()ed.\n    // <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is\n    // less than rhs, else 1.</returns>\n    static ComparePP(lhs, rhs) {\n        let cmp = PointComparer.Compare(lhs.x, rhs.x);\n        if (cmp === 0) {\n            cmp = PointComparer.Compare(lhs.y, rhs.y);\n        }\n        return cmp;\n    }\n    // return true if less or equal holds for two values that are assumed to have been Round()ed\n    static LessOrEqual(a, b) {\n        const comp = PointComparer.Compare(a, b);\n        return comp < 0 || comp === 0;\n    }\n    static Less(a, b) {\n        return PointComparer.Compare(a, b) < 0;\n    }\n    // static Assert_Rounded(d: number) {\n    //  //  Be sure there is enough precision to round that far; anything larger than this is\n    //  //  unlikely to be a graph coordinate (it's probably a line intersection way out of range).\n    //  if (Math.log10(Math.abs(d)) < 14 - GeomConstants.distanceEpsilonPrecision) {\n    //    /*Assert.assert(\n    //      Math.abs(Point.RoundDouble(d) - d) <\n    //        PointComparer.DifferenceEpsilon,\n    //      'unRounded value passed',\n    //    )*/\n    //  }\n    // }\n    // static Assert_RoundedP(p: Point) {\n    //  // PointComparer.Assert_Rounded(p.x)\n    //  // PointComparer.Assert_Rounded(p.y)\n    // }\n    static GetDirections(a, b) {\n        // PointComparer.Assert_RoundedP(a)\n        // PointComparer.Assert_RoundedP(b)\n        return CompassVector.DirectionFromPointToPoint(a, b);\n    }\n    static IsPureDirection(a, b) {\n        // PointComparer.Assert_RoundedP(a)\n        // PointComparer.Assert_RoundedP(b)\n        return CompassVector.IsPureDirection(PointComparer.GetDirections(a, b));\n    }\n    static IsPureDirectionD(dir) {\n        return CompassVector.IsPureDirection(dir);\n    }\n    static IsPureLower(a, b) {\n        // PointComparer.Assert_RoundedP(a)\n        // PointComparer.Assert_RoundedP(b)\n        // Is a lower than b along the orthogonal line segment?  That means moving\n        // from a to b is in the increasing direction.\n        const dir = PointComparer.GetDirections(a, b);\n        return Direction.East === dir || Direction.North === dir;\n    }\n    static GetPureDirectionVV(first, second) {\n        return PointComparer.GetDirections(first.point, second.point);\n    }\n}\n// Due to the vagaries of rounding, we may encounter a result that is not quite 0\n// when subtracting two numbers that are close.\n// ReSharper disable InconsistentNaming\nPointComparer.differenceEpsilon = GeomConstants.distanceEpsilon / 2;\n//# sourceMappingURL=PointComparer.js.map","//\n// PortManager.cs\n// MSAGL class for Port management for Rectilinear Edge Routing.\n//\n// This stores information mapping the App-level Ports (e.g. FloatingPort, RelativeFloatingPort,\n// and MultiLocationFloatingPort) to the router's BasicScanPort subclasses (ObstaclePort and FreePoint).\nimport { uniteSets, substractSets } from '../../utils/setOperations';\nimport { Point, Rectangle } from '../../math/geometry';\nimport { CompassVector } from '../../math/geometry/compassVector';\nimport { PointLocation, Curve } from '../../math/geometry/curve';\nimport { Direction } from '../../math/geometry/direction';\nimport { LineSegment } from '../../math/geometry/lineSegment';\nimport { InteractiveObstacleCalculator } from '../interactiveObstacleCalculator';\nimport { ObstaclePort } from './ObstaclePort';\nimport { PointComparer } from './PointComparer';\nimport { ScanDirection } from './ScanDirection';\nimport { ScanSegment } from './ScanSegment';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nimport { FreePoint } from './FreePoint';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { TransientGraphUtility } from './TransientGraphUtility';\nimport { PointMap } from '../../utils/PointMap';\nimport { PointSet } from '../../utils/PointSet';\nexport class PortManager {\n    // Extension of port visibility splices into the visibility graph.\n    get LimitPortVisibilitySpliceToEndpointBoundingBox() {\n        return this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox;\n    }\n    set LimitPortVisibilitySpliceToEndpointBoundingBox(value) {\n        this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox = value;\n    }\n    // Typing shortcuts\n    get VisGraph() {\n        return this.graphGenerator.VisibilityGraph;\n    }\n    get HScanSegments() {\n        return this.graphGenerator.HorizontalScanSegments;\n    }\n    get VScanSegments() {\n        return this.graphGenerator.VerticalScanSegments;\n    }\n    get ObstacleTree() {\n        return this.graphGenerator.ObstacleTree;\n    }\n    get AncestorSets() {\n        return this.ObstacleTree.AncestorSets;\n    }\n    constructor(graphGenerator) {\n        // The mapping of Msagl.Port (which may be MultiLocation) to the underlying Obstacle.Shape.\n        this.obstaclePortMap = new Map();\n        // The mapping of Msagl.Port.Location or a Waypoint to a FreePoint with visibility info.\n        this.freePointMap = new PointMap();\n        // This tracks which locations were used by the last call to RouteEdges, so we can remove unused locations.\n        this.freePointLocationsUsedByRouteEdges = new PointSet();\n        // Storage and implementation of RectilinearEdgeRouter property of the same name.\n        this.RouteToCenterOfObstacles = false;\n        // A control point is a source, target, or waypoint (terminology only, there's no ControlPoint\n        // class).  These lists are the control points we've added for the current path.\n        this.obstaclePortsInGraph = new Array();\n        this.freePointsInGraph = new Set();\n        // The current set of Obstacles that are groups whose boundaries are crossable.\n        this.activeAncestors = new Array();\n        this.TransUtil = new TransientGraphUtility(graphGenerator);\n        this.graphGenerator = graphGenerator;\n    }\n    Clear() {\n        this.TransUtil.RemoveFromGraph();\n        // Probably nothing in here when this is called\n        this.obstaclePortMap.clear();\n    }\n    CreateObstaclePorts(obstacle) {\n        // Create ObstaclePorts for all Ports of this obstacle.  This just creates the\n        // ObstaclePort object; we don't add its edges/vertices to the graph until we\n        // do the actual routing.\n        for (const port of obstacle.Ports) {\n            this.CreateObstaclePort(obstacle, port);\n        }\n    }\n    CreateObstaclePort(obstacle, port) {\n        // This will replace any previous specification for the port (last one wins).\n        /*Assert.assert(\n          !this.obstaclePortMap.has(port),\n          'Port is used by more than one obstacle',\n        )*/\n        if (port.Curve == null) {\n            return null;\n        }\n        const roundedLocation = Point.RoundPoint(port.Location);\n        if (PointLocation.Outside === Curve.PointRelativeToCurveLocation(roundedLocation, obstacle.InputShape.BoundaryCurve)) {\n            // Obstacle.Port is outside Obstacle.Shape; handle it as a FreePoint.\n            return null;\n        }\n        if (obstacle.InputShape.BoundaryCurve !== port.Curve &&\n            PointLocation.Outside === Curve.PointRelativeToCurveLocation(roundedLocation, port.Curve)) {\n            // Obstacle.Port is outside port.Curve; handle it as a FreePoint.\n            return null;\n        }\n        const oport = new ObstaclePort(port, obstacle);\n        this.obstaclePortMap.set(port, oport);\n        return oport;\n    }\n    FindVertices(port) {\n        const vertices = new Array();\n        const oport = this.obstaclePortMap.get(port);\n        if (oport) {\n            if (this.RouteToCenterOfObstacles) {\n                vertices.push(oport.CenterVertex);\n            }\n            else {\n                // Add all vertices on the obstacle borders.  Avoid LINQ for performance.\n                for (const entrance of oport.PortEntrances) {\n                    const vertex = this.VisGraph.FindVertex(entrance.UnpaddedBorderIntersect);\n                    if (vertex != null) {\n                        vertices.push(vertex);\n                    }\n                }\n            }\n        }\n        else {\n            vertices.push(this.VisGraph.FindVertex(Point.RoundPoint(port.Location)));\n        }\n        return vertices;\n    }\n    RemoveObstaclePorts(obstacle) {\n        for (const port of obstacle.Ports) {\n            // Since we remove the port from the visibility graph after each routing, all we\n            // have to do here is remove it from the dictionary.\n            this.RemoveObstaclePort(port);\n        }\n    }\n    RemoveObstaclePort(port) {\n        this.obstaclePortMap.delete(port);\n    }\n    // Add path control points - source, target, and any waypoints.\n    AddControlPointsToGraph(edge, shapeToObstacleMap) {\n        this.GetPortSpliceLimitRectangle(edge);\n        this.activeAncestors = [];\n        const s = { oport: null };\n        const t = { oport: null };\n        const ssAncs = this.FindAncestorsAndObstaclePort(edge.sourcePort, s);\n        const ttAncs = this.FindAncestorsAndObstaclePort(edge.targetPort, t);\n        if (this.AncestorSets.size > 0 && s.oport != null && t.oport != null) {\n            // Make non-common ancestors' boundaries transparent (we don't want to route outside common ancestors).\n            const ttAncsOnly = substractSets(ttAncs, ssAncs);\n            const ssAncsOnly = substractSets(ssAncs, ttAncs);\n            this.ActivateAncestors(ssAncsOnly, ttAncsOnly, shapeToObstacleMap);\n        }\n        // Now that we've set any active ancestors, splice in the port visibility.\n        this.AddPortToGraph(edge.sourcePort, s.oport);\n        this.AddPortToGraph(edge.targetPort, t.oport);\n    }\n    ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(oobWaypoint, port) {\n        if (oobWaypoint == null || !oobWaypoint.IsOutOfBounds) {\n            return;\n        }\n        // Connect to the graphbox side at points collinear with the vertices.  The waypoint may be\n        // OOB in two directions so call once for each axis.\n        const endpointVertices = this.FindVertices(port);\n        let dirFromGraph = oobWaypoint.OutOfBoundsDirectionFromGraph & (Direction.North | Direction.South);\n        this.ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint, dirFromGraph, endpointVertices);\n        dirFromGraph = oobWaypoint.OutOfBoundsDirectionFromGraph & (Direction.East | Direction.West);\n        this.ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint, dirFromGraph, endpointVertices);\n    }\n    ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint, dirFromGraph, endpointVertices) {\n        if (Direction.None === dirFromGraph) {\n            // Not out of bounds on this axis.\n            return;\n        }\n        const dirToGraph = CompassVector.OppositeDir(dirFromGraph);\n        for (const vertex of endpointVertices) {\n            const graphBorderLocation = this.InBoundsGraphBoxIntersect(vertex.point, dirFromGraph);\n            const graphBorderVertex = this.VisGraph.FindVertex(graphBorderLocation);\n            if (graphBorderVertex != null) {\n                this.TransUtil.ConnectVertexToTargetVertex(oobWaypoint.Vertex, graphBorderVertex, dirToGraph, ScanSegment.NormalWeight);\n            }\n        }\n    }\n    SetAllAncestorsActive(edgeGeom, shapeToObstacleMap) {\n        if (0 === this.AncestorSets.size) {\n            return false;\n        }\n        this.ObstacleTree.AdjustSpatialAncestors();\n        this.ClearActiveAncestors();\n        const t = { oport: null };\n        const s = { oport: null };\n        const ssAncs = this.FindAncestorsAndObstaclePort(edgeGeom.sourcePort, s);\n        const ttAncs = this.FindAncestorsAndObstaclePort(edgeGeom.targetPort, t);\n        if (this.AncestorSets.size > 0 && ssAncs != null && ttAncs != null) {\n            // Make all ancestors boundaries transparent; in this case we've already tried with only\n            // non-common and found no path, so perhaps an obstacle is outside its parent group's bounds.\n            this.ActivateAncestors(ssAncs, ttAncs, shapeToObstacleMap);\n            return true;\n        }\n        return false;\n    }\n    SetAllGroupsActive() {\n        // We couldn't get a path when we activated all hierarchical and spatial group ancestors of the shapes,\n        // so assume we may be landlocked and activate all groups, period.\n        this.ClearActiveAncestors();\n        for (const group of this.ObstacleTree.GetAllGroups()) {\n            group.IsTransparentAncestor = true;\n            this.activeAncestors.push(group);\n        }\n    }\n    FindAncestorsAndObstaclePort(port, t) {\n        t.oport = this.FindObstaclePort(port);\n        if (0 === this.AncestorSets.size) {\n            return null;\n        }\n        if (t.oport != null) {\n            return this.AncestorSets.get(t.oport.Obstacle.InputShape);\n        }\n        // This is a free Port (not associated with an obstacle) or a Waypoint; return all spatial parents.\n        return new Set(Array.from(this.ObstacleTree.Root.AllHitItems(Rectangle.mkPP(port.Location, port.Location), (shape) => shape.IsGroup)).map((obs) => obs.InputShape));\n    }\n    ActivateAncestors(ssAncsToUse, ttAncsToUse, shapeToObstacleMap) {\n        for (const shape of uniteSets(ssAncsToUse, ttAncsToUse)) {\n            const group = shapeToObstacleMap.get(shape);\n            /*Assert.assert(group.IsGroup, 'Ancestor shape is not a group')*/\n            group.IsTransparentAncestor = true;\n            this.activeAncestors.push(group);\n        }\n    }\n    ClearActiveAncestors() {\n        for (const group of this.activeAncestors) {\n            group.IsTransparentAncestor = false;\n        }\n        this.activeAncestors = [];\n    }\n    RemoveControlPointsFromGraph() {\n        this.ClearActiveAncestors();\n        this.RemoveObstaclePortsFromGraph();\n        this.RemoveFreePointsFromGraph();\n        this.TransUtil.RemoveFromGraph();\n        this.portSpliceLimitRectangle = Rectangle.mkEmpty();\n    }\n    RemoveObstaclePortsFromGraph() {\n        for (const oport of this.obstaclePortsInGraph) {\n            oport.RemoveFromGraph();\n        }\n        this.obstaclePortsInGraph = [];\n    }\n    RemoveFreePointsFromGraph() {\n        for (const freePoint of this.freePointsInGraph) {\n            freePoint.RemoveFromGraph();\n        }\n        this.freePointsInGraph.clear();\n    }\n    RemoveStaleFreePoints() {\n        // FreePoints are not necessarily persistent - they may for example be waypoints which are removed.\n        // So after every routing pass, remove any that were not added to the graph. Because the FreePoint has\n        // be removed from the graph, its Vertex (and thus Point) are no longer set in the FreePoint, so we\n        // must use the key from the dictionary.\n        if (this.freePointMap.size > this.freePointLocationsUsedByRouteEdges.size) {\n            const staleFreePairs = Array.from(this.freePointMap).filter((p) => !this.freePointLocationsUsedByRouteEdges.has(p[0]));\n            for (const staleFreePair of staleFreePairs) {\n                this.freePointMap.deleteP(staleFreePair[0]);\n            }\n        }\n    }\n    ClearVisibility() {\n        // Most of the retained freepoint stuff is about precalculated visibility.\n        this.freePointMap.clear();\n        for (const oport of this.obstaclePortMap.values()) {\n            oport.ClearVisibility();\n        }\n    }\n    BeginRouteEdges() {\n        this.RemoveControlPointsFromGraph();\n        // ensure there are no leftovers\n        this.freePointLocationsUsedByRouteEdges.clear();\n    }\n    EndRouteEdges() {\n        this.RemoveStaleFreePoints();\n    }\n    FindObstaclePort(port) {\n        let oport = this.obstaclePortMap.get(port);\n        if (oport) {\n            // First see if the obstacle's port list has changed without UpdateObstacles() being called.\n            // Unfortunately we don't have a way to update the obstacle's ports until we enter\n            // this block; there is no direct Port->Shape/Obstacle mapping.  So UpdateObstacle must still\n            // be called, but at least this check here will remove obsolete ObstaclePorts.\n            const t = {\n                removedPorts: null,\n                addedPorts: null,\n            };\n            if (oport.Obstacle.GetPortChanges(t)) {\n                for (const newPort of t.addedPorts) {\n                    this.CreateObstaclePort(oport.Obstacle, newPort);\n                }\n                for (const oldPort of t.removedPorts) {\n                    this.RemoveObstaclePort(oldPort);\n                }\n                // If it's not still there, it was moved outside the obstacle so we'll just add it as a FreePoint.\n                oport = this.obstaclePortMap.get(port);\n            }\n        }\n        return oport;\n    }\n    AddPortToGraph(port, oport) {\n        if (oport != null) {\n            this.AddObstaclePortToGraph(oport);\n            return;\n        }\n        // This is a FreePoint, either a Waypoint or a Port not in an Obstacle.Ports list.\n        this.AddFreePointToGraph(port.Location);\n    }\n    AddObstaclePortToGraph(oport) {\n        // If the port's position has changed without UpdateObstacles() being called, recreate it.\n        if (oport.LocationHasChanged) {\n            this.RemoveObstaclePort(oport.Port);\n            oport = this.CreateObstaclePort(oport.Obstacle, oport.Port);\n            if (oport == null) {\n                // Port has been moved outside obstacle; return and let caller add it as a FreePoint.\n                return;\n            }\n        }\n        oport.AddToGraph(this.TransUtil, this.RouteToCenterOfObstacles);\n        this.obstaclePortsInGraph.push(oport);\n        this.CreateObstaclePortEntrancesIfNeeded(oport);\n        // We've determined the entrypoints on the obstacle boundary for each PortEntry,\n        // so now add them to the VisGraph.\n        for (const entrance of oport.PortEntrances) {\n            this.AddObstaclePortEntranceToGraph(entrance);\n        }\n        return;\n    }\n    CreateObstaclePortEntrancesIfNeeded(oport) {\n        if (oport.PortEntrances.length > 0) {\n            return;\n        }\n        // Create the PortEntrances with initial information:  border intersect and outer edge direction.\n        this.CreateObstaclePortEntrancesFromPoints(oport);\n    }\n    GetPortVisibilityIntersection(edgeGeometry) {\n        const sourceOport = this.FindObstaclePort(edgeGeometry.sourcePort);\n        const targetOport = this.FindObstaclePort(edgeGeometry.targetPort);\n        if (sourceOport == null || targetOport == null) {\n            return null;\n        }\n        if (sourceOport.Obstacle.IsInConvexHull || targetOport.Obstacle.IsInConvexHull) {\n            return null;\n        }\n        this.CreateObstaclePortEntrancesIfNeeded(sourceOport);\n        this.CreateObstaclePortEntrancesIfNeeded(targetOport);\n        if (!sourceOport.VisibilityRectangle.intersects(targetOport.VisibilityRectangle)) {\n            return null;\n        }\n        for (const sourceEntrance of sourceOport.PortEntrances) {\n            if (!sourceEntrance.WantVisibilityIntersection) {\n                continue;\n            }\n            for (const targetEntrance of targetOport.PortEntrances) {\n                if (!targetEntrance.WantVisibilityIntersection) {\n                    continue;\n                }\n                const points = sourceEntrance.IsVertical === targetEntrance.IsVertical\n                    ? PortManager.GetPathPointsFromOverlappingCollinearVisibility(sourceEntrance, targetEntrance)\n                    : PortManager.GetPathPointsFromIntersectingVisibility(sourceEntrance, targetEntrance);\n                if (points != null) {\n                    return points;\n                }\n            }\n        }\n        return null;\n    }\n    static GetPathPointsFromOverlappingCollinearVisibility(sourceEntrance, targetEntrance) {\n        // If the segments are the same they'll be in reverse.  Note: check for IntervalsOverlap also, if we support FreePoints here.\n        if (!StaticGraphUtility.IntervalsAreSame(sourceEntrance.MaxVisibilitySegment.start, sourceEntrance.MaxVisibilitySegment.end, targetEntrance.MaxVisibilitySegment.end, targetEntrance.MaxVisibilitySegment.start)) {\n            return null;\n        }\n        if (sourceEntrance.HasGroupCrossings || targetEntrance.HasGroupCrossings) {\n            return null;\n        }\n        if (Point.closeDistEps(sourceEntrance.UnpaddedBorderIntersect, targetEntrance.UnpaddedBorderIntersect)) {\n            // Probably one obstacle contained within another; we handle that elsewhere.\n            return null;\n        }\n        return [sourceEntrance.UnpaddedBorderIntersect, targetEntrance.UnpaddedBorderIntersect];\n    }\n    static GetPathPointsFromIntersectingVisibility(sourceEntrance, targetEntrance) {\n        const intersect = StaticGraphUtility.SegmentsIntersectLL(sourceEntrance.MaxVisibilitySegment, targetEntrance.MaxVisibilitySegment);\n        if (!intersect) {\n            return null;\n        }\n        if (sourceEntrance.HasGroupCrossingBeforePoint(intersect) || targetEntrance.HasGroupCrossingBeforePoint(intersect)) {\n            return null;\n        }\n        return [sourceEntrance.UnpaddedBorderIntersect, intersect, targetEntrance.UnpaddedBorderIntersect];\n    }\n    CreateObstaclePortEntrancesFromPoints(oport) {\n        const graphBox = this.graphGenerator.ObstacleTree.GraphBox;\n        const curveBox = Rectangle.mkPP(Point.RoundPoint(oport.PortCurve.boundingBox.leftBottom), Point.RoundPoint(oport.PortCurve.boundingBox.rightTop));\n        // This Port does not have a PortEntry, so we'll have visibility edges to its location\n        // in the Horizontal and Vertical directions (possibly all 4 directions, if not on boundary).\n        //\n        // First calculate the intersection with the obstacle in all directions.  Do nothing in the\n        // horizontal direction for port locations that are on the unpadded vertical extremes, because\n        // this will have a path that moves alongside a rectilinear obstacle side in less than the\n        // padding radius and will thus create the PaddedBorderIntersection on the side rather than top\n        // (and vice-versa for the vertical direction).  We'll have an edge in the vertical direction\n        // to the padded extreme boundary ScanSegment, and the Nudger will modify paths as appropriate\n        // to remove unnecessary bends.\n        // Use the unrounded port location to intersect with its curve.\n        const location = Point.RoundPoint(oport.PortLocation);\n        let found = false;\n        const t = { xx0: null, xx1: null };\n        if (!PointComparer.Equal(location.y, curveBox.top) && !PointComparer.Equal(location.y, curveBox.bottom)) {\n            found = true;\n            const hSeg = new LineSegment(graphBox.left, location.y, graphBox.right, location.y);\n            this.GetBorderIntersections(location, hSeg, oport.PortCurve, t);\n            let wBorderIntersect = new Point(Math.min(t.xx0.x, t.xx1.x), location.y);\n            if (wBorderIntersect.x < curveBox.left) {\n                // Handle rounding error\n                wBorderIntersect = new Point(curveBox.left, wBorderIntersect.y);\n            }\n            let eBorderIntersect = new Point(Math.max(t.xx0.x, t.xx1.x), location.y);\n            if (eBorderIntersect.x > curveBox.right) {\n                eBorderIntersect = new Point(curveBox.right, eBorderIntersect.y);\n            }\n            this.CreatePortEntrancesAtBorderIntersections(curveBox, oport, location, wBorderIntersect, eBorderIntersect);\n        }\n        // endif horizontal pass is not at vertical extreme\n        if (!PointComparer.Equal(location.x, curveBox.left) && !PointComparer.Equal(location.x, curveBox.right)) {\n            found = true;\n            const vSeg = new LineSegment(location.x, graphBox.bottom, location.x, graphBox.top);\n            this.GetBorderIntersections(location, vSeg, oport.PortCurve, t);\n            let sBorderIntersect = new Point(location.x, Math.min(t.xx0.y, t.xx1.y));\n            if (sBorderIntersect.y < graphBox.bottom) {\n                // Handle rounding error\n                sBorderIntersect = new Point(sBorderIntersect.x, graphBox.bottom);\n            }\n            let nBorderIntersect = new Point(location.x, Math.max(t.xx0.y, t.xx1.y));\n            if (nBorderIntersect.y > graphBox.top) {\n                nBorderIntersect = new Point(nBorderIntersect.x, graphBox.top);\n            }\n            this.CreatePortEntrancesAtBorderIntersections(curveBox, oport, location, sBorderIntersect, nBorderIntersect);\n        }\n        // endif vertical pass is not at horizontal extreme\n        if (!found) {\n            // This must be on a corner, else one of the above would have matched.\n            this.CreateEntrancesForCornerPort(curveBox, oport, location);\n        }\n    }\n    GetBorderIntersections(location, lineSeg, curve, t) {\n        // Important:  the LineSegment must be the first arg to GetAllIntersections so RawIntersection works.\n        const xxs = Curve.getAllIntersections(lineSeg, curve, true);\n        /*Assert.assert(2 === xxs.length, 'Expected two intersections')*/\n        t.xx0 = Point.RoundPoint(xxs[0].x);\n        t.xx1 = Point.RoundPoint(xxs[1].x);\n    }\n    CreatePortEntrancesAtBorderIntersections(curveBox, oport, location, unpaddedBorderIntersect0, unpaddedBorderIntersect1) {\n        // Allow entry from both sides, except from the opposite side of a point on the border.\n        const dir = PointComparer.GetDirections(unpaddedBorderIntersect0, unpaddedBorderIntersect1);\n        if (!PointComparer.EqualPP(unpaddedBorderIntersect0, location)) {\n            this.CreatePortEntrance(curveBox, oport, unpaddedBorderIntersect1, dir);\n        }\n        if (!PointComparer.EqualPP(unpaddedBorderIntersect1, location)) {\n            this.CreatePortEntrance(curveBox, oport, unpaddedBorderIntersect0, CompassVector.OppositeDir(dir));\n        }\n    }\n    static GetDerivative(oport, borderPoint) {\n        // This is only used for ObstaclePorts, which have ensured Port.Curve is not null.\n        const param = oport.PortCurve.closestParameter(borderPoint);\n        let deriv = oport.PortCurve.derivative(param);\n        const parMid = (oport.PortCurve.parStart + oport.PortCurve.parEnd) / 2;\n        if (!InteractiveObstacleCalculator.CurveIsClockwise(oport.PortCurve, oport.PortCurve.value(parMid))) {\n            deriv = deriv.mul(-1);\n        }\n        return deriv;\n    }\n    CreatePortEntrance(curveBox, oport, unpaddedBorderIntersect, outDir) {\n        oport.CreatePortEntrance(unpaddedBorderIntersect, outDir, this.ObstacleTree);\n        const scanDir = ScanDirection.GetInstance(outDir);\n        let axisDistanceBetweenIntersections = StaticGraphUtility.GetRectangleBound(curveBox, outDir) - scanDir.Coord(unpaddedBorderIntersect);\n        if (axisDistanceBetweenIntersections < 0) {\n            axisDistanceBetweenIntersections = -axisDistanceBetweenIntersections;\n        }\n        if (axisDistanceBetweenIntersections > GeomConstants.intersectionEpsilon) {\n            // This is not on an extreme boundary of the unpadded curve (it's on a sloping (nonrectangular) boundary),\n            // so we need to generate another entrance in one of the perpendicular directions (depending on which\n            // way the side slopes).  Derivative is always clockwise.\n            const perpDirs = CompassVector.VectorDirection(PortManager.GetDerivative(oport, unpaddedBorderIntersect));\n            let perpDir;\n            outDir | CompassVector.OppositeDir(outDir);\n            if (Direction.None !== (outDir & perpDirs)) {\n                // If the derivative is in the same direction as outDir then perpDir is toward the obstacle\n                // interior and must be reversed.\n                perpDir = CompassVector.OppositeDir(perpDir);\n            }\n            oport.CreatePortEntrance(unpaddedBorderIntersect, perpDir, this.ObstacleTree);\n        }\n    }\n    CreateEntrancesForCornerPort(curveBox, oport, location) {\n        // This must be a corner or it would have been within one of the bounds and handled elsewhere.\n        // Therefore create an entrance in both directions, with the first direction selected so that\n        // the second can be obtained via RotateRight.\n        let outDir = Direction.North;\n        if (PointComparer.EqualPP(location, curveBox.leftBottom)) {\n            outDir = Direction.South;\n        }\n        else if (PointComparer.EqualPP(location, curveBox.leftTop)) {\n            outDir = Direction.West;\n        }\n        else if (PointComparer.EqualPP(location, curveBox.rightTop)) {\n            outDir = Direction.North;\n        }\n        else if (PointComparer.EqualPP(location, curveBox.rightBottom)) {\n            outDir = Direction.East;\n        }\n        else {\n            /*Assert.assert(false, 'Expected Port to be on corner of curveBox')*/\n        }\n        oport.CreatePortEntrance(location, outDir, this.ObstacleTree);\n        oport.CreatePortEntrance(location, CompassVector.RotateRight(outDir), this.ObstacleTree);\n    }\n    AddObstaclePortEntranceToGraph(entrance) {\n        // Note: As discussed in ObstaclePortEntrance.AddToGraph, oport.VisibilityBorderIntersect may be\n        // on a border shared with another obstacle, in which case we'll extend into that obstacle.  This\n        // should be fine if we're consistent about \"touching means overlapped\", so that a path that comes\n        // through the other obstacle on the shared border is OK.\n        const borderVertex = this.VisGraph.FindVertex(entrance.VisibilityBorderIntersect);\n        if (borderVertex) {\n            entrance.ExtendEdgeChain(this.TransUtil, borderVertex, borderVertex, this.portSpliceLimitRectangle, this.RouteToCenterOfObstacles);\n            return;\n        }\n        // There may be no scansegment to splice to before we hit an adjacent obstacle, so if the edge\n        // is null there is nothing to do.\n        const t = { targetVertex: null };\n        const weight = entrance.IsOverlapped ? ScanSegment.OverlappedWeight : ScanSegment.NormalWeight;\n        const edge = this.FindorCreateNearestPerpEdgePPDNT(entrance.MaxVisibilitySegment.end, entrance.VisibilityBorderIntersect, entrance.OutwardDirection, weight, t);\n        if (edge != null) {\n            entrance.AddToAdjacentVertex(this.TransUtil, t.targetVertex, this.portSpliceLimitRectangle, this.RouteToCenterOfObstacles);\n        }\n    }\n    InBoundsGraphBoxIntersect(point, dir) {\n        return StaticGraphUtility.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.GraphBox, point, dir);\n    }\n    FindorCreateNearestPerpEdgePPDN(first, second, dir, weight) {\n        const t = { targetVertex: null };\n        return this.FindorCreateNearestPerpEdgePPDNT(first, second, dir, weight, t);\n    }\n    FindorCreateNearestPerpEdgePPDNT(first, second, dir, weight, t) {\n        // Find the closest perpendicular ScanSegment that intersects a segment with endpoints\n        // first and second, then find the closest parallel ScanSegment that intersects that\n        // perpendicular ScanSegment.  This gives us a VisibilityVertex location from which we\n        // can walk to the closest perpendicular VisibilityEdge that intersects first->second.\n        const couple = StaticGraphUtility.SortAscending(first, second);\n        const low = couple[0];\n        const high = couple[1];\n        const perpendicularScanSegments = StaticGraphUtility.IsVerticalD(dir) ? this.HScanSegments : this.VScanSegments;\n        // Look up the nearest intersection.  For obstacles, we cannot just look for the bounding box\n        // corners because nonrectilinear obstacles may have other obstacles overlapping the bounding\n        // box (at either the corners or between the port border intersection and the bounding box\n        // side), and of course obstacles may overlap too.\n        const nearestPerpSeg = StaticGraphUtility.IsAscending(dir)\n            ? perpendicularScanSegments.FindLowestIntersector(low, high)\n            : perpendicularScanSegments.FindHighestIntersector(low, high);\n        if (nearestPerpSeg == null) {\n            // No ScanSegment between this and visibility limits.\n            t.targetVertex = null;\n            return null;\n        }\n        const edgeIntersect = StaticGraphUtility.SegmentIntersectionSP(nearestPerpSeg, low);\n        // We now know the nearest perpendicular segment that intersects start->end.  Next we'll find a close\n        // parallel scansegment that intersects the perp segment, then walk to find the nearest perp edge.\n        return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(StaticGraphUtility.IsAscending(dir) ? low : high, nearestPerpSeg, edgeIntersect, weight, t);\n    }\n    FindOrCreateNearestPerpEdgeFromNearestPerpSegment(pointLocation, scanSeg, edgeIntersect, weight, t) {\n        var _a;\n        // Given: a ScanSegment scanSeg perpendicular to pointLocation->edgeIntersect and containing edgeIntersect.\n        // To find: a VisibilityEdge perpendicular to pointLocation->edgeIntersect which may be on scanSeg, or may\n        //          be closer to pointLocation than the passed edgeIntersect is.\n        // Since there may be TransientEdges between pointLocation and edgeIntersect, we start by finding\n        // a scanSeg-intersecting (i.e. parallel to pointLocation->edgeIntersect) ScanSegment, then starting from\n        // the intersection of those segments, walk the VisibilityGraph until we find the closest VisibilityEdge\n        // perpendicular to pointLocation->edgeIntersect.  If there is a vertex on that edge collinear to\n        // pointLocation->edgeIntersect, return the edge for which it is Source, else split the edge.\n        // If there is already a vertex at edgeIntersect, we do not need to look for the intersecting ScanSegment.\n        const tt = {\n            segsegVertex: this.VisGraph.FindVertex(edgeIntersect),\n            targetVertex: null,\n        };\n        if (tt.segsegVertex == null) {\n            const edge = this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(pointLocation, edgeIntersect, scanSeg, weight, tt);\n            if (edge != null) {\n                return edge;\n            }\n        }\n        else if (PointComparer.EqualPP(pointLocation, edgeIntersect)) {\n            // The initial pointLocation was on scanSeg at an existing vertex so return an edge\n            // from that vertex along scanSeg. Look in both directions in case of dead ends.\n            t.targetVertex = tt.segsegVertex;\n            return this.TransUtil.FindNextEdge(t.targetVertex, CompassVector.OppositeDir(scanSeg.ScanDirection.Dir));\n        }\n        // pointLocation is not on the initial scanSeg, so see if there is a transient edge between\n        // pointLocation and edgeIntersect.  edgeIntersect === segsegVertex.Point if pointLocation is\n        // collinear with intSegBefore (pointLocation is before or after intSegBefore's VisibilityVertices).\n        const dirTowardLocation = PointComparer.GetDirections(edgeIntersect, pointLocation);\n        let perpDir = PointComparer.GetDirections(tt.segsegVertex.point, pointLocation);\n        if (dirTowardLocation === perpDir) {\n            // intSegBefore is collinear with pointLocation so walk to the vertex closest to pointLocation.\n            const ot = { bracketTarget: null, bracketSource: null };\n            TransientGraphUtility.FindBracketingVertices(tt.segsegVertex, pointLocation, dirTowardLocation, ot);\n            // Return an edge. Look in both directions in case of dead ends.\n            return ((_a = this.TransUtil.FindNextEdge(ot.bracketSource, CompassVector.RotateLeft(dirTowardLocation))) !== null && _a !== void 0 ? _a : this.TransUtil.FindNextEdge(ot.bracketSource, CompassVector.RotateRight(dirTowardLocation)));\n        }\n        // Now make perpDir have only the perpendicular component.\n        perpDir &= ~dirTowardLocation; // if this is Directions. None, pointLocation === edgeIntersect\n        // StaticGraphUtility.Assert((Direction.None !== perpDir), \"pointLocation === initial segsegVertex.Point should already have exited\", this.ObstacleTree, this.VisGraph);\n        // Other TransientVE edge chains may have been added between the control point and the\n        // ScanSegment (which is always non-transient), and they may have split ScanSegment VEs.\n        // Fortunately we know we'll always have all transient edge chains extended to or past any\n        // control point (due to LimitRectangle), so we can just move up lowestIntSeg toward\n        // pointLocation, updating segsegVertex and edgeIntersect.  There are 3 possibilities:\n        //  - location is not on an edge - the usual case, we just create an edge perpendicular\n        //    to an edge on scanSeg, splitting that scanSeg edge in the process.\n        //  - location is on a VE that is parallel to scanSeg.  This is essentially the same thing\n        //    but we don't need the first perpendicular edge to scanSeg.\n        //  - location is on a VE that is perpendicular to scanSeg.  In that case the vertex on ScanSeg\n        //    already exists; TransUtil.FindOrAddEdge just returns the edge starting at that intersection.\n        // FreePoint tests of this are in RectilinearTests.FreePortLocationRelativeToTransientVisibilityEdges*.\n        const perpendicularEdge = this.TransUtil.FindNearestPerpendicularOrContainingEdge(tt.segsegVertex, perpDir, pointLocation);\n        if (perpendicularEdge == null) {\n            // Dead end; we're above the highest point at which there is an intersection of scanSeg.\n            // Create a new vertex and edge higher than the ScanSegment's HighestVisibilityVertex\n            // if that doesn't cross an obstacle (if we are between two ScanSegment dead-ends, we may).\n            // We hit this in RectilinearFileTests.Nudger_Many_Paths_In_Channel and .Nudger_Overlap*.\n            // StaticGraphUtility.Assert((edgeIntersect > scanSeg.HighestVisibilityVertex.point), \"edgeIntersect is not > scanSeg.HighestVisibilityVertex\", this.ObstacleTree, this.VisGraph);\n            t.targetVertex = this.TransUtil.AddVertex(edgeIntersect);\n            return this.TransUtil.FindOrAddEdge(t.targetVertex, scanSeg.HighestVisibilityVertex, scanSeg.Weight);\n        }\n        // We have an intersecting perp edge, which may be on the original scanSeg or closer to pointLocation.\n        // Get one of its vertices and re-find the intersection on it (it doesn't matter which vertex of the\n        // edge we use, but for consistency use the \"lower in perpDir\" one).\n        tt.segsegVertex = StaticGraphUtility.GetEdgeEnd(perpendicularEdge, CompassVector.OppositeDir(perpDir));\n        edgeIntersect = StaticGraphUtility.SegmentIntersectionPPP(pointLocation, edgeIntersect, tt.segsegVertex.point);\n        // By this point we've verified there's no intervening Transient edge, so if we have an identical\n        // point, we're done.\n        if (PointComparer.EqualPP(tt.segsegVertex.point, edgeIntersect)) {\n            t.targetVertex = tt.segsegVertex;\n            return this.TransUtil.FindNextEdge(tt.segsegVertex, perpDir);\n        }\n        // The targetVertex doesn't exist; this will split the edge and add it.\n        t.targetVertex = this.TransUtil.FindOrAddVertex(edgeIntersect);\n        return this.TransUtil.FindOrAddEdge(tt.segsegVertex, t.targetVertex, weight);\n    }\n    FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(pointLocation, edgeIntersect, scanSeg, weight, t) {\n        const intersectingSegments = scanSeg.IsVertical ? this.HScanSegments : this.VScanSegments;\n        const intSegBefore = intersectingSegments.FindHighestIntersector(scanSeg.Start, edgeIntersect);\n        if (intSegBefore == null) {\n            // Dead end; we're below the lowest point at which there is an intersection of scanSeg.\n            // Create a new vertex and edge lower than the ScanSegment's LowestVisibilityVertex.\n            // Test: RectilinearFileTests.Overlap_Rotate_SplicePort_FreeObstaclePorts.\n            t.segsegVertex = null;\n            t.targetVertex = this.TransUtil.AddVertex(edgeIntersect);\n            return this.TransUtil.FindOrAddEdge(t.targetVertex, scanSeg.LowestVisibilityVertex, scanSeg.Weight);\n        }\n        // Get the VisibilityVertex at the intersection of the two segments we just found;\n        // edgeIntersect is between that vertex and another on the segment, and we'll split\n        // the edge between those two vertices (or find one nearer to walk to).\n        const segsegIntersect = StaticGraphUtility.SegmentsIntersection(scanSeg, intSegBefore);\n        t.segsegVertex = this.VisGraph.FindVertex(segsegIntersect);\n        if (!t.segsegVertex) {\n            // This happens only for UseSparseVisibilityGraph; in that case we must create the\n            // intersection vertex in the direction of both segments so we can start walking.\n            t.segsegVertex = this.TransUtil.AddVertex(segsegIntersect);\n            const newEdge = this.AddEdgeToClosestSegmentEnd(scanSeg, t.segsegVertex, scanSeg.Weight);\n            this.AddEdgeToClosestSegmentEnd(intSegBefore, t.segsegVertex, intSegBefore.Weight);\n            if (PointComparer.EqualPP(t.segsegVertex.point, edgeIntersect)) {\n                t.targetVertex = t.segsegVertex;\n                return newEdge;\n            }\n        }\n        if (PointComparer.EqualPP(pointLocation, edgeIntersect)) {\n            // The initial pointLocation was on scanSeg and we had to create a new vertex for it,\n            // so we'll find or create (by splitting) the edge on scanSeg that contains pointLocation.\n            t.targetVertex = this.TransUtil.FindOrAddVertex(edgeIntersect);\n            return this.TransUtil.FindOrAddEdge(t.segsegVertex, t.targetVertex, weight);\n        }\n        t.targetVertex = null;\n        return null;\n    }\n    AddEdgeToClosestSegmentEnd(scanSeg, segsegVertex, weight) {\n        // FindOrAddEdge will walk until it finds the minimal bracketing vertices.\n        if (PointComparer.IsPureLower(scanSeg.HighestVisibilityVertex.point, segsegVertex.point)) {\n            return this.TransUtil.FindOrAddEdge(scanSeg.HighestVisibilityVertex, segsegVertex, weight);\n        }\n        if (PointComparer.IsPureLower(segsegVertex.point, scanSeg.LowestVisibilityVertex.point)) {\n            return this.TransUtil.FindOrAddEdge(segsegVertex, scanSeg.LowestVisibilityVertex, weight);\n        }\n        return this.TransUtil.FindOrAddEdgeVV(scanSeg.LowestVisibilityVertex, segsegVertex);\n    }\n    GetPortSpliceLimitRectangle(edgeGeom) {\n        if (!this.LimitPortVisibilitySpliceToEndpointBoundingBox) {\n            this.portSpliceLimitRectangle = this.graphGenerator.ObstacleTree.GraphBox;\n            return;\n        }\n        // Return the endpoint-containing rectangle marking the limits of edge-chain extension for a single path.\n        this.portSpliceLimitRectangle = this.GetPortRectangle(edgeGeom.sourcePort);\n        this.portSpliceLimitRectangle.addRecSelf(this.GetPortRectangle(edgeGeom.targetPort));\n    }\n    GetPortRectangle(port) {\n        const oport = this.obstaclePortMap.get(port);\n        if (oport) {\n            return oport.Obstacle.VisibilityBoundingBox.clone();\n        }\n        // FreePoint.\n        return Rectangle.mkOnPoints([Point.RoundPoint(port.Location)]);\n    }\n    AddToLimitRectangle(location) {\n        if (this.graphGenerator.IsInBoundsP(location)) {\n            this.portSpliceLimitRectangle.add(location);\n        }\n    }\n    FindOrCreateFreePoint(location) {\n        let freePoint = this.freePointMap.get(location);\n        if (!freePoint) {\n            freePoint = new FreePoint(this.TransUtil, location);\n            this.freePointMap.set(location, freePoint);\n        }\n        else {\n            freePoint.GetVertex(this.TransUtil, location);\n        }\n        this.freePointsInGraph.add(freePoint);\n        this.freePointLocationsUsedByRouteEdges.add(location);\n        return freePoint;\n    }\n    // This is private because it depends on LimitRectangle\n    AddFreePointToGraph(location) {\n        // This is a FreePoint, either a Waypoint or a Port not in an Obstacle.Ports list.\n        // We can't modify the Port.Location as the caller owns that, so Point.RoundPoint it\n        // at the point at which we acquire it.\n        location = Point.RoundPoint(location);\n        // If the point already exists before FreePoint creation, there's nothing to do.\n        const vertex = this.VisGraph.FindVertex(location);\n        const freePoint = this.FindOrCreateFreePoint(location);\n        if (vertex != null) {\n            return freePoint;\n        }\n        if (!this.graphGenerator.IsInBoundsP(location)) {\n            this.CreateOutOfBoundsFreePoint(freePoint);\n            return freePoint;\n        }\n        // Vertex is inbounds and does not yet exist.  Possibilities are:\n        //  - point is on one ScanSegment (perhaps a dead-end)\n        //  - point is not on any edge (it's in free space so it's in the middle of some rectangle\n        //    (possibly not closed) formed by ScanSegment intersections)\n        let edge = null;\n        freePoint.IsOverlapped = this.ObstacleTree.PointIsInsideAnObstacle(freePoint.Point, this.HScanSegments.ScanDirection);\n        let scanSegment;\n        this.VScanSegments.FindSegmentContainingPoint(location, true);\n        if (scanSegment != null) {\n            // The location is on one ScanSegment.  Find the intersector and split an edge along the segment\n            // (or extend the VisibilityEdges of the segment in the desired direction).\n            const t = { targetVertex: null };\n            edge = this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(location, scanSegment, location, freePoint.InitialWeight, t);\n        }\n        let edgeDir = Direction.South;\n        if (edge != null) {\n            // The freePoint is on one (but not two) segments, and has already been spliced into\n            // that segment's edge chain.  Add edges laterally to the parallel edges.\n            edgeDir = StaticGraphUtility.EdgeDirectionVE(edge);\n            this.ConnectFreePointToLateralEdge(freePoint, CompassVector.RotateLeft(edgeDir));\n            this.ConnectFreePointToLateralEdge(freePoint, CompassVector.RotateRight(edgeDir));\n        }\n        else {\n            // The freePoint is not on ScanSegment so we must splice to 4 surrounding edges (or it may be on a\n            // TransientVE). Look in each of the 4 directions, trying first to avoid crossing any obstacle\n            // boundaries.  However if we cannot find an edge that does not cross an obstacle boundary, the\n            // freepoint is inside a non-overlapped obstacle, so take a second pass to connect to the nearest\n            // edge regardless of obstacle boundaries.\n            for (let ii = 0; ii < 4; ii++) {\n                this.ConnectFreePointToLateralEdge(freePoint, edgeDir);\n                edgeDir = CompassVector.RotateLeft(edgeDir);\n            }\n        }\n        return freePoint;\n    }\n    CreateOutOfBoundsFreePoint(freePoint) {\n        // For an out of bounds (OOB) point, we'll link one edge from it to the inbounds edge if it's\n        // out of bounds in only one direction; if in two, we'll add a bend. Currently we don't need\n        // to do any more because multiple waypoints are processed as multiple subpaths.\n        const oobLocation = freePoint.Point;\n        const inboundsLocation = this.graphGenerator.MakeInBoundsLocation(oobLocation);\n        const dirFromGraph = PointComparer.GetDirections(inboundsLocation, oobLocation);\n        freePoint.OutOfBoundsDirectionFromGraph = dirFromGraph;\n        if (!PointComparer.IsPureDirectionD(dirFromGraph)) {\n            // It's OOB in two directions so will need a bend, but we know inboundsLocation\n            // is a graph corner so it has a vertex already and we don't need to look up sides.\n            //StaticGraphUtility.Assert((this.VisGraph.FindVertex(inboundsLocation) != null), \"graph corner vertex not found\", this.ObstacleTree, this.VisGraph);\n            freePoint.AddOobEdgesFromGraphCorner(this.TransUtil, inboundsLocation);\n            return;\n        }\n        // We know inboundsLocation is on the nearest graphBox border ScanSegment, so this won't return a\n        // null edge, and we'll just do normal join-to-one-edge handling, extending in the direction to the graph.\n        let inboundsVertex = this.VisGraph.FindVertex(inboundsLocation);\n        const dirToGraph = CompassVector.OppositeDir(dirFromGraph);\n        if (inboundsVertex != null) {\n            freePoint.AddToAdjacentVertex(this.TransUtil, inboundsVertex, dirToGraph, this.portSpliceLimitRectangle);\n        }\n        else {\n            const edge = this.FindorCreateNearestPerpEdgePPDN(oobLocation, inboundsLocation, dirFromGraph, ScanSegment.NormalWeight);\n            if (edge != null) {\n                inboundsVertex = freePoint.AddEdgeToAdjacentEdge(this.TransUtil, edge, dirToGraph, this.portSpliceLimitRectangle);\n            }\n        }\n        // This may be an oob waypoint, in which case we want to add additional edges so we can\n        // go outside graph, cross the waypoint, and come back in.  Shortest-paths will do the\n        // work of determining the optimal path, to avoid backtracking.\n        const inboundsLeftVertex = StaticGraphUtility.FindAdjacentVertex(inboundsVertex, CompassVector.RotateLeft(dirToGraph));\n        if (inboundsLeftVertex != null) {\n            this.TransUtil.ConnectVertexToTargetVertex(freePoint.Vertex, inboundsLeftVertex, dirToGraph, ScanSegment.NormalWeight);\n        }\n        const inboundsRightVertex = StaticGraphUtility.FindAdjacentVertex(inboundsVertex, CompassVector.RotateRight(dirToGraph));\n        if (inboundsRightVertex != null) {\n            this.TransUtil.ConnectVertexToTargetVertex(freePoint.Vertex, inboundsRightVertex, dirToGraph, ScanSegment.NormalWeight);\n        }\n    }\n    ConnectFreePointToLateralEdge(freePoint, lateralDir) {\n        // Turn on pivot vertex to either side to find the next edge to connect to.  If the freepoint is\n        // overlapped (inside an obstacle), just find the closest ScanSegment outside the obstacle and\n        // start extending from there; otherwise, we can have the FreePoint calculate its max visibility.\n        const end = freePoint.IsOverlapped\n            ? this.InBoundsGraphBoxIntersect(freePoint.Point, lateralDir)\n            : freePoint.MaxVisibilityInDirectionForNonOverlappedFreePoint(lateralDir, this.TransUtil);\n        const lateralEdge = this.FindorCreateNearestPerpEdgePPDN(end, freePoint.Point, lateralDir, freePoint.InitialWeight);\n        // There may be no VisibilityEdge between the current point and any adjoining obstacle in that direction.\n        if (lateralEdge != null) {\n            freePoint.AddEdgeToAdjacentEdge(this.TransUtil, lateralEdge, lateralDir, this.portSpliceLimitRectangle);\n        }\n    }\n}\n//# sourceMappingURL=PortManager.js.map","//\n// RectilinearEdgeRouter.cs\n// MSAGL main class for Rectilinear Edge Routing.Routing.\n//\n// Copyright Microsoft Corporation.\nimport { Nudger } from './nudging/Nudger';\nimport { Point } from '../../math/geometry';\nimport { GeomEdge } from '../../layout/core/geomEdge';\nimport { Curve } from '../../math/geometry/curve';\nimport { Ellipse } from '../../math/geometry/ellipse';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { Polyline } from '../../math/geometry/polyline';\nimport { Algorithm } from '../../utils/algorithm';\nimport { ShapeCreator } from '../ShapeCreator';\nimport { SplineRouter } from '../splineRouter';\nimport { MsmtRectilinearPath } from './MsmtRectilinearPath';\nimport { Path } from './nudging/Path';\nimport { Obstacle } from './obstacle';\nimport { PointComparer } from './PointComparer';\nimport { PortManager } from './PortManager';\nimport { SparseVisibilityGraphGenerator } from './SparseVisibiltyGraphGenerator';\nimport { SsstRectilinearPath } from './SsstRectilinearPath';\nimport { Arrowhead } from '../../layout/core/arrowhead';\n// Provides rectilinear edge routing functionality\nexport class RectilinearEdgeRouter extends Algorithm {\n    // If true, route to obstacle centers.  Initially false for greater accuracy with the current\n    // MultiSourceMultiTarget approach.\n    get RouteToCenterOfObstacles() {\n        return this.PortManager.RouteToCenterOfObstacles;\n    }\n    set RouteToCenterOfObstacles(value) {\n        this.PortManager.RouteToCenterOfObstacles = value;\n    }\n    // If true, limits the extension of port visibility splices into the visibility graph to the rectangle defined by\n    // the path endpoints.\n    get LimitPortVisibilitySpliceToEndpointBoundingBox() {\n        return this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox;\n    }\n    set LimitPortVisibilitySpliceToEndpointBoundingBox(value) {\n        this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox = value;\n    }\n    // Add an GeomEdge to route\n    AddEdgeGeometryToRoute(edgeGeometry) {\n        // The Port.Location values are not necessarily rounded by the caller.  The values\n        // will be rounded upon acquisition in PortManager.cs.  PointComparer.Equal expects\n        // all values to be rounded.\n        if (!Point.closeDistEps(Point.RoundPoint(edgeGeometry.sourcePort.Location), Point.RoundPoint(edgeGeometry.targetPort.Location))) {\n            this.EdgesToRoute.push(edgeGeometry);\n        }\n        else {\n            this.selfEdges.push(edgeGeometry);\n        }\n    }\n    // Array all edge routing specifications that are currently active.  We want to hide access to the\n    // Array itself so people don't add or remove items directly.\n    get EdgeGeometriesToRoute() {\n        return this.EdgesToRoute;\n    }\n    // Remove all EdgeGeometries to route\n    RemoveAllEdgeGeometriesToRoute() {\n        // Don't call RemoveEdgeGeometryToRoute as it will interrupt the EdgeGeometries enumerator.\n        this.EdgesToRoute = [];\n    }\n    // If true, this router uses a sparse visibility graph, which saves memory for large graphs but\n    // may choose suboptimal paths.  Set on constructor.\n    get UseSparseVisibilityGraph() {\n        return this.GraphGenerator instanceof SparseVisibilityGraphGenerator;\n    }\n    get Obstacles() {\n        return Array.from(this.ShapeToObstacleMap.values()).map((obs) => obs.InputShape);\n    }\n    // The collection of padded obstacle boundary polylines around the input shapes to route around.\n    get PaddedObstacles() {\n        return Array.from(this.ShapeToObstacleMap.values()).map((obs) => obs.PaddedPolyline);\n    }\n    // Add obstacles to the router.\n    AddObstacles(obstacles) {\n        this.AddShapes(obstacles);\n        this.RebuildTreeAndGraph();\n    }\n    AddShapes(obstacles) {\n        for (const shape of obstacles) {\n            this.AddObstacleWithoutRebuild(shape);\n        }\n    }\n    // Add a single obstacle to the router.\n    AddObstacle(shape) {\n        this.AddObstacleWithoutRebuild(shape);\n        this.RebuildTreeAndGraph();\n    }\n    // For each Shapes, update its position and reroute as necessary.\n    UpdateObstacles(obstacles) {\n        for (const shape of obstacles) {\n            this.UpdateObstacleWithoutRebuild(shape);\n        }\n        this.RebuildTreeAndGraph();\n    }\n    // For each Shapes, update its position and reroute as necessary.\n    UpdateObstacle(obstacle) {\n        this.UpdateObstacleWithoutRebuild(obstacle);\n        this.RebuildTreeAndGraph();\n    }\n    // Remove obstacles from the router.\n    RemoveObstacles(obstacles) {\n        for (const shape of obstacles) {\n            this.RemoveObstacleWithoutRebuild(shape);\n        }\n        this.RebuildTreeAndGraph();\n    }\n    // Removes an obstacle from the router.\n    // <returns>All EdgeGeometries affected by the re-routing and re-nudging in order to avoid the new obstacle.</returns>\n    RemoveObstacle(obstacle) {\n        this.RemoveObstacleWithoutRebuild(obstacle);\n        this.RebuildTreeAndGraph();\n    }\n    // utilities\n    AddObstacleWithoutRebuild(shape) {\n        if (shape.BoundaryCurve == null) {\n            throw new Error('Shape must have a BoundaryCurve');\n        }\n        this.CreatePaddedObstacle(shape);\n    }\n    UpdateObstacleWithoutRebuild(shape) {\n        if (shape.BoundaryCurve == null) {\n            throw new Error('Shape must have a BoundaryCurve');\n        }\n        // Always do all of this even if the Shape objects are the same, because the BoundaryCurve probably changed.\n        this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get(shape));\n        this.CreatePaddedObstacle(shape);\n    }\n    CreatePaddedObstacle(shape) {\n        const obstacle = new Obstacle(shape, this.Padding);\n        this.ShapeToObstacleMap.set(shape, obstacle);\n        this.PortManager.CreateObstaclePorts(obstacle);\n    }\n    RemoveObstacleWithoutRebuild(shape) {\n        const obstacle = this.ShapeToObstacleMap.get(shape);\n        this.ShapeToObstacleMap.delete(shape);\n        this.PortManager.RemoveObstaclePorts(obstacle);\n    }\n    // Remove all obstacles from the graph.\n    RemoveAllObstacles() {\n        this.InternalClear(/* retainObstacles:*/ false);\n    }\n    RebuildTreeAndGraph() {\n        const hadTree = this.ObsTree.Root != null;\n        const hadVg = this.GraphGenerator.VisibilityGraph != null;\n        this.InternalClear(/* retainObstacles:*/ true);\n        if (hadTree) {\n            this.GenerateObstacleTree();\n        }\n        if (hadVg) {\n            this.GenerateVisibilityGraph();\n        }\n    }\n    // The visibility graph generated by GenerateVisibilityGraph.\n    get VisibilityGraph() {\n        this.GenerateVisibilityGraph();\n        return this.GraphGenerator.VisibilityGraph;\n    }\n    // Clears all data set into the router.\n    Clear() {\n        this.InternalClear(/* retainObstacles:*/ false);\n    }\n    static constructorEmpty() {\n        return RectilinearEdgeRouter.constructorC(null);\n        // pass-through default arguments to parameterized ctor\n    }\n    static constructorC(cancelToket) {\n        return new RectilinearEdgeRouter([], RectilinearEdgeRouter.DefaultPadding, RectilinearEdgeRouter.DefaultCornerFitRadius);\n    }\n    // Constructor that takes the obstacles but uses defaults for other arguments.\n    // as well as any intervening obstacles.</param>\n    static constructorI(Obstacle) {\n        return new RectilinearEdgeRouter(Obstacle, RectilinearEdgeRouter.DefaultPadding, RectilinearEdgeRouter.DefaultCornerFitRadius);\n    }\n    // Constructor for a router that does not use obstacle rectangles in the visibility graph.\n    // as well as any intervening obstacles.</param>\n    // The minimum padding from an obstacle's curve to its enclosing polyline.\n    // The radius of the arc inscribed into path corners\n    // but may select suboptimal paths</param>\n    static constructorINN(obstacles, padding, cornerFitRadius) {\n        return new RectilinearEdgeRouter(obstacles, padding, cornerFitRadius);\n    }\n    // Constructor specifying graph and shape information.\n    // as well as any intervening obstacles.</param>\n    // The minimum padding from an obstacle's curve to its enclosing polyline.\n    // The radius of the arc inscribed into path corners\n    // but may select suboptimal paths</param>\n    // Use obstacle bounding boxes in visibility graph\n    constructor(obstacles, padding, cornerFitRadius) {\n        super(null);\n        // If an edge does not connect to an obstacle it should stay away from it at least at the padding distance\n        this.Padding = 0;\n        /**  The radius of the arc inscribed into the path corners. */\n        this.CornerFitRadius = 0;\n        /** the minimal distance between to parrallel segments */\n        this.edgeSeparatian = 3;\n        // The relative penalty of a bend, representated as a percentage of the Manhattan distance between\n        // two ports being connected.\n        this.BendPenaltyAsAPercentageOfDistance = 0;\n        // To support dynamic obstacles, we index obstacles by their Shape, which is\n        // the unpadded inner obstacle boundary and contains a unique ID so we can\n        // handle overlap due to dragging.\n        this.ShapeToObstacleMap = new Map();\n        // The list of EdgeGeometries to route\n        this.EdgesToRoute = new Array();\n        this.removeStaircases = true;\n        this.selfEdges = new Array();\n        this.Padding = padding;\n        this.CornerFitRadius = cornerFitRadius;\n        this.BendPenaltyAsAPercentageOfDistance = SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance;\n        this.GraphGenerator = new SparseVisibilityGraphGenerator();\n        this.PortManager = new PortManager(this.GraphGenerator);\n        this.AddShapes(obstacles);\n    }\n    // The graph whose edges are being routed.\n    // The minimum padding from an obstacle's curve to its enclosing polyline.\n    // The radius of the arc inscribed into path corners\n    // but may select suboptimal paths</param>\n    // If true, use obstacle bounding boxes in visibility graph\n    static constructorGNAN(graph, geomEdges, padding, cornerFitRadius) {\n        const ret = new RectilinearEdgeRouter(ShapeCreator.GetShapes(graph), padding, cornerFitRadius);\n        if (geomEdges == null)\n            for (const edge of graph.deepEdges) {\n                ret.AddEdgeGeometryToRoute(edge);\n            }\n        else {\n            for (const edge of geomEdges) {\n                ret.AddEdgeGeometryToRoute(edge);\n            }\n        }\n        return ret;\n    }\n    // Executes the algorithm.\n    // Calculates the routed edges geometry, optionally forcing re-routing for existing paths.\n    run() {\n        this.GenerateVisibilityGraph();\n        this.GeneratePaths();\n    }\n    GeneratePaths() {\n        const edgePaths = this.EdgesToRoute.map((eg) => new Path(eg));\n        this.FillEdgePathsWithShortestPaths(edgePaths);\n        this.NudgePaths(edgePaths);\n        this.RouteSelfEdges();\n        this.FinaliseEdgeGeometries();\n    }\n    RouteSelfEdges() {\n        for (const edge of this.selfEdges) {\n            const t = { smoothedPolyline: null };\n            edge.curve = GeomEdge.RouteSelfEdge(edge.sourcePort.Curve, Math.max(this.Padding, 2 * edge.GetMaxArrowheadLength()), t);\n        }\n    }\n    FillEdgePathsWithShortestPaths(edgePaths) {\n        this.PortManager.BeginRouteEdges();\n        const shortestPathRouter = new MsmtRectilinearPath(this.BendPenaltyAsAPercentageOfDistance);\n        for (const edgePath of edgePaths) {\n            this.AddControlPointsAndGeneratePath(shortestPathRouter, edgePath);\n        }\n        this.PortManager.EndRouteEdges();\n    }\n    AddControlPointsAndGeneratePath(shortestPathRouter, edgePath) {\n        const intersectPoints = this.PortManager.GetPortVisibilityIntersection(edgePath.GeomEdge);\n        if (intersectPoints != null) {\n            this.GeneratePathThroughVisibilityIntersection(edgePath, intersectPoints);\n            return;\n        }\n        this.SpliceVisibilityAndGeneratePath(shortestPathRouter, edgePath);\n    }\n    GeneratePathThroughVisibilityIntersection(edgePath, intersectPoints) {\n        edgePath.PathPoints = intersectPoints;\n    }\n    SpliceVisibilityAndGeneratePath(shortestPathRouter, edgePath) {\n        this.PortManager.AddControlPointsToGraph(edgePath.GeomEdge, this.ShapeToObstacleMap);\n        // this.PortManager.TransUtil.DevTrace_VerifyAllVertices(this.VisibilityGraph)\n        // this.PortManager.TransUtil.DevTrace_VerifyAllEdgeIntersections(\n        //  this.VisibilityGraph,\n        // )\n        if (!this.GeneratePath(shortestPathRouter, edgePath, false)) {\n            this.RetryPathsWithAdditionalGroupsEnabled(shortestPathRouter, edgePath);\n        }\n        this.PortManager.RemoveControlPointsFromGraph();\n    }\n    // ReSharper disable UnusedMember.Local\n    GeneratePath(shortestPathRouter, edgePath, lastChance) {\n        const sourceVertices = this.PortManager.FindVertices(edgePath.GeomEdge.sourcePort);\n        const targetVertices = this.PortManager.FindVertices(edgePath.GeomEdge.targetPort);\n        return RectilinearEdgeRouter.GetSingleStagePath(edgePath, shortestPathRouter, sourceVertices, targetVertices, lastChance);\n    }\n    static GetSingleStagePath(edgePath, shortestPathRouter, sourceVertices, targetVertices, lastChance) {\n        edgePath.PathPoints = shortestPathRouter.GetPath(sourceVertices, targetVertices);\n        if (lastChance) {\n            RectilinearEdgeRouter.EnsureNonNullPath(edgePath);\n        }\n        return edgePath.PathPoints != null && edgePath.PathPoints.length > 0;\n    }\n    static EnsureNonNullPath(edgePath) {\n        if (edgePath.PathPoints == null) {\n            // Probably a fully-landlocked obstacle such as RectilinearTests.Route_Between_Two_Separately_Landlocked_Obstacles\n            // or disconnected subcomponents due to excessive overlaps, such as Rectilinear(File)Tests.*Disconnected*.  In this\n            // case, just put the single-bend path in there, even though it most likely cuts across unrelated obstacles.\n            if (PointComparer.IsPureDirection(edgePath.GeomEdge.sourcePort.Location, edgePath.GeomEdge.targetPort.Location)) {\n                edgePath.PathPoints = [edgePath.GeomEdge.sourcePort.Location, edgePath.GeomEdge.targetPort.Location];\n            }\n            else {\n                edgePath.PathPoints = [\n                    edgePath.GeomEdge.sourcePort.Location,\n                    new Point(edgePath.GeomEdge.sourcePort.Location.x, edgePath.GeomEdge.targetPort.Location.y),\n                    edgePath.GeomEdge.targetPort.Location,\n                ];\n            }\n        }\n    }\n    RetryPathsWithAdditionalGroupsEnabled(shortestPathRouter, edgePath) {\n        // Insert any spatial parent groups that are not in our hierarchical parent tree and retry,\n        // if we haven't already done this.\n        if (!this.PortManager.SetAllAncestorsActive(edgePath.GeomEdge, this.ShapeToObstacleMap) ||\n            !this.GeneratePath(shortestPathRouter, edgePath, false)) {\n            // Last chance: enable all groups (if we have any).  Only do this on a per-path basis so a single degenerate\n            // path won't make the entire graph look bad.\n            this.PortManager.SetAllGroupsActive();\n            this.GeneratePath(shortestPathRouter, edgePath, true);\n        }\n    }\n    // static ShowPointEnum(p: Iterable<Point>) {\n    //    //  ReSharper disable InconsistentNaming\n    //    const w0: number = 0.1;\n    //    const w1: number = 3;\n    //    let arr: Point[] = p.toArray();\n    //    let d: number = ((w1 - w0)\n    //                / (arr.length - 1));\n    //    let l = new Array<DebugCurve>();\n    //    for (let i: number = 0; (i\n    //                < (arr.length - 1)); i++) {\n    //        l.Add(new DebugCurve(100, (w0\n    //                            + (i * d)), \"blue\", new LineSegment(arr[i], arr[(i + 1)])));\n    //    }\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n    //    //  ReSharper restore InconsistentNaming\n    // }\n    NudgePaths(edgePaths) {\n        // If we adjusted for spatial ancestors, this nudging can get very weird, so refetch in that case.\n        const ancestorSets = this.ObsTree.SpatialAncestorsAdjusted ? SplineRouter.GetAncestorSetsMap(this.Obstacles) : this.AncestorsSets;\n        // Using VisibilityPolyline retains any reflection/staircases on the convex hull borders; using\n        // PaddedPolyline removes them.\n        Nudger.NudgePaths(edgePaths, this.edgeSeparatian, this.PaddedObstacles, ancestorSets, this.RemoveStaircases);\n        // Nudger.NudgePaths(edgePaths, CornerFitRadius, this.ObstacleTree.GetAllPrimaryObstacles().Select(obs => obs.VisibilityPolyline), ancestorSets, RemoveStaircases);\n    }\n    get RemoveStaircases() {\n        return this.removeStaircases;\n    }\n    set RemoveStaircases(value) {\n        this.removeStaircases = value;\n    }\n    FinaliseEdgeGeometries() {\n        for (const edgeGeom of this.EdgesToRoute.concat(this.selfEdges)) {\n            if (edgeGeom.curve == null) {\n                continue;\n            }\n            const poly = edgeGeom.curve instanceof Polyline;\n            if (poly) {\n                edgeGeom.curve = RectilinearEdgeRouter.FitArcsIntoCorners(this.CornerFitRadius, Array.from(edgeGeom.curve));\n            }\n            RectilinearEdgeRouter.CalculateArrowheads(edgeGeom);\n        }\n    }\n    CreateVisibilityGraph() {\n        this.GraphGenerator.Clear();\n        this.InitObstacleTree();\n        this.GraphGenerator.GenerateVisibilityGraph();\n        // if (DebugObject.dumpDebugCurves) DebugObject.dumpDebugCurves('./tmp/rvg.svg', this.mkDC())\n    }\n    // mkDC(): Array<DebugCurve> {\n    //   const dc = new Array<DebugCurve>()\n    //   dc.push(\n    //     ...Array.from(this.VisibilityGraph.Edges).map((e) =>\n    //       DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', LineSegment.mkPP(e.SourcePoint, e.TargetPoint)),\n    //     ),\n    //   )\n    //   dc.push(...this.Obstacles.map((o) => DebugCurve.mkDebugCurveTWCI(100, 2, 'Red', o.BoundaryCurve)))\n    //   return dc\n    // }\n    static CalculateArrowheads(edgeGeom) {\n        Arrowhead.trimSplineAndCalculateArrowheadsII(edgeGeom, edgeGeom.sourcePort.Curve, edgeGeom.targetPort.Curve, edgeGeom.curve, true);\n    }\n    get ObsTree() {\n        return this.GraphGenerator.ObstacleTree;\n    }\n    GenerateObstacleTree() {\n        if (this.Obstacles == null || this.Obstacles.length === 0) {\n            throw new Error('No obstacles have been added');\n        }\n        if (this.ObsTree.Root == null) {\n            this.InitObstacleTree();\n        }\n    }\n    InitObstacleTree() {\n        this.AncestorsSets = SplineRouter.GetAncestorSetsMap(this.Obstacles);\n        this.ObsTree.Init(this.ShapeToObstacleMap.values(), this.AncestorsSets, this.ShapeToObstacleMap);\n    }\n    InternalClear(retainObstacles) {\n        this.GraphGenerator.Clear();\n        this.ClearShortestPaths();\n        if (retainObstacles) {\n            // Remove precalculated visibility, since we're likely revising obstacle positions.\n            this.PortManager.ClearVisibility();\n        }\n        else {\n            this.PortManager.Clear();\n            this.ShapeToObstacleMap.clear();\n            this.EdgesToRoute = [];\n        }\n    }\n    ClearShortestPaths() {\n        for (const edgeGeom of this.EdgesToRoute) {\n            edgeGeom.curve = null;\n        }\n    }\n    GenerateVisibilityGraph() {\n        if (this.Obstacles == null || this.Obstacles.length === 0) {\n            throw new Error('No obstacles have been set');\n        }\n        // Must test GraphGenerator.VisibilityGraph because this.VisibilityGraph calls back to\n        // this function to ensure the graph is present.\n        if (this.GraphGenerator.VisibilityGraph == null) {\n            this.CreateVisibilityGraph();\n        }\n    }\n    // ShowPathWithTakenEdgesAndGraph(path: Iterable<VisibilityVertex>, takenEdges: Set<VisibilityEdge>) {\n    //    let list = new Array<VisibilityVertex>(path);\n    //    let lines = new Array<LineSegment>();\n    //    for (let i: number = 0; (i\n    //                < (list.Count - 1)); i++) {\n    //        lines.Add(new LineSegment(list[i].Point, list[(i + 1)].Point));\n    //    }\n    //    //  ReSharper disable InconsistentNaming\n    //    let w0: number = 4;\n    //    const let w1: number = 8;\n    //    let delta: number = ((w1 - w0)\n    //                / (list.Count - 1));\n    //    let dc = new Array<DebugCurve>();\n    //    for (let line: LineSegment of lines) {\n    //        dc.Add(new DebugCurve(50, w0, \"red\", line));\n    //        w0 = (w0 + delta);\n    //    }\n    //    dc.AddRange(takenEdges.Select(() => {  }, new DebugCurve(50, 2, \"black\", new LineSegment(edge.SourcePoint, edge.TargetPoint))));\n    //    let k: Iterable<DebugCurve> = this.GetGraphDebugCurves();\n    //    dc.AddRange(k);\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dc);\n    //    //  ReSharper restore InconsistentNaming\n    // }\n    static FitArcsIntoCorners(radius, polyline) {\n        if (radius == 0) {\n            return Polyline.mkFromPoints(polyline);\n        }\n        const ellipses = RectilinearEdgeRouter.GetFittedArcSegs(radius, polyline);\n        const curve = new Curve();\n        let prevEllipse = null;\n        for (const ellipse of ellipses) {\n            const ellipseIsAlmostCurve = RectilinearEdgeRouter.EllipseIsAlmostLineSegment(ellipse);\n            if (prevEllipse != null) {\n                if (ellipseIsAlmostCurve) {\n                    Curve.continueWithLineSegmentP(curve, RectilinearEdgeRouter.CornerPoint(ellipse));\n                }\n                else {\n                    Curve.continueWithLineSegmentP(curve, ellipse.start);\n                    curve.addSegment(ellipse);\n                }\n            }\n            else if (ellipseIsAlmostCurve) {\n                Curve.addLineSegment(curve, polyline[0], RectilinearEdgeRouter.CornerPoint(ellipse));\n            }\n            else {\n                Curve.addLineSegment(curve, polyline[0], ellipse.start);\n                curve.addSegment(ellipse);\n            }\n            prevEllipse = ellipse;\n        }\n        if (curve.segs.length > 0) {\n            Curve.continueWithLineSegmentP(curve, polyline[polyline.length - 1]);\n        }\n        else {\n            Curve.addLineSegment(curve, polyline[0], polyline[polyline.length - 1]);\n        }\n        return curve;\n    }\n    static CornerPoint(ellipse) {\n        return ellipse.center.add(ellipse.aAxis.add(ellipse.bAxis));\n    }\n    static EllipseIsAlmostLineSegment(ellipse) {\n        return ellipse.aAxis.lengthSquared < 0.0001 || ellipse.aAxis.lengthSquared < 0.0001;\n    }\n    static *GetFittedArcSegs(radius, polyline) {\n        let leg = polyline[1].sub(polyline[0]);\n        let dir = leg.normalize();\n        let rad0 = Math.min(radius, leg.length / 2);\n        for (let i = 1; i < polyline.length - 1; i++) {\n            leg = polyline[i + 1].sub(polyline[i]);\n            const legLength = leg.length;\n            if (legLength < GeomConstants.intersectionEpsilon) {\n                yield new Ellipse(0, 0, new Point(0, 0), new Point(0, 0), polyline[i]);\n                continue;\n            }\n            const ndir = leg.div(legLength);\n            if (Math.abs(ndir.dot(dir)) > 0.9) {\n                yield new Ellipse(0, 0, new Point(0, 0), new Point(0, 0), polyline[i]);\n            }\n            const nrad0 = Math.min(radius, leg.length / 2);\n            const axis0 = ndir.mul(-nrad0);\n            const axis1 = dir.mul(rad0);\n            yield new Ellipse(0, Math.PI / 2, axis0, axis1, polyline[i].sub(axis1.add(axis0)));\n            dir = ndir;\n            rad0 = nrad0;\n        }\n    }\n}\n// The padding from an obstacle's curve to its enclosing polyline.\nRectilinearEdgeRouter.DefaultPadding = 1;\n// The default radius of the arc inscribed into path corners.\nRectilinearEdgeRouter.DefaultCornerFitRadius = 3;\n//# sourceMappingURL=RectilinearEdgeRouter.js.map","import { Arrowhead } from '../../layout/core/arrowhead';\nimport { RelativeFloatingPort } from '../../layout/core/relativeFloatingPort';\nimport { Point } from '../../math/geometry';\nimport { CornerSite } from '../../math/geometry/cornerSite';\nimport { SmoothedPolyline } from '../../math/geometry/smoothedPolyline';\nimport { RelativeShape } from '../RelativeShape';\nimport { RectilinearEdgeRouter } from './RectilinearEdgeRouter';\nexport class RectilinearInteractiveEditor {\n    static CreatePortsAndRouteEdges(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, ct = null) {\n        const r = RectilinearInteractiveEditor.FillRouter(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode);\n        r.run();\n        RectilinearInteractiveEditor.CreateSelfEdges(Array.from(geometryEdges).filter((e) => e.sourcePort.Location === e.targetPort.Location), cornerFitRadius);\n    }\n    //  Create a RectilinearEdgeRouter from the passed obstacleNodes, with one port at the center of each obstacle,\n    //  and route between the obstacles, with default bend penalty.\n    static CreatePortsAndRouteEdges_(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph, useObstacleRectangles) {\n        RectilinearInteractiveEditor.CreatePortsAndRouteEdges(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode);\n    }\n    //  Create a RectilinearEdgeRouter from the passed obstacleNodes, with one port at the center of each obstacle,\n    //  and route between the obstacles, with default bend penalty.\n    static CreatePortsAndRouteEdges__(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph) {\n        RectilinearInteractiveEditor.CreatePortsAndRouteEdges(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode);\n    }\n    //  Create a RectilinearEdgeRouter populated with the passed obstacles.\n    //  <returns>The populated RectilinearEdgeRouter</returns>\n    static FillRouter(cornerFitRadius, padding, obstacleNodes, geomEdges, edgeRoutingMode) {\n        // Assert.assert(\n        //   EdgeRoutingMode.Rectilinear === edgeRoutingMode || EdgeRoutingMode.RectilinearToCenter === edgeRoutingMode,\n        //   'Non-rectilinear edgeRoutingMode',\n        // )\n        const nodeShapesMap = new Map();\n        RectilinearInteractiveEditor.FillNodeShapesMap(obstacleNodes, geomEdges, nodeShapesMap);\n        const router = new RectilinearEdgeRouter(nodeShapesMap.values(), padding, cornerFitRadius);\n        for (const geomEdge of geomEdges) {\n            geomEdge.sourcePort = first(nodeShapesMap.get(geomEdge.source).Ports);\n            geomEdge.targetPort = first(nodeShapesMap.get(geomEdge.target).Ports);\n            router.AddEdgeGeometryToRoute(geomEdge);\n        }\n        return router;\n    }\n    static FillNodeShapesMap(obstacleNodes, geomEdges, nodeShapeMap) {\n        for (const node of obstacleNodes) {\n            const shape = RectilinearInteractiveEditor.CreateShapeWithRelativeNodeAtCenter(node);\n            nodeShapeMap.set(node, shape);\n        }\n        for (const e of geomEdges) {\n            let node = e.source;\n            if (!nodeShapeMap.has(node)) {\n                nodeShapeMap.set(node, RectilinearInteractiveEditor.CreateShapeWithRelativeNodeAtCenter(node));\n            }\n            node = e.target;\n            if (!nodeShapeMap.has(node)) {\n                nodeShapeMap.set(node, RectilinearInteractiveEditor.CreateShapeWithRelativeNodeAtCenter(node));\n            }\n        }\n    }\n    static CreateSelfEdges(selfEdges, cornerFitRadius) {\n        for (const edge of selfEdges) {\n            RectilinearInteractiveEditor.CreateSimpleEdgeCurveWithGivenFitRadius(edge, cornerFitRadius);\n        }\n    }\n    //\n    static CreateSimpleEdgeCurveWithGivenFitRadius(edge, cornerFitRadius) {\n        const a = edge.source.center;\n        const b = edge.target.center;\n        if (edge.source === edge.target) {\n            const dx = edge.source.boundaryCurve.boundingBox.width / 2;\n            const dy = edge.source.boundingBox.height / 4;\n            edge.smoothedPolyline = RectilinearInteractiveEditor.CreateUnderlyingPolylineForSelfEdge(a, dx, dy);\n            for (let site = edge.smoothedPolyline.headSite.next; site.next != null; site = site.next) {\n                RectilinearInteractiveEditor.CalculateCoefficiensUnderSite(site, cornerFitRadius);\n            }\n            edge.curve = edge.smoothedPolyline.createCurve();\n        }\n        else {\n            edge.smoothedPolyline = SmoothedPolyline.mkFromPoints([a, b]);\n            edge.curve = edge.smoothedPolyline.createCurve();\n        }\n        if (!Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, edge.curve, true)) {\n            Arrowhead.createBigEnoughSpline(edge);\n        }\n    }\n    //  creates an edge curve based only on the source and target geometry\n    static CreateSimpleEdgeCurve(edge) {\n        const a = edge.source.center;\n        const b = edge.target.center;\n        if (edge.source === edge.target) {\n            const dx = edge.source.boundaryCurve.boundingBox.width / 2;\n            const dy = edge.source.boundingBox.height / 4;\n            edge.smoothedPolyline = RectilinearInteractiveEditor.CreateUnderlyingPolylineForSelfEdge(a, dx, dy);\n            edge.curve = edge.smoothedPolyline.createCurve();\n        }\n        else {\n            edge.smoothedPolyline = SmoothedPolyline.mkFromPoints([a, b]);\n            edge.curve = edge.smoothedPolyline.createCurve();\n        }\n        if (!Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, edge.curve, true)) {\n            Arrowhead.createBigEnoughSpline(edge);\n        }\n    }\n    static CreateUnderlyingPolylineForSelfEdge(p0, dx, dy) {\n        const p1 = p0.add(new Point(0, dy));\n        const p2 = p0.add(new Point(dx, dy));\n        const p3 = p0.add(new Point(dx, dy * -1));\n        const p4 = p0.add(new Point(0, dy * -1));\n        let site = CornerSite.mkSiteP(p0);\n        const polyline = new SmoothedPolyline(site);\n        site = CornerSite.mkSiteSP(site, p1);\n        site = CornerSite.mkSiteSP(site, p2);\n        site = CornerSite.mkSiteSP(site, p3);\n        site = CornerSite.mkSiteSP(site, p4);\n        CornerSite.mkSiteSP(site, p0);\n        return polyline;\n    }\n    //  Create a Shape with a single relative port at its center.\n    static CreateShapeWithRelativeNodeAtCenter(node) {\n        const shape = new RelativeShape(node);\n        shape.Ports.add(new RelativeFloatingPort(() => node.boundaryCurve, () => node.center, new Point(0, 0)));\n        return shape;\n    }\n    static CalculateCoefficiensUnderSite(site, radius) {\n        let l = radius / site.point.sub(site.prev.point).length;\n        l = Math.min(0.5, l);\n        site.previouisBezierCoefficient = l;\n        l = radius / site.next.point.sub(site.point).length;\n        l = Math.min(0.5, l);\n        site.nextBezierCoefficient = l;\n    }\n}\nfunction first(collection) {\n    for (const t of collection) {\n        return t;\n    }\n}\n//# sourceMappingURL=RectilinearInteractiveEditor.js.map","import { RBTree } from '../../math/RBTree/rbTree';\nimport { compareBooleans, compareNumbers } from '../../utils/compare';\nimport { LowObstacleSide } from './BasicObstacleSide';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nimport { VisibilityGraphGenerator } from './VisibilityGraphGenerator';\nexport class RectilinearScanLine {\n    constructor(scanDir, start) {\n        this.scanDirection = scanDir;\n        this.SideTree = new RBTree((a, b) => this.Compare(a, b));\n        this.linePositionAtLastInsertOrRemove = start;\n    }\n    Insert(side, scanPos) {\n        //        DevTraceInfo(1, \"prev LinePos = {0}, new LinePos = {1}, inserting side = {2}\", this.linePositionAtLastInsertOrRemove, scanPos, side.ToString());\n        // Assert(!scanDirection.IsFlat(side), \"Flat sides are not allowed in the scanline\");\n        // Assert(null == Find(side), \"side already exists in the ScanLine\");\n        this.linePositionAtLastInsertOrRemove = scanPos;\n        // RBTree's internal operations on insert/remove etc. mean the node can't cache the\n        // RBNode returned by insert(); instead we must do find() on each call.  But we can\n        // use the returned node to get predecessor/successor.\n        const node = this.SideTree.insert(side);\n        // DevTraceDump(2);\n        return node;\n    }\n    get Count() {\n        return this.SideTree.count;\n    }\n    Remove(side, scanPos) {\n        /*Assert.assert(\n          null !=  this.Find(side),\n          'side does not exist in the ScanLine',\n        )*/\n        this.linePositionAtLastInsertOrRemove = scanPos;\n        this.SideTree.remove(side);\n    }\n    Find(side) {\n        // Sides that start after the current position cannot be in the scanline.\n        if (-1 === this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove, side.Start)) {\n            return null;\n        }\n        return this.SideTree.find(side);\n    }\n    NextLowB(side) {\n        return this.NextLowR(this.Find(side));\n    }\n    NextLowR(sideNode) {\n        const pred = this.SideTree.previous(sideNode);\n        return pred;\n    }\n    NextHighB(side) {\n        return this.NextHighR(this.Find(side));\n    }\n    NextHighR(sideNode) {\n        const succ = this.SideTree.next(sideNode);\n        return succ;\n    }\n    Next(dir, sideNode) {\n        const succ = StaticGraphUtility.IsAscending(dir) ? this.SideTree.next(sideNode) : this.SideTree.previous(sideNode);\n        return succ;\n    }\n    Lowest() {\n        return this.SideTree.treeMinimum();\n    }\n    // For ordering lines along the scanline at segment starts/ends.\n    Compare(first, second) {\n        // If these are two sides of the same obstacle then the ordering is obvious.\n        if (first.Obstacle === second.Obstacle) {\n            if (first === second) {\n                return 0;\n            }\n            return first instanceof LowObstacleSide ? -1 : 1;\n        }\n        // RectilinearScanLine.Debug_VerifySidesDoNotIntersect(first, second)\n        // Other than intersecting sides at vertices of the same obstacle, there should be no interior intersections...\n        const firstIntersect = VisibilityGraphGenerator.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove, first, this.scanDirection);\n        const secondIntersect = VisibilityGraphGenerator.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove, second, this.scanDirection);\n        let cmp = firstIntersect.compareTo(secondIntersect);\n        // ... but we may still have rectangular sides that coincide, or angled sides that are close enough here but\n        // are not detected by the convex-hull overlap calculations.  In those cases, we refine the comparison by side\n        // type, with High coming before Low, and then by obstacle ordinal if needed. Because there are no interior\n        // intersections, this ordering will remain valid as long as the side(s) are in the scanline.\n        if (0 === cmp) {\n            const firstIsLow = first instanceof LowObstacleSide;\n            const secondIsLow = second instanceof LowObstacleSide;\n            cmp = compareBooleans(firstIsLow, secondIsLow);\n            if (0 === cmp) {\n                cmp = compareNumbers(first.Obstacle.Ordinal, second.Obstacle.Ordinal);\n            }\n        }\n        return cmp;\n    }\n}\n//# sourceMappingURL=RectilinearScanLine.js.map","import { CompassVector } from '../../math/geometry/compassVector';\nimport { Direction } from '../../math/geometry/direction';\nimport { PointComparer } from './PointComparer';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nexport class ScanDirection {\n    get Dir() {\n        return this.dir;\n    }\n    set Dir(value) {\n        this.dir = value;\n    }\n    // Use the internal static xxxInstance properties to get an instance.\n    constructor(directionAlongScanLine) {\n        /*Assert.assert(\n          StaticGraphUtility.IsAscending(directionAlongScanLine),\n          'directionAlongScanLine must be ascending',\n        )*/\n        this.Dir = directionAlongScanLine;\n        this.DirectionAsPoint = CompassVector.toPoint(this.Dir);\n        this.PerpDirection = Direction.North === directionAlongScanLine ? Direction.East : Direction.North;\n        this.PerpDirectionAsPoint = CompassVector.toPoint(this.PerpDirection);\n        this.OppositeDirection = CompassVector.OppositeDir(directionAlongScanLine);\n    }\n    get IsHorizontal() {\n        return Direction.East === this.Dir;\n    }\n    get IsVertical() {\n        return Direction.North === this.Dir;\n    }\n    // Compare in perpendicular direction first, then parallel direction.\n    Compare(lhs, rhs) {\n        const cmp = this.ComparePerpCoord(lhs, rhs);\n        return 0 !== cmp ? cmp : this.CompareScanCoord(lhs, rhs);\n    }\n    CompareScanCoord(lhs, rhs) {\n        return PointComparer.Compare(lhs.sub(rhs).dot(this.DirectionAsPoint), 0);\n    }\n    ComparePerpCoord(lhs, rhs) {\n        return PointComparer.Compare(lhs.sub(rhs).dot(this.PerpDirectionAsPoint), 0);\n    }\n    IsFlatS(seg) {\n        return this.IsFlatPP(seg.Start, seg.End);\n    }\n    IsFlatPP(start, end) {\n        // Return true if there is no change in the perpendicular direction.\n        return PointComparer.Equal(end.sub(start).dot(this.PerpDirectionAsPoint), 0);\n    }\n    IsPerpendicularS(seg) {\n        return this.IsPerpendicularPP(seg.Start, seg.End);\n    }\n    IsPerpendicularPP(start, end) {\n        // Return true if there is no change in the primary direction.\n        return PointComparer.Equal(end.sub(start).dot(this.DirectionAsPoint), 0);\n    }\n    Coord(point) {\n        return point.dot(this.DirectionAsPoint);\n    }\n    Min(first, second) {\n        return this.Compare(first, second) <= 0 ? first : second;\n    }\n    Max(first, second) {\n        return this.Compare(first, second) >= 0 ? first : second;\n    }\n    get PerpendicularInstance() {\n        return this.IsHorizontal ? ScanDirection.VerticalInstance : ScanDirection.HorizontalInstance;\n    }\n    static GetInstance(dir) {\n        return StaticGraphUtility.IsVerticalD(dir) ? ScanDirection.VerticalInstance : ScanDirection.HorizontalInstance;\n    }\n    ToString() {\n        return this.Dir.toString();\n    }\n}\nScanDirection.HorizontalInstance = new ScanDirection(Direction.East);\nScanDirection.VerticalInstance = new ScanDirection(Direction.North);\n//# sourceMappingURL=ScanDirection.js.map","// import {Curve} from '../../math/geometry/curve'\nimport { Point } from '../../math/geometry/point';\nimport { compareNumbers } from '../../utils/compare';\nimport { SegmentBase } from '../visibility/SegmentBase';\nimport { VisibilityEdge } from '../visibility/VisibilityEdge';\nimport { VisibilityGraph } from '../visibility/VisibilityGraph';\nimport { PointAndCrossingsList } from './PointAndCrossingsList';\nimport { PointComparer } from './PointComparer';\nimport { ScanDirection } from './ScanDirection';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nexport class ScanSegment extends SegmentBase {\n    static mk(start, end) {\n        return new ScanSegment(start, end, ScanSegment.NormalWeight, /* gbcList:*/ null);\n    }\n    constructor(start, end, weight, gbcList) {\n        super();\n        this.Update(start, end);\n        this.Weight = weight;\n        this.GroupBoundaryPointAndCrossingsList = gbcList;\n    }\n    get Start() {\n        return this.startPoint;\n    }\n    get End() {\n        return this.endPoint;\n    }\n    get IsVertical() {\n        return ScanSegment.IsVerticalSegment(this.Start, this.End);\n    }\n    get ScanDirection() {\n        return this.IsVertical ? ScanDirection.VerticalInstance : ScanDirection.HorizontalInstance;\n    }\n    // For overlaps, we will need to create a VisibilityVertex at the junction of overlapped/nonoverlapped\n    // segments, but we don't want to create this for non-overlapped situations.\n    get IsOverlapped() {\n        return ScanSegment.OverlappedWeight === this.Weight;\n    }\n    get IsReflection() {\n        return ScanSegment.ReflectionWeight === this.Weight;\n    }\n    static IsVerticalSegment(start, end) {\n        return start.x === end.x;\n    }\n    MergeGroupBoundaryCrossingList(other) {\n        if (other != null) {\n            if (this.GroupBoundaryPointAndCrossingsList == null) {\n                this.GroupBoundaryPointAndCrossingsList = new PointAndCrossingsList();\n            }\n            this.GroupBoundaryPointAndCrossingsList.MergeFrom(other);\n        }\n    }\n    TrimGroupBoundaryCrossingList() {\n        if (this.GroupBoundaryPointAndCrossingsList != null) {\n            this.GroupBoundaryPointAndCrossingsList.Trim(this.Start, this.End);\n        }\n    }\n    // ctor\n    Update(start, end) {\n        /*Assert.assert(\n          PointComparer.EqualPP(start, end) ||\n            StaticGraphUtility.IsAscending(PointComparer.GetDirections(start, end)),\n          'non-ascending segment',\n        )*/\n        this.startPoint = start;\n        this.endPoint = end;\n    }\n    SetInitialVisibilityVertex(newVertex) {\n        this.LowestVisibilityVertex = newVertex;\n        this.HighestVisibilityVertex = newVertex;\n    }\n    AppendVisibilityVertex(vg, newVertex) {\n        /*Assert.assert(newVertex != null, 'newVertex must not be null')*/\n        /*Assert.assert(\n          (this.LowestVisibilityVertex == null ) ==\n            (this.HighestVisibilityVertex == null ),\n          'Mismatched null Lowest/HighestVisibilityVertex',\n        )*/\n        /*Assert.assert(\n          StaticGraphUtility.PointIsOnSegmentSP(this, newVertex.point),\n          'newVertex is out of segment range',\n        )*/\n        if (this.HighestVisibilityVertex == null) {\n            if (!this.AddGroupCrossingsBeforeHighestVisibilityVertex(vg, newVertex)) {\n                this.SetInitialVisibilityVertex(newVertex);\n            }\n        }\n        else {\n            // In the event of overlaps where ScanSegments share a Start/End at a border, SegmentIntersector\n            // may be appending the same Vertex twice.  If that point is on the border of a group,\n            // then we may have just added the border-crossing edge as well.\n            if (PointComparer.IsPureLower(newVertex.point, this.HighestVisibilityVertex.point)) {\n                /*Assert.assert(\n                  null !=\n                    vg.FindEdgePP(newVertex.point, this.HighestVisibilityVertex.point),\n                  'unexpected low/middle insertion to ScanSegment',\n                )*/\n                return;\n            }\n            // Add the new edge.  This will always be in the ascending direction.\n            if (!this.AddGroupCrossingsBeforeHighestVisibilityVertex(vg, newVertex)) {\n                this.AppendHighestVisibilityVertex(newVertex);\n            }\n        }\n    }\n    AddVisibilityEdge(source, target) {\n        /*Assert.assert(source.point !== target.point, 'Self-edges are not allowed')*/\n        /*Assert.assert(\n          PointComparer.IsPureLower(source.point, target.point),\n          'Impure or reversed direction encountered',\n        )*/\n        // Make sure we aren't adding two edges in the same direction to the same vertex.\n        /*Assert.assert(\n          StaticGraphUtility.FindAdjacentVertex(\n            source,\n            StaticGraphUtility.EdgeDirectionVV(source, target),\n          ) == null ,\n          'Duplicate outEdge from Source vertex',\n        )*/\n        /*Assert.assert(\n          StaticGraphUtility.FindAdjacentVertex(\n            target,\n            StaticGraphUtility.EdgeDirectionVV(target, source),\n          ) == null ,\n          'Duplicate inEdge to Target vertex',\n        )*/\n        const edge = new VisibilityEdge(source, target, this.Weight);\n        VisibilityGraph.AddEdge(edge);\n        return edge;\n    }\n    AppendHighestVisibilityVertex(newVertex) {\n        if (!PointComparer.EqualPP(this.HighestVisibilityVertex.point, newVertex.point)) {\n            this.AddVisibilityEdge(this.HighestVisibilityVertex, newVertex);\n            this.HighestVisibilityVertex = newVertex;\n        }\n    }\n    LoadStartOverlapVertexIfNeeded(vg) {\n        // For adjacent segments with different IsOverlapped, we need a vertex that\n        // joins the two so a path may be run.  This is paired with the other segment's\n        // LoadEndOverlapVertexIfNeeded.\n        if (this.NeedStartOverlapVertex) {\n            const vertex = vg.FindVertex(this.Start);\n            this.AppendVisibilityVertex(vg, vertex !== null && vertex !== void 0 ? vertex : vg.AddVertexP(this.Start));\n        }\n    }\n    LoadEndOverlapVertexIfNeeded(vg) {\n        // See comments in LoadStartOverlapVertexIfNeeded.\n        if (this.NeedEndOverlapVertex) {\n            const vertex = vg.FindVertex(this.End);\n            this.AppendVisibilityVertex(vg, vertex !== null && vertex !== void 0 ? vertex : vg.AddVertexP(this.End));\n        }\n    }\n    OnSegmentIntersectorBegin(vg) {\n        // If we process any group crossings, they'll have created the first point.\n        if (!this.AppendGroupCrossingsThroughPoint(vg, this.Start)) {\n            this.LoadStartOverlapVertexIfNeeded(vg);\n        }\n    }\n    OnSegmentIntersectorEnd(vg) {\n        this.AppendGroupCrossingsThroughPoint(vg, this.End);\n        this.GroupBoundaryPointAndCrossingsList = null;\n        if (this.HighestVisibilityVertex == null || PointComparer.IsPureLower(this.HighestVisibilityVertex.point, this.End)) {\n            this.LoadEndOverlapVertexIfNeeded(vg);\n        }\n    }\n    // If we have collinear segments, then we may be able to just update the previous one\n    // instead of growing the ScanSegmentTree.\n    // - For multiple collinear OpenVertexEvents, neighbors to the high side have not yet\n    //   been seen, so a segment is created that spans the lowest and highest neighbors.\n    //   A subsequent collinear OpenVertexEvent will be to the high side and will add a\n    //   subsegment of that segment, so we subsume it into LastAddedSegment.\n    // - For multiple collinear CloseVertexEvents, closing neighbors to the high side are\n    //   still open, so a segment is created from the lowest neighbor to the next-highest\n    //   collinear obstacle to be closed.  When that next-highest CloseVertexEvent is\n    //   encountered, it will extend LastAddedSegment.\n    // - For multiple collinear mixed Open and Close events, we'll do all Opens first,\n    //   followed by all closes (per EventQueue opening), so we may add multiple discrete\n    //   segments, which ScanSegmentTree will merge.\n    static Subsume(t, newStart, newEnd, weight, gbcList, scanDir, tree, ot) {\n        // Initialize these to the non-subsumed state; the endpoints were extended (or on a\n        // different line).\n        ot.extendStart = true;\n        ot.extendEnd = true;\n        if (t.seg == null) {\n            return false;\n        }\n        // If they don't overlap (including touching at an endpoint), we don't subsume.\n        if (!StaticGraphUtility.IntervalsOverlapPPPP(t.seg.Start, t.seg.End, newStart, newEnd)) {\n            return false;\n        }\n        // If the overlapped-ness isn't the same, we don't subsume.  ScanSegmentTree::MergeSegments\n        // will mark that the low-to-high direction needs a VisibilityVertex to link the two segments.\n        // These may differ by more than Curve.DistanceEpsilon in the case of reflection lookahead\n        // segments collinear with vertex-derived segments, so have a looser tolerance here and we'll\n        // adjust the segments in ScanSegmentTree.MergeSegments.\n        if (t.seg.Weight !== weight) {\n            if (t.seg.Start === newStart && t.seg.End === newEnd) {\n                // This is probably because of a rounding difference by one DistanceEpsilon reporting being\n                // inside an obstacle vs. the scanline intersection calculation side-ordering.\n                // Test is RectilinearFileTests.Overlap_Rounding_Vertex_Intersects_Side.\n                t.seg.Weight = Math.min(t.seg.Weight, weight);\n                return true;\n            }\n            // In the case of groups, we go through the group boundary; this may coincide with a\n            // reflection segment. RectilinearFileTests.ReflectionSubsumedBySegmentExitingGroup.\n            /*Assert.assert(\n              (t.seg.Weight === ScanSegment.OverlappedWeight) ==\n                (weight === ScanSegment.OverlappedWeight) ||\n                Curve.closeIntersectionPoints(t.seg.End, newStart) ||\n                Curve.closeIntersectionPoints(t.seg.Start, newEnd),\n              'non-equal overlap-mismatched ScanSegments overlap by more than just Start/End',\n            )*/\n            return false;\n        }\n        // Subsume the input segment.  Return whether the start/end points were extended (newStart\n        // is before this.Start, or newEnd is after this.End), so the caller can generate reflections\n        // and so we can merge group border crossings.\n        ot.extendStart = -1 === scanDir.CompareScanCoord(newStart, t.seg.Start);\n        ot.extendEnd = 1 === scanDir.CompareScanCoord(newEnd, t.seg.End);\n        if (ot.extendStart || ot.extendEnd) {\n            // We order by start and end so need to replace this in the tree regardless of which end changes.\n            tree.Remove(t.seg);\n            t.seg.startPoint = scanDir.Min(t.seg.Start, newStart);\n            t.seg.endPoint = scanDir.Max(t.seg.End, newEnd);\n            t.seg = tree.InsertUnique(t.seg).item;\n            t.seg.MergeGroupBoundaryCrossingList(gbcList);\n        }\n        return true;\n    }\n    IntersectsSegment(seg) {\n        return StaticGraphUtility.SegmentsIntersection(this, seg) !== undefined;\n    }\n    toString() {\n        return '[' + this.Start + ' -> ' + this.End + (this.IsOverlapped ? ' olap' : ' free') + ']';\n    }\n    ContainsPoint(test) {\n        // This may be off the line so do not use GetPureDirections.\n        return (PointComparer.EqualPP(this.Start, test) ||\n            PointComparer.EqualPP(this.End, test) ||\n            PointComparer.GetDirections(this.Start, test) === PointComparer.GetDirections(test, this.End));\n    }\n    get HasSparsePerpendicularCoords() {\n        return this.sparsePerpendicularCoords == null ? false : this.sparsePerpendicularCoords.size > 0;\n    }\n    CreatePointFromPerpCoord(perpCoord) {\n        return this.IsVertical ? new Point(this.Start.x, perpCoord) : new Point(perpCoord, this.Start.y);\n    }\n    AddSparseVertexCoord(perpCoord) {\n        /*Assert.assert(\n          this.ContainsPoint(this.CreatePointFromPerpCoord(perpCoord)),\n          'vertexLocation is not on Segment',\n        )*/\n        if (this.sparsePerpendicularCoords == null) {\n            this.sparsePerpendicularCoords = new Set();\n        }\n        this.sparsePerpendicularCoords.add(perpCoord);\n    }\n    AddSparseEndpoint(coord) {\n        // This is called after AddSparseVertexCoord so this.sparsePerpendicularCoords is already instantiated.\n        if (!this.sparsePerpendicularCoords.has(coord)) {\n            this.sparsePerpendicularCoords.add(coord);\n            return true;\n        }\n        return false;\n    }\n    CreateSparseVerticesAndEdges(vg) {\n        var _a;\n        if (this.sparsePerpendicularCoords == null) {\n            return;\n        }\n        this.AppendGroupCrossingsThroughPoint(vg, this.Start);\n        for (const perpCoord of Array.from(this.sparsePerpendicularCoords.values()).sort(compareNumbers)) {\n            const vertexLocation = this.CreatePointFromPerpCoord(perpCoord);\n            /*Assert.assert(\n              this.ContainsPoint(vertexLocation),\n              'vertexLocation is not on Segment',\n            )*/\n            this.AppendVisibilityVertex(vg, (_a = vg.FindVertex(vertexLocation)) !== null && _a !== void 0 ? _a : vg.AddVertexP(vertexLocation));\n        }\n        this.AppendGroupCrossingsThroughPoint(vg, this.End);\n        this.GroupBoundaryPointAndCrossingsList = null;\n        this.sparsePerpendicularCoords.clear();\n        this.sparsePerpendicularCoords = null;\n    }\n    HasVisibility() {\n        // Skip this only if it has no visibility vertex.\n        return null != this.LowestVisibilityVertex;\n    }\n    AddGroupCrossingsBeforeHighestVisibilityVertex(vg, newVertex) {\n        if (this.AppendGroupCrossingsThroughPoint(vg, newVertex.point)) {\n            // We may have added an interior vertex that is just higher than newVertex.\n            if (PointComparer.IsPureLower(this.HighestVisibilityVertex.point, newVertex.point)) {\n                this.AddVisibilityEdge(this.HighestVisibilityVertex, newVertex);\n                this.HighestVisibilityVertex = newVertex;\n            }\n            return true;\n        }\n        return false;\n    }\n    AppendGroupCrossingsThroughPoint(vg, lastPoint) {\n        var _a;\n        if (this.GroupBoundaryPointAndCrossingsList == null) {\n            return false;\n        }\n        let found = false;\n        while (this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(lastPoint)) {\n            // We will only create crossing Edges that the segment actually crosses, not those it ends before crossing.\n            // For those terminal crossings, the adjacent segment creates the interior vertex and crossing edge.\n            const pac = this.GroupBoundaryPointAndCrossingsList.Pop();\n            let lowDirCrossings = null;\n            let highDirCrossings = null;\n            if (PointComparer.ComparePP(pac.Location, this.Start) > 0) {\n                lowDirCrossings = PointAndCrossingsList.ToCrossingArray(pac.Crossings, this.ScanDirection.OppositeDirection);\n            }\n            if (PointComparer.ComparePP(pac.Location, this.End) < 0) {\n                highDirCrossings = PointAndCrossingsList.ToCrossingArray(pac.Crossings, this.ScanDirection.Dir);\n            }\n            found = true;\n            const crossingVertex = (_a = vg.FindVertex(pac.Location)) !== null && _a !== void 0 ? _a : vg.AddVertexP(pac.Location);\n            vg.AddVertexP(pac.Location);\n            if (null != lowDirCrossings || null != highDirCrossings) {\n                this.AddLowCrossings(vg, crossingVertex, lowDirCrossings);\n                this.AddHighCrossings(vg, crossingVertex, highDirCrossings);\n            }\n            else {\n                // This is at this.Start with only lower-direction toward group interior(s), or at this.End with only\n                // higher-direction toward group interior(s).  Therefore an adjacent ScanSegment will create the crossing\n                // edge, so create the crossing vertex here and we'll link to it.\n                if (this.LowestVisibilityVertex == null) {\n                    this.SetInitialVisibilityVertex(crossingVertex);\n                }\n                else {\n                    /*Assert.assert(\n                      PointComparer.EqualPP(this.End, crossingVertex.point),\n                      'Expected this.End crossingVertex',\n                    )*/\n                    this.AppendHighestVisibilityVertex(crossingVertex);\n                }\n            }\n        }\n        return found;\n    }\n    static GetCrossingInteriorVertex(vg, crossingVertex, crossing) {\n        var _a;\n        const interiorPoint = crossing.GetInteriorVertexPoint(crossingVertex.point);\n        return (_a = vg.FindVertex(interiorPoint)) !== null && _a !== void 0 ? _a : vg.AddVertexP(interiorPoint);\n    }\n    AddCrossingEdge(vg, lowVertex, highVertex, crossings) {\n        let edge = null;\n        if (null != this.HighestVisibilityVertex) {\n            // We may have a case where point xx.xxxxx8 has added an ascending-direction crossing, and now we're on\n            // xx.xxxxx9 adding a descending-direction crossing.  In that case there should already be a VisibilityEdge\n            // in the direction we want.\n            if (PointComparer.EqualPP(this.HighestVisibilityVertex.point, highVertex.point)) {\n                edge = vg.FindEdgePP(lowVertex.point, highVertex.point);\n                /*Assert.assert(\n                  edge != null,\n                  'Inconsistent forward-backward sequencing in HighVisibilityVertex',\n                )*/\n            }\n            else {\n                this.AppendHighestVisibilityVertex(lowVertex);\n            }\n        }\n        if (edge == null) {\n            edge = this.AddVisibilityEdge(lowVertex, highVertex);\n        }\n        const crossingsArray = crossings.map((c) => c.Group.InputShape);\n        const prevIsPassable = edge.IsPassable;\n        if (prevIsPassable == null) {\n            edge.IsPassable = () => {\n                for (const s of crossingsArray)\n                    if (s.IsTransparent)\n                        return true;\n                return false;\n            };\n        }\n        else {\n            // Because we don't have access to the previous delegate's internals, we have to chain.  Fortunately this\n            // will never be more than two deep.  File Test: Groups_Forward_Backward_Between_Same_Vertices.\n            edge.IsPassable = () => {\n                for (const s of crossingsArray)\n                    if (s.IsTransparent || prevIsPassable())\n                        return true;\n                return false;\n            };\n        }\n        if (this.LowestVisibilityVertex == null) {\n            this.SetInitialVisibilityVertex(lowVertex);\n        }\n        this.HighestVisibilityVertex = highVertex;\n    }\n    AddLowCrossings(vg, crossingVertex, crossings) {\n        if (crossings != null) {\n            const interiorVertex = ScanSegment.GetCrossingInteriorVertex(vg, crossingVertex, crossings[0]);\n            this.AddCrossingEdge(vg, interiorVertex, crossingVertex, crossings);\n            // low-to-high\n        }\n    }\n    AddHighCrossings(vg, crossingVertex, crossings) {\n        if (crossings != null) {\n            const interiorVertex = ScanSegment.GetCrossingInteriorVertex(vg, crossingVertex, crossings[0]);\n            this.AddCrossingEdge(vg, crossingVertex, interiorVertex, crossings);\n            // low-to-high\n        }\n    }\n}\nScanSegment.NormalWeight = VisibilityEdge.DefaultWeight;\nScanSegment.ReflectionWeight = 5;\nScanSegment.OverlappedWeight = 500;\n//# sourceMappingURL=ScanSegment.js.map","import { Point } from '../../math/geometry/point';\nimport { RBTree } from '../../math/RBTree/rbTree';\nimport { PointComparer } from './PointComparer';\nimport { ScanSegment } from './ScanSegment';\nexport class ScanSegmentTree {\n    constructor(scanDir) {\n        // Temporary variables for lookup.\n        this.lookupSegment = ScanSegment.mk(new Point(0, 0), new Point(0, 1));\n        this.ScanDirection = scanDir;\n        this.segmentTree = new RBTree((a, b) => this.Compare(a, b));\n        this.findIntersectorPred = (a) => this.CompareIntersector(a);\n        this.findPointPred = (a) => this.CompareToPoint(a);\n    }\n    get Segments() {\n        return this.segmentTree.allNodes();\n    }\n    // If the seg is already in the tree it returns that instance, else it inserts the new\n    // seg and returns that.\n    InsertUnique(seg) {\n        // RBTree's internal operations on insert/remove etc. mean the node can't cache the\n        // RBNode returned by insert(); instead we must do find() on each call.  But we can\n        // use the returned node to get predecessor/successor.\n        this.AssertValidSegmentForInsertion(seg);\n        const node = this.segmentTree.find(seg);\n        if (node != null) {\n            /*Assert.assert(\n              seg.IsOverlapped === node.item.IsOverlapped,\n              'Existing node found with different isOverlapped',\n            )*/\n            return node;\n        }\n        return this.segmentTree.insert(seg);\n    }\n    AssertValidSegmentForInsertion(seg) {\n        /*Assert.assert(\n          seg.End.x >= seg.Start.x && seg.End.y >= seg.Start.y,\n          'Reversed direction in ScanSegment',\n        )*/\n        /*Assert.assert(\n          this.ScanDirection.IsFlatPP(seg.Start, seg.End),\n          'non-flat segment cannot be inserted',\n        )*/\n    }\n    Remove(seg) {\n        /*Assert.assert(\n          seg.IsVertical === this.ScanDirection.IsVertical,\n          'seg.IsVertical !== this.ScanDirection.IsVertical',\n        )*/\n        this.segmentTree.remove(seg);\n    }\n    Find(start, end) {\n        /*Assert.assert(\n          PointComparer.EqualPP(start, end) ||\n            !this.ScanDirection.IsPerpendicularPP(start, end),\n          'perpendicular segment passed',\n        )*/\n        this.lookupSegment.Update(start, end);\n        const node = this.segmentTree.find(this.lookupSegment);\n        if (null != node && PointComparer.EqualPP(node.item.End, end)) {\n            return node.item;\n        }\n        return null;\n    }\n    // Find the lowest perpendicular scanseg that intersects the segment endpoints.\n    FindLowestIntersector(start, end) {\n        const node = this.FindLowestIntersectorNode(start, end);\n        return null != node ? node.item : null;\n    }\n    FindLowestIntersectorNode(start, end) {\n        /*Assert.assert(\n          this.ScanDirection.IsPerpendicularPP(start, end),\n          'non-perpendicular segment passed',\n        )*/\n        // Find the last segment that starts at or before 'start'.\n        this.lookupSegment.Update(start, start);\n        let node = this.segmentTree.findLast(this.findIntersectorPred);\n        // We have a segment that intersects start/end, or one that ends before 'start' and thus we\n        // must iterate to find the lowest bisector.  TODOperf: see how much that iteration costs us\n        // (here and Highest); consider a BSP tree or interval tree (maybe 2-d RBTree for updatability).\n        if (PointComparer.EqualPP(start, end)) {\n            if (null != node && this.ScanDirection.Compare(node.item.End, start) < 0) {\n                node = null;\n            }\n        }\n        else {\n            this.lookupSegment.Update(start, end);\n            while (null != node && !node.item.IntersectsSegment(this.lookupSegment)) {\n                // If the node segment starts after 'end', no intersection was found.\n                if (this.ScanDirection.Compare(node.item.Start, end) > 0) {\n                    return null;\n                }\n                node = this.segmentTree.next(node);\n            }\n        }\n        return node;\n    }\n    // Find the highest perpendicular scanseg that intersects the segment endpoints.\n    FindHighestIntersector(start, end) {\n        /*Assert.assert(\n          this.ScanDirection.IsPerpendicularPP(start, end),\n          'non-perpendicular segment passed',\n        )*/\n        // Find the last segment that starts at or before 'end'.\n        this.lookupSegment.Update(end, end);\n        let node = this.segmentTree.findLast(this.findIntersectorPred);\n        // Now we either have a segment that intersects start/end, or one that ends before\n        // 'end' and need to iterate to find the highest bisector.\n        if (PointComparer.EqualPP(start, end)) {\n            if (null != node && this.ScanDirection.Compare(node.item.End, start) < 0) {\n                node = null;\n            }\n        }\n        else {\n            this.lookupSegment.Update(start, end);\n            while (null != node && !node.item.IntersectsSegment(this.lookupSegment)) {\n                // If the node segment ends before 'start', no intersection was found.\n                if (this.ScanDirection.Compare(node.item.End, start) < 0) {\n                    return null;\n                }\n                node = this.segmentTree.previous(node);\n            }\n        }\n        return null != node ? node.item : null;\n    }\n    CompareIntersector(seg) {\n        // We're looking for the last segment that starts before LookupSegment.Start.\n        return this.ScanDirection.Compare(seg.Start, this.lookupSegment.Start) <= 0;\n    }\n    FindSegmentContainingPoint(location, allowUnfound) {\n        return this.FindSegmentOverlappingPoints(location, location, allowUnfound);\n    }\n    FindSegmentOverlappingPoints(start, end, allowUnfound) {\n        this.lookupSegment.Update(start, end);\n        const node = this.segmentTree.findFirst(this.findPointPred);\n        // If we had any segments in the tree that end after 'start', node has the first one.\n        // Now we need to that it starts before 'end'.  ScanSegment.CompareToPointPositionFullLength\n        // asserts the point is on the segment which we don't want to require here, so\n        // compare the endpoints directly.\n        if (node != null) {\n            const seg = node.item;\n            if (this.ScanDirection.Compare(seg.Start, end) <= 0) {\n                return seg;\n            }\n        }\n        // Not found.\n        if (!allowUnfound) {\n            /*Assert.assert(false, 'Could not find expected segment')*/\n        }\n        return null;\n    }\n    CompareToPoint(treeSeg) {\n        // Test if treeSeg overlaps the LookupSegment.Start point.  We're using FindFirst,\n        // so we'll just return false for everything that ends before the point and true for anything\n        // that ends at or after it, then the caller will verify overlap.\n        return this.ScanDirection.Compare(treeSeg.End, this.lookupSegment.Start) >= 0;\n    }\n    MergeAndRemoveNextNode(currentSegment, nextSegNode) {\n        // Merge at the ends only - if we're here, start will be the same or greater.\n        if (-1 === this.ScanDirection.Compare(currentSegment.End, nextSegNode.item.End)) {\n            currentSegment.Update(currentSegment.Start, nextSegNode.item.End);\n        }\n        // Removing the node can revise the tree's RBNodes internally so re-get the current segment.\n        currentSegment.MergeGroupBoundaryCrossingList(nextSegNode.item.GroupBoundaryPointAndCrossingsList);\n        this.segmentTree.deleteNodeInternal(nextSegNode);\n        return this.segmentTree.find(currentSegment);\n    }\n    MergeSegments() {\n        if (this.segmentTree.count < 2) {\n            return;\n        }\n        let currentSegNode = this.segmentTree.treeMinimum();\n        let nextSegNode = this.segmentTree.next(currentSegNode);\n        for (; null != nextSegNode; nextSegNode = this.segmentTree.next(currentSegNode)) {\n            const cmp = this.ScanDirection.Compare(nextSegNode.item.Start, currentSegNode.item.End);\n            switch (cmp) {\n                case 1:\n                    // Next segment starts after the current one.\n                    currentSegNode = nextSegNode;\n                    break;\n                case 0:\n                    if (nextSegNode.item.IsOverlapped === currentSegNode.item.IsOverlapped) {\n                        // Overlapping is the same, so merge.  Because the ordering in the tree is that\n                        // same-Start nodes are ordered by longest-End first, this will retain the tree ordering.\n                        currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.item, nextSegNode);\n                    }\n                    else {\n                        // Touching start/end with differing IsOverlapped so they need a connecting vertex.\n                        currentSegNode.item.NeedEndOverlapVertex = true;\n                        nextSegNode.item.NeedStartOverlapVertex = true;\n                        currentSegNode = nextSegNode;\n                    }\n                    break;\n                default:\n                    /*Assert.assert(\n                      nextSegNode.item.Start !== currentSegNode.item.Start ||\n                        nextSegNode.item.End < currentSegNode.item.End,\n                      'Identical segments are not allowed, and longer ones must come first',\n                    )*/\n                    // Because longer segments are ordered before shorter ones at the same start position,\n                    // nextSegNode.Item must be a duplicate segment or is partially or totally overlapped.\n                    // In the case of reflection lookahead segments, the side-intersection calculated from\n                    // horizontal vs. vertical directions may be slightly different along the parallel\n                    // coordinate from an overlapped segment, so let non-overlapped win that disagreement.\n                    if (currentSegNode.item.IsOverlapped !== nextSegNode.item.IsOverlapped) {\n                        /*Assert.assert(\n                          Point.closeIntersections(\n                            currentSegNode.item.End,\n                            nextSegNode.item.Start,\n                          ),\n                          'Segments share a span with different IsOverlapped',\n                        )*/\n                        if (currentSegNode.item.IsOverlapped) {\n                            // If the Starts are different, then currentSegNode is the only item at its\n                            // start, so we don't need to re-insert.  Otherwise, we need to remove it and\n                            // re-find nextSegNode's side.\n                            if (currentSegNode.item.Start === nextSegNode.item.Start) {\n                                // currentSegNode is a tiny overlapped segment between two non-overlapped segments (so\n                                // we'll have another merge later, when we hit the other non-overlapped segment).\n                                // Notice reversed params.  TestNote: No longer have repro with the change to convex hulls;\n                                // this may no longer happen since overlapped edges will now always be inside rectangular\n                                // obstacles so there are no angled-side calculations.\n                                currentSegNode = this.MergeAndRemoveNextNode(nextSegNode.item, currentSegNode);\n                            }\n                            else {\n                                currentSegNode.item.Update(currentSegNode.item.Start, nextSegNode.item.Start);\n                                currentSegNode = nextSegNode;\n                            }\n                        }\n                        else if (currentSegNode.item.End === nextSegNode.item.End) {\n                            // nextSegNode is a tiny non-overlapped segment between two overlapped segments (so\n                            // we'll have another merge later, when we hit the other non-overlapped segment).\n                            // TestNote: No longer have repro with the change to convex hulls;\n                            // this may no longer happen since overlapped edges will now always be inside rectangular\n                            // obstacles so there are no angled-side calculations.\n                            currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.item, nextSegNode);\n                        }\n                        else {\n                            // Remove nextSegNode, increment its start to be after currentSegment, re-insert nextSegNode, and\n                            // re-find currentSegNode (there may be more segments between nextSegment.Start and currentSegment.End).\n                            const nextSegment = nextSegNode.item;\n                            const currentSegment = currentSegNode.item;\n                            this.segmentTree.deleteNodeInternal(nextSegNode);\n                            nextSegment.Update(currentSegment.End, nextSegment.End);\n                            this.segmentTree.insert(nextSegment);\n                            nextSegment.TrimGroupBoundaryCrossingList();\n                            currentSegNode = this.segmentTree.find(currentSegment);\n                        }\n                        break;\n                    }\n                    // Overlaps match so do a normal merge operation.\n                    currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.item, nextSegNode);\n                    break;\n            }\n            // endswitch\n        }\n    }\n    // For ordering the line segments inserted by the ScanLine. Assuming vertical sweep (sweeping up from\n    // bottom, scanning horizontally) then order ScanSegments first by lowest Y coord, then by lowest X coord.\n    Compare(first, second) {\n        if (first === second) {\n            return 0;\n        }\n        if (first == null) {\n            return -1;\n        }\n        if (second == null) {\n            return 1;\n        }\n        // This orders on both axes.\n        let cmp = this.ScanDirection.Compare(first.Start, second.Start);\n        if (0 === cmp) {\n            // Longer segments come first, to make overlap removal easier.\n            cmp = this.ScanDirection.Compare(first.End, second.End) * -1;\n        }\n        return cmp;\n    }\n}\n//# sourceMappingURL=ScanSegmentTree.js.map","// This forms the vector of ScanSegments for the sparse VisibilityGraph.\nimport { ScanSegment } from './ScanSegment';\nimport { ScanSegmentVectorItem } from './ScanSegmentVectorItem';\nexport class ScanSegmentVector {\n    constructor(coordMap, isHorizontal) {\n        // The index of the scan segment vector we're appending to on the ScanSegment-generation sweep.\n        this.CurrentSlotIndex = 0;\n        this.vector = [];\n        this.IsHorizontal = isHorizontal;\n        const coords = Array.from(coordMap).sort((a, b) => (a > b ? 1 : a < b ? -1 : 0));\n        for (const c of coords) {\n            this.vector.push(new ScanSegmentVectorItem(c));\n        }\n    }\n    get Length() {\n        return this.vector.length;\n    }\n    // The item at the index of the scan segment vector we're appending to on the ScanSegment-generation sweep.\n    get CurrentSlot() {\n        return this.vector[this.CurrentSlotIndex];\n    }\n    // The indexed item in the vector.\n    Item(slot) {\n        return this.vector[slot];\n    }\n    // Appends a ScanSegment to the linked list in the \"Current\" slot.\n    CreateScanSegment(start, end, weight, gbcList) {\n        this.CurrentSlot.AppendScanSegment(new ScanSegment(start, end, weight, gbcList));\n    }\n    ScanSegmentsCompleteForCurrentSlot() {\n        this.CurrentSlotIndex++;\n    }\n    ScanSegmentsComplete() {\n        for (const item of this.vector) {\n            item.AddPendingPerpendicularCoordsToScanSegments();\n        }\n    }\n    // Returns an enumeration of the vector of ScanSegmentVectorItems.\n    Items() {\n        return this.vector;\n    }\n    // Reset vector state between passes.\n    ResetForIntersections() {\n        for (const t of this.vector) {\n            t.ResetForIntersections();\n        }\n    }\n    // Search the vector for the nearest slot in the specified direction.\n    FindNearest(coord, directionIfMiss) {\n        // Array.BinarySearch doesn't allow mapping from ScanSegmentVectorItem to its Coord.\n        let low = 0;\n        let high = this.vector.length - 1;\n        if (coord <= this.vector[low].Coord) {\n            return low;\n        }\n        if (coord >= this.vector[high].Coord) {\n            return high;\n        }\n        while (high - low > 2) {\n            const mid = low + ((high - low) >> 1);\n            const item = this.vector[mid];\n            if (coord < item.Coord) {\n                high = mid;\n                continue;\n            }\n            if (coord > item.Coord) {\n                low = mid;\n                continue;\n            }\n            // TODOsparse - profile - see if I really need the perpCoordMap\n            /*Assert.assert(false, 'Should not be here if coord is in the vector')*/\n            return mid;\n        }\n        // We know the value is between low and high, non-inclusive.\n        for (low++; low <= high; low++) {\n            const item = this.vector[low];\n            if (coord < item.Coord) {\n                return directionIfMiss > 0 ? low : low - 1;\n            }\n            if (coord === item.Coord) {\n                break;\n            }\n        }\n        // TODOsparse - profile - see if I really need the perpCoordMap\n        /*Assert.assert(false, 'Should not be here if coord is in the vector')*/\n        return low;\n    }\n    CreateSparseVerticesAndEdges(vg) {\n        for (const item of this.vector) {\n            item.ResetForIntersections();\n            for (let segment = item.FirstSegment; segment != null; segment = segment.NextSegment) {\n                segment.CreateSparseVerticesAndEdges(vg);\n            }\n        }\n    }\n    // Get the coordinate that remains constant along a segment in this vector.\n    GetParallelCoord(site) {\n        return this.IsHorizontal ? site.y : site.x;\n    }\n    // Get the coordinate that changes along a segment in this vector (and is thus the parallel\n    // coord of an intersecting segment).\n    GetPerpendicularCoord(site) {\n        return this.IsHorizontal ? site.x : site.y;\n    }\n    ConnectAdjoiningSegmentEndpoints() {\n        // Make sure that any series of segments (of different overlappedness) that have points in the\n        // graph are connected at adjoining starts/ends and ends/starts (these adjoining points may not be\n        // Steiner points in the graph if they are on indirect segments.\n        for (const item of this.vector) {\n            item.ResetForIntersections();\n            let prevSegment = item.FirstSegment;\n            for (let segment = prevSegment.NextSegment; segment != null; segment = segment.NextSegment) {\n                if (segment.HasSparsePerpendicularCoords && prevSegment.HasSparsePerpendicularCoords) {\n                    if (segment.Start === prevSegment.End) {\n                        const perpCoord = this.GetPerpendicularCoord(segment.Start);\n                        prevSegment.AddSparseEndpoint(perpCoord);\n                        segment.AddSparseEndpoint(perpCoord);\n                    }\n                }\n                prevSegment = segment;\n            }\n        }\n    }\n    toString() {\n        return (this.IsHorizontal ? '(H) count' : '(V) count === ') + this.vector.length;\n    }\n}\n//# sourceMappingURL=ScanSegmentVector.js.map","// This forms one slot in the scan segment vector.\nimport { Point } from '../../math/geometry/point';\nimport { PointComparer } from './PointComparer';\nexport class ScanSegmentVectorItem {\n    AddPendingPerpendicularCoord(coord) {\n        if (this.pendingPerpCoords == null) {\n            this.pendingPerpCoords = new Array();\n        }\n        this.pendingPerpCoords.push(coord);\n    }\n    // Restores state between intersection passes.\n    ResetForIntersections() {\n        /*Assert.assert(null !=  this.FirstSegment, 'Empty ScanSegmentVectorItem')*/\n        this.CurrentSegment = this.FirstSegment;\n    }\n    // Indicates whether ScanSegments in this item are horizontally or vertically oriented.\n    get IsHorizontal() {\n        return !this.FirstSegment.IsVertical;\n    }\n    // Ctor, taking the parallel (constant) coordinate.\n    // the parallel (constant) coordinate\n    constructor(coord) {\n        this.Coord = coord;\n    }\n    // Move along the linked list until we hit the ScanSegment that contains the point.\n    TraverseToSegmentContainingPoint(point) {\n        // This is not a simple Next() because scan segments are extended \"through\" obstacles\n        // (intermixing overlapped and non-overlapped) and thus a ScanSegment's Start and End\n        // may not be in the vertexPoints collection and the ScanSegment must be skipped.\n        if (this.CurrentSegment.ContainsPoint(point)) {\n            return true;\n        }\n        const pointCoord = this.IsHorizontal ? point.y : point.x;\n        if (!PointComparer.Equal(this.Coord, pointCoord)) {\n            /*Assert.assert(\n              PointComparer.Compare(this.Coord, pointCoord) === -1,\n              'point is before current Coord',\n            )*/\n            while (this.MoveNext()) {\n                // Skip to the end of the linked list if this point is not on the same coordinate.\n            }\n            return false;\n        }\n        for (;;) {\n            // In the event of mismatched rounding on horizontal versus vertical intersections\n            // with a sloped obstacle side, we may have a point that is just before or just\n            // after the current segment.  If the point is in some space that doesn't have a\n            // scansegment, and if we are \"close enough\" to one end or the other of a scansegment,\n            // then grow the scansegment enough to include the new point.\n            if (this.CurrentSegment.NextSegment == null ||\n                PointComparer.GetDirections(this.CurrentSegment.End, point) ==\n                    PointComparer.GetDirections(point, this.CurrentSegment.NextSegment.Start)) {\n                if (Point.closeIntersections(this.CurrentSegment.End, point)) {\n                    this.CurrentSegment.Update(this.CurrentSegment.Start, point);\n                    return true;\n                }\n            }\n            if (!this.MoveNext()) {\n                return false;\n            }\n            if (this.CurrentSegment.ContainsPoint(point)) {\n                return true;\n            }\n            // This is likely the reverse of the above; the point rounding mismatched to just before\n            // rather than just after the current segment.\n            if (PointComparer.IsPureLower(point, this.CurrentSegment.Start)) {\n                /*Assert.assert(\n                  Point.closeIntersections(this.CurrentSegment.Start, point),\n                  'Skipped over the point in the ScanSegment linked list',\n                )*/\n                this.CurrentSegment.Update(point, this.CurrentSegment.End);\n                return true;\n            }\n        }\n    }\n    MoveNext() {\n        this.CurrentSegment = this.CurrentSegment.NextSegment;\n        return this.HasCurrent;\n    }\n    get HasCurrent() {\n        return null != this.CurrentSegment;\n    }\n    // Returns true if the point is the end of the current segment and there is an adjoining NextSegment.\n    PointIsCurrentEndAndNextStart(point) {\n        return (point.equal(this.CurrentSegment.End) && null != this.CurrentSegment.NextSegment && point.equal(this.CurrentSegment.NextSegment.Start));\n    }\n    // Set Current to the ScanSegment containing the perpendicular coordinate, then add that coordinate to its\n    // sparse-vector coordinate list.\n    AddPerpendicularCoord(perpCoord) {\n        const point = this.IsHorizontal ? new Point(perpCoord, this.Coord) : new Point(this.Coord, perpCoord);\n        this.TraverseToSegmentContainingPoint(point);\n        this.CurrentSegment.AddSparseVertexCoord(perpCoord);\n    }\n    toString() {\n        if (this.FirstSegment == null) {\n            return '-0- ' + this.Coord;\n        }\n        return this.IsHorizontal ? '(H) Y === ' + this.Coord : '(V) X === ';\n    }\n    AppendScanSegment(segment) {\n        if (this.FirstSegment == null) {\n            this.FirstSegment = segment;\n        }\n        else {\n            // Note: segment.Start may !== Current.End due to skipping internal ScanSegment creation for non-overlapped obstacles.\n            this.CurrentSegment.NextSegment = segment;\n        }\n        this.CurrentSegment = segment;\n    }\n    AddPendingPerpendicularCoordsToScanSegments() {\n        if (this.pendingPerpCoords != null) {\n            this.ResetForIntersections();\n            for (const point of this.pendingPerpCoords) {\n                this.AddPerpendicularCoord(point);\n            }\n        }\n    }\n}\n//# sourceMappingURL=ScanSegmentVectorItem.js.map","// Scan direction is parallel to the sweepline which moves in the perpendicular direction;\n// i.e. scan direction is \"sideways\" along the sweepline.  We do several passes, following Clarkson et al.,\n// \"Rectilinear shortest paths through polygonal obstacles in O(n (log n)2) time\" (checked into the enlistment).\n//   1.  Enumerate all obstacles and load their extreme vertex coordinate projections to the perpendicular axis.\n//   2.  Run a scanline (in each direction) that:\n//      a.  Accumulates the vertices and generates obstacle-related Steiner points.\n//      b.  Generates the ScanSegments.\n//   3.  Iterate in parallel along the ScanSegments and *VertexPoints to determine the sparse intersections\n//       by binary division, as in the paper.\n//   4.  Finally we create the VisibilityVertices and VisibilityEdges along each ScanSegment from its\n//       list of intersections.\n// Differences from the paper largely are due to the paper's creation of non-orthogonal edges along\n// obstacle sides; instead, we create orthogonal edges to the lateral sides of the obstacle's bounding\n// box. Also, we support overlapped obstacles (interior edges are weighted, as in the non-sparse\nimport { Point } from '../../math/geometry/point';\nimport { comparePointsYFirst } from '../../utils/compare';\nimport { PointSet } from '../../utils/PointSet';\nimport { AxisCoordinateEvent } from './AxisCoordinateEvent';\nimport { LowObstacleSide } from './BasicObstacleSide';\nimport { OpenVertexEvent } from './OpenVertexEvent';\nimport { PointComparer } from './PointComparer';\nimport { ScanDirection } from './ScanDirection';\nimport { ScanSegment } from './ScanSegment';\nimport { ScanSegmentVector } from './ScanSegmentVector';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nimport { VisibilityGraphGenerator } from './VisibilityGraphGenerator';\n// implementation) and groups.\nexport class SparseVisibilityGraphGenerator extends VisibilityGraphGenerator {\n    constructor() {\n        super(/* wantReflections:*/ false);\n        // The points of obstacle vertices encountered on horizontal scan.\n        this.horizontalVertexPoints = new PointSet();\n        // The points of obstacle vertices encountered on vertical scan.\n        this.verticalVertexPoints = new PointSet();\n        // The Steiner points generated at the bounding box of obstacles.\n        // These help ensure that we can \"go around\" the obstacle, as with the non-orthogonal edges in the paper.\n        this.boundingBoxSteinerPoints = new PointSet();\n        // Accumulates distinct vertex projections to the X axis during sweep.\n        this.xCoordAccumulator = new Set();\n        // Accumulates distinct vertex projections to the Y axis during sweep.\n        this.yCoordAccumulator = new Set();\n        // The index from a coordinate to a horizontal vector slot.\n        this.horizontalCoordMap = new Map();\n        // The index from a point to a vertical vector slot.\n        this.verticalCoordMap = new Map();\n    }\n    Clear() {\n        super.Clear();\n        this.Cleanup();\n    }\n    Cleanup() {\n        this.horizontalVertexPoints.clear();\n        this.verticalVertexPoints.clear();\n        this.boundingBoxSteinerPoints.clear();\n        this.xCoordAccumulator.clear();\n        this.yCoordAccumulator.clear();\n        this.horizontalCoordMap.clear();\n        this.verticalCoordMap.clear();\n    }\n    // Generate the visibility graph along which edges will be routed.\n    GenerateVisibilityGraph() {\n        this.AccumulateVertexCoords();\n        this.CreateSegmentVectorsAndPopulateCoordinateMaps();\n        this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints();\n        this.GenerateSparseIntersectionsFromVertexPoints();\n        this.CreateScanSegmentTrees();\n        this.Cleanup();\n    }\n    AccumulateVertexCoords() {\n        // Unlike the paper we only generate lines for extreme vertices (i.e. on the horizontal pass we\n        // don't generate a horizontal vertex projection to the Y axis for a vertex that is not on the top\n        // or bottom of the obstacle).  So we can just use the bounding box.\n        for (const obstacle of this.ObstacleTree.GetAllObstacles()) {\n            this.xCoordAccumulator.add(obstacle.VisibilityBoundingBox.left);\n            this.xCoordAccumulator.add(obstacle.VisibilityBoundingBox.right);\n            this.yCoordAccumulator.add(obstacle.VisibilityBoundingBox.top);\n            this.yCoordAccumulator.add(obstacle.VisibilityBoundingBox.bottom);\n        }\n    }\n    CreateSegmentVectorsAndPopulateCoordinateMaps() {\n        this.horizontalScanSegmentVector = new ScanSegmentVector(this.yCoordAccumulator, true);\n        this.verticalScanSegmentVector = new ScanSegmentVector(this.xCoordAccumulator, false);\n        for (let slot = 0; slot < this.horizontalScanSegmentVector.Length; slot++) {\n            this.horizontalCoordMap.set(this.horizontalScanSegmentVector.Item(slot).Coord, slot);\n        }\n        for (let slot = 0; slot < this.verticalScanSegmentVector.Length; slot++) {\n            this.verticalCoordMap.set(this.verticalScanSegmentVector.Item(slot).Coord, slot);\n        }\n    }\n    RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints() {\n        // Do a scanline pass to create scan segments that span the entire height/width of the graph\n        // (mixing overlapped with free segments as needed) and generate the type-2 Steiner points.\n        super.GenerateVisibilityGraph();\n        this.horizontalScanSegmentVector.ScanSegmentsComplete();\n        this.verticalScanSegmentVector.ScanSegmentsComplete();\n        this.xCoordAccumulator.clear();\n        this.yCoordAccumulator.clear();\n    }\n    InitializeEventQueue(scanDir) {\n        super.InitializeEventQueue(scanDir);\n        this.SetVectorsAndCoordMaps(scanDir);\n        this.AddAxisCoordinateEvents(scanDir);\n    }\n    AddAxisCoordinateEvents(scanDir) {\n        // Normal event ordering will apply - and will thus order the ScanSegments created in the vectors.\n        if (scanDir.IsHorizontal) {\n            for (const coord of this.yCoordAccumulator) {\n                this.eventQueue.Enqueue(new AxisCoordinateEvent(new Point(this.ObstacleTree.GraphBox.left - SparseVisibilityGraphGenerator.SentinelOffset, coord)));\n            }\n            return;\n        }\n        for (const coord of this.xCoordAccumulator) {\n            this.eventQueue.Enqueue(new AxisCoordinateEvent(new Point(coord, this.ObstacleTree.GraphBox.bottom - SparseVisibilityGraphGenerator.SentinelOffset)));\n        }\n    }\n    ProcessCustomEvent(evt) {\n        if (!this.ProcessAxisCoordinate(evt)) {\n            this.ProcessCustomEvent(evt);\n        }\n    }\n    ProcessAxisCoordinate(evt) {\n        if (evt instanceof AxisCoordinateEvent) {\n            this.CreateScanSegmentsOnAxisCoordinate(evt.Site);\n            return true;\n        }\n        return false;\n    }\n    InsertPerpendicularReflectionSegment(start, end) {\n        /*Assert.assert(\n          false,\n          'base.wantReflections is false in Sparse mode so this should never be called',\n        )*/\n        // ReSharper disable HeuristicUnreachableCode\n        return false;\n        // ReSharper restore HeuristicUnreachableCode\n    }\n    InsertParallelReflectionSegment(start, end, eventObstacle, lowNborSide, highNborSide, action) {\n        /*Assert.assert(\n          false,\n          'base.wantReflections is false in Sparse mode so this should never be called',\n        )*/\n        // ReSharper disable HeuristicUnreachableCode\n        return false;\n        // ReSharper restore HeuristicUnreachableCode\n    }\n    ProcessVertexEvent(lowSideNode, highSideNode, vertexEvent) {\n        const vertexPoints = this.ScanDirection.IsHorizontal ? this.horizontalVertexPoints : this.verticalVertexPoints;\n        vertexPoints.add(vertexEvent.Site);\n        // For easier reading...\n        const lowNborSide = this.LowNeighborSides.LowNeighbor.item;\n        const highNborSide = this.HighNeighborSides.HighNeighbor.item;\n        const highDir = this.ScanDirection.Dir;\n        const lowDir = this.ScanDirection.OppositeDirection;\n        // Generate the neighbor side intersections, regardless of overlaps; these are the type-2 Steiner points.\n        const lowSteiner = this.ScanLineIntersectSide(vertexEvent.Site, lowNborSide);\n        const highSteiner = this.ScanLineIntersectSide(vertexEvent.Site, highNborSide);\n        // Add the intersections at the neighbor bounding boxes if the intersection is not at a sentinel.\n        // Go in the opposite direction from the neighbor intersection to find the border between the Steiner\n        // point and vertexEvent.Site (unless vertexEvent.Site is inside the bounding box).\n        if (this.ObstacleTree.GraphBox.contains(lowSteiner)) {\n            const bboxIntersectBeforeLowSteiner = StaticGraphUtility.RectangleBorderIntersect(lowNborSide.Obstacle.VisibilityBoundingBox, lowSteiner, highDir);\n            if (PointComparer.IsPureLower(bboxIntersectBeforeLowSteiner, vertexEvent.Site)) {\n                this.boundingBoxSteinerPoints.add(bboxIntersectBeforeLowSteiner);\n            }\n        }\n        if (this.ObstacleTree.GraphBox.contains(highSteiner)) {\n            const bboxIntersectBeforeHighSteiner = StaticGraphUtility.RectangleBorderIntersect(highNborSide.Obstacle.VisibilityBoundingBox, highSteiner, lowDir);\n            if (PointComparer.IsPureLower(vertexEvent.Site, bboxIntersectBeforeHighSteiner)) {\n                this.boundingBoxSteinerPoints.add(bboxIntersectBeforeHighSteiner);\n            }\n        }\n        // Add the corners of the bounding box of the vertex obstacle, if they are visible to the event site.\n        // This ensures that we \"go around\" the obstacle, as with the non-orthogonal edges in the paper.\n        const t = { lowCorner: undefined, highCorner: undefined };\n        SparseVisibilityGraphGenerator.GetBoundingCorners(lowSideNode.item.Obstacle.VisibilityBoundingBox, vertexEvent instanceof OpenVertexEvent, this.ScanDirection.IsHorizontal, t);\n        if (PointComparer.IsPureLower(lowSteiner, t.lowCorner) || lowNborSide.Obstacle.IsInSameClump(vertexEvent.Obstacle)) {\n            vertexPoints.add(t.lowCorner);\n        }\n        if (PointComparer.IsPureLower(t.highCorner, highSteiner) || highNborSide.Obstacle.IsInSameClump(vertexEvent.Obstacle)) {\n            vertexPoints.add(t.highCorner);\n        }\n    }\n    static GetBoundingCorners(boundingBox, isLowSide, isHorizontal, t) {\n        if (isLowSide) {\n            t.lowCorner = boundingBox.leftBottom;\n            t.highCorner = isHorizontal ? boundingBox.rightBottom : boundingBox.leftTop;\n            return;\n        }\n        t.lowCorner = isHorizontal ? boundingBox.leftTop : boundingBox.rightBottom;\n        t.highCorner = boundingBox.rightTop;\n    }\n    CreateScanSegmentsOnAxisCoordinate(site) {\n        this.CurrentGroupBoundaryCrossingMap.Clear();\n        // Iterate the ScanLine and create ScanSegments.  There will always be at least the two sentinel sides.\n        const sideNode = this.scanLine.Lowest();\n        let nextNode = this.scanLine.NextHighR(sideNode);\n        let overlapDepth = 0;\n        let start = site;\n        let isInsideOverlappedObstacle = false;\n        for (; null != nextNode; nextNode = this.scanLine.NextHighR(nextNode)) {\n            if (this.SkipSide(start, nextNode.item)) {\n                continue;\n            }\n            if (nextNode.item.Obstacle.IsGroup) {\n                // Do not create internal group crossings in non-overlapped obstacles.\n                if (overlapDepth === 0 || isInsideOverlappedObstacle) {\n                    this.HandleGroupCrossing(site, nextNode.item);\n                }\n                continue;\n            }\n            const isLowSide = nextNode.item instanceof LowObstacleSide;\n            if (isLowSide) {\n                if (overlapDepth > 0) {\n                    overlapDepth++;\n                    continue;\n                }\n                // We are not overlapped, so create a ScanSegment from the previous side intersection to the\n                // intersection with the side in nextNode.Item.\n                start = this.CreateScanSegment(start, nextNode.item, ScanSegment.NormalWeight);\n                this.CurrentGroupBoundaryCrossingMap.Clear();\n                overlapDepth = 1;\n                isInsideOverlappedObstacle = nextNode.item.Obstacle.isOverlapped;\n                continue;\n            }\n            // This is a HighObstacleSide.  If we've got overlap nesting, decrement the depth.\n            /*Assert.assert(overlapDepth > 0, 'Overlap depth must be positive')*/\n            overlapDepth++;\n            if (overlapDepth > 0) {\n                continue;\n            }\n            // If we are not within an overlapped obstacle, don't bother creating the overlapped ScanSegment\n            // as there will never be visibility connecting to it.\n            start =\n                nextNode.item.Obstacle.isOverlapped || nextNode.item.Obstacle.OverlapsGroupCorner\n                    ? this.CreateScanSegment(start, nextNode.item, ScanSegment.OverlappedWeight)\n                    : this.ScanLineIntersectSide(start, nextNode.item);\n            this.CurrentGroupBoundaryCrossingMap.Clear();\n            isInsideOverlappedObstacle = false;\n        }\n        // The final piece.\n        const end = this.ScanDirection.IsHorizontal\n            ? new Point(this.ObstacleTree.GraphBox.right + SparseVisibilityGraphGenerator.SentinelOffset, start.y)\n            : new Point(start.x, this.ObstacleTree.GraphBox.top + SparseVisibilityGraphGenerator.SentinelOffset);\n        this.parallelSegmentVector.CreateScanSegment(start, end, ScanSegment.NormalWeight, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start, end));\n        this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot();\n    }\n    HandleGroupCrossing(site, groupSide) {\n        if (!this.ScanLineCrossesObstacle(site, groupSide.Obstacle)) {\n            return;\n        }\n        // Here we are always going left-to-right.  As in base.SkipToNeighbor, we don't stop traversal for groups,\n        // neither do we create overlapped edges (unless we're inside a non-group obstacle).  Instead we turn\n        // the boundary crossing on or off based on group membership at ShortestPath-time.  Even though this is\n        // the sparse VG, we always create these edges at group boundaries so we don't skip over them.\n        const dirToInsideOfGroup = groupSide instanceof LowObstacleSide ? this.ScanDirection.Dir : this.ScanDirection.OppositeDirection;\n        const intersect = this.ScanLineIntersectSide(site, groupSide);\n        const crossing = this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, groupSide.Obstacle, dirToInsideOfGroup);\n        // The vertex crossing the edge is perpendicular to the group boundary.  A rectilinear group will also have\n        // an edge parallel to that group boundary that includes the point of that crossing vertex; therefore we must\n        // split that non-crossing edge at that vertex.\n        this.AddPerpendicularCoordForGroupCrossing(intersect);\n        // Similarly, the crossing edge's opposite vertex may be on a perpendicular segment.\n        const interiorPoint = crossing.GetInteriorVertexPoint(intersect);\n        this.AddPerpendicularCoordForGroupCrossing(interiorPoint);\n    }\n    AddPerpendicularCoordForGroupCrossing(intersect) {\n        const nonCrossingPerpSlot = this.FindPerpendicularSlot(intersect, 0);\n        if (-1 !== nonCrossingPerpSlot) {\n            this.perpendicularSegmentVector.Item(nonCrossingPerpSlot).AddPendingPerpendicularCoord(this.parallelSegmentVector.CurrentSlot.Coord);\n        }\n    }\n    SkipSide(start, side) {\n        if (side.Obstacle.IsSentinel) {\n            return true;\n        }\n        // Skip sides of obstacles that we do not actually pass through.\n        const bbox = side.Obstacle.VisibilityBoundingBox;\n        if (this.ScanDirection.IsHorizontal) {\n            return start.y === bbox.bottom || start.y === bbox.top;\n        }\n        return start.x === bbox.left || start.x === bbox.right;\n    }\n    CreateScanSegment(start, side, weight) {\n        const end = this.ScanLineIntersectSide(start, side);\n        if (start !== end) {\n            this.parallelSegmentVector.CreateScanSegment(start, end, weight, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start, end));\n        }\n        return end;\n    }\n    GenerateSparseIntersectionsFromVertexPoints() {\n        this.VisibilityGraph = SparseVisibilityGraphGenerator.NewVisibilityGraph();\n        // Generate the sparse intersections between ScanSegments based upon the ordered vertexPoints.\n        this.GenerateSparseIntersectionsAlongHorizontalAxis();\n        this.GenerateSparseIntersectionsAlongVerticalAxis();\n        this.ConnectAdjoiningScanSegments();\n        // Now each segment has the coordinates all of its intersections, so create the visibility graph.\n        this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph);\n        this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph);\n    }\n    GenerateSparseIntersectionsAlongHorizontalAxis() {\n        this.currentAxisPointComparer = comparePointsYFirst;\n        const vertexPoints = Array.from(this.horizontalVertexPoints.values()).sort(this.currentAxisPointComparer);\n        const bboxSteinerPoints = Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);\n        this.ScanDirection = ScanDirection.HorizontalInstance;\n        this.SetVectorsAndCoordMaps(this.ScanDirection);\n        this.GenerateSparseIntersections(vertexPoints, bboxSteinerPoints);\n    }\n    GenerateSparseIntersectionsAlongVerticalAxis() {\n        this.currentAxisPointComparer = (a, b) => a.compareTo(b);\n        const vertexPoints = Array.from(this.verticalVertexPoints.values()).sort(this.currentAxisPointComparer);\n        const bboxSteinerPoints = Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);\n        this.ScanDirection = ScanDirection.VerticalInstance;\n        this.SetVectorsAndCoordMaps(this.ScanDirection);\n        this.GenerateSparseIntersections(vertexPoints, bboxSteinerPoints);\n    }\n    SetVectorsAndCoordMaps(scanDir) {\n        if (scanDir.IsHorizontal) {\n            this.parallelSegmentVector = this.horizontalScanSegmentVector;\n            this.perpendicularSegmentVector = this.verticalScanSegmentVector;\n            this.perpendicularCoordMap = this.verticalCoordMap;\n        }\n        else {\n            this.parallelSegmentVector = this.verticalScanSegmentVector;\n            this.perpendicularSegmentVector = this.horizontalScanSegmentVector;\n            this.perpendicularCoordMap = this.horizontalCoordMap;\n        }\n    }\n    ConnectAdjoiningScanSegments() {\n        // Ensure there is a vertex at the end/start point of two ScanSegments; these will always differ in overlappedness.\n        this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints();\n        this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints();\n    }\n    GenerateSparseIntersections(vertexPoints, bboxSteinerPoints) {\n        this.perpendicularSegmentVector.ResetForIntersections();\n        this.parallelSegmentVector.ResetForIntersections();\n        // Position the enumerations to the first point.\n        let i = 1;\n        const steinerPointsCounter = { j: 0 };\n        for (const item of this.parallelSegmentVector.Items()) {\n            for (;;) {\n                if (!item.CurrentSegment.ContainsPoint(vertexPoints[i])) {\n                    // Done accumulating intersections for the current segment; move to the next segment.\n                    if (!this.AddSteinerPointsToInterveningSegments(vertexPoints[i], bboxSteinerPoints, steinerPointsCounter, item) ||\n                        !item.TraverseToSegmentContainingPoint(vertexPoints[i])) {\n                        // Done with this vectorItem, move to the next item.\n                        break;\n                    }\n                }\n                this.AddPointsToCurrentSegmentIntersections(bboxSteinerPoints, steinerPointsCounter, item);\n                this.GenerateIntersectionsFromVertexPointForCurrentSegment(vertexPoints[i], item);\n                if (item.PointIsCurrentEndAndNextStart(vertexPoints[i])) {\n                    // MoveNext will always return true because the test to enter this block returned true.\n                    item.MoveNext();\n                    /*Assert.assert(\n                      item.HasCurrent,\n                      'MoveNext ended before EndAndNextStart',\n                    )*/\n                    continue;\n                }\n                if (++i >= vertexPoints.length) {\n                    // No more vertexPoints; we're done.\n                    return;\n                }\n            }\n        }\n        // We should have exited in the \"no more vertexPoints\" case above.\n        /*Assert.assert(false, 'Mismatch in points and segments')*/\n    }\n    AddSteinerPointsToInterveningSegments(currentVertexPoint, bboxSteinerPoints, t, item) {\n        // With overlaps, we may have bboxSteinerPoints on segments that do not contain vertices.\n        while (t.j < bboxSteinerPoints.length && this.currentAxisPointComparer(bboxSteinerPoints[t.j], currentVertexPoint) === -1) {\n            if (!item.TraverseToSegmentContainingPoint(bboxSteinerPoints[t.j])) {\n                // Done with this vectorItem, move to the next item.\n                return false;\n            }\n            this.AddPointsToCurrentSegmentIntersections(bboxSteinerPoints, t, item);\n        }\n        return true;\n    }\n    AddPointsToCurrentSegmentIntersections(pointsToAdd, t, parallelItem) {\n        // The first Steiner point should be in the segment, unless we have a non-orthogonal or overlapped or both situation\n        // that results in no Steiner points having been generated, or Steiner points being generated on a segment that has\n        // the opposite overlap state from the segment containing the corresponding vertex.\n        for (; t.j < pointsToAdd.length && parallelItem.CurrentSegment.ContainsPoint(pointsToAdd[t.j]); t.j++) {\n            const steinerSlot = this.FindPerpendicularSlot(pointsToAdd[t.j], 0);\n            this.AddSlotToSegmentIntersections(parallelItem, steinerSlot);\n        }\n    }\n    GenerateIntersectionsFromVertexPointForCurrentSegment(site, parallelItem) {\n        const perpStartSlot = this.FindPerpendicularSlot(parallelItem.CurrentSegment.Start, 1);\n        const perpEndSlot = this.FindPerpendicularSlot(parallelItem.CurrentSegment.End, -1);\n        const siteSlot = this.FindPerpendicularSlot(site, 0);\n        // See comments in FindIntersectingSlot; we don't add non-extreme vertices in the perpendicular direction\n        // so in some heavily-overlapped scenarios, we may not have any intersections within this scan segment.\n        if (perpStartSlot >= perpEndSlot) {\n            return;\n        }\n        this.AddSlotToSegmentIntersections(parallelItem, perpStartSlot);\n        this.AddSlotToSegmentIntersections(parallelItem, perpEndSlot);\n        if (siteSlot > perpStartSlot && siteSlot < perpEndSlot) {\n            this.AddSlotToSegmentIntersections(parallelItem, siteSlot);\n            this.AddBinaryDivisionSlotsToSegmentIntersections(parallelItem, perpStartSlot, siteSlot, perpEndSlot);\n        }\n    }\n    // These are called when the site may not be in the vector.\n    FindPerpendicularSlot(site, directionIfMiss) {\n        return SparseVisibilityGraphGenerator.FindIntersectingSlot(this.perpendicularSegmentVector, this.perpendicularCoordMap, site, directionIfMiss);\n    }\n    static FindIntersectingSlot(segmentVector, coordMap, site, directionIfMiss) {\n        const coord = segmentVector.GetParallelCoord(site);\n        const slot = coordMap.get(coord);\n        if (slot !== undefined) {\n            return slot;\n        }\n        // There are a few cases where the perpCoord is not in the map:\n        // 1.  The first ScanSegment in a slot will have a Start at the sentinel, which is before the first\n        //     perpendicular segment; similarly, the last ScanSegment in a slot will have an out-of-range End.\n        // 2.  Sequences of overlapped/nonoverlapped scan segments that pass through obstacles.  Their start\n        //     and end points are not in vertexPoints because they were not vertex-derived, so we find the\n        //     closest bracketing coordinates that are in the vectors.\n        // 3.  Non-extreme vertices in the perpendicular direction (e.g. for a triangle, we add the X's of\n        //     the left and right to the coords, but not of the top).\n        // 4.  Non-rectilinear group side intersections.\n        return directionIfMiss === 0 ? -1 : segmentVector.FindNearest(coord, directionIfMiss);\n    }\n    AddSlotToSegmentIntersections(parallelItem, perpSlot) {\n        const perpItem = this.perpendicularSegmentVector.Item(perpSlot);\n        parallelItem.CurrentSegment.AddSparseVertexCoord(perpItem.Coord);\n        perpItem.AddPerpendicularCoord(parallelItem.Coord);\n    }\n    AddBinaryDivisionSlotsToSegmentIntersections(parallelItem, startSlot, siteSlot, endSlot) {\n        // The input parameters' slots have already been added to the segment's coords.\n        // If there was no object to the low or high side, then the start or end slot was already\n        // the graphbox max (0 or perpSegmentVector.Length, respectively).  So start dividing.\n        let low = 0;\n        let high = this.perpendicularSegmentVector.Length - 1;\n        // Terminate when we are one away because we don't have an edge from a point to itself.\n        while (high - low > 1) {\n            const mid = low + Math.floor((high - low) / 2);\n            // We only use the half of the graph that the site is in, so arbitrarily decide that it is\n            // in the lower half if it is at the midpoint.\n            if (siteSlot <= mid) {\n                high = mid;\n                if (siteSlot < high && high <= endSlot) {\n                    this.AddSlotToSegmentIntersections(parallelItem, high);\n                }\n                continue;\n            }\n            low = mid;\n            if (siteSlot > low && low >= startSlot) {\n                this.AddSlotToSegmentIntersections(parallelItem, low);\n            }\n        }\n    }\n    // Create the ScanSegmentTrees that functions as indexes for port-visibility splicing.\n    CreateScanSegmentTrees() {\n        SparseVisibilityGraphGenerator.CreateScanSegmentTree(this.horizontalScanSegmentVector, this.HorizontalScanSegments);\n        SparseVisibilityGraphGenerator.CreateScanSegmentTree(this.verticalScanSegmentVector, this.VerticalScanSegments);\n    }\n    static CreateScanSegmentTree(segmentVector, segmentTree) {\n        for (const item of segmentVector.Items()) {\n            for (let segment = item.FirstSegment; segment != null; segment = segment.NextSegment) {\n                if (segment.HasVisibility()) {\n                    segmentTree.InsertUnique(segment);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=SparseVisibiltyGraphGenerator.js.map","import { Point } from '../../math/geometry/point';\nexport class SpliceUtility {\n    // Most of the original contents of this file have been subsumed into ObstacleTree and TransientGraphUtility.\n    static MungeClosestIntersectionInfo(rayOrigin, closestIntersection, isHorizontal) {\n        const bbox = closestIntersection.seg1.boundingBox;\n        const closest = Point.RoundPoint(closestIntersection.x).clone();\n        return isHorizontal\n            ? new Point(SpliceUtility.MungeIntersect(rayOrigin.x, closest.x, bbox.left, bbox.right), closest.y)\n            : new Point(closest.x, SpliceUtility.MungeIntersect(rayOrigin.y, closest.y, bbox.bottom, bbox.top));\n    }\n    // Make sure that we intersect the object space.\n    static MungeIntersect(site, intersect, start, end) {\n        if (site < intersect) {\n            const min = Math.min(start, end);\n            if (intersect < min) {\n                intersect = min;\n            }\n        }\n        else if (site > intersect) {\n            const max = Math.max(start, end);\n            if (intersect > max) {\n                intersect = max;\n            }\n        }\n        return Point.RoundDouble(intersect);\n    }\n}\n//# sourceMappingURL=SpliceUtility.js.map","// single source single target rectilinear path\nimport { CompassVector } from '../../math/geometry/compassVector';\nimport { Direction } from '../../math/geometry/direction';\nimport { GenericBinaryHeapPriorityQueue } from '../../structs/genericBinaryHeapPriorityQueue';\nimport { closeDistEps, compareNumbers } from '../../utils/compare';\nimport { VertexEntry } from './VertexEntry';\nclass NextNeighbor {\n    constructor() {\n        this.Clear();\n    }\n    Set(v, w) {\n        this.Vertex = v;\n        this.Weight = w;\n    }\n    Clear() {\n        this.Vertex = null;\n        this.Weight = Number.NaN;\n    }\n}\nexport class SsstRectilinearPath {\n    // The cost of the path calculation\n    CombinedCost(length, numberOfBends) {\n        return this.LengthImportance * length + this.BendsImportance * numberOfBends;\n    }\n    TotalCostFromSourceToVertex(length, numberOfBends) {\n        return this.CombinedCost(length, numberOfBends) + this.sourceCostAdjustment;\n    }\n    constructor() {\n        // For consistency and speed, path extensions impose an ordering as in the paper:  straight, right, left.  We\n        // enqueue entries in the reverse order of preference so the latest timestamp will be the preferred direction.\n        // Thus straight-ahead neighbors are in slot 2, right in slot 1, left in slot 0.  (If the target happens\n        // to be to the Left, then the heuristic lookahead score will override the Right preference).\n        // The next neighbors to extend the path to from the current vertex.\n        this.nextNeighbors = [new NextNeighbor(), new NextNeighbor(), new NextNeighbor()];\n        this.LengthImportance = 1;\n        this.BendsImportance = 1;\n    }\n    InitPath(sourceVertexEntries, source, target) {\n        if (source === target || !this.InitEntryDirectionsAtTarget(target)) {\n            return false;\n        }\n        this.Target = target;\n        this.Source = source;\n        const cost = this.TotalCostFromSourceToVertex(0, 0) + this.HeuristicDistanceFromVertexToTarget(source.point, Direction.None);\n        if (cost >= this.upperBoundOnCost) {\n            return false;\n        }\n        // This path starts lower than upperBoundOnCost, so create our structures and process it.\n        this.queue = new GenericBinaryHeapPriorityQueue(compareNumbers);\n        this.visitedVertices = [source];\n        if (sourceVertexEntries == null) {\n            this.EnqueueInitialVerticesFromSource(cost);\n        }\n        else {\n            this.EnqueueInitialVerticesFromSourceEntries(sourceVertexEntries);\n        }\n        return this.queue.count > 0;\n    }\n    InitEntryDirectionsAtTarget(vert) {\n        this.EntryDirectionsToTarget = Direction.None;\n        // This routine is only called once so don't worry about optimizing foreach.\n        for (const edge of vert.OutEdges) {\n            this.EntryDirectionsToTarget = this.EntryDirectionsToTarget | CompassVector.DirectionFromPointToPoint(edge.TargetPoint, vert.point);\n        }\n        for (const edge of vert.InEdges) {\n            this.EntryDirectionsToTarget = this.EntryDirectionsToTarget | CompassVector.DirectionFromPointToPoint(edge.SourcePoint, vert.point);\n        }\n        // If this returns false then the target is isolated.\n        return this.EntryDirectionsToTarget !== Direction.None;\n    }\n    static IsInDirs(direction, dirs) {\n        return direction === (direction & dirs);\n    }\n    MultistageAdjustedCostBound(bestCost) {\n        // Allow an additional bend's cost for intermediate stages so we don't jump out early.\n        return Number.isFinite(bestCost) ? bestCost + this.BendsImportance : bestCost;\n    }\n    // estimation from below for the distance\n    HeuristicDistanceFromVertexToTarget(point, entryDirToVertex) {\n        const vectorToTarget = this.Target.point.sub(point);\n        if (closeDistEps(vectorToTarget.x, 0) && closeDistEps(vectorToTarget.y, 0)) {\n            // We are at the target.\n            return this.targetCostAdjustment;\n        }\n        const dirToTarget = CompassVector.VectorDirection(vectorToTarget);\n        let numberOfBends;\n        if (entryDirToVertex === Direction.None) {\n            entryDirToVertex = Direction.East | (Direction.North | (Direction.West | Direction.South));\n            numberOfBends = this.GetNumberOfBends(entryDirToVertex, dirToTarget);\n        }\n        else {\n            numberOfBends = this.GetNumberOfBends(entryDirToVertex, dirToTarget);\n        }\n        return this.CombinedCost(SsstRectilinearPath.ManhattanDistance(point, this.Target.point), numberOfBends) + this.targetCostAdjustment;\n    }\n    GetNumberOfBends(entryDirToVertex, dirToTarget) {\n        return CompassVector.IsPureDirection(dirToTarget)\n            ? this.GetNumberOfBendsForPureDirection(entryDirToVertex, dirToTarget)\n            : SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, this.EntryDirectionsToTarget);\n    }\n    GetNumberOfBendsForPureDirection(entryDirToVertex, dirToTarget) {\n        if ((dirToTarget & entryDirToVertex) === dirToTarget) {\n            if (SsstRectilinearPath.IsInDirs(dirToTarget, this.EntryDirectionsToTarget)) {\n                return 0;\n            }\n            if (SsstRectilinearPath.IsInDirs(SsstRectilinearPath.Left(dirToTarget), this.EntryDirectionsToTarget) ||\n                SsstRectilinearPath.IsInDirs(SsstRectilinearPath.Right(dirToTarget), this.EntryDirectionsToTarget)) {\n                return 2;\n            }\n            return 4;\n        }\n        return this.GetNumberOfBendsForPureDirection(SsstRectilinearPath.AddOneTurn[entryDirToVertex], dirToTarget) + 1;\n    }\n    static GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, entryDirectionsToTarget) {\n        const a = dirToTarget & entryDirToVertex;\n        if (a === Direction.None) {\n            return (SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, SsstRectilinearPath.AddOneTurn[entryDirToVertex], entryDirectionsToTarget) + 1);\n        }\n        const b = dirToTarget & entryDirectionsToTarget;\n        if (b === Direction.None) {\n            return (SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, SsstRectilinearPath.AddOneTurn[entryDirectionsToTarget]) + 1);\n        }\n        return (a | b) === dirToTarget ? 1 : 2;\n    }\n    static Left(direction) {\n        switch (direction) {\n            case Direction.None:\n                return Direction.None;\n                break;\n            case Direction.North:\n                return Direction.West;\n                break;\n            case Direction.East:\n                return Direction.North;\n                break;\n            case Direction.South:\n                return Direction.East;\n                break;\n            case Direction.West:\n                return Direction.South;\n                break;\n            default:\n                throw new Error('direction');\n                break;\n        }\n    }\n    static Right(direction) {\n        switch (direction) {\n            case Direction.None:\n                return Direction.None;\n                break;\n            case Direction.North:\n                return Direction.East;\n                break;\n            case Direction.East:\n                return Direction.South;\n                break;\n            case Direction.South:\n                return Direction.West;\n                break;\n            case Direction.West:\n                return Direction.North;\n                break;\n            default:\n                throw new Error('direction');\n                break;\n        }\n    }\n    static RestorePathV(t) {\n        return SsstRectilinearPath.RestorePath(t, null);\n    }\n    static RestorePath(t, firstVertexInStage) {\n        if (t.entry == null) {\n            return [];\n        }\n        const list = new Array();\n        let skippedCollinearEntry = false;\n        let lastEntryDir = Direction.None;\n        while (true) {\n            // Reduce unnecessary AxisEdge creations in Nudger by including only bend points, not points in the middle of a segment.\n            if (lastEntryDir === t.entry.Direction) {\n                skippedCollinearEntry = true;\n            }\n            else {\n                skippedCollinearEntry = false;\n                list.push(t.entry.Vertex.point);\n                lastEntryDir = t.entry.Direction;\n            }\n            const previousEntry = t.entry.PreviousEntry;\n            if (previousEntry == null || t.entry.Vertex === firstVertexInStage) {\n                break;\n            }\n            t.entry = previousEntry;\n        }\n        if (skippedCollinearEntry) {\n            list.push(t.entry.Vertex.point);\n        }\n        list.reverse();\n        return list;\n    }\n    QueueReversedEntryToNeighborVertexIfNeeded(bestEntry, entryFromNeighbor, weight) {\n        // If we have a lower-cost path from bestEntry to entryFromNeighbor.PreviousVertex than the cost of entryFromNeighbor,\n        // or bestEntry has degree 1 (it is a dead-end), enqueue a path in the opposite direction (entryFromNeighbor will probably\n        // never be extended from this point).\n        const t = { numberOfBends: 0, length: 0 };\n        const neigVer = entryFromNeighbor.PreviousVertex;\n        const dirToNeighbor = SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigVer, weight, t);\n        if (this.CombinedCost(t.length, t.numberOfBends) < this.CombinedCost(entryFromNeighbor.Length, entryFromNeighbor.NumberOfBends) ||\n            bestEntry.Vertex.Degree === 1) {\n            const cost = this.TotalCostFromSourceToVertex(t.length, t.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(neigVer.point, dirToNeighbor);\n            this.EnqueueEntry(bestEntry, neigVer, t.length, t.numberOfBends, cost);\n        }\n    }\n    UpdateEntryToNeighborVertexIfNeeded(bestEntry, neigEntry, weight) {\n        const t = {\n            numberOfBends: 0,\n            length: 0,\n        };\n        const dirToNeighbor = SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigEntry.Vertex, weight, t);\n        if (this.CombinedCost(t.length, t.numberOfBends) < this.CombinedCost(neigEntry.Length, neigEntry.NumberOfBends)) {\n            const newCost = this.TotalCostFromSourceToVertex(t.length, t.numberOfBends) +\n                this.HeuristicDistanceFromVertexToTarget(neigEntry.Vertex.point, dirToNeighbor);\n            neigEntry.ResetEntry(bestEntry, t.length, t.numberOfBends, newCost);\n            this.queue.DecreasePriority(neigEntry, newCost);\n        }\n    }\n    CreateAndEnqueueEntryToNeighborVertex(bestEntry, neigVer, weight) {\n        const t = { numberOfBends: 0, length: 0 };\n        const dirToNeighbor = SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigVer, weight, t);\n        const cost = this.TotalCostFromSourceToVertex(t.length, t.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(neigVer.point, dirToNeighbor);\n        if (cost < this.upperBoundOnCost) {\n            if (neigVer.VertexEntries == null) {\n                this.visitedVertices.push(neigVer);\n            }\n            this.EnqueueEntry(bestEntry, neigVer, t.length, t.numberOfBends, cost);\n        }\n    }\n    EnqueueEntry(bestEntry, neigVer, length, numberOfBends, cost) {\n        const entry = new VertexEntry(neigVer, bestEntry, length, numberOfBends, cost);\n        neigVer.SetVertexEntry(entry);\n        this.queue.Enqueue(entry, entry.Cost);\n    }\n    static GetLengthAndNumberOfBendsToNeighborVertex(prevEntry, vertex, weight, t) {\n        t.length = prevEntry.Length + SsstRectilinearPath.ManhattanDistance(prevEntry.Vertex.point, vertex.point) * weight;\n        const directionToVertex = CompassVector.DirectionFromPointToPoint(prevEntry.Vertex.point, vertex.point);\n        t.numberOfBends = prevEntry.NumberOfBends;\n        if (prevEntry.Direction !== Direction.None && directionToVertex !== prevEntry.Direction) {\n            t.numberOfBends++;\n        }\n        return directionToVertex;\n    }\n    static ManhattanDistance(a, b) {\n        return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n    }\n    GetPathWithCost(sourceVertexEntries, source, adjustmentToSourceCost, targetVertexEntries, target, adjustmentToTargetCost, priorBestCost) {\n        this.upperBoundOnCost = priorBestCost;\n        this.sourceCostAdjustment = adjustmentToSourceCost;\n        this.targetCostAdjustment = adjustmentToTargetCost;\n        if (!this.InitPath(sourceVertexEntries, source, target)) {\n            return null;\n        }\n        while (this.queue.count > 0) {\n            const bestEntry = this.queue.Dequeue();\n            const bestVertex = bestEntry.Vertex;\n            if (bestVertex === this.Target) {\n                if (targetVertexEntries == null) {\n                    this.Cleanup();\n                    return bestEntry;\n                }\n                // We'll never get a duplicate entry direction here; we either relaxed the cost via UpdateEntryToNeighborIfNeeded\n                // before we dequeued it, or it was closed.  So, we simply remove the direction from the valid target entry directions\n                // and if we get to none, we're done.  We return a null path until the final stage.\n                bestEntry.Direction;\n                if (this.EntryDirectionsToTarget === Direction.None) {\n                    let i = 0;\n                    for (const t of this.Target.VertexEntries) {\n                        targetVertexEntries[i++] = t;\n                    }\n                    this.Cleanup();\n                    return null;\n                }\n                this.upperBoundOnCost = Math.min(this.MultistageAdjustedCostBound(bestEntry.Cost), this.upperBoundOnCost);\n                continue;\n            }\n            // It's safe to close this after removing it from the queue.  Any updateEntryIfNeeded that changes it must come\n            // while it is still on the queue; it is removed from the queue only if it has the lowest cost path, and we have\n            // no negative path weights, so any other path that might try to extend to it after this cannot have a lower cost.\n            bestEntry.IsClosed = true;\n            // PerfNote: Array.ForEach is optimized, but don't use .Where.\n            for (const bendNeighbor of this.nextNeighbors) {\n                bendNeighbor.Clear();\n            }\n            const preferredBendDir = SsstRectilinearPath.Right(bestEntry.Direction);\n            this.ExtendPathAlongInEdges(bestEntry, bestVertex.InEdges, preferredBendDir);\n            this.ExtendPathAlongOutEdges(bestEntry, bestVertex.OutEdges, preferredBendDir);\n            for (const bendNeighbor of this.nextNeighbors) {\n                if (bendNeighbor.Vertex != null) {\n                    this.ExtendPathToNeighborVertex(bestEntry, bendNeighbor.Vertex, bendNeighbor.Weight);\n                }\n            }\n        }\n        // Either there is no path to the target, or we have abandoned the path due to exceeding priorBestCost.\n        if (targetVertexEntries != null && this.Target.VertexEntries != null) {\n            for (let i = 0; i < this.Target.VertexEntries.length; i++) {\n                targetVertexEntries[i] = this.Target.VertexEntries[i];\n            }\n        }\n        this.Cleanup();\n        return null;\n    }\n    ExtendPathAlongInEdges(bestEntry, edges, preferredBendDir) {\n        // Iteration is faster than foreach and much faster than .Where.\n        for (const edge of edges) {\n            this.ExtendPathAlongEdge(bestEntry, edge, true, preferredBendDir);\n        }\n    }\n    ExtendPathAlongOutEdges(bestEntry, edges, preferredBendDir) {\n        // Avoid GetEnumerator overhead.\n        let outEdgeNode = edges.isEmpty() ? null : edges.treeMinimum();\n        for (; outEdgeNode != null; outEdgeNode = edges.next(outEdgeNode)) {\n            this.ExtendPathAlongEdge(bestEntry, outEdgeNode.item, false, preferredBendDir);\n        }\n    }\n    ExtendPathAlongEdge(bestEntry, edge, isInEdges, preferredBendDir) {\n        if (!SsstRectilinearPath.IsPassable(edge)) {\n            return;\n        }\n        // This is after the initial source vertex so PreviousEntry won't be null.\n        const neigVer = isInEdges ? edge.Source : edge.Target;\n        if (neigVer === bestEntry.PreviousVertex) {\n            // For multistage paths, the source may be a waypoint outside the graph boundaries that is collinear\n            // with both the previous and next points in the path; in that case it may have only one degree.\n            // For other cases, we just ignore it and the path will be abandoned.\n            if (bestEntry.Vertex.Degree > 1 || bestEntry.Vertex !== this.Source) {\n                return;\n            }\n            this.ExtendPathToNeighborVertex(bestEntry, neigVer, edge.Weight);\n            return;\n        }\n        // Enqueue in reverse order of preference per comments on NextNeighbor class.\n        const neigDir = CompassVector.DirectionFromPointToPoint(bestEntry.Vertex.point, neigVer.point);\n        let nextNeighbor = this.nextNeighbors[2];\n        if (neigDir !== bestEntry.Direction) {\n            nextNeighbor = this.nextNeighbors[neigDir === preferredBendDir ? 1 : 0];\n        }\n        /*Assert.assert(nextNeighbor.Vertex == null , 'bend neighbor already exists')*/\n        nextNeighbor.Set(neigVer, edge.Weight);\n    }\n    EnqueueInitialVerticesFromSource(cost) {\n        const bestEntry = new VertexEntry(this.Source, null, 0, 0, cost);\n        bestEntry.IsClosed = true;\n        // This routine is only called once so don't worry about optimizing foreach.where\n        for (const edge of this.Source.OutEdges) {\n            if (!SsstRectilinearPath.IsPassable(edge))\n                continue;\n            this.ExtendPathToNeighborVertex(bestEntry, edge.Target, edge.Weight);\n        }\n        for (const edge of this.Source.InEdges) {\n            if (!SsstRectilinearPath.IsPassable(edge))\n                continue;\n            this.ExtendPathToNeighborVertex(bestEntry, edge.Source, edge.Weight);\n        }\n    }\n    EnqueueInitialVerticesFromSourceEntries(sourceEntries) {\n        for (const entry of sourceEntries) {\n            if (entry != null) {\n                this.queue.Enqueue(entry, entry.Cost);\n            }\n        }\n    }\n    ExtendPathToNeighborVertex(bestEntry, neigVer, weight) {\n        const dirToNeighbor = CompassVector.DirectionFromPointToPoint(bestEntry.Vertex.point, neigVer.point);\n        const neigEntry = neigVer.VertexEntries != null ? neigVer.VertexEntries[CompassVector.ToIndex(dirToNeighbor)] : null;\n        if (neigEntry == null) {\n            if (!this.CreateAndEnqueueReversedEntryToNeighborVertex(bestEntry, neigVer, weight)) {\n                this.CreateAndEnqueueEntryToNeighborVertex(bestEntry, neigVer, weight);\n            }\n        }\n        else if (!neigEntry.IsClosed) {\n            this.UpdateEntryToNeighborVertexIfNeeded(bestEntry, neigEntry, weight);\n        }\n    }\n    CreateAndEnqueueReversedEntryToNeighborVertex(bestEntry, neigVer, weight) {\n        // VertexEntries is null for the initial source. Otherwise, if there is already a path into bestEntry's vertex\n        // from neigVer, we're turning back on the path; therefore we have already enqueued the neighbors of neigVer.\n        // However, the path cost includes both path length to the current point and the lookahead; this means that we\n        // may now be coming into the neigVer from the opposite side with an equal score to the previous entry, but\n        // the new path may be going toward the target while the old one (from neigVer to bestEntry) went away from\n        // the target.  So, if we score better going in the opposite direction, enqueue bestEntry->neigVer; ignore\n        // neigVer->bestEntry as it probably won't be extended again.\n        if (bestEntry.Vertex.VertexEntries != null) {\n            const dirFromNeighbor = CompassVector.DirectionFromPointToPoint(neigVer.point, bestEntry.Vertex.point);\n            const entryFromNeighbor = bestEntry.Vertex.VertexEntries[CompassVector.ToIndex(dirFromNeighbor)];\n            if (entryFromNeighbor != null) {\n                /*Assert.assert(\n                  entryFromNeighbor.PreviousVertex === neigVer,\n                  'mismatch in turnback PreviousEntry',\n                )*/\n                /*Assert.assert(\n                  entryFromNeighbor.PreviousEntry.IsClosed,\n                  'turnback PreviousEntry should be closed',\n                )*/\n                this.QueueReversedEntryToNeighborVertexIfNeeded(bestEntry, entryFromNeighbor, weight);\n                return true;\n            }\n        }\n        return false;\n    }\n    static IsPassable(edge) {\n        return edge.IsPassable == null || edge.IsPassable();\n    }\n    Cleanup() {\n        for (const v of this.visitedVertices) {\n            v.RemoveVertexEntries();\n        }\n        this.visitedVertices = [];\n        this.queue = null;\n        // this.TestClearIterations()\n    }\n}\n// Only bends importance needs to be public.\nSsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance = 4;\nSsstRectilinearPath.AddOneTurn = [\n    Direction.None,\n    Direction.North | Direction.East | Direction.West,\n    Direction.North | Direction.East | Direction.South,\n    15,\n    Direction.East | Direction.South | Direction.West,\n    15,\n    15,\n    15,\n    13,\n    15,\n    15,\n    15,\n    15,\n    15,\n    15,\n    15, //15\n];\n//# sourceMappingURL=SsstRectilinearPath.js.map","// import {CompassVector} from '../../math/geometry/compassVector'\nimport { Direction } from '../../math/geometry/direction';\nimport { Point } from '../../math/geometry/point';\nimport { PointComparer } from './PointComparer';\nexport class StaticGraphUtility {\n    // Determine the direction of an edge.\n    static EdgeDirectionVE(edge) {\n        return StaticGraphUtility.EdgeDirectionVV(edge.Source, edge.Target);\n    }\n    static EdgeDirectionVV(source, target) {\n        return PointComparer.GetDirections(source.point, target.point);\n    }\n    static GetEdgeEnd(edge, dir) {\n        const edgeDir = StaticGraphUtility.EdgeDirectionVE(edge);\n        /*Assert.assert(\n          0 !== (dir & (edgeDir | CompassVector.OppositeDir(edgeDir))),\n          'dir is orthogonal to edge',\n        )*/\n        return dir === edgeDir ? edge.Target : edge.Source;\n    }\n    static FindAdjacentVertex(vertex, dir) {\n        // This function finds the next vertex in the desired direction relative to the\n        // current vertex, not necessarily the edge orientation, hence it does not use\n        // EdgeDirection().  This is so the caller can operate on a desired movement\n        // direction without having to track whether we're going forward or backward\n        // through the In/OutEdge chain.\n        for (const edge of vertex.InEdges) {\n            if (PointComparer.GetDirections(vertex.point, edge.SourcePoint) === dir) {\n                return edge.Source;\n            }\n        }\n        // Avoid GetEnumerator overhead.\n        for (const edge of vertex.OutEdges) {\n            if (PointComparer.GetDirections(vertex.point, edge.TargetPoint) === dir) {\n                return edge.Target;\n            }\n        }\n        return null;\n    }\n    static FindAdjacentEdge(a, dir) {\n        for (const edge of a.InEdges) {\n            if (PointComparer.GetDirections(edge.SourcePoint, a.point) === dir) {\n                return edge;\n            }\n        }\n        for (const edge of a.OutEdges) {\n            if (PointComparer.GetDirections(a.point, edge.TargetPoint) === dir) {\n                return edge;\n            }\n        }\n        return null;\n    }\n    static FindBendPointBetween(sourcePoint, targetPoint, finalEdgeDir) {\n        return !StaticGraphUtility.IsVerticalD(finalEdgeDir) ? new Point(sourcePoint.x, targetPoint.y) : new Point(targetPoint.x, sourcePoint.y);\n    }\n    static SegmentIntersectionPPP(first, second, from) {\n        const dir = PointComparer.GetDirections(first, second);\n        return StaticGraphUtility.IsVerticalD(dir) ? new Point(first.x, from.y) : new Point(from.x, first.y);\n    }\n    static SegmentIntersectionSP(seg, from) {\n        return StaticGraphUtility.SegmentIntersectionPPP(seg.Start, seg.End, from);\n    }\n    static SegmentsIntersection(first, second) {\n        return StaticGraphUtility.IntervalsIntersect(first.Start, first.End, second.Start, second.End);\n    }\n    static SegmentsIntersectLL(first, second) {\n        return StaticGraphUtility.IntervalsIntersect(first.start, first.end, second.start, second.end);\n    }\n    static IntervalsOverlapSS(first, second) {\n        return StaticGraphUtility.IntervalsOverlapPPPP(first.Start, first.End, second.Start, second.End);\n    }\n    static IntervalsOverlapPPPP(start1, end1, start2, end2) {\n        return (StaticGraphUtility.IntervalsAreCollinear(start1, end1, start2, end2) &&\n            PointComparer.ComparePP(start1, end2) !== PointComparer.ComparePP(end1, start2));\n    }\n    static IntervalsAreCollinear(start1, end1, start2, end2) {\n        /*Assert.assert(\n          StaticGraphUtility.IsVerticalPP(start1, end1) ==\n            StaticGraphUtility.IsVerticalPP(start2, end2),\n          'segments are not in the same orientation',\n        )*/\n        const vertical = StaticGraphUtility.IsVerticalPP(start1, end1);\n        if (StaticGraphUtility.IsVerticalPP(start2, end2) === vertical) {\n            // This handles touching endpoints as well.\n            return vertical ? PointComparer.Equal(start1.x, start2.x) : PointComparer.Equal(start1.y, start2.y);\n        }\n        return false;\n    }\n    static IntervalsAreSame(start1, end1, start2, end2) {\n        return PointComparer.EqualPP(start1, start2) && PointComparer.EqualPP(end1, end2);\n    }\n    static IntervalsIntersect(firstStart, firstEnd, secondStart, secondEnd) {\n        /*Assert.assert(\n          StaticGraphUtility.IsVerticalPP(firstStart, firstEnd) !=\n            StaticGraphUtility.IsVerticalPP(secondStart, secondEnd),\n          'cannot intersect two parallel segments',\n        )*/\n        const intersect = StaticGraphUtility.SegmentIntersectionPPP(firstStart, firstEnd, secondStart);\n        return StaticGraphUtility.PointIsOnSegmentPPP(firstStart, firstEnd, intersect) &&\n            StaticGraphUtility.PointIsOnSegmentPPP(secondStart, secondEnd, intersect)\n            ? intersect\n            : undefined;\n    }\n    static SegmentIntersectionEP(edge, from) {\n        return StaticGraphUtility.SegmentIntersectionPPP(edge.SourcePoint, edge.TargetPoint, from);\n    }\n    static PointIsOnSegmentPPP(first, second, test) {\n        return (PointComparer.EqualPP(first, test) ||\n            PointComparer.EqualPP(second, test) ||\n            PointComparer.GetDirections(first, test) === PointComparer.GetDirections(test, second));\n    }\n    static PointIsOnSegmentSP(seg, test) {\n        return StaticGraphUtility.PointIsOnSegmentPPP(seg.Start, seg.End, test);\n    }\n    static IsVerticalD(dir) {\n        return 0 !== (dir & (Direction.North | Direction.South));\n    }\n    static IsVerticalE(edge) {\n        return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(edge.SourcePoint, edge.TargetPoint));\n    }\n    static IsVerticalPP(first, second) {\n        return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(first, second));\n    }\n    static IsVertical(seg) {\n        return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(seg.start, seg.end));\n    }\n    static IsAscending(dir) {\n        return (dir & (Direction.North | Direction.East)) !== 0;\n    }\n    static Slope(start, end, scanDir) {\n        // Find the slope relative to scanline - how much scan coord changes per sweep change.\n        const lineDir = end.sub(start);\n        return lineDir.dot(scanDir.PerpDirectionAsPoint) / lineDir.dot(scanDir.DirectionAsPoint);\n    }\n    static SortAscending(a, b) {\n        const dir = PointComparer.GetDirections(a, b);\n        /*Assert.assert(\n          Direction.None === dir || PointComparer.IsPureDirectionD(dir),\n          'SortAscending with impure direction',\n        )*/\n        return Direction.None === dir || StaticGraphUtility.IsAscending(dir) ? [a, b] : [b, a];\n    }\n    static RectangleBorderIntersect(boundingBox, point, dir) {\n        switch (dir) {\n            case Direction.North:\n            case Direction.South:\n                return new Point(point.x, StaticGraphUtility.GetRectangleBound(boundingBox, dir));\n                break;\n            case Direction.East:\n            case Direction.West:\n                return new Point(StaticGraphUtility.GetRectangleBound(boundingBox, dir), point.y);\n                break;\n            default:\n                throw new Error();\n                break;\n        }\n    }\n    static GetRectangleBound(rect, dir) {\n        switch (dir) {\n            case Direction.North:\n                return rect.top;\n                break;\n            case Direction.South:\n                return rect.bottom;\n                break;\n            case Direction.East:\n                return rect.right;\n                break;\n            case Direction.West:\n                return rect.left;\n                break;\n            default:\n                throw new Error();\n                break;\n        }\n    }\n    static RectangleInteriorsIntersect(a, b) {\n        return (PointComparer.Compare(a.bottom, b.top) < 0 &&\n            PointComparer.Compare(b.bottom, a.top) < 0 &&\n            PointComparer.Compare(a.left, b.right) < 0 &&\n            PointComparer.Compare(b.left, a.right) < 0);\n    }\n    static PointIsInRectangleInterior(point, rect) {\n        return (PointComparer.Compare(point.y, rect.top) < 0 &&\n            PointComparer.Compare(rect.bottom, point.y) < 0 &&\n            PointComparer.Compare(point.x, rect.right) < 0 &&\n            PointComparer.Compare(rect.left, point.x) < 0);\n    }\n}\n//# sourceMappingURL=StaticGraphUtility.js.map","import { String } from 'typescript-string-operations';\nimport { Point, CompassVector, Direction, LineSegment } from '../../math/geometry';\nimport { closeDistEps } from '../../utils/compare';\nimport { TollFreeVisibilityEdge } from '../visibility/TollFreeVisibilityEdge';\nimport { VisibilityGraph } from '../visibility/VisibilityGraph';\nimport { GroupBoundaryCrossing } from './GroupBoundaryCrossing';\nimport { PointAndCrossingsList } from './PointAndCrossingsList';\nimport { PointComparer } from './PointComparer';\nimport { ScanSegment } from './ScanSegment';\nimport { SparseVisibilityGraphGenerator } from './SparseVisibiltyGraphGenerator';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nexport class TransientGraphUtility {\n    get ObstacleTree() {\n        return this.GraphGenerator.ObstacleTree;\n    }\n    get VisGraph() {\n        return this.GraphGenerator.VisibilityGraph;\n    }\n    get IsSparseVg() {\n        return this.GraphGenerator instanceof SparseVisibilityGraphGenerator;\n    }\n    constructor(graphGen) {\n        // Vertices added to the graph for routing.\n        this.AddedVertices = new Array();\n        // Edges added to the graph for routing.\n        this.AddedEdges = new Array();\n        // Edges joining two non-transient vertices; these must be replaced.\n        this.edgesToRestore = new Array();\n        this.LimitPortVisibilitySpliceToEndpointBoundingBox = false;\n        this.GraphGenerator = graphGen;\n    }\n    AddVertex(location) {\n        const vertex = this.VisGraph.AddVertexP(location);\n        this.AddedVertices.push(vertex);\n        return vertex;\n    }\n    FindOrAddVertex(location) {\n        const vertex = this.VisGraph.FindVertex(location);\n        return vertex !== null && vertex !== void 0 ? vertex : this.AddVertex(location);\n    }\n    FindOrAddEdgeVV(sourceVertex, targetVertex) {\n        return this.FindOrAddEdge(sourceVertex, targetVertex, ScanSegment.NormalWeight);\n    }\n    FindOrAddEdge(sourceVertex, targetVertex, weight) {\n        // Since we're adding transient edges into the graph, we're not doing full intersection\n        // evaluation; thus there may already be an edge from the source vertex in the direction\n        // of the target vertex, but ending before or after the target vertex.\n        const dirToTarget = PointComparer.GetPureDirectionVV(sourceVertex, targetVertex);\n        // Is there an edge in the chain from sourceVertex in the direction of targetVertex\n        // that brackets targetvertex?\n        //      <sourceVertex> -> ..1.. -> ..2.. <end>   3\n        // Yes if targetVertex is at the x above 1 or 2, No if it is at 3.  If false, bracketSource\n        // will be set to the vertex at <end> (if there are any edges in that direction at all).\n        const t = {\n            bracketSource: undefined,\n            bracketTarget: undefined,\n            splitVertex: undefined,\n        };\n        TransientGraphUtility.GetBrackets(sourceVertex, targetVertex, dirToTarget, t);\n        // If null !=  edge then targetVertex is between bracketSource and bracketTarget and SplitEdge returns the\n        // first half-edge (and weight is ignored as the split uses the edge weight).\n        let edge = this.VisGraph.FindEdgePP(t.bracketSource.point, t.bracketTarget.point);\n        edge = edge != null ? this.SplitEdge(edge, t.splitVertex) : this.CreateEdge(t.bracketSource, t.bracketTarget, weight);\n        return edge;\n    }\n    static GetBrackets(sourceVertex, targetVertex, dirToTarget, t) {\n        // Is there an edge in the chain from sourceVertex in the direction of targetVertex\n        // that brackets targetvertex?\n        //      <sourceVertex> -> ..1.. -> ..2.. <end>   3\n        // Yes if targetVertex is at the x above 1 or 2, No if it is at 3.  If false, bracketSource\n        // will be set to the vertex at <end> (if there are any edges in that direction at all).\n        t.splitVertex = targetVertex;\n        if (!TransientGraphUtility.FindBracketingVertices(sourceVertex, targetVertex.point, dirToTarget, t)) {\n            // No bracketing of targetVertex from sourceVertex but bracketSource has been updated.\n            // Is there a bracket of bracketSource from the targetVertex direction?\n            //                      3   <end> ..2.. <- ..1..   <targetVertex>\n            // Yes if bracketSource is at the x above 1 or 2, No if it is at 3.  If false, bracketTarget\n            // will be set to the vertex at <end> (if there are any edges in that direction at all).\n            // If true, then bracketSource and splitVertex must be updated.\n            const tt = {\n                bracketSource: null,\n                bracketTarget: null,\n            };\n            if (TransientGraphUtility.FindBracketingVertices(targetVertex, sourceVertex.point, CompassVector.OppositeDir(dirToTarget), tt)) {\n                /*Assert.assert(\n                  t.bracketSource === sourceVertex,\n                  'Mismatched bracketing detection',\n                )*/\n                t.bracketSource = tt.bracketTarget;\n                t.splitVertex = sourceVertex;\n            }\n            t.bracketTarget = tt.bracketSource;\n        }\n    }\n    static FindBracketingVertices(sourceVertex, targetPoint, dirToTarget, t) {\n        // Walk from the source to target until we bracket target or there is no nextVertex\n        // in the desired direction.\n        t.bracketSource = sourceVertex;\n        for (;;) {\n            t.bracketTarget = StaticGraphUtility.FindAdjacentVertex(t.bracketSource, dirToTarget);\n            if (t.bracketTarget == null) {\n                break;\n            }\n            if (Point.closeDistEps(t.bracketTarget.point, targetPoint)) {\n                // Desired edge already exists.\n                return true;\n            }\n            if (dirToTarget !== PointComparer.GetDirections(t.bracketTarget.point, targetPoint)) {\n                // bracketTarget is past vertex in the traversal direction.\n                break;\n            }\n            t.bracketSource = t.bracketTarget;\n        }\n        return t.bracketTarget != null;\n    }\n    // DEVTRACE\n    // ReSharper restore InconsistentNaming\n    CreateEdge(first, second, weight) {\n        // All edges in the graph are ascending.\n        let source = first;\n        let target = second;\n        if (!PointComparer.IsPureLower(source.point, target.point)) {\n            source = second;\n            target = first;\n        }\n        const edge = new TollFreeVisibilityEdge(source, target, weight);\n        VisibilityGraph.AddEdge(edge);\n        this.AddedEdges.push(edge);\n        return edge;\n    }\n    RemoveFromGraph() {\n        this.RemoveAddedVertices();\n        this.RemoveAddedEdges();\n        this.RestoreRemovedEdges();\n    }\n    RemoveAddedVertices() {\n        for (const vertex of this.AddedVertices) {\n            // Removing all transient vertices will remove all associated transient edges as well.\n            if (this.VisGraph.FindVertex(vertex.point) != null) {\n                this.VisGraph.RemoveVertex(vertex);\n            }\n        }\n        this.AddedVertices = [];\n    }\n    RemoveAddedEdges() {\n        for (const edge of this.AddedEdges) {\n            // If either vertex was removed, so was the edge, so just check source.\n            if (this.VisGraph.FindVertex(edge.SourcePoint) != null) {\n                VisibilityGraph.RemoveEdge(edge);\n            }\n        }\n        this.AddedEdges = [];\n    }\n    RestoreRemovedEdges() {\n        for (const edge of this.edgesToRestore) {\n            // We should only put TransientVisibilityEdges in this list, and should never encounter\n            // a non-transient edge in the graph after we've replaced it with a transient one, so\n            // the edge should not be in the graph until we re-insert it.\n            /*Assert.assert(\n              !(edge instanceof TollFreeVisibilityEdge),\n              'Unexpected Transient edge',\n            )*/\n            VisibilityGraph.AddEdge(edge);\n        }\n        this.edgesToRestore = [];\n    }\n    FindNextEdge(vertex, dir) {\n        return StaticGraphUtility.FindAdjacentEdge(vertex, dir);\n    }\n    FindPerpendicularOrContainingEdge(startVertex, dir, pointLocation) {\n        // Return the edge in 'dir' from startVertex that is perpendicular to pointLocation.\n        // startVertex must therefore be located such that pointLocation is in 'dir' direction from it,\n        // or is on the same line.\n        // StaticGraphUtility.Assert((0\n        //                === (CompassVector.OppositeDir(dir) & PointComparer.GetDirections(startVertex.point, pointLocation))), \"the ray from 'dir' is away from pointLocation\", this.ObstacleTree, this.VisGraph);\n        while (true) {\n            const nextVertex = StaticGraphUtility.FindAdjacentVertex(startVertex, dir);\n            if (nextVertex == null) {\n                break;\n            }\n            const dirCheck = PointComparer.GetDirections(nextVertex.point, pointLocation);\n            // If the next vertex is past the intersection with pointLocation, this edge brackets it.\n            if (0 !== (CompassVector.OppositeDir(dir) & dirCheck)) {\n                return this.VisGraph.FindEdgePP(startVertex.point, nextVertex.point);\n            }\n            startVertex = nextVertex;\n        }\n        return null;\n    }\n    FindNearestPerpendicularOrContainingEdge(startVertex, dir, pointLocation) {\n        // Similar to FindPerpendicularEdge, but first try to move closer to pointLocation,\n        // as long as there are edges going in 'dir' that extend to pointLocation.\n        let dirTowardLocation;\n        dir & PointComparer.GetDirections(startVertex.point, pointLocation);\n        // If Directions. None then pointLocation is collinear.\n        let currentVertex = startVertex;\n        const currentDirTowardLocation = dirTowardLocation;\n        // First move toward pointLocation far as we can.\n        while (Direction.None !== currentDirTowardLocation) {\n            const nextVertex = StaticGraphUtility.FindAdjacentVertex(currentVertex, dirTowardLocation);\n            if (nextVertex == null) {\n                break;\n            }\n            if (0 !== (CompassVector.OppositeDir(dirTowardLocation) & PointComparer.GetDirections(nextVertex.point, pointLocation))) {\n                break;\n            }\n            currentVertex = nextVertex;\n            dir & PointComparer.GetDirections(currentVertex.point, pointLocation);\n        }\n        // Now find the first vertex that has a chain that intersects pointLocation, if any, moving away\n        // from pointLocation until we find it or arrive back at startVertex.\n        let perpEdge;\n        while (true) {\n            perpEdge = this.FindPerpendicularOrContainingEdge(currentVertex, dir, pointLocation);\n            if (perpEdge != null || currentVertex === startVertex) {\n                break;\n            }\n            currentVertex = StaticGraphUtility.FindAdjacentVertex(currentVertex, CompassVector.OppositeDir(dirTowardLocation));\n        }\n        return perpEdge;\n    }\n    ConnectVertexToTargetVertex(sourceVertex, targetVertex, finalEdgeDir, weight) {\n        // finalDir is the required direction of the final edge to the targetIntersect\n        // (there will be two edges if we have to add a bend vertex).\n        // StaticGraphUtility.Assert(PointComparer.IsPureDirection(finalEdgeDir), \"finalEdgeDir is not pure\", this.ObstacleTree, this.VisGraph);\n        // // targetIntersect may be CenterVertex if that is on an extreme bend or a flat border.\n        if (Point.closeDistEps(sourceVertex.point, targetVertex.point)) {\n            return;\n        }\n        // If the target is collinear with sourceVertex we can just create one edge to it.\n        const targetDirs = PointComparer.GetDirections(sourceVertex.point, targetVertex.point);\n        if (PointComparer.IsPureDirectionD(targetDirs)) {\n            this.FindOrAddEdgeVV(sourceVertex, targetVertex);\n            return;\n        }\n        // Not collinear so we need to create a bend vertex and edge if they don't yet exist.\n        const bendPoint = StaticGraphUtility.FindBendPointBetween(sourceVertex.point, targetVertex.point, finalEdgeDir);\n        const bendVertex = this.FindOrAddVertex(bendPoint);\n        this.FindOrAddEdge(sourceVertex, bendVertex, weight);\n        // Now create the outer target vertex if it doesn't exist.\n        this.FindOrAddEdge(bendVertex, targetVertex, weight);\n    }\n    AddEdgeToTargetEdge(sourceVertex, targetEdge, targetIntersect) {\n        // StaticGraphUtility.Assert((Point.closeDistEps(sourceVertex.point, targetIntersect) || PointComparer.IsPureDirection(sourceVertex.point, targetIntersect)), \"non-orthogonal edge request\", this.ObstacleTree, this.VisGraph);\n        // StaticGraphUtility.Assert(StaticGraphUtility.PointIsOnSegmentSP(targetEdge.SourcePoint, targetEdge.TargetPoint, targetIntersect), \"targetIntersect is not on targetEdge\", this.ObstacleTree, this.VisGraph);\n        // If the target vertex does not exist, we must split targetEdge to add it.\n        let targetVertex = this.VisGraph.FindVertex(targetIntersect);\n        if (targetVertex == null) {\n            targetVertex = this.AddVertex(targetIntersect);\n            this.SplitEdge(targetEdge, targetVertex);\n        }\n        this.FindOrAddEdgeVV(sourceVertex, targetVertex);\n        return targetVertex;\n    }\n    SplitEdge(edge, splitVertex) {\n        // If the edge is NULL it means we could not find an appropriate one, so do nothing.\n        if (edge == null) {\n            return null;\n        }\n        // StaticGraphUtility.Assert(StaticGraphUtility.PointIsOnSegmentSP(edge.SourcePoint, edge.TargetPoint, splitVertex.point), \"splitVertex is not on edge\", this.ObstacleTree, this.VisGraph);\n        if (Point.closeDistEps(edge.Source.point, splitVertex.point) || Point.closeDistEps(edge.Target.point, splitVertex.point)) {\n            // No split needed.\n            return edge;\n        }\n        // Store the original edge, if needed.\n        if (!(edge instanceof TollFreeVisibilityEdge)) {\n            this.edgesToRestore.push(edge);\n        }\n        VisibilityGraph.RemoveEdge(edge);\n        // If this is an overlapped edge, or we're in sparseVg, then it may be an unpadded->padded edge that crosses\n        // over another obstacle's padded boundary, and then either a collinear splice from a free point or another\n        // obstacle in the same cluster starts splicing from that leapfrogged boundary, so we have the edges:\n        //      A   ->   D                      | D is unpadded, A is padded border of sourceObstacle\n        //        B -> C  ->  E  ->  F          | B and C are vertical ScanSegments between A and D\n        //      <-- splice direction is West    | F is unpadded, E is padded border of targetObstacle\n        // Now after splicing F to E to C to B we go A, calling FindOrAddEdge B->A; the bracketing process finds\n        // A->D which we'll be splitting at B, which would wind up with A->B, B->C, B->D, having to Eastward\n        // outEdges from B.  See RectilinearTests.Reflection_Block1_Big_UseRect for overlapped, and\n        // RectilinearTests.FreePortLocationRelativeToTransientVisibilityEdgesSparseVg for sparseVg.\n        // To avoid this we add the edges in each direction from splitVertex with FindOrAddEdge.  If we've\n        // come here from a previous call to FindOrAddEdge, then that call has found the bracketing vertices,\n        // which are the endpoints of 'edge', and we've removed 'edge', so we will not call SplitEdge again.\n        if ((this.IsSparseVg || edge.Weight === ScanSegment.OverlappedWeight) && splitVertex.Degree > 0) {\n            this.FindOrAddEdge(splitVertex, edge.Source, edge.Weight);\n            return this.FindOrAddEdge(splitVertex, edge.Target, edge.Weight);\n        }\n        // Splice it into the graph in place of targetEdge.  Return the first half, because\n        // this may be called from AddEdge, in which case the split vertex is the target vertex.\n        this.CreateEdge(splitVertex, edge.Target, edge.Weight);\n        return this.CreateEdge(edge.Source, splitVertex, edge.Weight);\n    }\n    ExtendEdgeChainVRLPB(startVertex, limitRect, maxVisibilitySegment, pacList, isOverlapped) {\n        const dir = PointComparer.GetDirections(maxVisibilitySegment.start, maxVisibilitySegment.end);\n        if (dir === Direction.None) {\n            return;\n        }\n        /*Assert.assert(\n          CompassVector.IsPureDirection(dir),\n          'impure max visibility segment',\n        )*/\n        // Shoot the edge chain out to the shorter of max visibility or intersection with the limitrect.\n        // StaticGraphUtility.Assert((Point.closeDistEps(maxVisibilitySegment.start, startVertex.point)\n        //                || (PointComparer.GetPureDirectionVV(maxVisibilitySegment.start, startVertex.point) === dir)), \"Inconsistent direction found\", this.ObstacleTree, this.VisGraph);\n        const oppositeFarBound = StaticGraphUtility.GetRectangleBound(limitRect, dir);\n        const maxDesiredSplicePoint = StaticGraphUtility.IsVerticalD(dir)\n            ? Point.RoundPoint(new Point(startVertex.point.x, oppositeFarBound))\n            : Point.RoundPoint(new Point(oppositeFarBound, startVertex.point.y));\n        if (Point.closeDistEps(maxDesiredSplicePoint, startVertex.point)) {\n            // Nothing to do.\n            return;\n        }\n        if (PointComparer.GetDirections(startVertex.point, maxDesiredSplicePoint) !== dir) {\n            // It's in the opposite direction, so no need to do anything.\n            return;\n        }\n        // If maxDesiredSplicePoint is shorter, create a new shorter segment.  We have to pass both segments\n        // through to the worker function so it knows whether it can go past maxDesiredSegment (which may be limited\n        // by limitRect).\n        let maxDesiredSegment = maxVisibilitySegment;\n        if (PointComparer.GetDirections(maxDesiredSplicePoint, maxDesiredSegment.end) === dir) {\n            maxDesiredSegment = LineSegment.mkPP(maxDesiredSegment.start, maxDesiredSplicePoint);\n        }\n        this.ExtendEdgeChain(startVertex, dir, maxDesiredSegment, maxVisibilitySegment, pacList, isOverlapped);\n    }\n    ExtendEdgeChain(startVertex, extendDir, maxDesiredSegment, maxVisibilitySegment, pacList, isOverlapped) {\n        // StaticGraphUtility.Assert((PointComparer.GetDirections(maxDesiredSegment.start, maxDesiredSegment.end) === extendDir), \"maxDesiredSegment is reversed\", this.ObstacleTree, this.VisGraph);\n        // Direction*s*, because it may return None, which is valid and means startVertex is on the\n        // border of an obstacle and we don't want to go inside it.\n        const segmentDir = PointComparer.GetDirections(startVertex.point, maxDesiredSegment.end);\n        if (segmentDir !== extendDir) {\n            // OppositeDir may happen on overlaps where the boundary has a gap in its ScanSegments due to other obstacles\n            // overlapping it and each other.  This works because the port has an edge connected to startVertex,\n            // which is on a ScanSegment outside the obstacle.\n            // StaticGraphUtility.Assert((isOverlapped\n            //                || (segmentDir !== CompassVector.OppositeDir(extendDir))), \"obstacle encountered between prevPoint and startVertex\", this.ObstacleTree, this.VisGraph);\n            return;\n        }\n        // We'll find the segment to the left (or right if to the left doesn't exist),\n        // then splice across in the opposite direction.\n        let spliceSourceDir = CompassVector.RotateLeft(extendDir);\n        let spliceSource = StaticGraphUtility.FindAdjacentVertex(startVertex, spliceSourceDir);\n        if (spliceSource == null) {\n            spliceSourceDir = CompassVector.OppositeDir(spliceSourceDir);\n            spliceSource = StaticGraphUtility.FindAdjacentVertex(startVertex, spliceSourceDir);\n            if (spliceSource == null) {\n                return;\n            }\n        }\n        // Store this off before ExtendSpliceWorker, which overwrites it.\n        const spliceTargetDir = CompassVector.OppositeDir(spliceSourceDir);\n        const t = { spliceTarget: null };\n        if (this.ExtendSpliceWorker(spliceSource, extendDir, spliceTargetDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, t)) {\n            // We ended on the source side and may have dead-ends on the target side so reverse sides.\n            this.ExtendSpliceWorker(t.spliceTarget, extendDir, spliceSourceDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, t);\n        }\n        this.SpliceGroupBoundaryCrossings(pacList, startVertex, maxDesiredSegment);\n    }\n    SpliceGroupBoundaryCrossings(crossingList, startVertex, maxSegment) {\n        if (crossingList == null || 0 === crossingList.Count()) {\n            return;\n        }\n        crossingList.Reset();\n        let start = maxSegment.start;\n        let end = maxSegment.end;\n        let dir = PointComparer.GetDirections(start, end);\n        // Make sure we are going in the ascending direction.\n        if (!StaticGraphUtility.IsAscending(dir)) {\n            start = maxSegment.end;\n            end = maxSegment.start;\n            dir = CompassVector.OppositeDir(dir);\n        }\n        // We need to back up to handle group crossings that are between a VisibilityBorderIntersect on a sloped border and the\n        // incoming startVertex (which is on the first ScanSegment in Perpendicular(dir) that is outside that padded border).\n        startVertex = TransientGraphUtility.TraverseToFirstVertexAtOrAbove(startVertex, start, CompassVector.OppositeDir(dir));\n        // Splice into the Vertices between and including the start/end points.\n        for (let currentVertex = startVertex; currentVertex != null; currentVertex = StaticGraphUtility.FindAdjacentVertex(currentVertex, dir)) {\n            const isFinalVertex = PointComparer.ComparePP(currentVertex.point, end) >= 0;\n            while (crossingList.CurrentIsBeforeOrAt(currentVertex.point)) {\n                const pac = crossingList.Pop();\n                // If it's past the start and at or before the end, splice in the crossings in the descending direction.\n                if (PointComparer.ComparePP(pac.Location, startVertex.point) > 0) {\n                    if (PointComparer.ComparePP(pac.Location, end) <= 0) {\n                        this.SpliceGroupBoundaryCrossing(currentVertex, pac, CompassVector.OppositeDir(dir));\n                    }\n                }\n                // If it's at or past the start and before the end, splice in the crossings in the descending direction.\n                if (PointComparer.ComparePP(pac.Location, startVertex.point) >= 0) {\n                    if (PointComparer.ComparePP(pac.Location, end) < 0) {\n                        this.SpliceGroupBoundaryCrossing(currentVertex, pac, dir);\n                    }\n                }\n            }\n            if (isFinalVertex) {\n                break;\n            }\n        }\n    }\n    static TraverseToFirstVertexAtOrAbove(startVertex, start, dir) {\n        let returnVertex = startVertex;\n        const oppositeDir = CompassVector.OppositeDir(dir);\n        for (;;) {\n            const nextVertex = StaticGraphUtility.FindAdjacentVertex(returnVertex, dir);\n            // This returns Directions. None on a match.\n            if (nextVertex == null || PointComparer.GetDirections(nextVertex.point, start) === oppositeDir) {\n                break;\n            }\n            returnVertex = nextVertex;\n        }\n        return returnVertex;\n    }\n    SpliceGroupBoundaryCrossing(currentVertex, pac, dirToInside) {\n        var _a, _b;\n        const crossings = PointAndCrossingsList.ToCrossingArray(pac.Crossings, dirToInside);\n        if (crossings != null) {\n            const outerVertex = (_a = this.VisGraph.FindVertex(pac.Location)) !== null && _a !== void 0 ? _a : this.AddVertex(pac.Location);\n            if (!currentVertex.point.equal(outerVertex.point)) {\n                this.FindOrAddEdgeVV(currentVertex, outerVertex);\n            }\n            const interiorPoint = crossings[0].GetInteriorVertexPoint(pac.Location);\n            const interiorVertex = (_b = this.VisGraph.FindVertex(interiorPoint)) !== null && _b !== void 0 ? _b : this.AddVertex(interiorPoint);\n            // FindOrAddEdge splits an existing edge so may not return the portion bracketed by outerVertex and interiorVertex.\n            const edge = this.FindOrAddEdgeVV(outerVertex, interiorVertex);\n            //const edge = this.VisGraph.FindEdgePP(outerVertex.point, interiorVertex.point)\n            const crossingsArray = crossings.map((c) => c.Group.InputShape);\n            edge.IsPassable = () => crossingsArray.some((s) => s.IsTransparent);\n        }\n    }\n    // The return value is whether we should try a second pass if this is called on the first pass,\n    // using spliceTarget to wrap up dead-ends on the target side.\n    ExtendSpliceWorker(spliceSourcePar, extendDir, spliceTargetDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, t) {\n        // This is called after having created at least one extension vertex (initially, the\n        // first one added outside the obstacle), so we know extendVertex\n        // will be there. spliceSource  is the vertex to the OppositeDir(spliceTargetDir) of that extendVertex.\n        let extendVertex = StaticGraphUtility.FindAdjacentVertex(spliceSourcePar, spliceTargetDir);\n        t.spliceTarget = StaticGraphUtility.FindAdjacentVertex(extendVertex, spliceTargetDir);\n        const st = { spliceSource: spliceSourcePar };\n        for (;;) {\n            if (!TransientGraphUtility.GetNextSpliceSource(st, spliceTargetDir, extendDir)) {\n                break;\n            }\n            // spliceSource is now on the correct edge relative to the desired nextExtendPoint.\n            // spliceTarget is in the opposite direction of the extension-line-to-spliceSource.\n            const nextExtendPoint = StaticGraphUtility.FindBendPointBetween(extendVertex.point, st.spliceSource.point, CompassVector.OppositeDir(spliceTargetDir));\n            // We test below for being on or past maxDesiredSegment; here we may be skipping\n            // over maxDesiredSegmentEnd which is valid since we want to be sure to go to or\n            // past limitRect, but be sure to stay within maxVisibilitySegment.\n            if (TransientGraphUtility.IsPointPastSegmentEnd(maxVisibilitySegment, nextExtendPoint)) {\n                break;\n            }\n            t.spliceTarget = TransientGraphUtility.GetSpliceTarget(st, spliceTargetDir, nextExtendPoint);\n            // StaticGraphUtility.Test_DumpVisibilityGraph(ObstacleTree, VisGraph);\n            if (t.spliceTarget == null) {\n                // This may be because spliceSource was created just for Group boundaries.  If so,\n                // skip to the next nextExtendVertex location.\n                if (this.IsSkippableSpliceSourceWithNullSpliceTarget(st.spliceSource, extendDir)) {\n                    continue;\n                }\n                // We're at a dead-end extending from the source side, or there is an intervening obstacle, or both.\n                // Don't splice across lateral group boundaries.\n                if (this.ObstacleTree.SegmentCrossesAnObstacle(st.spliceSource.point, nextExtendPoint)) {\n                    return false;\n                }\n            }\n            // We might be walking through a point where a previous chain dead-ended.\n            let nextExtendVertex = this.VisGraph.FindVertex(nextExtendPoint);\n            if (nextExtendVertex != null) {\n                if (t.spliceTarget == null || this.VisGraph.FindEdgePP(extendVertex.point, nextExtendPoint) != null) {\n                    // We are probably along a ScanSegment so visibility in this direction has already been determined.\n                    // Stop and don't try to continue extension from the opposite side.  If we continue splicing here\n                    // it might go across an obstacle.\n                    if (t.spliceTarget == null) {\n                        this.FindOrAddEdge(extendVertex, nextExtendVertex, isOverlapped ? ScanSegment.OverlappedWeight : ScanSegment.NormalWeight);\n                    }\n                    return false;\n                }\n                // This should always have been found in the find-the-next-target loop above if there is\n                // a vertex (which would be nextExtendVertex, which we just found) between spliceSource\n                // and spliceTarget.  Even for a sparse graph, an edge should not skip over a vertex.\n                // StaticGraphUtility.Assert((spliceTarget === StaticGraphUtility.FindAdjacentVertex(nextExtendVertex, spliceTargetDir)), \"no edge exists between an existing nextExtendVertex and spliceTarget\", this.ObstacleTree, this.VisGraph);\n            }\n            else {\n                // StaticGraphUtility.Assert(((spliceTarget == null )\n                //                || (spliceTargetDir === PointComparer.GetPureDirectionVV(nextExtendPoint, spliceTarget.point))), \"spliceTarget is not to spliceTargetDir of nextExtendVertex\", this.ObstacleTree, this.VisGraph);\n                nextExtendVertex = this.AddVertex(nextExtendPoint);\n            }\n            this.FindOrAddEdge(extendVertex, nextExtendVertex, isOverlapped ? ScanSegment.OverlappedWeight : ScanSegment.NormalWeight);\n            // This will split the edge if targetVertex is non-null; otherwise we are at a dead-end\n            // on the target side so must not create a vertex as it would be inside an obstacle.\n            this.FindOrAddEdge(st.spliceSource, nextExtendVertex, isOverlapped ? ScanSegment.OverlappedWeight : ScanSegment.NormalWeight);\n            if (isOverlapped) {\n                isOverlapped = this.SeeIfSpliceIsStillOverlapped(extendDir, nextExtendVertex);\n            }\n            extendVertex = nextExtendVertex;\n            // Test GetDirections because it may return Directions. None.\n            if (0 === (extendDir & PointComparer.GetDirections(nextExtendPoint, maxDesiredSegment.end))) {\n                // At or past the desired max extension point, so we're done.\n                t.spliceTarget = null;\n                break;\n            }\n        }\n        return t.spliceTarget != null;\n    }\n    static GetNextSpliceSource(t, spliceTargetDir, extendDir) {\n        let nextSpliceSource = StaticGraphUtility.FindAdjacentVertex(t.spliceSource, extendDir);\n        if (nextSpliceSource == null) {\n            // See if there is a source further away from the extension line - we might have\n            // been on freePoint line (or another nearby PortEntry line) that dead-ended.\n            // Look laterally from the previous spliceSource first.\n            nextSpliceSource = t.spliceSource;\n            for (;;) {\n                nextSpliceSource = StaticGraphUtility.FindAdjacentVertex(nextSpliceSource, CompassVector.OppositeDir(spliceTargetDir));\n                if (nextSpliceSource == null) {\n                    return false;\n                }\n                const nextSpliceSourceExtend = StaticGraphUtility.FindAdjacentVertex(nextSpliceSource, extendDir);\n                if (nextSpliceSourceExtend != null) {\n                    nextSpliceSource = nextSpliceSourceExtend;\n                    break;\n                }\n            }\n        }\n        t.spliceSource = nextSpliceSource;\n        return true;\n    }\n    static GetSpliceTarget(t, spliceTargetDir, nextExtendPoint) {\n        // Look for the target.  There may be a dead-ended edge starting at the current spliceSource\n        // edge that has a vertex closer to the extension line; in that case keep walking until we\n        // have the closest vertex on the Source side of the extension line as spliceSource.\n        const prevDir = PointComparer.GetDirections(t.spliceSource.point, nextExtendPoint);\n        let nextDir = prevDir;\n        let spliceTarget = t.spliceSource;\n        while (nextDir === prevDir) {\n            t.spliceSource = spliceTarget;\n            spliceTarget = StaticGraphUtility.FindAdjacentVertex(t.spliceSource, spliceTargetDir);\n            if (spliceTarget == null) {\n                break;\n            }\n            if (Point.closeDistEps(spliceTarget.point, nextExtendPoint)) {\n                // If we encountered an existing vertex for the extension chain, update spliceTarget\n                // to be after it and we're done with this loop.\n                spliceTarget = StaticGraphUtility.FindAdjacentVertex(spliceTarget, spliceTargetDir);\n                break;\n            }\n            nextDir = PointComparer.GetDirections(spliceTarget.point, nextExtendPoint);\n        }\n        return spliceTarget;\n    }\n    SeeIfSpliceIsStillOverlapped(extendDir, nextExtendVertex) {\n        // If we've spliced out of overlapped space into free space, we may be able to turn off the\n        // overlapped state if we have a perpendicular non-overlapped edge.\n        let edge = this.FindNextEdge(nextExtendVertex, CompassVector.RotateLeft(extendDir));\n        let maybeFreeSpace = edge == null ? false : ScanSegment.NormalWeight === edge.Weight;\n        if (!maybeFreeSpace) {\n            edge = this.FindNextEdge(nextExtendVertex, CompassVector.RotateRight(extendDir));\n            maybeFreeSpace = edge == null ? false : ScanSegment.NormalWeight === edge.Weight;\n        }\n        return !maybeFreeSpace || this.ObstacleTree.PointIsInsideAnObstaclePD(nextExtendVertex.point, extendDir);\n    }\n    IsSkippableSpliceSourceWithNullSpliceTarget(spliceSource, extendDir) {\n        if (TransientGraphUtility.IsSkippableSpliceSourceEdgeWithNullTarget(StaticGraphUtility.FindAdjacentEdge(spliceSource, extendDir))) {\n            return true;\n        }\n        const spliceSourceEdge = StaticGraphUtility.FindAdjacentEdge(spliceSource, CompassVector.OppositeDir(extendDir));\n        // Since target is null, if this is a reflection, it is bouncing off an outer side of a group or\n        // obstacle at spliceSource.  In that case, we don't want to splice from it because then we could\n        // cut through the group and outside again; instead we should just stay outside it.\n        return (TransientGraphUtility.IsSkippableSpliceSourceEdgeWithNullTarget(spliceSourceEdge) ||\n            TransientGraphUtility.IsReflectionEdge(spliceSourceEdge));\n    }\n    static IsSkippableSpliceSourceEdgeWithNullTarget(spliceSourceEdge) {\n        return (spliceSourceEdge != null &&\n            spliceSourceEdge.IsPassable != null &&\n            closeDistEps(spliceSourceEdge.Length, GroupBoundaryCrossing.BoundaryWidth));\n    }\n    static IsReflectionEdge(edge) {\n        return edge != null && edge.Weight === ScanSegment.ReflectionWeight;\n    }\n    static IsPointPastSegmentEnd(maxSegment, point) {\n        return PointComparer.GetDirections(maxSegment.start, maxSegment.end) === PointComparer.GetDirections(maxSegment.end, point);\n    }\n    toString() {\n        return String.Format('{0} {1}', this.AddedVertices.length, this.edgesToRestore.length);\n    }\n}\n//# sourceMappingURL=TransientGraphUtility.js.map","import { CompassVector } from '../../math/geometry/compassVector';\nimport { Direction } from '../../math/geometry/direction';\nexport class VertexEntry {\n    // A class that records an entry from a specific direction for a vertex.\n    // Vertex that this VertexEntry enters\n    // The previous VertexEntry along this path; null for a path source\n    // Length of the path up to this vertex\n    // Number of bends in the path up to this vertex\n    // Cost of the path up to this vertex\n    constructor(vertex, prevEntry, length, numberOfBends, cost) {\n        // Indicates whether we are allowing further entries into this vertex from this direction.\n        this.IsClosed = false;\n        this.Vertex = vertex;\n        this.Direction = prevEntry != null ? CompassVector.DirectionFromPointToPoint(prevEntry.Vertex.point, vertex.point) : Direction.None;\n        this.ResetEntry(prevEntry, length, numberOfBends, cost);\n    }\n    ResetEntry(prevEntry, length, numberOfBends, cost) {\n        // A new prevEntry using the same previous vertex but a different entry to that vertex is valid here;\n        // e.g. we could have prevEntry from S, which in turn had a prevEntry from E, replaced by prevEntry from\n        // S which has a prevEntry from S.\n        // #if (TEST_MSAGL)\n        // if ((this.PreviousEntry != null)) {\n        //    Assert.assert((this.PreviousEntry.Vertex === prevEntry.Vertex), \"Inconsistent prevEntry vertex\");\n        //    Assert.assert((this.PreviousEntry.Direction !== prevEntry.Direction), \"Duplicate prevEntry direction\");\n        //    Assert.assert((this.Direction === CompassVector.PureDirectionFromPointToPoint(this.PreviousEntry.Vertex.point, this.Vertex.point)), \"Inconsistent entryDir\");\n        // }\n        // #endif\n        // // TEST_MSAGL\n        this.PreviousEntry = prevEntry;\n        this.Length = length;\n        this.NumberOfBends = numberOfBends;\n        this.Cost = cost;\n    }\n    // The vertex that this VertexEntry is entered from\n    get PreviousVertex() {\n        return this.PreviousEntry == null ? null : this.PreviousEntry.Vertex;\n    }\n    toString() {\n        return this.Vertex.point + (' ' + (this.Direction + (' ' + (this.IsClosed + (' ' + this.Cost)))));\n    }\n}\n//# sourceMappingURL=VertexEntry.js.map","// Scan direction is parallel to the sweepline which moves in the perpendicular direction;\n// i.e. scan direction is \"sideways\" along the sweepline.  We also have lookahead scans\n// that enqueue events along the scan-primary coordinate (in the direction of the scan, i.e.\n// X for Hscan, Y for Vscan) to handle reflections from non-orthogonal obstacle sides,\n// and lookback scans that have not had their reflections calculated because they reflect\nimport { Point } from '../../math/geometry/point';\nimport { Rectangle } from '../../math/geometry/rectangle';\nimport { VisibilityGraph } from '../visibility/VisibilityGraph';\nimport { HighObstacleSide, LowObstacleSide } from './BasicObstacleSide';\nimport { BasicReflectionEvent } from './basicReflectionEvent';\nimport { EventQueue } from './EventQueue';\nimport { GroupBoundaryCrossingMap } from './GroupBoundaryCrossingMap';\nimport { HighReflectionEvent } from './HighReflectionEvent';\nimport { LookaheadScan } from './LookaheadScan';\nimport { CloseVertexEvent, HighBendVertexEvent, LowBendVertexEvent } from './MiscVertexEvents';\nimport { LowReflectionEvent } from './LowReflectionEvent';\nimport { NeighborSides } from './NeighborSides';\nimport { Obstacle } from './obstacle';\nimport { ObstacleTree } from './ObstacleTree';\nimport { OpenVertexEvent } from './OpenVertexEvent';\nimport { PointComparer } from './PointComparer';\nimport { RectilinearScanLine } from './RectilinearScanLine';\nimport { ScanDirection } from './ScanDirection';\nimport { ScanSegmentTree } from './ScanSegmentTree';\nimport { SpliceUtility } from './SpliceUtility';\nimport { StaticGraphUtility } from './StaticGraphUtility';\nimport { VisibilityVertexRectilinear } from './VisibilityVertexRectiline';\nimport { CompassVector } from '../../math/geometry/compassVector';\n// backward from the scanline and thus must be picked up on a subsequent perpendicular sweep.\nexport class VisibilityGraphGenerator {\n    constructor(wantReflections) {\n        // This is the tree of rectangle nodes of the input obstacles' padded encompassing polylines.\n        this.ObstacleTree = new ObstacleTree();\n        // This is a map of all group boundary crossings for the current scanline event being processed,\n        // including the direction (along the scanline axis, horizontal or vertical) that a path crossing\n        // that boundary takes toward the group's interior.  A point may be in here twice in the event of\n        // groups sharing a boundary.\n        this.CurrentGroupBoundaryCrossingMap = new GroupBoundaryCrossingMap();\n        // For scanline traversal.\n        this.LowNeighborSides = new NeighborSides();\n        this.HighNeighborSides = new NeighborSides();\n        this.ScanDirection = ScanDirection.HorizontalInstance;\n        this.eventQueue = new EventQueue();\n        this.HorizontalScanSegments = new ScanSegmentTree(ScanDirection.HorizontalInstance);\n        this.VerticalScanSegments = new ScanSegmentTree(ScanDirection.VerticalInstance);\n        this.wantReflections = wantReflections;\n    }\n    get ParallelScanSegments() {\n        return this.ScanDirection.IsHorizontal ? this.HorizontalScanSegments : this.VerticalScanSegments;\n    }\n    get PerpendicularScanSegments() {\n        return this.ScanDirection.IsHorizontal ? this.VerticalScanSegments : this.HorizontalScanSegments;\n    }\n    static NewVisibilityGraph() {\n        const ret = new VisibilityGraph();\n        ret.VertexFactory = (point) => new VisibilityVertexRectilinear(point);\n        return ret;\n    }\n    // Generate the visibility graph along which edges will be routed.\n    GenerateVisibilityGraph() {\n        // Generate the Polyline tree from the padded shapes.  ObstacleTree allows us to do\n        // obstacle hit-testing for dynamic obstacles, as well as providing input for the Nudger.\n        // Each PolylinePoint contains a reference to the Polyline of which it is a member.\n        if (this.ObstacleTree.Root == null) {\n            return;\n        }\n        // Now enqueue initial events for the vertical sweep (horizontal scan); start with the lowest\n        // vertices and then we'll load subsequent vertices (and intersections) as we encounter them.\n        // We'll defer the generation of vertex events in the perpendicular direction until we're done\n        // with this sweep, to save memory; but we may enqueue intersection events in the perpendicular\n        // direction during this sweep.\n        this.InitializeEventQueue(ScanDirection.HorizontalInstance);\n        // Create the sentinels and add them to the scanline.  Do NOT add them to the event queue\n        // because we're not going to close them.  We're also effectively adding only the inner side\n        // perpendicular to the scan, but we need the polyline for segment-subsumption tracking.\n        // Creating with two points has the lines \"clockwise\" (and counterclockwise) as above.\n        //\n        // We don't need to store the sentinels as we retrieve them from [SweepEvent].Vertex.Polyline.\n        // And we only need the low sentine's HighSide and the high sentinel's LowSide, but we use both\n        // to save Obstacle from having to worry about the special case.  Note: reflection will\n        // automatically not happen when hitting sentinels because their borders are IsPerpendicular.\n        let scanlineSentinelOrdinal = Obstacle.FirstSentinelOrdinal;\n        // Low sentinel...\n        let lowerCorner = new Point(this.ObstacleTree.GraphBox.left - VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.bottom - VisibilityGraphGenerator.SentinelOffset);\n        let upperCorner = new Point(this.ObstacleTree.GraphBox.left - VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.top + VisibilityGraphGenerator.SentinelOffset);\n        let sentinel = Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);\n        this.scanLine.Insert(sentinel.ActiveHighSide, this.ObstacleTree.GraphBox.leftBottom);\n        // High sentinel...\n        lowerCorner = new Point(this.ObstacleTree.GraphBox.right + VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.bottom - VisibilityGraphGenerator.SentinelOffset);\n        upperCorner = new Point(this.ObstacleTree.GraphBox.right + VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.top + VisibilityGraphGenerator.SentinelOffset);\n        sentinel = Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);\n        this.scanLine.Insert(sentinel.ActiveLowSide, this.ObstacleTree.GraphBox.leftBottom);\n        // Process the Hscan events.`\n        //DevTraceInfoVgGen(1, \"Processing Horizontal Scan events\");\n        this.ProcessEvents();\n        // Now do the horizontal sweep (vertical scan).  Note: Because we use Cartesian coordinates\n        // rather than Page coordinates, the High and Low sides reverse the direction they traverse\n        // when doing vertical scan; this information is passed as a ctor param.  This allows for\n        // consistent comparisons.\n        this.InitializeEventQueue(ScanDirection.VerticalInstance);\n        // Lower sentinel...\n        lowerCorner = new Point(this.ObstacleTree.GraphBox.left - VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.bottom - VisibilityGraphGenerator.SentinelOffset);\n        upperCorner = new Point(this.ObstacleTree.GraphBox.right + VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.bottom - VisibilityGraphGenerator.SentinelOffset);\n        sentinel = Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);\n        this.scanLine.Insert(sentinel.ActiveHighSide, this.ObstacleTree.GraphBox.leftBottom);\n        // Upper sentinel\n        lowerCorner = new Point(this.ObstacleTree.GraphBox.left - VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.top + VisibilityGraphGenerator.SentinelOffset);\n        upperCorner = new Point(this.ObstacleTree.GraphBox.right + VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.top + VisibilityGraphGenerator.SentinelOffset);\n        sentinel = Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal);\n        this.scanLine.Insert(sentinel.ActiveLowSide, this.ObstacleTree.GraphBox.leftBottom);\n        // Process the Vscan events.\n        // DevTraceInfoVgGen(1, \"Processing Vertical Scan events\");\n        this.ProcessEvents();\n    }\n    // // ReSharper disable InconsistentNaming\n    // protected static Debug_AssertGraphIsRectilinear(graph: VisibilityGraph, this.ObstacleTree: this.ObstacleTree) {\n    //    this.#if TEST_MSAGL\n    //    if (graph.Edges.Any(edge => !PointComparer.IsPureDirection(PointComparer.GetDirections(edge.SourcePoint, edge.TargetPoint))))\n    //    {\n    //        StaticGraphUtility.Assert(false, \"Generated VisibilityGraph contains non-rectilinear lines\", this.ObstacleTree, graph);\n    //        return;\n    //    }\n    //    this.#endif\n    // }\n    static ScanLineIntersectSidePBS(site, side, scanDir) {\n        // Note: we don't assert that site and side are not PointComparer.Equal, because ScanLine calls\n        // this on sides that share vertices.\n        /*Assert.assert(\n          !scanDir.IsFlatS(side),\n          'flat sides should not be in the scanline or encountered on lookahead scan',\n        )*/\n        // We know that we will have an intersection if the side is adjacent in the scanline, so\n        // we can optimize the calculation to project along the slope of the BasicObstacleSide.\n        // Also, due to rounding, we need to make sure that when intersecting the side, we're not\n        // falling short due to rounding error; that can be a problem if we're right at a vertex\n        // of that obstacle, because then there is no intersection with the perpendicular line\n        // from that vertex.  So make sure we are at least to the nearest coordinate of that side.\n        // Note:  Calculate slope here using 'dir' rather than side.SlopeInverse because Reflection\n        // lookaheads calculate the perpendicular intersection and side.Slope(Inverse) is always\n        // relative to the scanline parallel.\n        const dir = side.Direction;\n        let ix = side.Start.x;\n        let iy = side.Start.y;\n        if (scanDir.IsHorizontal) {\n            ix += (dir.x / dir.y) * (site.y - side.Start.y);\n            ix = SpliceUtility.MungeIntersect(site.x, ix, side.Start.x, side.End.x);\n            iy = site.y;\n        }\n        else {\n            ix = site.x;\n            iy += (dir.y / dir.x) * (site.x - side.Start.x);\n            iy = SpliceUtility.MungeIntersect(site.y, iy, side.Start.y, side.End.y);\n        }\n        return new Point(ix, iy);\n    }\n    GetOpenVertex(poly) {\n        let lowest = poly.startPoint;\n        let next = this.TraversePolylineForEvents(lowest);\n        // We want the bottom vertex to be the lowest in scanline-parallel coordinate if there is a\n        // flat bottom side, and we've guaranteed that the lines are oriented clockwise.  This means\n        // that we want a <= comparison of the current node vs. the candidate, to store the last\n        // lowest vertex of the clockwise rotation.  Stop when we've turned upward from descending/flat.\n        let iPrevCmp = this.PointCompare(next.point, lowest.point);\n        for (;; next = this.TraversePolylineForEvents(next)) {\n            const iCurCmp = this.PointCompare(next.point, lowest.point);\n            if (iCurCmp <= 0) {\n                lowest = next;\n            }\n            else if (iCurCmp > 0 && iPrevCmp <= 0) {\n                break;\n            }\n            iPrevCmp = iCurCmp;\n        }\n        return lowest;\n    }\n    TraversePolylineForEvents(polyPoint) {\n        // When loading scanline events, we'll go clockwise for horizontal scan, where the\n        // scanline-parallel coordinate increases to the right, or counterclockwise for vertical\n        // scan, where the scanline-parallel coordinate increases to the left.\n        return this.ScanDirection.IsHorizontal ? polyPoint.nextOnPolyline : polyPoint.prevOnPolyline;\n    }\n    InitializeEventQueue(scanDir) {\n        this.ScanDirection = scanDir;\n        this.eventQueue.Reset(this.ScanDirection);\n        this.EnqueueBottomVertexEvents();\n        this.scanLine = new RectilinearScanLine(this.ScanDirection, this.ObstacleTree.GraphBox.leftBottom);\n        this.lookaheadScan = new LookaheadScan(this.ScanDirection);\n    }\n    EnqueueBottomVertexEvents() {\n        for (const obstacle of this.ObstacleTree.GetAllPrimaryObstacles()) {\n            const bottomVertex = this.GetOpenVertex(obstacle.VisibilityPolyline);\n            this.eventQueue.Enqueue(new OpenVertexEvent(obstacle, bottomVertex));\n        }\n    }\n    // end EnqueueBottomVertexEvents\n    IsFlat(side) {\n        return this.ScanDirection.IsFlatS(side);\n    }\n    IsPerpendicular(side) {\n        // If it's perpendicular we won't generate reflections.\n        return this.ScanDirection.IsPerpendicularS(side);\n    }\n    // Params are event site (vertex point) and the obstacle side adjacent to that site.\n    ScanLineIntersectSide(site, side) {\n        return VisibilityGraphGenerator.ScanLineIntersectSidePBS(site, side, this.ScanDirection);\n    }\n    SideReflectsUpward(side) {\n        // Returns false if vertical.\n        if (side instanceof LowObstacleSide) {\n            // Low side slopes upward if slope is positive (to the high direction).\n            return this.ScanDirection.Coord(side.End) > this.ScanDirection.Coord(side.Start);\n        }\n        // High side slopes upward if slope is negative (to the low direction).\n        return this.ScanDirection.Coord(side.End) < this.ScanDirection.Coord(side.Start);\n    }\n    SideReflectsDownward(side) {\n        // Returns false if vertical.\n        if (side instanceof LowObstacleSide) {\n            // Low side slopes downward if slope is negative (to the low direction).\n            return this.ScanDirection.Coord(side.End) < this.ScanDirection.Coord(side.Start);\n        }\n        // High side slopes downward if slope is positive (to the high direction).\n        return this.ScanDirection.Coord(side.End) > this.ScanDirection.Coord(side.Start);\n    }\n    // Calculate reflections from the lines, depending on line side (Low vs. High) and slope.\n    // Because the low neighbor intersection is on a high side of its obstacle\n    // and vice-versa, then the \"side\" of a lowNbor is a highSide, and vice versa.\n    StoreLookaheadSite(initialObstacle, reflectingSide, reflectionSite, wantExtreme) {\n        if (!this.wantReflections) {\n            return;\n        }\n        // If the line is perpendicular, we won't generate reflections (they'd be redundant).\n        if (!this.IsPerpendicular(reflectingSide)) {\n            // If this is hitting an extreme vertex in the forward direction, we will (or already did) create a normal\n            // ScanSegment in the perpendicular direction.\n            if (!wantExtreme && !StaticGraphUtility.PointIsInRectangleInterior(reflectionSite, reflectingSide.Obstacle.VisibilityBoundingBox)) {\n                return;\n            }\n            // We can only do upward reflections, which fortunately is all we need.\n            if (this.SideReflectsUpward(reflectingSide)) {\n                // We defer actually creating the perpendicular line until we've processed\n                // the reflection event we're about to enqueue, so we may legitimately encounter\n                // two (or more) reflections at the same point along the parallel-to-scanline\n                // coordinate, if we have a side that is nearly but not quite perpendicular to\n                // the scanline.  For example:\n                //      \\\n                //       \\----------------------------- line2\n                //        \\---------------------------- line1\n                // Assume the vertical side is very close to perpendicular; then as we process\n                // the horizontal lines in the upward direction, we may generate two lookahead\n                // reflections at coordinates that are sufficiently far apart in the vertical\n                // coordinate (in this example, Y) that the lines are not subsumed, but are\n                // sufficiently close in the horizontal coordinate (in this example, X) that\n                // the perpendicular lines would be subsumed. In that case, we look here to see\n                // if there is an active lookahead scan for the reflecting site's parallel coordinate;\n                // if so, then because we know that the side reflects upward, we also know that\n                // the perpendicular line from the lowest segment's reflection site will intersect\n                // the higher segments here, providing the VisibilityVertices we need, so we can\n                // safely ignore the duplicate lookahead.\n                // Don't worry about enqueueing a reflection at the extreme scanline-parallel\n                // vertex because we'll MergeSegments to handle that.\n                if (this.lookaheadScan.Find(reflectionSite) == null) {\n                    this.lookaheadScan.Add(new BasicReflectionEvent(initialObstacle, reflectingSide.Obstacle, reflectionSite));\n                    //DevTraceInfoVgGen(1, \"Storing reflection lookahead site {0}\", reflectionSite);\n                }\n                else {\n                    // DevTraceInfoVgGen(1, \"Reflection lookahead site {0} already exists\", reflectionSite);\n                }\n            }\n        }\n    }\n    // Load any lookahead scan ray intersections with a side we've just added.\n    LoadReflectionEvents(sideToQueue) {\n        this.LoadReflectionEventsBB(sideToQueue, sideToQueue);\n    }\n    // sideWithRange is either the same as sideToQueue, if that side is being loaded by an\n    // OpenVertexEvent, or is a different side that is just closing.\n    LoadReflectionEventsBB(sideToQueue, sideWithRange) {\n        // If this line reflects upward then it cannot receive rays from below (they would pass\n        // through its obstacle), and of course a perpendicular lookahead line will never\n        // intersect a perpendicular side.\n        if (sideToQueue == null || this.SideReflectsUpward(sideToQueue) || this.IsPerpendicular(sideToQueue)) {\n            return;\n        }\n        // If there is no overlap in the rectangles along the current axis, there is nothing\n        // to do.  This reduces (but doesn't prevent) duplicate events being loaded.\n        const bbox1 = Rectangle.mkPP(sideToQueue.Start, sideToQueue.End);\n        const bbox2 = Rectangle.mkPP(sideWithRange.Start, sideWithRange.End);\n        if (this.ScanDirection.IsHorizontal ? !bbox1.intersectsOnX(bbox2) : !bbox1.intersectsOnY(bbox2)) {\n            return;\n        }\n        // Make sure we order the endpoints from low to high along the scanline parallel, and get only\n        // the intersection.  RectilinearFileTests.Nudger_Overlap* exercise reflection lookahead subranges.\n        const bboxIntersect = Rectangle.intersect(bbox1, bbox2);\n        const low = bboxIntersect.leftBottom;\n        const high = bboxIntersect.rightTop;\n        // This is inclusive of the endpoints of sideWithRange, to be sure that we remove the item\n        // from LookaheadScan; if it's on an extreme vertex in the perpendicular sweep then it will\n        // stop the chain; see TestRectilinear.Reflection_Staircase_Stops_At_BoundingBox_Side*.\n        let lookaheadSiteNode = this.lookaheadScan.FindFirstInRange(low, high);\n        while (lookaheadSiteNode != null) {\n            // Calculate the lookahead intersection with this side in the perpendicular direction to\n            // the scanline.  Note: due to rounding error, this may be different from the calculation\n            // in the parallel direction when the scanline gets up to the ScanDirection.PerpCoord(intersect);\n            // this will be adjusted in ScanSegmentTree.MergeSegments.\n            const intersect = VisibilityGraphGenerator.ScanLineIntersectSidePBS(lookaheadSiteNode.item.Site, sideToQueue, this.ScanDirection.PerpendicularInstance);\n            //DevTraceInfoVgGen(1, \"Loading reflection from lookahead site {0} to intersect at {1}\", lookaheadSiteNode.item.Site, intersect);\n            // DevTraceInfoVgGen(2, \"     side {0})\", sideToQueue);\n            // same indent as AddSegment\n            // In some cases where the ActiveLowSide and ActiveHighSide of an obstacle lean in the same\n            // direction such that LowSide is above HighSide, e.g. on the horizontal pass when they both\n            // lean to the right, the delayed-lookahead in CloseVertex (obstacle close) event may find the\n            // high side spanning the scanline-parallel coordinate range where its low side has enqueued\n            // lookahead events.  In that case the intersection will be less than the enqueueing site so\n            // ignore it.  See RectilinearTests.ReflectionsSitedByLowSideAreNotLoadedByHighSide.)\n            // Similarly, if this is at the same perpendicular coordinate as the current scanline\n            // position, ignore it; otherwise we could back up in the scanline's parallel coordinate.\n            // Since we retrieved events for the endpoint of any previous side, this won't be\n            // encountered on a bend vertex event; therefore we're on a near-flat bottom side\n            // so we're parallel to the extreme-vertex line and it's fine to just absorb the photon.\n            // This also handles the case of reflections into intersecting sides - at some point\n            // they converge such that the intersection is not ahead of the lookahead site.\n            if (this.ScanDirection.ComparePerpCoord(intersect, lookaheadSiteNode.item.Site) > 0) {\n                // Add an event to continue the chain, \"shifting\" the site's reflecting\n                // obstacle back to the initialObstacle position.  We must load this here\n                // and process it in ConfirmLookaheadEvent so it will be removed from\n                // the lookahead list; we can't remove it here if it doesn't satisfy the\n                // staircase requirements, because this may be called from loading a \"higher\"\n                // side (during the sweep) which could steal events from the lower side.\n                this.AddReflectionEvent(lookaheadSiteNode.item, sideToQueue, intersect);\n            }\n            else if (lookaheadSiteNode.item.ReflectingObstacle !== sideToQueue.Obstacle) {\n                //DevTraceInfoVgGen(1, \"  (discarding reflection at intersect {0} as it is not ahead of the previous site)\", intersect);\n                // We need to remove the site.  We're in the middle of Node enumeration so just\n                // mark the site and on function exit we'll remove any so marked.\n                this.lookaheadScan.MarkStaleSite(lookaheadSiteNode.item);\n            }\n            else {\n                // DevTraceInfoVgGen(1, \"  (skipping reflection at intersect {0} as it is the same obstacle)\", intersect);\n            }\n            // Get the next item, leaving the current one in the lookahead scan until\n            // we actually process the event; this lets us know whether an intervening\n            // obstacle may be opened and intercepted the reflection. ConfirmLookaheadEvents\n            // will actually do the removal when the lowest side containing the lookahead\n            // site is loaded.  See RectilinearTests.ReflectionsRemoveInterceptedSite.\n            lookaheadSiteNode = this.lookaheadScan.FindNextInRange(lookaheadSiteNode, high);\n        }\n        // endwhile previousSiteNode\n        this.lookaheadScan.RemoveStaleSites();\n    }\n    // Determine whether the event is valid and do some common processing.\n    AddPerpendicularReflectionSegment(currentEvent, eventSide, nborSide) {\n        // If eventSide is null it means we had the wrong side type as a scanline neighbor.\n        // If another obstacle opened up, then that obstacle (or another intervening one) should have\n        // drained this reflection event.\n        /*Assert.assert(null !=  eventSide, 'eventSide should not be null')*/\n        // Between the time currentEvent was queued and the time we're now processing it, another\n        // obstacle may have opened between the previousSite and the eventSite, in which case it\n        // removed currentEvent from the queue already.  So currentEvent may be stale.  The new\n        // obstacle may have stored *another* lookahead site with the same scanline-parallel\n        // coordinate (but higher up perpendicularly).  So remove the exact site of currentEvent;\n        // otherwise the currentEvent could be a stale event with the lower scanline-parallel\n        // coordinate, and would remove the site from the lookahead list before the \"live\" event\n        // looks for it.  See RectilinearTests.ReflectionsRemoveInterceptedSite.\n        if (this.lookaheadScan.RemoveExact(currentEvent.PreviousSite)) {\n            /*Assert.assert(\n              currentEvent.InitialObstacle ==\n                currentEvent.PreviousSite.ReflectingObstacle,\n              'Inconsistency: currentEvent.InitialObstacle !== currentEvent.PreviousSite.ReflectingObstacle',\n            )*/\n            // ReSharper disable HeuristicUnreachableCode\n            // ReSharper disable ConditionIsAlwaysTrueOrFalse\n            if (eventSide == null) {\n                // We've removed the event so there's nothing else to do.\n                return false;\n            }\n            // ReSharper restore ConditionIsAlwaysTrueOrFalse\n            // ReSharper restore HeuristicUnreachableCode\n            // If the two sides intersect ahead of the scanline, we don't want the reflection.\n            // If the reflecting side is flat, no reflection is done - that's handled by OpenVertexEvent.\n            /*Assert.assert(\n              !this.IsFlat(eventSide),\n              'Flat sides should not be encountered in reflections',\n            )*/\n            if (currentEvent.PreviousSite.IsStaircaseStep(currentEvent.ReflectingObstacle)) {\n                // We need to draw the perpendicular lines here because we may be on the second\n                // sweep so there won't be a subsequent sweep to draw them.  And if we're on the\n                // second sweep, we may have already loaded this segment as part of a continuation\n                // of an overlapped segment. Either way, we only want this if we are not on an extreme\n                // edge of the target obstacle (reflectingObstacle for the perpendicular segment,\n                // nborSide.Obstacle for the parallel segment).  Extreme vertices will generate segments.\n                // See TestRectilinear.Reflection_Staircase_Stops_At_BoundingBox_Side*.\n                if (!StaticGraphUtility.PointIsInRectangleInterior(currentEvent.Site, currentEvent.ReflectingObstacle.VisibilityBoundingBox)) {\n                    return false;\n                }\n                //DevTraceInfoVgGen(1, \"Perpendicular Reflection - Adding Segment [{0} -> {1}]\", currentEvent.PreviousSite.Site, currentEvent.Site);\n                //DevTraceInfoVgGen(2, \"  -> side {0}\", eventSide);\n                // same indent as AddSegment; eventSide is highNbor\n                if (!this.InsertPerpendicularReflectionSegment(currentEvent.PreviousSite.Site, currentEvent.Site)) {\n                    return false;\n                }\n                // If the neighbor continues the staircase and the parallel segment would hit a non-extreme point\n                // on the neighbor, return true and the Low/HighReflectionEvent handler will add the parallel segment.\n                if (nborSide != null && currentEvent.IsStaircaseStep(nborSide.Obstacle)) {\n                    return this.ScanLineCrossesObstacle(currentEvent.Site, nborSide.Obstacle);\n                }\n                //DevTraceInfoVgGen(1, \"Reflection Lookahead site {0} is not an outgoing staircase step; discontinuing\", currentEvent.PreviousSite);\n            }\n            else {\n                //DevTraceInfoVgGen(1, \"Reflection Lookahead site {0} is not an incoming staircase step; discontinuing\", currentEvent.PreviousSite);\n            }\n        }\n        else {\n            //DevTraceInfoVgGen(1, \"Reflection Lookahead site {0} is no longer in the lookahead table; skipping\", currentEvent.PreviousSite);\n        }\n        return false;\n    }\n    AddParallelReflectionSegment(eventObstacle, lowNborSide, highNborSide, action) {\n        {\n            // If this is reflecting to a low neighbor, then that intersect is 'start' in the low-to-high\n            // sequence, and the event site is the end; otherwise we start at the event site and end at\n            // the high neighbor.\n            const intersect = this.ScanLineIntersectSide(action.Site, lowNborSide !== null && lowNborSide !== void 0 ? lowNborSide : highNborSide);\n            const start = lowNborSide != null ? intersect : action.Site;\n            const end = lowNborSide != null ? action.Site : intersect;\n            // Now get the opposite neighbors so AddSegment can continue the reflection chain.\n            if (lowNborSide == null) {\n                lowNborSide = this.scanLine.NextLowB(highNborSide).item;\n            }\n            else {\n                highNborSide = this.scanLine.NextHighB(lowNborSide).item;\n            }\n            return this.InsertParallelReflectionSegment(start, end, eventObstacle, lowNborSide, highNborSide, action);\n        }\n    }\n    AddReflectionEvent(previousSite, side, site) {\n        /*Assert.assert(\n          null !=  this.scanLine.Find(side),\n          \"AddReflectionEvent could not find 'side' in the scanline\",\n        )*/\n        // Add an event that will be drained when a side spanning the scanline-parallel is loaded\n        // as the sweep moves \"up\".\n        const lowSide = side;\n        if (lowSide != null) {\n            this.eventQueue.Enqueue(new LowReflectionEvent(previousSite, lowSide, site));\n        }\n        else {\n            this.eventQueue.Enqueue(new HighReflectionEvent(previousSite, side, site));\n        }\n    }\n    AddSideToScanLine(side, scanPos) {\n        const node = this.scanLine.Insert(side, scanPos);\n        // Now get any pending LookaheadScan intersections along this side.\n        this.LoadReflectionEvents(side);\n        return node;\n    }\n    RemoveSideFromScanLine(sideNode, scanPos) {\n        this.scanLine.Remove(sideNode.item, scanPos);\n    }\n    PointCompare(lhs, rhs) {\n        return this.ScanDirection.Compare(lhs, rhs);\n    }\n    Clear() {\n        this.ObstacleTree.Clear();\n        this.eventQueue = new EventQueue();\n        this.HorizontalScanSegments = new ScanSegmentTree(ScanDirection.HorizontalInstance);\n        this.VerticalScanSegments = new ScanSegmentTree(ScanDirection.VerticalInstance);\n        this.VisibilityGraph = null;\n    }\n    ProcessEvents() {\n        // Note: Sentinel vertices are not in EventQueue so eventcount will go to 0.\n        while (this.eventQueue.Count > 0) {\n            const evt = this.eventQueue.Dequeue();\n            if (evt instanceof OpenVertexEvent) {\n                this.ProcessEventO(evt);\n            }\n            else if (evt instanceof LowBendVertexEvent) {\n                this.ProcessEventLB(evt);\n            }\n            else if (evt instanceof HighBendVertexEvent) {\n                this.ProcessEventHB(evt);\n            }\n            else if (evt instanceof CloseVertexEvent) {\n                this.ProcessEventCV(evt);\n            }\n            else if (evt instanceof LowReflectionEvent) {\n                this.ProcessEventLR(evt);\n            }\n            else if (evt instanceof HighReflectionEvent) {\n                this.ProcessEventHR(evt);\n            }\n            else {\n                this.ProcessCustomEvent(evt);\n            }\n            this.LowNeighborSides.Clear();\n            this.HighNeighborSides.Clear();\n        }\n        // endwhile there are events\n        // Ensure we have no leftovers in the scanline - we should have the two sentinels and nothing else.\n        /*Assert.assert(\n          2 === this.scanLine.Count,\n          'There are leftovers in the scanline',\n        )*/\n    }\n    ProcessCustomEvent(evt) {\n        // These are events specific to the derived class; by default there are none.\n        /*Assert.assert(false, 'Unknown event type ' + evt)*/\n    }\n    ScanLineCrossesObstacle(eventSite, obstacle) {\n        // An inner or outer neighbor's side is only an overlap start/stop candidate if its obstacle\n        // brackets the open/close event's Perpendicular Scan coord.\n        return (this.ScanDirection.ComparePerpCoord(eventSite, obstacle.VisibilityBoundingBox.leftBottom) > 0 &&\n            this.ScanDirection.ComparePerpCoord(eventSite, obstacle.VisibilityBoundingBox.rightTop) < 0);\n    }\n    FindInitialNeighborSides(sideNode, t) {\n        t.lowNborSideNode = this.scanLine.NextLowR(sideNode);\n        t.highNborSideNode = this.scanLine.NextHighR(sideNode);\n    }\n    // As described in the doc, we stop at the first neighbor of the appropriate side type that we touch\n    // the border of, even if that's just skimming along the extreme vertex of it, because those will\n    // continue the chain of open/close+addSegment, and we don't want to follow the full length of the\n    // segment each time if there are a lot of collinear obstacle open/close events.\n    FindNeighborsBRR(vertexEvent, lowSideNode, highSideNode) {\n        this.LowNeighborSides.Clear();\n        this.HighNeighborSides.Clear();\n        // Find the first HighObstacleSide in the low (scanline-decreasing) direction (this may be the low\n        // sentinel) and the lowest LowObstacleSide toward that that we cross *through*, if any.  Then do\n        // the same thing in the high direction.  If we are not overlapped, then we'll jump out immediately\n        // from SkipToNeighbor, so there won't be a lot of redundant effort in that case.\n        this.FindNeighbors(vertexEvent, lowSideNode, this.LowNeighborSides);\n        this.FindNeighbors(vertexEvent, highSideNode, this.HighNeighborSides);\n    }\n    FindNeighbors(vertexEvent, sideNode, neighborSides) {\n        // vertexEvent.Site is on one of vertexEvent.Obstacle.Active(Low|High)Side, so we must get the\n        // appropriate vertex on whichever one of those Active*Sides is sideNode.\n        const sideReferencePoint = vertexEvent instanceof OpenVertexEvent ? sideNode.item.Start : sideNode.item.End;\n        const t = { lowNborSideNode: null, highNborSideNode: null };\n        this.FindInitialNeighborSides(sideNode, t);\n        this.SkipToNeighbor(this.ScanDirection.OppositeDirection, sideNode.item, sideReferencePoint, t.lowNborSideNode, neighborSides);\n        this.SkipToNeighbor(this.ScanDirection.Dir, sideNode.item, sideReferencePoint, t.highNborSideNode, neighborSides);\n    }\n    SkipToNeighbor(nborSearchDir, side, sideReferencePoint, nborNode, neighborSides) {\n        // Find the first neighbor side (LowObstacleSide if going high, HighObstacleSide if going low) and\n        // the side of opposite type (which would potentially end overlap), that that we cross *through*, if any.\n        let overlapSideNode = null;\n        let interveningGroupSide = null;\n        for (;; nborNode = this.scanLine.Next(nborSearchDir, nborNode)) {\n            // Ignore the opposite side of the current obstacle.\n            if (nborNode.item.Obstacle === side.Obstacle) {\n                continue;\n            }\n            if (nborNode.item.Obstacle.IsGroup) {\n                if (this.ProcessGroupSideEncounteredOnTraversalToNeighbor(nborNode, sideReferencePoint, nborSearchDir)) {\n                    // Keep the first one (outermost) encountered.\n                    if (interveningGroupSide == null) {\n                        interveningGroupSide = nborNode.item;\n                    }\n                }\n                continue;\n            }\n            // Check for overlap-ending obstacle.\n            if (nborNode.item instanceof HighObstacleSide === StaticGraphUtility.IsAscending(nborSearchDir)) {\n                if (this.ScanLineCrossesObstacle(sideReferencePoint, nborNode.item.Obstacle)) {\n                    overlapSideNode = nborNode;\n                    interveningGroupSide = null;\n                }\n                continue;\n            }\n            // If we're here, we found the neighbor we were looking for.\n            break;\n        }\n        neighborSides.SetSides(nborSearchDir, nborNode, overlapSideNode, interveningGroupSide);\n    }\n    // end this.ProcessEvent(CloseVertexEvent)\n    ProcessGroupSideEncounteredOnTraversalToNeighbor(nborNode, sideReferencePoint, nborSearchDir) {\n        if (!this.ScanLineCrossesObstacle(sideReferencePoint, nborNode.item.Obstacle)) {\n            return false;\n        }\n        // We don't stop overlap or neighbor-traversal for groups, because we must go through the boundary;\n        // neither do we create overlapped edges (unless we're inside a non-group obstacle).  Instead we turn\n        // the boundary crossing on or off based on group membership at ShortestPath-time.\n        const dirToInsideOfGroup = nborNode.item instanceof LowObstacleSide === StaticGraphUtility.IsAscending(nborSearchDir)\n            ? nborSearchDir\n            : CompassVector.OppositeDir(nborSearchDir);\n        const intersect = this.ScanLineIntersectSide(sideReferencePoint, nborNode.item);\n        this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, nborNode.item.Obstacle, dirToInsideOfGroup);\n        return true;\n    }\n    FindNeighborsAndProcessVertexEvent(lowSideNode, highSideNode, vertexEvent) {\n        this.CurrentGroupBoundaryCrossingMap.Clear();\n        this.FindNeighborsBRR(vertexEvent, lowSideNode, highSideNode);\n        this.ProcessVertexEvent(lowSideNode, highSideNode, vertexEvent);\n        // Clear this again because we don't want Reflections to access stale values.\n        this.CurrentGroupBoundaryCrossingMap.Clear();\n    }\n    ProcessEventO(openVertEvent) {\n        var _a, _b;\n        // First insert the two new lines into the scanline.  Note: Although the lines are clockwise oriented,\n        // LowObstacleSide and HighObstacleSide take a parameter to know when to go counterclockwise.\n        const obstacle = openVertEvent.Obstacle;\n        obstacle.CreateInitialSides(openVertEvent.Vertex, this.ScanDirection);\n        /*Assert.assert(\n          !this.IsFlat(obstacle.ActiveLowSide),\n          'OpenVertexEvent ActiveLowSide should not be flat',\n        )*/\n        /*Assert.assert(\n          !this.IsFlat(obstacle.ActiveHighSide),\n          'RemoveCollinearSides should have been called',\n        )*/\n        //DevTraceIfFlatSide(true, obstacle.ActiveLowSide.Start, obstacle.ActiveHighSide.Start);\n        // Adding can rotate the RBTree which modifies RBNodes so get the lowSideNode after adding highSideNode.\n        // AddSideToScanLine loads any reflection events for the side.\n        this.AddSideToScanLine(obstacle.ActiveLowSide, openVertEvent.Site);\n        const highSideNode = this.AddSideToScanLine(obstacle.ActiveHighSide, openVertEvent.Site);\n        const lowSideNode = this.scanLine.Find(obstacle.ActiveLowSide);\n        // Get the neighbors.  In the simple, non-overlapped case, we'll generate a segment between them which\n        // includes the vertex point (and any flat border of the current obstacle).  These neighbors will\n        // never be null; one or both may be the fake sentinel borders at the graphBox limits.\n        this.FindNeighborsAndProcessVertexEvent(lowSideNode, highSideNode, openVertEvent);\n        // Look for Reflections.  If the ScanSegments we just added generated any\n        // ReflectionEvents, then the Active*Side to that side may cover them, or if we're overlapped,\n        // the Active*Side of the overlapping obstacle may if there is a non-overlapped segment extension.\n        // Check the neighbors in both directions.\n        const lowReflector = (_a = this.LowNeighborSides.GroupSideInterveningBeforeLowNeighbor) !== null && _a !== void 0 ? _a : this.LowNeighborSides.LowNeighborSide;\n        if (this.SideReflectsUpward(lowReflector)) {\n            this.LoadReflectionEvents(obstacle.ActiveLowSide);\n        }\n        const highReflector = (_b = this.HighNeighborSides.GroupSideInterveningBeforeHighNeighbor) !== null && _b !== void 0 ? _b : this.HighNeighborSides.HighNeighborSide;\n        if (this.SideReflectsUpward(highReflector)) {\n            this.LoadReflectionEvents(obstacle.ActiveHighSide);\n        }\n        // If this is a flat side it must absorb any outstanding reflection sites.\n        if (obstacle.ActiveHighSide.Start !== obstacle.ActiveLowSide.Start) {\n            // Create a temp HighObstacleSide so the \"next vertex\" moves in the correct direction.\n            const tempSide = new HighObstacleSide(obstacle, openVertEvent.Vertex, this.ScanDirection);\n            this.lookaheadScan.RemoveSitesForFlatBottom(tempSide.Start, tempSide.End);\n        }\n        // Add events for the low and high sides.\n        this.EnqueueLowBendVertexEvent(obstacle.ActiveLowSide);\n        this.EnqueueHighBendOrCloseVertexEvent(obstacle.ActiveHighSide);\n    }\n    // end this.ProcessEvent(OpenVertexEvent)\n    ProcessEventLB(lowVertEvent) {\n        // Note:  we only draw lines only from \"interesting\" vertices, which would be those\n        // that open or close an obstacle, as well as staircase Reflections (see doc). This means\n        // Low/HighVertexEvents routines will just track the change in ActiveLowSide/ActiveHighSide.\n        // This is a vertex on the low side of the obstacle.  Update the ActiveLowSide in the obstacle\n        // and scanline (this also checks for Reflection events).\n        const obstacle = lowVertEvent.Obstacle;\n        const lowSide = new LowObstacleSide(obstacle, lowVertEvent.Vertex, this.ScanDirection);\n        // If the new lowSide is flat we don't remove it due to potential overlaps; that lets any collinear\n        // OpenVertexEvents know they are overlapped (touching === overlap).  When we get to CloseVertexEvent,\n        // keeping the current ActiveLowSide in the scanline tells us how when the interior sides stop\n        // so we know when we've found a neighbor.  Similarly, if we're turning down toward the\n        // scanline, we let CloseVertexEvent remove the side (in case there are coincident vertices).\n        // That leaves the case of still ascending, where we replace the side in the scanline.\n        if (this.ScanDirection.ComparePerpCoord(lowSide.End, lowSide.Start) > 0) {\n            this.RemoveSideFromScanLine(this.scanLine.Find(obstacle.ActiveLowSide), lowVertEvent.Site);\n            this.AddSideToScanLine(lowSide, lowVertEvent.Site);\n            obstacle.ActiveLowSide = lowSide;\n            this.EnqueueLowBendVertexEvent(lowSide);\n        }\n    }\n    // end this.ProcessEvent(LowBendVertexEvent)\n    EnqueueLowBendVertexEvent(lowSide) {\n        // We've already ensured the extension is valid so just queue the next event.\n        this.eventQueue.Enqueue(new LowBendVertexEvent(lowSide.Obstacle, lowSide.EndVertex));\n    }\n    ProcessEventHB(highVertEvent) {\n        // See comments in LowBendVertexEvent; this is mostly the same thing to the other side.\n        const obstacle = highVertEvent.Obstacle;\n        const highSide = new HighObstacleSide(obstacle, highVertEvent.Vertex, this.ScanDirection);\n        this.RemoveSideFromScanLine(this.scanLine.Find(obstacle.ActiveHighSide), highVertEvent.Site);\n        const highSideNode = this.AddSideToScanLine(highSide, highVertEvent.Site);\n        obstacle.ActiveHighSide = highSide;\n        this.EnqueueHighBendOrCloseVertexEvent(obstacle.ActiveHighSide);\n        // If this is an extreme high-side lateral vertex on the horizontal pass turning to an upward-reflecting\n        // side - i.e. if it is a vertex on the right-most border of the bounding box, and the new HighObstacleSide\n        // has negative slope - then we may have a situation where a neighbor LowObstacleSide reflects downward and\n        // spans this entire HighObstacleSide and a little more:\n        //     #\n        //       #\n        //      .  #\n        //       \\   #\n        //        .    #\n        //               #\n        // The \".\\.\" side is completely spanned by the '#' side and because of the tilt directions, lookahead\n        // will not happen, therefore reflections will not happen and there will be no scansegments between the\n        // two sides.  This could lead to spurious overlaps.  So in this case we drop in an extra lookahead.\n        // (This is not an issue for other tilt directions - there is always a reflection chain generated).\n        // Test is RectilinearFileTests.Overlap_ExtremeSide_Lookahead.\n        if (this.wantReflections &&\n            this.ScanDirection.IsHorizontal &&\n            highSide.Start.x === obstacle.VisibilityBoundingBox.right &&\n            this.SideReflectsUpward(highSide)) {\n            const nborSideNode = this.scanLine.NextHighR(highSideNode);\n            if (nborSideNode.item instanceof LowObstacleSide && this.SideReflectsDownward(nborSideNode.item)) {\n                if (!obstacle.isOverlapped || !this.ObstacleTree.PointIsInsideAnObstacle(highSide.Start, this.ScanDirection)) {\n                    this.StoreLookaheadSite(nborSideNode.item.Obstacle, highSide, highSide.Start, true);\n                    this.LoadReflectionEvents(nborSideNode.item);\n                }\n            }\n        }\n    }\n    EnqueueHighBendOrCloseVertexEvent(highSide) {\n        // If the next side segment after highSide is ascending from the scanline we want to queue another\n        // HighBendVertexEvent; otherwise it is flat or turns down toward the scanline so queue a CloseVertexEvent.\n        const obstacle = highSide.Obstacle;\n        const nextHighSideEnd = this.ScanDirection.IsHorizontal\n            ? highSide.EndVertex.prevOnPolyline\n            : highSide.EndVertex.nextOnPolyline;\n        if (this.ScanDirection.ComparePerpCoord(nextHighSideEnd.point, highSide.End) > 0) {\n            this.eventQueue.Enqueue(new HighBendVertexEvent(obstacle, highSide.EndVertex));\n        }\n        else {\n            this.eventQueue.Enqueue(new CloseVertexEvent(obstacle, highSide.EndVertex));\n        }\n    }\n    // end this.ProcessEvent(HighBendVertexEvent)\n    CreateCloseEventSegmentsAndFindNeighbors(closeVertEvent) {\n        const obstacle = closeVertEvent.Obstacle;\n        // DevTraceIfFlatSide(false, obstacle.ActiveLowSide.End, obstacle.ActiveHighSide.End);\n        let lowSideNode = this.scanLine.Find(obstacle.ActiveLowSide);\n        let highSideNode = this.scanLine.Find(obstacle.ActiveHighSide);\n        // Two sides coming together at a top point will be reverse-ordered in the scanline,\n        // because their projections ahead of the intersection are slope-based.  This must\n        // be the case in order to maintain scanline consistency.  Therefore we need to\n        // check the comparison and reverse the local variables if necessary.  Fortunately\n        // we only concern ourselves with the actual Low-vs-High side type for neighbors,\n        // not the sides of the obstacle.\n        if (1 === this.scanLine.Compare(obstacle.ActiveLowSide, obstacle.ActiveHighSide)) {\n            const temp = lowSideNode;\n            lowSideNode = highSideNode;\n            highSideNode = temp;\n        }\n        // As with OpenVertexEvent, the idea here is to find the neighbors and draw the line between them\n        // that includes the event vertex (and any flat top obstacle side), with consideration for overlaps.\n        this.FindNeighborsAndProcessVertexEvent(lowSideNode, highSideNode, closeVertEvent);\n        // Inner overlaps: any overlapped sides coming out of the obstacle must have reflection events\n        // drained for any that were generated from sides of the closing obstacle if they extend\n        // outside the closing obstacle.\n        if (this.wantReflections && obstacle.isOverlapped) {\n            for (let nextNode = this.scanLine.NextHighR(lowSideNode); nextNode.item !== highSideNode.item; nextNode = this.scanLine.NextHighR(nextNode)) {\n                this.LoadReflectionEvents(nextNode.item);\n            }\n        }\n        // Remove the obstacle from the Scanline.  This comes after the foregoing which is why it's a\n        // separate function; the RBTree modifies RBNodes, so doing the .Remove at the end of a separate\n        // function ensures we won't access RBNodes that may no longer contain what we expect.\n        this.scanLine.Remove(obstacle.ActiveLowSide, closeVertEvent.Site);\n        this.scanLine.Remove(obstacle.ActiveHighSide, closeVertEvent.Site);\n    }\n    ProcessEventCV(closeVertEvent) {\n        // This event closes the obstacle.  It removes the ActiveLowSide and ActiveHighSide from the scanline and does\n        // not add new sides.  As above, see comments in OpenVertexEvent and its callees for more detailed explanations.\n        this.CreateCloseEventSegmentsAndFindNeighbors(closeVertEvent);\n        // For reflection, in addition to the delayed lookahead we do in the other *VertexEvents, we need to\n        // detect pending reflections up to an already loaded obstacle side.  This may be transitive; using\n        // H directions as an example:\n        //  (A). Obstacles A and B lean rightward such that a vertical line can be drawn from the lower side\n        //    of ObstacleA downward to the right of ObstacleB (missing it) and hitting Obstacle C.\n        //  (B). ObstacleC's start point is above the start points of Obstacles A and B.\n        //  (C). ObjectC reflects a Lookahead scan up along the line cited in (A).\n        // To handle this, whenever we close an object, see if either nbor side spans lookahead scan points.\n        // If so, then add the events.  Otherwise, we know that a new side for those nbor objects, or for\n        // subsequent higher objects, will be created at some point (unless we run out of obstacles).\n        // Since we do reflections only in staircase situations, these lookahead events will be discarded\n        // (because the existing edge would have to have already been processed as an immediate neighbor,\n        // in order to satisfy the definition of a staircase).  See RectilinearTests.ReflectionsDetectedByAlreadyLoadedSide.\n        // Check the neighbors in both directions for reflection events.\n        // When querying for lookahead sites for a nborSide, always test the full nborSide range if\n        // the opposite nborSide reflects upward, because we will have generated a lookahead site for the\n        // current eventObstacle on that upward-reflecting nborSide.  For example, restricting the\n        // lowNborSide lookahead-site query to the currentEventObstacle.ActiveLowSide would pick up\n        // any lookahead sites stored on eventObstacle.ActiveLowSide, but would not pick up a lookahead\n        // site that the current CloseVertexEvent just stored on the highNborSide).\n        // Fix: Updated this to remove restricted-range as it skips the range that includes the far side of the\n        // current obstacle when called for neighbors that extend across the top vertex.\n        const lowNborSide = this.LowNeighborSides.LowNeighbor.item;\n        const highNborSide = this.HighNeighborSides.HighNeighbor.item;\n        const obstacle = closeVertEvent.Obstacle;\n        this.LoadReflectionEvents(lowNborSide);\n        this.LoadReflectionEvents(highNborSide);\n        // This prepares the object for the second (perpendicular) sweep.\n        obstacle.Close();\n    }\n    ProcessEventLR(lowIntEvent) {\n        // Unlike LowBendVertexEvent we don't update the ActiveLowSide in the obstacle and scanline.\n        const obstacle = lowIntEvent.Side.Obstacle;\n        // Add a perpendicular segment from the previous site to the lowNbor intersection, then from\n        // the lowNbor intersection to the event site.\n        const lowNborSide = this.scanLine.NextLowB(lowIntEvent.Side).item;\n        if (this.AddPerpendicularReflectionSegment(lowIntEvent, lowIntEvent.Side, lowNborSide)) {\n            if (this.AddParallelReflectionSegment(obstacle, lowNborSide, null, lowIntEvent)) {\n                // We may have just added a reflection that reflects back onto obstacle.ActiveLowSide.\n                this.LoadReflectionEvents(obstacle.ActiveLowSide);\n            }\n        }\n    }\n    // end this.ProcessEvent(LowReflectionEvent)\n    ProcessEventHR(highIntEvent) {\n        // Unlike HighBendVertexEvent we don't update the ActiveHighSide in the obstacle and scanline.\n        const obstacle = highIntEvent.Side.Obstacle;\n        // Add a perpendicular segment from the previous site to the highNbor intersection, then from\n        // the highNbor intersection to the event site.\n        const highNborSide = this.scanLine.NextHighB(highIntEvent.Side).item;\n        if (this.AddPerpendicularReflectionSegment(highIntEvent, highIntEvent.Side, highNborSide)) {\n            if (this.AddParallelReflectionSegment(obstacle, null, highNborSide, highIntEvent)) {\n                // We may have just added a reflection that reflects back onto obstacle.ActiveHighSide.\n                this.LoadReflectionEvents(obstacle.ActiveHighSide);\n            }\n        }\n    }\n    // end this.ProcessEvent(HighReflectionEvent)\n    MakeInBoundsLocation(location) {\n        const xPos = Math.max(location.x, this.ObstacleTree.GraphBox.left);\n        const yPos = Math.max(location.y, this.ObstacleTree.GraphBox.bottom);\n        return new Point(Math.min(xPos, this.ObstacleTree.GraphBox.right), Math.min(yPos, this.ObstacleTree.GraphBox.top));\n    }\n    IsInBoundsV(vertex) {\n        return this.IsInBoundsP(vertex.point);\n    }\n    IsInBoundsP(p) {\n        return PointComparer.EqualPP(p, this.MakeInBoundsLocation(p));\n    }\n}\n// This ensures that sentinels lie outside the graph boundaries, to ensure the scanline orders\n// orders the sentinels properly.  Its borders are not drawn; instead the borders of objects\n// already contain padding and this is assumed to be sufficient to provide space for routing.\n/* const */ VisibilityGraphGenerator.SentinelOffset = 1;\n//# sourceMappingURL=VisibilityGraphGenerator.js.map","import { CompassVector } from '../../math/geometry/compassVector';\nimport { VisibilityVertex } from '../visibility/VisibilityVertex';\nexport class VisibilityVertexRectilinear extends VisibilityVertex {\n    constructor(point) {\n        super(point);\n    }\n    SetVertexEntry(entry) {\n        if (this.VertexEntries == null) {\n            this.VertexEntries = new Array(4);\n        }\n        this.VertexEntries[CompassVector.ToIndex(entry.Direction)] = entry;\n    }\n    RemoveVertexEntries() {\n        this.VertexEntries = null;\n    }\n}\n//# sourceMappingURL=VisibilityVertexRectiline.js.map","import { SweepEvent } from '../spline/coneSpanner/SweepEvent';\nexport class BasicReflectionEvent extends SweepEvent {\n    // Called by StoreLookaheadSite only.\n    constructor(initialObstacle, reflectingObstacle, site) {\n        super();\n        this.InitialObstacle = initialObstacle;\n        this.ReflectingObstacle = reflectingObstacle;\n        this.site = site;\n    }\n    // Called by LowReflectionEvent or HighReflectionEvent ctors, which are called out of\n    // AddReflectionEvent, which in turn is called by LoadLookaheadIntersections.\n    // In this case we know the eventObstacle and initialObstacle are the same obstacle (the\n    // one that the reflected ray bounced off of, to generate the Left/HighReflectionEvent).\n    static mk(previousSite, reflectingObstacle, site) {\n        const ret = new BasicReflectionEvent(previousSite.ReflectingObstacle, reflectingObstacle, site);\n        ret.PreviousSite = previousSite;\n        return ret;\n    }\n    // If true, we have a staircase situation.\n    IsStaircaseStep(reflectionTarget) {\n        return this.InitialObstacle === reflectionTarget;\n    }\n    get Site() {\n        return this.site;\n    }\n}\n//# sourceMappingURL=basicReflectionEvent.js.map","// a wrapper arownd VisibilityEdge representing the same edge\nimport { CompassVector } from '../../../math/geometry/compassVector';\nimport { VisibilityEdge } from '../../visibility/VisibilityEdge';\n// but oriented along the X or the Y axis\nexport class AxisEdge extends VisibilityEdge {\n    constructor(source, target) {\n        super(source, target);\n        this.RightNeighbors = new Set();\n        this.setOfLongestSegs = new Set();\n        this.RightBound = Number.POSITIVE_INFINITY;\n        this.LeftBound = Number.NEGATIVE_INFINITY;\n        this.Direction = CompassVector.DirectionFromPointToPoint(source.point, target.point);\n        /*Assert.assert(\n          this.Direction === Direction.East || this.Direction === Direction.North,\n        )*/\n    }\n    AddRightNeighbor(edge) {\n        this.RightNeighbors.add(edge);\n    }\n    get LongestNudgedSegments() {\n        return this.setOfLongestSegs;\n    }\n    AddLongestNudgedSegment(segment) {\n        this.setOfLongestSegs.add(segment);\n    }\n    BoundFromRight(rightbound) {\n        rightbound = Math.max(rightbound, this.LeftBound);\n        this.RightBound = Math.min(rightbound, this.RightBound);\n    }\n    BoundFromLeft(leftbound) {\n        leftbound = Math.min(leftbound, this.RightBound);\n        this.LeftBound = Math.max(leftbound, this.LeftBound);\n    }\n}\n//# sourceMappingURL=AxisEdge.js.map","import { SweepEvent } from '../../spline/coneSpanner/SweepEvent';\nexport class AxisEdgeHighPointEvent extends SweepEvent {\n    constructor(edge, point) {\n        super();\n        this.site = point;\n        this.AxisEdge = edge;\n    }\n    get Site() {\n        return this.site;\n    }\n}\n//# sourceMappingURL=AxisEdgeHighPointEvent.js.map","import { SweepEvent } from '../../spline/coneSpanner/SweepEvent';\nexport class AxisEdgeLowPointEvent extends SweepEvent {\n    constructor(edge, point) {\n        super();\n        this.site = point;\n        this.AxisEdge = edge;\n    }\n    get Site() {\n        return this.site;\n    }\n}\n//# sourceMappingURL=AxisEdgeLowPointEvent.js.map","export class AxisEdgesContainer {\n    get Edges() {\n        return this.edges;\n    }\n    AddEdge(edge) {\n        this.UpPoint = edge.TargetPoint;\n        /*Assert.assert(!this.edges.has(edge))*/\n        this.edges.add(edge);\n    }\n    constructor(source) {\n        this.edges = new Set();\n        this.Source = source;\n    }\n    RemoveAxis(edge) {\n        /*Assert.assert(this.edges.has(edge))*/\n        this.edges.delete(edge);\n    }\n    IsEmpty() {\n        return this.edges.size === 0;\n    }\n}\n//# sourceMappingURL=AxisEdgesContainer.js.map","// sets the order of connector paths on the edges\n//\nimport { Queue } from 'queue-typescript';\nimport { CompassVector } from '../../../math/geometry/compassVector';\nimport { Direction } from '../../../math/geometry/direction';\nimport { compareNumbers } from '../../../utils/compare';\nimport { VisibilityGraph } from '../../visibility/VisibilityGraph';\nimport { AxisEdge } from './AxisEdge';\nimport { LinkedPoint } from './LinkedPoint';\nimport { PathEdge } from './PathEdge';\nexport class CombinatorialNudger {\n    get PathVisibilityGraph() {\n        return this.pathVisibilityGraph;\n    }\n    constructor(paths) {\n        // A new visibility graph is needed; the DAG of AxisEdges.\n        this.pathVisibilityGraph = new VisibilityGraph();\n        this.axisEdgesToPathOrders = new Map();\n        this.OriginalPaths = paths;\n    }\n    GetOrder() {\n        this.FillTheVisibilityGraphByWalkingThePaths();\n        this.InitPathOrder();\n        this.OrderPaths();\n        return this.axisEdgesToPathOrders;\n    }\n    FillTheVisibilityGraphByWalkingThePaths() {\n        for (const path of this.OriginalPaths) {\n            this.FillTheVisibilityGraphByWalkingPath(path);\n        }\n    }\n    FillTheVisibilityGraphByWalkingPath(path) {\n        const pathEdgesEnum = this.CreatePathEdgesFromPoints(it(), path.Width);\n        let t = pathEdgesEnum.next();\n        if (!t.done) {\n            path.SetFirstEdge(t.value);\n        }\n        while ((t = pathEdgesEnum.next()).done === false) {\n            path.AddEdge(t.value);\n        }\n        function* it() {\n            if (path.PathPoints instanceof LinkedPoint) {\n                for (let p = path.PathPoints; p != null; p = p.Next) {\n                    yield p.Point;\n                }\n            }\n            else {\n                for (const p of path.PathPoints)\n                    yield p;\n            }\n        }\n    }\n    *CreatePathEdgesFromPoints(pathPoints, width) {\n        let t = pathPoints.next();\n        let p0 = t.value;\n        while (!(t = pathPoints.next()).done) {\n            yield this.CreatePathEdge(p0, t.value, width);\n            p0 = t.value;\n        }\n    }\n    CreatePathEdge(p0, p1, width) {\n        const dir = CompassVector.DirectionFromPointToPoint(p0, p1);\n        switch (dir) {\n            case Direction.East:\n            case Direction.North:\n                return new PathEdge(this.GetAxisEdge(p0, p1), width);\n            case Direction.South:\n            case Direction.West: {\n                const e = new PathEdge(this.GetAxisEdge(p1, p0), width);\n                e.Reversed = true;\n                return e;\n            }\n            default:\n                throw new Error('Not a rectilinear path');\n        }\n    }\n    GetAxisEdge(p0, p1) {\n        return this.PathVisibilityGraph.AddEdgeF(p0, p1, (m, n) => new AxisEdge(m, n));\n    }\n    InitPathOrder() {\n        for (const axisEdge of this.PathVisibilityGraph.Edges) {\n            this.axisEdgesToPathOrders.set(axisEdge, new Array());\n        }\n        for (const p of this.OriginalPaths) {\n            for (const pathEdge of p.PathEdges()) {\n                this.axisEdgesToPathOrders.get(pathEdge.AxisEdge).push(pathEdge);\n            }\n        }\n    }\n    OrderPaths() {\n        for (const axisEdge of CombinatorialNudger.WalkGraphEdgesInTopologicalOrderIfPossible(this.PathVisibilityGraph)) {\n            this.OrderPathEdgesSharingEdge(axisEdge);\n        }\n    }\n    OrderPathEdgesSharingEdge(edge) {\n        const pathOrder = this.PathOrderOfVisEdge(edge);\n        pathOrder.sort(CombinatorialNudger.CompareTwoPathEdges);\n        let i = 0;\n        // fill the index\n        for (const pathEdge of pathOrder) {\n            pathEdge.Index = i++;\n        }\n    }\n    static CompareTwoPathEdges(x, y) {\n        if (x === y) {\n            return 0;\n        }\n        /*Assert.assert(x.AxisEdge === y.AxisEdge)*/\n        // Nudger.ShowOrderedPaths(null, new[] { x.Path, y.Path }, x.AxisEdge.SourcePoint, x.AxisEdge.TargetPoint);\n        const r = CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(x, y, x.AxisEdge, x.AxisEdge.Direction);\n        return r !== 0\n            ? r\n            : -CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(x, y, x.AxisEdge, CompassVector.OppositeDir(x.AxisEdge.Direction));\n    }\n    //\n    // axisEdge together with the axisEdgeIsReversed parameter define direction of the movement over the paths\n    static CompareInDirectionStartingFromAxisEdge(x, y, axisEdge, direction) {\n        while (true) {\n            x = CombinatorialNudger.GetNextPathEdgeInDirection(x, axisEdge, direction);\n            if (x == null) {\n                return 0;\n            }\n            y = CombinatorialNudger.GetNextPathEdgeInDirection(y, axisEdge, direction);\n            if (y == null) {\n                return 0;\n            }\n            if (x.AxisEdge === y.AxisEdge) {\n                direction = CombinatorialNudger.FindContinuedDirection(axisEdge, direction, x.AxisEdge);\n                axisEdge = x.AxisEdge;\n                const r = CombinatorialNudger.GetExistingOrder(x, y);\n                if (r === CombinatorialNudger.NotOrdered) {\n                    continue;\n                }\n                return direction === axisEdge.Direction ? r : -r;\n            }\n            // there is a fork\n            const forkVertex = direction === axisEdge.Direction ? axisEdge.Target : axisEdge.Source;\n            const xFork = CombinatorialNudger.OtherVertex(x.AxisEdge, forkVertex);\n            const yFork = CombinatorialNudger.OtherVertex(y.AxisEdge, forkVertex);\n            const projection = CombinatorialNudger.ProjectionForCompare(axisEdge, direction !== axisEdge.Direction);\n            return compareNumbers(projection(xFork.point), projection(yFork.point));\n        }\n    }\n    static FindContinuedDirection(edge, direction, nextAxisEdge) {\n        if (edge.Direction === direction)\n            return nextAxisEdge.Source === edge.Target ? nextAxisEdge.Direction : CompassVector.OppositeDir(nextAxisEdge.Direction);\n        return nextAxisEdge.Source === edge.Source ? nextAxisEdge.Direction : CompassVector.OppositeDir(nextAxisEdge.Direction);\n    }\n    static OtherVertex(axisEdge, v) {\n        return axisEdge.Source === v ? axisEdge.Target : axisEdge.Source;\n    }\n    static ProjectionForCompare(axisEdge, isReversed) {\n        return axisEdge.Direction === Direction.North\n            ? isReversed\n                ? (p) => -p.x\n                : (p) => p.x\n            : isReversed\n                ? (p) => p.y\n                : (p) => -p.y;\n    }\n    static GetNextPathEdgeInDirection(e, axisEdge, direction) {\n        /*Assert.assert(e.AxisEdge === axisEdge)*/\n        return axisEdge.Direction === direction ? (e.Reversed ? e.Prev : e.Next) : e.Reversed ? e.Next : e.Prev;\n    }\n    static GetExistingOrder(x, y) {\n        const xi = x.Index;\n        if (xi === -1) {\n            return CombinatorialNudger.NotOrdered;\n        }\n        const yi = y.Index;\n        /*Assert.assert(yi !== -1)*/\n        return compareNumbers(xi, yi);\n    }\n    PathOrderOfVisEdge(axisEdge) {\n        return this.axisEdgesToPathOrders.get(axisEdge);\n    }\n    static InitQueueOfSources(queue, dictionary, graph) {\n        for (const v of graph.Vertices()) {\n            const inDegree = v.InEdgesLength();\n            dictionary.set(v, inDegree);\n            if (inDegree === 0) {\n                queue.enqueue(v);\n            }\n        }\n        /*Assert.assert(queue.length > 0)*/\n    }\n    static *WalkGraphEdgesInTopologicalOrderIfPossible(visibilityGraph) {\n        // Here the visibility graph is always a DAG since the edges point only to North and East\n        // where possible\n        const sourcesQueue = new Queue();\n        const inDegreeLeftUnprocessed = new Map();\n        CombinatorialNudger.InitQueueOfSources(sourcesQueue, inDegreeLeftUnprocessed, visibilityGraph);\n        while (sourcesQueue.length > 0) {\n            const visVertex = sourcesQueue.dequeue();\n            for (const edge of visVertex.OutEdges) {\n                const incomingEdges = inDegreeLeftUnprocessed.get(edge.Target);\n                inDegreeLeftUnprocessed.set(edge.Target, incomingEdges - 1);\n                if (incomingEdges === 1) {\n                    sourcesQueue.enqueue(edge.Target);\n                }\n                yield edge;\n            }\n        }\n    }\n}\nCombinatorialNudger.NotOrdered = Number.MAX_VALUE;\n//# sourceMappingURL=CombinatorialNudger.js.map","// The class is looking for the free space around AxisEdges\nimport { Point } from '../../../math/geometry/point';\nimport { CompassVector } from '../../../math/geometry/compassVector';\n//import{ {DebugCurve} from '../../../math/geometry/}DebugCurve'\nimport { Direction } from '../../../math/geometry/direction';\nimport { GeomConstants } from '../../../math/geometry/geomConstants';\nimport { RBTree } from '../../../math/RBTree/rbTree';\nimport { compareNumbers } from '../../../utils/compare';\nimport { LeftObstacleSide } from '../../spline/coneSpanner/LeftObstacleSide';\nimport { LeftVertexEvent } from '../../spline/coneSpanner/LeftVertexEvent';\nimport { RightObstacleSide } from '../../spline/coneSpanner/RightObstacleSide';\nimport { RightVertexEvent } from '../../spline/coneSpanner/RightVertexEvent';\nimport { VertexEvent } from '../../spline/coneSpanner/VertexEvent';\nimport { LineSweeperBase } from '../../visibility/LineSweeperBase';\nimport { AxisEdgeHighPointEvent } from './AxisEdgeHighPointEvent';\nimport { AxisEdgeLowPointEvent } from './AxisEdgeLowPointEvent';\nimport { AxisEdgesContainer } from './AxisEdgesContainer';\nimport { DebugCurve } from '../../../math/geometry/debugCurve';\nexport class FreeSpaceFinder extends LineSweeperBase {\n    //\n    // edges to find the empty space around\n    constructor(direction, obstacles, axisEdgesToObstaclesTheyOriginatedFrom, pathOrders, axisEdges) {\n        super(obstacles, new CompassVector(direction).ToPoint());\n        this.DirectionPerp = new CompassVector(direction).Right.ToPoint();\n        this.PathOrders = pathOrders;\n        this.xProjection = direction === Direction.North ? (p) => p.x : (p) => -p.y;\n        this.edgeContainersTree = new RBTree((a, b) => this.CompareAA(a, b));\n        this.SweepPole = CompassVector.VectorDirection(this.SweepDirection);\n        /*Assert.assert(CompassVector.IsPureDirection(this.SweepPole))*/\n        this.AxisEdges = axisEdges;\n        this.AxisEdgesToObstaclesTheyOriginatedFrom = axisEdgesToObstaclesTheyOriginatedFrom;\n    }\n    //   Array<Path> EdgePaths { get; set; }\n    // VisibilityGraph PathVisibilityGraph { get; set; }\n    // calculates the right offsets\n    FindFreeSpace() {\n        this.InitTheQueueOfEvents();\n        this.ProcessEvents();\n        //    ShowAxisEdges();\n    }\n    ProcessEvents() {\n        while (this.EventQueue.Count > 0) {\n            this.ProcessEvent(this.EventQueue.Dequeue());\n        }\n    }\n    ProcessEvent(sweepEvent) {\n        if (sweepEvent instanceof VertexEvent) {\n            this.ProcessVertexEvent(sweepEvent);\n        }\n        else {\n            this.Z = this.GetZP(sweepEvent.Site);\n            if (sweepEvent instanceof AxisEdgeLowPointEvent) {\n                this.ProcessLowEdgeEvent(sweepEvent);\n            }\n            else {\n                /*Assert.assert(sweepEvent instanceof AxisEdgeHighPointEvent)*/\n                this.ProcessHighEdgeEvent(sweepEvent);\n            }\n        }\n    }\n    ProcessHighEdgeEvent(edgeForNudgingHighPointEvent) {\n        const edge = edgeForNudgingHighPointEvent.AxisEdge;\n        this.RemoveEdge(edge);\n        this.ConstraintEdgeWithObstaclesAtZ(edge, edge.Target.point);\n    }\n    ProcessLowEdgeEvent(lowEdgeEvent) {\n        const edge = lowEdgeEvent.AxisEdge;\n        const containerNode = this.GetOrCreateAxisEdgesContainer(edge);\n        containerNode.item.AddEdge(edge);\n        const prev = this.edgeContainersTree.previous(containerNode);\n        if (prev != null) {\n            for (const prevEdge of prev.item.edges) {\n                for (const ed of containerNode.item.edges) {\n                    this.TryToAddRightNeighbor(prevEdge, ed);\n                }\n            }\n        }\n        const next = this.edgeContainersTree.next(containerNode);\n        if (next != null) {\n            for (const ed of containerNode.item.Edges) {\n                for (const neEdge of next.item.edges) {\n                    this.TryToAddRightNeighbor(ed, neEdge);\n                }\n            }\n        }\n        this.ConstraintEdgeWithObstaclesAtZ(edge, edge.Source.point);\n    }\n    TryToAddRightNeighbor(leftEdge, rightEdge) {\n        if (this.ProjectionsOfEdgesOverlap(leftEdge, rightEdge)) {\n            leftEdge.AddRightNeighbor(rightEdge);\n        }\n    }\n    ProjectionsOfEdgesOverlap(leftEdge, rightEdge) {\n        return this.SweepPole === Direction.North\n            ? !(leftEdge.TargetPoint.y < rightEdge.SourcePoint.y - GeomConstants.distanceEpsilon ||\n                rightEdge.TargetPoint.y < leftEdge.SourcePoint.y - GeomConstants.distanceEpsilon)\n            : !(leftEdge.TargetPoint.x < rightEdge.SourcePoint.x - GeomConstants.distanceEpsilon ||\n                rightEdge.TargetPoint.x < leftEdge.SourcePoint.x - GeomConstants.distanceEpsilon);\n    }\n    // DebShowEdge(edge: AxisEdge, point: Point) {\n    //    //  ReSharper restore UnusedMember.Local\n    //    //  if (InterestingEdge(edge))\n    //    this.ShowEdge(edge, point);\n    // }\n    // // ReSharper disable SuggestBaseTypeForParameter\n    // ShowEdge(edge: AxisEdge, point: Point) {\n    //    //  ReSharper restore SuggestBaseTypeForParameter\n    //    let dd = this.GetObstacleBoundaries(\"black\");\n    //    let seg = new DebugCurve(1, \"red\", new LineSegment(edge.Source.point, edge.Target.point));\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd.Concat(new, [));\n    //    seg;\n    //    new DebugCurve(\"blue\", CurveFactory.CreateEllipse(3, 3, point));\n    // }\n    GetObstacleBoundaries(color) {\n        return this.Obstacles.map((p) => DebugCurve.mkDebugCurveWCI(1, color, p));\n    }\n    //\n    // a point on the edge on Z level\n    ConstraintEdgeWithObstaclesAtZ(edge, point) {\n        /*Assert.assert(point === edge.Source.point || point === edge.Target.point)*/\n        this.ConstraintEdgeWithObstaclesAtZFromLeft(edge, point);\n        this.ConstraintEdgeWithObstaclesAtZFromRight(edge, point);\n    }\n    ConstraintEdgeWithObstaclesAtZFromRight(edge, point) {\n        const node = this.GetActiveSideFromRight(point);\n        if (node == null) {\n            return;\n        }\n        if (this.NotRestricting(edge, node.item.Polyline)) {\n            return;\n        }\n        const x = this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(node.item);\n        edge.BoundFromRight(x.dot(this.DirectionPerp));\n    }\n    GetActiveSideFromRight(point) {\n        return this.LeftObstacleSideTree.findFirst((side) => FreeSpaceFinder.PointToTheLeftOfLineOrOnLineLocal(point, side.Start, side.End));\n    }\n    ConstraintEdgeWithObstaclesAtZFromLeft(edge, point) {\n        //    ShowNudgedSegAndPoint(point, nudgedSegment);\n        const node = this.GetActiveSideFromLeft(point);\n        if (node == null) {\n            return;\n        }\n        if (this.NotRestricting(edge, node.item.Polyline)) {\n            return;\n        }\n        const x = this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(node.item);\n        edge.BoundFromLeft(x.dot(this.DirectionPerp));\n    }\n    static PointToTheLeftOfLineOrOnLineLocal(a, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(a, linePoint0, linePoint1) > -FreeSpaceFinder.AreaComparisonEpsilon;\n    }\n    static PointToTheRightOfLineOrOnLineLocal(a, linePoint0, linePoint1) {\n        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, a) < FreeSpaceFinder.AreaComparisonEpsilon;\n    }\n    GetActiveSideFromLeft(point) {\n        return this.RightObstacleSideTree.findLast((side) => FreeSpaceFinder.PointToTheRightOfLineOrOnLineLocal(point, side.Start, side.End));\n    }\n    // ReSharper disable UnusedMember.Local\n    // ShowPointAndEdge(point: Point, edge: AxisEdge) {\n    //    //  ReSharper restore UnusedMember.Local\n    //    let curves: Array<ICurve> = this.GetCurves(point, edge);\n    //    LayoutAlgorithmSettings.Show(curves.ToArray());\n    // }\n    // // ReSharper disable UnusedMember.Local\n    // ShowPointAndEdgeWithSweepline(point: Point, edge: AxisEdge) {\n    //    //  ReSharper restore UnusedMember.Local\n    //    let curves: Array<ICurve> = this.GetCurves(point, edge);\n    //    curves.Add(new LineSegment(((this.SweepDirection * this.Z) + (10 * this.DirectionPerp)), ((this.SweepDirection * this.Z) - (10 * this.DirectionPerp))));\n    //    LayoutAlgorithmSettings.Show(curves.ToArray());\n    // }\n    // GetCurves(point: Point, edge: AxisEdge): Array<ICurve> {\n    //    let ellipse = CurveFactory.CreateEllipse(3, 3, point);\n    //    let curves = new Array<ICurve>(this.Obstacles.select(() => {  }, (<ICurve>(o))));\n    //    if ((edge.RightBound < Number.POSITIVE_INFINITY)) {\n    //        let rightOffset: number = edge.RightBound;\n    //        let del = (this.DirectionPerp * rightOffset);\n    //        curves.Add(new LineSegment((edge.Source.point + del), (edge.Target.point + del)));\n    //    }\n    //    if ((edge.LeftBound > Number.NEGATIVE_INFINITY)) {\n    //        let leftOffset: number = edge.LeftBound;\n    //        let del = (this.DirectionPerp * leftOffset);\n    //        curves.Add(new LineSegment((edge.Source.point + del), (edge.Target.point + del)));\n    //    }\n    //    curves.AddRange(from, e, in, this.PathOrders.keys, let, a=e.SourcePoint, let, b=e.TargetPoint, select, new CubicBezierSegment(a, ((a * 0.8)\n    //                        + (b * 0.2)), ((a * 0.2)\n    //                        + (b * 0.8)), b)).Cast();\n    //    return curves;\n    // }\n    // GetCurvesTest(point: Point): Array<DebugCurve> {\n    //    let ellipse = CurveFactory.CreateEllipse(3, 3, point);\n    //    let curves = new Array<DebugCurve>(this.Obstacles.select(() => {  }, new DebugCurve(100, 1, \"black\", o)));\n    //    curves.AddRange(from, e, in, this.edgeContainersTree, from, axisEdge, in, e, let, a=axisEdge.Source.Point, let, b=axisEdge.Target.Point, select, new DebugCurve(100, 1, \"green\", new LineSegment(a, b)));\n    //    curves.AddRange(FreeSpaceFinder.RightNeighborsCurvesTest(this.edgeContainersTree));\n    //    return curves;\n    // }\n    // static RightNeighborsCurvesTest(rbTree: Array<AxisEdgesContainer>): Array<DebugCurve> {\n    //    for (let container of rbTree) {\n    //        for (let edge of container) {\n    //            for (let rn of edge.RightNeighbors) {\n    //                yield;\n    //                return new DebugCurve(100, 1, \"brown\", new LineSegment(FreeSpaceFinder.EdgeMidPoint(edge), FreeSpaceFinder.EdgeMidPoint(rn)));\n    //            }\n    //        }\n    //    }\n    // }\n    static EdgeMidPoint(edge) {\n        return Point.middle(edge.SourcePoint, edge.TargetPoint);\n    }\n    // ShowAxisEdges() {\n    //    //  ReSharper restore UnusedMember.Local\n    //    let dd = new Array<DebugCurve>(this.GetObstacleBoundaries(\"black\"));\n    //    let i: number = 0;\n    //    for (let axisEdge of this.AxisEdges) {\n    //        let color = DebugCurve.colors[i];\n    //        dd.Add(new DebugCurve(200, 1, color, new LineSegment(axisEdge.Source.point, axisEdge.Target.point)));\n    //        let perp: Point = new Point(0, 1);\n    //        // TODO: Warning!!!, inline IF is not supported ?\n    //        (axisEdge.Direction === Direction.East);\n    //        new Point(-1, 0);\n    //        if ((axisEdge.LeftBound !== Number.NEGATIVE_INFINITY)) {\n    //            dd.Add(new DebugCurve(200, 0.5, color, new LineSegment((axisEdge.Source.point\n    //                                    + (axisEdge.LeftBound * perp)), (axisEdge.Target.point\n    //                                    + (axisEdge.LeftBound * perp)))));\n    //        }\n    //        if ((axisEdge.RightBound !== Number.POSITIVE_INFINITY)) {\n    //            dd.Add(new DebugCurve(200, 0.5, color, new LineSegment((axisEdge.Source.point\n    //                                    - (axisEdge.RightBound * perp)), (axisEdge.Target.point\n    //                                    - (axisEdge.RightBound * perp)))));\n    //        }\n    //        i = ((i + 1)\n    //                    % DebugCurve.colors.length);\n    //    }\n    //    DebugCurveCollection.WriteToFile(dd, \"c:/tmp/ae\");\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);\n    // }\n    // // ReSharper disable UnusedMember.Local\n    // ShowAtPoint(point: Point) {\n    //    //  ReSharper restore UnusedMember.Local\n    //    let curves = this.GetCurvesTest(point);\n    //    LayoutAlgorithmSettings.ShowDebugCurves(curves.ToArray());\n    // }\n    GetOrCreateAxisEdgesContainer(edge) {\n        const source = edge.Source.point;\n        const ret = this.GetAxisEdgesContainerNode(source);\n        if (ret != null) {\n            return ret;\n        }\n        return this.edgeContainersTree.insert(new AxisEdgesContainer(source));\n    }\n    //\n    // the point has to be on the same line as the container\n    GetAxisEdgesContainerNode(point) {\n        const prj = this.xProjection(point);\n        const ret = this.edgeContainersTree.findFirst((cont) => this.xProjection(cont.Source) >= prj - GeomConstants.distanceEpsilon / 2);\n        if (ret != null) {\n            if (this.xProjection(ret.item.Source) <= prj + GeomConstants.distanceEpsilon / 2) {\n                return ret;\n            }\n        }\n        return null;\n    }\n    ProcessVertexEvent(vertexEvent) {\n        this.Z = this.GetZS(vertexEvent);\n        if (vertexEvent instanceof LeftVertexEvent) {\n            this.ProcessLeftVertex(vertexEvent, vertexEvent.Vertex.nextOnPolyline);\n        }\n        else {\n            if (vertexEvent instanceof RightVertexEvent) {\n                this.ProcessRightVertex(vertexEvent, vertexEvent.Vertex.prevOnPolyline);\n            }\n            else {\n                this.ProcessLeftVertex(vertexEvent, vertexEvent.Vertex.nextOnPolyline);\n                this.ProcessRightVertex(vertexEvent, vertexEvent.Vertex.prevOnPolyline);\n            }\n        }\n    }\n    ProcessRightVertex(rightVertexEvent, nextVertex) {\n        /*Assert.assert(this.Z === rightVertexEvent.Site.dot(this.SweepDirection))*/\n        const site = rightVertexEvent.Site;\n        this.ProcessPrevSegmentForRightVertex(rightVertexEvent, site);\n        const delta = nextVertex.point.sub(rightVertexEvent.Site);\n        const deltaX = delta.dot(this.DirectionPerp);\n        const deltaZ = delta.dot(this.SweepDirection);\n        if (deltaZ <= GeomConstants.distanceEpsilon) {\n            if (deltaX > 0 && deltaZ >= 0) {\n                this.EnqueueEvent(new RightVertexEvent(nextVertex));\n            }\n            else {\n                this.RestrictEdgeContainerToTheRightOfEvent(rightVertexEvent.Vertex);\n            }\n        }\n        else {\n            // deltaZ>epsilon\n            this.InsertRightSide(new RightObstacleSide(rightVertexEvent.Vertex));\n            this.EnqueueEvent(new RightVertexEvent(nextVertex));\n            this.RestrictEdgeContainerToTheRightOfEvent(rightVertexEvent.Vertex);\n        }\n    }\n    RestrictEdgeContainerToTheRightOfEvent(polylinePoint) {\n        const site = polylinePoint.point;\n        const siteX = this.xProjection(site);\n        const containerNode = this.edgeContainersTree.findFirst((container) => siteX <= this.xProjection(container.Source));\n        if (containerNode != null) {\n            for (const edge of containerNode.item.Edges) {\n                if (!this.NotRestricting(edge, polylinePoint.polyline)) {\n                    edge.BoundFromLeft(this.DirectionPerp.dot(site));\n                }\n            }\n        }\n    }\n    NotRestricting(edge, polyline) {\n        const p = this.AxisEdgesToObstaclesTheyOriginatedFrom.get(edge);\n        return p === polyline;\n    }\n    ProcessPrevSegmentForRightVertex(rightVertexEvent, site) {\n        const prevSite = rightVertexEvent.Vertex.nextOnPolyline.point;\n        const delta = site.sub(prevSite);\n        const deltaZ = delta.dot(this.SweepDirection);\n        if (deltaZ > GeomConstants.distanceEpsilon) {\n            this.RemoveRightSide(new RightObstacleSide(rightVertexEvent.Vertex.nextOnPolyline));\n        }\n    }\n    RemoveEdge(edge) {\n        const containerNode = this.GetAxisEdgesContainerNode(edge.Source.point);\n        containerNode.item.RemoveAxis(edge);\n        if (containerNode.item.IsEmpty()) {\n            this.edgeContainersTree.deleteNodeInternal(containerNode);\n        }\n    }\n    ProcessLeftVertex(leftVertexEvent, nextVertex) {\n        /*Assert.assert(this.Z === leftVertexEvent.Site.dot(this.SweepDirection))*/\n        const site = leftVertexEvent.Site;\n        this.ProcessPrevSegmentForLeftVertex(leftVertexEvent, site);\n        const delta = nextVertex.point.sub(leftVertexEvent.Site);\n        const deltaX = delta.dot(this.DirectionPerp);\n        const deltaZ = delta.dot(this.SweepDirection);\n        if (deltaZ <= GeomConstants.distanceEpsilon) {\n            if (deltaX < 0 && deltaZ >= 0) {\n                this.EnqueueEvent(new LeftVertexEvent(nextVertex));\n            }\n        }\n        else {\n            // deltaZ>epsilon\n            this.InsertLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex));\n            this.EnqueueEvent(new LeftVertexEvent(nextVertex));\n        }\n        // ShowAtPoint(leftVertexEvent.Site);\n        this.RestrictEdgeFromTheLeftOfEvent(leftVertexEvent.Vertex);\n    }\n    RestrictEdgeFromTheLeftOfEvent(polylinePoint) {\n        // ShowAtPoint(site);\n        const site = polylinePoint.point;\n        const containerNode = this.GetContainerNodeToTheLeftOfEvent(site);\n        if (containerNode != null) {\n            for (const edge of containerNode.item.Edges) {\n                if (!this.NotRestricting(edge, polylinePoint.polyline)) {\n                    edge.BoundFromRight(site.dot(this.DirectionPerp));\n                }\n            }\n        }\n    }\n    GetContainerNodeToTheLeftOfEvent(site) {\n        const siteX = this.xProjection(site);\n        return this.edgeContainersTree.findLast((container) => this.xProjection(container.Source) <= siteX);\n        //                Point.PointToTheRightOfLineOrOnLine(site, container.Source,\n        //                                                                                                container.UpPoint));\n    }\n    ProcessPrevSegmentForLeftVertex(leftVertexEvent, site) {\n        const prevSite = leftVertexEvent.Vertex.prevOnPolyline.point;\n        const delta = site.sub(prevSite);\n        const deltaZ = delta.dot(this.SweepDirection);\n        if (deltaZ > GeomConstants.distanceEpsilon) {\n            this.RemoveLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex.prevOnPolyline));\n        }\n    }\n    InitTheQueueOfEvents() {\n        this.InitQueueOfEvents();\n        for (const axisEdge of this.AxisEdges) {\n            this.EnqueueEventsForEdge(axisEdge);\n        }\n    }\n    EnqueueEventsForEdge(edge) {\n        if (this.EdgeIsParallelToSweepDir(edge)) {\n            this.EnqueueEvent(FreeSpaceFinder.EdgeLowPointEvent(edge, edge.Source.point));\n            this.EnqueueEvent(FreeSpaceFinder.EdgeHighPointEvent(edge, edge.Target.point));\n        }\n    }\n    EdgeIsParallelToSweepDir(edge) {\n        return edge.Direction === this.SweepPole || edge.Direction === CompassVector.OppositeDir(this.SweepPole);\n    }\n    static EdgeHighPointEvent(edge, point) {\n        return new AxisEdgeHighPointEvent(edge, point);\n    }\n    static EdgeLowPointEvent(edge, point) {\n        return new AxisEdgeLowPointEvent(edge, point);\n    }\n    CompareAA(x, y) {\n        return compareNumbers(x.Source.dot(this.DirectionPerp), y.Source.dot(this.DirectionPerp));\n    }\n}\nFreeSpaceFinder.AreaComparisonEpsilon = GeomConstants.intersectionEpsilon;\n//# sourceMappingURL=FreeSpaceFinder.js.map","// import {CompassVector} from '../../../math/geometry/compassVector'\n// represents a segment of a path\nexport class LinkedPoint {\n    constructor(point) {\n        this.Point = point;\n    }\n    *GetEnumerator() {\n        let p;\n        for (p = this; p != null; p = p.Next) {\n            yield p.Point;\n        }\n    }\n    get X() {\n        return this.Point.x;\n    }\n    get Y() {\n        return this.Point.y;\n    }\n    InsertVerts(i, j, points) {\n        for (j--; i < j; j--) {\n            this.SetNewNext(points[j]);\n        }\n    }\n    InsertVertsInReverse(i, j, points) {\n        for (i++; i < j; i++) {\n            this.SetNewNext(points[i]);\n        }\n    }\n    SetNewNext(p) {\n        const nv = new LinkedPoint(p);\n        const tmp = this.Next;\n        this.Next = nv;\n        nv.Next = tmp;\n        /*Assert.assert(CompassVector.IsPureDirectionPP(this.Point, this.Next.Point))*/\n    }\n}\n//# sourceMappingURL=LinkedPoint.js.map","// intersects a set of horizontal LinkedPoints with a set of vertical LinkedPoints\nimport { Point } from '../../../math/geometry/point';\nimport { GeomConstants } from '../../../math/geometry/geomConstants';\nimport { GenericBinaryHeapPriorityQueue } from '../../../structs/genericBinaryHeapPriorityQueue';\nimport { RBTree } from '../../../math/RBTree/rbTree';\nimport { closeDistEps, compareNumbers } from '../../../utils/compare';\nexport class LinkedPointSplitter {\n    //\n    // no two horizontal segs overlap, but they can share an end point\n    // no two vertical segs overlap, but they can share an end point\n    constructor(horizontalPoints, verticalPoints) {\n        this.tree = new RBTree((a, b) => compareNumbers(a.Point.x, b.Point.x));\n        this.VerticalPoints = verticalPoints;\n        this.HorizontalPoints = horizontalPoints;\n    }\n    SplitPoints() {\n        if (this.VerticalPoints.length === 0 || this.HorizontalPoints.length === 0) {\n            return;\n        }\n        // there will be no intersections\n        this.InitEventQueue();\n        this.ProcessEvents();\n    }\n    ProcessEvents() {\n        while (!this.Queue.IsEmpty()) {\n            const t = { priority: 0 };\n            const linkedPoint = this.Queue.DequeueAndGetPriority(t);\n            this.ProcessEvent(linkedPoint, t.priority);\n        }\n    }\n    ProcessEvent(linkedPoint, z) {\n        if (closeDistEps(linkedPoint.Next.Point.x, linkedPoint.Point.x)) {\n            if (z === LinkedPointSplitter.Low(linkedPoint)) {\n                this.ProcessLowLinkedPointEvent(linkedPoint);\n            }\n            else {\n                this.ProcessHighLinkedPointEvent(linkedPoint);\n            }\n        }\n        else {\n            this.IntersectWithTree(linkedPoint);\n        }\n    }\n    IntersectWithTree(horizontalPoint) {\n        let right;\n        let left;\n        let xAligned;\n        /*Assert.assert(closeDistEps(horizontalPoint.Y, horizontalPoint.Next.Y))*/\n        const y = horizontalPoint.Y;\n        if (horizontalPoint.Point.x < horizontalPoint.Next.Point.x) {\n            left = horizontalPoint.Point.x;\n            right = horizontalPoint.Next.Point.x;\n            xAligned = true;\n        }\n        else {\n            right = horizontalPoint.Point.x;\n            left = horizontalPoint.Next.Point.x;\n            xAligned = false;\n        }\n        if (xAligned) {\n            for (let node = this.tree.findFirst((p) => left <= p.Point.x); node != null && node.item.Point.x <= right; node = this.tree.next(node)) {\n                const p = new Point(node.item.Point.x, y);\n                horizontalPoint = LinkedPointSplitter.TrySplitHorizontalPoint(horizontalPoint, p, true);\n                LinkedPointSplitter.TrySplitVerticalPoint(node.item, p);\n            }\n        }\n        else {\n            for (let node = this.tree.findLast((p) => p.Point.x <= right); node != null && node.item.Point.x >= left; node = this.tree.previous(node)) {\n                const p = new Point(node.item.Point.x, y);\n                horizontalPoint = LinkedPointSplitter.TrySplitHorizontalPoint(horizontalPoint, p, false);\n                LinkedPointSplitter.TrySplitVerticalPoint(node.item, p);\n            }\n        }\n    }\n    static TrySplitVerticalPoint(linkedPoint, point) {\n        /*Assert.assert(closeDistEps(linkedPoint.X, linkedPoint.Next.X))*/\n        if (LinkedPointSplitter.Low(linkedPoint) + GeomConstants.distanceEpsilon < point.y &&\n            point.y + GeomConstants.distanceEpsilon < LinkedPointSplitter.High(linkedPoint)) {\n            linkedPoint.SetNewNext(point);\n        }\n    }\n    static TrySplitHorizontalPoint(horizontalPoint, point, xAligned) {\n        /*Assert.assert(closeDistEps(horizontalPoint.Y, horizontalPoint.Next.Y))*/\n        if ((xAligned &&\n            horizontalPoint.X + GeomConstants.distanceEpsilon < point.x &&\n            point.x + GeomConstants.distanceEpsilon < horizontalPoint.Next.X) ||\n            (!xAligned &&\n                horizontalPoint.Next.X + GeomConstants.distanceEpsilon < point.x &&\n                point.x + GeomConstants.distanceEpsilon < horizontalPoint.X)) {\n            horizontalPoint.SetNewNext(point);\n            return horizontalPoint.Next;\n        }\n        return horizontalPoint;\n    }\n    ProcessHighLinkedPointEvent(linkedPoint) {\n        this.tree.remove(linkedPoint);\n    }\n    ProcessLowLinkedPointEvent(linkedPoint) {\n        this.tree.insert(linkedPoint);\n    }\n    InitEventQueue() {\n        this.Queue = new GenericBinaryHeapPriorityQueue(compareNumbers);\n        for (const vertPoint of this.VerticalPoints) {\n            this.Queue.Enqueue(vertPoint, LinkedPointSplitter.Low(vertPoint));\n        }\n        // a horizontal point will appear of the queue after a vertical point\n        // with the same coordinate low coorinate\n        for (const horizPoint of this.HorizontalPoints) {\n            this.Queue.Enqueue(horizPoint, horizPoint.Point.y);\n        }\n    }\n    static Low(vertPoint) {\n        return Math.min(vertPoint.Point.y, vertPoint.Next.Point.y);\n    }\n    static High(vertPoint) {\n        return Math.max(vertPoint.Point.y, vertPoint.Next.Point.y);\n    }\n}\n//# sourceMappingURL=LinkedPointSplitter.js.map","import { CompassVector } from '../../../math/geometry/compassVector';\nimport { Direction } from '../../../math/geometry/direction';\nimport { SegmentBase } from '../../visibility/SegmentBase';\n// Represent a maximal straight segment of a path\nexport class LongestNudgedSegment extends SegmentBase {\n    constructor(variable) {\n        super();\n        // has to be North or East\n        this.CompassDirection = Direction.None;\n        // the segment can go only North or East independently of the edge directions\n        this.edges = new Array();\n        this._isFixed = false;\n        this.Id = -1;\n        this.IdealPosition = 0;\n        this.Id = variable;\n    }\n    get Start() {\n        return this.start;\n    }\n    get End() {\n        return this.end;\n    }\n    // the list of edges holding the same offset and direction\n    get Edges() {\n        return this.edges;\n    }\n    AddEdge(edge) {\n        if (this.Edges.length === 0) {\n            let dir = CompassVector.VectorDirectionPP(edge.Source, edge.Target);\n            switch (dir) {\n                case Direction.South:\n                    dir = Direction.North;\n                    break;\n                case Direction.West:\n                    dir = Direction.East;\n                    break;\n            }\n            this.CompassDirection = dir;\n            this.start = edge.Source;\n            this.end = edge.Source;\n            // does not matter; it will be fixed immediately\n        }\n        switch (this.CompassDirection) {\n            case Direction.North:\n                this.TryPointForStartAndEndNorth(edge.Source);\n                this.TryPointForStartAndEndNorth(edge.Target);\n                break;\n            case Direction.East:\n                this.TryPointForStartAndEndEast(edge.Source);\n                this.TryPointForStartAndEndEast(edge.Target);\n                break;\n        }\n        this.Edges.push(edge);\n    }\n    TryPointForStartAndEndNorth(p) {\n        if (p.y < this.start.y) {\n            this.start = p;\n        }\n        else if (p.y > this.end.y) {\n            this.end = p;\n        }\n    }\n    TryPointForStartAndEndEast(p) {\n        if (p.x < this.start.x) {\n            this.start = p;\n        }\n        else if (p.x > this.end.x) {\n            this.end = p;\n        }\n    }\n    // the segments constraining \"this\" from the right\n    get IsFixed() {\n        return this._isFixed;\n    }\n    set IsFixed(value) {\n        this._isFixed = value;\n    }\n    // the maximal width of the edges\n    get Width() {\n        let w = 0;\n        for (const e of this.edges) {\n            w = Math.max(w, e.Width);\n        }\n        return w;\n    }\n    GetLeftBound() {\n        if (!this.IsFixed) {\n            let lb = Number.NEGATIVE_INFINITY;\n            for (const edge of this.edges) {\n                lb = Math.max(lb, edge.AxisEdge.LeftBound);\n            }\n            return lb;\n        }\n        return this.CompassDirection === Direction.North ? this.Edges[0].Source.x : -this.Edges[0].Source.y;\n    }\n    GetRightBound() {\n        if (!this.IsFixed) {\n            let rb = Number.POSITIVE_INFINITY;\n            for (const edge of this.edges) {\n                rb = Math.min(rb, edge.AxisEdge.RightBound);\n            }\n            return rb;\n        }\n        return this.Position();\n    }\n    Position() {\n        return this.CompassDirection === Direction.North ? this.Edges[0].Source.x : -this.Edges[0].Source.y;\n    }\n}\n//# sourceMappingURL=LongestNudgedSegment.js.map","import { Point } from '../../../math/geometry/point';\nimport { Rectangle } from '../../../math/geometry/rectangle';\nimport { UniformOneDimensionalSolver } from '../../../math/projectionSolver/UniformOneDimensionalSolver';\nimport { CompassVector } from '../../../math/geometry/compassVector';\nimport { Curve, PointLocation } from '../../../math/geometry/curve';\nimport { DebugCurve } from '../../../math/geometry/debugCurve';\nimport { Direction } from '../../../math/geometry/direction';\nimport { GeomConstants } from '../../../math/geometry/geomConstants';\nimport { LineSegment } from '../../../math/geometry/lineSegment';\nimport { Polyline } from '../../../math/geometry/polyline';\nimport { closeDistEps } from '../../../utils/compare';\nimport { CombinatorialNudger } from './CombinatorialNudger';\nimport { FreeSpaceFinder } from './FreeSpaceFinder';\nimport { LongestNudgedSegment } from './LongestNudgedSegment';\nimport { PathRefiner } from './PathRefiner';\nimport { StaircaseRemover } from './StaircaseRemover';\nimport { HitTestBehavior } from '../../../math/geometry/RTree/hitTestBehavior';\nimport { CreateRectNodeOnArrayOfRectNodes, mkRectangleNode } from '../../../math/geometry/RTree/rectangleNode';\n// following paper \"Orthogonal Connector Routing\"\nexport class Nudger {\n    get HasGroups() {\n        return null != this.HierarchyOfGroups && this.HierarchyOfGroups.Count > 0;\n    }\n    //  \"nudges\" paths to decrease the number of intersections and stores the results inside WidePaths of \"paths\"\n    // paths through the graph\n    // two parallel paths should be separated by this distance if it is feasible\n    // polygonal convex obstacles organized  of a tree; the obstacles here are padded original obstacles\n    //\n    constructor(paths, cornerFitRad, obstacles, ancestorsSets) {\n        this.AncestorsSets = ancestorsSets;\n        this.HierarchyOfGroups = CreateRectNodeOnArrayOfRectNodes(Array.from(ancestorsSets.keys())\n            .filter((shape) => shape.IsGroup)\n            .map((group) => mkRectangleNode(group, group.BoundingBox)));\n        this.Obstacles = obstacles;\n        this.EdgeSeparation = 2 * cornerFitRad;\n        this.Paths = paths;\n        this.HierarchyOfObstacles = CreateRectNodeOnArrayOfRectNodes(obstacles.map((p) => mkRectangleNode(p, p.boundingBox)));\n        this.MapPathsToTheirObstacles();\n    }\n    MapPathsToTheirObstacles() {\n        this.PathToObstacles = new Map();\n        for (const path of this.Paths) {\n            this.MapPathToItsObstacles(path);\n        }\n    }\n    MapPathToItsObstacles(path) {\n        if (!path.PathPoints || path.PathPoints.length === 0)\n            return;\n        const fr = path.PathPoints;\n        const startNode = this.HierarchyOfObstacles.FirstHitNodeWithPredicate(fr[0], Nudger.ObstacleTest);\n        const endNode = this.HierarchyOfObstacles.FirstHitNodeWithPredicate(fr[fr.length - 1], Nudger.ObstacleTest);\n        if (null != startNode && null != endNode) {\n            this.PathToObstacles.set(path, [startNode.UserData, endNode.UserData]);\n        }\n    }\n    static ObstacleTest(pnt, polyline) {\n        return Curve.PointRelativeToCurveLocation(pnt, polyline) !== PointLocation.Outside ? HitTestBehavior.Stop : HitTestBehavior.Continue;\n    }\n    Calculate(direction, mergePaths) {\n        this.NudgingDirection = direction;\n        PathRefiner.RefinePaths(this.Paths, mergePaths);\n        this.GetPathOrdersAndPathGraph();\n        this.MapAxisEdgesToTheirObstacles();\n        this.DrawPaths();\n    }\n    MapAxisEdgesToTheirObstacles() {\n        this.axisEdgesToObstaclesTheyOriginatedFrom = new Map();\n        for (const path of this.Paths) {\n            this.MapPathEndAxisEdgesToTheirObstacles(path);\n        }\n        // The assignment above was too greedy. An edge belonging to interiour edges of some path can be marked by mistake.\n        for (const path of this.Paths) {\n            this.UmmapPathInteriourFromStrangerObstacles(path);\n        }\n    }\n    UmmapPathInteriourFromStrangerObstacles(path) {\n        const firstUnmappedEdge = this.FindFirstUnmappedEdge(path);\n        if (firstUnmappedEdge == null) {\n            return;\n        }\n        const lastUnmappedEdge = this.FindLastUnmappedEdge(path);\n        for (let edge = firstUnmappedEdge; edge != null && edge !== lastUnmappedEdge; edge = edge.Next) {\n            this.axisEdgesToObstaclesTheyOriginatedFrom.delete(edge.AxisEdge);\n        }\n    }\n    FindLastUnmappedEdge(path) {\n        for (let edge = path.LastEdge; edge != null; edge = edge.Prev) {\n            if (edge.AxisEdge.Direction !== this.NudgingDirection) {\n                return edge;\n            }\n        }\n        return null;\n    }\n    FindFirstUnmappedEdge(path) {\n        for (let edge = path.FirstEdge; edge != null; edge = edge.Next) {\n            if (edge.AxisEdge.Direction !== this.NudgingDirection) {\n                return edge;\n            }\n        }\n        return null;\n    }\n    MapPathEndAxisEdgesToTheirObstacles(path) {\n        const coupleOfObstacles = this.PathToObstacles.get(path);\n        if (coupleOfObstacles) {\n            this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(path, coupleOfObstacles[0]);\n            this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(path, coupleOfObstacles[1]);\n        }\n    }\n    ProcessThePathEndToMapAxisEdgesToTheirObstacles(path, endPolyline) {\n        for (let edge = path.LastEdge; edge != null && CompassVector.DirectionsAreParallel(edge.Direction, this.NudgingDirection); edge = edge.Prev) {\n            this.axisEdgesToObstaclesTheyOriginatedFrom.set(edge.AxisEdge, endPolyline);\n        }\n    }\n    ProcessThePathStartToMapAxisEdgesToTheirObstacles(path, startPolyline) {\n        for (let edge = path.FirstEdge; edge != null && CompassVector.DirectionsAreParallel(edge.Direction, this.NudgingDirection); edge = edge.Next) {\n            this.axisEdgesToObstaclesTheyOriginatedFrom.set(edge.AxisEdge, startPolyline);\n        }\n        // possible bug here because an edge might ignore two obstacles if it connects them\n    }\n    GetPathOrdersAndPathGraph() {\n        const combinatorialNudger = new CombinatorialNudger(this.Paths);\n        this.PathOrders = combinatorialNudger.GetOrder();\n        this.PathVisibilityGraph = combinatorialNudger.PathVisibilityGraph;\n    }\n    static GetCurvesForShow(paths, obstacles) {\n        const ret = new Array();\n        for (const path of paths) {\n            const poly = new Polyline();\n            for (const point of path.PathPoints) {\n                poly.addPoint(point);\n            }\n            ret.push(poly);\n        }\n        return ret.concat(Array.from(obstacles));\n    }\n    DrawPaths() {\n        this.SetWidthsOfArrowheads();\n        this.CreateLongestNudgedSegments();\n        this.FindFreeSpaceInDirection(Array.from(this.PathVisibilityGraph.Edges));\n        this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals();\n        this.PositionShiftedEdqges();\n    }\n    SetWidthsOfArrowheads() {\n        for (const edgePath of this.Paths) {\n            Nudger.SetWidthsOfArrowheadsForEdge(edgePath);\n        }\n    }\n    static SetWidthsOfArrowheadsForEdge(path) {\n        const edgeGeom = path.GeomEdge;\n        if (edgeGeom.targetArrowhead != null) {\n            const pathEdge = path.LastEdge;\n            pathEdge.Width = Math.max(edgeGeom.targetArrowhead.width, pathEdge.Width);\n        }\n        if (edgeGeom.sourceArrowhead != null) {\n            const pathEdge = path.FirstEdge;\n            pathEdge.Width = Math.max(edgeGeom.sourceArrowhead.width, pathEdge.Width);\n        }\n    }\n    PositionShiftedEdqges() {\n        this.Solver = new UniformOneDimensionalSolver(this.EdgeSeparation);\n        for (let i = 0; i < this.LongestNudgedSegs.length; i++) {\n            this.CreateVariablesOfLongestSegment(this.LongestNudgedSegs[i]);\n        }\n        this.CreateConstraintsOfTheOrder();\n        this.CreateConstraintsBetweenLongestSegments();\n        this.Solver.SolveByRegularSolver();\n        this.ShiftPathEdges();\n    }\n    MoveLongestSegsIdealPositionsInsideFeasibleIntervals() {\n        for (let i = 0; i < this.LongestNudgedSegs.length; i++) {\n            const seg = this.LongestNudgedSegs[i];\n            Nudger.MoveLongestSegIdealPositionsInsideFeasibleInterval(seg);\n        }\n    }\n    static MoveLongestSegIdealPositionsInsideFeasibleInterval(seg) {\n        if (seg.IsFixed) {\n            return;\n        }\n        const leftBound = seg.GetLeftBound();\n        const rightBound = seg.GetRightBound();\n        if (seg.IdealPosition < leftBound) {\n            seg.IdealPosition = leftBound;\n        }\n        else if (seg.IdealPosition > rightBound) {\n            seg.IdealPosition = rightBound;\n        }\n    }\n    ShiftPathEdges() {\n        for (const path of this.Paths) {\n            path.PathPoints = this.GetShiftedPoints(path);\n        }\n    }\n    GetShiftedPoints(path) {\n        return Nudger.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(path));\n    }\n    // sometimes we have very small mistakes  of the positions that have to be fixed\n    static Rectilinearise(a, b) {\n        if (a.x === b.x || a.y === b.y)\n            return b;\n        const dx = Math.abs(a.x - b.x);\n        const dy = Math.abs(a.y - b.y);\n        return dx < dy ? new Point(a.x, b.y) : new Point(b.x, a.y);\n    }\n    GetShiftedPointsSimple(path) {\n        const ret = [];\n        const edge = path.FirstEdge;\n        ret.push(this.ShiftedPoint(edge.Source, edge.LongestNudgedSegment));\n        for (const e of path.PathEdges()) {\n            ret.push(this.ShiftedEdgePositionOfTarget(e));\n        }\n        return ret;\n    }\n    ShiftedEdgePositionOfTarget(e) {\n        return e.LongestNudgedSegment != null || e.Next == null\n            ? this.ShiftedPoint(e.Target, e.LongestNudgedSegment)\n            : this.ShiftedPoint(e.Next.Source, e.Next.LongestNudgedSegment);\n    }\n    ShiftedPoint(point, segment) {\n        if (segment == null) {\n            return point;\n        }\n        const t = this.Solver.GetVariablePosition(segment.Id);\n        return this.NudgingDirection === Direction.North ? new Point(t, point.y) : new Point(point.x, -t);\n    }\n    // static ShowPathsFromPoints(paths: Array<Path>, enumerable: Array<Polyline>) {\n    //    let dd = new Array<DebugCurve>();\n    //    if ((enumerable != null)) {\n    //        dd=dd.concat(Nudger.GetObstacleBoundaries(enumerable, \"grey\"));\n    //    }\n    //    let i: number = 0;\n    //    for (let p  of paths) {\n    //        dd = dd.concat(Nudger.PathDebugCurvesFromPoints(p, DebugCurve.colors[Math.min(DebugCurve.colors.length, i++)]));\n    //    }\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);\n    // }\n    // static PathDebugCurvesFromPoints(path: Path, color: string): Array<DebugCurve> {\n    //    const let startWidth: number = 0.01;\n    //    const let endWidth: number = 3;\n    //    let pts = path.PathPoints.toArray();\n    //    let delta: number = ((endWidth - startWidth)\n    //                / (pts.length - 1));\n    //    for (let i: number = 0; (i\n    //                < (pts.length - 1)); i++) {\n    //        yield;\n    //    }\n    //    return new DebugCurve((startWidth\n    //                    + (delta * i)), color, new LineSegment(pts[i], pts[(i + 1)]));\n    // }\n    // static ShowParamPaths(s: Point, e: Point, params paths: Path[]) {\n    //    Nudger.ShowOrderedPaths(null, paths, s, e);\n    // }\n    // //         ReSharper disable UnusedMember.Local\n    // static ShowOrderedPaths(obstacles: Array<Polyline>, paths: Array<Path>, s: Point, e: Point) {\n    //    //            ReSharper restore UnusedMember.Local\n    //    let colors: string[] = [\n    //            \"red\",\n    //            \"green\",\n    //            \"blue\",\n    //            \"violet\",\n    //            \"rose\",\n    //            \"black\"];\n    //    const let startWidth: number = 0.001;\n    //    const let endWidth: number = 0.1;\n    //    let dd = new Array<DebugCurve>();\n    //    if ((obstacles != null)) {\n    //        dd.AddRange(Nudger.GetObstacleBoundaries(obstacles, \"grey\"));\n    //    }\n    //    let i: number = 0;\n    //    for (let path  of paths) {\n    //        dd.AddRange(Nudger.GetTestPathAsDebugCurve(startWidth, endWidth, colors[Math.min((colors.length - 1), i++)], path));\n    //    }\n    //    let ell = new DebugCurve(1, \"black\", new Ellipse(0.01, 0.01, s));\n    //    dd.Add(ell);\n    //    dd.Add(new DebugCurve(1, \"black\", new Ellipse(0.02, 0.02, e)));\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd.concat(Nudger.GetObstacleBoundaries(obstacles, \"lightblue\")));\n    // }\n    // static GetTestPathAsDebugCurve(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {\n    //    if ((path.PathEdges.Count() > 0)) {\n    //        let count: number = path.PathEdges.Count();\n    //        let deltaW: number = ((endWidth - startWidth)\n    //                    / (count - 1));\n    //        // TODO: Warning!!!, inline IF is not supported ?\n    //        (count > 1);\n    //        1;\n    //        // if count ==1 the value of deltaW does not matter\n    //        let i: number = 0;\n    //        for (let e  of path.PathEdges) {\n    //            yield;\n    //        }\n    //        return new DebugCurve(150, (startWidth\n    //                        + (deltaW\n    //                        * (i + 1))), color, new LineSegment(e.Source, e.Target));\n    //    }\n    //    else {\n    //        let count: number = path.PathPoints.count();\n    //        let pts = path.PathPoints.toArray();\n    //        let deltaW = ((endWidth - startWidth)\n    //                    / (count - 1));\n    //        // TODO: Warning!!!, inline IF is not supported ?\n    //        (count > 1);\n    //        1;\n    //        // if count ==1 the value of deltaW does not matter\n    //        for (let i: number = 0; (i\n    //                    < (count - 1)); i++) {\n    //            yield;\n    //        }\n    //        return new DebugCurve(150, (startWidth\n    //                        + (deltaW * i)), color, new LineSegment(pts[i], pts[(i + 1)]));\n    //    }\n    // }\n    // static GetTestEdgePathAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {\n    //    let count: number = path.PathPoints.count();\n    //    let deltaW: number = ((endWidth - startWidth)\n    //                / (count - 1));\n    //    // TODO: Warning!!!, inline IF is not supported ?\n    //    (count > 1);\n    //    1;\n    //    // if count ==1 the value of deltaW does not matter\n    //    let points = path.PathPoints.toArray();\n    //    for (let i: number = 0; (i\n    //                < (points.length - 1)); i++) {\n    //        yield;\n    //    }\n    //    return new DebugCurve(125, (startWidth\n    //                    + (deltaW * i)), color, new LineSegment(points[i], points[(i + 1)]));\n    // }\n    // static GetEdgePathFromPathEdgesAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {\n    //    let points = path.PathPoints.toArray();\n    //    let count: number = points.length;\n    //    let deltaW: number = ((endWidth - startWidth)\n    //                / (count - 1));\n    //    // TODO: Warning!!!, inline IF is not supported ?\n    //    (count > 1);\n    //    1;\n    //    // if count ==1 the value of deltaW does not matter\n    //    for (let i: number = 0; (i\n    //                < (points.length - 1)); i++) {\n    //        yield;\n    //    }\n    //    return new DebugCurve(120, (startWidth\n    //                    + (deltaW * i)), color, new LineSegment(points[i], points[(i + 1)]));\n    // }\n    // // ReSharper disable UnusedMember.Local\n    // static ShowEdgePaths(obstacles: Array<Polyline>, edgePaths: Array<Path>) {\n    //    //  ReSharper restore UnusedMember.Local\n    //    let debCurves: Array<DebugCurve> = Nudger.GetDebCurvesOfPaths(obstacles, edgePaths);\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);\n    // }\n    // static GetDebCurvesOfPaths(enumerable: Array<Polyline>, edgePaths: Array<Path>): Array<DebugCurve> {\n    //    let debCurves = Nudger.GetObstacleBoundaries(enumerable, \"black\");\n    //    let i: number = 0;\n    //    for (let edgePath  of edgePaths) {\n    //        debCurves.AddRange(Nudger.GetTestEdgePathAsDebugCurves(0.2, 4, DebugCurve.colors[((i + 1)\n    //                            % DebugCurve.colors.length)], edgePath));\n    //    }\n    //    return debCurves;\n    // }\n    // static ShowPathsInLoop(enumerable: Array<Polyline>, edgePaths: Array<Path>, point: Point) {\n    //    for (let edgePath  of edgePaths.where(() => {  }, (((path.PathPoints.First() - point).Length < 1)\n    //                    || ((path.PathPoints.Last() - point).Length < 1)))) {\n    //        let debCurves = Nudger.GetObstacleBoundaries(enumerable, \"black\");\n    //        debCurves.AddRange(Nudger.GetTestEdgePathAsDebugCurves(0.1, 4, \"red\", edgePath));\n    //        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);\n    //    }\n    // }\n    // // ReSharper disable UnusedMember.Local\n    // ShowLongSegsWithIdealPositions(dir: Direction) {\n    //    //  ReSharper restore UnusedMember.Local\n    //    let debCurves = Nudger.GetObstacleBoundaries(this.Obstacles, \"black\");\n    //    let i: number = 0;\n    //    debCurves.AddRange(this.LongestNudgedSegs.Select(() => {  }, Nudger.DebugCurveOfLongSeg(ls, DebugCurve.colors[i++, Percent, DebugCurve.colors.length], dir)));\n    //    DebugCurveCollection.WriteToFile(debCurves, \"c:/tmp/longSegs\");\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);\n    // }\n    // static DebugCurveOfLongSeg(ls: LongestNudgedSegment, s: string, dir: Direction): DebugCurve {\n    //    return new DebugCurve(1, s, Nudger.LineSegOfLongestSeg(ls, dir));\n    // }\n    static LineSegOfLongestSeg(ls, dir) {\n        const projectionToDir = dir === Direction.East ? (p) => p.x : (p) => p.y;\n        const mm = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };\n        for (const edge of ls.Edges) {\n            Nudger.UpdateMinMaxWithPoint(mm, projectionToDir, edge.Source);\n            Nudger.UpdateMinMaxWithPoint(mm, projectionToDir, edge.Target);\n        }\n        return dir === Direction.East\n            ? new LineSegment(mm.min, -ls.IdealPosition, mm.max, -ls.IdealPosition)\n            : new LineSegment(ls.IdealPosition, mm.min, ls.IdealPosition, mm.max);\n    }\n    static UpdateMinMaxWithPoint(mm, projectionToDir, point) {\n        const p = projectionToDir(point);\n        if (mm.min > p) {\n            mm.min = p;\n        }\n        if (mm.max < p) {\n            mm.max = p;\n        }\n    }\n    // ShowPathsDebug(edgePaths: Array<Path>) {\n    //    let debCurves = Nudger.GetObstacleBoundaries(this.Obstacles, \"black\");\n    //    let i: number = 0;\n    //    for (let edgePath  of edgePaths) {\n    //        debCurves.AddRange(Nudger.GetEdgePathFromPathEdgesAsDebugCurves(0.01, 0.4, DebugCurve.colors[((i + 1)\n    //                            % DebugCurve.colors.length)], edgePath));\n    //    }\n    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);\n    // }\n    // static PathDebugCurves(path: Path, color: string): Array<DebugCurve> {\n    //    let d = path.PathEdges.Select(() => {  }, new DebugCurve(70, 0.5, color, new LineSegment(e.Source, e.Target)));\n    //    return d.Concat(Nudger.MarkPathVerts(path));\n    // }\n    // private static MarkPathVerts(path: Path): Array<DebugCurve> {\n    //    let first: boolean = true;\n    //    let p = new Point();\n    //    for (let p0  of path.PathPoints) {\n    //        if (first) {\n    //            yield;\n    //            return new DebugCurve(200, 1, \"violet\", CurveFactory.CreateDiamond(5, 5, p0));\n    //            first = false;\n    //        }\n    //        else {\n    //            yield;\n    //        }\n    //        return new DebugCurve(100, 0.5, \"brown\", CurveFactory.CreateEllipse(1.5, 1.5, p0));\n    //        p = p0;\n    //    }\n    //    yield;\n    //    return new DebugCurve(200, 1, \"green\", CurveFactory.CreateDiamond(3, 3, p));\n    // }\n    // static PathDebugCurvesFromPoint(path: Path): Array<DebugCurve> {\n    //    let l = new Array<Point>(path.PathPoints);\n    //    for (let i: number = 0; (i\n    //                < (l.Count - 1)); i++) {\n    //        yield;\n    //    }\n    //    return new DebugCurve(4, \"red\", new LineSegment(l[i], l[(i + 1)]));\n    // }\n    //\n    // ReSharper disable UnusedMember.Local\n    //        void ShowEdgesOfEdgePath(Path path){\n    // ReSharper restore UnusedMember.Local\n    //            string[] colors = {\"red\", \"brown\", \"purple\"};\n    //            const double w0 = 1;\n    //            const double w1 = 3;\n    //            double dw = (w1 - w0)/path.OrientedSubpaths.Count;\n    //            int i = 0;\n    //            var dc = new Array<DebugCurve>();\n    //            foreach (var s  of path.OrientedSubpaths){\n    //                dc.AddRange(SubpathDebugCurves(w0 + dw*i, colors[Math.Min(i++, colors.Length - 1)], s));\n    //            }\n    //            LayoutAlgorithmSettings.ShowDebugCurves(dc.ToArray());\n    //        }\n    //\n    //        static Array<DebugCurve> SubpathDebugCurves(double w, string color, OrientedSubpath subpath){\n    //            return subpath.LinkedPath.Select(e => new DebugCurve(w, color, new LineSegment(e.Source.Point, e.Target.Point)));\n    //        }\n    // static GetObstacleBoundaries(obstacles: Array<Polyline>, color: string): Array<DebugCurve> {\n    //    let debugCurves = new Array<DebugCurve>();\n    //    if ((obstacles != null)) {\n    //        debugCurves.AddRange(obstacles.select(() => {  }, new DebugCurve(50, 0.3, color, poly)));\n    //    }\n    //    return debugCurves;\n    // }\n    CreateConstraintsBetweenLongestSegments() {\n        for (const segment of this.LongestNudgedSegs) {\n            this.CreateConstraintsBetweenLongestSegmentsForSegment(segment);\n        }\n    }\n    CreateConstraintsBetweenLongestSegmentsForSegment(segment) {\n        const rightNeighbors = new Set();\n        for (const pathEdge of segment.Edges) {\n            const axisEdge = pathEdge.AxisEdge;\n            if (axisEdge != null) {\n                for (const rightNeiAxisEdge of axisEdge.RightNeighbors) {\n                    for (const longSeg of rightNeiAxisEdge.LongestNudgedSegments) {\n                        rightNeighbors.add(longSeg);\n                    }\n                }\n            }\n        }\n        for (const seg of rightNeighbors) {\n            this.ConstraintTwoLongestSegs(segment, seg);\n        }\n    }\n    CreateConstraintsOfTheOrder() {\n        for (const kv of this.PathOrders) {\n            if (Nudger.ParallelToDirection(kv[0], this.NudgingDirection)) {\n                this.CreateConstraintsOfThePathOrder(kv[1]);\n            }\n        }\n    }\n    static ParallelToDirection(edge, direction) {\n        switch (direction) {\n            case Direction.North:\n            case Direction.South:\n                return closeDistEps(edge.SourcePoint.x, edge.TargetPoint.x);\n                break;\n            default:\n                return closeDistEps(edge.SourcePoint.y, edge.TargetPoint.y);\n                break;\n        }\n    }\n    CreateConstraintsOfThePathOrder(pathOrder) {\n        let prevEdge = null;\n        for (const pathEdge of pathOrder.filter((p) => p.LongestNudgedSegment != null)) {\n            if (prevEdge != null) {\n                this.ConstraintTwoLongestSegs(prevEdge.LongestNudgedSegment, pathEdge.LongestNudgedSegment);\n            }\n            prevEdge = pathEdge;\n        }\n    }\n    ConstraintTwoLongestSegs(prevSeg, seg) {\n        if (!prevSeg.IsFixed || !seg.IsFixed) {\n            this.Solver.AddConstraint(prevSeg.Id, seg.Id);\n        }\n    }\n    CreateVariablesOfLongestSegment(segment) {\n        if (!segment.IsFixed) {\n            const leftBound = segment.GetLeftBound();\n            const rightBound = segment.GetRightBound();\n            if (leftBound >= rightBound) {\n                // don't move the segment from the way it was generated\n                this.Solver.AddFixedVariable(segment.Id, Nudger.SegmentPosition(segment, this.NudgingDirection));\n                segment.IsFixed = true;\n            }\n            else {\n                this.Solver.AddVariableNNNN(segment.Id, Nudger.SegmentPosition(segment, this.NudgingDirection), segment.IdealPosition, segment.Width);\n                //           Assert.assert(leftBound + Curve.DistanceEpsilon < rightBound); //this assert does not hold for overlaps\n                if (leftBound !== Number.NEGATIVE_INFINITY) {\n                    this.Solver.SetLowBound(leftBound, segment.Id);\n                }\n                if (rightBound !== Number.POSITIVE_INFINITY) {\n                    this.Solver.SetUpperBound(segment.Id, rightBound);\n                }\n            }\n        }\n        else {\n            this.Solver.AddFixedVariable(segment.Id, Nudger.SegmentPosition(segment, this.NudgingDirection));\n        }\n    }\n    static SegmentPosition(segment, direction) {\n        return direction === Direction.North ? segment.Start.x : -segment.Start.y;\n    }\n    FindFreeSpaceInDirection(axisEdges) {\n        this.BoundAxisEdgesByRectsKnownInAdvance();\n        const freeSpaceFinder = new FreeSpaceFinder(this.NudgingDirection, this.Obstacles, this.axisEdgesToObstaclesTheyOriginatedFrom, this.PathOrders, axisEdges);\n        freeSpaceFinder.FindFreeSpace();\n    }\n    BoundAxisEdgesByRectsKnownInAdvance() {\n        for (const path of this.Paths) {\n            if (this.HasGroups) {\n                this.BoundPathByMinCommonAncestors(path);\n            }\n            this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(path);\n        }\n    }\n    BoundPathByMinCommonAncestors(path) {\n        for (const sh of this.GetMinCommonAncestors(path.GeomEdge)) {\n            const rect = sh.BoundingBox;\n            for (const e of path.PathEdges()) {\n                const edge = e.AxisEdge;\n                if (edge.Direction === this.NudgingDirection) {\n                    this.BoundAxisEdgeByRect(rect, edge);\n                }\n            }\n        }\n    }\n    GetMinCommonAncestors(edge) {\n        if (this.PortToShapes == null) {\n            this.PortToShapes = Nudger.MapPortsToShapes(this.AncestorsSets.keys());\n        }\n        const commonAncestors = IntersectSets(this.AncestorsForPort(edge.sourcePort), this.AncestorsForPort(edge.targetPort));\n        return Array.from(commonAncestors).filter((anc) => !anc.Children.some((child) => commonAncestors.has(child)));\n    }\n    AncestorsForPort(port) {\n        const shape = this.PortToShapes.get(port);\n        if (shape) {\n            return this.AncestorsSets.get(shape);\n        }\n        // This is a FreePort or Waypoint; return all spatial parents.\n        return new Set(this.HierarchyOfGroups.AllHitItems(Rectangle.mkPP(port.Location, port.Location), null));\n    }\n    BoundAxisEdgeAdjacentToObstaclePort(port, axisEdge) {\n        if (port.Curve == null) {\n            this.BoundAxisByPoint(port.Location, axisEdge);\n        }\n        else if (port.Curve.boundingBox.contains(port.Location)) {\n            this.BoundAxisEdgeByRect(port.Curve.boundingBox, axisEdge);\n        }\n    }\n    BoundAxisByPoint(point, axisEdge) {\n        if (axisEdge != null && axisEdge.Direction === this.NudgingDirection) {\n            if (this.NudgingDirection === Direction.North) {\n                axisEdge.BoundFromLeft(point.x);\n                axisEdge.BoundFromRight(point.x);\n            }\n            else {\n                axisEdge.BoundFromLeft(-point.y);\n                axisEdge.BoundFromRight(-point.y);\n            }\n        }\n    }\n    BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(path) {\n        this.BoundAxisEdgeAdjacentToObstaclePort(path.GeomEdge.sourcePort, path.FirstEdge.AxisEdge);\n        this.BoundAxisEdgeAdjacentToObstaclePort(path.GeomEdge.targetPort, path.LastEdge.AxisEdge);\n    }\n    BoundAxisEdgeByRect(rectangle, axisEdge) {\n        if (axisEdge != null && axisEdge.Direction === this.NudgingDirection) {\n            if (this.NudgingDirection === Direction.North) {\n                axisEdge.BoundFromLeft(rectangle.left);\n                axisEdge.BoundFromRight(rectangle.right);\n            }\n            else {\n                axisEdge.BoundFromLeft(rectangle.top * -1);\n                axisEdge.BoundFromRight(rectangle.bottom * -1);\n            }\n        }\n    }\n    CreateLongestNudgedSegments() {\n        const projectionToPerp = this.NudgingDirection === Direction.East ? (p) => -p.y : (p) => p.x;\n        this.LongestNudgedSegs = new Array();\n        for (let i = 0; i < this.Paths.length; i++) {\n            this.CreateLongestNudgedSegmentsForPath(this.Paths[i], projectionToPerp);\n        }\n    }\n    CreateLongestNudgedSegmentsForPath(path, projectionToPerp) {\n        // ShowEdgesOfEdgePath(path);\n        this.GoOverPathAndCreateLongSegs(path);\n        Nudger.CalculateIdealPositionsForLongestSegs(path, projectionToPerp);\n    }\n    static CalculateIdealPositionsForLongestSegs(path, projectionToPerp) {\n        let currentLongSeg = null;\n        let ret = null;\n        let prevOffset = projectionToPerp(path.Start);\n        for (const edge of path.PathEdges()) {\n            if (edge.LongestNudgedSegment != null) {\n                currentLongSeg = edge.LongestNudgedSegment;\n                if (ret != null) {\n                    let t;\n                    Nudger.SetIdealPositionForSeg(ret, (t = projectionToPerp(ret.start)), prevOffset, projectionToPerp(currentLongSeg.Start));\n                    prevOffset = t;\n                    ret = null;\n                }\n            }\n            else if (currentLongSeg != null) {\n                ret = currentLongSeg;\n                currentLongSeg = null;\n            }\n        }\n        if (ret != null) {\n            Nudger.SetIdealPositionForSeg(ret, projectionToPerp(ret.Start), prevOffset, projectionToPerp(path.End));\n        }\n        else if (currentLongSeg != null) {\n            currentLongSeg.IdealPosition = projectionToPerp(currentLongSeg.Start);\n        }\n    }\n    static SetIdealPositionForSeg(segment, segPosition, offset0, offset1) {\n        const max = Math.max(offset0, offset1);\n        const min = Math.min(offset0, offset1);\n        if (min + GeomConstants.distanceEpsilon < segPosition) {\n            if (segPosition < max) {\n                segment.IdealPosition = 0.5 * (max + min);\n            }\n            else {\n                segment.IdealPosition = max;\n            }\n        }\n        else {\n            segment.IdealPosition = min;\n        }\n    }\n    GoOverPathAndCreateLongSegs(path) {\n        let currentLongestSeg = null;\n        const oppositeDir = CompassVector.OppositeDir(this.NudgingDirection);\n        for (const edge of path.PathEdges()) {\n            const edgeDir = edge.Direction;\n            if (edgeDir === this.NudgingDirection || edgeDir === oppositeDir) {\n                if (currentLongestSeg == null) {\n                    edge.LongestNudgedSegment = currentLongestSeg = new LongestNudgedSegment(this.LongestNudgedSegs.length);\n                    this.LongestNudgedSegs.push(currentLongestSeg);\n                }\n                else {\n                    edge.LongestNudgedSegment = currentLongestSeg;\n                }\n                if (edge.IsFixed) {\n                    currentLongestSeg.IsFixed = true;\n                }\n            }\n            else {\n                // the edge is perpendicular to \"direction\"\n                edge.LongestNudgedSegment = null;\n                currentLongestSeg = null;\n            }\n        }\n    }\n    static BuildPolylineForPath(path) {\n        const t = { points: path.PathPoints.map((p) => p.clone()) };\n        Nudger.ExtendPolylineToPorts(t, path);\n        /* for (let i = 0; i < t.points.length - 1; i++) {\n    // Assert.assert(\n            CompassVector.IsPureDirectionPP(t.points[i], t.points[i + 1]),\n          )\n        }*/\n        return t.points;\n    }\n    static ExtendPolylineToPorts(t, path) {\n        Nudger.ExtendPolylineToSourcePort(t, path.GeomEdge.sourcePort.Location);\n        Nudger.ExtendPolylineToTargetPort(t, path.GeomEdge.targetPort.Location);\n        // In some overlapped cases where the source or target vertex used for the path\n        // coincides with the target or source port location, we can end up with a single-point\n        // path.  In that case, we just force a straightline path.\n        if (t.points.length < 2) {\n            t.points = new Array(2);\n            t.points[0] = path.GeomEdge.sourcePort.Location;\n            t.points[1] = path.GeomEdge.targetPort.Location;\n        }\n    }\n    static ExtendPolylineToTargetPort(t, location) {\n        const n = t.points.length - 1;\n        const dir = CompassVector.VectorDirectionPP(t.points[n - 1], t.points[n]);\n        if (Nudger.ProjectionsAreClose(t.points[n - 1], dir, location)) {\n            // it might be that the last point on polyline is at the port already\n            // then we just drop the last point\n            t.points = t.points.slice(0, n);\n            return;\n        }\n        const p = t.points[n];\n        if (dir === Direction.East || dir === Direction.West) {\n            t.points[n] = new Point(location.x, p.y);\n        }\n        else {\n            t.points[n] = new Point(p.x, location.y);\n        }\n    }\n    static ProjectionsAreClose(a, dir, b) {\n        if (dir === Direction.East || dir === Direction.West) {\n            return closeDistEps(a.x, b.x);\n        }\n        return closeDistEps(a.y, b.y);\n    }\n    static ExtendPolylineToSourcePort(t, location) {\n        const dir = CompassVector.VectorDirectionPP(t.points[0], t.points[1]);\n        if (Nudger.ProjectionsAreClose(t.points[1], dir, location)) {\n            // it might be that the second point on polyline is at the port already\n            // then we just drop the first point\n            t.points = t.points.slice(1);\n            return;\n        }\n        const p = t.points[0];\n        if (dir === Direction.East || dir === Direction.West) {\n            t.points[0] = new Point(location.x, p.y);\n        }\n        else {\n            t.points[0] = new Point(p.x, location.y);\n        }\n    }\n    static RemoveSwitchbacksAndMiddlePoints(points) {\n        const ret = [];\n        let a = points[0];\n        ret.push(a);\n        let b = points[1];\n        let prevDir = CompassVector.VectorDirectionPP(a, b);\n        let i = 1;\n        while (++i < points.length) {\n            const dir = CompassVector.VectorDirectionPP(b, points[i]);\n            if (!(dir === prevDir || CompassVector.OppositeDir(dir) === prevDir || dir === Direction.None)) {\n                if (!Point.closeDistEps(a, b)) {\n                    // make sure that we are not returning the same point twice\n                    ret.push((a = Nudger.Rectilinearise(a, b)));\n                }\n                prevDir = dir;\n            }\n            b = points[i];\n        }\n        if (!Point.closeDistEps(a, b)) {\n            ret.push(Nudger.Rectilinearise(a, b));\n        }\n        return ret;\n    }\n    // this function defines the final path coordinates\n    // the set of paths, point sequences\n    // the radius of the arc inscribed into the path corners\n    // an enumeration of padded obstacles\n    //\n    //\n    // <returns>the mapping of the path to its modified path</returns>\n    static NudgePaths(paths, cornerFitRadius, paddedObstacles, ancestorsSets, removeStaircases) {\n        if (paths.length === 0) {\n            return;\n        }\n        const nudger = new Nudger(paths, cornerFitRadius, paddedObstacles, ancestorsSets);\n        nudger.Calculate(Direction.North, true);\n        nudger.Calculate(Direction.East, false);\n        nudger.Calculate(Direction.North, false);\n        if (removeStaircases) {\n            nudger.RemoveStaircases();\n        }\n        for (const path of paths) {\n            path.GeomEdge.curve = Polyline.mkFromPoints(Nudger.BuildPolylineForPath(path));\n        }\n    }\n    RemoveStaircases() {\n        StaircaseRemover.RemoveStaircases(this.Paths, this.HierarchyOfObstacles);\n    }\n    static MapPortsToShapes(listOfShapes) {\n        const portToShapes = new Map();\n        for (const shape of listOfShapes) {\n            for (const port of shape.Ports) {\n                portToShapes.set(port, shape);\n            }\n        }\n        return portToShapes;\n    }\n    // ShowPathsDebug(edgePaths: Iterable<Path>, fn: string) {\n    //  const debCurves = GetObstacleBoundaries(this.Obstacles, 'black')\n    //  const i = 0\n    //  for (const edgePath of edgePaths) {\n    //    for (const c of Nudger.GetEdgePathFromPathEdgesAsDebugCurves(\n    //      0.1,\n    //      1.0,\n    //      DebugCurve.colors[(i + 1) % DebugCurve.colors.length],\n    //      edgePath,\n    //    )) {\n    //      debCurves.push(c)\n    //    }\n    //  }\n    //  SvgDebugWriter.dumpDebugCurves(fn, debCurves)\n    // }\n    static *GetEdgePathFromPathEdgesAsDebugCurves(startWidth, endWidth, color, path) {\n        const points = path.ArrayOfPathPoints();\n        const count = points.length;\n        const deltaW = count > 1 ? (endWidth - startWidth) / (count - 1) : 1;\n        // if count ==1 the value of deltaW does not matter\n        for (let i = 0; i < points.length - 1; i++) {\n            yield DebugCurve.mkDebugCurveTWCI(200, startWidth + deltaW * i, color, LineSegment.mkPP(points[i], points[i + 1]));\n        }\n    }\n}\n// function GetObstacleBoundaries(\n//  obstacles: Array<Polyline>,\n//  color: string,\n// ): Array<DebugCurve> {\n//  const debugCurves = new Array<DebugCurve>()\n//  if (obstacles != null) {\n//    for (const o of obstacles)\n//      debugCurves.push(DebugCurve.mkDebugCurveTWCI(50, 0.3, color, o))\n//  }\n//  return debugCurves\n// }\nfunction IntersectSets(a, b) {\n    const r = new Set();\n    if (a.size < b.size) {\n        for (const x of a)\n            if (b.has(x))\n                r.add(x);\n    }\n    else {\n        for (const x of b)\n            if (a.has(x))\n                r.add(x);\n    }\n    return r;\n}\n//# sourceMappingURL=Nudger.js.map","import { StringBuilder } from 'typescript-string-operations';\nimport { LinkedPoint } from './LinkedPoint';\n// represents the path for an GeomEdge\nexport class Path {\n    get PathPoints() {\n        return this._pathPoints;\n    }\n    set PathPoints(value) {\n        this._pathPoints = value;\n    }\n    get Width() {\n        return this.GeomEdge.lineWidth;\n    }\n    // constructor\n    constructor(edgeGeometry) {\n        this.GeomEdge = edgeGeometry;\n    }\n    get End() {\n        return this.LastEdge.Target;\n    }\n    get Start() {\n        return this.FirstEdge.Source;\n    }\n    ArrayOfPathPoints() {\n        if (this._pathPoints instanceof LinkedPoint) {\n            return Array.from(iteratePoints(this._pathPoints));\n        }\n        else {\n            return this._pathPoints;\n        }\n    }\n    *PathEdges() {\n        for (let e = this.FirstEdge; e != null; e = e.Next) {\n            yield e;\n        }\n    }\n    AddEdge(edge) {\n        edge.Path = this;\n        /*Assert.assert(edge.Source === this.LastEdge.Target)*/\n        this.LastEdge.Next = edge;\n        edge.Prev = this.LastEdge;\n        this.LastEdge = edge;\n    }\n    SetFirstEdge(edge) {\n        this.FirstEdge = edge;\n        this.LastEdge = edge;\n        edge.Path = this;\n    }\n    //\n    toString() {\n        const sb = new StringBuilder();\n        if (this.PathPoints instanceof LinkedPoint)\n            sb.Append('L');\n        for (const p of iteratePoints(this.PathPoints))\n            sb.Append(p.toString());\n        return sb.ToString();\n    }\n}\nfunction* iteratePoints(pathPoints) {\n    if (pathPoints instanceof LinkedPoint) {\n        for (let p = pathPoints; p != null; p = p.Next) {\n            yield p.Point;\n        }\n    }\n    else {\n        for (const p of pathPoints)\n            yield p;\n    }\n}\n//# sourceMappingURL=Path.js.map","// A place holder for an edge in a path to keep it inside of a linked list representing a path.\n// Each PathEdge belongs to only one path\nimport { CompassVector } from '../../../math/geometry/compassVector';\nimport { closeDistEps } from '../../../utils/compare';\n// In the last case the PathEdge is marked as Reversed. Several PathEdges can share the same AxisEdge.\nexport class PathEdge {\n    toString() {\n        return this.Source + (' ' + this.Target);\n    }\n    constructor(edgeForNudging, width) {\n        // A fixed edge cannot be shifted from its visibility edge; offset is always 0.\n        // Such an edge can be, for example, a terminal edge going to a port.\n        this.IsFixed = false;\n        // if set to true then in the path the edge is reversed\n        this.Reversed = false;\n        this.index = -1;\n        this.AxisEdge = edgeForNudging;\n        this.Width = width;\n    }\n    // It is the offset of the edge from the underlying line segment\n    // [VisibilityEdge.SourcePoint, VisibilityEdge.TargetPoint] in to the direction of the VisibilityEdge.Perpendicular.\n    // Offset holder is the same for the maximal parallel sequence of connected PathEdges\n    get LongestNudgedSegment() {\n        return this.longestNudgedSegment;\n    }\n    set LongestNudgedSegment(value) {\n        this.longestNudgedSegment = value;\n        if (this.longestNudgedSegment != null) {\n            this.longestNudgedSegment.AddEdge(this);\n            this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment);\n        }\n    }\n    get Source() {\n        return !this.Reversed ? this.AxisEdge.SourcePoint : this.AxisEdge.TargetPoint;\n    }\n    get Target() {\n        return this.Reversed ? this.AxisEdge.SourcePoint : this.AxisEdge.TargetPoint;\n    }\n    static VectorsAreParallel(a, b) {\n        return closeDistEps(a.x * b.y - a.y * b.x, 0);\n    }\n    static EdgesAreParallel(edge, pathEdge) {\n        return PathEdge.VectorsAreParallel(edge.AxisEdge.TargetPoint.sub(edge.AxisEdge.SourcePoint), pathEdge.AxisEdge.TargetPoint.sub(pathEdge.AxisEdge.SourcePoint));\n    }\n    get Direction() {\n        return this.Reversed ? CompassVector.OppositeDir(this.AxisEdge.Direction) : this.AxisEdge.Direction;\n    }\n    // not set yet\n    // the index of the edge in the order\n    get Index() {\n        return this.index;\n    }\n    set Index(value) {\n        this.index = value;\n    }\n}\n//# sourceMappingURL=PathEdge.js.map","// Avoid a situation where two paths cross each other more than once. Remove self loops.\n//\nimport { PointMap } from '../../../utils/PointMap';\nimport { LinkedPoint } from './LinkedPoint';\nexport class PathMerger {\n    constructor(paths) {\n        this.verticesToPathOffsets = new PointMap();\n        this.Paths = paths;\n    }\n    // Avoid a situation where two paths cross each other more than once. Remove self loops.\n    MergePaths() {\n        this.InitVerticesToPathOffsetsAndRemoveSelfCycles();\n        for (const path of this.Paths) {\n            this.ProcessPath(path);\n        }\n    }\n    ProcessPath(path) {\n        const departedPaths = new Map();\n        let prevLocationPathOffsets = null;\n        for (let linkedPoint = path.PathPoints; linkedPoint != null; linkedPoint = linkedPoint.Next) {\n            const pathOffsets = this.verticesToPathOffsets.get(linkedPoint.Point);\n            if (prevLocationPathOffsets != null) {\n                // handle returning paths\n                if (departedPaths.size > 0) {\n                    for (const [path0, v] of pathOffsets) {\n                        const departerLinkedPoint = departedPaths.get(path0);\n                        if (departerLinkedPoint) {\n                            // returned!\n                            this.CollapseLoopingPath(path0, departerLinkedPoint, v, path, linkedPoint);\n                            departedPaths.delete(path0);\n                        }\n                    }\n                }\n                // find departed paths\n                for (const [k, v] of prevLocationPathOffsets) {\n                    if (!pathOffsets.has(k))\n                        departedPaths.set(k, v);\n                }\n            }\n            prevLocationPathOffsets = pathOffsets;\n        }\n    }\n    //        bool Correct() {\n    //            foreach (var kv of verticesToPathOffsets) {\n    //                Point p = kv.Key;\n    //                Map<Path, LinkedPoint> pathOffs = kv.Value;\n    //                foreach (var pathOff of pathOffs) {\n    //                    var path = pathOff.Key;\n    //                    var linkedPoint = pathOff.Value;\n    //                    if (linkedPoint.Point !== p)\n    //                        return false;\n    //                    if (FindLinkedPointInPath(path, p) == null ) {\n    //                        return false;\n    //                    }\n    //                }\n    //            }\n    //            return true;\n    //        }\n    CollapseLoopingPath(loopingPath, departureFromLooping, arrivalToLooping, stemPath, arrivalToStem) {\n        const departurePointOnStem = PathMerger.FindLinkedPointInPath(stemPath, departureFromLooping.Point);\n        const pointsToInsert = Array.from(PathMerger.GetPointsInBetween(departurePointOnStem, arrivalToStem));\n        if (PathMerger.Before(departureFromLooping, arrivalToLooping)) {\n            this.CleanDisappearedPiece(departureFromLooping, arrivalToLooping, loopingPath);\n            this.ReplacePiece(departureFromLooping, arrivalToLooping, pointsToInsert, loopingPath);\n        }\n        else {\n            this.CleanDisappearedPiece(arrivalToLooping, departureFromLooping, loopingPath);\n            this.ReplacePiece(arrivalToLooping, departureFromLooping, pointsToInsert.reverse(), loopingPath);\n        }\n    }\n    static *GetPointsInBetween(a, b) {\n        for (let i = a.Next; i !== b; i = i.Next) {\n            yield i.Point;\n        }\n    }\n    ReplacePiece(a, b, points, loopingPath) {\n        let prevPoint = a;\n        for (const point of points) {\n            const lp = new LinkedPoint(point);\n            prevPoint.Next = lp;\n            prevPoint = lp;\n            const pathOffset = this.verticesToPathOffsets.get(point);\n            /*Assert.assert(!pathOffset.has(loopingPath))*/\n            pathOffset.set(loopingPath, prevPoint);\n        }\n        prevPoint.Next = b;\n    }\n    CleanDisappearedPiece(a, b, loopingPath) {\n        for (const point of PathMerger.GetPointsInBetween(a, b)) {\n            const pathOffset = this.verticesToPathOffsets.get(point);\n            /*Assert.assert(pathOffset.has(loopingPath))*/\n            pathOffset.delete(loopingPath);\n        }\n    }\n    // checks that a is before b of the path\n    // <returns>true is a is before b of the path</returns>\n    static Before(a, b) {\n        for (a = a.Next; a != null; a = a.Next) {\n            if (a === b) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static FindLinkedPointInPath(path, point) {\n        // this function is supposed to always succeed. it will throw a null reference exception otherwise\n        for (let linkedPoint = path.PathPoints;; linkedPoint = linkedPoint.Next) {\n            if (linkedPoint.Point.equal(point)) {\n                return linkedPoint;\n            }\n        }\n    }\n    InitVerticesToPathOffsetsAndRemoveSelfCycles() {\n        for (const path of this.Paths) {\n            for (let linkedPoint = path.PathPoints; linkedPoint != null; linkedPoint = linkedPoint.Next) {\n                let pathOffsets = this.verticesToPathOffsets.get(linkedPoint.Point);\n                if (!pathOffsets) {\n                    this.verticesToPathOffsets.set(linkedPoint.Point, (pathOffsets = new Map()));\n                }\n                // check for the loop\n                const loopPoint = pathOffsets.get(path);\n                if (loopPoint) {\n                    // we have a loop\n                    this.CleanDisappearedPiece(loopPoint, linkedPoint, path);\n                    loopPoint.Next = linkedPoint.Next;\n                }\n                else {\n                    pathOffsets.set(path, linkedPoint);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=PathMerger.js.map","// If two paths intersect then insert the intersection point as a vertex into both paths.\n// Remove path self loops. Merge paths between the crossings if they have multiple crossings.\n// If a path passes through a vertex of another path then insert this vertex into the first path.\nimport { Point } from '../../../math/geometry/point';\nimport { Direction } from '../../../math/geometry/direction';\nimport { LinkedPoint } from './LinkedPoint';\nimport { LinkedPointSplitter } from './LinkedPointSplitter';\nimport { PathMerger } from './PathMerger';\nimport { closeDistEps } from '../../../utils/compare';\nexport class PathRefiner {\n    static RefinePaths(paths, mergePaths) {\n        PathRefiner.AdjustPaths(paths);\n        const pathsToFirstLinkedVertices = PathRefiner.CreatePathsToFirstLinkedVerticesMap(paths);\n        PathRefiner.Refine(Array.from(pathsToFirstLinkedVertices.values()));\n        PathRefiner.CrossVerticalAndHorizontalSegs(pathsToFirstLinkedVertices.values());\n        PathRefiner.ReconstructPathsFromLinkedVertices(pathsToFirstLinkedVertices);\n        if (mergePaths) {\n            new PathMerger(paths).MergePaths();\n        }\n    }\n    // make sure that every two different points of paths are separated by at least 10e-6\n    static AdjustPaths(paths) {\n        for (const path of paths) {\n            path.PathPoints = PathRefiner.AdjustPathPoints(path.PathPoints);\n        }\n    }\n    static AdjustPathPoints(points) {\n        if (!points || points.length === 0)\n            return;\n        const arr = [];\n        let p = Point.RoundPoint(points[0]);\n        arr.push(p);\n        for (let i = 1; i < points.length; i++) {\n            const np = Point.RoundPoint(points[i]);\n            if (!p.equal(np)) {\n                p = np;\n                arr.push(p);\n            }\n        }\n        return arr;\n    }\n    static CrossVerticalAndHorizontalSegs(pathsFirstLinked) {\n        const horizontalPoints = new Array();\n        const verticalPoints = new Array();\n        for (const pnt of pathsFirstLinked) {\n            for (let p = pnt; p.Next != null; p = p.Next) {\n                if (closeDistEps(p.Point.x, p.Next.Point.x)) {\n                    verticalPoints.push(p);\n                }\n                else {\n                    horizontalPoints.push(p);\n                }\n            }\n        }\n        new LinkedPointSplitter(horizontalPoints, verticalPoints).SplitPoints();\n    }\n    static ReconstructPathsFromLinkedVertices(pathsToPathLinkedPoints) {\n        for (const [k, v] of pathsToPathLinkedPoints) {\n            k.PathPoints = v;\n        }\n    }\n    static Refine(pathFirstPoints) {\n        PathRefiner.RefineInDirection(Direction.North, pathFirstPoints);\n        PathRefiner.RefineInDirection(Direction.East, pathFirstPoints);\n    }\n    // refines all segments that are parallel to \"direction\"\n    static *groupByProj(proj, linkedPointsInDirection) {\n        const map = new Map();\n        for (const lp of linkedPointsInDirection) {\n            const p = proj(lp.Point);\n            let arr = map.get(p);\n            if (!arr) {\n                arr = new Array();\n                map.set(p, arr);\n            }\n            arr.push(lp);\n        }\n        for (const v of map.values()) {\n            yield v;\n        }\n    }\n    static RefineInDirection(direction, pathFirstPoints) {\n        const t = {\n            projectionToPerp: undefined,\n            projectionToDirection: undefined,\n        };\n        PathRefiner.GetProjectionsDelegates(direction, t);\n        const linkedPointsInDirection = Array.from(PathRefiner.GetAllLinkedVertsInDirection(t.projectionToPerp, pathFirstPoints));\n        const colliniarBuckets = PathRefiner.groupByProj(t.projectionToPerp, linkedPointsInDirection);\n        for (const pathLinkedPointBucket of colliniarBuckets) {\n            PathRefiner.RefineCollinearBucket(pathLinkedPointBucket, t.projectionToDirection);\n        }\n    }\n    static GetProjectionsDelegates(direction, t) {\n        if (direction === Direction.East) {\n            t.projectionToDirection = (p) => p.x;\n            t.projectionToPerp = (p) => p.y;\n        }\n        else {\n            t.projectionToPerp = (p) => p.x;\n            t.projectionToDirection = (p) => p.y;\n        }\n    }\n    static *GetAllLinkedVertsInDirection(projectionToPerp, initialVerts) {\n        for (const vert of initialVerts) {\n            for (let v = vert; v.Next != null; v = v.Next) {\n                if (closeDistEps(projectionToPerp(v.Point), projectionToPerp(v.Next.Point))) {\n                    yield v;\n                }\n            }\n        }\n    }\n    // refine vertices belonging to a bucket;\n    // pathLinkedVertices belong to a line parallel to the direction of the refinement\n    static RefineCollinearBucket(pathLinkedVertices, projectionToDirection) {\n        const coords = new Set();\n        const pointProjPairs = new Array();\n        for (const pathLinkedPoint of pathLinkedVertices) {\n            let x = projectionToDirection(pathLinkedPoint.Point);\n            if (!coords.has(x)) {\n                coords.add(x);\n                pointProjPairs.push([pathLinkedPoint.Point, x]);\n            }\n            x = projectionToDirection(pathLinkedPoint.Next.Point);\n            if (!coords.has(x)) {\n                coords.add(x);\n                pointProjPairs.push([pathLinkedPoint.Next.Point, x]);\n            }\n        }\n        pointProjPairs.sort((a, b) => a[1] - b[1]);\n        const points = pointProjPairs.map(a => a[0]);\n        const coordToIndex = new Map();\n        for (let i = 0; i < pointProjPairs.length; i++)\n            coordToIndex.set(pointProjPairs[i][1], i);\n        for (const pathLinkedVertex of pathLinkedVertices) {\n            const i = coordToIndex.get(projectionToDirection(pathLinkedVertex.Point));\n            const j = coordToIndex.get(projectionToDirection(pathLinkedVertex.Next.Point));\n            if (Math.abs(j - i) > 1) {\n                PathRefiner.InsertPoints(pathLinkedVertex, points, i, j);\n            }\n        }\n    }\n    static InsertPoints(pathLinkedVertex, arrayOfPoints, i, j) {\n        if (i < j) {\n            pathLinkedVertex.InsertVerts(i, j, arrayOfPoints);\n        }\n        else {\n            pathLinkedVertex.InsertVertsInReverse(j, i, arrayOfPoints);\n        }\n    }\n    static CreatePathsToFirstLinkedVerticesMap(edgePaths) {\n        const dict = new Map();\n        for (const path of edgePaths) {\n            dict.set(path, PathRefiner.CreateLinkedVertexOfEdgePath(path));\n        }\n        return dict;\n    }\n    static CreateLinkedVertexOfEdgePath(path) {\n        const arr = path.PathPoints;\n        let pathPoint = new LinkedPoint(arr[0]);\n        const first = pathPoint;\n        for (let i = 1; i < arr.length; i++) {\n            pathPoint.Next = new LinkedPoint(arr[i]);\n            pathPoint = pathPoint.Next;\n        }\n        return first;\n    }\n}\n//# sourceMappingURL=PathRefiner.js.map","export class SegWithIndex {\n    // offset\n    constructor(pts, i) {\n        /*Assert.assert(i < pts.length && i >= 0)*/\n        this.Points = pts;\n        this.I = i;\n    }\n    static equal(a, b) {\n        return a.I === b.I && a.Points === b.Points;\n    }\n    get Start() {\n        return this.Points[this.I];\n    }\n    get End() {\n        return this.Points[this.I + 1];\n    }\n}\n//# sourceMappingURL=SegWithIndex.js.map","import { Point, Rectangle, CompassVector, Curve, GeomConstants, LineSegment } from '../../../math/geometry';\nimport { BinaryRTree } from '../../../math/geometry/RTree/rTree';\nimport { closeDistEps } from '../../../utils/compare';\nimport { SegWithIndex } from './SegWithIndex';\nexport class StaircaseRemover {\n    constructor(paths, hierarchyOfObstacles) {\n        this.segTree = new BinaryRTree(null);\n        this.crossedOutPaths = new Set();\n        this.HierarchyOfObstacles = new BinaryRTree(hierarchyOfObstacles);\n        this.Paths = paths;\n    }\n    static RemoveStaircases(paths, hierarchyOfObstacles) {\n        const r = new StaircaseRemover(paths, hierarchyOfObstacles);\n        r.Calculate();\n    }\n    Calculate() {\n        this.InitHierarchies();\n        let success;\n        do {\n            success = false;\n            for (const path of this.Paths.filter((p) => !this.crossedOutPaths.has(p))) {\n                if (this.ProcessPath(path))\n                    success = true;\n            }\n        } while (success);\n    }\n    ProcessPath(path) {\n        const t = { pts: path.PathPoints, canHaveStaircase: false };\n        if (this.ProcessPoints(t)) {\n            path.PathPoints = t.pts;\n            return true;\n        }\n        if (!t.canHaveStaircase) {\n            this.crossedOutPaths.add(path);\n        }\n        return false;\n    }\n    ProcessPoints(t) {\n        const staircaseStart = this.FindStaircaseStart(t);\n        if (staircaseStart < 0) {\n            return false;\n        }\n        t.pts = this.RemoveStaircasePN(t.pts, staircaseStart);\n        return true;\n    }\n    FindStaircaseStart(t) {\n        t.canHaveStaircase = false;\n        if (t.pts.length < 5) {\n            return -1;\n        }\n        const segs = [new SegWithIndex(t.pts, 0), new SegWithIndex(t.pts, 1), new SegWithIndex(t.pts, 2), new SegWithIndex(t.pts, 3)];\n        let segToReplace = 0;\n        for (let i = 0;;) {\n            const w = { canHaveStaircaseAtI: false };\n            if (this.IsStaircase(t.pts, i, segs, w)) {\n                t.canHaveStaircase = true;\n                return i;\n            }\n            t.canHaveStaircase = t.canHaveStaircase || w.canHaveStaircaseAtI;\n            i++;\n            if (t.pts.length < i + 5) {\n                return -1;\n            }\n            segs[segToReplace] = new SegWithIndex(t.pts, i + 3);\n            segToReplace++;\n            segToReplace %= 4;\n        }\n    }\n    static GetFlippedPoint(pts, offset) {\n        const horiz = closeDistEps(pts[offset].y, pts[offset + 1].y);\n        return horiz ? new Point(pts[offset + 4].x, pts[offset].y) : new Point(pts[offset].x, pts[offset + 4].y);\n    }\n    // ignoring crossing at a\n    Crossing(a, b, segsToIgnore) {\n        return StaircaseRemover.IsCrossing(LineSegment.mkPP(a, b), this.segTree, segsToIgnore);\n    }\n    // ignoring crossing at ls.Start\n    static IsCrossing(ls, rTree, segsToIgnore) {\n        for (const seg of rTree.GetAllIntersecting(ls.boundingBox))\n            if (segsToIgnore.findIndex((p) => p === seg) === -1)\n                return true;\n        return false;\n    }\n    IntersectObstacleHierarchyPPP(a, b, c) {\n        return this.IntersectObstacleHierarchyL(LineSegment.mkPP(a, b)) || this.IntersectObstacleHierarchyL(LineSegment.mkPP(b, c));\n    }\n    IntersectObstacleHierarchyL(ls) {\n        return this.HierarchyOfObstacles.GetAllIntersecting(ls.boundingBox).some((poly) => Curve.intersectionOne(ls, poly, false) != null);\n    }\n    IsStaircase(pts, offset, segsToIgnore, w) {\n        const a = pts[offset];\n        const b = pts[offset + 1];\n        let c = pts[offset + 2];\n        const d = pts[offset + 3];\n        const f = pts[offset + 4];\n        w.canHaveStaircaseAtI = false;\n        if (CompassVector.DirectionFromPointToPoint(a, b) !== CompassVector.DirectionFromPointToPoint(c, d) ||\n            CompassVector.DirectionFromPointToPoint(b, c) !== CompassVector.DirectionFromPointToPoint(d, f)) {\n            return false;\n        }\n        c = StaircaseRemover.GetFlippedPoint(pts, offset);\n        if (this.IntersectObstacleHierarchyPPP(b, c, d)) {\n            return false;\n        }\n        w.canHaveStaircaseAtI = true;\n        return !this.Crossing(b, c, segsToIgnore);\n    }\n    RemoveStaircasePN(pts, staircaseStart) {\n        const a = pts[staircaseStart];\n        const b = pts[staircaseStart + 1];\n        const horiz = Math.abs(a.y - b.y) < GeomConstants.distanceEpsilon / 2;\n        return this.RemoveStaircasePNB(pts, staircaseStart, horiz);\n    }\n    RemoveStaircasePNB(pts, staircaseStart, horiz) {\n        this.RemoveSegs(pts);\n        const ret = new Array(pts.length - 2);\n        ArrayCopyAAN(pts, ret, staircaseStart + 1);\n        const a = pts[staircaseStart + 1];\n        const c = pts[staircaseStart + 3];\n        ret[staircaseStart + 1] = horiz ? new Point(c.x, a.y) : new Point(a.x, c.y);\n        ArrayCopyANANN(pts, staircaseStart + 4, ret, staircaseStart + 2, ret.length - staircaseStart - 2);\n        this.InsertNewSegs(ret, staircaseStart);\n        return ret;\n    }\n    RemoveSegs(pts) {\n        for (let i = 0; i < pts.length - 1; i++) {\n            this.RemoveSeg(new SegWithIndex(pts, i));\n        }\n    }\n    RemoveSeg(seg) {\n        this.segTree.Remove(StaircaseRemover.Rect(seg), seg);\n    }\n    InsertNewSegs(pts, staircaseStart) {\n        this.InsSeg(pts, staircaseStart);\n        this.InsSeg(pts, staircaseStart + 1);\n    }\n    InitHierarchies() {\n        for (const path of this.Paths) {\n            this.InsertPathSegs(path);\n        }\n    }\n    InsertPathSegs(path) {\n        this.InsertSegs(path.PathPoints);\n    }\n    InsertSegs(pts) {\n        for (let i = 0; i < pts.length - 1; i++) {\n            this.InsSeg(pts, i);\n        }\n    }\n    InsSeg(pts, i) {\n        const seg = new SegWithIndex(pts, i);\n        this.segTree.Add(StaircaseRemover.Rect(seg), seg);\n    }\n    static Rect(seg) {\n        return Rectangle.mkPP(seg.Start, seg.End);\n    }\n}\nfunction ArrayCopyANANN(a, ai, b, bi, length) {\n    while (length-- > 0) {\n        b[bi++] = a[ai++];\n    }\n}\nfunction ArrayCopyAAN(a, b, length) {\n    /*Assert.assert(a.length >= length)*/\n    /*Assert.assert(b.length >= length)*/\n    let i = 0;\n    while (length-- > 0) {\n        b[i++] = a[i++];\n    }\n}\n//# sourceMappingURL=StaircaseRemover.js.map","import { CompassVector } from '../../math/geometry/compassVector';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { Point, TriangleOrientation } from '../../math/geometry/point';\nimport { Polyline } from '../../math/geometry/polyline';\nimport { substractSets } from '../../utils/setOperations';\nimport { InteractiveObstacleCalculator } from '../interactiveObstacleCalculator';\nimport { LowObstacleSide, HighObstacleSide } from './BasicObstacleSide';\nexport class Obstacle {\n    get PaddedPolyline() {\n        return this._PaddedPolyline;\n    }\n    set PaddedPolyline(value) {\n        this._PaddedPolyline = value;\n    }\n    get looseVisibilityPolyline() {\n        if (this._looseVisibilityPolyline == null) {\n            this._looseVisibilityPolyline = Obstacle.CreateLoosePolyline(this.VisibilityPolyline);\n        }\n        return this._looseVisibilityPolyline;\n    }\n    set looseVisibilityPolyline(value) {\n        this._looseVisibilityPolyline = value;\n    }\n    GetPortChanges(t) {\n        t.addedPorts = substractSets(this.InputShape.Ports, this.Ports);\n        t.removedPorts = substractSets(this.Ports, this.InputShape.Ports);\n        if (0 === t.addedPorts.size && 0 === t.removedPorts.size) {\n            return false;\n        }\n        this.Ports = new Set(this.InputShape.Ports);\n        return true;\n    }\n    get IsInConvexHull() {\n        return this.ConvexHull != null;\n    }\n    get IsGroup() {\n        return this.InputShape != null && this.InputShape.IsGroup;\n    }\n    get VisibilityBoundingBox() {\n        return this.VisibilityPolyline.boundingBox;\n    }\n    get VisibilityPolyline() {\n        return this.ConvexHull != null ? this.ConvexHull.Polyline : this.PaddedPolyline;\n    }\n    static CreateSentinel(a, b, scanDir, scanlineOrdinal) {\n        const sentinel = Obstacle.mk(a, b, scanlineOrdinal);\n        sentinel.CreateInitialSides(sentinel.PaddedPolyline.startPoint, scanDir);\n        return sentinel;\n    }\n    CreateInitialSides(startPoint, scanDir) {\n        /*Assert.assert(\n          this.ActiveLowSide == null  && this.ActiveHighSide == null ,\n          'Cannot call SetInitialSides when sides are already set',\n        )*/\n        this.ActiveLowSide = new LowObstacleSide(this, startPoint, scanDir);\n        this.ActiveHighSide = new HighObstacleSide(this, startPoint, scanDir);\n        if (scanDir.IsFlatS(this.ActiveHighSide)) {\n            // No flat sides in the scanline; we'll do lookahead processing in the scanline to handle overlaps\n            // with existing segments, and normal neighbor handling will take care of collinear OpenVertexEvents.\n            this.ActiveHighSide = new HighObstacleSide(this, this.ActiveHighSide.EndVertex, scanDir);\n        }\n    }\n    constructor(shape, padding) {\n        if (shape == null) {\n            return;\n        }\n        this.PaddedPolyline = InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(shape.BoundaryCurve, padding);\n        Obstacle.RoundVerticesAndSimplify(this.PaddedPolyline);\n        this.IsRectangle = this.IsPolylineRectangle();\n        this.InputShape = shape;\n        this.Ports = new Set(this.InputShape.Ports);\n    }\n    static mk(a, b, scanlineOrdinal) {\n        const obs = new Obstacle(null, 0);\n        obs.PaddedPolyline = Polyline.mkClosedFromPoints([Point.RoundPoint(a), Point.RoundPoint(b)]);\n        obs.Ordinal = scanlineOrdinal;\n        return obs;\n    }\n    IsPolylineRectangle() {\n        if (this.PaddedPolyline.count !== 4) {\n            return false;\n        }\n        let ppt = this.PaddedPolyline.startPoint;\n        let nextPpt = ppt.nextOnPolyline;\n        let dir = CompassVector.VectorDirectionPP(ppt.point, nextPpt.point);\n        if (!CompassVector.IsPureDirection(dir)) {\n            return false;\n        }\n        do {\n            ppt = nextPpt;\n            nextPpt = ppt.nextOnPolyline;\n            const nextDir = CompassVector.DirectionFromPointToPoint(ppt.point, nextPpt.point);\n            // We know the polyline is clockwise.\n            if (nextDir !== CompassVector.RotateRight(dir)) {\n                return false;\n            }\n            dir = nextDir;\n        } while (ppt !== this.PaddedPolyline.startPoint);\n        return true;\n    }\n    static RoundVerticesAndSimplify(polyline) {\n        /*Assert.assert(polyline.isClockwise(), 'Polyline is not clockwise')*/\n        /*Assert.assert(polyline.closed)*/\n        // Following creation of the padded border, round off the vertices for consistency\n        // in later operations (intersections and event ordering).\n        let ppt = polyline.startPoint;\n        do {\n            ppt.point = Point.RoundPoint(ppt.point);\n            ppt = ppt.nextOnPolyline;\n        } while (ppt !== polyline.startPoint);\n        Obstacle.RemoveCloseAndCollinearVerticesInPlace(polyline);\n        // We've modified the points so the BoundingBox may have changed; force it to be recalculated.\n        polyline.setInitIsRequired();\n        // Verify that the polyline is still clockwise.\n        /*Assert.assert(\n          polyline.isClockwise(),\n          'Polyline is not clockwise after RoundVertices',\n        )*/\n    }\n    // A single convex hull is shared by all obstacles contained by it and we only want one occurrence of that\n    // convex hull's polyline in the visibility graph generation.\n    get IsPrimaryObstacle() {\n        return this.ConvexHull == null || this === this.ConvexHull.PrimaryObstacle;\n    }\n    static RemoveCloseAndCollinearVerticesInPlace(polyline) {\n        const epsilon = GeomConstants.intersectionEpsilon * 10;\n        for (let pp = polyline.startPoint.next; pp != null; pp = pp.next) {\n            if (Point.close(pp.prev.point, pp.point, epsilon)) {\n                if (pp.next == null) {\n                    polyline.RemoveEndPoint();\n                }\n                else {\n                    pp.prev.next = pp.next;\n                    pp.next.prev = pp.prev;\n                }\n            }\n        }\n        if (Point.close(polyline.start, polyline.end, epsilon)) {\n            polyline.RemoveStartPoint();\n        }\n        polyline = polyline.RemoveCollinearVertices();\n        if (polyline.endPoint.prev != null &&\n            polyline.endPoint.prev !== polyline.startPoint &&\n            Point.getTriangleOrientation(polyline.endPoint.prev.point, polyline.end, polyline.start) === TriangleOrientation.Collinear) {\n            polyline.RemoveEndPoint();\n        }\n        if (polyline.startPoint.next != null &&\n            polyline.endPoint.prev !== polyline.startPoint &&\n            Point.getTriangleOrientation(polyline.end, polyline.start, polyline.startPoint.next.point) === TriangleOrientation.Collinear) {\n            polyline.RemoveStartPoint();\n        }\n        polyline.setInitIsRequired();\n        return polyline;\n    }\n    get isOverlapped() {\n        return this.clump !== undefined && this.clump.length > 0;\n    }\n    get IsSentinel() {\n        return this.InputShape == null;\n    }\n    IsInSameClump(other) {\n        return this.isOverlapped && this.clump === other.clump;\n    }\n    Close() {\n        this.ActiveLowSide = null;\n        this.ActiveHighSide = null;\n    }\n    SetConvexHull(hull) {\n        // This obstacle may have been in a rectangular obstacle or clump that was now found to overlap with a non-rectangular obstacle.\n        this.clump = null;\n        this.IsRectangle = false;\n        this.ConvexHull = hull;\n        this.looseVisibilityPolyline = null;\n    }\n    static CreateLoosePolyline(polyline) {\n        const loosePolyline = InteractiveObstacleCalculator.CreatePaddedPolyline(polyline, GeomConstants.intersectionEpsilon * 10);\n        Obstacle.RoundVerticesAndSimplify(loosePolyline);\n        return loosePolyline;\n    }\n    get IsTransparentAncestor() {\n        return this.InputShape == null ? false : this.InputShape.IsTransparent;\n    }\n    set IsTransparentAncestor(value) {\n        this.InputShape.IsTransparent = value;\n    }\n}\nObstacle.FirstSentinelOrdinal = 1;\nObstacle.FirstNonSentinelOrdinal = 10;\n//# sourceMappingURL=obstacle.js.map","import { Queue } from 'queue-typescript';\nlet id_global = 0;\nexport class Shape {\n    get Parents() {\n        return Array.from(this.parents.values());\n    }\n    get Children() {\n        return Array.from(this.children.values());\n    }\n    get BoundaryCurve() {\n        return this.boundaryCurve;\n    }\n    set BoundaryCurve(value) {\n        this.boundaryCurve = value;\n    }\n    // The bounding box of the shape.\n    get BoundingBox() {\n        return this.BoundaryCurve.boundingBox;\n    }\n    // The set of Ports for this obstacle, usually RelativePorts.  In the event of overlapping\n    // obstacles, this identifies the obstacle to which the port applies.\n    get Ports() {\n        return this.ports;\n    }\n    // Default constructor.\n    static mkShape() {\n        return new Shape(null);\n    }\n    /**  Constructor taking the curve of the shape.*/\n    constructor(boundaryCurve = null) {\n        this.parents = new Set();\n        this.children = new Set();\n        this.ports = new Set();\n        this.BoundaryCurve = boundaryCurve;\n    }\n    /**  A group is a shape that has children.*/\n    get IsGroup() {\n        return this.children.size > 0;\n    }\n    *Descendants() {\n        const q = new Queue();\n        for (const shape of this.Children) {\n            q.enqueue(shape);\n        }\n        while (q.length > 0) {\n            const sh = q.dequeue();\n            yield sh;\n            for (const shape of sh.Children) {\n                q.enqueue(shape);\n            }\n        }\n    }\n    *Ancestors() {\n        const q = new Queue();\n        for (const shape of this.Parents) {\n            q.enqueue(shape);\n        }\n        while (q.length > 0) {\n            const sh = q.dequeue();\n            yield sh;\n            for (const shape of sh.Parents) {\n                q.enqueue(shape);\n            }\n        }\n    }\n    // Adds a parent. A shape can have several parents\n    AddParent(shape) {\n        this.parents.add(shape);\n        shape.children.add(this);\n    }\n    AddChild(shape) {\n        shape.parents.add(this);\n        this.children.add(shape);\n    }\n    //\n    RemoveChild(shape) {\n        this.children.delete(shape);\n        shape.parents.delete(this);\n    }\n    //\n    RemoveParent(shape) {\n        this.parents.delete(shape);\n        shape.children.delete(this);\n    }\n    ToString() {\n        return this.UserData ? this.UserData.toString() : 'null';\n    }\n}\n//# sourceMappingURL=shape.js.map","import { Shape } from './shape';\nimport { mkRTree } from '../math/geometry/RTree/rTree';\nimport { GeomEdge } from '../layout/core/geomEdge';\nimport { RelativeFloatingPort } from '../layout/core/relativeFloatingPort';\nimport { Point } from '../math/geometry/point';\nimport { Algorithm } from '../utils/algorithm';\nimport { Curve, CurveFactory, LineSegment, PointLocation, Rectangle } from '../math/geometry';\nimport { closeDistEps } from '../utils/compare';\nimport { PointSet } from '../utils/PointSet';\nimport { LineSweeper } from './spline/coneSpanner/LineSweeper';\nimport { VisibilityGraph } from './visibility/VisibilityGraph';\nimport { ConeSpanner } from './spline/coneSpanner/ConeSpanner';\nimport { HookUpAnywhereFromInsidePort } from '../layout/core/hookUpAnywhereFromInsidePort';\nimport { ClusterBoundaryPort } from './ClusterBoundaryPort';\nimport { createRectangleNodeOnData, CreateRectNodeOnArrayOfRectNodes, mkRectangleNode, } from '../math/geometry/RTree/rectangleNode';\nimport { CurvePort } from '../layout/core/curvePort';\nimport { BundlingSettings } from './BundlingSettings';\nimport { Assert, GeomGraph } from '..';\nimport { ShapeCreatorForRoutingToParents } from './ShapeCreatorForRoutingToParents';\nimport { ShapeObstacleCalculator } from './ShapeObstacleCalculator';\nimport { InteractiveEdgeRouter } from './interactiveEdgeRouter';\nimport { addRange, uniteSets, insertRange, setIntersection, setsAreEqual } from '../utils/setOperations';\nimport { Queue } from 'queue-typescript';\nimport { Arrowhead } from '../layout/core/arrowhead';\nimport { Polygon } from './visibility/Polygon';\nimport { PointPairMap } from '../utils/pointPairMap';\nimport { InteractiveObstacleCalculator } from './interactiveObstacleCalculator';\nimport { ShapeCreator } from './ShapeCreator';\nimport { getEdgeRoutingSettingsFromAncestorsOrDefault } from '../layout/driver';\nimport { PointPair } from '../math/geometry/pointPair';\nimport { MultiEdgeRouter } from './MultiEdgeRouter';\nimport { BundleRouter } from './spline/bundling/BundleRouter';\nimport { SdShortestPath } from './spline/bundling/SdShortestPath';\nimport { Cdt, createCDTOnPolylineRectNode } from './ConstrainedDelaunayTriangulation/Cdt';\nimport { DebugCurve } from '../math/geometry/debugCurve';\nimport { PathOptimizer } from './spline/pathOptimizer';\nimport { CrossRectangleNodes } from '../math/geometry/RTree/rectangleNodeUtils';\nimport { edgeNodesBelongToSet } from '../structs/graph';\nimport { initRandom } from '../utils/random';\nimport { RelativeShape } from './RelativeShape';\n/**  routing edges around shapes */\nexport class SplineRouter extends Algorithm {\n    get ContinueOnOverlaps() {\n        return this.continueOnOverlaps;\n    }\n    set ContinueOnOverlaps(value) {\n        this.continueOnOverlaps = value;\n    }\n    get LoosePadding() {\n        return this.loosePadding;\n    }\n    set LoosePadding(value) {\n        this.loosePadding = value;\n    }\n    get MultiEdgesSeparation() {\n        return this.multiEdgesSeparation;\n    }\n    set MultiEdgesSeparation(value) {\n        this.multiEdgesSeparation = value;\n    }\n    static mk2(graph, edgeRoutingSettings) {\n        return SplineRouter.mk5(graph, edgeRoutingSettings.Padding, edgeRoutingSettings.PolylinePadding, edgeRoutingSettings.ConeAngle, edgeRoutingSettings.bundlingSettings);\n    }\n    static mk4(graph, tightTightPadding, loosePadding, coneAngle) {\n        return new SplineRouter(graph, Array.from(graph.deepEdges), tightTightPadding, loosePadding, coneAngle, null);\n    }\n    // Creates a spline group router for the given graph\n    static mk5(graph, tightTightPadding, loosePadding, coneAngle, bundlingSettings) {\n        return new SplineRouter(graph, Array.from(graph.deepEdges), tightTightPadding, loosePadding, coneAngle, bundlingSettings);\n    }\n    // Creates a spline group router for a given GeomGraph.\n    constructor(graph, edges, tightPadding = 1, loosePadding = 2, coneAngle = 30 * (Math.PI / 180), bundlingSettings = null, cancelToken = null) {\n        super(cancelToken);\n        // setting this to true forces the calculation to go on even when node overlaps are present\n        //\n        this.continueOnOverlaps = true;\n        this.shapesToTightLooseCouples = new Map();\n        this.multiEdgesSeparation = 0.5;\n        this.routeMultiEdgesAsBundles = true;\n        // if set to true the algorithm will try to shortcut a shortest polyline inner points\n        this.UsePolylineEndShortcutting = true;\n        // if set to true the algorithm will try to shortcut a shortest polyline start and end\n        this.UseInnerPolylingShortcutting = true;\n        this.AllowedShootingStraightLines = true;\n        this._overlapsDetected = false;\n        this.edges = edges;\n        this.BundlingSettings = bundlingSettings;\n        this.geomGraph = graph;\n        this.LoosePadding = loosePadding;\n        this.tightPadding = tightPadding;\n        this.coneAngle = coneAngle;\n        this.routeMultiEdgesAsBundles = edges.length < 1000 && graph.deepNodeCount < 1000;\n    }\n    static mk6(graph, tightPadding, loosePadding, coneAngle, inParentEdges, outParentEdges) {\n        const ret = SplineRouter.mk4(graph, tightPadding, loosePadding, coneAngle);\n        const obstacles = ShapeCreatorForRoutingToParents.GetShapes(inParentEdges, outParentEdges);\n        ret.Initialize(obstacles, coneAngle);\n        return ret;\n    }\n    Initialize(obstacles, coneAngleValue) {\n        this.rootShapes = obstacles.filter((s) => s.Parents == null || s.Parents.length === 0);\n        this.coneAngle = coneAngleValue;\n        if (this.coneAngle === 0) {\n            this.coneAngle = Math.PI / 6;\n        }\n    }\n    // Executes the algorithm.\n    run() {\n        if (this.edges.length == 0) {\n            return;\n        }\n        if (this.geomGraph.isEmpty()) {\n            return;\n        }\n        console.time('SplineRouter');\n        const obstacles = ShapeCreator.GetShapes(this.geomGraph, this.edges);\n        if (this.BundlingSettings == null &&\n            this.geomGraph.layoutSettings &&\n            this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings &&\n            this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings) {\n            this.BundlingSettings = this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings;\n        }\n        this.Initialize(obstacles, this.coneAngle);\n        this.GetOrCreateRoot();\n        this.RouteOnRoot();\n        this.RemoveRoot();\n        console.timeEnd('SplineRouter');\n    }\n    /** Uses the existing routes and optimizing them only to avoid 'activeNodes'.   */\n    rerouteOnSubsetOfNodes(activeNodes) {\n        this.RouteMultiEdgesAsBundles = false;\n        this.edges = Array.from(this.geomGraph.deepEdges).filter((e) => edgeNodesBelongToSet(e.edge, activeNodes));\n        const obstacles = ShapeCreator.GetShapes(this.geomGraph, this.edges);\n        this.rootShapes = obstacles.filter((s) => s.Parents == null || s.Parents.length === 0);\n        this.GetOrCreateRoot();\n        this.CalculateShapeToBoundaries(this.root);\n        this.calcLooseShapesToNodes();\n        this.CalculatePortsToShapes();\n        this.rerouteOnActiveNodes(activeNodes);\n        this.RemoveRoot();\n    }\n    calcLooseShapesToNodes() {\n        this.loosePolylinesToNodes = new Map();\n        if (!this.OverlapsDetected) {\n            for (const [nodeShape, cpl] of this.shapesToTightLooseCouples) {\n                this.loosePolylinesToNodes.set(cpl.LooseShape.BoundaryCurve, new Set([nodeShape.node.node]));\n            }\n            return;\n        }\n        const nodeTree = createRectangleNodeOnData(this.geomGraph.nodesBreadthFirst, (n) => n.boundingBox);\n        const looseTree = this.GetLooseHierarchy();\n        CrossRectangleNodes(looseTree, nodeTree, (poly, geomNode) => {\n            if (Curve.CurveIsInsideOther(geomNode.boundaryCurve, poly)) {\n                let polyNodes = this.loosePolylinesToNodes.get(poly);\n                for (const an of geomNode.getAncestors()) {\n                    if (an instanceof GeomGraph && an.parent == null)\n                        continue;\n                    if (an.boundaryCurve == null)\n                        continue;\n                    if (Curve.CurveIsInsideOther(an.boundaryCurve, poly))\n                        return; // we need to take an ancestor instead\n                }\n                if (polyNodes == null) {\n                    this.loosePolylinesToNodes.set(poly, (polyNodes = new Set()));\n                }\n                polyNodes.add(geomNode.node);\n            }\n        });\n    }\n    RouteOnRoot() {\n        initRandom(0);\n        this.CalculatePortsToShapes();\n        this.CalculatePortsToEnterableShapes();\n        this.CalculateShapeToBoundaries(this.root);\n        if (this.OverlapsDetected && !this.ContinueOnOverlaps) {\n            return;\n        }\n        this.BindLooseShapes();\n        this.SetLoosePolylinesForAnywherePorts();\n        this.CalculateVisibilityGraph();\n        this.RouteOnVisGraph();\n    }\n    CalculatePortsToEnterableShapes() {\n        this.portsToEnterableShapes = new Map();\n        for (const [port, shape] of this.portsToShapes) {\n            const portShapes = new Set();\n            if (!SplineRouter.EdgesAttachedToPortAvoidTheNode(port)) {\n                portShapes.add(shape);\n            }\n            this.portsToEnterableShapes.set(port, portShapes);\n        }\n        for (const rootShape of this.rootShapes) {\n            for (const sh of rootShape.Descendants()) {\n                for (const port of sh.Ports) {\n                    const enterableSet = this.portsToEnterableShapes.get(port);\n                    insertRange(enterableSet, Array.from(sh.Ancestors()).filter((s) => s.BoundaryCurve != null));\n                }\n            }\n        }\n    }\n    static EdgesAttachedToPortAvoidTheNode(port) {\n        return port instanceof CurvePort || port instanceof ClusterBoundaryPort;\n    }\n    SetLoosePolylinesForAnywherePorts() {\n        for (const [shape, cpl] of this.shapesToTightLooseCouples) {\n            for (const port of shape.Ports) {\n                const isHport = port instanceof HookUpAnywhereFromInsidePort;\n                if (isHport) {\n                    const aport = port;\n                    aport.LoosePolyline = cpl.LooseShape.BoundaryCurve;\n                }\n                if (port instanceof ClusterBoundaryPort) {\n                    const c = port;\n                    c.LoosePolyline = cpl.LooseShape.BoundaryCurve;\n                }\n            }\n        }\n    }\n    BindLooseShapes() {\n        this.looseRoot = new Shape();\n        for (const shape of this.root.Children) {\n            const looseShape = this.shapesToTightLooseCouples.get(shape).LooseShape;\n            this.BindLooseShapesUnderShape(shape);\n            this.looseRoot.AddChild(looseShape);\n        }\n    }\n    BindLooseShapesUnderShape(shape) {\n        const loose = this.shapesToTightLooseCouples.get(shape).LooseShape;\n        for (const child of shape.Children) {\n            const childLooseShape = this.shapesToTightLooseCouples.get(child).LooseShape;\n            loose.AddChild(childLooseShape);\n            this.BindLooseShapesUnderShape(child);\n        }\n    }\n    CalculateShapeToBoundaries(shape) {\n        this.ProgressStep();\n        if (shape.Children.length === 0) {\n            return;\n        }\n        for (const child of shape.Children) {\n            this.CalculateShapeToBoundaries(child);\n        }\n        let loosePaddingMax = Number.POSITIVE_INFINITY;\n        if (shape instanceof RelativeShape) {\n            const node = shape.node;\n            const padding = node.padding;\n            this.tightPadding = Math.min(this.tightPadding, 0.4 * padding);\n            loosePaddingMax = 0.4 * padding;\n        }\n        this.obstacleCalculator = new ShapeObstacleCalculator(shape, this.tightPadding, Math.min(this.AdjustedLoosePadding, loosePaddingMax), this.shapesToTightLooseCouples);\n        this.obstacleCalculator.Calculate(0.01);\n        this.OverlapsDetected || (this.OverlapsDetected = this.obstacleCalculator.OverlapsDetected);\n    }\n    get OverlapsDetected() {\n        return this._overlapsDetected;\n    }\n    set OverlapsDetected(value) {\n        this._overlapsDetected = value;\n    }\n    get AdjustedLoosePadding() {\n        return this.BundlingSettings == null ? this.LoosePadding : this.LoosePadding * BundleRouter.SuperLoosePaddingCoefficient;\n    }\n    GroupEdgesByPassport() {\n        const ret = new Array();\n        for (const edge of this.edges) {\n            const edgePassport = this.EdgePassport(edge); // todo : is ret.find() too slow?\n            let pair = ret.find((p) => setsAreEqual(p.passport, edgePassport));\n            if (!pair) {\n                pair = { passport: edgePassport, edges: [] };\n                ret.push(pair);\n            }\n            pair.edges.push(edge);\n        }\n        return ret;\n    }\n    RouteOnVisGraph() {\n        this.ancestorSets = SplineRouter.GetAncestorSetsMap(Array.from(this.root.Descendants()));\n        if (this.BundlingSettings == null) {\n            const edgeGroups = this.GroupEdgesByPassport();\n            for (let i = 0; i < edgeGroups.length; i++) {\n                const edgeGroup = edgeGroups[i];\n                const passport = edgeGroup.passport;\n                const obstacleShapes = this.GetObstaclesFromPassport(passport);\n                const interactiveEdgeRouter = this.CreateInteractiveEdgeRouter(Array.from(obstacleShapes));\n                this.RouteEdgesWithTheSamePassport(edgeGroup, interactiveEdgeRouter, obstacleShapes);\n            }\n        }\n        else {\n            this.RouteBundles();\n        }\n    }\n    rerouteOnActiveNodes(activeNodeSet) {\n        this.ancestorSets = SplineRouter.GetAncestorSetsMap(Array.from(this.root.Descendants()));\n        if (this.BundlingSettings == null) {\n            for (const edgeGroup of this.GroupEdgesByPassport()) {\n                const passport = edgeGroup.passport;\n                const obstacleShapes = this.GetObstaclesFromPassport(passport);\n                const filteredObstacleShapes = new Set();\n                for (const sh of obstacleShapes) {\n                    const lsh = this.LooseShapeOfOriginalShape(sh);\n                    for (const n of this.loosePolylinesToNodes.get(lsh.BoundaryCurve)) {\n                        if (activeNodeSet.has(n)) {\n                            filteredObstacleShapes.add(sh);\n                        }\n                    }\n                }\n                const interactiveEdgeRouter = this.CreateInteractiveEdgeRouter(Array.from(filteredObstacleShapes));\n                this.rerouteEdgesWithTheSamePassportActiveNodes(edgeGroup, interactiveEdgeRouter, filteredObstacleShapes, activeNodeSet);\n            }\n        }\n        else {\n            this.RouteBundles();\n        }\n    }\n    getDebugCurvesFromEdgesAndCdt(cdt) {\n        const ret = Array.from(this.geomGraph.deepEdges)\n            .map((e) => e.curve)\n            .filter((c) => c != null)\n            .filter((c) => c.count > 5)\n            .map((c) => DebugCurve.mkDebugCurveTWCI(200, 1, 'Red', c));\n        for (const s of cdt.PointsToSites.values()) {\n            for (const e of s.Edges) {\n                ret.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, e.constrained ? 'Blue' : 'Green', LineSegment.mkPP(e.lowerSite.point, e.upperSite.point)));\n            }\n        }\n        return ret;\n    }\n    RouteEdgesWithTheSamePassport(edgeGeometryGroup, interactiveEdgeRouter, obstacleShapes) {\n        const t = {\n            regularEdges: [],\n            multiEdges: [],\n        };\n        try {\n            const cdtOnLooseObstacles = this.getCdtFromPassport(obstacleShapes);\n            interactiveEdgeRouter.pathOptimizer.setCdt(cdtOnLooseObstacles);\n        }\n        catch (e) {\n            interactiveEdgeRouter.pathOptimizer.setCdt(null);\n        }\n        if (this.RouteMultiEdgesAsBundles) {\n            this.SplitOnRegularAndMultiedges(edgeGeometryGroup.edges, t);\n            if (t.regularEdges.length > 0) {\n                for (let i = 0; i < t.regularEdges.length; i++) {\n                    this.routeEdge(interactiveEdgeRouter, t.regularEdges[i]);\n                }\n            }\n            if (t.multiEdges != null) {\n                this.ScaleDownLooseHierarchy(interactiveEdgeRouter, obstacleShapes);\n                this.RouteMultiEdges(t.multiEdges, interactiveEdgeRouter, edgeGeometryGroup.passport);\n            }\n        }\n        else {\n            for (let i = 0; i < edgeGeometryGroup.edges.length; i++) {\n                this.routeEdge(interactiveEdgeRouter, edgeGeometryGroup.edges[i]);\n            }\n        }\n    }\n    /** edgeToPolys maps edges to their original polyline routes */\n    rerouteEdgesWithTheSamePassportActiveNodes(edgeGeometryGroup, interactiveEdgeRouter, obstacleShapes, activeNodes) {\n        const t = {\n            regularEdges: [],\n            multiEdges: [],\n        };\n        try {\n            const cdtOnLooseObstacles = this.getCdtFromPassport(obstacleShapes);\n            interactiveEdgeRouter.pathOptimizer.setCdt(cdtOnLooseObstacles);\n        }\n        catch (e) {\n            console.log(e);\n            interactiveEdgeRouter.pathOptimizer.setCdt(null);\n        }\n        if (this.RouteMultiEdgesAsBundles) {\n            this.SplitOnRegularAndMultiedges(edgeGeometryGroup.edges, t);\n            if (t.regularEdges.length > 0) {\n                for (let i = 0; i < t.regularEdges.length; i++) {\n                    const e = t.regularEdges[i];\n                    Assert.assert(edgeNodesBelongToSet(e.edge, activeNodes));\n                    this.rerouteEdge(interactiveEdgeRouter, e);\n                }\n            }\n            if (t.multiEdges != null) {\n                this.ScaleDownLooseHierarchy(interactiveEdgeRouter, obstacleShapes);\n                this.RouteMultiEdges(t.multiEdges, interactiveEdgeRouter, edgeGeometryGroup.passport);\n            }\n        }\n        else {\n            for (let i = 0; i < edgeGeometryGroup.edges.length; i++) {\n                const e = edgeGeometryGroup.edges[i];\n                if (edgeNodesBelongToSet(e.edge, activeNodes)) {\n                    this.rerouteEdge(interactiveEdgeRouter, e);\n                }\n            }\n        }\n    }\n    /** poly gives the polyline to reroute */\n    rerouteEdge(interactiveEdgeRouter, edge) {\n        try {\n            interactiveEdgeRouter.rerouteEdge(edge);\n            Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.sourcePort.Curve, edge.targetPort.Curve, edge.curve, false);\n        }\n        catch (e) {\n            console.log('failed');\n            // It is fine for reroute to fail\n            // Just do nothing in this case: the edge will remain unchanged.\n            // this happens when the polyline corresponding to the edge is crossing a loose polyline, passinge too close to a node.\n            // This might happen, for example, when the polyline was generated by from the Sugiyama layout.\n            // Consider in the future to try to fix the polyline in this case, TODO\n        }\n    }\n    getCdtFromPassport(passport) {\n        // we need a set here because a loose polyline could be the same for different shapes\n        // in the case of overlaps\n        const loosePolys = new Set();\n        const ports = [];\n        // we cannot rely on the bounding box of the graph because it is not updated, or might be too large - would create thin triangles\n        const bb = Rectangle.mkEmpty();\n        for (const shape of passport) {\n            const lp = this.LoosePolyOfOriginalShape(shape);\n            if (lp == null)\n                continue;\n            loosePolys.add(lp);\n            for (const port of shape.Ports) {\n                ports.push(port.Location);\n            }\n            bb.addRecSelf(lp.boundingBox);\n        }\n        bb.pad(Math.max(bb.diagonal / 4, 100));\n        const lps = Array.from(loosePolys);\n        lps.push(bb.perimeter()); // this will give some space for the edges to be routed near the graph border\n        const cdt = new Cdt(ports, lps, []);\n        cdt.run();\n        return cdt;\n    }\n    // if set to true routes multi edges as ordered bundles\n    get RouteMultiEdgesAsBundles() {\n        return this.routeMultiEdgesAsBundles;\n    }\n    set RouteMultiEdgesAsBundles(value) {\n        this.routeMultiEdgesAsBundles = value;\n    }\n    routeEdge(interactiveEdgeRouter, edge) {\n        const transparentShapes = this.makeTransparentShapesOfEdgeAndGetTheShapes(edge);\n        this.ProgressStep();\n        this.RouteEdgeInternal(edge, interactiveEdgeRouter);\n        SplineRouter.SetTransparency(transparentShapes, false);\n    }\n    ScaleDownLooseHierarchy(interactiveEdgeRouter, obstacleShapes) {\n        const loosePolys = new Array();\n        for (const obstacleShape of obstacleShapes) {\n            const tl = this.shapesToTightLooseCouples.get(obstacleShape);\n            loosePolys.push(InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tl.TightPolyline, tl.Distance / 1.1, // 1.1 is BundleRouter.SuperLoosePaddingCoefficient,\n            0));\n        }\n        interactiveEdgeRouter.LooseHierarchy = SplineRouter.CreateLooseObstacleHierarachy(loosePolys);\n        interactiveEdgeRouter.ClearActivePolygons();\n        interactiveEdgeRouter.AddActivePolygons(loosePolys.map((poly) => new Polygon(poly)));\n    }\n    RouteMultiEdges(multiEdges, interactiveEdgeRouter, parents) {\n        const nodeBoundaries = [];\n        for (const p of parents) {\n            for (const ch of p.Children)\n                nodeBoundaries.push(ch.BoundaryCurve);\n        }\n        const bs = new BundlingSettings();\n        //giving more importance to ink might produce weird routings with huge detours, maybe 0 is the best value here\n        bs.InkImportance = 0.00001;\n        bs.EdgeSeparation = this.MultiEdgesSeparation;\n        const mer = new MultiEdgeRouter(multiEdges, interactiveEdgeRouter, nodeBoundaries, bs, (a) => this.makeTransparentShapesOfEdgeAndGetTheShapes(a));\n        mer.run();\n    }\n    SplitOnRegularAndMultiedges(edges, t) {\n        const portLocationPairsToEdges = new PointPairMap();\n        for (const eg of edges) {\n            if (SplineRouter.IsEdgeToParent(eg)) {\n                t.regularEdges.push(eg);\n            }\n            else {\n                SplineRouter.RegisterInPortLocationsToEdges(eg, portLocationPairsToEdges);\n            }\n        }\n        t.multiEdges = null;\n        for (const edgeGroup of portLocationPairsToEdges.values()) {\n            if (edgeGroup.length === 1 || this.OverlapsDetected) {\n                addRange(t.regularEdges, edgeGroup);\n            }\n            else {\n                if (t.multiEdges == null) {\n                    t.multiEdges = new Array();\n                }\n                t.multiEdges.push(edgeGroup);\n            }\n        }\n    }\n    static RegisterInPortLocationsToEdges(eg, portLocationPairsToEdges) {\n        let list;\n        const pp = new PointPair(eg.sourcePort.Location, eg.targetPort.Location);\n        list = portLocationPairsToEdges.get(pp);\n        if (!list) {\n            list = new Array();\n            portLocationPairsToEdges.set(pp, list);\n        }\n        list.push(eg);\n    }\n    static IsEdgeToParent(e) {\n        return e.sourcePort instanceof HookUpAnywhereFromInsidePort || e.targetPort instanceof HookUpAnywhereFromInsidePort;\n    }\n    CreateInteractiveEdgeRouter(obstacleShapes) {\n        // we need to create a set here because one loose polyline can hold several original shapes\n        const loosePolys = new Set(obstacleShapes.map((sh) => this.shapesToTightLooseCouples.get(sh).LooseShape.BoundaryCurve));\n        const router = new InteractiveEdgeRouter(this.cancelToken);\n        router.pathOptimizer = new PathOptimizer();\n        router.ObstacleCalculator = new InteractiveObstacleCalculator(obstacleShapes.map((sh) => sh.BoundaryCurve), this.tightPadding, this.loosePadding, false);\n        router.VisibilityGraph = this.visGraph;\n        router.TightHierarchy = this.CreateTightObstacleHierarachy(obstacleShapes);\n        router.LooseHierarchy = SplineRouter.CreateLooseObstacleHierarachy(Array.from(loosePolys));\n        router.UseSpanner = true;\n        router.LookForRoundedVertices = true;\n        router.TightPadding = this.tightPadding;\n        router.LoosePadding = this.LoosePadding;\n        router.UseEdgeLengthMultiplier = this.UseEdgeLengthMultiplier;\n        router.UsePolylineEndShortcutting = this.UsePolylineEndShortcutting;\n        router.UseInnerPolylingShortcutting = this.UseInnerPolylingShortcutting;\n        router.AllowedShootingStraightLines = this.AllowedShootingStraightLines;\n        router.AddActivePolygons(Array.from(loosePolys).map((polyline) => new Polygon(polyline)));\n        return router;\n    }\n    GetObstaclesFromPassport(passport) {\n        if (passport.size === 0) {\n            return new Set(this.root.Children);\n        }\n        const commonAncestors = this.GetCommonAncestorsAbovePassport(passport);\n        const allAncestors = this.GetAllAncestors(passport);\n        const ret = new Set();\n        for (const p of passport) {\n            for (const child of p.Children) {\n                if (!allAncestors.has(child))\n                    ret.add(child);\n            }\n        }\n        const enqueued = uniteSets(new Set(passport), ret);\n        const queue = new Queue();\n        for (const shape of passport) {\n            if (!commonAncestors.has(shape))\n                queue.enqueue(shape);\n        }\n        while (queue.length > 0) {\n            const a = queue.dequeue();\n            for (const parent of a.Parents) {\n                for (const sibling of parent.Children) {\n                    if (!allAncestors.has(sibling)) {\n                        ret.add(sibling);\n                    }\n                }\n                if (!commonAncestors.has(parent) && !enqueued.has(parent)) {\n                    queue.enqueue(parent);\n                    enqueued.add(parent);\n                }\n            }\n        }\n        return ret;\n    }\n    GetAllAncestors(passport) {\n        if (passport.size === 0) {\n            return new Set();\n        }\n        let ret = new Set(passport);\n        for (const shape of passport) {\n            ret = uniteSets(ret, this.ancestorSets.get(shape));\n        }\n        return ret;\n    }\n    GetCommonAncestorsAbovePassport(passport) {\n        if (passport.size === 0) {\n            return new Set();\n        }\n        const en = Array.from(passport);\n        let ret = this.ancestorSets.get(en[0]);\n        for (let i = 1; i < en.length; i++) {\n            const shape = en[i];\n            ret = setIntersection(ret, this.ancestorSets.get(shape));\n        }\n        return ret;\n    }\n    RouteBundles() {\n        this.ScaleLooseShapesDown();\n        this.CalculateEdgeEnterablePolylines();\n        const looseHierarchy = this.GetLooseHierarchy();\n        const cdt = createCDTOnPolylineRectNode(looseHierarchy);\n        // CdtSweeper.ShowFront(cdt.GetTriangles(), null, null,this.visGraph.Edges.Select(e=>new LineSegment(e.SourcePoint,e.TargetPoint)));\n        const shortestPath = new SdShortestPath((a) => this.makeTransparentShapesOfEdgeAndGetTheShapes(a), cdt, this.FindCdtGates(cdt));\n        const bundleRouter = new BundleRouter(this.edges, shortestPath, this.visGraph, this.BundlingSettings, this.LoosePadding, this.GetTightHierarchy(), looseHierarchy, this.enterableLoose, this.enterableTight, (port) => this.LoosePolyOfOriginalShape(this.portsToShapes.get(port)));\n        bundleRouter.run();\n    }\n    CreateTheMapToParentLooseShapes(shape, loosePolylinesToLooseParentShapeMap) {\n        for (const childShape of shape.Children) {\n            const tightLooseCouple = this.shapesToTightLooseCouples.get(childShape);\n            const poly = tightLooseCouple.LooseShape.BoundaryCurve;\n            loosePolylinesToLooseParentShapeMap.set(poly, shape);\n            this.CreateTheMapToParentLooseShapes(childShape, loosePolylinesToLooseParentShapeMap);\n        }\n    }\n    FindCdtGates(cdt) {\n        const loosePolylinesToLooseParentShapeMap = new Map();\n        this.CreateTheMapToParentLooseShapes(this.root, loosePolylinesToLooseParentShapeMap);\n        // looking for Cdt edges connecting two siblings; only those we define as gates\n        const gates = new Set();\n        for (const cdtSite of cdt.PointsToSites.values()) {\n            for (const cdtEdge of cdtSite.Edges) {\n                if (cdtEdge.CwTriangle == null && cdtEdge.CcwTriangle == null) {\n                    continue;\n                }\n                const a = cdtSite.Owner;\n                const b = cdtEdge.lowerSite.Owner;\n                if (a === b) {\n                    continue;\n                }\n                const aParent = loosePolylinesToLooseParentShapeMap.get(a);\n                if (aParent) {\n                    const bParent = loosePolylinesToLooseParentShapeMap.get(b);\n                    if (aParent === bParent) {\n                        gates.add(cdtEdge);\n                    }\n                }\n            }\n        }\n        // CdtSweeper.ShowFront(cdt.GetTriangles(), null,\n        //                    gates.Select(g => new LineSegment(g.upperSite.Point, g.lowerSite.Point)), null);\n        return gates;\n    }\n    CalculateEdgeEnterablePolylines() {\n        this.enterableLoose = new Map();\n        this.enterableTight = new Map();\n        for (const edge of this.edges) {\n            const looseSet = new Set();\n            const tightSet = new Set();\n            this.GetEdgeEnterablePolylines(edge, looseSet, tightSet);\n            this.enterableLoose.set(edge, looseSet);\n            this.enterableTight.set(edge, tightSet);\n        }\n    }\n    GetEdgeEnterablePolylines(edge, looseEnterable, tightEnterable) {\n        const sourceShape = this.portsToShapes.get(edge.sourcePort);\n        const targetShape = this.portsToShapes.get(edge.targetPort);\n        if (sourceShape !== this.root) {\n            this.GetEnterablesForShape(sourceShape, looseEnterable, tightEnterable);\n        }\n        if (targetShape !== this.root) {\n            this.GetEnterablesForShape(targetShape, looseEnterable, tightEnterable);\n        }\n    }\n    GetEnterablesForShape(shape, looseEnterable, tightEnterable) {\n        for (const a of this.ancestorSets.get(shape)) {\n            const la = this.LoosePolyOfOriginalShape(a);\n            if (la) {\n                looseEnterable.add(la);\n            }\n            const ta = this.TightPolyOfOriginalShape(a);\n            if (ta) {\n                tightEnterable.add(ta);\n            }\n        }\n    }\n    GetTightHierarchy() {\n        return CreateRectNodeOnArrayOfRectNodes(Array.from(this.shapesToTightLooseCouples.values()).map((tl) => mkRectangleNode(tl.TightPolyline, tl.TightPolyline.boundingBox)));\n    }\n    GetLooseHierarchy() {\n        const loosePolylines = new Set();\n        for (const t of this.shapesToTightLooseCouples.values()) {\n            loosePolylines.add(t.LooseShape.BoundaryCurve);\n        }\n        return CreateRectNodeOnArrayOfRectNodes(Array.from(loosePolylines).map((p) => mkRectangleNode(p, p.boundingBox)));\n    }\n    ScaleLooseShapesDown() {\n        for (const [, tl] of this.shapesToTightLooseCouples) {\n            tl.LooseShape.BoundaryCurve = InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tl.TightPolyline, tl.Distance / BundleRouter.SuperLoosePaddingCoefficient, 0);\n        }\n    }\n    /**\n     * The set of shapes where the edge source and target ports shapes are citizens: the shapes who's interior the edge can cross\n     *   In the simple case it is the union of the target port shape parents and the sourceport shape parents.\n     *   When one end shape contains another, the passport is the set consisting of the end shape and all other shape parents.\n     */\n    EdgePassport(edge) {\n        const ret = new Set();\n        const sourceShape = this.portsToShapes.get(edge.sourcePort);\n        const targetShape = this.portsToShapes.get(edge.targetPort);\n        if (this.IsAncestor(sourceShape, targetShape)) {\n            insertRange(ret, targetShape.Parents);\n            ret.add(sourceShape);\n            return ret;\n        }\n        if (this.IsAncestor(targetShape, sourceShape)) {\n            insertRange(ret, sourceShape.Parents);\n            ret.add(targetShape);\n            return ret;\n        }\n        if (sourceShape !== this.looseRoot) {\n            insertRange(ret, sourceShape.Parents);\n        }\n        if (targetShape !== this.looseRoot) {\n            insertRange(ret, targetShape.Parents);\n        }\n        return ret;\n    }\n    *AllPorts() {\n        for (const edge of this.edges) {\n            yield edge.sourcePort;\n            yield edge.targetPort;\n        }\n    }\n    CalculatePortsToShapes() {\n        this.portsToShapes = new Map();\n        for (const shape of this.root.Descendants()) {\n            for (const port of shape.Ports) {\n                this.portsToShapes.set(port, shape);\n            }\n        }\n        // assign all orphan ports to the root\n        for (const port of this.AllPorts()) {\n            if (!this.portsToShapes.has(port)) {\n                this.root.Ports.add(port);\n                this.portsToShapes.set(port, this.root);\n            }\n        }\n    }\n    RouteEdgeInternal(edge, iRouter) {\n        const addedEdges = new Array();\n        if (!(edge.sourcePort instanceof HookUpAnywhereFromInsidePort)) {\n            addRange(addedEdges, this.AddVisibilityEdgesFromPort(edge.sourcePort));\n        }\n        if (!(edge.targetPort instanceof HookUpAnywhereFromInsidePort)) {\n            addRange(addedEdges, this.AddVisibilityEdgesFromPort(edge.targetPort));\n        }\n        const t = { smoothedPolyline: null };\n        if (!Point.closeDistEps(edge.sourcePort.Location, edge.targetPort.Location)) {\n            edge.curve = iRouter.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(edge.sourcePort, edge.targetPort, true, t);\n        }\n        else {\n            edge.curve = GeomEdge.RouteSelfEdge(edge.sourcePort.Curve, Math.max(this.LoosePadding * 2, edge.GetMaxArrowheadLength()), t);\n        }\n        edge.smoothedPolyline = null; // t.smoothedPolyline\n        if (edge.curve == null) {\n            throw new Error();\n        }\n        for (const visibilityEdge of addedEdges) {\n            VisibilityGraph.RemoveEdge(visibilityEdge);\n        }\n        Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.sourcePort.Curve, edge.targetPort.Curve, edge.curve, false);\n        //  SetTransparency(transparentShapes, false);\n    }\n    *AddVisibilityEdgesFromPort(port) {\n        let portShape;\n        let boundaryCouple;\n        if (port instanceof CurvePort ||\n            !(portShape = this.portsToShapes.get(port)) ||\n            !(boundaryCouple = this.shapesToTightLooseCouples.get(portShape))) {\n            return;\n        }\n        const portLoosePoly = boundaryCouple.LooseShape;\n        for (const point of portLoosePoly.BoundaryCurve) {\n            if (this.visGraph.FindEdgePP(port.Location, point) == null)\n                yield this.visGraph.AddEdgePP(port.Location, point);\n        }\n    }\n    makeTransparentShapesOfEdgeAndGetTheShapes(edge) {\n        // it is OK here to repeat a shape in the returned list\n        const sourceShape = this.portsToShapes.get(edge.sourcePort);\n        const targetShape = this.portsToShapes.get(edge.targetPort);\n        const transparentLooseShapes = new Array();\n        for (const shape of this.GetTransparentShapes(edge.sourcePort, edge.targetPort, sourceShape, targetShape)) {\n            if (shape != null) {\n                transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));\n            }\n        }\n        for (const shape of this.portsToEnterableShapes.get(edge.sourcePort)) {\n            transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));\n        }\n        for (const shape of this.portsToEnterableShapes.get(edge.targetPort)) {\n            transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));\n        }\n        SplineRouter.SetTransparency(transparentLooseShapes, true);\n        return transparentLooseShapes;\n    }\n    LooseShapeOfOriginalShape(s) {\n        if (s === this.root) {\n            return this.looseRoot;\n        }\n        return this.shapesToTightLooseCouples.get(s).LooseShape;\n    }\n    LoosePolyOfOriginalShape(s) {\n        return this.LooseShapeOfOriginalShape(s).BoundaryCurve;\n    }\n    TightPolyOfOriginalShape(s) {\n        if (s === this.root) {\n            return null;\n        }\n        return this.shapesToTightLooseCouples.get(s).TightPolyline;\n    }\n    //    static GetEdgeColor(e: VisibilityEdge, sourcePort: Port, targetPort: Port): string {\n    //  if (((sourcePort == null )\n    //    || (targetPort == null ))) {\n    //    return \"green\";\n    //  }\n    //  if ((closeDistEps(e.SourcePoint, sourcePort.Location)\n    //    || (closeDistEps(e.SourcePoint, targetPort.Location)\n    //      || (closeDistEps(e.TargetPoint, sourcePort.Location) || closeDistEps(e.TargetPoint, targetPort.Location))))) {\n    //    return \"lightgreen\";\n    //  }\n    //  return \"green\";\n    //  // TODO: Warning!!!, inline IF is not supported ?\n    //  ((e.IsPassable == null )\n    //    || e.IsPassable());\n    //  \"red\";\n    // }\n    *GetTransparentShapes(sourcePort, targetPort, sourceShape, targetShape) {\n        for (const s of this.ancestorSets.get(sourceShape)) {\n            yield s;\n        }\n        for (const s of this.ancestorSets.get(targetShape)) {\n            yield s;\n        }\n        if (!SplineRouter.EdgesAttachedToPortAvoidTheNode(sourcePort))\n            yield sourceShape;\n        if (!SplineRouter.EdgesAttachedToPortAvoidTheNode(targetPort))\n            yield targetShape;\n    }\n    static SetTransparency(shapes, v) {\n        for (const shape of shapes) {\n            shape.IsTransparent = v;\n        }\n    }\n    IsAncestor(possibleAncestor, possiblePredecessor) {\n        let ancestors;\n        return (possiblePredecessor != null && (ancestors = this.ancestorSets.get(possiblePredecessor)) != null && ancestors.has(possibleAncestor));\n    }\n    static CreateLooseObstacleHierarachy(loosePolys) {\n        return CreateRectNodeOnArrayOfRectNodes(loosePolys.map((poly) => mkRectangleNode(poly, poly.boundingBox)));\n    }\n    CreateTightObstacleHierarachy(obstacles) {\n        const tightPolys = obstacles.map((sh) => this.shapesToTightLooseCouples.get(sh).TightPolyline);\n        return CreateRectNodeOnArrayOfRectNodes(tightPolys.map((tightPoly) => mkRectangleNode(tightPoly, tightPoly.boundingBox)));\n    }\n    CalculateVisibilityGraph() {\n        const setOfPortLocations = this.LineSweeperPorts != null ? PointSet.mk(this.LineSweeperPorts) : new PointSet();\n        this.ProcessHookAnyWherePorts(setOfPortLocations);\n        this.portRTree = mkRTree(Array.from(setOfPortLocations.values()).map((p) => [Rectangle.rectangleOnPoint(p), p]));\n        this.visGraph = new VisibilityGraph();\n        this.FillVisibilityGraphUnderShape(this.root);\n        // debug start\n        //this.dumpSvg()\n        // throw new Error()\n    }\n    // dumpSvg() {\n    //  SplineRouter.ShowVisGraph(\n    //    './tmp/vg.svg',\n    //    this.visGraph,\n    //    Array.from(new Set<Polyline>(Array.from(this.shapesToTightLooseCouples.values()).map((tl) => <Polyline>tl.LooseShape.BoundaryCurve))),\n    //    Array.from(this.geomGraph.shallowNodes)\n    //      .map((n) => n.boundaryCurve)\n    //      .concat(Array.from(this.root.Descendants()).map((d) => d.BoundaryCurve)),\n    //    null,\n    //  )\n    // }\n    static ShowVisGraph(fileName, tmpVisGraph, obstacles, greenCurves = null, redCurves = null) {\n        const l = Array.from(tmpVisGraph.Edges).map((e) => DebugCurve.mkDebugCurveTWCI(100, 1, e.IsPassable != null && e.IsPassable() ? 'green' : 'black', LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));\n        if (obstacles != null) {\n            for (const p of obstacles) {\n                l.push(DebugCurve.mkDebugCurveTWCI(100, 0.3, 'brown', p));\n                for (const t of p) {\n                    l.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'green', CurveFactory.mkCircle(1, t)));\n                }\n            }\n        }\n        if (greenCurves != null) {\n            for (const p of greenCurves) {\n                l.push(DebugCurve.mkDebugCurveTWCI(100, 10, 'navy', p));\n            }\n        }\n        if (redCurves != null) {\n            for (const p of redCurves)\n                l.push(DebugCurve.mkDebugCurveTWCI(100, 10, 'red', p));\n        }\n        // SvgDebugWriter.dumpDebugCurves(fileName, l)\n    }\n    ProcessHookAnyWherePorts(setOfPortLocations) {\n        for (const edge of this.edges) {\n            if (!(edge.sourcePort instanceof HookUpAnywhereFromInsidePort || edge.sourcePort instanceof ClusterBoundaryPort)) {\n                setOfPortLocations.add(edge.sourcePort.Location);\n            }\n            if (!(edge.targetPort instanceof HookUpAnywhereFromInsidePort || edge.targetPort instanceof ClusterBoundaryPort)) {\n                setOfPortLocations.add(edge.targetPort.Location);\n            }\n        }\n    }\n    // this function might change the shape's loose polylines by inserting new points\n    FillVisibilityGraphUnderShape(shape) {\n        // going depth first\n        const children = shape.Children;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            this.FillVisibilityGraphUnderShape(child);\n        }\n        const tightLooseCouple = this.shapesToTightLooseCouples.get(shape);\n        const looseBoundary = tightLooseCouple ? tightLooseCouple.LooseShape.BoundaryCurve : null;\n        const looseShape = tightLooseCouple ? tightLooseCouple.LooseShape : this.looseRoot;\n        const obstacles = new Set(looseShape.Children.map((c) => c.BoundaryCurve));\n        const portLocations = this.RemoveInsidePortsAndSplitBoundaryIfNeeded(looseBoundary);\n        let tmpVisGraph = new VisibilityGraph();\n        let coneSpanner = ConeSpanner.mk([], tmpVisGraph, this.coneAngle, portLocations, looseBoundary);\n        coneSpanner.run();\n        //SplineRouter.ShowVisGraph('c:/tmp/vg' + this.debcount++ + '.svg', tmpVisGraph, Array.from(obstacles))\n        // now run the spanner again to create the correct visibility graph around the inner obstacles\n        tmpVisGraph = new VisibilityGraph();\n        coneSpanner = ConeSpanner.mk(Array.from(obstacles), tmpVisGraph, this.coneAngle, portLocations, looseBoundary);\n        coneSpanner.run();\n        // SplineRouter.ShowVisGraph('./tmp/splineRouter' + ++SplineRouter.debCount + '.svg', tmpVisGraph, Array.from(obstacles))\n        this.ProgressStep();\n        for (const edge of tmpVisGraph.Edges) {\n            this.TryToCreateNewEdgeAndSetIsPassable(edge, looseShape);\n        }\n        this.AddBoundaryEdgesToVisGraph(looseBoundary);\n        //            if (obstacles.Count > 0)\n        //                SplineRouter.ShowVisGraph(tmpVisGraph, obstacles, null, null);\n    }\n    // #if TEST_MSAGL\n    //     static internal void ShowVisGraph(VisibilityGraph tmpVisGraph, Iterable<Polyline> obstacles, Iterable<ICurve> greenCurves, Iterable<ICurve> redCurves) {\n    //       var l = new Array<DebugCurve>(tmpVisGraph.Edges.Select(e => new DebugCurve(100, 1,\n    //           e.IsPassable != null && e.IsPassable() ? \"green\" : \"black\"\n    //           , new LineSegment(e.SourcePoint, e.TargetPoint))));\n    //       if (obstacles != null)\n    //         l.AddRange(obstacles.Select(p => new DebugCurve(100, 1, \"brown\", p)));\n    //       if (greenCurves != null)\n    //         l.AddRange(greenCurves.Select(p => new DebugCurve(100, 10, \"navy\", p)));\n    //       if (redCurves != null)\n    //         l.AddRange(redCurves.Select(p => new DebugCurve(100, 10, \"red\", p)));\n    //       LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n    //     }\n    // #endif\n    TryToCreateNewEdgeAndSetIsPassable(edge, looseShape) {\n        let e = this.visGraph.FindEdgePP(edge.SourcePoint, edge.TargetPoint);\n        if (e != null) {\n            return;\n        }\n        e = this.visGraph.AddEdgePP(edge.SourcePoint, edge.TargetPoint);\n        if (looseShape != null)\n            e.IsPassable = () => looseShape.IsTransparent;\n    }\n    AddBoundaryEdgesToVisGraph(boundary) {\n        if (boundary == null) {\n            return;\n        }\n        let pn;\n        for (let p = boundary.startPoint; true; p = pn) {\n            pn = p.nextOnPolyline;\n            this.visGraph.AddEdgePP(p.point, pn.point);\n            if (pn === boundary.startPoint) {\n                break;\n            }\n        }\n    }\n    /** this run will split the polyline enough to route later from the inner ports */\n    RemoveInsidePortsAndSplitBoundaryIfNeeded(boundary) {\n        const ret = new PointSet();\n        if (boundary == null) {\n            for (const point of this.portRTree.GetAllLeaves()) {\n                ret.add(point);\n            }\n            this.portRTree.clear();\n            return ret;\n        }\n        const boundaryBox = boundary.boundingBox;\n        const portLocationsInQuestion = this.portRTree.GetAllIntersecting(boundaryBox);\n        for (const point of portLocationsInQuestion) {\n            switch (Curve.PointRelativeToCurveLocation(point, boundary)) {\n                case PointLocation.Inside:\n                    ret.add(point);\n                    this.portRTree.Remove(Rectangle.rectangleOnPoint(point), point);\n                    break;\n                case PointLocation.Boundary:\n                    this.portRTree.Remove(Rectangle.rectangleOnPoint(point), point);\n                    const polylinePoint = SplineRouter.FindPointOnPolylineToInsertAfter(boundary, point);\n                    if (polylinePoint != null) {\n                        LineSweeper.InsertPointIntoPolylineAfter(boundary, polylinePoint, point);\n                    }\n                    else {\n                        throw new Error();\n                    }\n                    break;\n            }\n        }\n        return ret;\n    }\n    static FindPointOnPolylineToInsertAfter(boundary, point) {\n        for (let p = boundary.startPoint;;) {\n            const pn = p.nextOnPolyline;\n            if (Point.closeDistEps(point, p.point) || Point.closeDistEps(point, pn.point)) {\n                return null;\n            }\n            // the point is already inside\n            const dist = Point.distToLineSegment(point, p.point, pn.point).dist;\n            if (closeDistEps(dist, 0)) {\n                return p;\n            }\n            p = pn;\n            if (p === boundary.startPoint) {\n                throw new Error();\n            }\n        }\n    }\n    // creates a root; a shape with BoundaryCurve set to null\n    GetOrCreateRoot() {\n        if (this.rootShapes.length === 1) {\n            const r = this.rootShapes[0];\n            if (r.BoundaryCurve == null) {\n                this.root = r;\n                return;\n            }\n        }\n        this.rootWasCreated = true;\n        this.root = new Shape(null);\n        for (const rootShape of this.rootShapes) {\n            this.root.AddChild(rootShape);\n        }\n    }\n    RemoveRoot() {\n        if (!this.rootWasCreated)\n            return;\n        for (const rootShape of this.rootShapes) {\n            rootShape.RemoveParent(this.root);\n        }\n        this.root = null;\n        this.rootWasCreated = false;\n    }\n    // #if TEST_MSAGL\n    //     // ReSharper disable UnusedMember.Local\n    //     static void Show(\n    //         Iterable<GeomEdge> edgeGeometries, Iterable<Shape> listOfShapes) {\n    //       // ReSharper restore UnusedMember.Local\n    //       var r = new Random(1);\n    //       LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(\n    //           listOfShapes.Select(s => s.BoundaryCurve).Select(\n    //               c => new DebugCurve(50, 1, DebugCurve.Colors[r.Next(DebugCurve.Colors.Length - 1)], c)).Concat(\n    //                   edgeGeometries.Select(e => new DebugCurve(100, 1, \"red\", e.Curve))));\n    //     }\n    // #endif\n    static GetAncestorSetsMap(shapes) {\n        const ancSets = new Map();\n        for (const child of shapes.filter((child) => !ancSets.has(child))) {\n            ancSets.set(child, SplineRouter.GetAncestorSet(child, ancSets));\n        }\n        return ancSets;\n    }\n    static GetAncestorSet(child, ancSets) {\n        const ret = new Set(child.Parents);\n        for (const parent of child.Parents) {\n            let addition = ancSets.get(parent);\n            if (!addition) {\n                ancSets.set(parent, (addition = SplineRouter.GetAncestorSet(parent, ancSets)));\n            }\n            for (const t of addition)\n                ret.add(t);\n        }\n        return ret;\n    }\n    static CreatePortsIfNeeded(edges) {\n        for (const edge of edges) {\n            if (edge.sourcePort == null) {\n                const ed = edge;\n                new RelativeFloatingPort(() => ed.source.boundaryCurve, () => ed.source.center, new Point(0, 0));\n            }\n            if (edge.targetPort == null) {\n                const ed = edge;\n                new RelativeFloatingPort(() => ed.target.boundaryCurve, () => ed.target.center, new Point(0, 0));\n            }\n        }\n    }\n}\nexport function routeSplines(gg, edgesToRoute, cancelToken) {\n    const ers = getEdgeRoutingSettingsFromAncestorsOrDefault(gg);\n    const sr = new SplineRouter(gg, edgesToRoute, ers.Padding, ers.PolylinePadding, ers.coneAngle, ers.bundlingSettings, cancelToken);\n    sr.run();\n}\n//# sourceMappingURL=splineRouter.js.map","import { Point, parameterSpan } from '../../..';\nimport { TriangleOrientation } from '../../../math/geometry/point';\nexport class BundleBase {\n    isCorrectlyOrienected() {\n        const orientation = Point.getTriangleOrientation(this.Curve.boundingBox.center, this.Curve.value(this.parEnd), this.Curve.value(this.parStart));\n        return orientation !== TriangleOrientation.Counterclockwise;\n    }\n    get Count() {\n        return this.points.length;\n    }\n    constructor(count, boundaryCurve, position, belongsToRealNode) {\n        this.BelongsToRealNode = belongsToRealNode;\n        this.Curve = boundaryCurve;\n        this.Position = position;\n        this.points = new Array(count);\n        this.tangents = new Array(count);\n        this.OrientedHubSegments = new Array(count);\n    }\n    get CurveCenter() {\n        return this.Curve.boundingBox.center;\n    }\n    get OppositeBase() {\n        return this.OutgoingBundleInfo != null ? this.OutgoingBundleInfo.TargetBase : this.IncomingBundleInfo.SourceBase;\n    }\n    get length() {\n        return this.points.length;\n    }\n    get Points() {\n        return this.points;\n    }\n    get Tangents() {\n        return this.tangents;\n    }\n    get InitialMidParameter() {\n        return this.initialMidParameter;\n    }\n    set InitialMidParameter(value) {\n        this.initialMidParameter = value;\n        this.InitialMidPoint = this.Curve.value(value);\n    }\n    /**\n     * corresponds to the left point of the base: if looking from the center of\n     * this.Curve.boundingBox.center\n     */\n    get ParStart() {\n        return this.parStart;\n    }\n    set ParStart(value) {\n        this.parStart = value;\n        this.StartPoint = this.Curve.value(this.parStart);\n    }\n    /**\n     * corresponds to the right point of the base: if looking from the center of\n     * this.Curve.boundingBox.center */\n    get ParEnd() {\n        return this.parEnd;\n    }\n    set ParEnd(value) {\n        this.parEnd = value;\n        this.EndPoint = this.Curve.value(this.parEnd);\n    }\n    get ParMid() {\n        return (this.parStart + this.parEnd) / 2;\n    }\n    get MidPoint() {\n        return Point.middle(this.StartPoint, this.EndPoint);\n    }\n    get Span() {\n        return this.SpanBetweenTwoParameters(this.parStart, this.parEnd);\n    }\n    SpanBetweenTwoParameters(start, end) {\n        return start <= end ? end - start : end - start + parameterSpan(this.Curve);\n    }\n    RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange) {\n        if (rotationOfSourceLeftPoint === 0) {\n            return this.EndPoint;\n        }\n        return this.RotatePoint(rotationOfSourceLeftPoint, this.parEnd, parameterChange);\n    }\n    RotateRigthPoint(rotationOfSourceRightPoint, parameterChange) {\n        if (rotationOfSourceRightPoint === 0) {\n            return this.StartPoint;\n        }\n        return this.RotatePoint(rotationOfSourceRightPoint, this.parStart, parameterChange);\n    }\n    RotatePoint(rotation, t, parameterChange) {\n        const change = parameterSpan(this.Curve) * parameterChange;\n        t += rotation * change;\n        t = this.AdjustParam(t);\n        return this.Curve.value(t);\n    }\n    AdjustParam(t) {\n        if (t > this.Curve.parEnd)\n            t = this.Curve.parStart + (t - this.Curve.parEnd);\n        else if (t < this.Curve.parStart)\n            t = this.Curve.parEnd - (this.Curve.parStart - t);\n        return t;\n    }\n    RotateBy(rotationOfRightPoint, rotationOfLeftPoint, parameterChange) {\n        const change = parameterSpan(this.Curve) * parameterChange;\n        if (rotationOfRightPoint !== 0) {\n            this.ParStart = this.AdjustParam(this.ParStart + rotationOfRightPoint * change);\n        }\n        if (rotationOfLeftPoint !== 0) {\n            this.ParEnd = this.AdjustParam(this.ParEnd + rotationOfLeftPoint * change);\n        }\n    }\n    RelativeOrderOfBasesIsPreserved(rotationOfRightPoint, rotationOfLeftPoint, parameterChange) {\n        const change = parameterSpan(this.Curve) * parameterChange;\n        //we do not swap parRight and parLeft\n        const rnew = this.parStart + rotationOfRightPoint * change;\n        const lnew = this.parStart < this.parEnd\n            ? this.parEnd + rotationOfLeftPoint * change\n            : this.parEnd + parameterSpan(this.Curve) + rotationOfLeftPoint * change;\n        if (rnew > lnew)\n            return false;\n        //span could not be greater than pi\n        if (this.SpanBetweenTwoParameters(rnew, lnew) > parameterSpan(this.Curve) / 2.0)\n            return false;\n        //the base is the only base in the hub\n        if (this.Prev == null)\n            return true;\n        //distance between mid points is larger than parameterChange => we can't change the order\n        if (this.SpanBetweenTwoParameters(this.Prev.ParMid, this.ParMid) > change &&\n            this.SpanBetweenTwoParameters(this.ParMid, this.Next.ParMid) > change)\n            return true;\n        const rSoP = this.RotateLeftPoint(rotationOfLeftPoint, parameterChange);\n        const lSoP = this.RotateRigthPoint(rotationOfRightPoint, parameterChange);\n        const newMidPoint = Point.middle(rSoP, lSoP);\n        const curMidPoint = this.MidPoint;\n        //check Prev\n        if (Point.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, curMidPoint) !=\n            Point.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, newMidPoint))\n            return false;\n        //Next\n        if (Point.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, curMidPoint) !=\n            Point.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, newMidPoint))\n            return false;\n        return true;\n    }\n}\n//# sourceMappingURL=BundleBase.js.map","import { Point } from '../../../math/geometry/point';\nimport { Curve, PointLocation, LineSegment, GeomConstants, parameterSpan } from '../../../math/geometry';\nimport { Ellipse } from '../../../math/geometry/ellipse';\nimport { closeDistEps } from '../../../utils/compare';\nimport { addToMapOfArrays } from '../../../utils/setOperations';\nimport { BundleBase } from './BundleBase';\nimport { BundleInfo } from './BundleInfo';\nimport { getOrientationOf3Vectors } from './MetroGraphData';\nimport { OrientedHubSegment } from './OrientedHubSegment';\nexport class BundleBasesCalculator {\n    constructor(metroOrdering, metroGraphData, bundlingSettings) {\n        this.fixedBundles = new Set();\n        // the cooling scheme follows Yifan Hu, Efficient and high quality force-directed graph drawing\n        this.stepsWithProgress = 0;\n        this.metroOrdering = metroOrdering;\n        this.metroGraphData = metroGraphData;\n        this.bundlingSettings = bundlingSettings;\n    }\n    Run() {\n        // HubDebugger.ShowHubs(metroGraphData, bundlingSettings, true);\n        // HubDebugger.ShowHubs(metroGraphData, bundlingSettings);\n        this.AllocateBundleBases();\n        this.SetBasesRightLeftParamsToTheMiddles();\n        if (this.bundlingSettings.KeepOverlaps) {\n            this.UpdateSourceAndTargetBases();\n            this.CreateOrientedSegs();\n        }\n        else {\n            this.SetRightLeftParamsFeasiblySymmetrically();\n            // EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);\n            // these bases can be too wide and overlap each other, so we need to adjust them\n            this.AdjustStartEndParamsToAvoidBaseOverlaps();\n            this.UpdateSourceAndTargetBases();\n            // EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);\n            this.CreateOrientedSegs();\n            // EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);\n            // optimization: moving bases to reduce cost\n            // TimeMeasurer.DebugOutput(\"Initial cost of bundle bases: \" + Cost());\n            if (this.bundlingSettings.RotateBundles)\n                this.RotateBundlesToDiminishCost();\n            // EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);\n            this.AdjustStartEndParamsToAvoidBaseOverlaps();\n            this.UpdateSourceAndTargetBases();\n        }\n        // TimeMeasurer.DebugOutput(\"Optimized cost of bundle bases: \" + Cost());\n        //            EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);\n    }\n    AllocateBundleBases() {\n        this.externalBases = new Map();\n        this.internalBases = new Map();\n        this.Bundles = new Array();\n        for (const station of this.metroGraphData.Stations) {\n            if (station.BoundaryCurve == null)\n                station.BoundaryCurve = Ellipse.mkCircle(station.Radius, station.Position);\n        }\n        for (const station of this.metroGraphData.Stations) {\n            for (const neighbor of station.Neighbors) {\n                if (station.SerialNumber < neighbor.SerialNumber) {\n                    const bb = new BundleBase(this.metroGraphData.RealEdgeCount(station, neighbor), station.BoundaryCurve, station.Position, station.IsReal);\n                    station.BundleBases.set(neighbor, bb);\n                    const bb2 = new BundleBase(this.metroGraphData.RealEdgeCount(station, neighbor), neighbor.BoundaryCurve, neighbor.Position, neighbor.IsReal);\n                    neighbor.BundleBases.set(station, bb2);\n                    if (Curve.PointRelativeToCurveLocation(neighbor.Position, station.BoundaryCurve) !== PointLocation.Outside) {\n                        bb.IsParent = true;\n                        addToMapOfArrays(this.internalBases, station, bb);\n                        addToMapOfArrays(this.externalBases, neighbor, bb2);\n                    }\n                    else if (Curve.PointRelativeToCurveLocation(station.Position, neighbor.BoundaryCurve) !== PointLocation.Outside) {\n                        bb2.IsParent = true;\n                        addToMapOfArrays(this.externalBases, station, bb);\n                        addToMapOfArrays(this.internalBases, neighbor, bb2);\n                    }\n                    else {\n                        addToMapOfArrays(this.externalBases, station, bb);\n                        addToMapOfArrays(this.externalBases, neighbor, bb2);\n                    }\n                    const obstaclesToIgnore = this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(station, neighbor);\n                    const bundle = new BundleInfo(bb, bb2, obstaclesToIgnore, Array.from(this.metroOrdering.GetOrder(station, neighbor)).map((l) => l.Width / 2));\n                    bb.OutgoingBundleInfo = bb2.IncomingBundleInfo = bundle;\n                    this.Bundles.push(bundle);\n                }\n            }\n        }\n        //neighbors\n        this.SetBundleBaseNeighbors();\n    }\n    SetBundleBaseNeighbors() {\n        for (const c of this.externalBases.keys()) {\n            const list = this.externalBases.get(c);\n            this.SortBundlesCounterClockwise(list);\n            //set left\n            this.SetLeftRightBases(list);\n        }\n        for (const c of this.internalBases.keys()) {\n            const list = this.internalBases.get(c);\n            this.SortBundlesCounterClockwise(list);\n            //set left\n            this.SetLeftRightBases(list);\n        }\n    }\n    SortBundlesCounterClockwise(list) {\n        if (list.length > 2) {\n            const pivot = list[0].OppositeBase.Position;\n            const center = list[0].CurveCenter;\n            list.sort((u, v) => {\n                return getOrientationOf3Vectors(pivot.sub(center), u.OppositeBase.Position.sub(center), v.OppositeBase.Position.sub(center));\n            });\n        }\n    }\n    SetLeftRightBases(bases) {\n        const count = bases.length;\n        if (count <= 1) {\n            return;\n        }\n        for (let i = 0; i < count; i++) {\n            bases[i].Prev = bases[(i - 1 + count) % count];\n            bases[i].Next = bases[(i + 1) % count];\n        }\n    }\n    CreateOrientedSegs() {\n        for (const metroline of this.metroGraphData.Metrolines) {\n            this.CreateOrientedSegsOnLine(metroline);\n        }\n    }\n    CreateOrientedSegsOnLine(line) {\n        for (let polyPoint = line.Polyline.startPoint.next; polyPoint.next != null; polyPoint = polyPoint.next) {\n            this.CreateOrientedSegsOnLineVertex(line, polyPoint);\n        }\n    }\n    CreateOrientedSegsOnLineVertex(line, polyPoint) {\n        const u = this.metroGraphData.PointToStations.get(polyPoint.prev.point);\n        const v = this.metroGraphData.PointToStations.get(polyPoint.point);\n        const w = this.metroGraphData.PointToStations.get(polyPoint.next.point);\n        const h0 = v.BundleBases.get(u);\n        const h1 = v.BundleBases.get(w);\n        const j0 = this.metroOrdering.GetLineIndexInOrder(u, v, line);\n        const j1 = this.metroOrdering.GetLineIndexInOrder(w, v, line);\n        const or0 = (h0.OrientedHubSegments[j0] = new OrientedHubSegment(null, false, j0, h0));\n        const or1 = (h1.OrientedHubSegments[j1] = new OrientedHubSegment(null, true, j1, h1));\n        or1.Other = or0;\n        or0.Other = or1;\n    }\n    UpdateSourceAndTargetBases() {\n        for (const bundleInfo of this.Bundles) {\n            bundleInfo.UpdateSourceAndTargetBases(true, true);\n        }\n    }\n    SetBasesRightLeftParamsToTheMiddles() {\n        for (const bundle of this.Bundles) {\n            const sbase = bundle.SourceBase;\n            const tbase = bundle.TargetBase;\n            sbase.ParEnd = sbase.ParStart = this.GetBaseMiddleParamInDirection(sbase, sbase.Position, tbase.Position);\n            tbase.ParEnd = tbase.ParStart = this.GetBaseMiddleParamInDirection(tbase, tbase.Position, sbase.Position);\n        }\n    }\n    GetBaseMiddleParamInDirection(targetBase, sPos, neighbPos) {\n        const curve = targetBase.Curve;\n        const isCircle = curve instanceof Ellipse;\n        if (isCircle) {\n            const circle = curve;\n            if (circle.isArc()) {\n                return Point.angle(circle.aAxis, neighbPos.sub(sPos));\n            }\n        }\n        const intersections = Curve.getAllIntersections(curve, LineSegment.mkPP(sPos, neighbPos), true);\n        for (const intersectionInfo of intersections) {\n            const xP = intersectionInfo.x;\n            if (xP.sub(sPos).dot(xP.sub(neighbPos)) <= 0) {\n                return intersectionInfo.par0;\n            }\n        }\n        // SvgDebugWriter.dumpDebugCurves('./tmp/baseMiddle.svg', [\n        //  DebugCurve.mkDebugCurveTWCI(100, 1, 'Red', curve),\n        //  DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', LineSegment.mkPP(sPos, neighbPos)),\n        // ])\n        throw new Error();\n    }\n    SetRightLeftParamsFeasiblySymmetrically() {\n        for (const bundle of this.Bundles) {\n            bundle.SetParamsFeasiblySymmetrically(this.metroGraphData.TightTree);\n        }\n    }\n    AdjustStartEndParamsToAvoidBaseOverlaps() {\n        for (const c of this.externalBases.values())\n            this.AdjustCurrentBundleWidthsOnCurve(c);\n        for (const c of this.internalBases.values())\n            this.AdjustCurrentBundleWidthsOnCurve(c);\n    }\n    AdjustCurrentBundleWidthsOnCurve(bases) {\n        const count = bases.length;\n        if (count <= 1)\n            return;\n        for (let i = 0; i < count; i++) {\n            const rBase = bases[i];\n            const lBase = rBase.Next;\n            this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(rBase, lBase);\n            // Assert.assert(rBase.isCorrectlyOrienected() && lBase.isCorrectlyOrienected())\n        }\n    }\n    ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(rBase, lBase) {\n        const interval = intersectBases(rBase, lBase);\n        if (interval == null)\n            return;\n        if (closeDistEps(interval.start, interval.end))\n            return;\n        const rM = interval.rbaseMiddle;\n        const lM = interval.lbaseMiddle;\n        if (rM < lM) {\n            //swap\n            const t = rBase;\n            rBase = lBase;\n            lBase = t;\n        }\n        const rBaseSpan = rBase.Span;\n        const lBaseSpan = lBase.Span;\n        const x = (interval.end * rBaseSpan + interval.start * lBaseSpan) / (lBaseSpan + rBaseSpan);\n        rBase.ParStart = rBase.AdjustParam(x + GeomConstants.distanceEpsilon);\n        lBase.ParEnd = lBase.AdjustParam(x - GeomConstants.distanceEpsilon);\n        // Assert.assert(intersectBases(rBase, lBase) == null )\n    }\n    // find a cut point for 2 segments\n    RegularCut(l1, r1, l2, r2, span1, span2) {\n        let cutParam = (span1 * r2 + span2 * l1) / (span1 + span2);\n        const mn = Math.min(r1, r2);\n        const mx = Math.max(l1, l2);\n        // //Assert.assert((lessOrEqual(mx, cutParam) && ApproximateComparer.LessOrEqual(cutParam, mn)));\n        if (cutParam < mx) {\n            cutParam = mx;\n        }\n        if (cutParam > mn) {\n            cutParam = mn;\n        }\n        return cutParam;\n    }\n    RotateBundlesToDiminishCost() {\n        let parameterChange = BundleBasesCalculator.MaxParameterChange;\n        const t = { cost: this.Cost() };\n        let iteration = 0;\n        // HubDebugger.ShowHubs(metroGraphData, bundlingSettings, true);\n        while (iteration++ < BundleBasesCalculator.MaxIterations) {\n            const oldCost = t.cost;\n            this.RotateBundlesToDiminishCostOneIteration(parameterChange, t);\n            parameterChange = this.UpdateParameterChange(parameterChange, oldCost, t.cost);\n            if (parameterChange < BundleBasesCalculator.MinParameterChange) {\n                break;\n            }\n        }\n        // TimeMeasurer.DebugOutput(\"bases optimization completed after \" + iteration + \" iterations (cost=\" + cost + \")\");\n    }\n    UpdateParameterChange(step, oldEnergy, newEnergy) {\n        // cooling factor\n        const T = 0.8;\n        if (newEnergy + 1 < oldEnergy) {\n            this.stepsWithProgress++;\n            if (this.stepsWithProgress >= 5) {\n                this.stepsWithProgress = 0;\n                // step = Math.Min(MaxParameterChange, step / T);\n                this.fixedBundles.clear();\n            }\n        }\n        else {\n            this.stepsWithProgress = 0;\n            step *= T;\n            this.fixedBundles.clear();\n        }\n        return step;\n    }\n    RotateBundlesToDiminishCostOneIteration(parameterChange, t) {\n        let progress = false;\n        for (const bundleInfo of this.Bundles) {\n            if (this.fixedBundles.has(bundleInfo))\n                continue;\n            if (this.OptimizeBundle(bundleInfo, parameterChange, t)) {\n                progress = true;\n                /*bool isClusterS = bundleInfo.SourceBase.CurveCenter !== bundleInfo.SourceBase.Position;\n                            bool isClusterT = bundleInfo.TargetBase.CurveCenter !== bundleInfo.TargetBase.Position;\n                            while ((isClusterS || isClusterT) && OptimizeBundle(bundleInfo, parameterChange, ref cost)) { }*/\n            }\n            else\n                this.fixedBundles.add(bundleInfo);\n        }\n        return progress;\n    }\n    OptimizeBundle(bundleInfo, parameterChange, t) {\n        const bundleCost = this.CostBi(bundleInfo);\n        if (bundleCost < BundleBasesCalculator.CostThreshold) {\n            return false;\n        }\n        // choose the best step\n        let bestDelta = 0;\n        let bestJ = -1;\n        let bestI = -1;\n        for (let i = 0; i < BundleBasesCalculator.Deltas.length - 1; i++) {\n            let delta = this.DeltaWithChangedAngles(BundleBasesCalculator.Deltas[i][0], BundleBasesCalculator.Deltas[i][1], 0, 0, bundleInfo, bundleCost, parameterChange);\n            if (delta > BundleBasesCalculator.CostDeltaThreshold && delta > bestDelta) {\n                bestI = i;\n                bestJ = BundleBasesCalculator.Deltas.length - 1;\n                bestDelta = delta;\n            }\n            delta = this.DeltaWithChangedAngles(0, 0, BundleBasesCalculator.Deltas[i][0], BundleBasesCalculator.Deltas[i][1], bundleInfo, bundleCost, parameterChange);\n            if (delta > BundleBasesCalculator.CostDeltaThreshold && delta > bestDelta) {\n                bestI = BundleBasesCalculator.Deltas.length - 1;\n                bestJ = i;\n                bestDelta = delta;\n            }\n        }\n        if (bestDelta < BundleBasesCalculator.CostDeltaThreshold) {\n            return false;\n        }\n        t.cost -= bestDelta;\n        bundleInfo.RotateBy(BundleBasesCalculator.Deltas[bestI][0], BundleBasesCalculator.Deltas[bestI][1], BundleBasesCalculator.Deltas[bestJ][0], BundleBasesCalculator.Deltas[bestJ][1], parameterChange);\n        return true;\n    }\n    DeltaWithChangedAngles(rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, bundleInfo, bundleCost, parameterChange) {\n        if (!bundleInfo.RotationIsLegal(rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, parameterChange)) {\n            return 0;\n        }\n        bundleInfo.RotateBy(rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, parameterChange);\n        const newCost = this.CostBN(bundleInfo, bundleCost);\n        // restoring\n        bundleInfo.RotateBy(rotationOfSourceRigthPoint * -1, rotationOfSourceLeftPoint * -1, rotationOfTargetRigthPoint * -1, rotationOfTargetLeftPoint * -1, parameterChange);\n        return bundleCost - newCost;\n    }\n    CostBi(bundleInfo) {\n        return (BundleBasesCalculator.SeparationCoeff * this.SeparationCost(bundleInfo) +\n            (BundleBasesCalculator.SqueezeCoeff * this.SqueezeCost(bundleInfo) +\n                (BundleBasesCalculator.AssymetryCoeff * this.AssymetryCost(bundleInfo) +\n                    BundleBasesCalculator.CenterCoeff * this.CenterCostBi(bundleInfo))));\n    }\n    // this is an accelerated version of the above function (calculate cost partly)\n    CostBN(bundleInfo, limit) {\n        let cost = 0;\n        cost = cost + BundleBasesCalculator.CenterCoeff * this.CenterCostBi(bundleInfo);\n        if (cost > limit) {\n            return cost;\n        }\n        cost = cost + BundleBasesCalculator.SeparationCoeff * this.SeparationCost(bundleInfo);\n        if (cost > limit) {\n            return cost;\n        }\n        cost = cost + BundleBasesCalculator.SqueezeCoeff * this.SqueezeCost(bundleInfo);\n        if (cost > limit) {\n            return cost;\n        }\n        cost = cost + BundleBasesCalculator.AssymetryCoeff * this.AssymetryCost(bundleInfo);\n        return cost;\n    }\n    SqueezeCost(bundleInfo) {\n        const middleLineDir = bundleInfo.TargetBase.MidPoint.sub(bundleInfo.SourceBase.MidPoint).normalize();\n        const perp = middleLineDir.rotate90Ccw();\n        const projecton0 = Math.abs(bundleInfo.SourceBase.StartPoint.sub(bundleInfo.SourceBase.EndPoint).dot(perp));\n        const projecton1 = Math.abs(bundleInfo.TargetBase.StartPoint.sub(bundleInfo.TargetBase.EndPoint).dot(perp));\n        const del0 = Math.abs(bundleInfo.TotalRequiredWidth - projecton0) / bundleInfo.TotalRequiredWidth;\n        const del1 = Math.abs(bundleInfo.TotalRequiredWidth - projecton1) / bundleInfo.TotalRequiredWidth;\n        const del = Math.abs(projecton0 - projecton1) / bundleInfo.TotalRequiredWidth;\n        const cost = Math.exp(del0 * 10) - 1 + (Math.exp(del1 * 10) - 1);\n        return cost + del;\n    }\n    CenterCostBi(bundleInfo) {\n        if (!bundleInfo.SourceBase.BelongsToRealNode && !bundleInfo.TargetBase.BelongsToRealNode) {\n            return 0;\n        }\n        return this.CenterCostBb(bundleInfo.SourceBase) + this.CenterCostBb(bundleInfo.TargetBase);\n    }\n    CenterCostBb(bundleBase) {\n        if (!bundleBase.BelongsToRealNode) {\n            return 0;\n        }\n        const currentMid = bundleBase.ParMid;\n        const mn = Math.min(bundleBase.InitialMidParameter, currentMid);\n        const mx = Math.max(bundleBase.InitialMidParameter, currentMid);\n        const dist = Math.min(mx - mn, mn + (parameterSpan(bundleBase.Curve) - mx));\n        if (bundleBase.CurveCenter.equal(bundleBase.Position) || bundleBase.IsParent) {\n            return 25 * (dist * dist);\n        }\n        else {\n            return 500 * (dist * dist);\n        }\n    }\n    AssymetryCost(bundleInfo) {\n        return this.GetAssymetryCostForBase(bundleInfo.SourceBase) + this.GetAssymetryCostForBase(bundleInfo.TargetBase);\n    }\n    GetAssymetryCostForBase(bundleBase) {\n        if (bundleBase.BelongsToRealNode) {\n            return 0;\n        }\n        const assymetryWeight = bundleBase.OppositeBase.BelongsToRealNode ? 200 : 500;\n        let cost = 0;\n        for (const o of bundleBase.OrientedHubSegments) {\n            const i0 = o.Index;\n            const i1 = o.Other.Index;\n            const a = bundleBase.Points[i0];\n            const ta = bundleBase.Tangents[i0];\n            const oppositeBase = o.Other.BundleBase;\n            const b = oppositeBase.Points[i1];\n            const tb = oppositeBase.Tangents[i1];\n            const s = bundleBase.Count + oppositeBase.Count;\n            cost += this.GetAssymetryCostOnData(a, ta, b, tb, assymetryWeight) / s;\n        }\n        return cost;\n    }\n    GetAssymetryCostOnData(a, tangentA, b, tangentB, assymetryWeight) {\n        const xAxis = a.sub(b);\n        const len = xAxis.length;\n        if (len < GeomConstants.distanceEpsilon) {\n            return 0;\n        }\n        len;\n        // Tangents both have length 1. If they compensate each other on x-asis,\n        // then their projections on y-axis are the same.\n        const delx = tangentA.add(tangentB).dot(xAxis);\n        // const yAxis = xAxis.Rotate90Ccw();\n        // const ay = tangentA * yAxis;\n        // const by = tangentB * yAxis;\n        const ay = Point.crossProduct(xAxis, tangentA);\n        const by = Point.crossProduct(xAxis, tangentB);\n        const dely = ay - by;\n        // double ac = Math.Sqrt(delx * delx + dely * dely);\n        // double bc = Math.Sqrt(ay * ay + by * by);\n        const ac = delx * delx + dely * dely;\n        const bc = ay * ay + by * by;\n        return 10 * ac + assymetryWeight * bc;\n    }\n    SeparationCost(bundleInfo) {\n        return this.SeparationCostForBundleBase(bundleInfo.SourceBase) + this.SeparationCostForBundleBase(bundleInfo.TargetBase);\n    }\n    SeparationCostForBundleBase(bBase) {\n        if (bBase.Prev == null) {\n            return 0;\n        }\n        return this.SeparationCostForAdjacentBundleBases(bBase, bBase.Prev) + this.SeparationCostForAdjacentBundleBases(bBase, bBase.Next);\n    }\n    SeparationCostForAdjacentBundleBases(base0, base1) {\n        //Assert.assert(base0.Curve === base1.Curve)\n        const boundaryCurve = base0.Curve;\n        const len = this.IntervalsOverlapLength(base0.ParStart, base0.ParEnd, base1.ParStart, base1.ParEnd, boundaryCurve);\n        const mn = Math.min(base0.Span, base1.Span);\n        //Assert.assert(ApproximateComparer.LessOrEqual(len, mn));\n        //Assert.assert((mn > 0));\n        return Math.exp(len / (mn * 10)) - 1;\n    }\n    // returns the length of the overlapped interval of parameter space\n    IntervalsOverlapLength(a, b, c, d, curve) {\n        const s = curve.parStart;\n        const e = curve.parEnd;\n        if (a < b) {\n            if (c < d) {\n                return this.IntersectRegularIntervals(a, b, c, d);\n            }\n            return this.IntersectRegularIntervals(a, b, c, e) + this.IntersectRegularIntervals(a, b, s, d);\n        }\n        if (c < d) {\n            return this.IntersectRegularIntervals(a, e, c, d) + this.IntersectRegularIntervals(s, b, c, d);\n        }\n        return this.IntersectRegularIntervals(a, e, c, e) + this.IntersectRegularIntervals(s, b, s, d);\n    }\n    IntersectRegularIntervals(a, b, c, d) {\n        const low = Math.max(a, c);\n        const up = Math.min(b, d);\n        if (low < up) {\n            return up - low;\n        }\n        return 0;\n    }\n    Cost() {\n        let cost = 0;\n        for (const bundleInfo of this.Bundles) {\n            const c1 = BundleBasesCalculator.SeparationCoeff * this.SeparationCost(bundleInfo);\n            const c2 = BundleBasesCalculator.AssymetryCoeff * this.AssymetryCost(bundleInfo);\n            const c3 = BundleBasesCalculator.SqueezeCoeff * this.SqueezeCost(bundleInfo);\n            const c4 = BundleBasesCalculator.CenterCoeff * this.CenterCostBi(bundleInfo);\n            cost += (c1 + c2) / 2 + c3 + c4;\n            //Assert.assert(cost < Number.POSITIVE_INFINITY)\n        }\n        return cost;\n    }\n}\n/** 1(-1) rotate point CCW(CW)*/\nBundleBasesCalculator.Deltas = [\n    [1, -1],\n    // [0, 1],\n    //[-1, 1],\n    // [1, 0],\n    // [-1, 0],\n    //[1, -1],\n    // [0, -1],\n    [1, -1], //rotating the left point cw, the right ccw\n];\nBundleBasesCalculator.SeparationCoeff = 1;\nBundleBasesCalculator.SqueezeCoeff = 1;\nBundleBasesCalculator.CenterCoeff = 10;\nBundleBasesCalculator.AssymetryCoeff = 1;\nBundleBasesCalculator.MaxIterations = 200;\nBundleBasesCalculator.MaxParameterChange = 8 / 360;\n// it would be one degree for a circle\nBundleBasesCalculator.MinParameterChange = 0.1 / 360;\nBundleBasesCalculator.CostThreshold = 1e-5;\nBundleBasesCalculator.CostDeltaThreshold = 0.01;\nfunction intersectBases(rBase, lBase) {\n    // here rBase.Curve is the same as lBase.Curve\n    // getting the parameter span of the curve\n    const fullSpan = parameterSpan(rBase.Curve);\n    let e = rBase.ParEnd;\n    let s = rBase.ParStart < rBase.ParEnd ? rBase.ParStart : rBase.ParStart - fullSpan;\n    let oe = lBase.ParEnd;\n    let os = lBase.ParStart < lBase.ParEnd ? lBase.ParStart : lBase.ParStart - fullSpan;\n    // We have where s < e, and os < oe. Also e,s, os, oe <= rBase.Curve.ParEnd, but we can have s, os < rBase.Curve.ParStart\n    // In addition, we are going to fit the intervals into an interval which is not longer then fullSpan.\n    // To achive this we might need to shift one of the intervals by fullSpan\n    if (e > oe) {\n        // here also e > os\n        if (e - os > fullSpan) {\n            os += fullSpan;\n            oe += fullSpan;\n        }\n    }\n    else {\n        // here oe >= e > s\n        if (oe - s > fullSpan) {\n            s += fullSpan;\n            e += fullSpan;\n        }\n    }\n    // Assert.assert(s < e)\n    // Assert.assert(os < oe)\n    // Assert.assert(Math.abs(e - s) <= fullSpan, 'e - s <= fullSpan')\n    // Assert.assert(Math.abs(oe - os) <= fullSpan, 'oe - os <= fullSpan')\n    // Assert.assert(Math.abs(oe - s) <= fullSpan, 'oe - s <= fullSpan')\n    // Assert.assert(Math.abs(e - os) <= fullSpan, 'e - os <= fullSpan')\n    const xEnd = Math.min(e, oe);\n    const xStart = Math.max(s, os);\n    return xStart <= xEnd ? { start: xStart, end: xEnd, rbaseMiddle: (s + e) / 2, lbaseMiddle: (os + oe) / 2 } : null;\n}\n//# sourceMappingURL=BundleBasesCalculator.js.map","//\nimport { Curve, GeomConstants, LineSegment, Point } from '../../../math/geometry';\nimport { Intersections } from './Intersections';\nexport class BundleInfo {\n    constructor(sourceBase, targetBase, obstaclesToIgnore, halfWidthArray) {\n        this.SourceBase = sourceBase;\n        this.TargetBase = targetBase;\n        this.obstaclesToIgnore = obstaclesToIgnore;\n        this.HalfWidthArray = halfWidthArray;\n        this.TotalRequiredWidth = this.HalfWidthArray.reduce((a, b) => a + b, 0) * 2;\n        this.longEnoughSideLength = sourceBase.Curve.boundingBox.addRec(targetBase.Curve.boundingBox).diagonal;\n        // sometimes TotalRequiredWidth is too large to fit into the circle, so we evenly scale everything\n        const mn = Math.max(sourceBase.Curve.boundingBox.diagonal, targetBase.Curve.boundingBox.diagonal);\n        if (this.TotalRequiredWidth > mn) {\n            const scale = this.TotalRequiredWidth / mn;\n            for (let i = 0; i < this.HalfWidthArray.length; i++)\n                this.HalfWidthArray[i] /= scale;\n            this.TotalRequiredWidth /= scale;\n        }\n    }\n    SetParamsFeasiblySymmetrically(tightTree) {\n        this.CalculateTightObstaclesForBundle(tightTree, this.obstaclesToIgnore);\n        this.SetEndParamsSymmetrically();\n    }\n    CalculateTightObstaclesForBundle(tightTree, obstaclesToIgnore) {\n        const sRadius = this.SourceBase.Curve.boundingBox.diagonal / 2;\n        const tRadius = this.TargetBase.Curve.boundingBox.diagonal / 2;\n        const bundle = Intersections.Create4gon(this.SourceBase.Position, this.TargetBase.Position, sRadius * 2, tRadius * 2);\n        this.tightObstaclesInTheBoundingBox = Array.from(tightTree.AllHitItems(bundle.boundingBox, (p) => !obstaclesToIgnore.has(p) && Curve.ClosedCurveInteriorsIntersect(bundle, p)));\n    }\n    SetEndParamsSymmetrically() {\n        const targetPos = this.TargetBase.Position;\n        const sourcePos = this.SourceBase.Position;\n        const dir = targetPos.sub(sourcePos).normalize();\n        const perp = dir.rotate90Ccw();\n        const middle = Point.middle(targetPos, sourcePos);\n        const mdir = dir.mul(this.longEnoughSideLength);\n        const a = middle.add(mdir);\n        const b = middle.sub(mdir);\n        // [a,b] is a long enough segment\n        // we are already fine\n        if (this.SetRLParamsIfWidthIsFeasible(perp.mul(this.TotalRequiredWidth / 2), a, b)) {\n            this.SetInitialMidParams();\n            return;\n        }\n        // find the segment using binary search\n        let uw = this.TotalRequiredWidth;\n        let lw = 0;\n        let mw = uw / 2;\n        while (uw - lw > BundleInfo.FeasibleWidthEpsilon) {\n            if (this.SetRLParamsIfWidthIsFeasible(perp.mul(mw / 2), a, b)) {\n                lw = mw;\n            }\n            else {\n                uw = mw;\n            }\n            mw = 0.5 * (uw + lw);\n        }\n        if (mw <= BundleInfo.FeasibleWidthEpsilon) {\n            // try one side\n            if (this.SetRLParamsIfWidthIsFeasible_(perp.mul(BundleInfo.FeasibleWidthEpsilon), new Point(0, 0), a, b) ||\n                this.SetRLParamsIfWidthIsFeasible_(new Point(0, 0), perp.mul(-BundleInfo.FeasibleWidthEpsilon), a, b)) {\n                mw = 2 * BundleInfo.FeasibleWidthEpsilon;\n            }\n        }\n        //Assert.assert(mw > BundleInfo.FeasibleWidthEpsilon)\n        this.SourceBase.InitialMidParameter = this.SourceBase.AdjustParam(this.SourceBase.ParStart + this.SourceBase.Span / 2);\n        this.TargetBase.InitialMidParameter = this.TargetBase.AdjustParam(this.TargetBase.ParStart + this.TargetBase.Span / 2);\n    }\n    mkNameFromLRST() {\n        return './tmp/leftRight' + this.SourceBase.Position.toString() + '_' + this.TargetBase.Position.toString() + '.svg';\n    }\n    SetRLParamsIfWidthIsFeasible(perp, a, b) {\n        return this.SetRLParamsIfWidthIsFeasible_(perp, perp.neg(), a, b);\n    }\n    SetRLParamsIfWidthIsFeasible_(perpL, perpR, a, b) {\n        const targetLParam = { par: 0 };\n        const sourceLParam = { par: 0 };\n        const targetRParam = { par: 0 };\n        const sourceRParam = { par: 0 };\n        let ls = this.TrimSegWithBoundaryCurves(LineSegment.mkPP(a.add(perpL), b.add(perpL)), sourceLParam, targetRParam);\n        if (ls == null) {\n            return false;\n        }\n        const intersected = this.tightObstaclesInTheBoundingBox.find((t) => Curve.intersectionOne(ls, t, false) != null);\n        if (intersected) {\n            return false;\n        }\n        ls = this.TrimSegWithBoundaryCurves(LineSegment.mkPP(a.add(perpR), b.add(perpR)), sourceRParam, targetLParam);\n        if (ls == null) {\n            return false;\n        }\n        if (this.tightObstaclesInTheBoundingBox.find((t) => Curve.intersectionOne(ls, t, false) != null)) {\n            return false;\n        }\n        if (this.SourceBase.IsParent) {\n            this.SourceBase.ParStart = sourceLParam.par;\n            this.SourceBase.ParEnd = sourceRParam.par;\n        }\n        else {\n            this.SourceBase.ParStart = sourceRParam.par;\n            this.SourceBase.ParEnd = sourceLParam.par;\n        }\n        // SourceBase.InitialMidParameter = SourceBase.AdjustParam(SourceBase.ParRight + SourceBase.Span / 2);\n        if (this.TargetBase.IsParent) {\n            this.TargetBase.ParStart = targetLParam.par;\n            this.TargetBase.ParEnd = targetRParam.par;\n        }\n        else {\n            this.TargetBase.ParStart = targetRParam.par;\n            this.TargetBase.ParEnd = targetLParam.par;\n        }\n        //  SvgDebugWriter.dumpDebugCurves(this.mkNameFromLRST(), [\n        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Red', this.SourceBase.Curve),\n        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Blue', this.TargetBase.Curve),\n        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Green', LineSegment.mkPP(this.TargetBase.LeftPoint, this.SourceBase.LeftPoint)),\n        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Yellow', LineSegment.mkPP(this.TargetBase.RightPoint, this.SourceBase.RightPoint)),\n        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Black', LineSegment.mkPP(a, b)),\n        //  ])\n        // }\n        // //Assert.assert(this.SourceBase.LeftPoint.sub(this.SourceBase.Position).dot(perpL) > 0)\n        // //Assert.assert(this.TargetBase.LeftPoint.sub(this.SourceBase.Position).dot(perpL) < 0)\n        // Assert.assert(this.SourceBase.isCorrectlyOrienected() && this.TargetBase.isCorrectlyOrienected())\n        return true;\n    }\n    SetInitialMidParams() {\n        const t = { par: 0 };\n        const s = { par: 0 };\n        const ls = this.TrimSegWithBoundaryCurves(LineSegment.mkPP(this.TargetBase.CurveCenter, this.TargetBase.CurveCenter), s, t);\n        if (ls != null) {\n            this.SourceBase.InitialMidParameter = s.par;\n            this.TargetBase.InitialMidParameter = t.par;\n        }\n        else {\n            this.SourceBase.InitialMidParameter = this.SourceBase.AdjustParam(this.SourceBase.ParStart + this.SourceBase.Span / 2);\n            this.TargetBase.InitialMidParameter = this.TargetBase.AdjustParam(this.TargetBase.ParStart + this.TargetBase.Span / 2);\n        }\n        // SvgDebugWriter.dumpDebugCurves(this.mkNameFromST(), [\n        //  DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', this.SourceBase.Curve),\n        //  DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Blue', this.TargetBase.Curve),\n        //  DebugCurve.mkDebugCurveTWCI(\n        //    100,\n        //    0.2,\n        //    'Red',\n        //    CurveFactory.mkCircle(2, this.SourceBase.Curve.value(this.SourceBase.InitialMidParameter)),\n        //  ),\n        //  DebugCurve.mkDebugCurveTWCI(\n        //    100,\n        //    0.2,\n        //    'Blue',\n        //    CurveFactory.mkCircle(2, this.TargetBase.Curve.value(this.TargetBase.InitialMidParameter)),\n        //  ),\n        // ])\n    }\n    mkNameFromST() {\n        return './tmp/mparam' + this.SourceBase.Position.toString() + '_' + this.TargetBase.Position.toString() + '.svg';\n    }\n    TrimSegWithBoundaryCurves(ls, s, t) {\n        // ls goes from target to source\n        let inters = Curve.getAllIntersections(ls, this.SourceBase.Curve, true);\n        if (inters.length === 0) {\n            t.par = 0;\n            s.par = 0;\n            return null;\n        }\n        let sourceX;\n        if (inters.length === 1)\n            sourceX = inters[0];\n        else {\n            if (!this.SourceBase.IsParent)\n                sourceX = inters[0].par0 < inters[1].par0 ? inters[0] : inters[1];\n            else\n                sourceX = inters[0].par0 < inters[1].par0 ? inters[1] : inters[0];\n        }\n        inters = Curve.getAllIntersections(ls, this.TargetBase.Curve, true);\n        if (inters.length === 0) {\n            t.par = 0;\n            s.par = 0;\n            return null;\n        }\n        let targetX;\n        if (inters.length === 1)\n            targetX = inters[0];\n        else {\n            if (!this.TargetBase.IsParent)\n                targetX = inters[0].par0 > inters[1].par0 ? inters[0] : inters[1];\n            else\n                targetX = inters[0].par0 > inters[1].par0 ? inters[1] : inters[0];\n        }\n        s.par = sourceX.par1;\n        t.par = targetX.par1;\n        //   //Assert.assert(Point.closeDistEps(sourceX.x, this.SourceBase.Curve.value(sourceX.par1)))\n        // //Assert.assert(Point.closeDistEps(targetX.x, this.TargetBase.Curve.value(targetX.par1)))\n        // SvgDebugWriter.dumpDebugCurves('./tmp/trim_result' + ls.start.toString() + ls.end.toString() + '.svg', [\n        //  DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', this.SourceBase.Curve),\n        //  DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Blue', this.TargetBase.Curve),\n        //  DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Black', ls),\n        //  DebugCurve.mkDebugCurveTWCI(100, 0.5, 'Brown', LineSegment.mkPP(sourceX.x, targetX.x)),\n        // ])\n        return LineSegment.mkPP(sourceX.x, targetX.x);\n    }\n    RotateBy(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange) {\n        const needToUpdateSource = rotationOfSourceRightPoint !== 0 || rotationOfSourceLeftPoint !== 0;\n        const needToUpdateTarget = rotationOfTargetRightPoint !== 0 || rotationOfTargetLeftPoint !== 0;\n        if (needToUpdateSource) {\n            this.SourceBase.RotateBy(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, parameterChange);\n        }\n        if (needToUpdateTarget) {\n            this.TargetBase.RotateBy(rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange);\n        }\n        this.UpdateSourceAndTargetBases(needToUpdateSource, needToUpdateTarget);\n    }\n    UpdateSourceAndTargetBases(sourceChanged, targetChanged) {\n        if (sourceChanged) {\n            this.UpdatePointsOnBundleBase(this.SourceBase);\n        }\n        if (targetChanged) {\n            this.UpdatePointsOnBundleBase(this.TargetBase);\n        }\n        this.UpdateTangentsOnBases();\n    }\n    UpdateTangentsOnBases() {\n        const count = this.TargetBase.length;\n        // updating tangents\n        for (let i = 0; i < count; i++) {\n            let d = this.TargetBase.Points[i].sub(this.SourceBase.Points[count - 1 - i]);\n            const len = d.length;\n            if (len >= GeomConstants.tolerance) {\n                d = d.div(len);\n                this.TargetBase.Tangents[i] = d;\n                this.SourceBase.Tangents[count - 1 - i] = d.neg();\n            }\n            else {\n                // Assert.assert(false)\n            }\n        }\n    }\n    UpdatePointsOnBundleBase(bb) {\n        const count = bb.length;\n        const pns = bb.Points;\n        const ls = LineSegment.mkPP(bb.EndPoint, bb.StartPoint);\n        const scale = 1.0 / this.TotalRequiredWidth;\n        let t = this.HalfWidthArray[0];\n        pns[0] = ls.value(t * scale);\n        for (let i = 1; i < count; i++) {\n            t += this.HalfWidthArray[i - 1] + this.HalfWidthArray[i];\n            pns[i] = ls.value(t * scale);\n        }\n    }\n    RotationIsLegal(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange) {\n        // 1. we can't have intersections with obstacles\n        // (we check borderlines of the bundle only)\n        if (!this.SourceBase.IsParent && !this.TargetBase.IsParent) {\n            if (rotationOfSourceLeftPoint !== 0 || rotationOfTargetRightPoint !== 0) {\n                const rSoP = this.SourceBase.RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange);\n                const lTarP = this.TargetBase.RotateRigthPoint(rotationOfTargetRightPoint, parameterChange);\n                if (!this.LineIsLegal(rSoP, lTarP)) {\n                    return false;\n                }\n            }\n            if (rotationOfSourceRightPoint !== 0 || rotationOfTargetLeftPoint !== 0) {\n                const lSoP = this.SourceBase.RotateRigthPoint(rotationOfSourceRightPoint, parameterChange);\n                const rTarP = this.TargetBase.RotateLeftPoint(rotationOfTargetLeftPoint, parameterChange);\n                if (!this.LineIsLegal(lSoP, rTarP)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            if (rotationOfSourceLeftPoint !== 0 || rotationOfTargetLeftPoint !== 0) {\n                const lSoP = this.SourceBase.RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange);\n                const lTarP = this.TargetBase.RotateLeftPoint(rotationOfTargetLeftPoint, parameterChange);\n                if (!this.LineIsLegal(lSoP, lTarP)) {\n                    return false;\n                }\n            }\n            if (rotationOfSourceRightPoint !== 0 || rotationOfTargetRightPoint !== 0) {\n                const rSoP = this.SourceBase.RotateRigthPoint(rotationOfSourceRightPoint, parameterChange);\n                const rTarP = this.TargetBase.RotateRigthPoint(rotationOfTargetRightPoint, parameterChange);\n                if (!this.LineIsLegal(rSoP, rTarP)) {\n                    return false;\n                }\n            }\n        }\n        // 2. we are also not allowed to change the order of bundles around a hub\n        if (rotationOfSourceRightPoint !== 0 || rotationOfSourceLeftPoint !== 0) {\n            if (!this.SourceBase.RelativeOrderOfBasesIsPreserved(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, parameterChange)) {\n                return false;\n            }\n        }\n        if (rotationOfTargetRightPoint !== 0 || rotationOfTargetLeftPoint !== 0) {\n            if (!this.TargetBase.RelativeOrderOfBasesIsPreserved(rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    LineIsLegal(a, b) {\n        return this.tightObstaclesInTheBoundingBox.find((t) => Curve.intersectionOne(LineSegment.mkPP(a, b), t, false) != null) == null;\n    }\n}\nBundleInfo.FeasibleWidthEpsilon = 0.1;\n//# sourceMappingURL=BundleInfo.js.map","// The class is responsible for general edge bundling with ordered bundles.\n// Currently the router will fail if there are node overlaps.\nimport { GeomEdge } from '../../..';\nimport { HookUpAnywhereFromInsidePort } from '../../../layout/core/hookUpAnywhereFromInsidePort';\nimport { Curve, LineSegment } from '../../../math/geometry';\nimport { ClusterBoundaryPort } from '../../ClusterBoundaryPort';\nimport { SingleSourceMultipleTargetsShortestPathOnVisibilityGraph } from '../../SingleSourceMultipleTargetsShortestPathOnVisibilityGraph';\nimport { BundlingStatus } from './BundlingStatus';\nimport { Algorithm } from '../../../utils/algorithm';\nimport { FindIntersectionWithProperty } from '../../../math/geometry/RTree/rectangleNodeUtils';\nimport { MetroGraphData } from './MetroGraphData';\nimport { StationPositionsAdjuster } from './StationPositionsAdjuster';\nimport { EdgeNudger } from './EdgeNudger';\nimport { MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph } from '../../MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph';\nimport { addToMapOfSets } from '../../../utils/setOperations';\nimport { Arrowhead } from '../../../layout/core/arrowhead';\nimport { initRandom } from '../../../utils/random';\nexport class BundleRouter extends Algorithm {\n    constructor(edgesToRoute, shortestPathRouter, visibilityGraph, bundlingSettings, loosePadding, tightHierarchy, looseHierarchy, edgeLooseEnterable, edgeTightEnterable, loosePolylineOfPort) {\n        super(null);\n        this.bundlingSettings = bundlingSettings;\n        this.bundlingSettings.edgeWidthShrinkCoeff = 1;\n        this.edgesToRoute = edgesToRoute;\n        this.regularEdges = edgesToRoute.filter((e) => e.source !== e.target);\n        this.VisibilityGraph = visibilityGraph;\n        this.shortestPathRouter = shortestPathRouter;\n        this.LoosePadding = loosePadding;\n        this.LooseHierarchy = looseHierarchy;\n        this.TightHierarchy = tightHierarchy;\n        this.EdgeLooseEnterable = edgeLooseEnterable;\n        this.EdgeTightEnterable = edgeTightEnterable;\n        this.loosePolylineOfPort = loosePolylineOfPort;\n        initRandom(0);\n    }\n    ThereAreOverlaps(hierarchy) {\n        return FindIntersectionWithProperty(hierarchy, hierarchy, Curve.CurvesIntersect);\n    }\n    // edge routing with Ordered Bundles:\n    // 1. route edges with bundling\n    // 2. nudge bundles and hubs\n    // 3. order paths\n    run() {\n        if (this.ThereAreOverlaps(this.TightHierarchy)) {\n            this.Status = BundlingStatus.Overlaps;\n            return;\n        }\n        this.FixLocationsForHookAnywherePorts(this.edgesToRoute);\n        this.RoutePathsWithSteinerDijkstra();\n        this.FixChildParentEdges();\n        if (!this.bundlingSettings.StopAfterShortestPaths) {\n            this.OrderOptimizeNudgeEtc();\n        }\n        this.RouteSelfEdges();\n        this.FixArrowheads();\n    }\n    OrderOptimizeNudgeEtc() {\n        const metroGraphData = new MetroGraphData(this.regularEdges, this.LooseHierarchy, this.TightHierarchy, this.bundlingSettings, this.shortestPathRouter.cdt, this.EdgeLooseEnterable, this.EdgeTightEnterable, this.loosePolylineOfPort);\n        StationPositionsAdjuster.FixRouting(metroGraphData, this.bundlingSettings);\n        new EdgeNudger(metroGraphData, this.bundlingSettings).run();\n    }\n    // set endpoint of the edge from child to parent (cluster) to the boundary of the parent\n    // TODO: is there a better solution?\n    FixChildParentEdges() {\n        for (const edge of this.regularEdges) {\n            const sPort = edge.sourcePort;\n            const ePort = edge.targetPort;\n            if (sPort.Curve.boundingBox.containsRect(ePort.Curve.boundingBox)) {\n                const ii = Curve.intersectionOne(sPort.Curve, LineSegment.mkPP(edge.curve.start, edge.curve.end), false);\n                const poly = edge.curve;\n                poly.startPoint.point = ii.x;\n            }\n            if (ePort.Curve.boundingBox.containsRect(sPort.Curve.boundingBox)) {\n                const ii = Curve.intersectionOne(ePort.Curve, LineSegment.mkPP(edge.curve.start, edge.curve.end), true);\n                const poly = edge.curve;\n                poly.endPoint.point = ii.x;\n            }\n        }\n    }\n    // ReSharper disable UnusedMember.Local\n    // ShowGraphLocal() {\n    //  //  ReSharper restore UnusedMember.Local\n    //  const l = new List<ICurve>()\n    //  l.Clear()\n    //  for (const e in this.geometryGraph.edges) {\n    //    l.Add(new Ellipse(2, 2, e.Curve.Start))\n    //    l.Add(CurveFactory.CreateDiamond(5, 5, e.Curve.End))\n    //    l.Add(e.Curve)\n    //  }\n    //  SplineRouter.ShowVisGraph(this.VisibilityGraph, this.LooseHierarchy.GetAllLeaves(), null, l)\n    // }\n    FixLocationsForHookAnywherePorts(edges) {\n        for (const edge of edges) {\n            let isHookPort = edge.sourcePort instanceof HookUpAnywhereFromInsidePort;\n            if (isHookPort) {\n                const hookPort = edge.sourcePort;\n                hookPort.SetLocation(this.FigureOutHookLocation(hookPort.LoosePolyline, edge.targetPort, edge));\n            }\n            else {\n                isHookPort = edge.targetPort instanceof HookUpAnywhereFromInsidePort;\n                if (isHookPort) {\n                    const hookPort = edge.targetPort;\n                    hookPort.SetLocation(this.FigureOutHookLocation(hookPort.LoosePolyline, edge.sourcePort, edge));\n                }\n            }\n        }\n    }\n    FigureOutHookLocation(poly, otherEdgeEndPort, edgeGeom) {\n        const isClusterPort = otherEdgeEndPort instanceof ClusterBoundaryPort;\n        if (!isClusterPort) {\n            return this.FigureOutHookLocationForSimpleOtherPort(poly, otherEdgeEndPort, edgeGeom);\n        }\n        return this.FigureOutHookLocationForClusterOtherPort(poly, otherEdgeEndPort, edgeGeom);\n    }\n    FigureOutHookLocationForClusterOtherPort(poly, otherEdgeEndPort, edgeGeom) {\n        const shapes = this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(edgeGeom);\n        // SplineRouter.ShowVisGraph(this.VisibilityGraph, this.LooseHierarchy.GetAllLeaves(),\n        //    shapes.Select(sh => sh.BoundaryCurve), new[] { new LineSegment(edgeGeom.SourcePort.Location, edgeGeom.TargetPort.Location) });\n        const s = new MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph(Array.from(otherEdgeEndPort.LoosePolyline).map(this.VisibilityGraph.FindVertex.bind), Array.from(poly).map(this.VisibilityGraph.FindVertex.bind), this.VisibilityGraph);\n        const path = s.GetPath();\n        for (const sh of shapes) {\n            sh.IsTransparent = false;\n        }\n        return path[path.length - 1].point;\n    }\n    FigureOutHookLocationForSimpleOtherPort(poly, otherEdgeEndPort, edgeGeom) {\n        const otherEdgeEnd = otherEdgeEndPort.Location;\n        const shapes = this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(edgeGeom);\n        // SplineRouter.ShowVisGraph(this.VisibilityGraph, this.LooseHierarchy.GetAllLeaves(),\n        //    shapes.Select(sh => sh.BoundaryCurve), new[] { new LineSegment(edgeGeom.SourcePort.Location, edgeGeom.TargetPort.Location) });\n        const s = new SingleSourceMultipleTargetsShortestPathOnVisibilityGraph(this.VisibilityGraph.FindVertex(otherEdgeEnd), Array.from(poly).map((p) => this.VisibilityGraph.FindVertex(p)), this.VisibilityGraph);\n        const path = s.GetPath();\n        for (const sh of shapes) {\n            sh.IsTransparent = false;\n        }\n        return path[path.length - 1].point;\n    }\n    RoutePathsWithSteinerDijkstra() {\n        this.shortestPathRouter.VisibilityGraph = this.VisibilityGraph;\n        this.shortestPathRouter.BundlingSettings = this.bundlingSettings;\n        this.shortestPathRouter.geomEdges = this.regularEdges;\n        this.shortestPathRouter.ObstacleHierarchy = this.LooseHierarchy;\n        this.shortestPathRouter.RouteEdges();\n        // find appropriate edge separation\n        if (this.shortestPathRouter.cdt != null) {\n            this.AdjustEdgeSeparation();\n        }\n    }\n    // calculates maximum possible edge separation for the computed routing\n    //   if it is greater than bundlingSettings.EdgeSeparation, then proceed\n    //   if it is smaller, then either\n    //     stop edge bundling, or\n    //     reduce edge separation, or\n    //     move obstacles to get more free space\n    AdjustEdgeSeparation() {\n        const crossedCdtEdges = new Map();\n        this.shortestPathRouter.FillCrossedCdtEdges(crossedCdtEdges);\n        const pathsOnCdtEdge = this.GetPathsOnCdtEdge(crossedCdtEdges);\n        this.bundlingSettings.edgeWidthShrinkCoeff = this.CalculateEdgeWidthShrinkCoeff(pathsOnCdtEdge);\n    }\n    //  //  reducing edge separation\n    //  //  TimeMeasurer.DebugOutput(\"reducing edge separation to \" + es);\n    //  this.bundlingSettings.EdgeSeparation = es\n    //  this.shortestPathRouter.RouteEdges()\n    //  return true\n    // }\n    GetPathsOnCdtEdge(crossedEdges) {\n        const res = new Map();\n        for (const edge of crossedEdges.keys()) {\n            for (const cdtEdge of crossedEdges.get(edge)) {\n                addToMapOfSets(res, cdtEdge, edge);\n            }\n        }\n        return res;\n    }\n    CalculateEdgeWidthShrinkCoeff(pathsOnCdtEdge) {\n        let l = 0;\n        let r = this.bundlingSettings.edgeWidthShrinkCoeff;\n        if (this.EdgeSeparationIsOkMN(pathsOnCdtEdge, r)) {\n            return r;\n        }\n        let lHasChanged = false;\n        while (!lHasChanged || Math.abs(r - l) > 0.01) {\n            const cen = (l + r) / 2;\n            if (this.EdgeSeparationIsOkMN(pathsOnCdtEdge, cen)) {\n                l = cen;\n                lHasChanged = true;\n            }\n            else {\n                r = cen;\n            }\n        }\n        return l;\n    }\n    EdgeSeparationIsOkMN(pathsOnCdtEdge, widthShrinkCoeff) {\n        for (const edge of pathsOnCdtEdge.keys()) {\n            if (!this.EdgeSeparationIsOk(edge, pathsOnCdtEdge.get(edge), widthShrinkCoeff)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    EdgeSeparationIsOk(edge, paths, shrinkCoeff) {\n        const requiredWidth = Array.from(paths)\n            .map((e) => this.bundlingSettings.ActualEdgeWidth(e, shrinkCoeff))\n            .reduce((a, b) => a + b, 0);\n        return requiredWidth <= edge.Capacity;\n    }\n    RouteSelfEdges() {\n        for (const edge of this.edgesToRoute) {\n            if (edge.source === edge.target) {\n                const t = { smoothedPolyline: null };\n                edge.curve = GeomEdge.RouteSelfEdge(edge.source.boundaryCurve, this.LoosePadding * 2, t);\n            }\n        }\n    }\n    FixArrowheads() {\n        for (const edge of this.edgesToRoute) {\n            Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, edge.curve, false);\n        }\n    }\n}\n// for the shortest path calculation we will use not loosePadding, but loosePadding*SuperLoosePaddingCoefficient\n/* const */ BundleRouter.SuperLoosePaddingCoefficient = 1.1;\n//# sourceMappingURL=BundleRouter.js.map","export var BundlingStatus;\n(function (BundlingStatus) {\n    BundlingStatus[BundlingStatus[\"Success\"] = 0] = \"Success\";\n    BundlingStatus[BundlingStatus[\"Overlaps\"] = 1] = \"Overlaps\";\n    BundlingStatus[BundlingStatus[\"EdgeSeparationIsTooLarge\"] = 2] = \"EdgeSeparationIsTooLarge\";\n})(BundlingStatus || (BundlingStatus = {}));\n//# sourceMappingURL=BundlingStatus.js.map","import { Point } from '../../..';\nimport { LineSegment, PointLocation, GeomConstants } from '../../../math/geometry';\nimport { Cdt } from '../../ConstrainedDelaunayTriangulation/Cdt';\nimport { CdtThreader } from './CdtThreader';\n// Check intersections between edges and obstacles using triangulation (faster than kd-tree)\nexport class CdtIntersections {\n    EdgeIsLegal_(start, end, currentTriangle, obstaclesToIgnore) {\n        //Assert.assert(Cdt.PointIsInsideOfTriangle(start, currentTriangle))\n        if (Cdt.PointIsInsideOfTriangle(end, currentTriangle)) {\n            return true;\n        }\n        const threader = new CdtThreader(currentTriangle, start, end);\n        while (threader.MoveNext()) {\n            const piercedEdge = threader.CurrentPiercedEdge;\n            if (piercedEdge.constrained) {\n                //Assert.assert(piercedEdge.lowerSite.Owner === piercedEdge.upperSite.Owner)\n                const poly = piercedEdge.lowerSite.Owner;\n                if (!obstaclesToIgnore.has(poly)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    constructor(metroGraphData, bundlingSettings) {\n        this.ComputeForcesForBundles = false;\n        this.metroGraphData = metroGraphData;\n        this.bundlingSettings = bundlingSettings;\n    }\n    /**   returns false iff an edge overlap an obstacle,\n   otherwise it calulates distances to the closest obstacles */\n    BundleAvoidsObstacles(v, u, vPosition, uPosition, upperBound, t) {\n        t.closestDist = new Array();\n        const obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(v, u);\n        const closeObstacles = this.FindCloseObstaclesForBundle(u.cdtTriangle, uPosition, vPosition, obstaclesToIgnore, upperBound);\n        if (closeObstacles == null) {\n            return false;\n        }\n        for (const item of closeObstacles) {\n            const dist = item[1];\n            t.closestDist.push(dist);\n        }\n        return true;\n    }\n    // returns null iff the edge overlap an obstacle\n    FindCloseObstaclesForBundle(startTriangle, start, end, obstaclesToIgnore, upperBound) {\n        const obstacles = new Map();\n        const list = [];\n        if (!this.ThreadLineSegmentThroughTriangles(startTriangle, start, end, obstaclesToIgnore, list)) {\n            return null;\n        }\n        if (!this.ComputeForcesForBundles && !this.bundlingSettings.HighestQuality) {\n            return obstacles;\n        }\n        const checkedSites = new Set();\n        for (const t of list) {\n            for (const s of t.Sites) {\n                if (checkedSites.has(s))\n                    continue;\n                checkedSites.add(s);\n                const poly = s.Owner;\n                if (obstaclesToIgnore.has(poly))\n                    continue;\n                const pp = CdtIntersections.FindPolylinePoint(poly, s.point);\n                const t1 = LineSegment.minDistBetweenLineSegments(pp.point, pp.nextOnPolyline.point, start, end);\n                //out par11, out par12);\n                const d12 = t1.dist;\n                const par11 = t1.parab;\n                const par12 = t1.parcd;\n                const t2 = LineSegment.minDistBetweenLineSegments(pp.point, pp.prevOnPolyline.point, start, end);\n                //out par21, out par22);\n                const d22 = t2.dist;\n                const par21 = t2.parab;\n                const par22 = t2.parcd;\n                let r1, r2;\n                let dist;\n                if (d12 < d22) {\n                    dist = d12;\n                    if (dist > upperBound)\n                        continue;\n                    r1 = pp.point.add(pp.nextOnPolyline.point.sub(pp.point).mul(par11));\n                    r2 = start.add(end.sub(start).mul(par12));\n                }\n                else {\n                    dist = d22;\n                    if (dist > upperBound)\n                        continue;\n                    r1 = pp.point.add(pp.prevOnPolyline.point.sub(pp.point).mul(par21));\n                    r2 = start.add(end.sub(start).mul(par22));\n                }\n                //if (dist > upperBound) continue;\n                const currentValue = obstacles.get(poly);\n                if (!currentValue)\n                    obstacles.set(poly, [r1, r2]);\n            }\n        }\n        return obstacles;\n    }\n    /**   returns false iff the edge overlap an obstacle*/\n    ThreadLineSegmentThroughTriangles(currentTriangle, start, end, obstaclesToIgnore, triangles) {\n        if (Cdt.PointIsInsideOfTriangle(end, currentTriangle)) {\n            triangles.push(currentTriangle);\n            return true;\n        }\n        const threader = new CdtThreader(currentTriangle, start, end);\n        triangles.push(currentTriangle);\n        while (threader.MoveNext()) {\n            triangles.push(threader.CurrentTriangle);\n            const piercedEdge = threader.CurrentPiercedEdge;\n            if (piercedEdge.constrained) {\n                //Assert.assert(piercedEdge.lowerSite.Owner === piercedEdge.upperSite.Owner)\n                const poly = piercedEdge.lowerSite.Owner;\n                if (!obstaclesToIgnore.has(poly)) {\n                    return false;\n                }\n            }\n        }\n        if (threader.CurrentTriangle != null) {\n            triangles.push(threader.CurrentTriangle);\n        }\n        //\n        //            int positiveSign, negativeSign;\n        //            CdtEdge piercedEdge = FindFirstPiercedEdge(currentTriangle, start, end, out negativeSign, out positiveSign,  null);\n        //\n        //            //Assert.assert(positiveSign > negativeSign);\n        //\n        //            //Assert.assert(piercedEdge != null);\n        //\n        //            do {\n        //                triangles.Add(currentTriangle);\n        //                if (piercedEdge.Constrained) {\n        //                    //Assert.assert(piercedEdge.lowerSite.Owner === piercedEdge.upperSite.Owner);\n        //                    Polyline poly = (Polyline)piercedEdge.lowerSite.Owner;\n        //                    if (!obstaclesToIgnore.Contains(poly)) return false;\n        //                }\n        //            }\n        //            while (FindNextPierced(start, end, ref currentTriangle, ref piercedEdge, ref negativeSign, ref positiveSign));\n        //            if (currentTriangle != null)\n        //                triangles.Add(currentTriangle);\n        return true;\n    }\n    static PointLocationInsideTriangle(p, triangle) {\n        let seenBoundary = false;\n        for (let i = 0; i < 3; i++) {\n            const area = Point.signedDoubledTriangleArea(p, triangle.Sites.getItem(i).point, triangle.Sites.getItem(i + 1).point);\n            if (area < GeomConstants.distanceEpsilon * -1) {\n                return PointLocation.Outside;\n            }\n            if (area < GeomConstants.distanceEpsilon) {\n                seenBoundary = true;\n            }\n        }\n        return seenBoundary ? PointLocation.Boundary : PointLocation.Inside;\n    }\n    static FindPolylinePoint(poly, point) {\n        for (const ppp of poly.polylinePoints()) {\n            if (ppp.point.equal(point)) {\n                return ppp;\n            }\n        }\n        throw new Error('polyline point ' + point + ' not found');\n    }\n    // checks if an edge intersects obstacles\n    // otherwise it calulates distances to the closest obstacles\n    EdgeIsLegal(v, u, vPosition, uPosition) {\n        const list = [];\n        const obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(v, u);\n        return this.ThreadLineSegmentThroughTriangles(v.cdtTriangle, vPosition, uPosition, obstaclesToIgnore, list);\n    }\n    // checks if an edge intersects obstacles\n    // otherwise it calulates distances to the closest obstacles\n    EdgeIsLegalSSPPS(v, u, obstaclesToIgnore) {\n        // if (CdtIntersections.closedeb(u, v) || CdtIntersections.closedeb(v, u)) {\n        //  console.log(this)\n        // }\n        const start = v.Position;\n        const currentTriangle = v.cdtTriangle;\n        //Assert.assert(Cdt.PointIsInsideOfTriangle(start, currentTriangle))\n        const end = u.Position;\n        if (Cdt.PointIsInsideOfTriangle(end, currentTriangle)) {\n            return true;\n        }\n        const threader = new CdtThreader(currentTriangle, start, end);\n        while (threader.MoveNext()) {\n            const piercedEdge = threader.CurrentPiercedEdge;\n            if (piercedEdge.constrained) {\n                //Assert.assert(piercedEdge.lowerSite.Owner === piercedEdge.upperSite.Owner)\n                const poly = piercedEdge.lowerSite.Owner;\n                if (!obstaclesToIgnore.has(poly)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=CdtIntersections.js.map","import { Point } from '../../..';\nimport { GeomConstants } from '../../../math/geometry';\nimport { TriangleOrientation } from '../../../math/geometry/point';\nexport class CdtThreader {\n    get CurrentPiercedEdge() {\n        return this.currentPiercedEdge;\n    }\n    get CurrentTriangle() {\n        return this.currentTriangle;\n    }\n    constructor(startTriangle, start, end) {\n        this.currentTriangle = startTriangle;\n        this.start = start;\n        this.end = end;\n        //Assert.assert(CdtTriangle.PointLocationForTriangle(start, startTriangle) !== PointLocation.Outside)\n    }\n    /**This method finds the first edge of the current triangle that\n     * is pierced by a segment (start,end). It assumes that the start\n     * point is inside or on the boundary of the current triangle,\n     *  and the end point is outside.\n     * The function works by computing the sign of each vertex\n     *  of the current triangle with respect to the segment.\n     *  The sign is zero if the vertex is on the segment,\n     * positive if it is to the right of the segment  (when looking from the start point to the end point),\n     * and negative if it is to the left.\n     * The function then checks if there are two consecutive\n     * vertices with different signs. If so, it means that the edge between them is pierced by the segment. The function returns that edge as the result.\n  \n  The function also sets the positiveSign and negativeSign fields to store the signs of the vertices on either side of the pierced edge. This is useful for finding the next triangle in the path of the segment. */\n    FindFirstPiercedEdge() {\n        //Assert.assert(CdtTriangle.PointLocationForTriangle(this.start, this.currentTriangle) !== PointLocation.Outside)\n        //Assert.assert(CdtTriangle.PointLocationForTriangle(this.end, this.currentTriangle) === PointLocation.Outside)\n        const sign0 = this.GetHyperplaneSign(this.currentTriangle.Sites.item0);\n        const sign1 = this.GetHyperplaneSign(this.currentTriangle.Sites.item1);\n        if (sign0 !== sign1) {\n            if (Point.getTriangleOrientation(this.end, this.currentTriangle.Sites.item0.point, this.currentTriangle.Sites.item1.point) ==\n                TriangleOrientation.Clockwise) {\n                this.positiveSign = sign0;\n                this.negativeSign = sign1;\n                return this.currentTriangle.Edges.item0;\n            }\n        }\n        const sign2 = this.GetHyperplaneSign(this.currentTriangle.Sites.item2);\n        if (sign1 !== sign2) {\n            if (Point.getTriangleOrientation(this.end, this.currentTriangle.Sites.item1.point, this.currentTriangle.Sites.item2.point) ==\n                TriangleOrientation.Clockwise) {\n                this.positiveSign = sign1;\n                this.negativeSign = sign2;\n                return this.currentTriangle.Edges.item1;\n            }\n        }\n        this.positiveSign = sign2;\n        this.negativeSign = sign0;\n        //Assert.assert(this.positiveSign > this.negativeSign)\n        return this.currentTriangle.Edges.item2;\n    }\n    FindNextPierced() {\n        //Assert.assert(this.negativeSign < this.positiveSign)\n        this.currentTriangle = this.currentPiercedEdge.GetOtherTriangle_T(this.currentTriangle);\n        //            ShowDebug(null,currentPiercedEdge,currentTriangle);\n        if (this.currentTriangle == null) {\n            this.currentPiercedEdge = null;\n            return;\n        }\n        const i = this.currentTriangle.Edges.index(this.currentPiercedEdge);\n        let j;\n        // pierced index\n        const oppositeSite = this.currentTriangle.Sites.getItem(i + 2);\n        const oppositeSiteSign = this.GetHyperplaneSign(oppositeSite);\n        if (this.negativeSign === 0) {\n            //Assert.assert(this.positiveSign === 1)\n            if (oppositeSiteSign === -1 || oppositeSiteSign === 0) {\n                this.negativeSign = oppositeSiteSign;\n                j = i + 1;\n            }\n            else {\n                j = i + 2;\n            }\n        }\n        else if (this.positiveSign === 0) {\n            //Assert.assert(this.negativeSign === -1)\n            if (oppositeSiteSign === 1 || oppositeSiteSign === 0) {\n                this.positiveSign = oppositeSiteSign;\n                j = i + 2;\n            }\n            else {\n                j = i + 1;\n            }\n        }\n        else if (oppositeSiteSign !== this.positiveSign) {\n            this.negativeSign = oppositeSiteSign;\n            j = i + 1;\n        }\n        else {\n            //Assert.assert(this.negativeSign !== oppositeSiteSign)\n            this.positiveSign = oppositeSiteSign;\n            j = i + 2;\n        }\n        this.currentPiercedEdge =\n            Point.signedDoubledTriangleArea(this.end, this.currentTriangle.Sites.getItem(j).point, this.currentTriangle.Sites.getItem(j + 1).point) < -GeomConstants.distanceEpsilon\n                ? this.currentTriangle.Edges.getItem(j)\n                : null;\n    }\n    //        void ShowDebug(Array<CdtTriangle> cdtTriangles, CdtEdge cdtEdge, CdtTriangle cdtTriangle) {\n    //            var l = new Array<DebugCurve> { new DebugCurve(10,\"red\",new LineSegment(start,end)) };\n    //            if(cdtEdge!=null)\n    //                l.Add(new DebugCurve(100,3,\"navy\", new LineSegment(cdtEdge.upperSite.point,cdtEdge.lowerSite.point)));\n    //            AddTriangleToListOfDebugCurves(l,cdtTriangle,100,2,\"brown\");\n    //            LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n    //\n    //        }\n    //        static void AddTriangleToListOfDebugCurves(Array<DebugCurve> debugCurves,CdtTriangle triangle,byte transparency,double width,string color) {\n    //            foreach(var cdtEdge of triangle.Edges) {\n    //                debugCurves.Add(new DebugCurve(transparency,width,color,new LineSegment(cdtEdge.upperSite.point,cdtEdge.lowerSite.point)));\n    //            }\n    //        }\n    GetHyperplaneSign(cdtSite) {\n        const area = Point.signedDoubledTriangleArea(this.start, cdtSite.point, this.end);\n        if (area > GeomConstants.distanceEpsilon) {\n            return 1;\n        }\n        if (area < -GeomConstants.distanceEpsilon) {\n            return -1;\n        }\n        return 0;\n    }\n    MoveNext() {\n        if (this.currentPiercedEdge == null) {\n            this.currentPiercedEdge = this.FindFirstPiercedEdge();\n        }\n        else {\n            this.FindNextPierced();\n        }\n        return this.currentPiercedEdge != null;\n    }\n}\n//# sourceMappingURL=CdtThreader.js.map","import { Point } from '../../..';\nimport { HubRadiiCalculator } from './HubRadiiCalculator';\nimport { GreaterOrEqual } from './MetroGraphData';\n// Calculates the cost of the routing\nexport class CostCalculator {\n    constructor(metroGraphData, bundlingSettings) {\n        this.metroGraphData = metroGraphData;\n        this.bundlingSettings = bundlingSettings;\n    }\n    // Error of ink\n    static InkError(oldInk, newInk, bundlingSettings) {\n        return (oldInk - newInk) * bundlingSettings.InkImportance;\n    }\n    // Error of path lengths\n    static PathLengthsError(oldLength, newLength, idealLength, bundlingSettings) {\n        return (oldLength - newLength) * (bundlingSettings.PathLengthImportance / idealLength);\n    }\n    // Error of hubs\n    static RError(idealR, nowR, bundlingSettings) {\n        if (idealR <= nowR) {\n            return 0;\n        }\n        const res = bundlingSettings.HubRepulsionImportance * ((1 - nowR / idealR) * (idealR - nowR));\n        return res;\n    }\n    // Error of bundles\n    static BundleError(idealWidth, nowWidth, bundlingSettings) {\n        if (idealWidth <= nowWidth) {\n            return 0;\n        }\n        const res = bundlingSettings.BundleRepulsionImportance * ((1 - nowWidth / idealWidth) * (idealWidth - nowWidth));\n        return res;\n    }\n    // Cost of the whole graph\n    static Cost(metroGraphData, bundlingSettings) {\n        let cost = bundlingSettings.InkImportance * metroGraphData.Ink;\n        //path lengths\n        for (const metroline of metroGraphData.Metrolines) {\n            cost += (bundlingSettings.PathLengthImportance * metroline.Length) / metroline.IdealLength;\n        }\n        cost += this.CostOfForces(metroGraphData);\n        return cost;\n    }\n    // Cost of the whole graph (hubs and bundles)\n    static CostOfForces(metroGraphData) {\n        let cost = 0;\n        // hubs\n        for (const v of metroGraphData.VirtualStations()) {\n            cost = cost + v.cachedRadiusCost;\n        }\n        // bundles\n        for (const edge of metroGraphData.VirtualEdges()) {\n            const v = edge[0];\n            const u = edge[1];\n            cost += metroGraphData.GetIjInfo(v, u).cachedBundleCost;\n        }\n        return cost;\n    }\n    // Gain of ink\n    InkGain(node, newPosition) {\n        // ink\n        const oldInk = this.metroGraphData.Ink;\n        let newInk = this.metroGraphData.Ink;\n        for (const adj of node.Neighbors) {\n            const adjPosition = adj.Position;\n            newInk -= adjPosition.sub(node.Position).length;\n            newInk += adjPosition.sub(newPosition).length;\n        }\n        return CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);\n    }\n    // Gain of path lengths\n    PathLengthsGain(node, newPosition) {\n        let gain = 0;\n        //edge lengths\n        for (const e of this.metroGraphData.MetroNodeInfosOfNode(node)) {\n            const oldLength = e.Metroline.Length;\n            const prev = e.PolyPoint.prev.point;\n            const next = e.PolyPoint.next.point;\n            const newLength = e.Metroline.Length +\n                next.sub(newPosition).length +\n                prev.sub(newPosition).length -\n                next.sub(node.Position).length -\n                prev.sub(node.Position).length;\n            gain += CostCalculator.PathLengthsError(oldLength, newLength, e.Metroline.IdealLength, this.bundlingSettings);\n        }\n        return gain;\n    }\n    // Gain of radii\n    RadiusGain(node, newPosition) {\n        let gain = 0;\n        gain = gain + node.cachedRadiusCost;\n        gain = gain - this.RadiusCost(node, newPosition);\n        return gain;\n    }\n    RadiusCost(node, newPosition) {\n        let idealR;\n        if (Point.closeDistEps(node.Position, newPosition)) {\n            idealR = node.cachedIdealRadius;\n        }\n        else {\n            idealR = HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBNP(this.metroGraphData, this.bundlingSettings, node, newPosition);\n        }\n        const t = { touchedObstacles: [] };\n        if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(node, newPosition, idealR, t)) {\n            return CostCalculator.Inf;\n        }\n        let cost = 0;\n        for (const d of t.touchedObstacles) {\n            const dist = d[1].sub(newPosition).length;\n            cost += CostCalculator.RError(idealR, dist, this.bundlingSettings);\n        }\n        return cost;\n    }\n    // Gain of bundles\n    // if a newPosition is not valid (e.g. intersect obstacles) the result is -inf\n    BundleGain(node, newPosition) {\n        let gain = node.cachedBundleCost;\n        for (const adj of node.Neighbors) {\n            const lgain = this.BundleCost(node, adj, newPosition);\n            if (GreaterOrEqual(lgain, CostCalculator.Inf))\n                return -CostCalculator.Inf;\n            gain -= lgain;\n        }\n        return gain;\n    }\n    BundleCost(node, adj, newPosition) {\n        const idealWidth = this.metroGraphData.GetWidthSSN(node, adj, this.bundlingSettings.EdgeSeparation);\n        const t = { closestDist: [] };\n        //find conflicting obstacles\n        if (!this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(node, adj, newPosition, adj.Position, idealWidth, t)) {\n            return CostCalculator.Inf;\n        }\n        let cost = 0;\n        for (const pair of t.closestDist) {\n            const dist = pair[0].sub(pair[1]).length;\n            cost += CostCalculator.BundleError(idealWidth / 2, dist, this.bundlingSettings);\n        }\n        return cost;\n    }\n}\nCostCalculator.Inf = 1000000000;\n//# sourceMappingURL=CostCalculator.js.map","import { Point } from '../../..';\nimport { Curve, LineSegment, GeomConstants, CurveFactory } from '../../../math/geometry';\nimport { BezierSeg } from '../../../math/geometry/bezierSeg';\nimport { DebugCurve } from '../../../math/geometry/debugCurve';\nimport { Ellipse } from '../../../math/geometry/ellipse';\nimport { distPP } from '../../../math/geometry/point';\nimport { Algorithm } from '../../../utils/algorithm';\nimport { BundleBasesCalculator } from './BundleBasesCalculator';\nimport { HubRadiiCalculator } from './HubRadiiCalculator';\nimport { GeneralMetroMapOrdering } from './GeneralMetroMapOrdering';\nimport { segmentsIntersect } from '../../../math/geometry/lineSegment';\n//\n// import {Assert} from '../../../utils/assert'\n/** this class nudges the edges, sorts the edges that run in parallel in a way that minimezes the number of crossings*/\nexport class EdgeNudger extends Algorithm {\n    // Constructor\n    constructor(metroGraphData, bundlingSettings) {\n        super(null);\n        this.metroGraphData = metroGraphData;\n        this.bundlingSettings = bundlingSettings;\n    }\n    run() {\n        this.CreateMetroOrdering();\n        this.InitRadii();\n        this.FinalizePaths();\n    }\n    InitRadii() {\n        new HubRadiiCalculator(this.metroGraphData, this.bundlingSettings).CreateNodeRadii();\n    }\n    // bundle-map ordering\n    CreateMetroOrdering() {\n        this.metroOrdering = new GeneralMetroMapOrdering(this.metroGraphData.Metrolines);\n    }\n    FinalizePaths() {\n        this.CreateBundleBases();\n        this.CreateSegmentsInsideHubs();\n        this.CreateCurves();\n    }\n    CreateBundleBases() {\n        const bbCalc = new BundleBasesCalculator(this.metroOrdering, this.metroGraphData, this.bundlingSettings);\n        bbCalc.Run();\n    }\n    CreateCurves() {\n        //Assert.assert(this.metroGraphData.Metrolines.length === this.metroGraphData.Edges.length)\n        for (let i = 0; i < this.metroGraphData.Metrolines.length; i++) {\n            this.CreateCurveLine(this.metroGraphData.Metrolines[i], this.metroGraphData.Edges[i]);\n        }\n    }\n    CreateCurveLine(line, edge) {\n        const c = new Curve();\n        const start = EdgeNudger.FindCurveStart(this.metroGraphData, this.metroOrdering, line);\n        let currentEnd = start;\n        const hubSegsOfLine = EdgeNudger.HubSegsOfLine(this.metroGraphData, this.metroOrdering, line);\n        for (const seg of hubSegsOfLine) {\n            if (seg == null) {\n                continue;\n            }\n            c.addSegment(LineSegment.mkPP(currentEnd, seg.start));\n            c.addSegment(seg);\n            currentEnd = seg.end;\n        }\n        c.addSegment(LineSegment.mkPP(currentEnd, EdgeNudger.FindCurveEnd(this.metroGraphData, this.metroOrdering, line)));\n        edge.curve = c;\n    }\n    static FindCurveStart(metroGraphData, metroOrdering, metroline) {\n        const u = metroGraphData.PointToStations.get(metroline.Polyline.startPoint.point);\n        const v = metroGraphData.PointToStations.get(metroline.Polyline.startPoint.next.point);\n        const bb = u.BundleBases.get(v);\n        const index = !bb.IsParent\n            ? metroOrdering.GetLineIndexInOrder(v, u, metroline)\n            : metroOrdering.GetLineIndexInOrder(u, v, metroline);\n        return bb.Points[index];\n    }\n    static FindCurveEnd(metroGraphData, metroOrdering, metroline) {\n        const u = metroGraphData.PointToStations.get(metroline.Polyline.endPoint.prev.point);\n        const v = metroGraphData.PointToStations.get(metroline.Polyline.endPoint.point);\n        const bb = v.BundleBases.get(u);\n        const index = !bb.IsParent ? metroOrdering.GetLineIndexInOrder(u, v, metroline) : metroOrdering.GetLineIndexInOrder(v, u, metroline);\n        return bb.Points[index];\n    }\n    static *HubSegsOfLine(metroGraphData, metroOrdering, line) {\n        for (let i = line.Polyline.startPoint.next; i.next != null; i = i.next)\n            yield EdgeNudger.SegOnLineVertex(metroGraphData, metroOrdering, line, i);\n    }\n    static SegOnLineVertex(metroGraphData, metroOrdering, line, i) {\n        const u = metroGraphData.PointToStations.get(i.prev.point);\n        const v = metroGraphData.PointToStations.get(i.point);\n        const h0 = v.BundleBases.get(u);\n        const j0 = metroOrdering.GetLineIndexInOrder(u, v, line);\n        if (h0.OrientedHubSegments[j0] == null || h0.OrientedHubSegments[j0].Segment == null) {\n            const w = metroGraphData.PointToStations.get(i.next.point);\n            const otherBase = v.BundleBases.get(w);\n            const j1 = metroOrdering.GetLineIndexInOrder(w, v, line);\n            return LineSegment.mkPP(h0.Points[j0], otherBase.Points[j1]);\n        }\n        return h0.OrientedHubSegments[j0].Segment;\n    }\n    CreateSegmentsInsideHubs() {\n        for (const metroline of this.metroGraphData.Metrolines) {\n            this.CreateOrientedSegsOnLine(metroline);\n        }\n        if (this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs) {\n            this.FanBezierSegs();\n        }\n    }\n    CreateOrientedSegsOnLine(line) {\n        for (let polyPoint = line.Polyline.startPoint.next; polyPoint.next != null; polyPoint = polyPoint.next) {\n            this.CreateICurveForOrientedSeg(line, polyPoint);\n        }\n    }\n    CreateICurveForOrientedSeg(line, polyPoint) {\n        const u = this.metroGraphData.PointToStations.get(polyPoint.prev.point);\n        const v = this.metroGraphData.PointToStations.get(polyPoint.point);\n        const w = this.metroGraphData.PointToStations.get(polyPoint.next.point);\n        const h0 = v.BundleBases.get(u);\n        const h1 = v.BundleBases.get(w);\n        const j0 = this.metroOrdering.GetLineIndexInOrder(u, v, line);\n        const j1 = this.metroOrdering.GetLineIndexInOrder(w, v, line);\n        const seg = this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs\n            ? EdgeNudger.StandardBezier(h0.Points[j0], h0.Tangents[j0], h1.Points[j1], h1.Tangents[j1])\n            : EdgeNudger.BiArc(h0.Points[j0], h0.Tangents[j0], h1.Points[j1], h1.Tangents[j1]);\n        h0.OrientedHubSegments[j0].Segment = seg;\n        h1.OrientedHubSegments[j1].Segment = seg;\n        // if (seg instanceof BezierSeg) {\n        //  const dc = [\n        //    DebugCurve.mkDebugCurveTWCI(200, 1, 'Blue', LineSegment.mkPP(h1.Points[0], h1.Points[h1.length - 1])),\n        //    DebugCurve.mkDebugCurveTWCI(200, 1, 'Black', LineSegment.mkPP(h0.Points[0], h0.Points[h0.length - 1])),\n        //    DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Red', LineSegment.mkPP(h0.Points[j0], h0.Points[j0].add(h0.Tangents[j0]))),\n        //    DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Green', LineSegment.mkPP(h1.Points[j1], h1.Points[j1].add(h1.Tangents[j1]))),\n        //  ]\n        //  dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.1, 'Brown', seg))\n        //  dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Pink', line.Polyline))\n        //  dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Tan', u.BoundaryCurve))\n        //  dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Plum', v.BoundaryCurve))\n        //  dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'DarkOrange', w.BoundaryCurve))\n        //  SvgDebugWriter.dumpDebugCurves('./tmp/hubs' + EdgeNudger.debCount + '.svg', dc)\n        // }\n    }\n    static ShowHubs(metroGraphData, metroMapOrdering, station, fileName, moreCurves = []) {\n        let ttt = EdgeNudger.GetAllDebugCurves(metroMapOrdering, metroGraphData);\n        if (station != null) {\n            ttt.push(DebugCurve.mkDebugCurveTWCI(255, 1, 'red', CurveFactory.mkDiamond(5, 25, station.Position)));\n        }\n        ttt = ttt.concat(moreCurves);\n        // SvgDebugWriter.dumpDebugCurves(fileName, ttt) // uncomment this line to get the SVG output\n    }\n    static GetAllDebugCurves(metroMapOrdering, metroGraphData) {\n        return EdgeNudger.GraphNodes(metroGraphData)\n            .concat(EdgeNudger.VertexDebugCurves(metroMapOrdering, metroGraphData))\n            .concat(EdgeNudger.DebugEdges(metroGraphData));\n    }\n    static DebugEdges(metroGraphData1) {\n        return metroGraphData1.Edges.map((e) => DebugCurve.mkDebugCurveTWCI(40, 0.1, 'gray', e.curve));\n    }\n    static VertexDebugCurves(metroMapOrdering, metroGraphData) {\n        return EdgeNudger.DebugCircles(metroGraphData)\n            .concat(EdgeNudger.DebugHubBases(metroGraphData))\n            .concat(EdgeNudger.DebugSegs(metroGraphData))\n            .concat(EdgeNudger.BetweenHubs(metroMapOrdering, metroGraphData));\n    }\n    static BetweenHubs(metroMapOrdering, metroGraphData) {\n        const ret = [];\n        for (const ml of metroGraphData.Metrolines) {\n            const segs = EdgeNudger.GetInterestingSegs(metroGraphData, metroMapOrdering, ml);\n            const color = EdgeNudger.GetMonotoneColor(ml.Polyline.start, ml.Polyline.end, segs);\n            for (const seg of segs) {\n                ret.push(DebugCurve.mkDebugCurveTWCI(100, ml.Width, color, LineSegment.mkPP(seg[0], seg[1])));\n            }\n        }\n        return ret;\n    }\n    static GetInterestingSegs(metroGraphData, metroMapOrdering, line) {\n        const ret = new Array();\n        if (metroGraphData.Stations.length === 0 ||\n            metroGraphData.Stations[0].BundleBases == null ||\n            metroGraphData.Stations[0].BundleBases.size === 0)\n            return [];\n        let start = EdgeNudger.FindCurveStart(metroGraphData, metroMapOrdering, line);\n        const cubicSegs = EdgeNudger.HubSegsOfLine(metroGraphData, metroMapOrdering, line);\n        for (const seg of cubicSegs) {\n            if (seg == null) {\n                continue;\n            }\n            ret.push([start, seg.start]);\n            start = seg.end;\n        }\n        ret.push([start, EdgeNudger.FindCurveEnd(metroGraphData, metroMapOrdering, line)]);\n        return ret;\n    }\n    static GetMonotoneColor(start, end, segs) {\n        return 'green';\n        //            Point dir = end - start;\n        //            bool monotone = segs.All(seg => (seg.Second - seg.First)*dir >= 0);\n        //            return monotone ? \"green\" : \"magenta\";\n    }\n    static DebugHubBases(metroGraphData) {\n        const dc = new Array();\n        for (const s of metroGraphData.Stations) {\n            for (const h of s.BundleBases.values()) {\n                dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'red', LineSegment.mkPP(h.EndPoint, h.StartPoint)));\n            }\n        }\n        return dc;\n        // return\n        //    metroGraphData.Stations.SelectMany(s => s.BundleBases.Values).Select(\n        //        h => new DebugCurve(100, 0.01, \"red\", new LineSegment(h.Points[0], h.Points.Last())));\n    }\n    static DebugCircles(metroGraphData) {\n        return metroGraphData.Stations.map((station) => DebugCurve.mkDebugCurveTWCI(100, 0.1, 'blue', CurveFactory.mkCircle(station.Radius, station.Position)));\n    }\n    static DebugSegs(metroGraphData) {\n        const ls = new Array();\n        for (const s of metroGraphData.VirtualStations()) {\n            for (const b of s.BundleBases.values()) {\n                for (const h of b.OrientedHubSegments) {\n                    if (h == null) {\n                        continue;\n                    }\n                    if (h.Segment == null) {\n                        const uBase = h.Other.BundleBase;\n                        const i = h.Index;\n                        const j = h.Other.Index;\n                        ls.push(LineSegment.mkPP(b.Points[i], uBase.Points[j]));\n                    }\n                    else {\n                        ls.push(h.Segment);\n                    }\n                }\n            }\n        }\n        return ls.map((s) => DebugCurve.mkDebugCurveTWCI(100, 0.01, 'green', s));\n    }\n    static GraphNodes(metroGraphData) {\n        const nodes = metroGraphData.Edges.map((e) => e.sourcePort.Curve).concat(metroGraphData.Edges.map((e) => e.targetPort.Curve));\n        return nodes.map((n) => DebugCurve.mkDebugCurveTWCI(40, 1, 'black', n));\n    }\n    static BiArc(p0, ts, p4, te) {\n        //Assert.assert(closeDistEps(ts.lengthSquared, 1))\n        //Assert.assert(closeDistEps(te.lengthSquared, 1))\n        const v = p0.sub(p4);\n        if (v.length < GeomConstants.distanceEpsilon)\n            return null;\n        const vtse = v.dot(ts.sub(te));\n        const tste = -ts.dot(te);\n        //bad input for BiArc. we shouldn't allow such cases during bundle bases construction\n        if (ts.dot(p4.sub(p0)) <= 0 && ts.dot(te) <= 0) {\n            //switch to Bezier\n            return EdgeNudger.StandardBezier(p0, ts, p4, te);\n        }\n        //solving a quadratic equation\n        const a = 2 * (tste - 1);\n        const b = 2 * vtse;\n        const c = v.dot(v);\n        let al;\n        if (Math.abs(a) < GeomConstants.distanceEpsilon) {\n            //we have b*al+c=0\n            if (Math.abs(b) > GeomConstants.distanceEpsilon) {\n                al = -c / b;\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            let d = b * b - 4 * a * c;\n            //Assert.assert(d >= -GeomConstants.tolerance)\n            if (d < 0)\n                d = 0;\n            d = Math.sqrt(d);\n            al = (-b + d) / (2 * a);\n            if (al < 0)\n                al = (-b - d) / (2 * a);\n        }\n        const p1 = p0.add(ts.mul(al));\n        const p3 = p4.add(te.mul(al));\n        const p2 = Point.middle(p1, p3);\n        const orient1 = Point.getTriangleOrientation(p0, p1, p2);\n        const orient2 = Point.getTriangleOrientation(p2, p3, p4);\n        if (orient1 !== orient2) {\n            return EdgeNudger.StandardBezier(p0, ts, p4, te);\n        }\n        const curve = new Curve();\n        curve.addSegs([EdgeNudger.ArcOn(p0, p1, p2), EdgeNudger.ArcOn(p2, p3, p4)]);\n        return curve;\n    }\n    // returns the arc that a,b,c touches\n    static ArcOn(a, b, c) {\n        const t = { center: null };\n        if (Math.abs(Point.signedDoubledTriangleArea(a, b, c)) < 0.0001 || !EdgeNudger.FindArcCenter(a, b, c, t)) {\n            return LineSegment.mkPP(a, c);\n        }\n        const center = t.center;\n        const radius = distPP(a, center);\n        const chordLength = distPP(a, b);\n        if (chordLength / radius < 0.0001) {\n            return LineSegment.mkPP(a, c);\n        }\n        const cenA = a.sub(center);\n        let aAngle = Math.atan2(cenA.y, cenA.x);\n        const cenC = c.sub(center);\n        let cAngle = Math.atan2(cenC.y, cenC.x);\n        let delac = cAngle - aAngle;\n        if (delac < 0) {\n            delac += 2 * Math.PI;\n            cAngle += 2 * Math.PI;\n        }\n        if (delac <= Math.PI) {\n            // going ccw\n            const el = new Ellipse(aAngle, cAngle, new Point(radius, 0), new Point(0, radius), center);\n            return el;\n        }\n        // going clockwise\n        if (cAngle > 2 * Math.PI) {\n            cAngle -= 2 * Math.PI;\n        }\n        aAngle = Math.PI - aAngle;\n        cAngle = Math.PI - cAngle;\n        if (aAngle < 0) {\n            aAngle += 2 * Math.PI;\n        }\n        while (cAngle < aAngle) {\n            cAngle += 2 * Math.PI;\n        }\n        delac = cAngle - aAngle;\n        //Assert.assert(delac <= Math.PI)\n        return new Ellipse(aAngle, cAngle, new Point(-radius, 0), new Point(0, radius), center);\n    }\n    static FindArcCenter(a, b, c, t) {\n        const perp0 = b.sub(a).rotate90Cw();\n        const perp1 = b.sub(c).rotate90Cw();\n        t.center = Point.lineLineIntersection(a, a.add(perp0), c, c.add(perp1));\n        return t.center != null;\n    }\n    static StandardBezier(segStart, tangentAtStart, segEnd, tangentAtEnd) {\n        const len = distPP(segStart, segEnd) / 4;\n        return BezierSeg.mkBezier([segStart, segStart.add(tangentAtStart.mul(len)), segEnd.add(tangentAtEnd.mul(len)), segEnd]);\n    }\n    FanBezierSegs() {\n        let progress = true;\n        const maxSteps = 5;\n        let steps = 0;\n        while (progress && steps++ < maxSteps) {\n            progress = false;\n            for (const s of this.metroGraphData.Stations)\n                for (const segmentHub of s.BundleBases.values())\n                    progress || (progress = this.FanEdgesOfHubSegment(segmentHub));\n        }\n    }\n    FanEdgesOfHubSegment(bundleHub) {\n        let ret = false;\n        for (let i = 0; i < bundleHub.Count - 1; i++) {\n            ret || (ret = this.FanCouple(bundleHub, i, bundleHub.CurveCenter, bundleHub.Curve.boundingBox.diagonal / 2));\n        }\n        return ret;\n    }\n    // fans the couple i,i+1\n    FanCouple(bundleHub, i, center, radius) {\n        const lSeg = bundleHub.OrientedHubSegments[i];\n        const rSeg = bundleHub.OrientedHubSegments[i + 1];\n        if (lSeg == null) {\n            return false;\n        }\n        const x = segmentsIntersect(lSeg.Segment.start, lSeg.Segment.end, rSeg.Segment.start, rSeg.Segment.end);\n        if (x) {\n            // it doesn not make sense to push these segs apart\n            return false;\n        }\n        if (Point.getTriangleOrientation(lSeg.value(0), lSeg.value(0.5), lSeg.value(1)) !=\n            Point.getTriangleOrientation(rSeg.value(0), rSeg.value(0.5), rSeg.value(1))) {\n            return false;\n        }\n        const ll = this.BaseLength(lSeg);\n        const rl = this.BaseLength(rSeg);\n        if (Math.abs(ll - rl) < GeomConstants.intersectionEpsilon) {\n            return false;\n        }\n        if (ll > rl) {\n            return this.AdjustLongerSeg(lSeg, rSeg, center, radius);\n        }\n        return this.AdjustLongerSeg(rSeg, lSeg, center, radius);\n    }\n    AdjustLongerSeg(longerSeg, shorterSeg, center, radius) {\n        const del0 = longerSeg.value(0).sub(shorterSeg.value(0));\n        const del1 = longerSeg.value(1).sub(shorterSeg.value(1));\n        const minDelLength = Math.min(del0.length, del1.length);\n        const midPointOfShorter = shorterSeg.value(0.5);\n        const maxDelLen = Math.max(del0.length, del1.length);\n        if (this.NicelyAligned(longerSeg.Segment, del0, del1, midPointOfShorter, minDelLength, maxDelLen) === 0) {\n            return false;\n        }\n        return this.FitLonger(longerSeg, del0, del1, midPointOfShorter, minDelLength, maxDelLen, center, radius);\n    }\n    FitLonger(longerOrientedSeg, del0, del1, midPointOfShorter, minDelLength, maxDel, center, radius) {\n        let seg = longerOrientedSeg.Segment;\n        const start = seg.start;\n        const end = seg.end;\n        // LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve(\"green\", shorterDebugOnly), new DebugCurve(\"red\", seg));\n        let steps = 0;\n        const maxSteps = 10;\n        let lowP1 = seg.start.mul(1 - EdgeNudger.SqueezeBound).add(seg.B(1).mul(EdgeNudger.SqueezeBound));\n        let lowP2 = seg.end.mul(1 - EdgeNudger.SqueezeBound).add(seg.B(2).mul(EdgeNudger.SqueezeBound));\n        let highP1 = seg.B(1).mul(2).sub(seg.start);\n        // originally the tangents were 0.25 of the length of seg[1]-seg[0] - so were are safe to lengthen two times\n        let highP2 = seg.B(2).mul(2).sub(seg.end);\n        const t = { highP: highP1 };\n        this.PullControlPointToTheCircle(seg.start, t, center, radius);\n        highP1 = t.highP;\n        let r = this.NicelyAligned(seg, del0, del1, midPointOfShorter, minDelLength, maxDel);\n        do {\n            if (r === -1) {\n                // pull the control points lower\n                const p1 = Point.middle(seg.B(1), lowP1);\n                const p2 = Point.middle(seg.B(2), lowP2);\n                highP1 = seg.B(1);\n                highP2 = seg.B(2);\n                seg = new BezierSeg(start, p1, p2, end);\n            }\n            else {\n                //Assert.assert(r === 1)\n                // pull the control points higher\n                const p1 = Point.middle(seg.B(1), highP1);\n                const p2 = (seg.B(2), highP2);\n                lowP1 = seg.B(1);\n                lowP2 = seg.B(2);\n                seg = new BezierSeg(start, p1, p2, end);\n            }\n            if ((r = this.NicelyAligned(seg, del0, del1, midPointOfShorter, minDelLength, maxDel)) === 0) {\n                longerOrientedSeg.Segment = seg;\n                longerOrientedSeg.Other.Segment = seg;\n                return true;\n            }\n            if (steps++ > maxSteps)\n                return false; //cannot fix it\n            // cannot fix it\n        } while (true);\n    }\n    PullControlPointToTheCircle(start, t, center, radius) {\n        const closestPointOnLine = Point.ProjectionToLine(start, t.highP, center);\n        // the max offset from closestPointOnLine\n        const maxOffset = Math.sqrt(radius * radius - closestPointOnLine.sub(center).lengthSquared);\n        const offsetNow = t.highP.sub(closestPointOnLine);\n        const offsetLen = offsetNow.length;\n        if (offsetLen > maxOffset) {\n            t.highP = closestPointOnLine.add(offsetNow.mul(maxOffset / offsetLen));\n        }\n    }\n    //\n    NicelyAligned(longerSeg, del0, del1, midPointOfShorter, minDelLength, maxDelLen) {\n        const eps = 0.001;\n        const midDel = longerSeg.value(0.5).sub(midPointOfShorter);\n        const midDelLen = midDel.length;\n        if (del0.dot(midDel) < 0 || del1.dot(midDel) < 0) {\n            return 1;\n        }\n        if (midDelLen < minDelLength - eps) {\n            return 1;\n        }\n        if (midDelLen > maxDelLen + eps) {\n            return -1;\n        }\n        return 0;\n    }\n    BaseLength(seg) {\n        return seg.value(0).sub(seg.value(1)).lengthSquared;\n    }\n}\n/* const */ EdgeNudger.SqueezeBound = 0.2;\n//# sourceMappingURL=EdgeNudger.js.map","import { Queue } from 'queue-typescript';\nimport { PolylinePoint } from '../../../math/geometry/polylinePoint';\nimport { PointMap } from '../../../utils/PointMap';\nimport { PointSet } from '../../../utils/PointSet';\nimport { setsAreEqual } from '../../../utils/setOperations';\nimport { getOrientationOf3Vectors } from './MetroGraphData';\nimport { PathFixer } from './PathFixer';\nexport class FlipSwitcher {\n    get Polylines() {\n        return Array.from(this.polylineToEdgeGeom.keys());\n    }\n    constructor(metroGraphData) {\n        this.polylineToEdgeGeom = new Map();\n        this.pathsThroughPoints = new PointMap();\n        this.interestingPoints = new PointSet();\n        this.metroGraphData = metroGraphData;\n    }\n    Run() {\n        // TimeMeasurer.DebugOutput(\"switching flips...\");\n        this.Init();\n        this.SwitchFlips();\n    }\n    Init() {\n        for (const e of this.metroGraphData.Edges) {\n            this.polylineToEdgeGeom.set(e.curve, e);\n        }\n        for (const poly of this.Polylines) {\n            this.RegisterPolylinePointInPathsThrough(poly.polylinePoints());\n        }\n    }\n    RegisterPolylinePointInPathsThrough(points) {\n        for (const pp of points)\n            this.RegisterPolylinePointInPathsThroughP(pp);\n    }\n    RegisterPolylinePointInPathsThroughP(pp) {\n        addToPointMap(this.pathsThroughPoints, pp.point, pp);\n    }\n    UnregisterPolylinePointsInPathsThrough(points) {\n        for (const pp of points)\n            this.UnregisterPolylinePointInPathsThrough(pp);\n    }\n    UnregisterPolylinePointInPathsThrough(pp) {\n        removeFromPointMap(this.pathsThroughPoints, pp.point, pp);\n    }\n    SwitchFlips() {\n        const queued = new Set(this.Polylines);\n        const queue = new Queue();\n        for (const e of this.Polylines) {\n            queue.enqueue(e);\n        }\n        while (queue.length > 0) {\n            const initialPolyline = queue.dequeue();\n            queued.delete(initialPolyline);\n            const changedPolyline = this.ProcessPolyline(initialPolyline);\n            if (changedPolyline != null) {\n                // we changed both polylines\n                if (!queued.has(initialPolyline)) {\n                    queued.add(initialPolyline);\n                    queue.enqueue(initialPolyline);\n                }\n                if (!queued.has(changedPolyline)) {\n                    queued.add(changedPolyline);\n                    queue.enqueue(changedPolyline);\n                }\n            }\n        }\n    }\n    ProcessPolyline(polyline) {\n        const departed = new Map();\n        for (let pp = polyline.startPoint.next; pp != null; pp = pp.next) {\n            this.FillDepartedPolylinePoints(pp, departed);\n            // find returning\n            for (const polyPoint of this.pathsThroughPoints.get(pp.point)) {\n                const departingPP = departed.get(polyPoint.polyline);\n                if (departingPP) {\n                    if (this.ProcessFlip(pp, departingPP)) {\n                        return polyPoint.polyline;\n                    }\n                    departed.delete(polyPoint.polyline);\n                }\n            }\n        }\n        return null;\n    }\n    FillDepartedPolylinePoints(pp, departed) {\n        const prevPoint = pp.prev.point;\n        for (const polyPoint of this.pathsThroughPoints.get(prevPoint)) {\n            if (!this.IsNeighborOnTheSamePolyline(polyPoint, pp)) {\n                if (!departed.has(polyPoint.polyline)) {\n                    departed.set(polyPoint.polyline, polyPoint);\n                }\n            }\n        }\n    }\n    ProcessFlip(flipStartPP, flipEndPP) {\n        // temporary switching polylines of the same width only\n        // need to check capacities here\n        const polyA = flipStartPP.polyline;\n        const polyB = flipEndPP.polyline;\n        const flipStart = flipStartPP.point;\n        const flipEnd = flipEndPP.point;\n        const ea = this.polylineToEdgeGeom.get(polyA);\n        const eb = this.polylineToEdgeGeom.get(polyB);\n        if (ea.lineWidth !== eb.lineWidth ||\n            this.metroGraphData.EdgeLooseEnterable == null ||\n            !setsAreEqual(this.metroGraphData.EdgeLooseEnterable.get(ea), this.metroGraphData.EdgeLooseEnterable.get(eb))) {\n            return false;\n        }\n        //    polyA.init()\n        // polyB.init()\n        // FlipSwitcher.debugCount++\n        // if (FlipSwitcher.debugCount === 3) {\n        //  const da = DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', polyA)\n        //  const aStart = DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', CurveFactory.mkCircle(10, polyA.start))\n        //  const aEnd = DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', CurveFactory.mkCircle(5, polyA.end))\n        //  const db = DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Blue', polyB)\n        //  const bStart = DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Blue', CurveFactory.mkCircle(4, polyB.start))\n        //  const bEnd = DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Blue', CurveFactory.mkCircle(2, polyB.end))\n        //  SvgDebugWriter.dumpDebugCurves('./tmp/dadb_.svg', [da, db, aStart, aEnd, bStart, bEnd])\n        //  //   throw new Error()\n        // }\n        let pts = this.FindPointsOnPolyline(polyA, flipStart, flipEnd);\n        const aFirst = pts[0];\n        const aLast = pts[1];\n        const forwardOrderA = pts[2];\n        pts = this.FindPointsOnPolyline(polyB, flipStart, flipEnd);\n        const bFirst = pts[0];\n        const bLast = pts[1];\n        const forwardOrderB = pts[2];\n        //Assert.assert(this.PolylinePointsAreInForwardOrder(aFirst, aLast) === forwardOrderA)\n        //Assert.assert(this.PolylinePointsAreInForwardOrder(bFirst, bLast) === forwardOrderB)\n        // 0 - the end\n        // 1 - not intersect\n        // 2 - intersect\n        const rel1 = this.FindRelationOnFirstPoint(aFirst, bFirst, forwardOrderA, forwardOrderB);\n        const rel2 = this.FindRelationOnLastPoint(aLast, bLast, forwardOrderA, forwardOrderB);\n        // no intersection on both sides\n        if (rel1 !== 2 && rel2 !== 2) {\n            return false;\n        }\n        // can't swap to reduce crossings\n        if (rel1 === 1 || rel2 === 1) {\n            return false;\n        }\n        // unregister\n        this.UnregisterPolylinePointsInPathsThrough(polyA.polylinePoints());\n        this.UnregisterPolylinePointsInPathsThrough(polyB.polylinePoints());\n        // switching\n        this.Swap(aFirst, bFirst, aLast, bLast, forwardOrderA, forwardOrderB);\n        // register back\n        this.RegisterPolylinePointInPathsThrough(polyA.polylinePoints());\n        this.RegisterPolylinePointInPathsThrough(polyB.polylinePoints());\n        this.RegisterInterestingPoint(aFirst.point);\n        this.RegisterInterestingPoint(aLast.point);\n        this.numberOfReducedCrossings++;\n        return true;\n    }\n    FindPointsOnPolyline(polyline, first, last) {\n        let ppFirst;\n        let ppLast;\n        for (let pp = polyline.startPoint; pp != null; pp = pp.next) {\n            if (ppFirst == null) {\n                if (pp.point.equal(first)) {\n                    if (ppLast != null) {\n                        return [pp, ppLast, false];\n                    }\n                    ppFirst = pp;\n                }\n                else {\n                    if (ppLast == null && pp.point.equal(last)) {\n                        ppLast = pp;\n                    }\n                }\n            }\n            else {\n                // got ppFirst arleady\n                if (pp.point.equal(last)) {\n                    return [ppFirst, pp, true];\n                }\n            }\n        }\n        //Assert.assert(false)\n    }\n    PolylinePointsAreInForwardOrder(u, v) {\n        //Assert.assert(u.polyline === v.polyline)\n        for (let p = u; p != null; p = p.next) {\n            if (p === v) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Next(p, forwardOrder) {\n        return forwardOrder ? p.next : p.prev;\n    }\n    Prev(p, forwardOrder) {\n        return forwardOrder ? p.prev : p.next;\n    }\n    FindRelationOnFirstPoint(aFirst, bFirst, forwardOrderA, forwardOrderB) {\n        //Assert.assert(aFirst.point.equal(bFirst.point))\n        const a0 = aFirst;\n        const b0 = bFirst;\n        while (true) {\n            const prevA = this.Prev(aFirst, forwardOrderA);\n            const prevB = this.Prev(bFirst, forwardOrderB);\n            if (prevA == null || prevB == null) {\n                //Assert.assert(prevA == null  && prevB == null )\n                return 0;\n            }\n            if (!prevA.point.equal(prevB.point)) {\n                break;\n            }\n            aFirst = prevA;\n            bFirst = prevB;\n        }\n        return this.PolylinesIntersect(a0, b0, aFirst, bFirst, forwardOrderA, forwardOrderB);\n    }\n    FindRelationOnLastPoint(aLast, bLast, forwardOrderA, forwardOrderB) {\n        //Assert.assert(aLast.point.equal(bLast.point))\n        const a0 = aLast;\n        const b0 = bLast;\n        while (true) {\n            const nextA = this.Next(aLast, forwardOrderA);\n            const nextB = this.Next(bLast, forwardOrderB);\n            if (nextA == null || nextB == null) {\n                //Assert.assert(nextA == null  && nextB == null )\n                return 0;\n            }\n            if (!nextA.point.equal(nextB.point)) {\n                break;\n            }\n            aLast = nextA;\n            bLast = nextB;\n        }\n        while (this.Next(aLast, forwardOrderA).point.equal(this.Prev(bLast, forwardOrderB).point)) {\n            aLast = this.Next(aLast, forwardOrderA);\n            bLast = this.Prev(bLast, forwardOrderB);\n        }\n        return this.PolylinesIntersect(aLast, bLast, a0, b0, forwardOrderA, forwardOrderB);\n    }\n    PolylinesIntersect(a0, b0, a1, b1, forwardOrderA, forwardOrderB) {\n        const a0p = this.Prev(a0, forwardOrderA);\n        const a0n = this.Next(a0, forwardOrderA);\n        const a1n = this.Next(a1, forwardOrderA);\n        const a1p = this.Prev(a1, forwardOrderA);\n        const b0n = this.Next(b0, forwardOrderB);\n        const b1p = this.Prev(b1, forwardOrderB);\n        if (a0.point.equal(a1.point)) {\n            const bs = a0.point;\n            const left0 = getOrientationOf3Vectors(a1p.point.sub(bs), b1p.point.sub(bs), a0n.point.sub(bs));\n            const left1 = getOrientationOf3Vectors(a1p.point.sub(bs), b0n.point.sub(bs), a0n.point.sub(bs));\n            //Assert.assert(left0 !== 0 && left1 !== 0)\n            return left0 === left1 ? 1 : 2;\n        }\n        else {\n            const left0 = getOrientationOf3Vectors(a0p.point.sub(a0.point), a0n.point.sub(a0.point), b0n.point.sub(a0.point));\n            const left1 = getOrientationOf3Vectors(a1n.point.sub(a1.point), b1p.point.sub(a1.point), a1p.point.sub(a1.point));\n            //Assert.assert(left0 !== 0 && left1 !== 0)\n            return left0 === left1 ? 1 : 2;\n        }\n    }\n    Swap(aFirst, bFirst, aLast, bLast, forwardOrderA, forwardOrderB) {\n        const intermediateAPoints = this.GetRangeOnPolyline(this.Next(aFirst, forwardOrderA), aLast, forwardOrderA);\n        const intermediateBPoints = this.GetRangeOnPolyline(this.Next(bFirst, forwardOrderB), bLast, forwardOrderB);\n        // changing a\n        this.ChangePolylineSegment(aFirst, aLast, forwardOrderA, intermediateBPoints);\n        // changing b\n        this.ChangePolylineSegment(bFirst, bLast, forwardOrderB, intermediateAPoints);\n        // resulting polylines might have cycles\n        PathFixer.RemoveSelfCyclesFromPolyline(aFirst.polyline);\n        //Assert.assert(this.PolylineIsOK(aFirst.polyline))\n        PathFixer.RemoveSelfCyclesFromPolyline(bFirst.polyline);\n        //Assert.assert(this.PolylineIsOK(bFirst.polyline))\n    }\n    ChangePolylineSegment(aFirst, aLast, forwardOrderA, intermediateBPoints) {\n        let curA = aFirst;\n        for (const b of intermediateBPoints) {\n            const newp = PolylinePoint.mkFromPoint(b.point);\n            newp.polyline = curA.polyline;\n            if (forwardOrderA) {\n                newp.prev = curA;\n                curA.next = newp;\n            }\n            else {\n                newp.next = curA;\n                curA.prev = newp;\n            }\n            curA = newp;\n        }\n        if (forwardOrderA) {\n            curA.next = aLast;\n            aLast.prev = curA;\n        }\n        else {\n            curA.prev = aLast;\n            aLast.next = curA;\n        }\n    }\n    GetRangeOnPolyline(start, end, forwardOrder) {\n        const res = new Array();\n        for (let pp = start; pp !== end; pp = this.Next(pp, forwardOrder)) {\n            res.push(pp);\n        }\n        return res;\n    }\n    IsNeighborOnTheSamePolyline(a, b) {\n        return (a.prev != null && a.prev.point.equal(b.point)) || (a.next != null && a.next.point.equal(b.point));\n    }\n    RegisterInterestingPoint(p) {\n        if (!this.interestingPoints.has(p)) {\n            this.interestingPoints.add(p);\n        }\n    }\n    GetChangedHubs() {\n        return this.interestingPoints;\n    }\n    NumberOfReducedCrossings() {\n        return this.numberOfReducedCrossings;\n    }\n    PolylineIsOK(poly) {\n        const pointsToPP = new PointSet();\n        for (let pp = poly.startPoint; pp != null; pp = pp.next) {\n            if (pp === poly.startPoint) {\n                if (pp.prev != null) {\n                    return false;\n                }\n            }\n            else if (pp.prev.next !== pp) {\n                return false;\n            }\n            if (pp === poly.endPoint) {\n                if (pp.next != null) {\n                    return false;\n                }\n            }\n            else if (pp.next.prev !== pp) {\n                return false;\n            }\n            if (pointsToPP.has(pp.point)) {\n                return false;\n            }\n            pointsToPP.add(pp.point);\n        }\n        if (poly.startPoint.prev != null) {\n            return false;\n        }\n        if (poly.endPoint.next != null) {\n            return false;\n        }\n        return true;\n    }\n}\nfunction addToPointMap(pointMap, point, pp) {\n    let s = pointMap.get(point);\n    if (!s) {\n        s = new Set();\n        pointMap.set(point, s);\n    }\n    s.add(pp);\n}\nfunction removeFromPointMap(pathsThroughPoints, point, pp) {\n    const s = pathsThroughPoints.get(point);\n    if (!s)\n        return;\n    s.delete(pp);\n    if (s.size === 0) {\n        pathsThroughPoints.deleteP(point);\n    }\n}\n//# sourceMappingURL=FlipSwitcher.js.map","import { PointPair } from '../../../math/geometry/pointPair';\nimport { compareNumbers } from '../../../utils/compare';\nimport { PointPairMap } from '../../../utils/pointPairMap';\nimport { getOrientationOf3Vectors } from './MetroGraphData';\nimport { PointPairOrder } from './PointPairOrder';\n// greedy bundle map ordering based on path comparison\nexport class GeneralMetroMapOrdering {\n    // Initialize bundle graph and build the ordering\n    constructor(Metrolines) {\n        this.Metrolines = Metrolines;\n        this.BuildOrder();\n    }\n    *GetOrder(u, v) {\n        const pointPair = new PointPair(u.Position, v.Position);\n        const orderedMetrolineListForUv = this.bundles.get(pointPair).Metrolines;\n        if (u.Position === pointPair.first) {\n            for (let i = 0; i < orderedMetrolineListForUv.length; i++) {\n                yield orderedMetrolineListForUv[i];\n            }\n        }\n        else {\n            for (let i = orderedMetrolineListForUv.length - 1; i >= 0; i--) {\n                yield orderedMetrolineListForUv[i];\n            }\n        }\n    }\n    /**   Get the index of line on the edge (u->v) and node u */\n    GetLineIndexInOrder(u, v, ml) {\n        const pp = new PointPair(u.Position, v.Position);\n        const reversed = u.Position !== pp.first; // we can use the object comparison here because there is no cloning in PointPair\n        const d = this.bundles.get(pp).LineIndexInOrder;\n        return !reversed ? d.get(ml) : d.size - 1 - d.get(ml);\n    }\n    /**   Do the main job */\n    BuildOrder() {\n        this.bundles = new PointPairMap();\n        // initialization\n        for (const ml of this.Metrolines) {\n            for (let p = ml.Polyline.startPoint; p.next != null; p = p.next) {\n                const e = new PointPair(p.point, p.next.point);\n                let li = this.bundles.get(e);\n                if (!li) {\n                    this.bundles.set(e, (li = new PointPairOrder()));\n                }\n                li.Add(ml);\n            }\n        }\n        for (const edge of this.bundles) {\n            this.BuildOrderPP(edge[0], edge[1]);\n        }\n    }\n    /**   Build an order for edge (u->v) */\n    BuildOrderPP(pair, order) {\n        if (order.orderFixed) {\n            return;\n        }\n        order.Metrolines.sort((line0, line1) => this.CompareLines(line0, line1, pair.first, pair.second));\n        // save order\n        order.orderFixed = true;\n        order.LineIndexInOrder = new Map();\n        for (let i = 0; i < order.Metrolines.length; i++) {\n            order.LineIndexInOrder.set(order.Metrolines[i], i);\n        }\n    }\n    /**   Compare two lines on station u with respect to edge (u->v) */\n    CompareLines(ml0, ml1, u, v) {\n        const t = { polyPoint: null, next: null, prev: null };\n        this.FindStationOnLine(u, v, ml0, t);\n        const polylinePoint0 = t.polyPoint;\n        const next0 = t.next;\n        const prev0 = t.prev;\n        this.FindStationOnLine(u, v, ml1, t);\n        const polylinePoint1 = t.polyPoint;\n        const next1 = t.next;\n        const prev1 = t.prev;\n        // go backward\n        let p0 = polylinePoint0;\n        let p1 = polylinePoint1;\n        let p11;\n        let p00;\n        while ((p00 = prev0(p0)) != null && (p11 = prev1(p1)) != null && p00.point.equal(p11.point)) {\n            const edge = new PointPair(p00.point, p0.point);\n            if (this.bundles.get(edge).orderFixed) {\n                return this.CompareOnFixedOrder(edge, ml0, ml1, !p00.point.equal(edge.first));\n            }\n            p0 = p00;\n            p1 = p11;\n        }\n        if (p00 != null && p11 != null) {\n            // we have a backward fork\n            const forkBase = p0.point;\n            return -GeneralMetroMapOrdering.IsLeft(next0(p0).point.sub(forkBase), p00.point.sub(forkBase), p11.point.sub(forkBase));\n        }\n        // go forward\n        p0 = polylinePoint0;\n        p1 = polylinePoint1;\n        while ((p00 = next0(p0)) != null && (p11 = next1(p1)) != null && p00.point.equal(p11.point)) {\n            const edge = new PointPair(p00.point, p0.point);\n            if (this.bundles.get(edge).orderFixed) {\n                return this.CompareOnFixedOrder(edge, ml0, ml1, !p0.point.equal(edge.first));\n            }\n            p0 = p00;\n            p1 = p11;\n        }\n        if (p00 != null && p11 != null) {\n            // compare forward fork\n            const forkBase = p0.point;\n            return GeneralMetroMapOrdering.IsLeft(prev0(p0).point.sub(forkBase), p00.point.sub(forkBase), p11.point.sub(forkBase));\n        }\n        // these are multiple edges\n        return compareNumbers(ml0.Index, ml1.Index);\n    }\n    CompareOnFixedOrder(edge, ml0, ml1, reverse) {\n        const mlToIndex = this.bundles.get(edge).LineIndexInOrder;\n        const r = reverse ? -1 : 1;\n        return r * compareNumbers(mlToIndex.get(ml0), mlToIndex.get(ml1));\n    }\n    /** Fills Next and Prev functions according to the direction of the metroline */\n    // todo?  Reimplement it in more efficient way!!! (cache indexes)\n    FindStationOnLine(u, v, ml, t) {\n        for (let p = ml.Polyline.startPoint; p.next != null; p = p.next) {\n            if (p.point.equal(u) && p.next.point.equal(v)) {\n                t.next = (k) => k.next;\n                t.prev = (k) => k.prev;\n                t.polyPoint = p;\n                return;\n            }\n            if (p.point.equal(v) && p.next.point.equal(u)) {\n                t.next = (k) => k.prev;\n                t.prev = (k) => k.next;\n                t.polyPoint = p.next;\n                return;\n            }\n        }\n        throw new Error();\n    }\n    /**  computes orientation of three vectors with a common source\n       (compare the polar angles of v1 and v2 with respect to v0),\n        return -1 if the orientation is v0 v1 v2,\n                 1 if the orientation is v0 v2 v1,\n                 0  if v1 and v2 are collinear and codirectinal, TODO: seems fishy */\n    static IsLeft(v0, v1, v2) {\n        return getOrientationOf3Vectors(v0, v1, v2);\n    }\n}\n//# sourceMappingURL=GeneralMetroMapOrdering.js.map","import { Point } from '../../..';\nimport { GeomConstants } from '../../../math/geometry';\nimport { GenericBinaryHeapPriorityQueue } from '../../../structs/genericBinaryHeapPriorityQueue';\nimport { compareNumbers } from '../../../utils/compare';\n// Calculates node radii with 'water algorithm'\nexport class HubRadiiCalculator {\n    constructor(metroGraphData, bundlingSettings) {\n        this.metroGraphData = metroGraphData;\n        this.bundlingSettings = bundlingSettings;\n    }\n    // calculate node radii with fixed hubs\n    CreateNodeRadii() {\n        // set radii to zero\n        for (const v of this.metroGraphData.VirtualStations()) {\n            v.Radius = 0;\n            v.cachedIdealRadius = HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, v);\n        }\n        // TimeMeasurer.DebugOutput(\"Initial cost of radii: \" + Cost());\n        this.GrowHubs(false);\n        // maximally use free space\n        this.GrowHubs(true);\n        // TimeMeasurer.DebugOutput(\"Optimized cost of radii: \" + Cost());\n        // ensure radii are not zero\n        for (const v of this.metroGraphData.VirtualStations()) {\n            v.Radius = Math.max(v.Radius, this.bundlingSettings.MinHubRadius);\n        }\n    }\n    // Grow hubs\n    GrowHubs(useHalfEdgesAsIdealR) {\n        const queue = new GenericBinaryHeapPriorityQueue(compareNumbers);\n        for (const v of this.metroGraphData.VirtualStations()) {\n            queue.Enqueue(v, -this.CalculatePotential(v, useHalfEdgesAsIdealR));\n        }\n        let progress = false;\n        // choose a hub with the greatest potential\n        while (!queue.IsEmpty()) {\n            const t = { priority: 0 };\n            const v = queue.DequeueAndGetPriority(t);\n            if (t.priority >= 0) {\n                break;\n            }\n            // grow the hub\n            if (this.TryGrowHub(v, useHalfEdgesAsIdealR)) {\n                queue.Enqueue(v, -this.CalculatePotential(v, useHalfEdgesAsIdealR));\n                progress = true;\n            }\n        }\n        return progress;\n    }\n    TryGrowHub(v, useHalfEdgesAsIdealR) {\n        const allowedRadius = this.CalculateAllowedHubRadius(v);\n        //Debug.Assert(allowedRadius > 0);\n        if (v.Radius >= allowedRadius)\n            return false;\n        const idealR = useHalfEdgesAsIdealR\n            ? HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings, v)\n            : v.cachedIdealRadius;\n        //Debug.Assert(idealR > 0);\n        if (v.Radius >= idealR)\n            return false;\n        const step = 0.05;\n        let delta = step * (idealR - v.Radius);\n        if (delta < 1.0)\n            delta = 1.0;\n        const newR = Math.min(v.Radius + delta, allowedRadius);\n        if (newR <= v.Radius)\n            return false;\n        v.Radius = newR;\n        return true;\n    }\n    CalculatePotential(v, useHalfEdgesAsIdealR) {\n        const idealR = useHalfEdgesAsIdealR\n            ? HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings, v)\n            : v.cachedIdealRadius;\n        if (idealR <= v.Radius) {\n            return 0;\n        }\n        return (idealR - v.Radius) / idealR;\n    }\n    // Returns the maximal possible radius of the node\n    CalculateAllowedHubRadius(node) {\n        let r = this.bundlingSettings.MaxHubRadius;\n        //adjacent nodes\n        for (const adj of node.Neighbors) {\n            const dist = adj.Position.sub(node.Position).length;\n            //Debug.Assert(dist - 0.05 * (node.Radius + adj.Radius) + 1 >= node.Radius + adj.Radius);\n            r = Math.min(r, dist / 1.05 - adj.Radius);\n        }\n        //TODO: still we can have two intersecting hubs for not adjacent nodes\n        //obstacles\n        const minimalDistance = this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(node, node.Position, r);\n        if (minimalDistance < r)\n            r = minimalDistance - 0.001;\n        return Math.max(r, 0.1);\n    }\n    // Returns the ideal radius of the hub\n    static CalculateIdealHubRadius(metroGraphData, bundlingSettings, node) {\n        let r = 1.0;\n        for (const adj of node.Neighbors) {\n            const width = metroGraphData.GetWidthSSN(adj, node, bundlingSettings.EdgeSeparation);\n            const nr = width / 2.0 + bundlingSettings.EdgeSeparation;\n            r = Math.max(r, nr);\n        }\n        r = Math.min(r, 2 * bundlingSettings.MaxHubRadius);\n        return r;\n    }\n    // Returns the ideal radius of the hub\n    static CalculateIdealHubRadiusWithNeighborsMBS(metroGraphData, bundlingSettings, node) {\n        return HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBNP(metroGraphData, bundlingSettings, node, node.Position);\n    }\n    // Returns the ideal radius of the hub\n    static CalculateIdealHubRadiusWithNeighborsMBNP(metroGraphData, bundlingSettings, node, newPosition) {\n        let r = HubRadiiCalculator.CalculateIdealHubRadius(metroGraphData, bundlingSettings, node);\n        if (node.Neighbors.length > 1) {\n            const adjNodes = node.Neighbors;\n            // there must be enough space between neighbor bundles\n            for (let i = 0; i < adjNodes.length; i++) {\n                const adj = adjNodes[i];\n                const nextAdj = adjNodes[(i + 1) % adjNodes.length];\n                r = Math.max(r, HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles(r, node, newPosition, adj, nextAdj, metroGraphData, bundlingSettings));\n            }\n        }\n        r = Math.min(r, 2 * bundlingSettings.MaxHubRadius);\n        return r;\n    }\n    // Returns the ideal radius of the hub\n    static CalculateIdealHubRadiusWithAdjacentEdges(bundlingSettings, node) {\n        let r = bundlingSettings.MaxHubRadius;\n        for (const adj of node.Neighbors)\n            r = Math.min(r, node.Position.sub(adj.Position).length / 2);\n        return r;\n    }\n    static GetMinRadiusForTwoAdjacentBundles(r, node, nodePosition, adj0, adj1, metroGraphData, bundlingSettings) {\n        const w0 = metroGraphData.GetWidthSSN(node, adj0, bundlingSettings.EdgeSeparation);\n        const w1 = metroGraphData.GetWidthSSN(node, adj1, bundlingSettings.EdgeSeparation);\n        return HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(r, nodePosition, adj0.Position, adj1.Position, w0, w1, bundlingSettings);\n    }\n    // Radius we need to draw to separate adjacent bundles ab and ac\n    static GetMinRadiusForTwoAdjacentBundlesNPPPNNB(r, a, b, c, widthAB, widthAC, bundlingSettings) {\n        if (widthAB < GeomConstants.distanceEpsilon || widthAC < GeomConstants.distanceEpsilon) {\n            return r;\n        }\n        let angle = Point.anglePCP(b, a, c);\n        angle = Math.min(angle, Math.PI * 2 - angle);\n        if (angle < GeomConstants.distanceEpsilon) {\n            return 2 * bundlingSettings.MaxHubRadius;\n        }\n        if (angle >= Math.PI / 2) {\n            return r * 1.05;\n        }\n        // find the intersection point of two bundles\n        const sina = Math.sin(angle);\n        const cosa = Math.cos(angle);\n        const aa = widthAB / (4 * sina);\n        const bb = widthAC / (4 * sina);\n        let d = 2 * Math.sqrt(aa * aa + (bb * bb + 2 * (aa * (bb * cosa))));\n        d = Math.min(d, 2 * bundlingSettings.MaxHubRadius);\n        d = Math.max(d, r);\n        return d;\n    }\n}\n//# sourceMappingURL=HubRadiiCalculator.js.map","import { HitTestBehavior } from '../../../math/geometry/RTree/hitTestBehavior';\nimport { Cdt } from '../../ConstrainedDelaunayTriangulation/Cdt';\nimport { HubRadiiCalculator } from './HubRadiiCalculator';\n// Stores intersections between edges, hubs, and obstacles to speed up simulated annealing\nexport class IntersectionCache {\n    constructor(metroGraphData, bundlingSettings, costCalculator, cdt) {\n        this.metroGraphData = metroGraphData;\n        this.bundlingSettings = bundlingSettings;\n        this.costCalculator = costCalculator;\n        this.cdt = cdt;\n    }\n    InitializeCostCache() {\n        for (const v of this.metroGraphData.VirtualStations()) {\n            v.cachedIdealRadius = HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, v);\n            v.cachedRadiusCost = this.costCalculator.RadiusCost(v, v.Position);\n            v.cachedBundleCost = 0;\n        }\n        for (const edge of this.metroGraphData.VirtualEdges()) {\n            const v = edge[0];\n            const u = edge[1];\n            const edgeInfo = this.metroGraphData.GetIjInfo(v, u);\n            edgeInfo.cachedBundleCost = this.costCalculator.BundleCost(v, u, v.Position);\n            v.cachedBundleCost += edgeInfo.cachedBundleCost;\n            u.cachedBundleCost += edgeInfo.cachedBundleCost;\n        }\n    }\n    UpdateCostCache(node) {\n        const cdtTree = this.cdt.getRectangleNodeOnTriangles();\n        node.cdtTriangle = cdtTree.FirstHitNodeWithPredicate(node.Position, IntersectionCache.testPointInside).UserData;\n        node.cachedIdealRadius = HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, node);\n        node.cachedRadiusCost = this.costCalculator.RadiusCost(node, node.Position);\n        node.cachedBundleCost = 0;\n        for (const adj of node.Neighbors) {\n            if (!adj.IsReal) {\n                adj.cachedIdealRadius = HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, adj);\n                adj.cachedRadiusCost = this.costCalculator.RadiusCost(adj, adj.Position);\n            }\n            const edgeInfo = this.metroGraphData.GetIjInfo(node, adj);\n            adj.cachedBundleCost -= edgeInfo.cachedBundleCost;\n            edgeInfo.cachedBundleCost = this.costCalculator.BundleCost(node, adj, node.Position);\n            node.cachedBundleCost += edgeInfo.cachedBundleCost;\n            adj.cachedBundleCost += edgeInfo.cachedBundleCost;\n        }\n    }\n    static testPointInside(pnt, t) {\n        return Cdt.PointIsInsideOfTriangle(pnt, t) ? HitTestBehavior.Stop : HitTestBehavior.Continue;\n    }\n}\n//# sourceMappingURL=IntersectionCache.js.map","// Check intersections between hubs and obstacles with kd-tree\nimport { Point } from '../../..';\nimport { Polyline, PointLocation, Curve } from '../../../math/geometry';\nimport { uniteSets } from '../../../utils/setOperations';\nexport class Intersections {\n    constructor(metroGraphData, bundlingSettings, obstacleTree, obstaclesToIgnore) {\n        this.metroGraphData = metroGraphData;\n        this.obstaclesToIgnoreLambda = obstaclesToIgnore;\n        this.bundlingSettings = bundlingSettings;\n        this.obstacleTree = obstacleTree;\n    }\n    ObstaclesToIgnoreForBundle(u, v) {\n        if (u != null && v != null) {\n            return uniteSets(this.obstaclesToIgnoreLambda(u), this.obstaclesToIgnoreLambda(v));\n        }\n        if (u == null && v == null) {\n            return new Set();\n        }\n        if (u != null) {\n            return this.obstaclesToIgnoreLambda(u);\n        }\n        else {\n            return this.obstaclesToIgnoreLambda(v);\n        }\n    }\n    HubAvoidsObstaclesSPNBA(node, center, upperBound, t) {\n        const md = { minimalDistance: upperBound };\n        return Intersections.IntersectCircleWithTree(this.obstacleTree, center, upperBound, this.obstaclesToIgnoreLambda(node), t.touchedObstacles, md);\n    }\n    HubAvoidsObstaclesPNS__(center, upperBound, obstaclesToIgnore) {\n        const t = { touchedObstacles: Array() };\n        const md = { minimalDistance: 0 };\n        return this.HubAvoidsObstaclesPNSTT(center, upperBound, obstaclesToIgnore, t, md);\n    }\n    GetMinimalDistanceToObstacles(node, nodePosition, upperBound) {\n        const touchedObstacles = new Array();\n        const t = { minimalDistance: upperBound };\n        if (!Intersections.IntersectCircleWithTree(this.obstacleTree, nodePosition, upperBound, this.obstaclesToIgnoreLambda(node), touchedObstacles, t)) {\n            return 0;\n        }\n        return t.minimalDistance;\n    }\n    HubAvoidsObstaclesPNSTT(center, upperBound, obstaclesToIgnore, t, m) {\n        t.touchedObstacles = new Array();\n        m.minimalDistance = upperBound;\n        return Intersections.IntersectCircleWithTree(this.obstacleTree, center, upperBound, obstaclesToIgnore, t.touchedObstacles, m);\n    }\n    // Computes the intersection between the hub and obstacles\n    // Returns false iff the center is inside of an obstacle, which is not ignored\n    static IntersectCircleWithTree(node, center, radius, obstaclesToIgnore, touchedObstacles, t) {\n        if (!node.irect.contains_point_radius(center, radius)) {\n            return true;\n        }\n        if (node.UserData == null) {\n            let res = Intersections.IntersectCircleWithTree(node.Left, center, radius, obstaclesToIgnore, touchedObstacles, t);\n            if (!res) {\n                return false;\n            }\n            res = Intersections.IntersectCircleWithTree(node.Right, center, radius, obstaclesToIgnore, touchedObstacles, t);\n            if (!res) {\n                return false;\n            }\n        }\n        else {\n            const obstacle = node.UserData;\n            if (obstaclesToIgnore.has(obstacle)) {\n                return true;\n            }\n            const pl = Curve.PointRelativeToCurveLocation(center, obstacle);\n            if (pl !== PointLocation.Outside) {\n                Intersections.containingPoly = obstacle;\n                return false;\n            }\n            const touchPoint = obstacle.value(obstacle.closestParameter(center));\n            const dist = touchPoint.sub(center).length;\n            if (dist <= radius) {\n                touchedObstacles.push([obstacle, touchPoint]);\n            }\n            t.minimalDistance = Math.min(dist, t.minimalDistance);\n        }\n        return true;\n    }\n    static Create4gon(apex, baseCenter, width1, width2) {\n        let norm = baseCenter.sub(apex).normalize();\n        norm = new Point(norm.y, norm.x * -1);\n        return Polyline.mkFromPoints([\n            apex.add(norm.mul(width1 / 2)),\n            apex.sub(norm.mul(width1 / 2)),\n            baseCenter.sub(norm.mul(width2 / 2)),\n            baseCenter.add(norm.mul(width2 / 2)),\n        ]);\n    }\n}\n//#if TEST_MSAGL && TEST_MSAGL\n// check the validness of the drawing:\n//    // 1. hubs are not inside loose obstacles\n//    // 2. bundles do not cross loose obstacles\n//    // <\n//     bool HubPositionsAreOK() {\n//        //check polylines\n//        foreach(var line of metroGraphData.Metrolines) {\n//            var poly = line.Polyline;\n//            foreach(var p of poly.PolylinePoints)\n//            Assert.assert(metroGraphData.PointToStations.ContainsKey(p.point));\n//        }\n//        foreach(var station of metroGraphData.Stations) {\n//            if (!station.IsRealNode && !HubAvoidsObstacles(station.Position, 0, obstaclesToIgnore(station))) {\n//                if (LayoutAlgorithmSettings.ShowDebugCurvesEnumeration != null) {\n//                    HubDebugger.ShowHubs(metroGraphData, bundlingSettings, station);\n//                    ShowStationWithObstaclesToIgnore(station, obstacleTree.AllHitItems(station.Position));\n//                }\n//                return false;\n//            }\n//            //bundles\n//            foreach(var adj of station.Neighbors) {\n//                if (Point.closeDistEps(adj.Position, station.Position))\n//                    return false;\n//                if (!EdgeIsLegal(station, adj, station.Position, adj.Position)) {\n//                    if (LayoutAlgorithmSettings.ShowDebugCurvesEnumeration != null) {\n//                        //debug visualization\n//                        var l = new Array<DebugCurve>();\n//                        //foreach (var st of metroGraphData.Stations) {\n//                        //    l.Add(new DebugCurve(100, 0.5, \"grey\", st.BoundaryCurve));\n//                        //}\n//                        foreach(var poly of obstaclesToIgnore(station)) {\n//                            l.Add(new DebugCurve(100, 5, \"green\", poly));\n//                        }\n//                        foreach(var obstacle of obstacleTree.GetAllLeaves()) {\n//                            l.Add(new DebugCurve(100, 1, \"red\", obstacle));\n//                        }\n//                        l.Add(new DebugCurve(1, \"blue\", station.BoundaryCurve));\n//                        l.Add(new DebugCurve(1, \"blue\", adj.BoundaryCurve));\n//                        l.Add(new DebugCurve(1, \"blue\", new LineSegment(adj.Position, adj.Neighbors.First().Position)));\n//                        l.Add(new DebugCurve(1, \"blue\", new LineSegment(station.Position, adj.Position)));\n//                        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n//                        //end debug visualization\n//                        return false;\n//                    }\n//                }\n//            }\n//        }\n//        return true;\n//    }\n//    void ShowStationWithObstaclesToIgnore(Station station, Array < Polyline > allHitItems) {\n//        var l = new Array<DebugCurve>();\n//        foreach(var poly of allHitItems) {\n//            l.Add(new DebugCurve(100, 0.5, \"brown\", poly));\n//        }\n//        if (obstaclesToIgnore(station) != null)\n//            foreach(var poly of obstaclesToIgnore(station))\n//        l.Add(new DebugCurve(100, 1, \"red\", poly));\n//        foreach(var obstacle of obstacleTree.GetAllLeaves())\n//        l.Add(new DebugCurve(50, 0.1, \"green\", obstacle));\n//        l.Add(new DebugCurve(0.1, \"blue\", new Ellipse(1, 1, station.Position)));\n//        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n//    }\n//    // edge doesn't cross obstacles\n//    // NOTE: use method in CdtIntersection insetad!\n//    // <\n//    bool EdgeIsLegal(Station stationA, Station stationB, Point a, Point b) {\n//        var crossings = InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(new LineSegment(a, b), obstacleTree);\n//        Set < Polyline > obstaclesToIgnoreForBundle = ObstaclesToIgnoreForBundle(stationA, stationB);\n//        if (crossings.Count < 0) {\n//            var l = new Array<DebugCurve>();\n//            var crossingSet = new Set<ICurve>(crossings.Select(ii => ii.Segment1));\n//            l.AddRange(crossingSet.Select(p => new DebugCurve(100, 1, \"red\", p)));\n//            l.AddRange(obstaclesToIgnoreForBundle.Select(p => new DebugCurve(100, 0.5, \"green\", p)));\n//            LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n//        }\n//        return crossings.All(intersectionInfo => obstaclesToIgnoreForBundle.Contains((Polyline)intersectionInfo.Segment1));\n//    }\n// #endif\n// }\n//# sourceMappingURL=Intersections.js.map","// Wrapper for geometry graph with coinciding edges:\n//  'real' nodes stand for edge ends (source,target)\n//  'virtual' nodes stand for polyline control points\n//\n//  'real' edges are original graph edges\nimport { Stack } from 'stack-typescript';\nimport { Point } from '../../..';\nimport { Curve, PointLocation } from '../../../math/geometry';\nimport { PointMap } from '../../../utils/PointMap';\nimport { PointSet } from '../../../utils/PointSet';\nimport { createCDTOnPolylineRectNode } from '../../ConstrainedDelaunayTriangulation/Cdt';\nimport { CdtIntersections } from './CdtIntersections';\nimport { Intersections } from './Intersections';\nimport { Metroline } from './MetroLine';\nimport { MetroNodeInfo } from './MetroNodeInfo';\nimport { Station } from './Station';\nimport { StationEdgeInfo } from './StationEdgeInfo';\nimport { addToMapOfSets, setIntersection } from '../../../utils/setOperations';\nimport { closeDistEps, compareNumbersDistEps } from '../../../utils/compare';\nimport { IntersectionCache } from './IntersectionCache';\nimport { TupleMap } from './tupleMap';\n//  'virtual' edges are polyline segments\nexport class MetroGraphData {\n    constructor(regularEdges, looseTree, tightTree, bundlingSettings, cdt, edgeLooseEnterable, edgeTightEnterable, loosePolylineOfPort) {\n        this.cachedEnterableLooseForEnd = new PointMap();\n        this.bundlingSettings = bundlingSettings;\n        // Assert.assert(cdt != null);\n        this.regularEdges = regularEdges;\n        if (cdt != null) {\n            this.cdt = cdt;\n        }\n        else {\n            this.cdt = createCDTOnPolylineRectNode(looseTree);\n        }\n        this.EdgeLooseEnterable = edgeLooseEnterable;\n        this.EdgeTightEnterable = edgeTightEnterable;\n        this.LoosePolylineOfPort = loosePolylineOfPort;\n        this.looseIntersections = new Intersections(this, bundlingSettings, looseTree, (station) => station.getELP());\n        this.tightIntersections = new Intersections(this, bundlingSettings, tightTree, (station) => station.EnterableTightPolylines);\n        this.cdtIntersections = new CdtIntersections(this, bundlingSettings);\n        this.Initialize(false);\n    }\n    get Ink() {\n        return this.ink;\n    }\n    get Edges() {\n        return this.regularEdges;\n    }\n    VirtualStations() {\n        return Array.from(this.Stations).filter((s) => !s.IsReal);\n    }\n    get Metrolines() {\n        return this.metrolines;\n    }\n    get LooseTree() {\n        return this.looseIntersections.obstacleTree;\n    }\n    get TightTree() {\n        return this.tightIntersections.obstacleTree;\n    }\n    *VirtualEdges() {\n        for (const k of this.edgeInfoDictionary.keys())\n            yield k;\n    }\n    // number of real edges passing the edge uv\n    RealEdgeCount(u, v) {\n        const couple = u.SerialNumber < v.SerialNumber ? [u, v] : [v, u];\n        const cw = this.edgeInfoDictionary.get(couple[0], couple[1]);\n        if (cw)\n            return cw.Count;\n        return 0;\n    }\n    // real edges passing the node\n    MetroNodeInfosOfNode(node) {\n        return node.MetroNodeInfos;\n    }\n    // real edges passing the edge uv\n    GetIjInfo(u, v) {\n        const couple = u.SerialNumber < v.SerialNumber ? [u, v] : [v, u];\n        return this.edgeInfoDictionary.get(couple[0], couple[1]);\n    }\n    // Move node to the specified position\n    MoveNode(node, newPosition) {\n        const oldPosition = node.Position;\n        this.PointToStations.deleteP(oldPosition);\n        this.PointToStations.set(newPosition, node);\n        node.Position = newPosition;\n        //move curves\n        for (const metroNodeInfo of this.MetroNodeInfosOfNode(node))\n            metroNodeInfo.PolyPoint.point = newPosition;\n        // update lengths\n        for (const e of this.MetroNodeInfosOfNode(node)) {\n            const metroLine = e.Metroline;\n            const prev = e.PolyPoint.prev.point;\n            const succ = e.PolyPoint.next.point;\n            metroLine.Length +=\n                succ.sub(newPosition).length + prev.sub(newPosition).length - succ.sub(oldPosition).length - prev.sub(oldPosition).length;\n        }\n        // update ink\n        for (const adj of node.Neighbors)\n            this.ink += newPosition.sub(adj.Position).length - oldPosition.sub(adj.Position).length;\n        // update neighbors order\n        this.SortNeighbors(node);\n        for (const adj of node.Neighbors)\n            this.SortNeighbors(adj);\n    }\n    GetWidthSSN(u, v, edgeSeparation) {\n        const couple = u.SerialNumber < v.SerialNumber ? [u, v] : [v, u];\n        const cw = this.edgeInfoDictionary.get(couple[0], couple[1]);\n        return cw ? cw.Width + (cw.Count - 1) * edgeSeparation : 0;\n    }\n    GetWidthAN(metrolines, edgeSeparation) {\n        let width = 0;\n        for (const metroline of metrolines) {\n            width += metroline.Width;\n        }\n        const count = metrolines.length;\n        width += count > 0 ? (count - 1) * edgeSeparation : 0;\n        //Debug.Assert(GeomConstants.GreaterOrEqual(width, 0));\n        return width;\n    }\n    // Initialize data\n    Initialize(initTightTree) {\n        // TimeMeasurer.DebugOutput(\"bundle graph data initializing...\");\n        this.SimplifyRegularEdges();\n        this.InitializeStationData();\n        this.InitializeEdgeData();\n        this.InitializeVirtualGraph();\n        this.InitializeEdgeNodeInfo(initTightTree);\n        this.InitializeCdtInfo();\n        //            Assert.assert(looseIntersections.HubPositionsAreOK());\n        //          Assert.assert(tightIntersections.HubPositionsAreOK());\n    }\n    // remove self-cycles\n    SimplifyRegularEdges() {\n        for (const edge of this.regularEdges) {\n            this.SimplifyRegularEdge(edge);\n        }\n    }\n    // change the polyline by removing cycles\n    SimplifyRegularEdge(edge) {\n        const polyline = edge.curve;\n        const stack = new Stack();\n        const seen = new PointSet();\n        for (let p = polyline.endPoint; p != null; p = p.prev) {\n            const v = p.point;\n            if (seen.has(p.point)) {\n                let pp = p.next;\n                do {\n                    const u = stack.top;\n                    if (!u.equal(v)) {\n                        seen.delete(u);\n                        stack.pop();\n                        pp = pp.next;\n                    }\n                    else\n                        break;\n                } while (true);\n                pp.prev = p.prev;\n                pp.prev.next = pp;\n            }\n            else {\n                stack.push(v);\n                seen.add(v);\n            }\n        }\n    }\n    InitializeStationData() {\n        this.Stations = [];\n        //create indexes\n        this.PointToStations = new PointMap();\n        for (const edge of this.regularEdges) {\n            const poly = edge.curve;\n            this.ProcessPolylinePoints(poly);\n        }\n    }\n    ProcessPolylinePoints(poly) {\n        let p = poly.startPoint;\n        this.RegisterStation(p, true);\n        for (p = p.next; p !== poly.endPoint; p = p.next) {\n            this.RegisterStation(p, false);\n        }\n        this.RegisterStation(p, true);\n    }\n    RegisterStation(pp, isRealNode) {\n        if (!this.PointToStations.has(pp.point)) {\n            const station = new Station(this.Stations.length, isRealNode, pp.point);\n            this.PointToStations.set(pp.point, station);\n            this.Stations.push(station);\n        }\n        else {\n            //  #if(TEST_MSAGL && TEST_MSAGL)\n            //  const s = this.PointToStations[pp.point]\n            //  Assert.assert(s.IsRealNode === isRealNode)\n            //  #endif\n        }\n    }\n    InitializeEdgeData() {\n        this.metrolines = new Array();\n        for (let i = 0; i < this.regularEdges.length; i++) {\n            const geomEdge = this.regularEdges[i];\n            this.InitEdgeData(geomEdge, i);\n        }\n    }\n    InitEdgeData(geomEdge, index) {\n        const metroEdge = new Metroline(geomEdge.curve, this.bundlingSettings.ActualEdgeWidth(geomEdge), this.EdgeSourceAndTargetFunc(geomEdge), index);\n        this.metrolines.push(metroEdge);\n        this.PointToStations.get(metroEdge.Polyline.start).BoundaryCurve = geomEdge.sourcePort.Curve;\n        this.PointToStations.get(metroEdge.Polyline.end).BoundaryCurve = geomEdge.targetPort.Curve;\n    }\n    EdgeSourceAndTargetFunc(geomEdge) {\n        return () => [this.LoosePolylineOfPort(geomEdge.sourcePort), this.LoosePolylineOfPort(geomEdge.targetPort)];\n    }\n    /**   Initialize graph comprised of stations and their neighbors */\n    InitializeVirtualGraph() {\n        const neighbors = new Map();\n        for (const metroline of this.metrolines) {\n            let u = this.PointToStations.get(metroline.Polyline.start);\n            let v;\n            for (let p = metroline.Polyline.startPoint; p.next != null; p = p.next, u = v) {\n                v = this.PointToStations.get(p.next.point);\n                addToMapOfSets(neighbors, u, v);\n                addToMapOfSets(neighbors, v, u);\n            }\n        }\n        for (const s of this.Stations) {\n            s.Neighbors = Array.from(neighbors.get(s));\n        }\n    }\n    GetUnorderedIjInfo(i, j) {\n        return i.SerialNumber < j.SerialNumber ? this.GetCreateOrderedIjInfo(i, j) : this.GetCreateOrderedIjInfo(j, i);\n    }\n    static closedeb(u, v) {\n        return u.Position.sub(new Point(360.561, 428.416)).length < 0.1 && v.Position.sub(new Point(414.281, 440.732)).length < 0.1;\n    }\n    GetCreateOrderedIjInfo(i, j) {\n        //Assert.assert(i.SerialNumber < j.SerialNumber)\n        let cw = this.edgeInfoDictionary.get(i, j);\n        if (cw) {\n            return cw;\n        }\n        // if (MetroGraphData.closedeb(i, j) || MetroGraphData.closedeb(j, i)) {\n        //  console.log(this)\n        // }\n        cw = new StationEdgeInfo();\n        this.edgeInfoDictionary.set(i, j, cw);\n        return cw;\n    }\n    InitializeEdgeNodeInfo(initTightTree) {\n        this.edgeInfoDictionary = new TupleMap();\n        this.InitAllMetroNodeInfos(initTightTree);\n        this.SortAllNeighbors();\n        this.InitEdgeIjInfos();\n        this.ink = 0;\n        for (const edge of this.VirtualEdges()) {\n            this.ink += edge[0].Position.sub(edge[1].Position).length;\n        }\n    }\n    InitAllMetroNodeInfos(initTightTree) {\n        for (let i = 0; i < this.metrolines.length; i++) {\n            const metroline = this.metrolines[i];\n            this.InitMetroNodeInfos(metroline);\n            this.InitNodeEnterableLoosePolylines(metroline, this.regularEdges[i]);\n            if (initTightTree) {\n                this.InitNodeEnterableTightPolylines(metroline, this.regularEdges[i]);\n            }\n            metroline.UpdateLengths();\n        }\n    }\n    InitMetroNodeInfos(metroline) {\n        for (let pp = metroline.Polyline.startPoint; pp != null; pp = pp.next) {\n            const station = this.PointToStations.get(pp.point);\n            station.MetroNodeInfos.push(new MetroNodeInfo(metroline, station, pp));\n        }\n    }\n    InitNodeEnterableLoosePolylines(metroline, regularEdge) {\n        //If we have groups, EdgeLooseEnterable are precomputed.\n        const metrolineEnterable = this.EdgeLooseEnterable != null ? this.EdgeLooseEnterable.get(regularEdge) : new Set();\n        for (let p = metroline.Polyline.startPoint.next; p != null && p.next != null; p = p.next) {\n            const v = this.PointToStations.get(p.point);\n            if (v.getELP() != null)\n                v.setELP(setIntersection(v.getELP(), metrolineEnterable));\n            else\n                v.setELP(new Set(metrolineEnterable));\n        }\n        this.AddLooseEnterableForMetrolineStartEndPoints(metroline);\n    }\n    AddLooseEnterableForMetrolineStartEndPoints(metroline) {\n        this.AddLooseEnterableForEnd(metroline.Polyline.start);\n        this.AddLooseEnterableForEnd(metroline.Polyline.end);\n    }\n    AddTightEnterableForMetrolineStartEndPoints(metroline) {\n        this.AddTightEnterableForEnd(metroline.Polyline.start);\n        this.AddTightEnterableForEnd(metroline.Polyline.end);\n    }\n    AddLooseEnterableForEnd(point) {\n        const station = this.PointToStations.get(point);\n        if (!this.cachedEnterableLooseForEnd.has(point)) {\n            for (const poly of this.LooseTree.AllHitItems_(point))\n                if (Curve.PointRelativeToCurveLocation(point, poly) === PointLocation.Inside)\n                    station.AddEnterableLoosePolyline(poly);\n            this.cachedEnterableLooseForEnd.set(point, station.getELP());\n        }\n        else {\n            station.setELP(this.cachedEnterableLooseForEnd.get(point));\n        }\n    }\n    AddTightEnterableForEnd(point) {\n        const station = this.PointToStations.get(point);\n        for (const poly of this.TightTree.AllHitItems_(point))\n            if (Curve.PointRelativeToCurveLocation(point, poly) === PointLocation.Inside) {\n                station.AddEnterableTightPolyline(poly);\n            }\n    }\n    InitNodeEnterableTightPolylines(metroline, regularEdge) {\n        //If we have groups, EdgeTightEnterable are precomputed.\n        const metrolineEnterable = this.EdgeTightEnterable != null ? this.EdgeTightEnterable.get(regularEdge) : new Set();\n        for (let p = metroline.Polyline.startPoint.next; p != null && p.next != null; p = p.next) {\n            const v = this.PointToStations.get(p.point);\n            const nodeEnterable = v.EnterableTightPolylines;\n            if (nodeEnterable != null)\n                v.EnterableTightPolylines = setIntersection(nodeEnterable, metrolineEnterable);\n            else\n                v.EnterableTightPolylines = new Set(metrolineEnterable);\n        }\n        this.AddTightEnterableForMetrolineStartEndPoints(metroline);\n    }\n    SortAllNeighbors() {\n        // counter-clockwise sorting\n        for (const station of this.Stations)\n            this.SortNeighbors(station);\n    }\n    SortNeighbors(station) {\n        // nothing to sort\n        if (station.Neighbors.length <= 2) {\n            return;\n        }\n        const pivot = station.Neighbors[0].Position;\n        const center = station.Position;\n        station.Neighbors.sort((u, v) => getOrientationOf3Vectors(pivot.sub(center), u.Position.sub(center), v.Position.sub(center)));\n    }\n    InitEdgeIjInfos() {\n        for (const metroLine of this.metrolines) {\n            const poly = metroLine.Polyline;\n            let u = this.PointToStations.get(poly.start);\n            let v;\n            for (let p = metroLine.Polyline.startPoint; p.next != null; p = p.next, u = v) {\n                v = this.PointToStations.get(p.next.point);\n                const info = this.GetUnorderedIjInfo(u, v);\n                info.Width += metroLine.Width;\n                info.Metrolines.push(metroLine);\n            }\n        }\n    }\n    InitializeCdtInfo() {\n        const cdtTree = this.cdt.getRectangleNodeOnTriangles();\n        for (const station of this.Stations) {\n            station.cdtTriangle = cdtTree.FirstHitNodeWithPredicate(station.Position, IntersectionCache.testPointInside).UserData;\n            //Debug.Assert(station.CdtTriangle != null);\n        }\n    }\n    PointIsAcceptableForEdge(metroline, point) {\n        if (this.LoosePolylineOfPort == null) {\n            return true;\n        }\n        const polys = metroline.sourceAndTargetLoosePolylines();\n        return (Curve.PointRelativeToCurveLocation(point, polys[0]) === PointLocation.Outside &&\n            Curve.PointRelativeToCurveLocation(point, polys[1]) === PointLocation.Outside);\n    }\n}\n/**  computes orientation of three vectors with a common source\n     (compare the polar angles of v1 and v2 with respect to v0)\n      return -1 if the orientation is v0 v1 v2\n               1 if the orientation is v0 v2 v1\n               0  if v1 and v2 are collinear and codirectinal */\nexport function getOrientationOf3Vectors(v0, v1, v2) {\n    const xp2 = Point.crossProduct(v0, v2);\n    const dotp2 = v0.dot(v2);\n    const xp1 = Point.crossProduct(v0, v1);\n    const dotp1 = v0.dot(v1);\n    // v1 is collinear with v0\n    if (closeDistEps(xp1, 0) && GreaterOrEqual(dotp1, 0)) {\n        if (closeDistEps(xp2, 0) && GreaterOrEqual(dotp2, 0)) {\n            return 0;\n        }\n        return 1;\n    }\n    // v2 is collinear with v0\n    if (closeDistEps(xp2, 0) && GreaterOrEqual(dotp2, 0)) {\n        return -1;\n    }\n    if (closeDistEps(xp1, 0) || closeDistEps(xp2, 0) || xp1 * xp2 > 0) {\n        // both on same side of v0, compare to each other\n        return compareNumbersDistEps(Point.crossProduct(v2, v1), 0);\n    }\n    // vectors \"less than\" zero degrees are actually large, near 2 pi\n    return -compareNumbersDistEps(Math.sign(xp1), 0);\n}\nexport function GreaterOrEqual(numberA, numberB) {\n    return compareNumbersDistEps(numberA, numberB) >= 0;\n}\n//# sourceMappingURL=MetroGraphData.js.map","// holds the data of a path\nexport class Metroline {\n    constructor(polyline, width, sourceAndTargetLoosePolys, index) {\n        this.Width = width;\n        this.Polyline = polyline;\n        this.sourceAndTargetLoosePolylines = sourceAndTargetLoosePolys;\n        this.Index = index;\n    }\n    UpdateLengths() {\n        let l = 0;\n        for (let p = this.Polyline.startPoint; p.next != null; p = p.next) {\n            l += p.next.point.sub(p.point).length;\n        }\n        this.Length = l;\n        this.IdealLength = this.Polyline.end.sub(this.Polyline.start).length;\n    }\n}\n//# sourceMappingURL=MetroLine.js.map","export class MetroNodeInfo {\n    constructor(metroline, station, polyPoint) {\n        this.metroline = metroline;\n        this.station = station;\n        this.polyPoint = polyPoint;\n    }\n    get Metroline() {\n        return this.metroline;\n    }\n    get PolyPoint() {\n        return this.polyPoint;\n    }\n}\n//# sourceMappingURL=MetroNodeInfo.js.map","export class OrientedHubSegment {\n    get Segment() {\n        return this.segment;\n    }\n    set Segment(value) {\n        this.segment = value;\n    }\n    constructor(seg, reversed, index, bundleBase) {\n        this.Segment = seg;\n        this.Reversed = reversed;\n        this.Index = index;\n        this.BundleBase = bundleBase;\n    }\n    value(t) {\n        return this.Reversed ? this.Segment.value(this.Segment.parEnd - t) : this.Segment.value(t);\n    }\n}\n//# sourceMappingURL=OrientedHubSegment.js.map","import { Point, Rectangle } from '../../..';\nimport { LineSegment, GeomConstants, Curve } from '../../../math/geometry';\nimport { distPP, TriangleOrientation } from '../../../math/geometry/point';\nimport { PointPair } from '../../../math/geometry/pointPair';\nimport { PolylinePoint } from '../../../math/geometry/polylinePoint';\nimport { createRectangleNodeOnData } from '../../../math/geometry/RTree/rectangleNode';\nimport { CrossRectangleNodesSameType } from '../../../math/geometry/RTree/rectangleNodeUtils';\nimport { BinaryRTree } from '../../../math/geometry/RTree/rTree';\nimport { compareNumbers } from '../../../utils/compare';\nimport { PointMap } from '../../../utils/PointMap';\nimport { PointPairMap } from '../../../utils/pointPairMap';\nimport { PointSet } from '../../../utils/PointSet';\nimport { substractPointSets } from '../../../utils/setOperations';\nimport { FlipSwitcher } from './FlipSwitcher';\nexport class PathFixer {\n    constructor(metroGraphData, polylineAcceptsPoint) {\n        this.foundCrossings = new PointSet();\n        this.crossingsThatShouldBecomeHubs = new PointSet();\n        this.metroGraphData = metroGraphData;\n        this.polylineAcceptsPoint = polylineAcceptsPoint;\n    }\n    *Vertices() {\n        for (const poly of this.Polylines) {\n            for (const p of poly.polylinePoints()) {\n                yield p;\n            }\n        }\n    }\n    get Polylines() {\n        return this.metroGraphData.Edges.map((e) => e.curve);\n    }\n    Edges() {\n        const map = new PointPairMap(); // we need the keys only\n        for (const pp of this.Vertices()) {\n            if (pp.next)\n                map.set(new PointPair(pp.point, pp.next.point), 0);\n        }\n        return Array.from(map.keys());\n    }\n    run() {\n        if (this.metroGraphData.Edges.length === 0) {\n            return false;\n        }\n        const splittingPoints = new PointPairMap();\n        const treeOfVertices = new BinaryRTree(null);\n        for (const vertex of this.Vertices()) {\n            const r = Rectangle.mkOnPoints([vertex.point]);\n            r.pad(GeomConstants.intersectionEpsilon);\n            treeOfVertices.Add(r, vertex.point);\n        }\n        const treeOfEdges = createRectangleNodeOnData(this.Edges(), (e) => Rectangle.mkPP(e.first, e.second));\n        CrossRectangleNodesSameType(treeOfEdges, treeOfEdges, (a, b) => this.IntersectTwoEdges.bind(a, b, splittingPoints, treeOfVertices));\n        this.SortInsertedPoints(splittingPoints);\n        const pointsInserted = this.InsertPointsIntoPolylines(splittingPoints);\n        const progress = this.FixPaths();\n        const pointsRemoved = this.RemoveUnimportantCrossings();\n        return progress || pointsInserted || pointsRemoved;\n    }\n    FixPaths() {\n        let progress = false;\n        if (this.RemoveSelfCycles()) {\n            progress = true;\n        }\n        // if (CollapseCycles()) progress = true;\n        if (this.ReduceEdgeCrossings()) {\n            progress = true;\n        }\n        return progress;\n    }\n    SortInsertedPoints(splittingPoints) {\n        for (const pair of splittingPoints)\n            this.SortInsideSegment(pair[0], pair[1]);\n    }\n    SortInsideSegment(edge, list) {\n        //System.Diagnostics.Debug.Assert(list.Count > 0, \"an edge should not be present with an empty list\");\n        list.sort((a, b) => compareNumbers(distPP(a, edge.first), distPP(b, edge.first)));\n    }\n    InsertPointsIntoPolylines(splittingPoints) {\n        let inserted = false;\n        for (const metroline of this.metroGraphData.Metrolines) {\n            if (this.InsertPointsIntoPolyline(metroline, splittingPoints)) {\n                inserted = true;\n            }\n            return inserted;\n        }\n    }\n    InsertPointsIntoPolyline(metroline, splittingPoints) {\n        let inserted = false;\n        for (let pp = metroline.Polyline.startPoint; pp.next != null; pp = pp.next) {\n            if (this.InsertPointsOnPolypoint(pp, splittingPoints, metroline)) {\n                inserted = true;\n            }\n        }\n        return inserted;\n    }\n    InsertPointsOnPolypoint(pp, splittingPoints, metroline) {\n        const pointPair = new PointPair(pp.point, pp.next.point);\n        const reversed = pp.point !== pointPair.first;\n        const list = splittingPoints.get(pointPair);\n        if (!list) {\n            return false;\n        }\n        const endPolyPoint = pp.next;\n        const poly = pp.polyline;\n        if (reversed)\n            for (let i = list.length - 1; i >= 0; i--) {\n                if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(metroline, list[i]))\n                    continue;\n                const p = PolylinePoint.mkFromPoint(list[i]);\n                p.prev = pp;\n                p.polyline = poly;\n                pp.next = p;\n                pp = p;\n            }\n        else\n            for (let i = 0; i < list.length; i++) {\n                if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(metroline, list[i]))\n                    continue;\n                const p = PolylinePoint.mkFromPoint(list[i]);\n                p.prev = pp;\n                p.polyline = poly;\n                pp.next = p;\n                pp = p;\n            }\n        pp.next = endPolyPoint;\n        endPolyPoint.prev = pp;\n        return true;\n    }\n    RemoveSelfCycles() {\n        let progress = false;\n        for (const poly of this.Polylines)\n            if (PathFixer.RemoveSelfCyclesFromPolyline(poly)) {\n                progress = true;\n            }\n        return progress;\n    }\n    // returns removed points\n    static RemoveSelfCyclesFromPolyline(poly) {\n        let progress = false;\n        const pointsToPp = new PointMap();\n        for (let pp = poly.startPoint; pp != null; pp = pp.next) {\n            const point = pp.point;\n            const previous = pointsToPp.get(point);\n            if (previous) {\n                // we have a cycle\n                for (let px = previous.next; px !== pp.next; px = px.next) {\n                    pointsToPp.deleteP(px.point);\n                }\n                previous.next = pp.next;\n                pp.next.prev = previous;\n                progress = true;\n            }\n            else {\n                pointsToPp.set(pp.point, pp);\n            }\n        }\n        return progress;\n    }\n    // bool CollapseCycles() {\n    //    var cycleCollapser = new FlipCollapser(metroGraphData, bundlingSettings, cdt);\n    //    cycleCollapser.Run();\n    //    crossingsThatShouldBecomeHubs.InsertRange(cycleCollapser.GetChangedCrossing());\n    //    //TimeMeasurer.DebugOutput(\"#crossingsThatShouldBecomeHubs = \" + crossingsThatShouldBecomeHubs.Count);\n    //    return false;\n    // }\n    ReduceEdgeCrossings() {\n        const cycleCollapser = new FlipSwitcher(this.metroGraphData);\n        cycleCollapser.Run();\n        for (const t of cycleCollapser.GetChangedHubs())\n            this.crossingsThatShouldBecomeHubs.add(t);\n        // TimeMeasurer.DebugOutput(\"#reduced crossings = \" + cycleCollapser.NumberOfReducedCrossings());\n        return cycleCollapser.NumberOfReducedCrossings() > 0;\n    }\n    RemoveUnimportantCrossings() {\n        let removed = false;\n        this.pointsToDelete = substractPointSets(this.foundCrossings, this.crossingsThatShouldBecomeHubs);\n        for (const polyline of this.Polylines) {\n            if (this.RemoveUnimportantCrossingsFromPolyline(polyline)) {\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    RemoveUnimportantCrossingsFromPolyline(polyline) {\n        let removed = false;\n        for (let p = polyline.startPoint.next; p != null && p.next != null; p = p.next) {\n            if (this.pointsToDelete.has(p.point) &&\n                Point.getTriangleOrientation(p.prev.point, p.point, p.next.point) === TriangleOrientation.Collinear) {\n                // forget p\n                const pp = p.prev;\n                const pn = p.next;\n                pp.next = pn;\n                pn.prev = pp;\n                p = pp;\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    IntersectTwoEdges(a, b, splittingPoints, tree) {\n        const x = LineSegment.IntersectPPPP(a.first, a.second, b.first, b.second);\n        if (x) {\n            const vertex = this.FindExistingVertexOrCreateNew(tree, x);\n            if (this.AddVertexToSplittingList(a, splittingPoints, vertex) || this.AddVertexToSplittingList(b, splittingPoints, vertex)) {\n                this.foundCrossings.add(vertex);\n            }\n        }\n    }\n    FindExistingVertexOrCreateNew(tree, x) {\n        const p = tree.RootNode.FirstHitNode(x);\n        if (p != null) {\n            return p.UserData;\n        }\n        const rect = Rectangle.mkOnPoints([x]);\n        rect.pad(GeomConstants.intersectionEpsilon);\n        tree.Add(rect, x);\n        return x;\n    }\n    AddVertexToSplittingList(a, splittingPoints, intersectionPoint) {\n        //let t: number\n        //Assert.assert(Point.distToLineSegment(intersectionPoint, a.First, a.Second, /* out */ t) < ApproximateComparer.IntersectionEpsilon)\n        if (!Curve.closeIntersectionPoints(intersectionPoint, a.first) && !Curve.closeIntersectionPoints(intersectionPoint, a.second)) {\n            let list = splittingPoints.get(a);\n            if (!list) {\n                list = new Array();\n                splittingPoints.set(a, list);\n            }\n            if (!list.find((p) => p.equal(intersectionPoint))) {\n                list.push(intersectionPoint);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=PathFixer.js.map","export class PointPairOrder {\n    constructor() {\n        // array of metrolines for node u of edge u->v\n        this.Metrolines = new Array();\n    }\n    Add(metroline) {\n        this.Metrolines.push(metroline);\n    }\n}\n//# sourceMappingURL=PointPairOrder.js.map","//    [DebuggerDisplay(\"({SourcePoint.x},{SourcePoint.y})->({TargetPoint.x},{TargetPoint.y})\")]\nexport class SdBoneEdge {\n    constructor(visibilityEdge, source, target) {\n        this.numberOfPassedPaths = 0;\n        this.VisibilityEdge = visibilityEdge;\n        this.Source = source;\n        this.Target = target;\n    }\n    get TargetPoint() {\n        return this.Target.Point;\n    }\n    get SourcePoint() {\n        return this.Source.Point;\n    }\n    get IsOccupied() {\n        return this.numberOfPassedPaths > 0;\n    }\n    get IsPassable() {\n        return (this.Target.IsTargetOfRouting ||\n            this.Source.IsSourceOfRouting ||\n            this.VisibilityEdge.IsPassable == null ||\n            this.VisibilityEdge.IsPassable());\n    }\n    AddOccupiedEdge() {\n        this.numberOfPassedPaths++;\n    }\n    RemoveOccupiedEdge() {\n        this.numberOfPassedPaths--;\n        /*Assert.assert(this.numberOfPassedPaths >= 0)*/\n    }\n}\n//# sourceMappingURL=SdBoneEdge.js.map","import { HookUpAnywhereFromInsidePort } from '../../../layout/core/hookUpAnywhereFromInsidePort';\nimport { Polyline } from '../../../math/geometry/polyline';\nimport { Rectangle } from '../../../math/geometry/rectangle';\nimport { CreateRectNodeOnArrayOfRectNodes, mkRectangleNode } from '../../../math/geometry/RTree/rectangleNode';\nimport { CrossRectangleNodes } from '../../../math/geometry/RTree/rectangleNodeUtils';\nimport { GenericBinaryHeapPriorityQueue } from '../../../structs/genericBinaryHeapPriorityQueue';\nimport { addToMapOfSets } from '../../../utils/setOperations';\nimport { ClusterBoundaryPort } from '../../ClusterBoundaryPort';\nimport { Cdt } from '../../ConstrainedDelaunayTriangulation/Cdt';\nimport { Polygon } from '../../visibility/Polygon';\nimport { CdtThreader } from './CdtThreader';\nimport { SdBoneEdge } from './SdBoneEdge';\nimport { SdVertex } from './SdVertex';\nexport class SdShortestPath {\n    constructor(makeTransparentShapesOfEdgeGeometryAndGetTheShapes, cdt, gates) {\n        this.EdgesToRoutes = new Map();\n        this.EdgesToRouteSources = new Map();\n        this.MakeTransparentShapesOfEdgeGeometry = makeTransparentShapesOfEdgeGeometryAndGetTheShapes;\n        this.cdt = cdt;\n        this.Gates = gates;\n    }\n    CreateGraphElements() {\n        for (const sdVertex of this.vertexArray) {\n            const vv = sdVertex.VisibilityVertex;\n            for (const vEdge of vv.InEdges) {\n                const boneEdge = new SdBoneEdge(vEdge, this.VisibilityVerticesToSdVerts.get(vEdge.Source), this.VisibilityVerticesToSdVerts.get(vEdge.Target));\n                const otherSdVertex = this.VisibilityVerticesToSdVerts.get(vEdge.Source);\n                sdVertex.InBoneEdges.push(boneEdge);\n                otherSdVertex.OutBoneEdges.push(boneEdge);\n            }\n        }\n    }\n    CreateRoutingGraph() {\n        this.vertexArray = [];\n        this.VisibilityVerticesToSdVerts = new Map();\n        for (const v of this.VisibilityGraph.Vertices()) {\n            const sdVert = new SdVertex(v);\n            this.vertexArray.push(sdVert);\n            this.VisibilityVerticesToSdVerts.set(v, sdVert);\n        }\n        this.CreateGraphElements();\n    }\n    // routing of the edges minimizing (ink+path length+capacity penalty)\n    RouteEdges() {\n        this.Initialize();\n        this.RestoreCapacities();\n        for (const geomEdge of this.geomEdges) {\n            this.EdgesToRoutes.set(geomEdge, this.RouteEdge(geomEdge));\n        }\n        this.RerouteEdges();\n        for (const geomEdge of this.geomEdges)\n            this.SetEdgeGeometryCurve(geomEdge);\n    }\n    SetEdgeGeometryCurve(geomEdge) {\n        const poly = new Polyline();\n        let curV = this.EdgesToRouteSources.get(geomEdge);\n        poly.addPoint(curV.Point);\n        for (const edge of this.EdgesToRoutes.get(geomEdge)) {\n            if (edge.SourcePoint.equal(curV.Point)) {\n                poly.addPoint(edge.TargetPoint);\n                curV = edge.Target;\n            }\n            else {\n                poly.addPoint(edge.SourcePoint);\n                curV = edge.Source;\n            }\n        }\n        geomEdge.curve = poly;\n        const isClusterSourcePort = geomEdge.sourcePort instanceof ClusterBoundaryPort;\n        if (isClusterSourcePort)\n            SdShortestPath.ExtendPolylineStartToClusterBoundary(poly, geomEdge.sourcePort.Curve);\n        const isClusterTargetPort = geomEdge.targetPort instanceof ClusterBoundaryPort;\n        if (isClusterTargetPort)\n            SdShortestPath.ExtendPolylineEndToClusterBoundary(poly, geomEdge.targetPort.Curve);\n    }\n    static ExtendPolylineEndToClusterBoundary(poly, curve) {\n        const par = curve.closestParameter(poly.end);\n        poly.addPoint(curve.value(par));\n    }\n    static ExtendPolylineStartToClusterBoundary(poly, curve) {\n        const par = curve.closestParameter(poly.start);\n        poly.PrependPoint(curve.value(par));\n    }\n    RerouteEdges() {\n        this.RestoreCapacities();\n        for (const geomEdge of this.geomEdges) {\n            const newRoute = this.RerouteEdge(geomEdge);\n            this.EdgesToRoutes.set(geomEdge, newRoute);\n        }\n    }\n    RestoreCapacities() {\n        if (this.cdt != null) {\n            this.cdt.RestoreEdgeCapacities();\n        }\n    }\n    // Reroute edge\n    RerouteEdge(geomEdge) {\n        const route = this.EdgesToRoutes.get(geomEdge);\n        for (const edge of route)\n            edge.RemoveOccupiedEdge();\n        return this.RouteEdge(geomEdge);\n    }\n    RouteEdge(geomEdge) {\n        this.CurrentEdgeGeometry = geomEdge;\n        for (let i = 0; i < this.vertexArray.length; i++) {\n            const sdv = this.vertexArray[i];\n            sdv.SetPreviousToNull();\n            sdv.IsTargetOfRouting = sdv.IsSourceOfRouting = false;\n        }\n        const transparentShapes = this.MakeTransparentShapesOfEdgeGeometry(geomEdge);\n        const ret = this.RouteEdgeWithGroups();\n        for (const shape of transparentShapes)\n            shape.IsTransparent = false;\n        return ret;\n    }\n    RouteEdgeWithGroups() {\n        for (let i = 0; i < 2; i++) {\n            this.SetLengthCoefficient();\n            this.Queue = new GenericBinaryHeapPriorityQueue();\n            this.sourceLoosePoly = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.sourcePort, true);\n            this.targetLoosePoly = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.targetPort, false);\n            const ret = this.RouteOnKnownSourceTargetVertices(this.CurrentEdgeGeometry.targetPort.Location.sub(this.CurrentEdgeGeometry.sourcePort.Location).normalize(), i === 0);\n            if (ret != null) {\n                return ret;\n            }\n            for (let j = 0; j < this.vertexArray.length; j++) {\n                this.vertexArray[j].SetPreviousToNull();\n            }\n        }\n        // SplineRouter.ShowVisGraph('./tmp/badVis.svg', this.VisibilityGraph, Array.from(this.ObstacleHierarchy.GetAllLeaves()), null, [\n        //  LineSegment.mkPP(this.CurrentEdgeGeometry.sourcePort.Location, this.CurrentEdgeGeometry.targetPort.Location),\n        // ])\n        throw new Error();\n    }\n    RouteOnKnownSourceTargetVertices(pathDirection, lookingForMonotonePath) {\n        this.LowestCostToTarget = Number.POSITIVE_INFINITY;\n        this.ClosestTargetVertex = null;\n        while (this.Queue.count > 0) {\n            const hu = { priority: 0 };\n            const bestNode = this.Queue.DequeueAndGetPriority(hu);\n            if (hu.priority >= this.LowestCostToTarget) {\n                continue;\n            }\n            // update the rest\n            for (let i = 0; i < bestNode.OutBoneEdges.length; i++) {\n                const outBoneEdge = bestNode.OutBoneEdges[i];\n                if (outBoneEdge.IsPassable) {\n                    this.ProcessOutcomingBoneEdge(bestNode, outBoneEdge, pathDirection, lookingForMonotonePath);\n                }\n            }\n            for (let i = 0; i < bestNode.InBoneEdges.length; i++) {\n                const inBoneEdge = bestNode.InBoneEdges[i];\n                if (inBoneEdge.IsPassable) {\n                    this.ProcessIncomingBoneEdge(bestNode, inBoneEdge, pathDirection, lookingForMonotonePath);\n                }\n            }\n        }\n        return this.GetPathAndUpdateRelatedCosts();\n    }\n    ProcessOutcomingBoneEdge(v, outBoneEdge, pathDirection, lookingForMonotonePath) {\n        //Assert.assert(v === outBoneEdge.Source)\n        if (lookingForMonotonePath && pathDirection.dot(outBoneEdge.TargetPoint.sub(outBoneEdge.SourcePoint)) < 0) {\n            return;\n        }\n        this.ProcessBoneEdge(v, outBoneEdge.Target, outBoneEdge);\n    }\n    ProcessIncomingBoneEdge(v, inBoneEdge, pathDirection, lookingForMonotonePath) {\n        //Assert.assert(v === inBoneEdge.Target)\n        if (lookingForMonotonePath && pathDirection.dot(inBoneEdge.SourcePoint.sub(inBoneEdge.TargetPoint)) < 0) {\n            return;\n        }\n        this.ProcessBoneEdge(v, inBoneEdge.Source, inBoneEdge);\n    }\n    ProcessBoneEdge(v, queueCandidate, boneEdge) {\n        const newCost = this.GetEdgeAdditionalCost(boneEdge, v.Cost);\n        if (queueCandidate.Cost <= newCost) {\n            return;\n        }\n        queueCandidate.Cost = newCost;\n        queueCandidate.PrevEdge = boneEdge;\n        if (this.Queue.ContainsElement(queueCandidate)) {\n            this.Queue.DecreasePriority(queueCandidate, newCost);\n        }\n        else {\n            if (queueCandidate.IsTargetOfRouting) {\n                let costToTarget = 0;\n                if (this.CurrentEdgeGeometry.targetPort instanceof ClusterBoundaryPort) {\n                    costToTarget = this.LengthCoefficient * queueCandidate.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length;\n                }\n                if (newCost + costToTarget < this.LowestCostToTarget) {\n                    this.LowestCostToTarget = newCost + costToTarget;\n                    this.ClosestTargetVertex = queueCandidate;\n                }\n                return;\n                // do not enqueue the target vertices\n            }\n            this.Enqueue(queueCandidate);\n        }\n    }\n    GetPathAndUpdateRelatedCosts() {\n        // restore the path by moving backwards\n        let current = this.ClosestTargetVertex;\n        if (current == null) {\n            return null;\n        }\n        const result = new Array();\n        while (current.PrevEdge != null) {\n            result.push(current.PrevEdge);\n            this.RegisterPathInBoneEdge(current.PrevEdge);\n            current = current.Prev;\n        }\n        this.EdgesToRouteSources.set(this.CurrentEdgeGeometry, current);\n        result.reverse();\n        //Assert.assert(result.length > 0)\n        return result;\n    }\n    RegisterPathInBoneEdge(boneEdge) {\n        boneEdge.AddOccupiedEdge();\n        if (this.cdt != null && this.BundlingSettings.CapacityOverflowCoefficient !== 0) {\n            this.UpdateResidualCostsOfCrossedCdtEdges(boneEdge);\n        }\n    }\n    UpdateResidualCostsOfCrossedCdtEdges(boneEdge) {\n        for (const cdtEdge of boneEdge.CrossedCdtEdges) {\n            if (this.AdjacentToSourceOrTarget(cdtEdge))\n                continue;\n            if (cdtEdge.ResidualCapacity === cdtEdge.Capacity) {\n                cdtEdge.ResidualCapacity -= this.BundlingSettings.edgeWidthShrinkCoeff * this.CurrentEdgeGeometry.lineWidth;\n            }\n            else {\n                cdtEdge.ResidualCapacity -= this.BundlingSettings.ActualEdgeWidth(this.CurrentEdgeGeometry);\n            }\n        }\n    }\n    H(v) {\n        return v.Cost + this.LengthCoefficient * v.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length;\n    }\n    GetEdgeAdditionalCost(boneEdge, previousCost) {\n        const len = boneEdge.TargetPoint.sub(boneEdge.SourcePoint).length;\n        return (this.LengthCoefficient * len +\n            previousCost +\n            (boneEdge.IsOccupied ? 0 : this.BundlingSettings.InkImportance * len) +\n            this.CapacityOverflowCost(boneEdge));\n    }\n    CapacityOverflowCost(boneEdge) {\n        if (this.cdt == null || this.BundlingSettings.CapacityOverflowCoefficient === 0)\n            return 0;\n        let ret = 0;\n        for (const cdtEdge of this.CrossedCdtEdgesOfBoneEdge(boneEdge)) {\n            ret += this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier, this.BundlingSettings, this.CurrentEdgeGeometry, cdtEdge);\n        }\n        return ret;\n    }\n    CrossedCdtEdgesOfBoneEdge(boneEdge) {\n        if (boneEdge.CrossedCdtEdges != null)\n            return Array.from(boneEdge.CrossedCdtEdges);\n        return Array.from((boneEdge.CrossedCdtEdges = this.ThreadBoneEdgeThroughCdt(boneEdge)));\n    }\n    ThreadBoneEdgeThroughCdt(boneEdge) {\n        const start = boneEdge.SourcePoint;\n        const currentTriangle = boneEdge.Source.Triangle;\n        //Assert.assert(Cdt.PointIsInsideOfTriangle(start, currentTriangle))\n        const crossedEdges = new Set();\n        const end = boneEdge.TargetPoint;\n        if (Cdt.PointIsInsideOfTriangle(end, currentTriangle)) {\n            return crossedEdges;\n        }\n        const threader = new CdtThreader(currentTriangle, start, end);\n        while (threader.MoveNext()) {\n            const piercedEdge = threader.CurrentPiercedEdge;\n            //Assert.assert(piercedEdge != null)\n            if (this.Gates.has(piercedEdge)) {\n                crossedEdges.add(piercedEdge);\n            }\n        }\n        // if(ddd(boneEdge))\n        // CdtSweeper.ShowFront(Cdt.GetTriangles(),null,new []{new LineSegment(boneEdge.SourcePoint,boneEdge.TargetPoint)}, crossedEdges.Select(e=>new LineSegment(e.upperSite.point,e.lowerSite.point)));\n        return crossedEdges;\n    }\n    // TODO: method incorrect since id doesn't check AdjacentToSourceOrTarget condition\n    static CostOfCrossingCdtEdge(capacityOverflMult, bundlingSettings, currentEdgeGeometry, e) {\n        let w = currentEdgeGeometry.lineWidth * bundlingSettings.edgeWidthShrinkCoeff;\n        if (e.Capacity !== e.ResidualCapacity) {\n            w += bundlingSettings.EdgeSeparation * bundlingSettings.edgeWidthShrinkCoeff;\n        }\n        const del = e.ResidualCapacity - w;\n        if (del >= 0) {\n            return 0;\n        }\n        return -del * capacityOverflMult;\n    }\n    CostOfCrossingCdtEdgeLocal(capacityOverflMult, bundlingSettings, currentEdgeGeometry, e) {\n        if (this.AdjacentToSourceOrTarget(e)) {\n            return 0;\n        }\n        return SdShortestPath.CostOfCrossingCdtEdge(capacityOverflMult, bundlingSettings, currentEdgeGeometry, e);\n    }\n    AdjacentToSourceOrTarget(e) {\n        return (e.upperSite.Owner === this.sourceLoosePoly ||\n            e.lowerSite.Owner === this.sourceLoosePoly ||\n            e.upperSite.Owner === this.targetLoosePoly ||\n            e.lowerSite.Owner === this.targetLoosePoly);\n    }\n    SetLengthCoefficient() {\n        const idealEdgeLength = this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);\n        this.LengthCoefficient = this.BundlingSettings.PathLengthImportance / idealEdgeLength;\n    }\n    GetIdealDistanceBetweenSourceAndTarget(geomEdge) {\n        return geomEdge.sourcePort.Location.sub(geomEdge.targetPort.Location).length;\n    }\n    SetPortVerticesAndObstacles(port, sources) {\n        let poly;\n        if (port instanceof ClusterBoundaryPort) {\n            const cbport = port;\n            //SplineRouter.ShowVisGraph(this.VisibilityGraph, this.ObstacleHierarchy.GetAllLeaves(), null, new[]{cbport.LoosePolyline});\n            poly = cbport.LoosePolyline;\n            for (const point of poly) {\n                let initialCost = 0;\n                if (sources) {\n                    //we prefer paths starting from the center of the group\n                    initialCost = this.LengthCoefficient * point.sub(this.CurrentEdgeGeometry.sourcePort.Location).length;\n                }\n                this.AddAndEnqueueVertexToEnds(point, sources, initialCost);\n            }\n        }\n        else {\n            if (port instanceof HookUpAnywhereFromInsidePort) {\n                const anywherePort = port;\n                poly = anywherePort.LoosePolyline;\n                for (const point of poly)\n                    this.AddAndEnqueueVertexToEnds(point, sources, 0);\n            }\n            else {\n                this.AddAndEnqueueVertexToEnds(port.Location, sources, 0);\n                const polys = Array.from(this.ObstacleHierarchy.GetNodeItemsIntersectingRectangle(port.Curve.boundingBox));\n                let mindiag = polys[0].boundingBox.diagonal;\n                poly = polys[0];\n                for (let i = 1; i < polys.length; i++) {\n                    const pl = polys[i];\n                    const diag = pl.boundingBox.diagonal;\n                    if (diag < mindiag) {\n                        mindiag = diag;\n                        poly = pl;\n                    }\n                }\n            }\n        }\n        return poly;\n    }\n    Enqueue(simpleSdVertex) {\n        this.Queue.Enqueue(simpleSdVertex, this.H(simpleSdVertex));\n    }\n    AddAndEnqueueVertexToEnds(point, isSource, initialCost) {\n        const v = this.FindVertex(point);\n        const sdVert = this.VisibilityVerticesToSdVerts.get(v);\n        if (isSource) {\n            sdVert.IsSourceOfRouting = true;\n            sdVert.Cost = initialCost;\n            this.Enqueue(sdVert);\n        }\n        else {\n            sdVert.IsTargetOfRouting = true;\n        }\n    }\n    FindVertex(p) {\n        return this.VisibilityGraph.FindVertex(p); // in the C# version there is a backup search with rounding\n    }\n    Initialize() {\n        this.CreateRoutingGraph();\n        if (this.cdt != null) {\n            this.capacityOverlowPenaltyMultiplier = SdShortestPath.CapacityOverflowPenaltyMultiplier(this.BundlingSettings);\n            this.SetVertexTriangles();\n            this.CalculateCapacitiesOfTrianglulation();\n        }\n    }\n    CalculateCapacitiesOfTrianglulation() {\n        for (const e of this.Gates)\n            SdShortestPath.CalculateCdtEdgeCapacityForEdge(e);\n    }\n    static CalculateCdtEdgeCapacityForEdge(e) {\n        if (e.constrained || e.CwTriangle == null || e.CcwTriangle == null) {\n            return;\n        }\n        // this is a convex hull edge or an obstacle edge\n        const startPoly = e.upperSite.Owner;\n        const endPoly = e.lowerSite.Owner;\n        if (startPoly !== endPoly) {\n            // e.Capacity = Polygon.Distance(new Polygon(startPoly), new Polygon(endPoly)); //todo: cache this\n            // e.Capacity = (e.upperSite.point - e.lowerSite.point).length;\n            const distA = Polygon.DistancePoint(new Polygon(startPoly), e.lowerSite.point);\n            const distB = Polygon.DistancePoint(new Polygon(endPoly), e.upperSite.point);\n            e.Capacity = (distA + distB) / 2;\n        }\n        // else - it is a diagonal of an obstacle, do not care\n    }\n    SetVertexTriangles() {\n        const triangleTree = CreateRectNodeOnArrayOfRectNodes(Array.from(this.cdt.GetTriangles()).map((t) => mkRectangleNode(t, t.BoundingBox())));\n        const vertexTree = CreateRectNodeOnArrayOfRectNodes(this.vertexArray.map((v) => mkRectangleNode(v, Rectangle.mkOnPoints([v.Point]))));\n        CrossRectangleNodes(triangleTree, vertexTree, (a, b) => this.TryToAssigenTriangleToVertex(a, b));\n    }\n    TryToAssigenTriangleToVertex(triangle, vertex) {\n        if (vertex.Triangle != null) {\n            return;\n        }\n        if (Cdt.PointIsInsideOfTriangle(vertex.Point, triangle)) {\n            vertex.Triangle = triangle;\n        }\n    }\n    static CapacityOverflowPenaltyMultiplier(bundlingSettings) {\n        return bundlingSettings.CapacityOverflowCoefficient * (bundlingSettings.PathLengthImportance + bundlingSettings.InkImportance);\n    }\n    // compute cdt edges crossed by paths\n    FillCrossedCdtEdges(crossedCdtEdges) {\n        for (const geometryEdge of this.geomEdges) {\n            this.sourceLoosePoly = this.SetPortVerticesAndObstacles(geometryEdge.sourcePort, true);\n            this.targetLoosePoly = this.SetPortVerticesAndObstacles(geometryEdge.targetPort, false);\n            //crossedCdtEdges.Add(geometryEdge, new Set<CdtEdge>());\n            for (const boneEdge of this.EdgesToRoutes.get(geometryEdge)) {\n                for (const cdtEdge of this.CrossedCdtEdgesOfBoneEdge(boneEdge)) {\n                    if (this.AdjacentToSourceOrTarget(cdtEdge))\n                        continue;\n                    addToMapOfSets(crossedCdtEdges, geometryEdge, cdtEdge);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=SdShortestPath.js.map","export class SdVertex {\n    get Prev() {\n        if (this.PrevEdge == null) {\n            return null;\n        }\n        return this.PrevEdge.Source === this ? this.PrevEdge.Target : this.PrevEdge.Source;\n    }\n    constructor(visibilityVertex) {\n        this.InBoneEdges = new Array();\n        this.OutBoneEdges = new Array();\n        this.VisibilityVertex = visibilityVertex;\n    }\n    get Point() {\n        return this.VisibilityVertex.point;\n    }\n    get Cost() {\n        if (this.IsSourceOfRouting) {\n            return this.cost;\n        }\n        return this.Prev == null ? Number.POSITIVE_INFINITY : this.cost;\n    }\n    set Cost(value) {\n        this.cost = value;\n    }\n    SetPreviousToNull() {\n        this.PrevEdge = null;\n    }\n}\n//# sourceMappingURL=SdVertex.js.map","// Adjust current bundle-routing\nimport { Point } from '../../..';\nimport { Curve, CurveFactory, LineSegment, PointLocation, Rectangle } from '../../../math/geometry';\nimport { DebugCurve } from '../../../math/geometry/debugCurve';\nimport { random } from '../../../utils/random';\nimport { CostCalculator } from './CostCalculator';\nimport { EdgeNudger } from './EdgeNudger';\nimport { IntersectionCache } from './IntersectionCache';\nimport { Intersections } from './Intersections';\nexport class SimulatedAnnealing {\n    // fix routing by simulated annealing algorithm\n    static FixRouting(metroGraphData, bundlingSettings) {\n        return this.FixRoutingMBP(metroGraphData, bundlingSettings, null);\n    }\n    static FixRoutingMBP(metroGraphData, bundlingSettings, changedPoints) {\n        return new SimulatedAnnealing(metroGraphData, bundlingSettings).FixRoutingP(changedPoints);\n    }\n    constructor(metroGraphData, bundlingSettings) {\n        this.stepsWithProgress = 0;\n        this.metroGraphData = metroGraphData;\n        this.bundlingSettings = bundlingSettings;\n        this.costCalculator = new CostCalculator(this.metroGraphData, this.bundlingSettings);\n        this.cache = new IntersectionCache(this.metroGraphData, this.bundlingSettings, this.costCalculator, this.metroGraphData.cdt);\n    }\n    // Use constraint edge routing to reduce ink\n    FixRoutingP(changedPoints) {\n        //Assert.assert(SimulatedAnnealing.stationsArePositionedCorrectly(this.metroGraphData))\n        this.stationsForOptimizations = this.GetStationsForOptimizations(changedPoints);\n        this.cache.InitializeCostCache();\n        let step = SimulatedAnnealing.MaxStep;\n        let energy = Number.POSITIVE_INFINITY;\n        let x = this.metroGraphData.VirtualStations().map((v) => v.Position);\n        let iteration = 0;\n        while (iteration++ < SimulatedAnnealing.MaxIterations) {\n            const coordinatesChanged = this.TryMoveStations();\n            //TimeMeasurer.DebugOutput(\"  #iter = \" + iteration + \" moved: \" + cnt + \"/\" + metroGraphData.VirtualNodes().Count() + \" step: \" + step);\n            if (iteration <= 1 && !coordinatesChanged)\n                return false;\n            if (!coordinatesChanged)\n                break;\n            const oldEnergy = energy;\n            energy = CostCalculator.Cost(this.metroGraphData, this.bundlingSettings);\n            //TimeMeasurer.DebugOutput(\"energy: \" + energy);\n            step = this.UpdateMaxStep(step, oldEnergy, energy);\n            const oldX = x;\n            x = this.metroGraphData.VirtualStations().map((v) => v.Position);\n            if (step < SimulatedAnnealing.MinStep || this.Converged(step, oldX, x)) {\n                break;\n            }\n        }\n        // TimeMeasurer.DebugOutput(\"SA completed after \" + iteration + \" iterations\");\n        return true;\n    }\n    static stationsArePositionedCorrectly(metroGraphData) {\n        for (const e of metroGraphData.VirtualEdges()) {\n            if (!this.edgeIsPositionedCorrectly(e, metroGraphData))\n                return false;\n        }\n        return true;\n    }\n    static edgeIsPositionedCorrectly(e, metroGraphData) {\n        const u = e[0];\n        const v = e[1];\n        const allowedToIntersect = metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(u, v);\n        const ls = LineSegment.mkPP(u.Position, v.Position);\n        const intersected = Array.from(metroGraphData.looseIntersections.obstacleTree.GetNodeItemsIntersectingRectangle(ls.boundingBox))\n            .filter((poly) => !allowedToIntersect.has(poly))\n            .filter((poly) => Curve.CurvesIntersect(ls, poly));\n        if (intersected.length > 0) {\n            EdgeNudger.ShowHubs(metroGraphData, null, null, './tmp/badcross.svg', [\n                DebugCurve.mkDebugCurveTWCI(200, 1, 'Brown', ls),\n                DebugCurve.mkDebugCurveTWCI(200, 1, 'Red', CurveFactory.mkCircle(2, u.Position)),\n                DebugCurve.mkDebugCurveTWCI(200, 1, 'Blue', CurveFactory.mkCircle(5, v.Position)),\n                DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', CurveFactory.mkCircle(5, v.Position)),\n            ].concat(intersected.map((p) => DebugCurve.mkDebugCurveTWCI(100, 1, 'Pink', p))));\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    GetStationsForOptimizations(changedPoints) {\n        if (changedPoints == null) {\n            return new Set(this.metroGraphData.VirtualStations());\n        }\n        else {\n            const result = new Set();\n            for (const p of changedPoints) {\n                const s = this.metroGraphData.PointToStations.get(p);\n                if (s && !s.IsReal)\n                    result.add(s);\n            }\n            return result;\n        }\n    }\n    // stop SA if relative changes are small\n    Converged(step, oldx, newx) {\n        // return false;\n        let den = 0;\n        let num = 0;\n        for (let i = 0; i < oldx.length; i++) {\n            num += oldx[i].sub(newx[i]).lengthSquared;\n            den += oldx[i].lengthSquared;\n        }\n        const res = Math.sqrt(num / den);\n        return res < SimulatedAnnealing.MinRelativeChange;\n    }\n    UpdateMaxStep(step, oldEnergy, newEnergy) {\n        // cooling factor\n        const T = 0.8;\n        if (newEnergy + 1 < oldEnergy) {\n            this.stepsWithProgress++;\n            if (this.stepsWithProgress >= 5) {\n                this.stepsWithProgress = 0;\n                step = Math.min(SimulatedAnnealing.MaxStep, step / T);\n            }\n        }\n        else {\n            this.stepsWithProgress = 0;\n            step *= T;\n        }\n        return step;\n    }\n    TryMoveStations() {\n        let coordinatesChanged = false;\n        const movedStations = new Set();\n        // for (var node of metroGraphData.VirtualNodes()) {\n        for (const node of this.stationsForOptimizations) {\n            if (this.TryMoveStation(node)) {\n                //Assert.assert(this.stationsForOptimizations.has(node))\n                coordinatesChanged = true;\n                movedStations.add(node);\n                for (const adj of node.Neighbors) {\n                    if (!adj.IsReal) {\n                        movedStations.add(adj);\n                    }\n                }\n            }\n        }\n        this.stationsForOptimizations = movedStations;\n        return coordinatesChanged;\n    }\n    /**\n      Move node to decrease the cost of the drawing\n     Returns true iff position has changed\n  */\n    TryMoveStation(s) {\n        let direction = this.BuildDirection(s);\n        if (direction.length === 0) {\n            return false;\n        }\n        let stepLength = this.BuildStepLength(s, direction);\n        if (stepLength < SimulatedAnnealing.MinStep) {\n            // try random direction\n            direction = RandomPoint();\n            stepLength = this.BuildStepLength(s, direction);\n            if (stepLength < SimulatedAnnealing.MinStep) {\n                return false;\n            }\n        }\n        const step = direction.mul(stepLength);\n        const newPosition = s.Position.add(step);\n        // can this happen?\n        if (this.metroGraphData.PointToStations.has(newPosition)) {\n            return false;\n        }\n        if (!this.moveIsLegalForAdjacentBundles(s, newPosition)) {\n            return false;\n        }\n        this.metroGraphData.MoveNode(s, newPosition);\n        this.cache.UpdateCostCache(s);\n        return true;\n    }\n    /** checking the node position and neigborhood bundles */\n    moveIsLegalForAdjacentBundles(s, sNewPosition) {\n        for (const poly of this.metroGraphData.looseIntersections.obstacleTree.AllHitItems(Rectangle.mkOnPoints([sNewPosition]), (poly) => Curve.PointRelativeToCurveLocation(sNewPosition, poly) !== PointLocation.Outside)) {\n            if (s.getELP().has(poly) === false) {\n                return false;\n            }\n        }\n        for (const t of s.Neighbors) {\n            const obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t, s);\n            if (!this.metroGraphData.cdtIntersections.EdgeIsLegal_(t.Position, sNewPosition, t.cdtTriangle, obstaclesToIgnore))\n                return false;\n        }\n        return true;\n    }\n    // Calculate the direction to improve the ink function\n    BuildDirection(node) {\n        const forceInk = this.BuildForceForInk(node);\n        const forcePL = this.BuildForceForPathLengths(node);\n        const forceR = this.BuildForceForRadius(node);\n        const forceBundle = this.BuildForceForBundle(node);\n        const force = forceInk.add(forcePL.add(forceR.add(forceBundle)));\n        if (force.length < 0.1) {\n            return new Point(0, 0);\n        }\n        return force.normalize();\n    }\n    BuildStepLength(node, direction) {\n        let stepLength = SimulatedAnnealing.MinStep;\n        let costGain = this.CostGain(node, node.Position.add(direction.mul(stepLength)));\n        if (costGain < 0.01) {\n            return 0;\n        }\n        while (2 * stepLength <= SimulatedAnnealing.MaxStep) {\n            const newCostGain = this.CostGain(node, node.Position.add(direction.mul(stepLength * 2)));\n            if (newCostGain <= costGain) {\n                break;\n            }\n            stepLength *= 2;\n            costGain = newCostGain;\n        }\n        return stepLength;\n    }\n    // Computes cost delta when moving the node\n    // the cost will be negative if a new position overlaps obstacles\n    CostGain(node, newPosition) {\n        const MInf = -12345678;\n        const rGain = this.costCalculator.RadiusGain(node, newPosition);\n        if (rGain < MInf) {\n            return MInf;\n        }\n        const bundleGain = this.costCalculator.BundleGain(node, newPosition);\n        if (bundleGain < MInf) {\n            return MInf;\n        }\n        const inkGain = this.costCalculator.InkGain(node, newPosition);\n        const plGain = this.costCalculator.PathLengthsGain(node, newPosition);\n        return rGain + inkGain + plGain + bundleGain;\n    }\n    // force to decrease ink\n    BuildForceForInk(node) {\n        //return new Point(0,0);\n        let direction = new Point(0, 0);\n        for (const adj of node.Neighbors) {\n            const p = adj.Position.sub(node.Position);\n            direction = direction.add(p.normalize());\n        }\n        //derivative\n        const force = direction.mul(this.bundlingSettings.InkImportance);\n        return force;\n    }\n    // direction to decrease path lengths\n    BuildForceForPathLengths(node) {\n        // return new Point(0,0);\n        let direction = new Point(0, 0);\n        for (const mni of this.metroGraphData.MetroNodeInfosOfNode(node)) {\n            const metroline = mni.Metroline;\n            const u = mni.PolyPoint.next.point;\n            const v = mni.PolyPoint.prev.point;\n            const p1 = u.sub(node.Position);\n            const p2 = v.sub(node.Position);\n            direction = direction.add(p1.div(p1.length * metroline.IdealLength));\n            direction = direction.add(p2.div(p2.length * metroline.IdealLength));\n        }\n        // derivative\n        const force = direction.mul(this.bundlingSettings.PathLengthImportance);\n        return force;\n    }\n    // direction to increase radii\n    BuildForceForRadius(node) {\n        let direction = new Point(0, 0);\n        const idealR = node.cachedIdealRadius;\n        const t = { touchedObstacles: [] };\n        const res = this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(node, node.Position, idealR, t);\n        if (!res) {\n            EdgeNudger.ShowHubs(this.metroGraphData, null, node, './tmp/hubs.svg', [\n                DebugCurve.mkDebugCurveTWCI(255, 1, 'Brown', Intersections.containingPoly),\n                DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', CurveFactory.mkCircle(idealR, node.Position)),\n            ]);\n            throw new Error();\n        }\n        // throw new Error()\n        //Assert.assert(res) // problem here\n        for (const d of t.touchedObstacles) {\n            const dist = d[1].sub(node.Position).length;\n            //Assert.assert(dist <= idealR)\n            const lforce = 2 * (1 - dist / idealR);\n            const dir = node.Position.sub(d[1]).normalize();\n            direction = direction.add(dir.mul(lforce));\n        }\n        // derivative\n        const force = direction.mul(this.bundlingSettings.HubRepulsionImportance);\n        return force;\n    }\n    /** calculates the direction to push a bundle away from obstacle*/\n    BuildForceForBundle(station) {\n        let direction = new Point(0, 0);\n        for (const adjStation of station.Neighbors) {\n            const idealWidth = this.metroGraphData.GetWidthSSN(station, adjStation, this.bundlingSettings.EdgeSeparation);\n            const t = { closestDist: [] };\n            const res = this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(station, adjStation, station.Position, adjStation.Position, idealWidth / 2, t);\n            if (!res && false) {\n                EdgeNudger.ShowHubs(this.metroGraphData, null, station, './tmp/inside_forbid.svg', [\n                    DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Blue', LineSegment.mkPP(station.Position, adjStation.Position)),\n                    DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', CurveFactory.mkCircle(2, station.Position)),\n                    DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', CurveFactory.mkCircle(3, adjStation.Position)),\n                ]);\n            }\n            //Assert.assert(res) //todo : still unsolved\n            for (const d of t.closestDist) {\n                const dist = d[0].sub(d[1]).length;\n                // Debug.//Assert(LessOrEqual(dist, idealWidth / 2));\n                const lforce = 2.0 * (1.0 - dist / (idealWidth / 2));\n                const dir = d[0].sub(d[1]).normalize().neg();\n                direction = direction.add(dir.mul(lforce));\n            }\n        }\n        //derivative\n        const force = direction.mul(this.bundlingSettings.BundleRepulsionImportance);\n        return force;\n    }\n}\nSimulatedAnnealing.MaxIterations = 100;\nSimulatedAnnealing.MaxStep = 50;\nSimulatedAnnealing.MinStep = 1;\nSimulatedAnnealing.MinRelativeChange = 0.0005;\nfunction RandomPoint() {\n    return new Point(1 + 2 * random(), 1 + 2 * random());\n}\n//# sourceMappingURL=SimulatedAnnealing.js.map","import { Point } from '../../..';\n// (this needs to be public because it's used elsewhere in an interface implementation)\nexport class Station {\n    constructor(serialNumber, isRealNode, position) {\n        // radius of the corresponding hub\n        this.Radius = 0;\n        // it maps each neighbor to its hub\n        this.BundleBases = new Map();\n        // MetroNodeInfos corresponding to the node\n        this.MetroNodeInfos = new Array();\n        this._cachedIdealRadius = 0;\n        this.SerialNumber = serialNumber;\n        this.IsReal = isRealNode;\n        this.Position = position;\n        // if (this.debStop()) {\n        //  console.log(this)\n        // }\n    }\n    debStop() {\n        return (\n        //(this.SerialNumber === 1 && this.Position.sub(new Point(706.0327200902565, 203.36018761064003)).length < 0.01) ||\n        this.SerialNumber === 28 && this.Position.sub(new Point(841.2662778763244, 303.3817005853006)).length < 0.001);\n    }\n    get Position() {\n        return this._Position;\n    }\n    set Position(value) {\n        this._Position = value;\n        // if (this.debStop()) {\n        //  console.log(this)\n        // }\n    }\n    getELP() {\n        return this.EnterableLoosePolylines;\n    }\n    setELP(s) {\n        // if (this.SerialNumber === 32 && s.size > 0) {\n        //  console.log(this)\n        // }\n        this.EnterableLoosePolylines = s;\n    }\n    addEL(p) {\n        // if (this.SerialNumber === 32) {\n        //  console.log(this)\n        // }\n        this.EnterableLoosePolylines.add(p);\n    }\n    get cachedIdealRadius() {\n        return this._cachedIdealRadius;\n    }\n    set cachedIdealRadius(value) {\n        //Assert.assert(!isNaN(value))\n        this._cachedIdealRadius = value;\n    }\n    AddEnterableLoosePolyline(poly) {\n        if (this.EnterableLoosePolylines == null) {\n            this.EnterableLoosePolylines = new Set();\n        }\n        this.EnterableLoosePolylines.add(poly);\n    }\n    AddEnterableTightPolyline(poly) {\n        if (this.EnterableTightPolylines == null) {\n            this.EnterableTightPolylines = new Set();\n        }\n        this.EnterableTightPolylines.add(poly);\n    }\n}\n//# sourceMappingURL=Station.js.map","export class StationEdgeInfo {\n    constructor() {\n        this.Width = 0;\n        this.Metrolines = new Array();\n        this.cachedBundleCost = 0;\n    }\n    get Count() {\n        return this.Metrolines.length;\n    }\n}\n//# sourceMappingURL=StationEdgeInfo.js.map","import { Stack } from 'stack-typescript';\nimport { Point } from '../../..';\nimport { Polyline, LineSegment, Rectangle } from '../../../math/geometry';\nimport { distPP } from '../../../math/geometry/point';\nimport { PointPair } from '../../../math/geometry/pointPair';\nimport { PolylinePoint } from '../../../math/geometry/polylinePoint';\nimport { CreateRectNodeOnArrayOfRectNodes, mkRectangleNode } from '../../../math/geometry/RTree/rectangleNode';\nimport { CrossRectangleNodesSameType } from '../../../math/geometry/RTree/rectangleNodeUtils';\nimport { PointPairMap } from '../../../utils/pointPairMap';\nimport { PointSet } from '../../../utils/PointSet';\nimport { addToPointPairMap, addToPointMapTuple, removeFromPointPairMapTuple, setIntersection, setIntersectionOfArray, substractSets, uniteSets, setsAreEqual, } from '../../../utils/setOperations';\nimport { InteractiveEdgeRouter } from '../../interactiveEdgeRouter';\nimport { CostCalculator } from './CostCalculator';\nimport { HubRadiiCalculator } from './HubRadiiCalculator';\nimport { PathFixer } from './PathFixer';\nimport { SimulatedAnnealing } from './SimulatedAnnealing';\nimport { TupleMap } from './tupleMap';\n// Adjust current bundle-routing with a number of heuristic\nexport class StationPositionsAdjuster {\n    constructor(metroGraphData, bundlingSettings) {\n        this.metroGraphData = metroGraphData;\n        this.bundlingSettings = bundlingSettings;\n    }\n    /**  apply a number of heuristics to improve current routing */\n    static FixRouting(metroGraphData, bundlingSettings) {\n        const adjuster = new StationPositionsAdjuster(metroGraphData, bundlingSettings);\n        adjuster.GlueConflictingStations();\n        adjuster.UnglueEdgesFromBundleToSaveInk(true);\n        let step = 0;\n        const MaxSteps = 10;\n        while (++step < MaxSteps) {\n            // heuristics to improve routing\n            let progress = adjuster.GlueConflictingStations();\n            progress || (progress = adjuster.RelaxConstrainedEdges());\n            progress || (progress = step <= 3 && adjuster.UnglueEdgesFromBundleToSaveInk(false));\n            progress || (progress = adjuster.GlueCollinearNeighbors(step));\n            progress || (progress = step === 3 && adjuster.RemoveDoublePathCrossings());\n            if (!progress) {\n                break;\n            }\n        }\n        //one SA has to be executed with bundle forces\n        metroGraphData.cdtIntersections.ComputeForcesForBundles = true;\n        adjuster.RemoveDoublePathCrossings();\n        adjuster.UnglueEdgesFromBundleToSaveInk(true);\n        while (adjuster.GlueConflictingStations()) { }\n        metroGraphData.Initialize(true);\n        //this time initialize the tight enterables also\n        // this time initialize the tight enterables also\n        //            HubDebugger.ShowHubs(metroGraphData, bundlingSettings);\n        // TimeMeasurer.DebugOutput(\"NodePositionsAdjuster stopped after \" + step + \" steps\");\n        // HubDebugger.ShowHubs(metroGraphData, bundlingSettings, true);\n        // TimeMeasurer.DebugOutput(\"Final cost: \" + CostCalculator.Cost(metroGraphData, bundlingSettings));\n        // TimeMeasurer.DebugOutput(\"Final cost of forces: \" + CostCalculator.CostOfForces(metroGraphData, bundlingSettings));\n    }\n    /** unite the nodes that are close to each other */\n    GlueConflictingStations() {\n        //Assert.assert(SimulatedAnnealing.stationsArePositionedCorrectly(this.metroGraphData))\n        const circlesHierarchy = this.GetCirclesHierarchy();\n        if (circlesHierarchy == null) {\n            return false;\n        }\n        const gluingMap = new Map();\n        const gluedDomain = new Set();\n        CrossRectangleNodesSameType(circlesHierarchy, circlesHierarchy, (i, j) => this.TryToGlueStations(i, j, gluingMap, gluedDomain));\n        if (gluingMap.size === 0) {\n            return false;\n        }\n        //Assert.assert(SimulatedAnnealing.stationsArePositionedCorrectly(this.metroGraphData))\n        for (let i = 0; i < this.metroGraphData.Edges.length; i++) {\n            this.RegenerateEdge(gluingMap, i);\n        }\n        const affectedPoints = new PointSet();\n        for (const s of gluedDomain) {\n            affectedPoints.add(s.Position);\n            for (const neig of s.Neighbors)\n                if (!neig.IsReal)\n                    affectedPoints.add(neig.Position);\n        }\n        // TimeMeasurer.DebugOutput(\"gluing nodes\");\n        this.metroGraphData.Initialize(false);\n        SimulatedAnnealing.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, affectedPoints);\n        return true;\n    }\n    GetCirclesHierarchy() {\n        for (const v of this.metroGraphData.VirtualStations())\n            v.Radius = this.GetCurrentHubRadius(v);\n        const t = this.metroGraphData.VirtualStations().map(rectNodeOfStation);\n        return CreateRectNodeOnArrayOfRectNodes(t);\n        function rectNodeOfStation(i) {\n            const p = i.Position;\n            const r = Math.max(i.Radius, 5);\n            const del = new Point(r, r);\n            const b = Rectangle.mkPP(p.add(del), p.sub(del));\n            return mkRectangleNode(i, b);\n        }\n    }\n    GetCurrentHubRadius(node) {\n        if (node.IsReal) {\n            return node.BoundaryCurve.boundingBox.diagonal / 2;\n        }\n        else {\n            const idealR = node.cachedIdealRadius;\n            //TODO: which one?\n            let r = this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(node, node.Position, idealR);\n            //const r = idealR;\n            //Assert.assert(r <= idealR)\n            for (const adj of node.Neighbors)\n                r = Math.min(r, node.Position.sub(adj.Position).length);\n            return r;\n        }\n    }\n    TryToGlueStations(i, j, gluingMap, gluedDomain) {\n        //Assert.assert(i !== j)\n        if (!setsAreEqual(i.getELP(), j.getELP()))\n            return false;\n        const d = i.Position.sub(j.Position).length;\n        const r1 = Math.max(i.Radius, 5);\n        const r2 = Math.max(j.Radius, 5);\n        if (d >= r1 + r2) {\n            return;\n        }\n        // we are greedily trying to glue i to j\n        if (!this.TryGlueOrdered(i, j, gluedDomain, gluingMap)) {\n            this.TryGlueOrdered(j, i, gluedDomain, gluingMap);\n        }\n    }\n    TryGlueOrdered(i, j, gluedDomain, gluingMap) {\n        if (!gluingMap.has(i) && !gluedDomain.has(i) && this.StationGluingIsAllowed(i, j, gluingMap)) {\n            this.Map(i, j, gluedDomain, gluingMap);\n            // TimeMeasurer.DebugOutput(\"gluing nodes \" + i.serialNumber + \" and \" + j.serialNumber);\n            return true;\n        }\n        return false;\n    }\n    Map(i, j, gluedDomain, gluingMap) {\n        gluingMap.set(i, j);\n        gluedDomain.add(j);\n    }\n    /**  trying to glue i to j */\n    StationGluingIsAllowed(i, j, gluingMap) {\n        for (const adj of i.Neighbors) {\n            const k = StationPositionsAdjuster.Glued(adj, gluingMap);\n            //1. check that we can merge these stations (== no intersections)\n            const obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(k, i);\n            if (!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(k, j, obstaclesToIgnore))\n                return false;\n        }\n        //2. check that cost of the routing is reduced\n        const delta = this.ComputeCostDeltaAfterStationGluing(i, j, gluingMap);\n        if (delta < 0)\n            return false;\n        return true;\n    }\n    ComputeCostDeltaAfterStationGluing(i, j, gluingMap) {\n        const d = i.Position.sub(j.Position).length;\n        if (i.Radius >= d || j.Radius >= d) {\n            return 1;\n        }\n        let gain = 0;\n        // ink\n        const oldInk = this.metroGraphData.Ink;\n        let newInk = this.metroGraphData.Ink - j.Position.sub(i.Position).length;\n        for (const adj of i.Neighbors) {\n            const k = StationPositionsAdjuster.Glued(adj, gluingMap);\n            newInk -= k.Position.sub(i.Position).length;\n            newInk += this.metroGraphData.RealEdgeCount(k, j) === 0 ? k.Position.sub(j.Position).length : 0;\n        }\n        gain += CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);\n        //path lengths\n        for (const metroInfo of this.metroGraphData.MetroNodeInfosOfNode(i)) {\n            const oldLength = metroInfo.Metroline.Length;\n            let newLength = metroInfo.Metroline.Length;\n            const pi = metroInfo.PolyPoint;\n            const pa = pi.prev;\n            const pb = pi.next;\n            newLength -= pa.point.sub(i.Position).length + pb.point.sub(i.Position).length;\n            newLength += pa.point.sub(j.Position).length + pb.point.sub(j.Position).length;\n            gain += CostCalculator.PathLengthsError(oldLength, newLength, metroInfo.Metroline.IdealLength, this.bundlingSettings);\n        }\n        return gain;\n    }\n    RegenerateEdge(gluingMap, edgeIndex) {\n        const poly = this.metroGraphData.Metrolines[edgeIndex].Polyline;\n        for (const p of poly) {\n            if (!this.metroGraphData.PointToStations.has(p)) {\n                return;\n            }\n        }\n        let atLeastOnGlued = false;\n        for (const p of poly) {\n            if (gluingMap.has(this.metroGraphData.PointToStations.get(p))) {\n                atLeastOnGlued = true;\n                break;\n            }\n        }\n        if (!atLeastOnGlued) {\n            return;\n        }\n        const metrolines = Array.from(poly).map((p) => this.metroGraphData.PointToStations.get(p));\n        this.metroGraphData.Edges[edgeIndex].curve = Polyline.mkFromPoints(StationPositionsAdjuster.GluedPolyline(metrolines, gluingMap));\n        return;\n    }\n    static GluedPolyline(metroline, gluedMap) {\n        let i;\n        const ret = new Stack();\n        ret.push(metroline[0]);\n        const seenStations = new Set();\n        for (i = 1; i < metroline.length - 1; i++) {\n            const station = StationPositionsAdjuster.Glued(metroline[i], gluedMap);\n            if (seenStations.has(station)) {\n                // we made a cycle - need to cut it out\n                while (ret.top !== station) {\n                    seenStations.delete(ret.pop());\n                }\n                continue;\n            }\n            if (Point.closeDistEps(station.Position, ret.top.Position)) {\n                continue;\n            }\n            seenStations.add(station);\n            ret.push(station);\n        }\n        ret.push(metroline[i]);\n        return Array.from(ret)\n            .reverse()\n            .map((n) => n.Position);\n    }\n    static Glued(i, gluedMap) {\n        var _a;\n        return (_a = gluedMap.get(i)) !== null && _a !== void 0 ? _a : i;\n    }\n    // Unbundle unnecessary edges:\n    //  instead of one bundle (a->bcd) we get two bundles (a->b,a->cd) with smaller ink\n    UnglueEdgesFromBundleToSaveInk(alwaysExecuteSA) {\n        const segsToPolylines = new PointPairMap();\n        this.ink = this.metroGraphData.Ink;\n        this.polylineLength = new Map();\n        // create polylines\n        for (const metroline of this.metroGraphData.Metrolines) {\n            this.polylineLength.set(metroline, metroline.Length);\n            for (let pp = metroline.Polyline.startPoint; pp.next != null; pp = pp.next) {\n                const segment = new PointPair(pp.point, pp.next.point);\n                addToPointPairMap(segsToPolylines, segment, metroline);\n            }\n        }\n        const affectedPoints = new PointSet();\n        let progress = false;\n        for (const metroline of this.metroGraphData.Metrolines) {\n            const obstaclesAllowedToIntersect = setIntersection(this.metroGraphData.PointToStations.get(metroline.Polyline.start).getELP(), this.metroGraphData.PointToStations.get(metroline.Polyline.end).getELP());\n            if (this.TrySeparateOnPolyline(metroline, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect))\n                progress = true;\n        }\n        if (progress)\n            //TimeMeasurer.DebugOutput(\"unbundling\");\n            this.metroGraphData.Initialize(false);\n        if (alwaysExecuteSA || progress) {\n            SimulatedAnnealing.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, alwaysExecuteSA ? null : affectedPoints);\n        }\n        return progress;\n    }\n    TrySeparateOnPolyline(metroline, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect) {\n        let progress = false;\n        let relaxing = true;\n        while (relaxing) {\n            relaxing = false;\n            for (let p = metroline.Polyline.startPoint; p.next != null && p.next.next != null; p = p.next) {\n                if (this.TryShortcutPolypoint(p, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect)) {\n                    relaxing = true;\n                }\n            }\n            if (relaxing) {\n                progress = true;\n            }\n        }\n        return progress;\n    }\n    TryShortcutPolypoint(pp, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect) {\n        if (this.SeparationShortcutAllowed(pp, segsToPolylines, obstaclesAllowedToIntersect)) {\n            affectedPoints.add(pp.point);\n            affectedPoints.add(pp.next.point);\n            affectedPoints.add(pp.next.next.point);\n            this.RemoveShortcuttedPolypoint(pp, segsToPolylines);\n            return true;\n        }\n        return false;\n    }\n    // allowed iff line (a,c) is legal and inkgain > 0\n    SeparationShortcutAllowed(pp, segsToPolylines, obstaclesAllowedToIntersect) {\n        const a = pp.point;\n        const b = pp.next.point;\n        const c = pp.next.next.point;\n        const aStation = this.metroGraphData.PointToStations.get(a);\n        const bStation = this.metroGraphData.PointToStations.get(b);\n        const cStation = this.metroGraphData.PointToStations.get(c);\n        // 1. intersections\n        const aUc = uniteSets(aStation.getELP(), cStation.getELP());\n        const obstaclesToIgnore = setIntersectionOfArray([obstaclesAllowedToIntersect, bStation.getELP(), aUc]);\n        if (!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(aStation, cStation, obstaclesToIgnore)) {\n            return false;\n        }\n        // 2. cost gain\n        const inkgain = this.GetInkgain(pp, segsToPolylines, a, b, c);\n        if (inkgain < 0) {\n            return false;\n        }\n        return true;\n    }\n    GetInkgain(pp, segsToPolylines, a, b, c) {\n        //const abPolylines:Set<Metroline>, bcPolylines:Set<Metroline>, abcPolylines:Set<Metroline>;\n        const [abPolylines, bcPolylines, abcPolylines] = this.FindPolylines(pp, segsToPolylines);\n        let gain = 0;\n        //ink\n        const oldInk = this.ink;\n        let newInk = this.ink;\n        const ab = a.sub(b).length;\n        const bc = b.sub(c).length;\n        const ac = a.sub(c).length;\n        if (abPolylines.size === abcPolylines.size)\n            newInk -= ab;\n        if (bcPolylines.size === abcPolylines.size)\n            newInk -= bc;\n        const t = segsToPolylines.get(new PointPair(a, c));\n        if (!t || t.size === 0)\n            newInk += ac;\n        gain += CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);\n        //path lengths\n        for (const metroline of abcPolylines) {\n            const oldLength = this.polylineLength.get(metroline);\n            const newLength = oldLength - (ab + bc - ac);\n            gain += CostCalculator.PathLengthsError(oldLength, newLength, metroline.IdealLength, this.bundlingSettings);\n        }\n        //radii\n        let nowR = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(a));\n        const widthABC = this.metroGraphData.GetWidthAN(Array.from(abcPolylines), this.bundlingSettings.EdgeSeparation);\n        const widthABD = this.metroGraphData.GetWidthAN(Array.from(substractSets(abPolylines, abcPolylines)), this.bundlingSettings.EdgeSeparation);\n        let idealR = HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(nowR, a, c, b, widthABC, widthABD, this.bundlingSettings);\n        if (idealR > nowR) {\n            gain -= CostCalculator.RError(idealR, nowR, this.bundlingSettings);\n        }\n        //check opposite side\n        nowR = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(c));\n        const widthCBD = this.metroGraphData.GetWidthAN(Array.from(substractSets(bcPolylines, abcPolylines)), this.bundlingSettings.EdgeSeparation);\n        idealR = HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(nowR, c, b, a, widthCBD, widthABC, this.bundlingSettings);\n        if (idealR > nowR) {\n            gain -= CostCalculator.RError(idealR, nowR, this.bundlingSettings);\n        }\n        return gain;\n    }\n    RemoveShortcuttedPolypoint(pp, segsToPolylines) {\n        const a = pp.point;\n        const b = pp.next.point;\n        const c = pp.next.next.point;\n        const [abPolylines, bcPolylines, abcPolylines] = this.FindPolylines(pp, segsToPolylines);\n        const ab = distPP(a, b);\n        const bc = distPP(b, c);\n        const ac = distPP(a, c);\n        //fixing ink\n        if (abPolylines.size === abcPolylines.size)\n            this.ink -= ab;\n        if (bcPolylines.size === abcPolylines.size)\n            this.ink -= bc;\n        const t = segsToPolylines.get(new PointPair(a, c));\n        if (!t || t.size === 0)\n            this.ink += ac;\n        //fixing edge lengths\n        for (const metroline of abcPolylines) {\n            const l = this.polylineLength.get(metroline);\n            this.polylineLength.set(metroline, l - (ab + bc - ac));\n        }\n        //fixing polylines\n        for (const metroline of abcPolylines) {\n            const pp = Array.from(metroline.Polyline.polylinePoints()).find((p) => p.point.equal(b));\n            this.RemovePolypoint(pp);\n            removeFromPointPairMapTuple(segsToPolylines, [a, b], metroline);\n            removeFromPointPairMapTuple(segsToPolylines, [b, c], metroline);\n            addToPointMapTuple(segsToPolylines, [a, c], metroline);\n        }\n    }\n    FindPolylines(pp, segsToPolylines) {\n        const a = pp.point;\n        const b = pp.next.point;\n        const c = pp.next.next.point;\n        const abPolylines = segsToPolylines.getPP(a, b);\n        const bcPolylines = segsToPolylines.getPP(b, c);\n        const abcPolylines = setIntersection(abPolylines, bcPolylines);\n        return [abPolylines, bcPolylines, abcPolylines];\n    }\n    RemovePolypoint(p) {\n        const prev = p.prev;\n        const next = p.next;\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**   Fix the situation where a station has two neighbors that are almost in the same directions */\n    GlueCollinearNeighbors(step) {\n        const affectedPoints = new PointSet();\n        let progress = false;\n        for (const node of this.metroGraphData.Stations)\n            if (this.GlueCollinearNeighborsSPN(node, affectedPoints, step)) {\n                progress = true;\n            }\n        if (progress) {\n            // TimeMeasurer.DebugOutput(\"gluing edges\");\n            this.metroGraphData.Initialize(false);\n            SimulatedAnnealing.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, affectedPoints);\n        }\n        return progress;\n    }\n    GlueCollinearNeighborsSPN(node, affectedPoints, step) {\n        if (node.Neighbors.length <= 1) {\n            return false;\n        }\n        // node,adj => new via point\n        const gluedEdges = new TupleMap();\n        const neighbors = node.Neighbors;\n        for (let i = 0; i < neighbors.length; i++) {\n            this.TryToGlueEdges(node, neighbors[i], neighbors[(i + 1) % neighbors.length], gluedEdges, step);\n        }\n        if (gluedEdges.isEmpty) {\n            return false;\n        }\n        for (const keyValueTriple of gluedEdges) {\n            this.GlueEdge(keyValueTriple);\n            affectedPoints.add(keyValueTriple[0].Position);\n            affectedPoints.add(keyValueTriple[1].Position);\n            affectedPoints.add(keyValueTriple[2]);\n        }\n        return true;\n    }\n    TryToGlueEdges(node, a, b, gluedEdges, step) {\n        //Assert.assert(a !== b)\n        const angle = Point.anglePCP(a.Position, node.Position, b.Position);\n        if (angle < this.bundlingSettings.AngleThreshold) {\n            const la = distPP(a.Position, node.Position);\n            const lb = distPP(b.Position, node.Position);\n            const ratio = Math.min(la, lb) / Math.max(la, lb);\n            if (ratio < 0.05) {\n                return;\n            }\n            if (la < lb) {\n                if (this.EdgeGluingIsAllowedSSS(node, a, b)) {\n                    this.AddEdgeToGlue(node, b, a, a.Position, gluedEdges);\n                    return;\n                }\n            }\n            else if (this.EdgeGluingIsAllowedSSS(node, b, a)) {\n                this.AddEdgeToGlue(node, a, b, b.Position, gluedEdges);\n                return;\n            }\n            // TODO: need this???\n            if (step < 5 && ratio > 0.5) {\n                const newPosition = this.ConstructGluingPoint(node, a, b);\n                if (this.EdgeGluingIsAllowedSSSP(node, a, b, newPosition)) {\n                    this.AddEdgeToGlue(node, b, a, newPosition, gluedEdges);\n                }\n            }\n        }\n    }\n    ConstructGluingPoint(node, a, b) {\n        // temp\n        const len = Math.min(distPP(a.Position, node.Position), distPP(b.Position, node.Position) / 2);\n        const dir = a.Position.sub(node.Position).normalize().add(b.Position.sub(node.Position).normalize());\n        return node.Position.add(dir.mul(len / 2));\n    }\n    EdgeGluingIsAllowedSSS(node, a, b) {\n        // 0. can't pass through real nodes\n        if (a.IsReal || b.IsReal) {\n            return false;\n        }\n        // 0.5 do not glue the stations with the different passports\n        if (!setsAreEqual(a.getELP(), b.getELP())) {\n            return false;\n        }\n        // 1. check intersections)  Here we are bending the edge (node->b) to pass through a.Position.\n        // We need to be sure that segments (node,a) and (a,b) intersect only obstacles enterable for the bundle (node, b)\n        if (!this.metroGraphData.cdtIntersections.EdgeIsLegal(a, b, a.Position, b.Position)) {\n            return false;\n        }\n        const enterableForEdgeNodeB = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(node, b);\n        const crossingsOfEdgeNodeA = InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(LineSegment.mkPP(node.Position, a.Position), this.metroGraphData.LooseTree);\n        if (crossingsOfEdgeNodeA.find((ii) => !enterableForEdgeNodeB.has(ii.seg1))) {\n            return false;\n        }\n        const crossingsOfEdgeab = InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(LineSegment.mkPP(a.Position, b.Position), this.metroGraphData.LooseTree);\n        if (crossingsOfEdgeab.find((ii) => !enterableForEdgeNodeB.has(ii.seg1))) {\n            return false;\n        }\n        // 2. check cost\n        const delta = this.ComputeCostDeltaAfterEdgeGluing(node, a, b, a.Position);\n        if (delta < 0) {\n            return false;\n        }\n        return true;\n    }\n    EdgeGluingIsAllowedSSSP(node, a, b, gluingPoint) {\n        // 0. can't pass through real nodes\n        if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(gluingPoint, 0, setIntersection(a.getELP(), b.getELP()))) {\n            return false;\n        }\n        // 1. check intersections\n        if (!this.metroGraphData.cdtIntersections.EdgeIsLegal(node, null, node.Position, gluingPoint)) {\n            return false;\n        }\n        if (!this.metroGraphData.cdtIntersections.EdgeIsLegal(a, null, a.Position, gluingPoint)) {\n            return false;\n        }\n        if (!this.metroGraphData.cdtIntersections.EdgeIsLegal(b, null, b.Position, gluingPoint)) {\n            return false;\n        }\n        // 2. check cost\n        const delta = this.ComputeCostDeltaAfterEdgeGluing(node, a, b, gluingPoint);\n        if (delta < 0) {\n            return false;\n        }\n        return true;\n    }\n    ComputeCostDeltaAfterEdgeGluing(node, a, b, newp) {\n        let gain = 0;\n        //ink\n        const oldInk = this.metroGraphData.Ink;\n        const newInk = this.metroGraphData.Ink -\n            distPP(node.Position, b.Position) -\n            distPP(node.Position, a.Position) +\n            distPP(node.Position, newp) +\n            distPP(newp, a.Position) +\n            distPP(newp, b.Position);\n        gain += CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);\n        //path lengths\n        for (const metroline of this.metroGraphData.GetIjInfo(node, b).Metrolines) {\n            const oldLength = metroline.Length;\n            const newLength = metroline.Length - distPP(node.Position, b.Position) + distPP(node.Position, newp) + distPP(newp, b.Position);\n            gain += CostCalculator.PathLengthsError(oldLength, newLength, metroline.IdealLength, this.bundlingSettings);\n        }\n        for (const metroline of this.metroGraphData.GetIjInfo(node, a).Metrolines) {\n            const oldLength = metroline.Length;\n            const newLength = metroline.Length - distPP(node.Position, a.Position) + distPP(node.Position, newp) + distPP(newp, a.Position);\n            gain += CostCalculator.PathLengthsError(oldLength, newLength, metroline.IdealLength, this.bundlingSettings);\n        }\n        //also compute radii gain\n        //let nowR = Math.Min(GetCurrentHubRadius(node), (node.Position - newp).Length);\n        //let id2 = HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors(metroGraphData, bundlingSettings, node);\n        const id2 = node.cachedIdealRadius;\n        const nowR = this.GetCurrentHubRadius(node);\n        const idealR = HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles(nowR, node, node.Position, a, b, this.metroGraphData, this.bundlingSettings);\n        if (idealR > nowR) {\n            gain += CostCalculator.RError(idealR, nowR, this.bundlingSettings);\n        }\n        if (id2 > distPP(node.Position, newp) && !node.IsReal) {\n            gain -= CostCalculator.RError(id2, distPP(node.Position, newp), this.bundlingSettings);\n        }\n        return gain;\n    }\n    AddEdgeToGlue(node, b, a, newp, gluedEdges) {\n        // same edge in the reverse direction\n        if (gluedEdges.has(a, node)) {\n            return;\n        }\n        if (gluedEdges.has(b, node)) {\n            return;\n        }\n        if (gluedEdges.has(node, a)) {\n            return;\n        }\n        if (gluedEdges.has(node, b)) {\n            return;\n        }\n        gluedEdges.set(node, a, newp);\n        gluedEdges.set(node, b, newp);\n    }\n    GlueEdge(keyValuePair) {\n        const node = keyValuePair[0];\n        const a = keyValuePair[1];\n        const newp = keyValuePair[2];\n        for (const polylinePoint of node.MetroNodeInfos.map((i) => i.PolyPoint)) {\n            if (polylinePoint.next != null && polylinePoint.next.point.equal(a.Position)) {\n                this.SplitPolylinePoint(polylinePoint, newp);\n            }\n            else if (polylinePoint.prev != null && polylinePoint.prev.point.equal(a.Position)) {\n                this.SplitPolylinePoint(polylinePoint.prev, newp);\n            }\n        }\n    }\n    SplitPolylinePoint(node, pointToInsert) {\n        if (node.point === pointToInsert || node.next.point === pointToInsert) {\n            return;\n        }\n        const p = PolylinePoint.mkFromPoint(pointToInsert);\n        p.polyline = node.polyline;\n        p.next = node.next;\n        p.prev = node;\n        p.next.prev = p;\n        p.prev.next = p;\n    }\n    // split each edge that is too much constrained by the obstacles\n    RelaxConstrainedEdges() {\n        const affectedPoints = new PointSet();\n        let progress = false;\n        for (const edge of this.metroGraphData.VirtualEdges())\n            if (this.RelaxConstrainedEdge(edge[0], edge[1], affectedPoints))\n                progress = true;\n        if (progress) {\n            //TimeMeasurer.DebugOutput(\"relaxing constrained edges\");\n            this.metroGraphData.Initialize(false);\n            SimulatedAnnealing.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, affectedPoints);\n        }\n        return progress;\n    }\n    RelaxConstrainedEdge(a, b, affectedPoints) {\n        //find conflicting obstacles\n        const idealWidth = this.metroGraphData.GetWidthSSN(a, b, this.bundlingSettings.EdgeSeparation);\n        const t = { closestDist: new Array() };\n        this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(a, b, a.Position, b.Position, (0.99 * idealWidth) / 2.0, t);\n        // //Assert.assert(res); //todo still unsolved\n        const closestPoints = t.closestDist;\n        if (closestPoints.length > 0) {\n            //find closest obstacle\n            let bestDist = -1;\n            let bestPoint;\n            for (const d of closestPoints) {\n                //should not be too close\n                const distToSegmentEnd = Math.min(distPP(a.Position, d[1]), distPP(b.Position, d[1]));\n                const distAB = distPP(a.Position, b.Position);\n                const ratio = distToSegmentEnd / distAB;\n                if (ratio < 0.1)\n                    continue;\n                //choose the closest\n                const dist = distPP(d[0], d[1]);\n                if (bestDist === -1 || dist < bestDist) {\n                    bestDist = dist;\n                    bestPoint = d[1];\n                }\n            }\n            if (bestDist === -1)\n                return false;\n            if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(bestPoint, 0, setIntersection(a.getELP(), b.getELP())))\n                return false;\n            affectedPoints.add(bestPoint);\n            affectedPoints.add(a.Position);\n            affectedPoints.add(b.Position);\n            for (const metroline of this.metroGraphData.GetIjInfo(a, b).Metrolines) {\n                let pp = null;\n                //TODO: replace the cycle!\n                for (const ppp of metroline.Polyline.polylinePoints())\n                    if (ppp.point.equal(a.Position)) {\n                        pp = ppp;\n                        break;\n                    }\n                //Assert.assert(pp != null)\n                if (pp.next != null && pp.next.point.equal(b.Position))\n                    this.SplitPolylinePoint(pp, bestPoint);\n                else\n                    this.SplitPolylinePoint(pp.prev, bestPoint);\n            }\n            return true;\n        }\n        return false;\n    }\n    // switch flips\n    RemoveDoublePathCrossings() {\n        const progress = new PathFixer(this.metroGraphData, this.metroGraphData.PointIsAcceptableForEdge.bind(this)).run();\n        if (progress) {\n            this.metroGraphData.Initialize(false);\n            SimulatedAnnealing.FixRouting(this.metroGraphData, this.bundlingSettings);\n        }\n        return progress;\n    }\n}\n//# sourceMappingURL=StationPositionsAdjuster.js.map","export class TupleMap {\n    constructor() {\n        this.mainMap = new Map();\n    }\n    get isEmpty() {\n        return this.mainMap.size === 0 || this.everyMapIsEmpty();\n    }\n    everyMapIsEmpty() {\n        for (const b of this.mainMap.values()) {\n            if (b.size)\n                return false;\n        }\n        return true;\n    }\n    get(a, b) {\n        const m = this.mainMap.get(a);\n        if (m)\n            return m.get(b);\n    }\n    has(a, b) {\n        const m = this.mainMap.get(a);\n        if (!m)\n            return false;\n        return m.has(b);\n    }\n    set(a, b, c) {\n        let m = this.mainMap.get(a);\n        if (!m) {\n            m = new Map();\n            this.mainMap.set(a, m);\n        }\n        m.set(b, c);\n    }\n    *[Symbol.iterator]() {\n        for (const [a, m] of this.mainMap) {\n            for (const [b, c] of m) {\n                yield [a, b, c];\n            }\n        }\n    }\n    *keys() {\n        for (const [a, m] of this.mainMap) {\n            for (const [b] of m) {\n                yield [a, b];\n            }\n        }\n    }\n}\n//# sourceMappingURL=tupleMap.js.map","import { ConeSide } from './ConeSide';\n// represents a cone side that is broken by the obstacle\nexport class BrokenConeSide extends ConeSide {\n    get Start() {\n        return this.start;\n    }\n    get End() {\n        return this.EndVertex.point;\n    }\n    constructor(start, end, coneSide) {\n        super();\n        this.start = start;\n        this.EndVertex = end;\n        this.ConeSide = coneSide;\n    }\n    get Direction() {\n        return this.End.sub(this.Start);\n    }\n    toString() {\n        return 'BrokenConeSide: ' + (this.Start + (',' + this.End));\n    }\n}\n//# sourceMappingURL=BrokenConeSide.js.map","export class Cone {\n    get Removed() {\n        return this.removed;\n    }\n    set Removed(value) {\n        this.removed = value;\n    }\n    constructor(apex, coneSweeper) {\n        this.apex = apex;\n        this.coneSweeper = coneSweeper;\n    }\n    get Apex() {\n        return this.apex;\n    }\n    set Apex(value) {\n        this.apex = value;\n    }\n    get RightSideDirection() {\n        return this.coneSweeper.ConeRightSideDirection;\n    }\n    get LeftSideDirection() {\n        return this.coneSweeper.ConeLeftSideDirection;\n    }\n    get RightSide() {\n        return this.rightSide;\n    }\n    set RightSide(value) {\n        this.rightSide = value;\n        this.rightSide.Cone = this;\n    }\n    get LeftSide() {\n        return this.leftSide;\n    }\n    set LeftSide(value) {\n        this.leftSide = value;\n        this.leftSide.Cone = this;\n    }\n}\n//# sourceMappingURL=Cone.js.map","// this event caused by the intersection of a ObstacleSideSegment and the other cone side of the same cone\n// when this event happens the cone has to be removed\nimport { SweepEvent } from './SweepEvent';\nexport class ConeClosureEvent extends SweepEvent {\n    get ConeToClose() {\n        return this.coneToClose;\n    }\n    get Site() {\n        return this.site;\n    }\n    constructor(site, cone) {\n        super();\n        this.site = site;\n        this.coneToClose = cone;\n    }\n    toString() {\n        return 'ConeClosureEvent ' + this.site;\n    }\n}\n//# sourceMappingURL=ConeClosureEvent.js.map","import { ConeSide } from './ConeSide';\nexport class ConeLeftSide extends ConeSide {\n    constructor(cone) {\n        super();\n        this.Cone = cone;\n    }\n    get Start() {\n        return this.Cone.Apex;\n    }\n    get Direction() {\n        return this.Cone.LeftSideDirection;\n    }\n    toString() {\n        return 'ConeLeftSide ' + this.Start + (' ' + this.Direction);\n    }\n}\n//# sourceMappingURL=ConeLeftSide.js.map","import { ConeSide } from './ConeSide';\nexport class ConeRightSide extends ConeSide {\n    constructor(cone) {\n        super();\n        this.Cone = cone;\n    }\n    get Start() {\n        return this.Cone.Apex;\n    }\n    get Direction() {\n        return this.Cone.RightSideDirection;\n    }\n    toString() {\n        return 'ConeRightSide ' + this.Start + ' ' + this.Direction;\n    }\n}\n//# sourceMappingURL=ConeRightSide.js.map","export class ConeSide {\n    constructor() {\n        this.Removed = false;\n    }\n}\n//# sourceMappingURL=ConeSide.js.map","import { Point } from '../../..';\nimport { TriangleOrientation } from '../../../math/geometry/point';\nimport { BrokenConeSide } from './BrokenConeSide';\nimport { ConeLeftSide } from './ConeLeftSide';\nexport class ConeSideComparer {\n    SetOperand(activeElement) {\n        this.x = this.IntersectionOfSegmentAndSweepLine(activeElement);\n    }\n    constructor(coneSweeper) {\n        this.coneSweeper = coneSweeper;\n    }\n    Compare(a, b) {\n        const aIsBrokenConeSide = a instanceof BrokenConeSide;\n        const bIsBrokenConeSide = b instanceof BrokenConeSide;\n        if (aIsBrokenConeSide) {\n            return bIsBrokenConeSide ? this.CompareBrokenSides(a, b) : this.CompareObstacleSideAndConeSide(b);\n        }\n        else {\n            // a is ConeSide\n            return bIsBrokenConeSide\n                ? this.CompareConeSideAndObstacleSide(a, b)\n                : ConeSideComparer.CompareNotIntersectingSegs(a, b);\n        }\n    }\n    static CompareNotIntersectingSegs(a, b) {\n        const signedArea = Point.getTriangleOrientation(a.Start, b.Start, b.Start.add(b.Direction));\n        switch (signedArea) {\n            case TriangleOrientation.Counterclockwise:\n                return -1;\n            case TriangleOrientation.Clockwise:\n                return 1;\n            default:\n                return 0;\n        }\n    }\n    CompareObstacleSideAndConeSide(coneSide) {\n        const orientation = Point.getTriangleOrientation(this.x, coneSide.Start, coneSide.Start.add(coneSide.Direction));\n        if (orientation === TriangleOrientation.Counterclockwise) {\n            return -1;\n        }\n        if (orientation === TriangleOrientation.Clockwise) {\n            return 1;\n        }\n        // we have the case where x belongs to the cone side\n        return coneSide instanceof ConeLeftSide ? -1 : 1;\n    }\n    CompareConeSideAndObstacleSide(coneSide, brokenConeSide) {\n        const orientation = Point.getTriangleOrientation(this.x, brokenConeSide.start, brokenConeSide.End);\n        if (orientation === TriangleOrientation.Counterclockwise) {\n            return -1;\n        }\n        if (orientation === TriangleOrientation.Clockwise) {\n            return 1;\n        }\n        // we have the case where x belongs to the cone side\n        //      lineSweeper.Show(CurveFactory.CreateDiamond(5,5, brokenConeSide.EndVertex.point));\n        return coneSide instanceof ConeLeftSide ? 1 : -1;\n    }\n    IntersectionOfSegmentAndSweepLine(obstacleSide) {\n        const den = obstacleSide.Direction.dot(this.coneSweeper.SweepDirection);\n        //Assert.assert(Math.abs(den) > 0)\n        const t = (this.coneSweeper.Z - obstacleSide.Start.dot(this.coneSweeper.SweepDirection)) / den;\n        return obstacleSide.Start.add(obstacleSide.Direction.mul(t));\n    }\n    CompareBrokenSides(aObst, bObst) {\n        if (aObst.EndVertex === bObst.EndVertex) {\n            return ConeSideComparer.CompareNotIntersectingSegs(aObst.ConeSide, bObst.ConeSide);\n        }\n        if (Point.getTriangleOrientation(this.x, bObst.start, bObst.EndVertex.point) === TriangleOrientation.Counterclockwise) {\n            return -1;\n        }\n        return 1;\n    }\n}\n//# sourceMappingURL=ConeSideComparer.js.map","import { Point } from '../../..';\nimport { Algorithm } from '../../../utils/algorithm';\nimport { PointSet } from '../../../utils/PointSet';\nimport { VisibilityGraph } from '../../visibility/VisibilityGraph';\nimport { LineSweeper } from './LineSweeper';\nexport class ConeSpanner extends Algorithm {\n    constructor(obstacles, visibilityGraph) {\n        super(null);\n        /** the angle of the cone */\n        this.coneAngle = Math.PI / 6;\n        this.ports = new PointSet();\n        this._obstacles = Array.from(VisibilityGraph.OrientHolesClockwise(obstacles));\n        this._visibilityGraph = visibilityGraph;\n    }\n    static mk(obstacles, visibilityGraph, coneAngle, ports, borderPolyline) {\n        const ret = new ConeSpanner(obstacles, visibilityGraph);\n        // Assert.assert(borderPolyline == null  || obstacles.every((o) => Curve.CurveIsInsideOther(o, borderPolyline)))\n        // Assert.assert(\n        //  borderPolyline == null  ||\n        //  Array.from(ports.values()).every((o) => Curve.PointRelativeToCurveLocation(o, borderPolyline) === PointLocation.Inside),\n        // )\n        // Assert.assert(obstacles.All(o => ports.All(p => Curve.PointRelativeToCurveLocation(p, o) === PointLocation.Outside)));\n        // todo: uncomment this assert - it failes on D:\\progression\\src\\ddsuites\\src\\vs\\Progression\\ScenarioTests\\Grouping\\GroupingResources\\GroupBySelection2.dgml\n        // when dragging\n        // Assert.assert(coneAngle > Math.PI / (180 * 2) && coneAngle <= Math.PI / 2)\n        ret.Ports = ports;\n        ret.BorderPolyline = borderPolyline;\n        ret.ConeAngle = coneAngle;\n        return ret;\n    }\n    get ConeAngle() {\n        return this.coneAngle;\n    }\n    set ConeAngle(value) {\n        this.coneAngle = value;\n    }\n    get Ports() {\n        return this.ports;\n    }\n    set Ports(value) {\n        this.ports = value;\n    }\n    get BorderPolyline() {\n        return this.borderPolyline;\n    }\n    set BorderPolyline(value) {\n        this.borderPolyline = value;\n    }\n    // If set to true then a smaller visibility graph is created.\n    // An edge is added to the visibility graph only if it is found at least twice:\n    // once sweeping with a direction d and the second time with -d\n    get Bidirectional() {\n        return this._bidirectional;\n    }\n    set Bidirectional(value) {\n        this._bidirectional = value;\n    }\n    static GetTotalSteps(coneAngle) {\n        return Math.floor((2 * Math.PI - coneAngle / 2) / coneAngle) + 1;\n    }\n    run() {\n        const offset = 2 * Math.PI - this.coneAngle / 2;\n        if (!this.Bidirectional) {\n            let angle;\n            for (let i = 0; (angle = this.coneAngle * i) <= offset; i++) {\n                super.ProgressStep();\n                this.AddDirection(new Point(Math.cos(angle), Math.sin(angle)), this.BorderPolyline, this._visibilityGraph);\n            }\n        }\n        else {\n            this.HandleBideractionalCase();\n        }\n    }\n    HandleBideractionalCase() {\n        const k = (Math.PI / this.coneAngle);\n        for (let i = 0; i < k; i++) {\n            const angle = i * this.coneAngle;\n            const vg0 = new VisibilityGraph();\n            this.AddDirection(new Point(Math.cos(angle), Math.sin(angle)), this.BorderPolyline, vg0);\n            const vg1 = new VisibilityGraph();\n            this.AddDirection(new Point(Math.cos(angle) * -1, Math.sin(angle) * -1), this.BorderPolyline, vg1);\n            this.AddIntersectionOfBothDirectionSweepsToTheResult(vg0, vg1);\n        }\n    }\n    AddIntersectionOfBothDirectionSweepsToTheResult(vg0, vg1) {\n        for (const edge of vg0.Edges) {\n            if (vg1.FindEdgePP(edge.SourcePoint, edge.TargetPoint) != null) {\n                this._visibilityGraph.AddEdgePP(edge.SourcePoint, edge.TargetPoint);\n            }\n        }\n    }\n    AddDirection(direction, borderPolyline, visibilityGraph) {\n        LineSweeper.Sweep(this._obstacles, direction, this.coneAngle, visibilityGraph, this.Ports, borderPolyline);\n    }\n}\n//# sourceMappingURL=ConeSpanner.js.map","// left here means an intersection of a left cone side with an obstacle edge\nimport { SweepEvent } from './SweepEvent';\nexport class LeftIntersectionEvent extends SweepEvent {\n    get EndVertex() {\n        return this.endVertex;\n    }\n    constructor(coneLeftSide, intersectionPoint, endVertex) {\n        super();\n        this.coneLeftSide = coneLeftSide;\n        this.intersectionPoint = intersectionPoint;\n        this.endVertex = endVertex;\n    }\n    get Site() {\n        return this.intersectionPoint;\n    }\n    toString() {\n        return 'LeftIntersectionEvent ' + this.intersectionPoint;\n    }\n}\n//# sourceMappingURL=LeftIntersectionEvent.js.map","import { ObstacleSide } from './ObstacleSide';\nexport class LeftObstacleSide extends ObstacleSide {\n    constructor(startVertex) {\n        super(startVertex);\n        this.end = startVertex.nextOnPolyline.point;\n    }\n    get End() {\n        return this.end;\n    }\n    get EndVertex() {\n        return this.StartVertex.nextOnPolyline;\n    }\n}\n//# sourceMappingURL=LeftObstacleSide.js.map","import { VertexEvent } from './VertexEvent';\nexport class LeftVertexEvent extends VertexEvent {\n    constructor(p) {\n        super(p);\n    }\n}\n//# sourceMappingURL=LeftVertexEvent.js.map","// sweeps a given direction of cones and adds discovered edges to the graph\nimport { Point } from '../../..';\nimport { GeomConstants, CurveFactory, LineSegment } from '../../../math/geometry';\nimport { TriangleOrientation } from '../../../math/geometry/point';\nimport { PolylinePoint } from '../../../math/geometry/polylinePoint';\nimport { RBTree } from '../../../math/RBTree/rbTree';\nimport { closeDistEps } from '../../../utils/compare';\nimport { LineSweeperBase } from '../../visibility/LineSweeperBase';\nimport { TollFreeVisibilityEdge } from '../../visibility/TollFreeVisibilityEdge';\nimport { VisibilityGraph } from '../../visibility/VisibilityGraph';\nimport { BrokenConeSide } from './BrokenConeSide';\nimport { Cone } from './Cone';\nimport { ConeClosureEvent } from './ConeClosureEvent';\nimport { ConeLeftSide } from './ConeLeftSide';\nimport { ConeRightSide } from './ConeRightSide';\nimport { ConeSideComparer } from './ConeSideComparer';\nimport { LeftIntersectionEvent } from './LeftIntersectionEvent';\nimport { LeftObstacleSide } from './LeftObstacleSide';\nimport { LeftVertexEvent } from './LeftVertexEvent';\nimport { RightIntersectionEvent } from './RightIntersectionEvent';\nimport { RightObstacleSide } from './RightObstacleSide';\nimport { RightVertexEvent } from './RightVertexEvent';\nimport { VertexEvent } from './VertexEvent';\nexport class LineSweeper extends LineSweeperBase /*implements IConeSweeper*/ {\n    constructor(obstacles, direction, coneRsDir, coneLsDir, visibilityGraph, ports, borderPolyline) {\n        super(obstacles, direction);\n        this.visibilityGraph = visibilityGraph;\n        this.ConeRightSideDirection = coneRsDir;\n        this.ConeLeftSideDirection = coneLsDir;\n        this.coneSideComparer = new ConeSideComparer(this);\n        this.leftConeSides = new RBTree((a, b) => this.coneSideComparer.Compare(a, b));\n        this.rightConeSides = new RBTree((a, b) => this.coneSideComparer.Compare(a, b));\n        this.Ports = ports;\n        this.BorderPolyline = borderPolyline;\n        this.PortEdgesCreator = (a, b) => {\n            return new TollFreeVisibilityEdge(a, b, 0);\n        };\n    }\n    static Sweep(obstacles, direction, coneAngle, visibilityGraph, ports, borderPolyline) {\n        const cs = new LineSweeper(obstacles, direction, direction.rotate(-coneAngle / 2), direction.rotate(coneAngle / 2), visibilityGraph, ports, borderPolyline);\n        cs.Calculate();\n    }\n    Calculate() {\n        this.InitQueueOfEvents();\n        while (this.EventQueue.Count > 0) {\n            this.ProcessEvent(this.EventQueue.Dequeue());\n        }\n        if (this.BorderPolyline != null) {\n            this.CloseRemainingCones();\n        }\n        this.CreatePortEdges();\n    }\n    CreatePortEdges() {\n        if (this.portEdgesGraph != null) {\n            for (const edge of this.portEdgesGraph.Edges) {\n                this.visibilityGraph.AddEdgeF(edge.SourcePoint, edge.TargetPoint, this.PortEdgesCreator);\n            }\n        }\n    }\n    CloseRemainingCones() {\n        if (this.leftConeSides.count === 0) {\n            return;\n        }\n        //Assert.assert(this.leftConeSides.count === this.rightConeSides.count)\n        let p = this.BorderPolyline.startPoint;\n        let steps = this.leftConeSides.count;\n        // we cannot make more than leftConeSides.Count if the data is correct\n        // because at each step we remove at least one cone\n        do {\n            const cone = this.leftConeSides.treeMinimum().item.Cone;\n            p = this.FindPolylineSideIntersectingConeRightSide(p, cone);\n            p = this.GetPolylinePointInsideOfConeAndRemoveCones(p, cone);\n            steps--;\n        } while (this.leftConeSides.count > 0 && steps > 0);\n    }\n    GetPolylinePointInsideOfConeAndRemoveCones(p, cone) {\n        const pn = p.nextOnPolyline;\n        const insidePoint = LineSweeper.FindInsidePoint(p.point, pn.point, cone);\n        if (Point.closeDistEps(insidePoint, p.point)) {\n            this.AddEdgeAndRemoveCone(cone, p.point);\n            this.AddEdgesAndRemoveRemainingConesByPoint(p.point);\n            // we don't move p forward here. In the next iteration we just cross [p,pn] with the new leftmost cone right side\n        }\n        else if (Point.closeDistEps(insidePoint, pn.point)) {\n            this.AddEdgeAndRemoveCone(cone, pn.point);\n            this.AddEdgesAndRemoveRemainingConesByPoint(pn.point);\n            p = pn;\n        }\n        else {\n            p = LineSweeper.InsertPointIntoPolylineAfter(this.BorderPolyline, p, insidePoint);\n            this.AddEdgeAndRemoveCone(cone, p.point);\n            this.AddEdgesAndRemoveRemainingConesByPoint(p.point);\n        }\n        return p;\n    }\n    static FindInsidePoint(leftPoint, rightPoint, cone) {\n        //            if (debug)\n        //                LayoutAlgorithmSettings.Show(CurveFactory.CreateCircle(3, leftPoint),\n        //                                             CurveFactory.CreateDiamond(3, 3, rightPoint),\n        //                                             BorderPolyline, ExtendSegmentToZ(cone.LeftSide),\n        //                                             ExtendSegmentToZ(cone.RightSide));\n        return LineSweeper.FindInsidePointBool(leftPoint, rightPoint, cone.Apex, cone.Apex.add(cone.LeftSideDirection), cone.Apex.add(cone.RightSideDirection));\n    }\n    static FindInsidePointBool(leftPoint, rightPoint, apex, leftSideConePoint, rightSideConePoint) {\n        if (Point.closeDistEps(leftPoint, rightPoint)) {\n            return leftPoint;\n        }\n        // does not matter which one to return\n        if (Point.PointIsInsideCone(leftPoint, apex, leftSideConePoint, rightSideConePoint)) {\n            return leftPoint;\n        }\n        if (Point.PointIsInsideCone(rightPoint, apex, leftSideConePoint, rightSideConePoint)) {\n            return rightPoint;\n        }\n        const m = Point.middle(leftPoint, rightPoint);\n        if (Point.pointToTheLeftOfLine(m, apex, leftSideConePoint)) {\n            return LineSweeper.FindInsidePointBool(m, rightPoint, apex, leftSideConePoint, rightSideConePoint);\n        }\n        return LineSweeper.FindInsidePointBool(leftPoint, m, apex, leftSideConePoint, rightSideConePoint);\n    }\n    AddEdgesAndRemoveRemainingConesByPoint(point) {\n        const conesToRemove = new Array();\n        for (const leftConeSide of this.leftConeSides) {\n            if (Point.PointToTheRightOfLineOrOnLine(point, leftConeSide.Start, leftConeSide.Start.add(leftConeSide.Direction))) {\n                conesToRemove.push(leftConeSide.Cone);\n            }\n            else {\n                break;\n            }\n        }\n        for (const cone of conesToRemove)\n            this.AddEdgeAndRemoveCone(cone, point);\n    }\n    FindPolylineSideIntersectingConeRightSide(p, cone) {\n        const startPoint = p;\n        const a = cone.Apex;\n        const b = cone.Apex.add(this.ConeRightSideDirection);\n        let pSign = LineSweeper.GetSign(p, a, b);\n        for (; true;) {\n            const pn = p.nextOnPolyline;\n            const pnSigh = LineSweeper.GetSign(pn, a, b);\n            if (pnSigh - pSign > 0) {\n                return p;\n            }\n            p = pn;\n            pSign = pnSigh;\n            if (p === startPoint) {\n                throw new Error('cannod decide if the polyline intersects the cone!');\n                //Assert.assert(false)\n            }\n        }\n    }\n    // #if TEST_MSAGL\n    //         // ReSharper disable UnusedMember.Local\n    //         static ICurve Box(Point p) {\n    //             // ReSharper restore UnusedMember.Local\n    //             return CurveFactory.CreateRectangle(2, 2, p);\n    //         }\n    //             \"CA1303:Do not pass literals as localized parameters\", MessageId = \"System.Diagnostics.Debug.WriteLine(System.String)\"\n    //         )]\n    //         void PrintOutRightSegTree() {\n    //             System.Diagnostics.Debug.WriteLine(\"right segment tree\");\n    //             foreach(var t of rightConeSides)\n    //             System.Diagnostics.Debug.WriteLine(t);\n    //             System.Diagnostics.Debug.WriteLine(\"end of right segments\");\n    //         }\n    // #endif\n    static GetSign(p, a, b) {\n        const d = Point.signedDoubledTriangleArea(a, b, p.point);\n        if (d < 0) {\n            return 1;\n        }\n        return d > 0 ? -1 : 0;\n    }\n    // #if TEST_MSAGL && TEST_MSAGL\n    //         void Showside(PolylinePoint p, Point a, Point b, PolylinePoint pn) {\n    //             ShowBothTrees(new DebugCurve(100, 1, \"brown\", BorderPolyline), new DebugCurve(100, 2, \"blue\",\n    //                 new LineSegment(a, b)),\n    //                 new DebugCurve(100, 2, \"green\",\n    //                     new LineSegment(\n    //                         pn.point, p.point)\n    //                 ));\n    //         }\n    // #endif\n    //        void CheckThatPolylineIsLegal()\n    //        {\n    //            var p = BorderPolyline.startPoint;\n    //            do\n    //            {\n    //                var pn = p.NextOnPolyline;\n    //                Assert.assert(!Point.closeDistEps(p.point, pn.point));\n    //                Assert.assert((pn.point - p.point)*(pn.NextOnPolyline.point - pn.point) > -GeomConstants.tolerance);\n    //                p = pn;\n    //            } while (p !== BorderPolyline.startPoint);\n    //        }\n    // #if TEST_MSAGL\n    //         void ShowBoundaryPolyline() {\n    //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(CreateBoundaryPolyDebugCurves());\n    //         }\n    //         Array < DebugCurve > CreateBoundaryPolyDebugCurves() {\n    //             int i = 0;\n    //             for (var p = BorderPolyline.startPoint; p != null; p = p.next) {\n    //                 yield return new DebugCurve(new Ellipse(1, 1, p.point), i++);\n    //             }\n    //         }\n    // #endif\n    AddEdgeAndRemoveCone(cone, p) {\n        if (this.Ports != null && this.Ports.has(cone.Apex)) {\n            this.CreatePortEdge(cone, p);\n        }\n        else {\n            this.visibilityGraph.AddEdgePP(cone.Apex, p);\n        }\n        this.RemoveCone(cone);\n    }\n    CreatePortEdge(cone, p) {\n        if (this.portEdgesGraph == null) {\n            this.portEdgesGraph = new VisibilityGraph();\n        }\n        const coneApexVert = this.portEdgesGraph.FindVertex(cone.Apex);\n        // all previous edges adjacent to cone.Apex\n        const edgesToFix = coneApexVert != null ? Array.from(coneApexVert.InEdges).concat(Array.from(coneApexVert.OutEdges.allNodes())) : null;\n        if (edgesToFix) {\n            for (const edge of edgesToFix) {\n                const otherPort = (edge.Target === coneApexVert ? edge.Source : edge.Target).point;\n                VisibilityGraph.RemoveEdge(edge);\n                this.portEdgesGraph.AddEdgePP(otherPort, p);\n            }\n        }\n        this.portEdgesGraph.AddEdgePP(cone.Apex, p);\n    }\n    static InsertPointIntoPolylineAfter(borderPolyline, insertAfter, pointToInsert) {\n        let np;\n        if (insertAfter.next != null) {\n            np = PolylinePoint.mkFromPoint(pointToInsert);\n            np.prev = insertAfter;\n            np.next = insertAfter.next;\n            insertAfter.next.prev = np;\n            insertAfter.next = np;\n        }\n        else {\n            np = PolylinePoint.mkFromPoint(pointToInsert);\n            np.prev = insertAfter;\n            insertAfter.next = np;\n            borderPolyline.endPoint = np;\n        }\n        np.polyline = borderPolyline;\n        // Assert.assert(\n        //  !(\n        //    Point.closeDistEps(np.point, np.prevOnPolyline.point) ||\n        //    Point.closeDistEps(np.point, np.nextOnPolyline.point)\n        //  ),\n        // )\n        borderPolyline.setInitIsRequired();\n        return np;\n    }\n    ProcessEvent(p) {\n        // Assert.assert(this.invariant())\n        if (p instanceof VertexEvent) {\n            this.ProcessVertexEvent(p);\n        }\n        else {\n            if (p instanceof RightIntersectionEvent) {\n                this.ProcessRightIntersectionEvent(p);\n            }\n            else {\n                if (p instanceof LeftIntersectionEvent) {\n                    this.ProcessLeftIntersectionEvent(p);\n                }\n                else {\n                    if (p instanceof ConeClosureEvent) {\n                        if (!p.ConeToClose.Removed) {\n                            this.RemoveCone(p.ConeToClose);\n                        }\n                    }\n                    else {\n                        this.ProcessPortObstacleEvent(p);\n                    }\n                    this.Z = this.GetZS(p);\n                }\n            }\n        }\n        // Assert.assert(TreesAreCorrect());\n    }\n    // #if TEST_MSAGL\n    //        protected override bool TreesAreCorrect() {\n    //            return TreeIsCorrect(leftConeSides) && TreeIsCorrect(rightConeSides);\n    //        }\n    //\n    //        bool TreeIsCorrect(RBTree<ConeSide> tree) {\n    //            var y = Number.NEGATIVE_INFINITY;\n    //            foreach (var t of tree) {\n    //                var x = coneSideComparer.IntersectionOfSegmentAndSweepLine(t);\n    //                var yp = x*DirectionPerp;\n    //                if (yp < y - GeomConstants.distanceEpsilon)\n    //                    return false;\n    //                y = yp;\n    //            }\n    //            return true;\n    //        }\n    // #endif\n    ProcessPortObstacleEvent(portObstacleEvent) {\n        this.Z = this.GetZS(portObstacleEvent);\n        this.GoOverConesSeeingVertexEvent(portObstacleEvent);\n        this.CreateConeOnVertex(portObstacleEvent);\n    }\n    ProcessLeftIntersectionEvent(leftIntersectionEvent) {\n        if (leftIntersectionEvent.coneLeftSide.Removed === false) {\n            if (Math.abs(leftIntersectionEvent.EndVertex.point.sub(leftIntersectionEvent.Site).dot(this.SweepDirection)) <\n                GeomConstants.distanceEpsilon) {\n                // the cone is totally covered by a horizontal segment\n                this.RemoveCone(leftIntersectionEvent.coneLeftSide.Cone);\n            }\n            else {\n                this.RemoveSegFromLeftTree(leftIntersectionEvent.coneLeftSide);\n                this.Z = this.GetZP(leftIntersectionEvent.Site);\n                // it is safe now to restore the order\n                const leftSide = new BrokenConeSide(leftIntersectionEvent.Site, leftIntersectionEvent.EndVertex, leftIntersectionEvent.coneLeftSide);\n                this.InsertToTree(this.leftConeSides, leftSide);\n                leftIntersectionEvent.coneLeftSide.Cone.LeftSide = leftSide;\n                this.LookForIntersectionOfObstacleSideAndLeftConeSide(leftIntersectionEvent.Site, leftIntersectionEvent.EndVertex);\n                this.TryCreateConeClosureForLeftSide(leftSide);\n            }\n        }\n        else {\n            this.Z = this.GetZP(leftIntersectionEvent.Site);\n        }\n    }\n    TryCreateConeClosureForLeftSide(leftSide) {\n        if (leftSide.Cone.RightSide instanceof ConeRightSide) {\n            const coneRightSide = leftSide.Cone.RightSide;\n            if (Point.getTriangleOrientation(coneRightSide.Start, coneRightSide.Start.add(coneRightSide.Direction), leftSide.EndVertex.point) ==\n                TriangleOrientation.Clockwise) {\n                this.CreateConeClosureEvent(leftSide, coneRightSide);\n            }\n        }\n    }\n    CreateConeClosureEvent(brokenConeSide, otherSide) {\n        const x = Point.RayIntersectsRayInteriors(brokenConeSide.start, brokenConeSide.Direction, otherSide.Start, otherSide.Direction);\n        if (x) {\n            const cc = new ConeClosureEvent(x, brokenConeSide.Cone);\n            this.EnqueueEvent(cc);\n        }\n    }\n    ProcessRightIntersectionEvent(rightIntersectionEvent) {\n        // restore Z for the time being\n        // Z = PreviousZ;\n        if (!rightIntersectionEvent.coneRightSide.Removed) {\n            // it can happen that the cone side participating in the intersection is gone;\n            // obstracted by another obstacle or because of a vertex found inside of the cone\n            // PrintOutRightSegTree();\n            this.RemoveSegFromRightTree(rightIntersectionEvent.coneRightSide);\n            this.Z = this.GetZP(rightIntersectionEvent.Site);\n            const rightSide = new BrokenConeSide(rightIntersectionEvent.Site, rightIntersectionEvent.EndVertex, rightIntersectionEvent.coneRightSide);\n            this.InsertToTree(this.rightConeSides, rightSide);\n            rightIntersectionEvent.coneRightSide.Cone.RightSide = rightSide;\n            this.LookForIntersectionOfObstacleSideAndRightConeSide(rightIntersectionEvent.Site, rightIntersectionEvent.EndVertex);\n            this.TryCreateConeClosureForRightSide(rightSide);\n        }\n        else {\n            this.Z = this.GetZP(rightIntersectionEvent.Site);\n        }\n    }\n    TryCreateConeClosureForRightSide(rightSide) {\n        if (rightSide.Cone.LeftSide instanceof ConeLeftSide) {\n            const coneLeftSide = rightSide.Cone.LeftSide;\n            if (Point.getTriangleOrientation(coneLeftSide.Start, coneLeftSide.Start.add(coneLeftSide.Direction), rightSide.EndVertex.point) ==\n                TriangleOrientation.Counterclockwise) {\n                this.CreateConeClosureEvent(rightSide, coneLeftSide);\n            }\n        }\n    }\n    RemoveConesClosedBySegment(leftPoint, rightPoint) {\n        this.CloseConesCoveredBySegment(leftPoint, rightPoint, this.GetZP(leftPoint) > this.GetZP(rightPoint) ? this.leftConeSides : this.rightConeSides);\n    }\n    CloseConesCoveredBySegment(leftPoint, rightPoint, tree) {\n        //Assert.assert(rightPoint.sub(leftPoint).dot(this.directionPerp) > GeomConstants.distanceEpsilon)\n        let node = tree.findFirst((s) => Point.getTriangleOrientation(s.Start, s.Start.add(s.Direction), leftPoint) === TriangleOrientation.Counterclockwise);\n        if (node == null)\n            return;\n        const x = Point.IntervalIntersectsRay(leftPoint, rightPoint, node.item.Start, node.item.Direction);\n        if (!x) {\n            return;\n        }\n        const conesToRemove = new Array();\n        do {\n            conesToRemove.push(node.item.Cone);\n            node = tree.next(node);\n        } while (node != null && Point.IntervalIntersectsRay(leftPoint, rightPoint, node.item.Start, node.item.Direction) !== undefined);\n        for (const cone of conesToRemove)\n            this.RemoveCone(cone);\n    }\n    ProcessVertexEvent(vertexEvent) {\n        this.Z = this.GetZS(vertexEvent);\n        this.GoOverConesSeeingVertexEvent(vertexEvent);\n        this.AddConeAndEnqueueEvents(vertexEvent);\n    }\n    // #if TEST_MSAGL\n    //         // ReSharper disable UnusedMember.Local\n    //         static Ellipse EllipseOnVert(SweepEvent vertexEvent) {\n    //             // ReSharper restore UnusedMember.Local\n    //             return new Ellipse(5, 5, vertexEvent.Site);\n    //         }\n    //         // ReSharper disable UnusedMember.Local\n    //         static Ellipse EllipseOnPolylinePoint(PolylinePoint pp) {\n    //             // ReSharper restore UnusedMember.Local\n    //             return EllipseOnPolylinePoint(pp, 5);\n    //         }\n    //         // ReSharper disable UnusedMember.Local\n    //         static Ellipse EllipseOnPolylinePoint(PolylinePoint pp, double i)\n    //         // ReSharper restore UnusedMember.Local\n    //         {\n    //             return new Ellipse(i, i, pp.point);\n    //         }\n    static Diamond(p) {\n        return CurveFactory.mkDiamond(2, 2, p);\n    }\n    //         // ReSharper disable UnusedMember.Local\n    //             \"CA1303:Do not pass literals as localized parameters\", MessageId = \"System.Diagnostics.Debug.WriteLine(System.String)\"\n    //         ),\n    //         void CheckConsistency() {\n    //             // ReSharper restore UnusedMember.Local\n    //             foreach(var s of rightConeSides) {\n    //                 coneSideComparer.SetOperand(s);\n    //             }\n    //             foreach(var s of leftConeSides) {\n    //                 coneSideComparer.SetOperand(s);\n    //                 if (!rightConeSides.Contains(s.Cone.RightSide)) {\n    //                     PrintOutRightSegTree();\n    //                     PrintOutLeftSegTree();\n    //                     ShowLeftTree();\n    //                     ShowRightTree();\n    //                 }\n    //             }\n    //         }\n    //         void ShowRightTree(params ICurve[] curves) {\n    //             var l = Obstacles.Select(p => new DebugCurve(100, 5, \"green\", p)).ToList();\n    //             l.AddRange(rightConeSides.Select(s => new DebugCurve(100, 5, \"blue\", ExtendSegmentToZ(s))));\n    //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)\n    //             //                l.Add(BezierOnEdge(edge));\n    //             l.AddRange(curves.Select(c => new DebugCurve(100, 5, \"brown\", c)));\n    //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n    //         }\n    //         void ShowBothTrees(params DebugCurve[] curves) {\n    //             var l = Obstacles.Select(p => new DebugCurve(100, 5, \"green\", p)).ToList();\n    //             l.AddRange(leftConeSides.Select(s => new DebugCurve(ExtendSegmentToZ(s))));\n    //             l.AddRange(rightConeSides.Select(s => new DebugCurve(ExtendSegmentToZ(s))));\n    //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)\n    //             //                l.Add(BezierOnEdge(edge));\n    //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n    //         }\n    //         void ShowLeftTree(params ICurve[] curves) {\n    //             var l = Obstacles.Select(p => new DebugCurve(100, 0.01, \"green\", p)).ToList();\n    //             var range = new RealNumberSpan();\n    //             var ellipseSize = 0.01;\n    //             foreach(var s of leftConeSides) {\n    //                 var curve = ExtendSegmentToZ(s);\n    //                 range.AddValue(curve.start * DirectionPerp);\n    //                 range.AddValue(curve.End * DirectionPerp);\n    //                 l.Add(new DebugCurve(100, 0.1, \"red\", curve));\n    //                 l.Add(new DebugCurve(200, 0.1, \"black\", new Ellipse(ellipseSize, ellipseSize, curve.End)));\n    //                 ellipseSize += 2;\n    //             }\n    //             l.Add(DebugSweepLine(range));\n    //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)\n    //             //                l.Add(BezierOnEdge(edge));\n    //             l.AddRange(curves.Select(c => new DebugCurve(100, 0.5, \"brown\", c)));\n    //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);\n    //         }\n    //         DebugCurve DebugSweepLine(RealNumberSpan range) {\n    //             var ls = new LineSegment(Z * SweepDirection + DirectionPerp * range.Min, Z * SweepDirection + DirectionPerp * range.Max);\n    //             return new DebugCurve(100, 0.1, \"magenta\", ls);\n    //         }\n    // #endif\n    AddConeAndEnqueueEvents(vertexEvent) {\n        if (vertexEvent instanceof LeftVertexEvent) {\n            const nextPoint = vertexEvent.Vertex.nextOnPolyline;\n            this.CloseConesAddConeAtLeftVertex(vertexEvent, nextPoint);\n        }\n        else {\n            if (vertexEvent instanceof RightVertexEvent) {\n                const nextPoint = vertexEvent.Vertex.prevOnPolyline;\n                this.CloseConesAddConeAtRightVertex(vertexEvent, nextPoint);\n            }\n            else {\n                this.CloseConesAddConeAtLeftVertex(vertexEvent, vertexEvent.Vertex.nextOnPolyline);\n                this.CloseConesAddConeAtRightVertex(vertexEvent, vertexEvent.Vertex.prevOnPolyline);\n            }\n        }\n    }\n    CloseConesAddConeAtRightVertex(rightVertexEvent, nextVertex) {\n        const prevSite = rightVertexEvent.Vertex.nextOnPolyline.point;\n        if (this.directionPerp.dot(rightVertexEvent.Site.sub(prevSite)) > GeomConstants.distanceEpsilon) {\n            this.RemoveConesClosedBySegment(prevSite, rightVertexEvent.Vertex.point);\n        }\n        if (this.directionPerp.dot(nextVertex.point.sub(rightVertexEvent.Site)) > GeomConstants.distanceEpsilon) {\n            this.RemoveConesClosedBySegment(rightVertexEvent.Site, nextVertex.point);\n        }\n        const site = rightVertexEvent.Site;\n        const coneLp = site.add(this.ConeLeftSideDirection);\n        const coneRp = site.add(this.ConeRightSideDirection);\n        const nextSite = nextVertex.point;\n        // SugiyamaLayoutSettings.Show(new LineSegment(site, coneLP), new LineSegment(site, coneRP), new LineSegment(site, nextSite));\n        // try to remove the right side\n        if (this.GetZP(site.sub(prevSite)) > GeomConstants.distanceEpsilon) {\n            this.RemoveRightSide(new RightObstacleSide(rightVertexEvent.Vertex.nextOnPolyline));\n        }\n        if (this.GetZP(site.sub(nextVertex.point)) > GeomConstants.distanceEpsilon) {\n            this.RemoveLeftSide(new LeftObstacleSide(nextVertex));\n        }\n        if (this.GetZP(nextSite) + GeomConstants.distanceEpsilon < this.GetZS(rightVertexEvent)) {\n            this.CreateConeOnVertex(rightVertexEvent);\n        }\n        if (!Point.PointToTheRightOfLineOrOnLine(nextSite, site, coneLp)) {\n            // if (angle <= -coneAngle / 2) {\n            this.CreateConeOnVertex(rightVertexEvent);\n            if (Point.PointToTheLeftOfLineOrOnLine(nextSite.add(this.DirectionPerp), nextSite, site)) {\n                this.EnqueueRightVertexEvent(new RightVertexEvent(nextVertex));\n            }\n            //  TryEnqueueRighVertexEvent(nextVertex);\n        }\n        else if (Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneRp)) {\n            this.CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent, nextVertex);\n        }\n        else {\n            if (this.GetZP(nextSite.sub(site)) > GeomConstants.distanceEpsilon) {\n                this.LookForIntersectionOfObstacleSideAndLeftConeSide(rightVertexEvent.Site, nextVertex);\n                this.InsertRightSide(new RightObstacleSide(rightVertexEvent.Vertex));\n            }\n            this.EnqueueRightVertexEvent(new RightVertexEvent(nextVertex));\n        }\n    }\n    CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent, nextVertex) {\n        this.EnqueueRightVertexEvent(new RightVertexEvent(nextVertex));\n        // the obstacle side is inside of the cone\n        // we need to create an obstacle left side segment instead of the left cone side\n        const cone = new Cone(rightVertexEvent.Vertex.point, this);\n        const obstacleSideSeg = new BrokenConeSide(cone.Apex, nextVertex, new ConeLeftSide(cone));\n        cone.LeftSide = obstacleSideSeg;\n        cone.RightSide = new ConeRightSide(cone);\n        const rnode = this.InsertToTree(this.rightConeSides, cone.RightSide);\n        this.LookForIntersectionWithConeRightSide(rnode);\n        const lnode = this.InsertToTree(this.leftConeSides, cone.LeftSide);\n        this.FixConeLeftSideIntersections(obstacleSideSeg, lnode);\n        if (this.GetZP(nextVertex.point.sub(rightVertexEvent.Site)) > GeomConstants.distanceEpsilon) {\n            this.InsertRightSide(new RightObstacleSide(rightVertexEvent.Vertex));\n        }\n    }\n    LookForIntersectionOfObstacleSideAndRightConeSide(obstacleSideStart, obstacleSideVertex) {\n        const node = this.GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart);\n        if (node != null) {\n            if (node.item instanceof ConeRightSide) {\n                const intersection = Point.IntervalIntersectsRay(obstacleSideStart, obstacleSideVertex.point, node.item.Start, this.ConeRightSideDirection);\n                if (intersection && this.SegmentIsNotHorizontal(intersection, obstacleSideVertex.point)) {\n                    this.EnqueueEvent(this.CreateRightIntersectionEvent(node.item, intersection, obstacleSideVertex));\n                }\n            }\n        }\n    }\n    CreateRightIntersectionEvent(coneRightSide, intersection, obstacleSideVertex) {\n        // Assert.assert(\n        //  Math.abs(this.GetZP(obstacleSideVertex.point.sub(intersection))) > 0,\n        // )\n        return new RightIntersectionEvent(coneRightSide, intersection, obstacleSideVertex);\n    }\n    GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart) {\n        return this.rightConeSides.findLast((s) => LineSweeper.PointIsToTheRightOfSegment(obstacleSideStart, s));\n    }\n    LookForIntersectionOfObstacleSideAndLeftConeSide(obstacleSideStart, obstacleSideVertex) {\n        const node = this.GetFirstNodeToTheRightOfPoint(obstacleSideStart);\n        //          ShowLeftTree(Box(obstacleSideStart));\n        if (node == null) {\n            return;\n        }\n        if (!(node.item instanceof ConeLeftSide))\n            return;\n        const coneLeftSide = node.item;\n        const intersection = Point.IntervalIntersectsRay(obstacleSideStart, obstacleSideVertex.point, coneLeftSide.Start, this.ConeLeftSideDirection);\n        if (intersection) {\n            this.EnqueueEvent(new LeftIntersectionEvent(coneLeftSide, intersection, obstacleSideVertex));\n        }\n    }\n    GetFirstNodeToTheRightOfPoint(p) {\n        return this.leftConeSides.findFirst((s) => LineSweeper.PointIsToTheLeftOfSegment(p, s));\n    }\n    static PointIsToTheLeftOfSegment(p, seg) {\n        return Point.getTriangleOrientation(seg.Start, seg.Start.add(seg.Direction), p) === TriangleOrientation.Counterclockwise;\n    }\n    static PointIsToTheRightOfSegment(p, seg) {\n        return Point.getTriangleOrientation(seg.Start, seg.Start.add(seg.Direction), p) === TriangleOrientation.Clockwise;\n    }\n    FixConeLeftSideIntersections(leftSide, rbNode) {\n        // the first intersection can happen only with succesors of leftSide\n        // Assert.assert(rbNode != null)\n        do {\n            // this loop usually works only once\n            rbNode = this.leftConeSides.next(rbNode);\n        } while (rbNode != null &&\n            Point.PointToTheRightOfLineOrOnLine(leftSide.Start, rbNode.item.Start, rbNode.item.Start.add(rbNode.item.Direction)));\n        if (rbNode != null) {\n            if (rbNode.item instanceof ConeLeftSide) {\n                const seg = rbNode.item;\n                const intersection = Point.IntervalIntersectsRay(leftSide.start, leftSide.End, seg.Start, seg.Direction);\n                if (intersection) {\n                    this.EnqueueEvent(new LeftIntersectionEvent(seg, intersection, leftSide.EndVertex));\n                }\n            }\n        }\n    }\n    InsertToTree(tree, coneSide) {\n        //Assert.assert(this.GetZP(coneSide.Direction) > 0)\n        this.coneSideComparer.SetOperand(coneSide);\n        return tree.insert(coneSide);\n    }\n    CloseConesAddConeAtLeftVertex(leftVertexEvent, nextVertex) {\n        // close segments first\n        const prevSite = leftVertexEvent.Vertex.prevOnPolyline.point;\n        if (leftVertexEvent.Site.sub(prevSite).dot(this.directionPerp) < -GeomConstants.distanceEpsilon) {\n            // we have a low non-vertical side going to the left from prevSite to leftVertexEvent\n            this.RemoveConesClosedBySegment(leftVertexEvent.Site, prevSite);\n        }\n        if (nextVertex.point.sub(leftVertexEvent.Site).dot(this.directionPerp) < -GeomConstants.distanceEpsilon) {\n            this.RemoveConesClosedBySegment(nextVertex.point, leftVertexEvent.Site);\n        }\n        const site = leftVertexEvent.Site;\n        const coneLp = site.add(this.ConeLeftSideDirection);\n        const coneRp = site.add(this.ConeRightSideDirection);\n        const nextSite = nextVertex.point;\n        // SugiyamaLayoutSettings.Show(new LineSegment(site, coneLP), new LineSegment(site, coneRP), new LineSegment(site, nextSite));\n        if (this.GetZP(site.sub(prevSite)) > GeomConstants.distanceEpsilon) {\n            this.RemoveLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex.prevOnPolyline));\n        }\n        const nextDelZ = this.GetZP(nextSite) - this.Z;\n        if (nextDelZ < -GeomConstants.distanceEpsilon) {\n            this.RemoveRightSide(new RightObstacleSide(nextVertex));\n        }\n        const toNext = nextSite.sub(leftVertexEvent.Site);\n        if (nextDelZ < -GeomConstants.distanceEpsilon ||\n            (closeDistEps(nextDelZ, 0) && this.GetZP(toNext) > 0 && toNext.dot(this.directionPerp) > -GeomConstants.distanceEpsilon)) {\n            // if (angle > Math.PI / 2)\n            this.CreateConeOnVertex(leftVertexEvent); // it is the last left vertex on this obstacle\n        }\n        else if (!Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneRp)) {\n            // if (angle >= coneAngle / 2) {\n            this.CreateConeOnVertex(leftVertexEvent);\n            this.EnqueueEvent(new LeftVertexEvent(nextVertex));\n            // we schedule LeftVertexEvent for a vertex with horizontal segment to the left on the top of the obstace\n        }\n        else if (!Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneLp)) {\n            // if (angle >= -coneAngle / 2) {\n            // we cannot completely obscure the cone here\n            this.EnqueueEvent(new LeftVertexEvent(nextVertex));\n            // the obstacle side is inside of the cone\n            // we need to create an obstacle right side segment instead of the cone side\n            const cone = new Cone(leftVertexEvent.Vertex.point, this);\n            const rightSide = new BrokenConeSide(leftVertexEvent.Vertex.point, nextVertex, new ConeRightSide(cone));\n            cone.RightSide = rightSide;\n            cone.LeftSide = new ConeLeftSide(cone);\n            this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides, cone.LeftSide));\n            const rbNode = this.InsertToTree(this.rightConeSides, rightSide);\n            this.FixConeRightSideIntersections(rightSide, rbNode);\n            if (this.GetZP(toNext) > GeomConstants.distanceEpsilon) {\n                this.InsertLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex));\n            }\n        }\n        else {\n            this.EnqueueEvent(new LeftVertexEvent(nextVertex));\n            if (this.GetZP(toNext) > GeomConstants.distanceEpsilon) {\n                // if( angle >- Pi/2\n                // Assert.assert(angle > -Math.PI / 2);\n                this.LookForIntersectionOfObstacleSideAndRightConeSide(leftVertexEvent.Site, nextVertex);\n                this.InsertLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex));\n            }\n        }\n    }\n    RemoveCone(cone) {\n        // the following should not happen if the containment hierarchy is correct.\n        // If containment is not correct it still should not result in a fatal error, just a funny looking route.\n        // Assert.assert(cone.Removed === false);\n        cone.Removed = true;\n        this.RemoveSegFromLeftTree(cone.LeftSide);\n        this.RemoveSegFromRightTree(cone.RightSide);\n    }\n    RemoveSegFromRightTree(coneSide) {\n        //   ShowRightTree();\n        //Assert.assert(coneSide.Removed === false)\n        this.coneSideComparer.SetOperand(coneSide);\n        let b = this.rightConeSides.remove(coneSide);\n        coneSide.Removed = true;\n        if (b == null) {\n            const tmpZ = this.Z;\n            this.Z = Math.max(this.GetZP(coneSide.Start), this.Z - 0.01);\n            // we need to return to the past a little bit when the order was still correc\n            this.coneSideComparer.SetOperand(coneSide);\n            b = this.rightConeSides.remove(coneSide);\n            this.Z = tmpZ;\n            // #if TEST_MSAGL\n            //                 if (b == null ) {\n            //                     PrintOutRightSegTree();\n            //                 }\n            // #endif\n        }\n    }\n    RemoveSegFromLeftTree(coneSide) {\n        //Assert.assert(coneSide.Removed === false)\n        coneSide.Removed = true;\n        this.coneSideComparer.SetOperand(coneSide);\n        const b = this.leftConeSides.remove(coneSide);\n        if (b == null) {\n            const tmpZ = this.Z;\n            this.Z = Math.max(this.GetZP(coneSide.Start), this.Z - 0.01);\n            this.coneSideComparer.SetOperand(coneSide);\n            // #if TEST_MSAGL\n            //                 b =\n            // #endif\n            this.leftConeSides.remove(coneSide);\n            this.Z = tmpZ;\n            // #if TEST_MSAGL\n            //                 if (b == null ) {\n            //                     PrintOutLeftSegTree();\n            //                     ShowLeftTree(new Ellipse(2, 2, coneSide.start));\n            //                 }\n            // #endif\n        }\n        //Assert.assert(b != null)\n    }\n    FixConeRightSideIntersections(rightSide, rbNode) {\n        // the first intersection can happen only with predecessors of rightSide\n        //Assert.assert(rbNode != null)\n        do {\n            // this loop usually works only once\n            rbNode = this.rightConeSides.previous(rbNode);\n        } while (rbNode != null &&\n            Point.PointToTheLeftOfLineOrOnLine(rightSide.start, rbNode.item.Start, rbNode.item.Start.add(rbNode.item.Direction)));\n        if (rbNode != null) {\n            let intersection;\n            if (rbNode.item instanceof ConeRightSide) {\n                const seg = rbNode.item;\n                if ((intersection = Point.IntervalIntersectsRay(rightSide.start, rightSide.End, seg.Start, seg.Direction))) {\n                    this.EnqueueEvent(this.CreateRightIntersectionEvent(seg, intersection, rightSide.EndVertex));\n                    // Show(CurveFactory.CreateDiamond(3, 3, intersection));\n                }\n            }\n        }\n    }\n    CreateConeOnVertex(sweepEvent) {\n        const cone = new Cone(sweepEvent.Site, this);\n        cone.LeftSide = new ConeLeftSide(cone);\n        cone.RightSide = new ConeRightSide(cone);\n        const leftNode = this.InsertToTree(this.leftConeSides, cone.LeftSide);\n        const rightNode = this.InsertToTree(this.rightConeSides, cone.RightSide);\n        this.LookForIntersectionWithConeRightSide(rightNode);\n        this.LookForIntersectionWithConeLeftSide(leftNode);\n    }\n    LookForIntersectionWithConeLeftSide(leftNode) {\n        // Show(new Ellipse(1, 1, leftNode.item.start));\n        if (leftNode.item instanceof ConeLeftSide) {\n            const coneLeftSide = leftNode.item;\n            const rightObstacleSide = this.FindFirstObstacleSideToTheLeftOfPoint(coneLeftSide.Start);\n            if (rightObstacleSide != null) {\n                this.TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide, rightObstacleSide);\n            }\n        }\n        else {\n            const seg = leftNode.item;\n            leftNode = this.leftConeSides.next(leftNode);\n            if (leftNode != null) {\n                if (leftNode.item instanceof ConeLeftSide) {\n                    this.TryIntersectionOfConeLeftSideAndObstacleConeSide(leftNode.item, seg);\n                }\n            }\n        }\n    }\n    LookForIntersectionWithConeRightSide(rightNode) {\n        // Show(new Ellipse(10, 5, rightNode.item.start));\n        if (rightNode.item instanceof ConeRightSide) {\n            const crs = rightNode.item;\n            const leftObstacleSide = this.FindFirstObstacleSideToToTheRightOfPoint(crs.Start);\n            if (leftObstacleSide != null) {\n                this.TryIntersectionOfConeRightSideAndObstacleSide(crs, leftObstacleSide);\n            }\n        }\n        else {\n            const seg = rightNode.item;\n            rightNode = this.rightConeSides.previous(rightNode);\n            if (rightNode != null) {\n                if (rightNode.item instanceof ConeRightSide) {\n                    this.TryIntersectionOfConeRightSideAndObstacleConeSide(rightNode.item, seg);\n                }\n            }\n        }\n    }\n    TryIntersectionOfConeRightSideAndObstacleConeSide(coneRightSide, seg) {\n        const x = Point.IntervalIntersectsRay(seg.start, seg.End, coneRightSide.Start, coneRightSide.Direction);\n        if (x) {\n            this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, x, seg.EndVertex));\n            // Show(CurveFactory.CreateDiamond(3, 3, x));\n        }\n    }\n    TryIntersectionOfConeRightSideAndObstacleSide(coneRightSide, side) {\n        const x = Point.IntervalIntersectsRay(side.Start, side.End, coneRightSide.Start, coneRightSide.Direction);\n        if (x) {\n            this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, x, side.EndVertex));\n            // Show(CurveFactory.CreateDiamond(3, 3, x));\n        }\n    }\n    TryIntersectionOfConeLeftSideAndObstacleConeSide(coneLeftSide, seg) {\n        const x = Point.IntervalIntersectsRay(seg.start, seg.End, coneLeftSide.Start, coneLeftSide.Direction);\n        if (x) {\n            this.EnqueueEvent(new LeftIntersectionEvent(coneLeftSide, x, seg.EndVertex));\n            // Show(CurveFactory.CreateDiamond(3, 3, x));\n        }\n    }\n    TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide, side) {\n        const x = Point.IntervalIntersectsRay(side.Start, side.End, coneLeftSide.Start, coneLeftSide.Direction);\n        if (x) {\n            this.EnqueueEvent(new LeftIntersectionEvent(coneLeftSide, x, side.EndVertex));\n            //    Show(CurveFactory.CreateDiamond(3, 3, x));\n        }\n    }\n    // Show(curves: ICurve[], fn: string) {\n    //   let l = Array.from(this.Obstacles).map((o) => DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Blue', o))\n    //   for (const s of this.rightConeSides) {\n    //     l.push(DebugCurve.mkDebugCurveWCI(0.5, 'Brown', this.ExtendSegmentToZ(s)))\n    //     if (s instanceof BrokenConeSide) l.push(DebugCurve.mkDebugCurveCI('Brown', LineSweeper.Diamond(s.start)))\n    //     l.push(DebugCurve.mkDebugCurveWCI(0.5, 'Green', this.ExtendSegmentToZ(s.Cone.LeftSide)))\n    //     if (s.Cone.LeftSide instanceof BrokenConeSide) l.push(DebugCurve.mkDebugCurveCI('Green', LineSweeper.Diamond(s.Cone.LeftSide.start)))\n    //   }\n    //   l.push(\n    //     ...Array.from(this.visibilityGraph.Edges).map((edge) =>\n    //       DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Cyan', LineSegment.mkPP(edge.SourcePoint, edge.TargetPoint)),\n    //     ),\n    //   )\n    //   l.push(...curves.map((c) => DebugCurve.mkDebugCurveCI('Red', c)))\n    //   l.push(\n    //     ...Array.from(this.eventQueue)\n    //       .filter((e) => e instanceof RightIntersectionEvent)\n    //       .map((e) => DebugCurve.mkDebugCurveCI('Black', LineSweeper.mkRightIntersDiamond(e.Site))),\n    //   )\n    //   SvgDebugWriter.dumpDebugCurves(fn, l)\n    // }\n    //         static BezierSeg BezierOnEdge(VisibilityEdge edge) {\n    //             return new BezierSeg(edge.SourcePoint, 2.0 / 3.0 * edge.SourcePoint + 1.0 / 3.0 * edge.TargetPoint,\n    //                 1.0 / 3.0 * edge.SourcePoint + 2.0 / 3.0 * edge.TargetPoint, edge.TargetPoint);\n    //         }\n    ExtendSegmentToZ(segment) {\n        const den = segment.Direction.dot(this.SweepDirection);\n        //Assert.assert(Math.Abs(den) > GeomConstants.distanceEpsilon);\n        const t = (this.Z + 40 - segment.Start.dot(this.SweepDirection)) / den;\n        return LineSegment.mkPP(segment.Start, segment.Start.add(segment.Direction.mul(t)));\n    }\n    //         internal ICurve ExtendSegmentToZPlus1(ConeSide segment) {\n    //             double den = segment.Direction * SweepDirection;\n    //             Assert.assert(Math.Abs(den) > GeomConstants.distanceEpsilon);\n    //             double t = (Z + 1 - segment.start * SweepDirection) / den;\n    //             return new LineSegment(segment.start, segment.start + segment.Direction * t);\n    //         }\n    // #endif\n    GoOverConesSeeingVertexEvent(vertexEvent) {\n        let rbNode = this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent);\n        if (rbNode == null) {\n            return;\n        }\n        const coneRightSide = rbNode.item;\n        const cone = coneRightSide.Cone;\n        const leftConeSide = cone.LeftSide;\n        if (LineSweeper.VertexIsToTheLeftOfSegment(vertexEvent, leftConeSide)) {\n            return;\n        }\n        const visibleCones = [cone];\n        this.coneSideComparer.SetOperand(leftConeSide);\n        rbNode = this.leftConeSides.find(leftConeSide);\n        if (rbNode == null) {\n            //this.Show([CurveFactory.CreateDiamond(10, 10, vertexEvent.Site)], './tmp/bug.svg')\n            const tmpZ = this.Z;\n            this.Z = Math.max(this.GetZP(leftConeSide.Start), this.PreviousZ);\n            // we need to return to the past a little bit when the order was still correct\n            this.coneSideComparer.SetOperand(leftConeSide);\n            rbNode = this.leftConeSides.find(leftConeSide);\n            this.Z = tmpZ;\n            // #if TEST_MSAGL\n            // //                if (rbNode == null ) {\n            //                     //GeometryGraph gg = CreateGraphFromObstacles();\n            //                     //gg.Save(\"c:\\\\tmp\\\\bug\");\n            // //                    PrintOutLeftSegTree();\n            // //                    System.Diagnostics.Debug.WriteLine(leftConeSide);\n            // //                    ShowLeftTree(new Ellipse(3, 3, vertexEvent.Site));\n            // //                    ShowRightTree(new Ellipse(3, 3, vertexEvent.Site));\n            // //                }\n            // #endif\n        }\n        // the following should not happen if the containment hierarchy is correct.\n        // If containment is not correct it still should not result in a fatal error, just a funny looking route.\n        // Assert.assert(rbNode!=null);\n        if (rbNode == null) {\n            // it is an emergency measure and should not happen\n            rbNode = this.GetRbNodeEmergency(leftConeSide);\n            if (rbNode == null) {\n                return; // the cone is not there! and it is a bug\n            }\n        }\n        rbNode = this.leftConeSides.next(rbNode);\n        while (rbNode != null && !LineSweeper.VertexIsToTheLeftOfSegment(vertexEvent, rbNode.item)) {\n            visibleCones.push(rbNode.item.Cone);\n            rbNode = this.leftConeSides.next(rbNode);\n        }\n        for (const visCone of visibleCones)\n            this.AddEdgeAndRemoveCone(visCone, vertexEvent.Site);\n    }\n    GetRbNodeEmergency(leftConeSide) {\n        if (this.leftConeSides.count === 0)\n            return null;\n        for (let node = this.leftConeSides.treeMinimum(); node != null; node = this.leftConeSides.next(node)) {\n            if (node.item === leftConeSide) {\n                return node;\n            }\n        }\n        return null;\n    }\n    // #if TEST_MSAGL\n    //             MessageId = \"System.Int32.ToString\")]\n    //         internal static GeometryGraph CreateGraphFromObstacles(Array < Polyline > obstacles) {\n    //             var gg = new GeometryGraph();\n    //             foreach(var ob of obstacles) {\n    //                 gg.Nodes.Add(new Node(ob.ToCurve()));\n    //             }\n    //             return gg;\n    //         }\n    //             \"CA1303:Do not pass literals as localized parameters\", MessageId = \"System.Diagnostics.Debug.WriteLine(System.String)\"\n    //         )]\n    //         void PrintOutLeftSegTree() {\n    //             System.Diagnostics.Debug.WriteLine(\"Left cone segments########\");\n    //             foreach(var t of leftConeSides) {\n    //                 var x = coneSideComparer.IntersectionOfSegmentAndSweepLine(t);\n    //                 System.Diagnostics.Debug.WriteLine(\"{0} x={1}\", t, x * DirectionPerp);\n    //             }\n    //             System.Diagnostics.Debug.WriteLine(\"##########end of left cone segments\");\n    //         }\n    // #endif\n    static VertexIsToTheLeftOfSegment(vertexEvent, seg) {\n        return Point.getTriangleOrientation(seg.Start, seg.Start.add(seg.Direction), vertexEvent.Site) === TriangleOrientation.Counterclockwise;\n    }\n    static VertexIsToTheRightOfSegment(vertexEvent, seg) {\n        return Point.getTriangleOrientation(seg.Start, seg.Start.add(seg.Direction), vertexEvent.Site) === TriangleOrientation.Clockwise;\n    }\n    FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent) {\n        return this.rightConeSides.findFirst((s) => !LineSweeper.VertexIsToTheRightOfSegment(vertexEvent, s));\n    }\n    EnqueueRightVertexEvent(vertexEvent) {\n        if (this.GetZP(vertexEvent.Site.sub(vertexEvent.Vertex.prevOnPolyline.point)) > GeomConstants.tolerance) {\n            // otherwise we enqueue the vertex twice; once as a LeftVertexEvent and once as a RightVertexEvent\n            return;\n        }\n        this.EnqueueEvent(vertexEvent);\n    }\n    invariant() {\n        // if (this.leftConeSides.count !== this.rightConeSides.count) {\n        //  return false\n        // }\n        for (const cs of this.leftConeSides) {\n            if (cs.Removed) {\n                return false;\n            }\n        }\n        for (const cs of this.rightConeSides) {\n            if (cs.Removed) {\n                return false;\n            }\n        }\n        // const lsSet = new Set<ConeSide>(this.leftConeSides)\n        // const rsSet = new Set<ConeSide>(this.rightConeSides)\n        // if (lsSet.size !== rsSet.size) return false\n        // const cones = new Set<Cone>()\n        // for (const ls of lsSet) {\n        //  const cone = ls.Cone\n        //  if (!rsSet.has(cone.RightSide)) return false\n        //  cones.add(cone)\n        // }\n        // if (cones.size !== lsSet.size) return false\n        // for (const rs of rsSet) {\n        //  if (!cones.has(rs.Cone)) {\n        //    return false\n        //  }\n        // }\n        // for (const ls of lsSet) {\n        //  if (!cones.has(ls.Cone)) {\n        //    return false\n        //  }\n        // }\n        return true;\n    }\n}\n//# sourceMappingURL=LineSweeper.js.map","import { VertexEvent } from './VertexEvent';\nexport class LowestVertexEvent extends VertexEvent {\n    constructor(p) {\n        super(p);\n    }\n}\n//# sourceMappingURL=LowestVertexEvent.js.map","import { SegmentBase } from '../../visibility/SegmentBase';\nexport class ObstacleSide extends SegmentBase {\n    Init(sv) {\n        this.StartVertex = sv;\n    }\n    constructor(startVertex) {\n        super();\n        this.Init(startVertex);\n    }\n    get Polyline() {\n        return this.StartVertex.polyline;\n    }\n    get Start() {\n        return this.StartVertex.point;\n    }\n    get End() {\n        return this.EndVertex.point;\n    }\n}\n//# sourceMappingURL=ObstacleSide.js.map","import { SweepEvent } from './SweepEvent';\n// right here means an intersection of a right cone side with an obstacle edge\nexport class RightIntersectionEvent extends SweepEvent {\n    get EndVertex() {\n        return this.endVertex;\n    }\n    set EndVertex(value) {\n        this.endVertex = value;\n    }\n    constructor(coneRightSide, intersectionPoint, endVertex) {\n        super();\n        this.coneRightSide = coneRightSide;\n        this.intersectionPoint = intersectionPoint;\n        this.endVertex = endVertex;\n    }\n    get Site() {\n        return this.intersectionPoint;\n    }\n    toString() {\n        return 'RightIntersectionEvent ' + this.intersectionPoint;\n    }\n}\n//# sourceMappingURL=RightIntersectionEvent.js.map","import { ObstacleSide } from './ObstacleSide';\nexport class RightObstacleSide extends ObstacleSide {\n    constructor(startVertex) {\n        super(startVertex);\n        this.end = startVertex.prevOnPolyline.point;\n    }\n    get End() {\n        return this.end;\n    }\n    get EndVertex() {\n        return this.StartVertex.prevOnPolyline;\n    }\n}\n//# sourceMappingURL=RightObstacleSide.js.map","import { VertexEvent } from './VertexEvent';\nexport class RightVertexEvent extends VertexEvent {\n    constructor(p) {\n        super(p);\n    }\n}\n//# sourceMappingURL=RightVertexEvent.js.map","export class SweepEvent {\n}\n//# sourceMappingURL=SweepEvent.js.map","import { SweepEvent } from './SweepEvent';\nexport class VertexEvent extends SweepEvent {\n    get Site() {\n        return this.Vertex.point;\n    }\n    constructor(p) {\n        super();\n        this.Vertex = p;\n    }\n    get Polyline() {\n        return this.Vertex.polyline;\n    }\n}\n//# sourceMappingURL=VertexEvent.js.map","import { Queue } from 'queue-typescript';\nimport { Point, Polyline } from '../../math/geometry';\nimport { TriangleOrientation } from '../../math/geometry/point';\nimport { Cdt } from '../ConstrainedDelaunayTriangulation/Cdt';\n//import {SvgDebugWriter} from '../../../test/utils/svgDebugWriter'\n//import {DebugCurve} from '../../math/geometry/debugCurve'\n/** Optimize path locally, without changing its topology.\n * The obstacles are represented by constrained edges of cdd, the Delaunay triangulation.\n * It is not assumed that the polyline passes only through the sites of the cdt.\n//  */\nlet debCount = 0;\nlet drawCount = 0;\nexport class PathOptimizer {\n    constructor() {\n        this.triangles = new Set();\n        // threader region\n    }\n    setCdt(cdt) {\n        this.cdt = cdt;\n        this.cdt.SetInEdges();\n        const polys = new Set();\n        for (const t of cdt.GetTriangles()) {\n            for (const s of t.Sites) {\n                if (s.Owner != null)\n                    polys.add(s.Owner);\n            }\n        }\n    }\n    outsideOfObstacles(t) {\n        var _a;\n        if (t == null)\n            return false;\n        const owner = (_a = t.Sites.item0.Owner) !== null && _a !== void 0 ? _a : t.Sites.item1.Owner;\n        return owner === this.sourcePoly || owner === this.targetPoly || !triangleIsInsideOfObstacle(t);\n    }\n    /** following \"https://page.mi.fu-berlin.de/mulzer/notes/alggeo/polySP.pdf\" */\n    run(poly) {\n        // console.log('debCount=', ++debCount)\n        this.triangles.clear();\n        this.poly = poly;\n        this.d = [];\n        if (poly.count <= 2 || this.cdt == null)\n            return;\n        this.sourcePoly = this.findPoly(poly.start);\n        this.targetPoly = this.findPoly(poly.end);\n        // if (debCount == 132) {\n        //   this.debugDraw(Array.from(this.cdt.GetTriangles()), null, null, poly)\n        // }\n        this.findChannelTriangles();\n        // if (debCount == 132) this.debugDraw(Array.from(this.triangles), null, null, poly)\n        let perimeter = this.getPerimeterEdges();\n        perimeter = this.fillTheCollapedSites(perimeter);\n        // if (debCount == 132) {\n        //   this.debugDraw(Array.from(this.cdt.GetTriangles()), perimeter, null, this.poly)\n        // }\n        const localCdt = new Cdt([], [], Array.from(perimeter).map((e) => {\n            return { A: e.lowerSite.point, B: e.upperSite.point };\n        }));\n        localCdt.run();\n        // if (debCount == 132) {\n        //   this.debugDraw(Array.from(localCdt.GetTriangles()), null, null, poly)\n        // }\n        const sleeve = this.getSleeve(this.findSourceTriangle(localCdt));\n        if (sleeve == null) {\n            // this.poly remains unchanged in this case\n            // in one case the original polyline was crossing a wrong obstacle and it caused the peremiter polyline\n            // not having the end inside\n            console.log('failed to create sleeve');\n            return;\n        }\n        if (sleeve.length == 0) {\n            this.poly = Polyline.mkFromPoints([poly.start, poly.end]);\n            return;\n        }\n        this.initDiagonals(sleeve);\n        this.refineFunnel();\n    }\n    /**A function that returns an array of all crossed triangles\n     * by a line segment from start to end\n     * assuming the initial triangle contains the start point*/\n    getAllCrossedTriangles(t, start, end) {\n        // Initialize an empty array to store the crossed triangles\n        let crossed = [];\n        // Initialize a queue to store the triangles to visit\n        let queue = [];\n        let containsEnd = null;\n        // Add the initial triangle to the queue\n        queue.push(t);\n        // Loop until the queue is empty\n        while (queue.length > 0) {\n            // Dequeue a triangle from the queue\n            let current = queue.pop();\n            if (containsEnd == null && current.containsPoint(end)) {\n                containsEnd = current;\n            }\n            // Check if the triangle intersects the line segment\n            if (current.intersectsLine(start, end, 0)) {\n                // Add the triangle to the crossed array\n                crossed.push(current);\n                // Loop through the neighbors of the triangle\n                for (const e of current.Edges) {\n                    // Check if the neighbor exists and is not already in the crossed array or the queue\n                    const tr = e.GetOtherTriangle_T(current);\n                    if (tr && !crossed.includes(tr) && !queue.includes(tr)) {\n                        // Add the neighbor to the queue\n                        queue.push(tr);\n                    }\n                }\n            }\n        }\n        // Return the crossed array\n        return { triangles: crossed, containsEnd: containsEnd };\n    }\n    findChannelTriangles() {\n        const site = this.cdt.FindSite(this.poly.start);\n        let t = site.Triangles().next().value;\n        this.triangles.clear();\n        for (let p = this.poly.startPoint; p.next != null; p = p.next) {\n            const res = this.getAllCrossedTriangles(t, p.point, p.next.point);\n            t = res.containsEnd;\n            for (const tr of res.triangles) {\n                if (this.outsideOfObstacles(tr))\n                    this.triangles.add(tr);\n            }\n        }\n    }\n    findPoly(p) {\n        var _a;\n        const site = this.cdt.FindSite(p);\n        for (const edge of site.Edges) {\n            const poly = (_a = edge.lowerSite.Owner) !== null && _a !== void 0 ? _a : edge.upperSite.Owner;\n            return poly;\n        }\n    }\n    /** Because of the floating point operations we might miss some triangles and get a polygon collapsing to a point somewhere inside of the polyline.\n     * This point will correspond to a site adjacent to more than two edges from 'perimeter'.\n     * We add to the polygon all the 'legal' triangles adjacent to this cite.\n     */\n    fillTheCollapedSites(perimeter) {\n        const siteToEdges = new Map();\n        for (const e of perimeter) {\n            addEdgeToMap(e.lowerSite, e);\n            addEdgeToMap(e.upperSite, e);\n        }\n        const sitesToFix = [];\n        for (const [site, es] of siteToEdges) {\n            if (es.length > 2) {\n                sitesToFix.push(site);\n            }\n        }\n        if (sitesToFix.length == 0)\n            return perimeter;\n        for (const s of sitesToFix) {\n            for (const t of s.Triangles()) {\n                if (this.outsideOfObstacles(t)) {\n                    this.triangles.add(t);\n                }\n            }\n        }\n        return this.getPerimeterEdges();\n        function addEdgeToMap(site, e) {\n            let es = siteToEdges.get(site);\n            if (es == null) {\n                siteToEdges.set(site, (es = []));\n            }\n            es.push(e);\n        }\n    }\n    findSourceTriangle(localCdt) {\n        let sourceTriangle;\n        for (const t of localCdt.GetTriangles()) {\n            if (t.containsPoint(this.poly.start)) {\n                sourceTriangle = t;\n                break;\n            }\n        }\n        return sourceTriangle;\n    }\n    // debugDraw(triangles: Tr[], perimEdges: Set<Ed>, poly: Polyline, originalPoly: Polyline, strangeObs: ICurve[] = [], ls: ICurve = null) {\n    //   const dc = []\n    //   if (ls) {\n    //     dc.push(DebugCurve.mkDebugCurveTWCI(255, 5, 'PapayaWhip', ls))\n    //   }\n    //   const box = this.poly.boundingBox.clone()\n    //   box.addRec(this.sourcePoly.boundingBox)\n    //   box.addRec(this.targetPoly.boundingBox)\n    //   for (const t of triangles) {\n    //     // if (t.BoundingBox().intersects(box) == false) continue\n    //     for (const e of t.Edges) {\n    //       dc.push(\n    //         DebugCurve.mkDebugCurveTWCI(\n    //           e.constrained ? 150 : 100,\n    //           e.constrained ? 1.5 : 1,\n    //           e.constrained ? 'DarkSeaGreen' : 'Cyan',\n    //           LineSegment.mkPP(e.upperSite.point, e.lowerSite.point),\n    //         ),\n    //       )\n    //     }\n    //   }\n    //   if (perimEdges) {\n    //     for (const e of perimEdges) {\n    //       dc.push(DebugCurve.mkDebugCurveTWCI(200, 2.5, 'Blue', LineSegment.mkPP(e.lowerSite.point, e.upperSite.point)))\n    //     }\n    //   }\n    //   if (poly) dc.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Green', poly))\n    //   for (const strangeOb of strangeObs) {\n    //     dc.push(DebugCurve.mkDebugCurveTWCI(200, 3, 'Pink', strangeOb))\n    //   }\n    //   if (originalPoly) dc.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Brown', originalPoly))\n    //   dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Violet', this.sourcePoly))\n    //   dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Magenta', this.targetPoly))\n    //   SvgDebugWriter.dumpDebugCurves('./tmp/poly' + ++drawCount + '.svg', dc)\n    // }\n    refineFunnel( /*dc: Array<DebugCurve>*/) {\n        // remove param later:Debug\n        const prefix = []; // the path befor apex\n        let v = this.poly.start; // the apex point\n        const leftChainStart = { point: v };\n        const rightChainStart = { point: v };\n        let leftChainEnd = { point: this.d[0].left, prev: leftChainStart };\n        let rightChainEnd = { point: this.d[0].right, prev: rightChainStart };\n        leftChainStart.next = leftChainEnd;\n        rightChainStart.next = rightChainEnd;\n        let z;\n        for (let i = 1; i < this.d.length; i++) {\n            processDiagonal(i, this.d);\n        }\n        // the shortest path will be on the right chain\n        this.d.push({ right: this.poly.end, left: leftChainEnd.point });\n        processDiagonal(this.d.length - 1, this.d);\n        const newPoly = Polyline.mkFromPoints(prefix);\n        for (let p = rightChainStart; p != null; p = p.next) {\n            newPoly.addPoint(p.point);\n        }\n        this.poly = newPoly;\n        function processDiagonal(i, d) {\n            const leftStep = d[i - 1].left !== d[i].left;\n            // Assert.assert(!leftStep || d[i - 1].left.equal(d[i].left) == false)\n            // Assert.assert(leftStep || d[i - 1].right !== d[i].right)\n            if (leftStep) {\n                z = d[i].left;\n                //draw(d[i - 1], d[i], dc)\n                let p = leftChainEnd;\n                for (; !(isApex(p) || reflexLeft(p)); p = p.prev) {\n                    // just stepping back on the left chain\n                }\n                if (isApex(p)) {\n                    walkForwardOnTheRigthUntilSeeZ();\n                }\n                else {\n                    extendLeftChainFromP(p);\n                }\n            }\n            else {\n                // right step: the diagonal advanced on the right chain\n                z = d[i].right;\n                let p = rightChainEnd;\n                for (; !(isApex(p) || reflexRight(p)); p = p.prev) {\n                    // just stepping back on the right chain\n                }\n                if (isApex(p)) {\n                    walkForwardOnTheLeftUntilSeeZ();\n                }\n                else {\n                    extendRightChainFromP(p);\n                }\n            }\n            //draw(d[i - 1], d[i], dc)\n        }\n        // function draw(d: Diagonal, dn: Diagonal, dc: DebugCurve[]) {\n        //   if (debCount < 1000000) return\n        //   const ldc = dc.map((d) => d.clone())\n        //   ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'Yellow', LineSegment.mkPP(d.left, d.right)))\n        //   ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'cyan', LineSegment.mkPP(dn.left, dn.right)))\n        //   for (let l: PathPoint = leftChainStart; l && l.next; l = l.next) {\n        //     ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'Magenta', LineSegment.mkPP(l.point, l.next.point)))\n        //   }\n        //   for (let r: PathPoint = rightChainStart; r && r.next; r = r.next) {\n        //     ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'Navy', LineSegment.mkPP(r.point, r.next.point)))\n        //   }\n        //   ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'red', CurveFactory.mkCircle(3, v)))\n        //   if (prefix.length) {\n        //     for (let i = 0; i < prefix.length - 1; i++) {\n        //       ldc.push(DebugCurve.mkDebugCurveTWCI(200, 3, 'Black', LineSegment.mkPP(prefix[i], prefix[i + 1])))\n        //     }\n        //     ldc.push(DebugCurve.mkDebugCurveTWCI(200, 3, 'Black', LineSegment.mkPP(prefix[prefix.length - 1], v)))\n        //   }\n        //   //SvgDebugWriter.dumpDebugCurves('/tmp/dc_' + ++debCount + '.svg', ldc)\n        // }\n        function visibleRight(pp) {\n            if (pp.next == null) {\n                return true;\n            }\n            return Point.pointToTheLeftOfLineOrOnLine(z, pp.point, pp.next.point);\n        }\n        function visibleLeft(pp) {\n            if (pp.next == null) {\n                return true;\n            }\n            return Point.pointToTheRightOfLineOrOnLine(z, pp.point, pp.next.point);\n        }\n        function reflexLeft(pp) {\n            return Point.pointToTheLeftOfLine(z, pp.prev.point, pp.point);\n        }\n        function reflexRight(pp) {\n            return Point.pointToTheRightOfLine(z, pp.prev.point, pp.point);\n        }\n        function walkForwardOnTheRigthUntilSeeZ() {\n            let p = rightChainStart;\n            while (!visibleRight(p)) {\n                p = p.next;\n            }\n            if (!isApex(p)) {\n                // got the new apex in p\n                let r = rightChainStart;\n                for (; !r.point.equal(p.point); r = r.next) {\n                    prefix.push(r.point);\n                }\n                rightChainStart.point = r.point;\n                rightChainStart.next = r.next; // need to keep rightChainStart and rightChainEnd different while r might be rightChainEnd here\n                v = r.point;\n                if (rightChainEnd.point.equal(rightChainStart.point)) {\n                    rightChainEnd.prev = rightChainEnd.next = null;\n                }\n            }\n            leftChainStart.point = v;\n            leftChainEnd.point = z;\n            leftChainEnd.prev = leftChainStart;\n            leftChainStart.next = leftChainEnd;\n        }\n        function walkForwardOnTheLeftUntilSeeZ() {\n            let p = leftChainStart;\n            while (!visibleLeft(p)) {\n                p = p.next;\n            }\n            if (!isApex(p)) {\n                // got the new apex at p\n                let r = leftChainStart;\n                for (; !r.point.equal(p.point); r = r.next) {\n                    prefix.push(r.point);\n                }\n                leftChainStart.point = r.point; //  need to keep leftChainStart and leftChainEnd different while r might be leftChainEnd here\n                leftChainStart.next = r.next;\n                v = r.point;\n                if (leftChainEnd.point.equal(leftChainStart.point)) {\n                    leftChainEnd.prev = leftChainStart.next = null;\n                }\n            }\n            rightChainStart.point = v;\n            rightChainEnd.point = z;\n            rightChainEnd.prev = rightChainStart;\n            rightChainStart.next = rightChainEnd;\n        }\n        function isApex(pp) {\n            const ret = pp.point == v;\n            //Assert.assert(ret || !pp.point.equal(v))\n            return ret;\n        }\n        function extendRightChainFromP(p) {\n            if (p != rightChainEnd) {\n                rightChainEnd.point = z;\n                rightChainEnd.prev = p;\n                p.next = rightChainEnd;\n            }\n            else {\n                rightChainEnd = { point: z, prev: p };\n                p.next = rightChainEnd;\n            }\n        }\n        function extendLeftChainFromP(p) {\n            if (p != leftChainEnd) {\n                leftChainEnd.point = z;\n                leftChainEnd.prev = p;\n                p.next = leftChainEnd;\n            }\n            else {\n                leftChainEnd = { point: z, prev: p };\n                p.next = leftChainEnd;\n            }\n        }\n    }\n    initDiagonals(sleeve) {\n        for (const sleeveEdge of sleeve) {\n            const e = sleeveEdge.edge;\n            const site = sleeveEdge.source.OppositeSite(e);\n            if (Point.getTriangleOrientation(site.point, e.lowerSite.point, e.upperSite.point) == TriangleOrientation.Counterclockwise) {\n                this.d.push({ left: e.upperSite.point, right: e.lowerSite.point });\n            }\n            else {\n                this.d.push({ right: e.upperSite.point, left: e.lowerSite.point });\n            }\n        }\n    }\n    getSleeve(sourceTriangle) {\n        const q = new Queue();\n        //Assert.assert(sourceTriangle != null)\n        q.enqueue(sourceTriangle);\n        // Assert.assert(sourceTriangle != null)\n        const edgeMap = new Map();\n        edgeMap.set(sourceTriangle, undefined);\n        while (q.length > 0) {\n            const t = q.dequeue();\n            const edgeIntoT = edgeMap.get(t);\n            if (t.containsPoint(this.poly.end)) {\n                return this.recoverPath(sourceTriangle, edgeMap, t);\n            }\n            for (const e of t.Edges) {\n                if (e.constrained)\n                    continue; // do not leave the polygon:\n                // we walk a dual graph of a triangulation of a polygon:\n                // it is not always a simple polygon, but usually it is\n                if (edgeIntoT !== undefined && e === edgeIntoT)\n                    continue;\n                const ot = e.GetOtherTriangle_T(t);\n                if (ot == null)\n                    continue;\n                if (edgeMap.has(ot))\n                    continue;\n                edgeMap.set(ot, e);\n                q.enqueue(ot);\n            }\n        }\n    }\n    recoverPath(sourceTriangle, edgeMap, t) {\n        const ret = [];\n        for (let tr = t; tr != sourceTriangle;) {\n            if (tr === sourceTriangle)\n                break;\n            const e = edgeMap.get(tr);\n            tr = e.GetOtherTriangle_T(tr);\n            ret.push({ source: tr, edge: e });\n        }\n        return ret.reverse();\n    }\n    getPerimeterEdges() {\n        const perimeter = new Set();\n        for (const t of this.triangles) {\n            for (const e of t.Edges) {\n                if (!this.triangles.has(e.GetOtherTriangle_T(t))) {\n                    perimeter.add(e);\n                }\n            }\n        }\n        return perimeter;\n    }\n}\nfunction triangleIsInsideOfObstacle(t) {\n    if (t.Sites.item0.Owner == null || t.Sites.item1.Owner == null || t.Sites.item2.Owner == null) {\n        return true; // one of the sites corresponds to a Port\n    }\n    return t.Sites.item0.Owner == t.Sites.item1.Owner && t.Sites.item0.Owner == t.Sites.item2.Owner;\n}\n//# sourceMappingURL=pathOptimizer.js.map","import { Point } from '../..';\nimport { LinearSystem2 } from '../../math/geometry/linearSystem';\nimport { TriangleOrientation } from '../../math/geometry/point';\nexport class ActiveDiagonalComparerWithRay {\n    get PointOnTangentAndInsertedDiagonal() {\n        return this.pointOnTheRay;\n    }\n    set PointOnTangentAndInsertedDiagonal(value) {\n        this.pointOnTheRay = value;\n    }\n    Compare(x, y) {\n        // Assert.assert(ActiveDiagonalComparerWithRay.BelongsToTheDiagonal(this.PointOnTangentAndInsertedDiagonal, x.Start, x.End))\n        if (!x.Start.equal(y.Start)) {\n            switch (Point.getTriangleOrientation(this.PointOnTangentAndInsertedDiagonal, y.Start, y.End)) {\n                case TriangleOrientation.Counterclockwise:\n                    return -1;\n                default:\n                    return 1;\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n    static BelongsToTheDiagonal(IntersectionOfTheRayAndInsertedEdge, start, end) {\n        return Point.closeDistEps(IntersectionOfTheRayAndInsertedEdge, Point.ClosestPointAtLineSegment(IntersectionOfTheRayAndInsertedEdge, start, end));\n    }\n    static IntersectDiagonalWithRay(pivot, pointOnRay, diagonal) {\n        const ray = pointOnRay.sub(pivot);\n        const source = diagonal.Start;\n        const target = diagonal.End;\n        // let x(t-s)+s is on the ray, then for some y we x(t-s)+s=y*ray+pivot, or x(t-s)-y*ray=pivot-s\n        const result = LinearSystem2.solve(target.x - source.x, ray.x * -1, pivot.x - source.x, target.y - source.y, ray.y * -1, pivot.y - source.y);\n        // Assert.assert(result && -GeomConstants.tolerance <= result.x && result.x <= 1 + GeomConstants.tolerance)\n        return pivot.add(ray.mul(result.y));\n    }\n}\n//# sourceMappingURL=ActiveDiagonalComparerWithRay.js.map","import { GeomConstants } from '../../math/geometry/geomConstants';\nimport { LinearSystem2 } from '../../math/geometry/linearSystem';\nimport { Point, TriangleOrientation } from '../../math/geometry/point';\nexport class ActiveEdgeComparerWithRay {\n    get Pivot() {\n        return this.pivot;\n    }\n    set Pivot(value) {\n        this.pivot = value;\n    }\n    get IntersectionOfTheRayAndInsertedEdge() {\n        return this.pointOnTheRay;\n    }\n    set IntersectionOfTheRayAndInsertedEdge(value) {\n        this.pointOnTheRay = value;\n    }\n    Compare(x, y) {\n        //Assert.assert(this.IntersectionPointBelongsToTheInsertedEdge(x))\n        switch (Point.getTriangleOrientation(this.IntersectionOfTheRayAndInsertedEdge, y.point, y.nextOnPolyline.point)) {\n            case TriangleOrientation.Counterclockwise:\n                return -1;\n            default:\n                return 1;\n        }\n    }\n    IntersectionPointBelongsToTheInsertedEdge(x) {\n        const a = x.point.sub(this.IntersectionOfTheRayAndInsertedEdge);\n        const b = x.nextOnPolyline.point.sub(this.IntersectionOfTheRayAndInsertedEdge);\n        return Math.abs(a.x * b.y - b.x * a.y) < GeomConstants.distanceEpsilon;\n    }\n    IntersectEdgeWithRayPPP(source, target, ray) {\n        //let x(t-s)+s is on the ray, then for some y we x(t-s)+s=y*ray+pivot, or x(t-s)-y*ray=pivot-s\n        const result = LinearSystem2.solve(target.x - source.x, -ray.x, this.Pivot.x - source.x, target.y - source.y, -ray.y, this.Pivot.y - source.y);\n        if (!(-GeomConstants.tolerance <= result.x && result.x <= 1 + GeomConstants.tolerance))\n            throw new Error();\n        if (!result)\n            throw new Error();\n        return this.Pivot.add(ray.mul(result.y));\n    }\n    IntersectEdgeWithRay(side, ray) {\n        return this.IntersectEdgeWithRayPPP(side.point, side.nextOnPolyline.point, ray);\n    }\n    static constructorPP(pivot, pointOnTheRay) {\n        const r = new ActiveEdgeComparerWithRay();\n        r.pivot = pivot;\n        r.pointOnTheRay = pointOnTheRay;\n        return r;\n    }\n}\n//# sourceMappingURL=ActiveEdgeComparerWithRay.js.map","import { UnimodalSequence } from './UnimodalSequence';\n// following https://dl.acm.org/doi/pdf/10.1145/7531.24036?casa_token=eU7GWug-Y98AAAAA%3A4GZQqc2mZBx14I_lLJyQrp6JLhxvxyn9pDaVCAisU2KozgOCW5HbSVYviPBxgN0RWf8GCUshDaW5\n// 'Intersection of Convex Objects in Two and Three Dimensions' by Chazelle, and Dobkin\n// For our purposes, it suffices to define a bimodal function as\n// one for which there is an r in [0, n-1] such that\n// [f(r), f(r + 1), . . . , f(n), f( 1), . . . ,  f(r - 1)] is unimodal. In our case no three sequential elements have the same value\nexport class BimodalSequence {\n    toArray() {\n        const r = [];\n        for (let i = 0; i < this.length; i++)\n            r.push(this.f(i));\n        return r;\n    }\n    constructor(sequence, length) {\n        this.f = sequence;\n        this.length = length;\n    }\n    GetAdjustedSequenceForMinimum() {\n        const leftVal = this.f(0);\n        const rightVal = this.f(this.length - 1);\n        const k = (rightVal - leftVal) / (this.length - 1);\n        return (i) => Math.min(this.f(i), leftVal + k * i);\n    }\n    GetAdjustedSequenceForMaximum() {\n        const leftVal = this.f(0);\n        const rightVal = this.f(this.length - 1);\n        const k = (rightVal - leftVal) / (this.length - 1);\n        return (i) => Math.max(this.f(i), leftVal + k * i);\n    }\n    // following Chazelle, Dobkin\n    FindMinimum() {\n        if (this.f(0) === this.f(this.length - 1)) {\n            //we have an unimodal function\n            return new UnimodalSequence(this.f, this.length).FindMinimum();\n        }\n        return new UnimodalSequence(this.GetAdjustedSequenceForMinimum(), this.length).FindMinimum();\n    }\n    FindMaximum() {\n        if (this.f(0) === this.f(this.length - 1)) {\n            //we have an unimodal function\n            return new UnimodalSequence(this.f, this.length).FindMaximum();\n        }\n        return new UnimodalSequence(this.GetAdjustedSequenceForMaximum(), this.length).FindMaximum();\n    }\n}\n//# sourceMappingURL=BimodalSequence.js.map","import { String } from 'typescript-string-operations';\nexport class Diagonal {\n    toString() {\n        return String.Format('{0},{1}', this.Start, this.End);\n    }\n    get Start() {\n        return this.leftTangent.End.point;\n    }\n    get End() {\n        return this.rightTangent.End.point;\n    }\n    constructor(leftTangent, rightTangent) {\n        this.LeftTangent = leftTangent;\n        this.RightTangent = rightTangent;\n    }\n    get LeftTangent() {\n        return this.leftTangent;\n    }\n    set LeftTangent(value) {\n        this.leftTangent = value;\n    }\n    get RightTangent() {\n        return this.rightTangent;\n    }\n    set RightTangent(value) {\n        this.rightTangent = value;\n    }\n    get RbNode() {\n        return this.rbNode;\n    }\n    set RbNode(value) {\n        this.rbNode = value;\n    }\n}\n//# sourceMappingURL=Diagonal.js.map","import { Point } from '../..';\nimport { TriangleOrientation } from '../../math/geometry/point';\nimport { RBTree } from '../../math/RBTree/rbTree';\nimport { TangentPair } from './TangentPair';\nimport { VisibilityGraph } from './VisibilityGraph';\nimport { Algorithm } from '../../utils/algorithm';\nimport { Diagonal } from './Diagonal';\nimport { Tangent } from './Tangent';\nimport { ActiveDiagonalComparerWithRay } from './ActiveDiagonalComparerWithRay';\nimport { StemStartPointComparer } from './StemStartPointComparer';\nexport class InteractiveTangentVisibilityGraphCalculator extends Algorithm {\n    // we calculate tangents between activePolygons and between activePolygons and existingObsacles\n    run() {\n        this.useLeftPTangents = true;\n        this.CalculateAndAddEdges();\n        // use another family of tangents\n        this.useLeftPTangents = false;\n        this.CalculateAndAddEdges();\n    }\n    CalculateAndAddEdges() {\n        for (const p of this.addedPolygons) {\n            this.CalculateVisibleTangentsFromPolygon(p);\n        }\n        this.ProgressStep();\n    }\n    CalculateVisibleTangentsFromPolygon(polygon) {\n        this.currentPolygon = polygon;\n        this.AllocateDataStructures();\n        this.OrganizeTangents();\n        this.InitActiveDiagonals();\n        this.Sweep();\n    }\n    AllocateDataStructures() {\n        this.tangents = new Array();\n        this.diagonals = new Array();\n        this.activeDiagonalTree = new RBTree(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer));\n    }\n    Sweep() {\n        if (this.tangents.length < 2) {\n            return;\n        }\n        for (let i = 1; i < this.tangents.length; i++) {\n            // we processed the first element already\n            const t = this.tangents[i];\n            if (t.Diagonal != null) {\n                if (t.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum()) {\n                    this.AddVisibleEdge(t);\n                }\n                if (t.IsHigh) {\n                    this.RemoveDiagonalFromActiveNodes(t.Diagonal);\n                }\n            }\n            else if (t.IsLow) {\n                this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = t.End.point;\n                this.InsertActiveDiagonal(new Diagonal(t, t.Comp));\n                if (t.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum()) {\n                    this.AddVisibleEdge(t);\n                }\n            }\n        }\n    }\n    AddVisibleEdge(t) {\n        VisibilityGraph.AddEdgeVV(getVertex(this.visibilityGraph, t.start), getVertex(this.visibilityGraph, t.End));\n    }\n    // this function will also add the first tangent to the visible edges if needed\n    InitActiveDiagonals() {\n        if (this.tangents.length === 0) {\n            return;\n        }\n        const firstTangent = this.tangents[0];\n        const firstTangentStart = firstTangent.start.point;\n        const firstTangentEnd = firstTangent.End.point;\n        for (const diagonal of this.diagonals) {\n            if (InteractiveTangentVisibilityGraphCalculator.RayIntersectDiagonal(firstTangentStart, firstTangentEnd, diagonal)) {\n                this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = ActiveDiagonalComparerWithRay.IntersectDiagonalWithRay(firstTangentStart, firstTangentEnd, diagonal);\n                this.InsertActiveDiagonal(diagonal);\n            }\n        }\n        if (firstTangent.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum()) {\n            this.AddVisibleEdge(firstTangent);\n        }\n        if (firstTangent.IsLow === false) {\n            // remove the diagonal of the top tangent from active edges\n            const diag = firstTangent.Diagonal;\n            this.RemoveDiagonalFromActiveNodes(diag);\n        }\n    }\n    RemoveDiagonalFromActiveNodes(diag) {\n        const changedNode = this.activeDiagonalTree.deleteSubTree(diag.RbNode);\n        if (changedNode != null) {\n            if (changedNode.item != null) {\n                changedNode.item.RbNode = changedNode;\n            }\n        }\n        diag.LeftTangent.Diagonal = null;\n        diag.RightTangent.Diagonal = null;\n    }\n    InsertActiveDiagonal(diagonal) {\n        diagonal.RbNode = this.activeDiagonalTree.insert(diagonal);\n        InteractiveTangentVisibilityGraphCalculator.MarkDiagonalAsActiveInTangents(diagonal);\n    }\n    static MarkDiagonalAsActiveInTangents(diagonal) {\n        diagonal.LeftTangent.Diagonal = diagonal;\n        diagonal.RightTangent.Diagonal = diagonal;\n    }\n    static RayIntersectDiagonal(pivot, pointOnRay, diagonal) {\n        const a = diagonal.Start;\n        const b = diagonal.End;\n        return (Point.getTriangleOrientation(pivot, a, b) === TriangleOrientation.Counterclockwise &&\n            Point.getTriangleOrientation(pivot, pointOnRay, a) !== TriangleOrientation.Counterclockwise &&\n            Point.getTriangleOrientation(pivot, pointOnRay, b) !== TriangleOrientation.Clockwise);\n    }\n    // compare tangents by measuring the counterclockwise angle between the tangent and the edge\n    static TangentComparison(e0, e1) {\n        return StemStartPointComparer.CompareVectorsByAngleToXAxis(e0.End.point.sub(e0.start.point), e1.End.point.sub(e1.start.point));\n    }\n    *AllObstacles() {\n        for (const p of this.addedPolygons) {\n            yield p;\n        }\n        if (this.polygons) {\n            for (const p of this.polygons) {\n                yield p;\n            }\n        }\n    }\n    OrganizeTangents() {\n        for (const q of this.AllObstacles()) {\n            if (q !== this.currentPolygon) {\n                this.ProcessPolygonQ(q);\n            }\n        }\n        this.tangents.sort(InteractiveTangentVisibilityGraphCalculator.TangentComparison);\n    }\n    ProcessPolygonQ(q) {\n        const tangentPair = new TangentPair(this.currentPolygon, q);\n        if (this.useLeftPTangents) {\n            tangentPair.CalculateLeftTangents();\n        }\n        else {\n            tangentPair.CalculateRightTangents();\n        }\n        let couple = this.useLeftPTangents ? tangentPair.leftPLeftQ : tangentPair.rightPLeftQ;\n        const t0 = new Tangent(this.currentPolygon.pp(couple[0]), q.pp(couple[1]));\n        t0.IsLow = true;\n        t0.SeparatingPolygons = !this.useLeftPTangents;\n        couple = this.useLeftPTangents ? tangentPair.leftPRightQ : tangentPair.rightPRightQ;\n        const t1 = new Tangent(this.currentPolygon.pp(couple[0]), q.pp(couple[1]));\n        t1.IsLow = false;\n        t1.SeparatingPolygons = this.useLeftPTangents;\n        t0.Comp = t1;\n        t1.Comp = t0;\n        this.tangents.push(t0);\n        this.tangents.push(t1);\n        this.diagonals.push(new Diagonal(t0, t1));\n    }\n    constructor(holes, addedPolygons, visibilityGraph) {\n        super(null); // TODO: add cancelToken\n        // the list of obstacles\n        this.polygons = [];\n        this.activeDiagonalComparer = new ActiveDiagonalComparerWithRay();\n        this.polygons = holes;\n        this.visibilityGraph = visibilityGraph;\n        this.addedPolygons = addedPolygons;\n    }\n}\nfunction getVertex(vg, pp) {\n    return vg.FindVertex(pp.point);\n}\n//# sourceMappingURL=InteractiveTangentVisibilityGraphCalculator.js.map","//\nimport { Point } from '../../math/geometry/point';\nimport { GeomConstants } from '../../math/geometry/geomConstants';\nimport { BinaryHeapWithComparer } from '../../structs/BinaryHeapWithComparer';\nimport { RBTree } from '../../math/RBTree/rbTree';\nimport { LowestVertexEvent } from '../spline/coneSpanner/LowestVertexEvent';\nimport { ObstacleSideComparer } from './ObstacleSideComparer';\nimport { PortObstacleEvent } from './PortObstacleEvent';\nexport class LineSweeperBase {\n    constructor(obstacles, sweepDirection) {\n        this.PreviousZ = Number.NEGATIVE_INFINITY;\n        this.z = Number.NEGATIVE_INFINITY;\n        this.Obstacles = obstacles !== null && obstacles !== void 0 ? obstacles : [];\n        this.SweepDirection = sweepDirection;\n        this.DirectionPerp = sweepDirection.rotate(-Math.PI / 2);\n        this.EventQueue = new BinaryHeapWithComparer((a, b) => this.Compare(a, b));\n        this.ObstacleSideComparer = new ObstacleSideComparer(this);\n        this.LeftObstacleSideTree = new RBTree((a, b) => this.ObstacleSideComparer.Compare(a, b));\n        this.RightObstacleSideTree = new RBTree((a, b) => this.ObstacleSideComparer.Compare(a, b));\n    }\n    get EventQueue() {\n        return this.eventQueue;\n    }\n    set EventQueue(value) {\n        this.eventQueue = value;\n    }\n    // sweep direction rotated by 90 degrees clockwise\n    get DirectionPerp() {\n        return this.directionPerp;\n    }\n    set DirectionPerp(value) {\n        this.directionPerp = value;\n    }\n    get Z() {\n        return this.z;\n    }\n    set Z(value) {\n        if (value > this.z + GeomConstants.tolerance) {\n            this.PreviousZ = this.z;\n        }\n        this.z = value;\n    }\n    GetZS(eve) {\n        return this.SweepDirection.dot(eve.Site);\n    }\n    GetZP(point) {\n        return this.SweepDirection.dot(point);\n    }\n    SegmentIsNotHorizontal(a, b) {\n        return Math.abs(a.sub(b).dot(this.SweepDirection)) > GeomConstants.distanceEpsilon;\n    }\n    RemoveLeftSide(side) {\n        this.ObstacleSideComparer.SetOperand(side);\n        this.LeftObstacleSideTree.remove(side);\n    }\n    RemoveRightSide(side) {\n        this.ObstacleSideComparer.SetOperand(side);\n        this.RightObstacleSideTree.remove(side);\n    }\n    InsertLeftSide(side) {\n        this.ObstacleSideComparer.SetOperand(side);\n        this.LeftObstacleSideTree.insert(side);\n    }\n    InsertRightSide(side) {\n        this.ObstacleSideComparer.SetOperand(side);\n        this.RightObstacleSideTree.insert(side);\n    }\n    FindFirstObstacleSideToTheLeftOfPoint(point) {\n        const node = this.RightObstacleSideTree.findLast((s) => Point.pointToTheRightOfLineOrOnLine(point, s.Start, s.End));\n        return node == null ? null : node.item;\n    }\n    FindFirstObstacleSideToToTheRightOfPoint(point) {\n        const node = this.LeftObstacleSideTree.findFirst((s) => !Point.pointToTheRightOfLineOrOnLine(point, s.Start, s.End));\n        return node == null ? null : node.item;\n    }\n    EnqueueEvent(eve) {\n        /*Assert.assert(this.GetZP(eve.Site) >= this.PreviousZ)*/\n        this.eventQueue.Enqueue(eve);\n    }\n    InitQueueOfEvents() {\n        for (const obstacle of this.Obstacles) {\n            this.EnqueueLowestPointsOnObstacles(obstacle);\n        }\n        if (this.Ports != null) {\n            for (const point of this.Ports.values()) {\n                this.EnqueueEvent(new PortObstacleEvent(point));\n            }\n        }\n    }\n    EnqueueLowestPointsOnObstacles(poly) {\n        const candidate = this.GetLowestPoint(poly);\n        this.EnqueueEvent(new LowestVertexEvent(candidate));\n    }\n    GetLowestPoint(poly) {\n        let candidate = poly.startPoint;\n        let pp = poly.startPoint.next;\n        for (; pp != null; pp = pp.next) {\n            if (this.Less(pp.point, candidate.point)) {\n                candidate = pp;\n            }\n        }\n        return candidate;\n    }\n    // imagine that direction points up,\n    // lower events have higher priorities,\n    // for events at the same level events to the left have higher priority\n    Compare(a, b) {\n        const aSite = a.Site;\n        const bSite = b.Site;\n        return this.ComparePoints(/* ref */ aSite, /* ref */ bSite);\n    }\n    Less(a, b) {\n        return this.ComparePoints(/* ref */ a, /* ref */ b) < 0;\n    }\n    ComparePoints(aSite, bSite) {\n        let aProjection = this.SweepDirection.dot(aSite);\n        let bProjection = this.SweepDirection.dot(bSite);\n        if (aProjection < bProjection) {\n            return -1;\n        }\n        if (aProjection > bProjection) {\n            return 1;\n        }\n        aProjection = this.directionPerp.dot(aSite);\n        bProjection = this.directionPerp.dot(bSite);\n        return aProjection < bProjection ? -1 : aProjection > bProjection ? 1 : 0;\n    }\n}\n//# sourceMappingURL=LineSweeperBase.js.map","import { Point } from '../../math/geometry/point';\n// import {GeomConstants} from '../../math/geometry/geomConstants'\nimport { TriangleOrientation } from '../../math/geometry/point';\nexport class ObstacleSideComparer {\n    constructor(lineSweeper) {\n        this.lineSweeper = lineSweeper;\n    }\n    Compare(a, b) {\n        const orient = Point.getTriangleOrientation(b.Start, b.End, this.x);\n        switch (orient) {\n            case TriangleOrientation.Collinear:\n                return 0;\n                break;\n            case TriangleOrientation.Clockwise:\n                return 1;\n                break;\n            default:\n                return -1;\n                break;\n        }\n    }\n    SetOperand(side) {\n        this.x = this.IntersectionOfSideAndSweepLine(side);\n    }\n    IntersectionOfSideAndSweepLine(obstacleSide) {\n        const den = obstacleSide.Direction.dot(this.lineSweeper.SweepDirection);\n        /*Assert.assert(Math.abs(den) > GeomConstants.distanceEpsilon)*/\n        const t = (this.lineSweeper.Z - obstacleSide.Start.dot(this.lineSweeper.SweepDirection)) / den;\n        return obstacleSide.Start.add(obstacleSide.Direction.mul(t));\n    }\n}\n//# sourceMappingURL=ObstacleSideComparer.js.map","// following \"Visibility Algorithms in the Plane\", Ghosh\nimport { Point } from '../..';\nimport { GeomConstants } from '../../math/geometry';\nimport { TriangleOrientation } from '../../math/geometry/point';\nimport { PolylinePoint } from '../../math/geometry/polylinePoint';\nimport { BinaryHeapWithComparer } from '../../structs/BinaryHeapWithComparer';\nimport { RBTree } from '../../math/RBTree/rbTree';\nimport { ActiveEdgeComparerWithRay } from './ActiveEdgeComparerWithRay';\nimport { Stem } from './Stem';\nimport { StemStartPointComparer } from './StemStartPointComparer';\nimport { TollFreeVisibilityEdge } from './TollFreeVisibilityEdge';\nimport { VisibilityKind } from './VisibilityKind';\nexport class PointVisibilityCalculator {\n    get QVertex() {\n        return this.qV;\n    }\n    set QVertex(value) {\n        this.qV = value;\n    }\n    // \"point\" can belong to the boundary of one of the holes\n    // tangent or regural visibility\n    // \"qVertex\" : the graph vertex corresponding to the pivot\n    static CalculatePointVisibilityGraph(listOfHoles, visibilityGraph, point, visibilityKind) {\n        // maybe there is nothing to do\n        const qv = visibilityGraph.FindVertex(point);\n        if (qv != null) {\n            return qv;\n        }\n        const calculator = new PointVisibilityCalculator(listOfHoles, visibilityGraph, point, visibilityKind);\n        calculator.FillGraph();\n        return calculator.QVertex;\n    }\n    FillGraph() {\n        this.ComputeHoleBoundariesPossiblyVisibleFromQ();\n        if (this.visibleBoundaries.size > 0) {\n            this.SortSAndInitActiveSides();\n            // CheckActiveSidesAreConsistent();\n            this.Sweep();\n        }\n    }\n    // sorts the set of potentially visible vertices around point q\n    SortSAndInitActiveSides() {\n        this.InitHeapAndInsertActiveSides();\n        for (let stem = this.heapForSorting.GetMinimum();; stem = this.heapForSorting.GetMinimum()) {\n            this.sortedListOfPolypoints.push(stem.Start);\n            if (stem.MoveStartClockwise()) {\n                this.heapForSorting.ChangeMinimum(stem);\n            }\n            else {\n                this.heapForSorting.Dequeue();\n            }\n            if (this.heapForSorting.Count === 0) {\n                break;\n            }\n        }\n    }\n    InitHeapAndInsertActiveSides() {\n        for (const pp of this.GetInitialVisibleBoundaryStemsAndInsertActiveSides()) {\n            this.heapForSorting.Enqueue(pp);\n        }\n    }\n    // these are chuncks of the visible boundaries growing from the polyline  point just above its crossing with the horizontal ray or\n    // from the visible part start\n    // In the general case we have two stems from one polyline\n    *GetInitialVisibleBoundaryStemsAndInsertActiveSides() {\n        for (const [hole, stem] of this.visibleBoundaries) {\n            let crosses = false;\n            for (const side of stem.Sides()) {\n                const source = side;\n                if (source.point.y < this.q.y) {\n                    if (side.nextOnPolyline.point.y >= this.q.y) {\n                        const orientation = Point.getTriangleOrientation(this.q, source.point, side.nextOnPolyline.point);\n                        if (orientation === TriangleOrientation.Counterclockwise || orientation === TriangleOrientation.Collinear) {\n                            crosses = true;\n                            // we have two stems here\n                            yield new Stem(stem.Start, side);\n                            yield new Stem(side.nextOnPolyline, stem.End);\n                            this.RegisterActiveSide(side);\n                            break;\n                        }\n                    }\n                }\n                else if (source.point.y > this.q.y) {\n                    break;\n                }\n                else if (side.point.x >= this.q.x) {\n                    // we have pp.Y==q.Y\n                    crosses = true;\n                    // we need to add one or two stems here\n                    yield new Stem(side, stem.End);\n                    if (side !== stem.Start) {\n                        yield new Stem(stem.Start, hole.prev(source));\n                    }\n                    this.RegisterActiveSide(side);\n                    break;\n                }\n            }\n            // there is no intersection with the ray\n            if (!crosses) {\n                yield stem;\n            }\n        }\n    }\n    RegisterActiveSide(side) {\n        this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge = this.activeEdgeComparer.IntersectEdgeWithRay(side, new Point(1, 0));\n        this.sideNodes.set(side, this.activeSidesTree.insert(side));\n    }\n    // private Polyline GetPolylineBetweenPolyPointsTest(Polyline hole, PolylinePoint p0, PolylinePoint p1) {\n    //    Polyline ret = new Polyline();\n    //    while (p0 !== p1) {\n    //        ret.AddPoint(p0.Point);\n    //        p0 = hole.Next(p0);\n    //    }\n    //    ret.AddPoint(p1.Point);\n    //    return ret;\n    // }\n    constructor(holes, visibilityGraph, point, visibilityKind) {\n        // A mapping from sides to their RBNodes\n        this.sideNodes = new Map();\n        // These are parts of hole boundaries visible from q where each node is taken in isolation\n        this.visibleBoundaries = new Map();\n        // the sorted list of possibly visible vertices\n        this.sortedListOfPolypoints = new Array();\n        this.holes = Array.from(holes);\n        // this.graphOfHoleBoundaries = holeBoundariesGraph;\n        this.visibilityGraph = visibilityGraph;\n        this.q = point;\n        this.qPolylinePoint = PolylinePoint.mkFromPoint(this.q);\n        this.QVertex = this.visibilityGraph.AddVertexP(this.qPolylinePoint.point);\n        this.visibilityKind = visibilityKind;\n        const comp = new StemStartPointComparer(this.q);\n        this.heapForSorting = new BinaryHeapWithComparer(comp.IComparer.bind(comp));\n    }\n    Sweep() {\n        for (const polylinePoint of this.sortedListOfPolypoints) {\n            this.SweepPolylinePoint(polylinePoint);\n        }\n    }\n    // this code will work for convex holes\n    SweepPolylinePoint(v) {\n        const inSide = PointVisibilityCalculator.GetIncomingSide(v);\n        const outSide = this.GetOutgoingSide(v);\n        // if (inEdge != null && outEdge != null)\n        //    SugiyamaLayoutSettings.Show(new LineSegment(inEdge.Start.Point, inEdge.End.Point), new LineSegment(outEdge.Start.Point,\n        //        outEdge.End.Point), new LineSegment(this.q, v.Point));\n        // else if (inEdge != null)\n        //    SugiyamaLayoutSettings.Show(new LineSegment(inEdge.Start.Point, inEdge.End.Point), new LineSegment(this.q, v.Point));\n        // else if (outEdge != null)\n        //    SugiyamaLayoutSettings.Show(new LineSegment(outEdge.Start.Point, outEdge.End.Point), new LineSegment(this.q, v.Point));\n        this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge = v.point;\n        let node;\n        if ((node = this.sideNodes.get(inSide))) {\n            // we have an active edge\n            if (node === this.activeSidesTree.treeMinimum()) {\n                this.AddEdge(v);\n            }\n            if (outSide != null) {\n                node.item = outSide;\n                // just replace the edge since the order does not change\n                this.sideNodes.set(outSide, node);\n            }\n            else {\n                const changedNode = this.activeSidesTree.deleteSubTree(node);\n                if (changedNode != null) {\n                    if (changedNode.item != null) {\n                        this.sideNodes.set(changedNode.item, changedNode);\n                    }\n                }\n            }\n            this.sideNodes.delete(inSide);\n        }\n        else if (outSide != null) {\n            let outsideNode;\n            if (!(outsideNode = this.sideNodes.get(outSide))) {\n                outsideNode = this.activeSidesTree.insert(outSide);\n                this.sideNodes.set(outSide, outsideNode);\n                if (outsideNode === this.activeSidesTree.treeMinimum()) {\n                    this.AddEdge(v);\n                }\n            }\n        }\n        else {\n            throw new Error();\n        }\n    }\n    AddEdge(v) {\n        if (this.visibilityKind === VisibilityKind.Regular ||\n            (this.visibilityKind === VisibilityKind.Tangent && PointVisibilityCalculator.LineTouchesPolygon(this.QVertex.point, v))) {\n            this.visibilityGraph.AddEdgeF(this.QVertex.point, v.point, (a, b) => new TollFreeVisibilityEdge(a, b));\n        }\n    }\n    static LineTouchesPolygon(a, p) {\n        const prev = p.polyline.prev(p).point;\n        const next = p.polyline.next(p).point;\n        const v = p.point;\n        return Point.signedDoubledTriangleArea(a, v, prev) * Point.signedDoubledTriangleArea(a, v, next) >= 0;\n    }\n    // ReSharper disable UnusedMember.Local\n    /*\n          DrawActiveEdgesAndVisibleGraph() {\n              // ReSharper restore UnusedMember.Local\n              let l = new Array<ICurve>();\n              for (let pe: VisibilityEdge in this.visibilityGraph.Edges) {\n                  l.Add(new LineSegment(pe.SourcePoint, pe.TargetPoint));\n              }\n              \n              for (let pe: PolylinePoint in this.activeSidesTree) {\n                  l.Add(new LineSegment(pe.Point, pe.NextOnPolyline.Point));\n              }\n              \n              l.Add(new Ellipse(0.1, 0.1, this.q));\n              LayoutAlgorithmSettings.Show(l.ToArray());\n          }\n    */\n    GetOutgoingSide(v) {\n        const visibleStem = this.visibleBoundaries.get(v.polyline);\n        if (v === visibleStem.End) {\n            return null;\n        }\n        return v;\n    }\n    static GetIncomingSide(v) {\n        return v.prevOnPolyline;\n    }\n    ComputeHoleBoundariesPossiblyVisibleFromQ() {\n        this.InitActiveEdgesAndActiveEdgesComparer();\n        for (const hole of this.holes) {\n            this.ComputeVisiblePartOfTheHole(hole);\n        }\n    }\n    InitActiveEdgesAndActiveEdgesComparer() {\n        this.activeEdgeComparer = new ActiveEdgeComparerWithRay();\n        this.activeEdgeComparer.pivot = this.q;\n        this.activeSidesTree = new RBTree(this.activeEdgeComparer.Compare.bind(this.activeEdgeComparer));\n    }\n    ComputeVisiblePartOfTheHole(hole) {\n        // find a separating edge\n        let a;\n        let needToGoCounterclockWise = true;\n        for (a = hole.startPoint; !this.HoleSideIsVisibleFromQ(hole, a); a = hole.next(a)) {\n            //Assert.assert(needToGoCounterclockWise || a !== hole.startPoint)\n            // check that we have not done the full circle\n            needToGoCounterclockWise = false;\n        }\n        let b = hole.next(a);\n        // now the side a, a.Next - is separating\n        if (needToGoCounterclockWise) {\n            while (this.HoleSideIsVisibleFromQ(hole, hole.prev(a))) {\n                a = hole.prev(a);\n            }\n        }\n        // go clockwise starting from b\n        for (; this.HoleSideIsVisibleFromQ(hole, b); b = hole.next(b)) { }\n        this.visibleBoundaries.set(hole, new Stem(a, b));\n    }\n    HoleSideIsVisibleFromQ(hole, b) {\n        return Point.signedDoubledTriangleArea(this.q, b.point, hole.next(b).point) >= -GeomConstants.squareOfDistanceEpsilon;\n    }\n}\n//# sourceMappingURL=PointVisibilityCalculator.js.map","import { LineSegment } from '../../math/geometry/lineSegment';\nimport { Point, TriangleOrientation } from '../../math/geometry/point';\nimport { Polyline } from '../../math/geometry/polyline';\nimport { BimodalSequence } from './BimodalSequence';\nimport { TangentPair } from './TangentPair';\nexport class Polygon {\n    static mkFromPoints(pts) {\n        return new Polygon(Polyline.mkClosedFromPoints(pts));\n    }\n    get Polyline() {\n        return this.polyline;\n    }\n    constructor(polyline) {\n        this.polyline = polyline;\n        this.points = new Array();\n        for (let pp = this.polyline.startPoint; pp; pp = pp.next)\n            this.points.push(pp);\n        /*Assert.assert(\n          polyline.count < 3 ||\n            Point.getTriangleOrientation(this.pnt(0), this.pnt(1), this.pnt(2)) !=\n              TriangleOrientation.Counterclockwise,\n        )*/\n    }\n    Next(i) {\n        return this.Module(i + 1);\n    }\n    Prev(i) {\n        return this.Module(i - 1);\n    }\n    get count() {\n        return this.Polyline.count;\n    }\n    Module(i) {\n        if (i < 0) {\n            return i + this.count;\n        }\n        if (i < this.count) {\n            return i;\n        }\n        return i - this.count;\n    }\n    pp(i) {\n        return this.points[this.Module(i)];\n    }\n    // LineSegment ls(Point pivot, int p) {\n    //    return new LineSegment(pivot, Pnt(p));\n    // }\n    pnt(i) {\n        return this.pp(i).point;\n    }\n    toString() {\n        return this.polyline.toString();\n    }\n    // the median of a chunk going clockwise from p1 to p2\n    Median(p1, p2) {\n        /*Assert.assert(p1 !== p2)*/\n        // otherwise we do not know what arc is mean: the whole one or just the point\n        if (p2 > p1) {\n            return Math.floor((p2 + p1) / 2);\n        }\n        return this.Module(p2 + Math.floor((this.count + p1) / 2));\n    }\n    // p1 and p2 represent the closest feature. Two cases are possible p1=p2, or p1 and p2 share an edge going from p1 to p2\n    // Remind that the polygons are oriented clockwise\n    FindTheFurthestVertexFromBisector(p1, p2, bisectorPivot, bisectorRay) {\n        let directionToTheHill = bisectorRay.rotate(Math.PI / 2);\n        if (this.polyline.startPoint.point.sub(bisectorPivot).dot(directionToTheHill) < 0) {\n            directionToTheHill = directionToTheHill.mul(-1);\n        }\n        if (p1 === p2) {\n            p2 = this.Next(p1);\n        }\n        // binary search\n        do {\n            const m = this.Median(p2, p1);\n            // now the chunk goes clockwise from p2 to p1\n            const mp = this.pnt(m);\n            if (this.pnt(this.Next(m)).sub(mp).dot(directionToTheHill) >= 0) {\n                p2 = this.Next(m);\n            }\n            else if (this.pnt(this.Prev(m)).sub(mp).dot(directionToTheHill) >= 0) {\n                p1 = this.Prev(m);\n            }\n            else {\n                p2 = m;\n            }\n            p1 = m;\n        } while (p1 !== p2);\n        return p1;\n    }\n    static TestPolygonDist(a, b) {\n        let ret = Number.MAX_SAFE_INTEGER;\n        for (let i = 0; i < a.count; i++) {\n            for (let j = 0; j < b.count; j++) {\n                const t = LineSegment.minDistBetweenLineSegments(a.pnt(i), a.pnt(i + 1), b.pnt(j), b.pnt(j + 1));\n                ret = Math.min(ret, t.dist);\n            }\n        }\n        return ret;\n    }\n    // Distance between two polygons\n    // p and q are the closest points\n    // The function doesn't work if the polygons intersect each other\n    static Distance(a, b) {\n        const tp = new TangentPair(a, b);\n        const pq = tp.FindClosestPoints();\n        //    #if(TEST_MSAGL)\n        // if (!Point.closeDistEps((p - q).length, Polygon.TestPolygonDist(a, b))) {\n        //  let stream = File.Open(\"c:\\tmp\\polygonBug\", FileMode.Create);\n        //  let bf = new BinaryFormatter();\n        //  bf.Serialize(stream, a);\n        //  bf.Serialize(stream, b);\n        //  LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve(100, 0.1, \"red\", a.Polyline), new DebugCurve(100, 0.1, \"blue\", b.Polyline), new DebugCurve(100, 0.1, \"black\", new LineSegment(p, q)));\n        //  System.Diagnostics.Debug.Fail(\"wrong distance between two polygons\");\n        // }\n        //    #endif\n        return {\n            p: pq.pClosest,\n            q: pq.qClosest,\n            dist: pq.pClosest.sub(pq.qClosest).length,\n        };\n    }\n    // Distance between two polygons\n    static DistanceOnly(a, b) {\n        /*Assert.assert(Polygon.PolygonIsLegalDebug(a))*/\n        /*Assert.assert(Polygon.PolygonIsLegalDebug(b))*/\n        return Polygon.Distance(a, b).dist;\n    }\n    static PolygonIsLegalDebug(a) {\n        const poly = a.Polyline;\n        for (let p = poly.startPoint; p.next != null && p.next.next != null; p = p.next) {\n            if (Point.getTriangleOrientation(p.point, p.next.point, p.next.next.point) === TriangleOrientation.Collinear) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Distance between polygon and point, assuming the point is outside of the polygon\n    static DistancePoint(poly, b) {\n        let res = Number.MAX_VALUE;\n        for (let i = 0; i < poly.count; i++) {\n            const dist = Point.distToLineSegment(b, poly.points[i].point, poly.points[(i + 1) % poly.count].point).dist;\n            res = Math.min(res, dist);\n        }\n        return res;\n    }\n    GetTangentPoints(t, point) {\n        const bimodalSequence = new BimodalSequence(this.GetSequenceDelegate(point), this.count);\n        t.leftTangentPoint = bimodalSequence.FindMaximum();\n        t.rightTangentPoint = bimodalSequence.FindMinimum();\n    }\n    GetSequenceDelegate(point) {\n        const pointOfP = this.pnt(0);\n        return (i) => {\n            const d = Point.anglePCP(pointOfP, point, this.pnt(i));\n            return d < Math.PI ? d : d - 2 * Math.PI;\n        };\n    }\n}\n//# sourceMappingURL=Polygon.js.map","import { SweepEvent } from '../spline/coneSpanner/SweepEvent';\nexport class PortObstacleEvent extends SweepEvent {\n    constructor(site) {\n        super();\n        this.site = site;\n    }\n    get Site() {\n        return this.site;\n    }\n}\n//# sourceMappingURL=PortObstacleEvent.js.map","export class SegmentBase {\n    get Direction() {\n        return this.End.sub(this.Start);\n    }\n    toString() {\n        return this.Start + ' ' + this.End;\n    }\n}\n//# sourceMappingURL=SegmentBase.js.map","import { String } from 'typescript-string-operations';\n// represents a chunk of a hole boundary\nexport class Stem {\n    get Start() {\n        return this.start;\n    }\n    set Start(value) {\n        this.start = value;\n    }\n    get End() {\n        return this.end;\n    }\n    set End(value) {\n        this.end = value;\n    }\n    constructor(start, end) {\n        //Assert.assert(start.polyline === end.polyline)\n        this.start = start;\n        this.end = end;\n    }\n    *Sides() {\n        let v = this.start;\n        while (v !== this.end) {\n            const side = v;\n            yield side;\n            v = side.nextOnPolyline;\n        }\n    }\n    MoveStartClockwise() {\n        if (this.Start !== this.End) {\n            this.Start = this.Start.nextOnPolyline;\n            return true;\n        }\n        return false;\n    }\n    toString() {\n        return String.Format('Stem({0},{1})', this.Start, this.End);\n    }\n}\n//# sourceMappingURL=Stem.js.map","// compares couples only by looking at the couple first point\nimport { GeomConstants } from '../../math/geometry';\n// we need the couple to hold the stem\nexport class StemStartPointComparer {\n    constructor(p) {\n        this.pivot = p;\n    }\n    IComparer(i, j) {\n        if (i === j)\n            return 0;\n        if (i == null)\n            return -1;\n        if (j == null)\n            return 1;\n        const a = i.Start.point.sub(this.pivot);\n        const b = j.Start.point.sub(this.pivot);\n        return StemStartPointComparer.CompareVectorsByAngleToXAxis(a, b);\n    }\n    static CompareVectorsByAngleToXAxis(a, b) {\n        if (a.y >= 0) {\n            if (b.y < 0) {\n                return -1;\n            }\n            return StemStartPointComparer.CompareVectorsPointingToTheSameYHalfPlane(a, b);\n        }\n        else {\n            // a.y <0\n            if (b.y >= 0) {\n                return 1;\n            }\n            return StemStartPointComparer.CompareVectorsPointingToTheSameYHalfPlane(a, b);\n        }\n    }\n    static CompareVectorsPointingToTheSameYHalfPlane(a, b) {\n        // now we know that a and b do not point to different Y half planes\n        const sign = a.x * b.y - a.y * b.x;\n        if (sign > GeomConstants.tolerance) {\n            return -1;\n        }\n        if (sign < -GeomConstants.tolerance) {\n            return 1;\n        }\n        // are they on the opposite sides of the pivot by X?\n        if (a.x >= 0) {\n            if (b.x < 0) {\n                return -1;\n            }\n        }\n        else if (b.x >= 0) {\n            return 1;\n        }\n        let del = Math.abs(a.x) - Math.abs(b.x);\n        if (del < 0) {\n            return -1;\n        }\n        if (del > 0) {\n            return 1;\n        }\n        del = Math.abs(a.y) - Math.abs(b.y);\n        if (del < 0) {\n            return -1;\n        }\n        if (del > 0) {\n            return 1;\n        }\n        return 0;\n        // points are equal\n    }\n}\n//# sourceMappingURL=StemStartPointComparer.js.map","import { String } from 'typescript-string-operations';\nexport class Tangent {\n    // the complimentary tangent\n    get Comp() {\n        return this.comp;\n    }\n    set Comp(value) {\n        this.comp = value;\n    }\n    get IsHigh() {\n        return !this.IsLow;\n    }\n    // true means that it is a low tangent to Q, false meanst that it is a high tangent to Q\n    get IsLow() {\n        return this.lowTangent;\n    }\n    set IsLow(value) {\n        this.lowTangent = value;\n    }\n    get SeparatingPolygons() {\n        return this.separatingPolygons;\n    }\n    set SeparatingPolygons(value) {\n        this.separatingPolygons = value;\n    }\n    // the diagonal will be not a null only when it is active\n    get Diagonal() {\n        return this.diagonal;\n    }\n    set Diagonal(value) {\n        this.diagonal = value;\n    }\n    get Start() {\n        return this.start;\n    }\n    set Start(value) {\n        this.start = value;\n    }\n    get End() {\n        return this.end;\n    }\n    set End(value) {\n        this.end = value;\n    }\n    constructor(start, end) {\n        this.start = start;\n        this.End = end;\n    }\n    toString() {\n        return String.Format('{0},{1}', this.Start, this.End);\n    }\n}\n//# sourceMappingURL=Tangent.js.map","// calculates the pair of tangent line segments between two convex non-intersecting polygons H and Q\nimport { LineSegment } from '../../math/geometry/lineSegment';\nimport { Point } from '../../math/geometry/point';\n// we suppose that polygons are clockwise oriented\nexport class TangentPair {\n    constructor(polygonP, polygonQ) {\n        this.P = polygonP;\n        this.Q = polygonQ;\n    }\n    LeftFromLineOnP(vertexIndex, lineStart, lineEnd) {\n        const p = this.P.pnt(vertexIndex);\n        if (this.upperBranchOnP) {\n            return Point.pointToTheLeftOfLineOrOnLine(lineEnd, p, lineStart);\n        }\n        return Point.pointToTheRightOfLineOrOnLine(lineEnd, p, lineStart);\n    }\n    LeftFromLineOnQ(vertexIndex, lineStart, lineEnd) {\n        const point = this.Q.pnt(vertexIndex);\n        if (this.lowerBranchOnQ) {\n            return Point.pointToTheLeftOfLineOrOnLine(lineEnd, point, lineStart);\n        }\n        return Point.pointToTheRightOfLineOrOnLine(lineEnd, point, lineStart);\n    }\n    PrevOnP(i) {\n        if (this.upperBranchOnP) {\n            return this.P.Prev(i);\n        }\n        return this.P.Next(i);\n    }\n    PrevOnQ(i) {\n        if (this.lowerBranchOnQ) {\n            return this.Q.Prev(i);\n        }\n        return this.Q.Next(i);\n    }\n    NextOnP(i) {\n        if (this.upperBranchOnP) {\n            return this.P.Next(i);\n        }\n        return this.P.Prev(i);\n    }\n    NextOnQ(i) {\n        if (this.lowerBranchOnQ) {\n            return this.Q.Next(i);\n        }\n        return this.Q.Prev(i);\n    }\n    MedianOnP(i, j) {\n        if (this.upperBranchOnP) {\n            return this.P.Median(i, j);\n        }\n        return this.P.Median(j, i);\n    }\n    MedianOnQ(i, j) {\n        if (this.lowerBranchOnQ) {\n            return this.Q.Median(i, j);\n        }\n        return this.Q.Median(j, i);\n    }\n    ModuleP(p0, p1) {\n        if (this.upperBranchOnP) {\n            return this.P.Module(p1 - p0);\n        }\n        return this.P.Module(p0 - p1);\n    }\n    ModuleQ(q0, q1) {\n        if (this.lowerBranchOnQ) {\n            return this.Q.Module(q1 - q0);\n        }\n        return this.Q.Module(q0 - q1);\n    }\n    // we pretend here that the branches go clockwise from p0 to p1, and from q0 to q1\n    TangentBetweenBranches(p0, p1, q0, q1) {\n        while (p1 !== p0 || q1 !== q0) {\n            const mp = p1 !== p0 ? this.MedianOnP(p0, p1) : p0;\n            const mq = q1 !== q0 ? this.MedianOnQ(q0, q1) : q0;\n            const mpp = this.P.pnt(mp);\n            const mqp = this.Q.pnt(mq);\n            // SugiyamaLayoutSettings.Show(P.Polyline, ls(mp, mq), ls(p1,q0), ls(p0,q1), Q.Polyline);\n            let moveOnP = true;\n            if (this.ModuleP(p0, p1) > 1) {\n                if (this.LeftFromLineOnP(this.NextOnP(mp), mpp, mqp)) {\n                    p0 = mp;\n                }\n                else if (this.LeftFromLineOnP(this.PrevOnP(mp), mpp, mqp)) {\n                    p1 = mp;\n                }\n                else {\n                    moveOnP = false;\n                }\n            }\n            else if (p1 !== p0) {\n                // we have only two point in the branch\n                // try to move p0 clockwise\n                if (this.LeftFromLineOnP(p1, this.P.pnt(p0), mqp)) {\n                    p0 = p1;\n                }\n                else if (this.LeftFromLineOnP(p0, this.P.pnt(p1), mqp)) {\n                    p1 = p0;\n                }\n                else {\n                    moveOnP = false;\n                }\n            }\n            else {\n                moveOnP = false;\n            }\n            let moveOnQ = true;\n            if (this.ModuleQ(q0, q1) > 1) {\n                if (this.LeftFromLineOnQ(this.NextOnQ(mq), mqp, mpp)) {\n                    q0 = mq;\n                }\n                else if (this.LeftFromLineOnQ(this.PrevOnQ(mq), mqp, mpp)) {\n                    q1 = mq;\n                }\n                else {\n                    moveOnQ = false;\n                }\n            }\n            else if (q1 !== q0) {\n                // we have only two points in the branch\n                if (this.LeftFromLineOnQ(q1, this.Q.pnt(q0), mpp)) {\n                    q0 = q1;\n                }\n                else if (this.LeftFromLineOnQ(q0, this.Q.pnt(q1), mpp)) {\n                    q1 = q0;\n                }\n                else {\n                    moveOnQ = false;\n                }\n            }\n            else {\n                moveOnQ = false;\n            }\n            if (!moveOnP && !moveOnQ) {\n                p0 = mp;\n                p1 = mp;\n                q0 = mq;\n                q1 = mq;\n            }\n        }\n        return [p0, q1];\n    }\n    // following the paper of Edelsbrunner\n    FindDividingBisector(t) {\n        const m = {\n            pClosest: undefined,\n            qClosest: undefined,\n            p1: undefined,\n            p2: undefined,\n            q1: undefined,\n            q2: undefined,\n        };\n        this.FindClosestFeatures(m);\n        t.bisectorPivot = Point.middle(m.pClosest, m.qClosest);\n        t.bisectorRay = m.pClosest.sub(m.qClosest).rotate(Math.PI / 2);\n        t.p1 = m.p1;\n        t.p2 = m.p2;\n        t.q1 = m.q1;\n        t.q2 = m.q2;\n        // number p=P.FindTheFurthestVertexFromBisector(\n        // #if TEST_MSAGL\n        //             //if (!Point.closeDistEps(pClosest, qClosest))\n        //             //    SugiyamaLayoutSettings.Show(this.P.Polyline, this.Q.Polyline, new LineSegment(pClosest, qClosest));\n        // #endif\n    }\n    FindClosestPoints() {\n        const m = {\n            q2: undefined,\n            p1: undefined,\n            p2: undefined,\n            q1: undefined,\n            pClosest: undefined,\n            qClosest: undefined,\n        };\n        this.FindClosestFeatures(m);\n        return { pClosest: m.pClosest, qClosest: m.qClosest };\n    }\n    FindClosestFeatures(m) {\n        const r = {\n            leftTangentPoint: undefined,\n            rightTangentPoint: undefined,\n        };\n        this.P.GetTangentPoints(r, this.Q.pp(0).point);\n        // LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve(P.Polyline), new DebugCurve(Q.Polyline), new DebugCurve(\"red\",Ls(p2, 0)), new DebugCurve(\"blue\",Ls(p1, 0)));\n        m.p2 = r.leftTangentPoint;\n        m.p1 = r.rightTangentPoint;\n        if (m.p2 === m.p1)\n            m.p2 += this.P.count;\n        this.Q.GetTangentPoints(r, this.P.pp(0).point);\n        // LayoutAlgorithmSettings.Show(P.Polyline, Q.Polyline, Ls(0, q1), Ls(0, q2));\n        m.q1 = r.leftTangentPoint;\n        m.q2 = r.rightTangentPoint;\n        if (m.q2 === m.q1) {\n            m.q2 += this.Q.count;\n        }\n        this.FindClosestPoints_(m);\n    }\n    //chunks go clockwise from p1 to p2 and from q2 to q1\n    FindClosestPoints_(t) {\n        while (this.ChunksAreLong(t.p2, t.p1, t.q2, t.q1))\n            this.ShrinkChunks(t);\n        if (t.p1 === t.p2) {\n            t.pClosest = this.P.pp(t.p2).point;\n            if (t.q1 === t.q2)\n                t.qClosest = this.Q.pp(t.q1).point;\n            else {\n                //                   if(debug) LayoutAlgorithmSettings.Show(new LineSegment(P.Pnt(p2), Q.Pnt(q2)), new LineSegment(P.Pnt(p1), Q.Pnt(q1)), P.Polyline, Q.Polyline);\n                t.qClosest = Point.ClosestPointAtLineSegment(t.pClosest, this.Q.pp(t.q1).point, this.Q.pp(t.q2).point);\n                if (Point.closeDistEps(t.qClosest, this.Q.pnt(t.q1)))\n                    t.q2 = t.q1;\n                else if (Point.closeDistEps(t.qClosest, this.Q.pnt(t.q2)))\n                    t.q1 = t.q2;\n            }\n        }\n        else {\n            /*Assert.assert(t.q1 === t.q2)*/\n            t.qClosest = this.Q.pp(t.q1).point;\n            t.pClosest = Point.ClosestPointAtLineSegment(t.qClosest, this.P.pp(t.p1).point, this.P.pp(t.p2).point);\n            if (Point.closeDistEps(t.pClosest, this.P.pnt(t.p1)))\n                t.p2 = t.p1;\n            else if (Point.closeDistEps(t.qClosest, this.P.pnt(t.p2)))\n                t.p1 = t.p2;\n        }\n    }\n    ChunksAreLong(p2, p1, q2, q1) {\n        const pLength = this.P.Module(p2 - p1) + 1;\n        if (pLength > 2) {\n            return true;\n        }\n        const qLength = this.Q.Module(q1 - q2) + 1;\n        if (qLength > 2) {\n            return true;\n        }\n        if (pLength === 2 && qLength === 2) {\n            return true;\n        }\n        return false;\n    }\n    ShrinkChunks(t) {\n        const mp = t.p1 === t.p2 ? t.p1 : this.P.Median(t.p1, t.p2);\n        const mq = t.q1 === t.q2 ? t.q1 : this.Q.Median(t.q2, t.q1);\n        const mP = this.P.pp(mp).point;\n        const mQ = this.Q.pp(mq).point;\n        const angles = {\n            a1: undefined,\n            a2: undefined,\n            b1: undefined,\n            b2: undefined,\n        };\n        this.GetAnglesAtTheMedian(mp, mq, mP, mQ, angles);\n        //           Core.Layout.LayoutAlgorithmSettings.Show(new LineSegment(P.Pnt(t.p2), Q.Pnt(t.t.q2)), new LineSegment(P.Pnt(t.p1), Q.Pnt(t.q1)), new LineSegment(P.Pnt(mp),Q.Pnt( mq)), P.Polyline, Q.Polyline);\n        //if (MovingAlongHiddenSide(ref t.p1, ref t.p2, ref t.q1, ref t.q2, mp, mq, a1, a2, b1, b2)) {\n        // //  SugiyamaLayoutSettings.Show(ls(t.p2, t.q2), ls(t.p1, t.q1), ls(mp, mq), P.Polyline, Q.Polyline);\n        //   return;\n        //}\n        if (this.InternalCut(t, mp, mq, angles.a1, angles.a2, angles.b1, angles.b2)) {\n            //              if(debug) LayoutAlgorithmSettings.Show(P.Polyline, Q.Polyline, Ls(t.p1, q1), Ls(t.p2,q2));\n            return;\n        }\n        //case 1\n        if (TangentPair.OneOfChunksContainsOnlyOneVertex(t, mp, mq, angles.a1, angles.b1))\n            return;\n        //case 2\n        if (this.OnlyOneChunkContainsExactlyTwoVertices(t, { mp: mp, mq: mq }, angles))\n            return;\n        // the case where we have exactly two vertices in each chunk\n        if (t.p2 === this.P.Next(t.p1) && t.q1 === this.Q.Next(t.q2)) {\n            const md = LineSegment.minDistBetweenLineSegments(this.P.pnt(t.p1), this.P.pnt(t.p2), this.Q.pnt(t.q1), this.Q.pnt(t.q2));\n            //Assert.assert(res);\n            if (md.parab === 0)\n                t.p2 = t.p1;\n            else if (md.parab === 1)\n                t.p1 = t.p2;\n            else if (md.parcd === 0)\n                t.q2 = t.q1;\n            else if (md.parcd === 1)\n                t.q1 = t.q2;\n            /*Assert.assert(t.p1 === t.p2 || t.q1 === t.q2)*/\n            return;\n            //we have trapeze {t.p1,t.p2,q2,q1} here\n            //let t.p1,t.p2 be the low base of the trapes\n            //where is the closest vertex , on the left side or on the rigth side?\n            //if (Point.angle(P.Pnt(t.p2), P.Pnt(t.p1), Q.Pnt(q1)) + Point.angle(P.Pnt(t.p1), Q.Pnt(q1), Q.Pnt(q2)) >= Math.PI)\n            //   ProcessLeftSideOfTrapez(ref t.p1, ref t.p2, ref q2, ref q1);\n            //else {\n            //   SwapPQ();\n            //   ProcessLeftSideOfTrapez(ref q2, ref q1, ref t.p1, ref t.p2);\n            //   SwapPQ();\n            //}\n            //return;\n        }\n        //case 3\n        if (angles.a1 <= Math.PI && angles.a2 <= Math.PI && angles.b1 <= Math.PI && angles.b2 <= Math.PI) {\n            if (angles.a1 + angles.b1 > Math.PI) {\n                if (angles.a1 >= Math.PI / 2)\n                    t.p1 = mp;\n                else\n                    t.q1 = mq;\n            }\n            else {\n                /*Assert.assert(\n                  angles.a2 + angles.b2 >= Math.PI - GeomConstants.tolerance,\n                )*/\n                if (angles.a2 >= Math.PI / 2)\n                    t.p2 = mp;\n                else\n                    t.q2 = mq;\n            }\n        }\n        else {\n            if (angles.a1 > Math.PI)\n                t.p1 = mp;\n            else if (angles.a2 > Math.PI)\n                t.p2 = mp;\n            else if (angles.b1 > Math.PI)\n                t.q1 = mq;\n            else {\n                /*Assert.assert(angles.b2 > Math.PI)*/\n                t.q2 = mq;\n            }\n        }\n    }\n    InternalCut(t, mp, mq, a1, a2, b1, b2) {\n        let ret = false;\n        if (a1 >= Math.PI && a2 >= Math.PI) {\n            //Find out who is on the same side from [mq,mp] as Q[0], the next or the prev. Remember that we found the first chunk from Q[0]\n            //System.Diagnostics.Debug.WriteLine(\"cutting P\");\n            //               if(debug) LayoutAlgorithmSettings.Show(P.Polyline, Q.Polyline, Ls(p1, q1), Ls(p2, q2), Ls(mp, mq));\n            const mpp = this.P.pp(mp).point;\n            const mqp = this.Q.pp(mq).point;\n            const mpnp = this.P.pp(this.P.Next(mp)).point;\n            const orientation = Point.getTriangleOrientation(mpp, mqp, this.Q.pp(0).point);\n            const nextOrientation = Point.getTriangleOrientation(mpp, mqp, mpnp);\n            if (orientation === nextOrientation)\n                t.p1 = this.P.Next(mp);\n            else\n                t.p2 = this.P.Prev(mp);\n            ret = true;\n        }\n        if (b1 >= Math.PI && b2 >= Math.PI) {\n            //Find out who is on the same side from [mq,mp] as P[0], the next or the prev. Remember that we found the first chunk from P[0]\n            //System.Diagnostics.Debug.WriteLine(\"cutting Q\");\n            //               if (debug) LayoutAlgorithmSettings.Show(P.Polyline, Q.Polyline, Ls(p1, q1), Ls(p2, q2), Ls(mp, mq));\n            const mpp = this.P.pp(mp).point;\n            const mqp = this.Q.pp(mq).point;\n            const mqnp = this.Q.pp(this.Q.Next(mq)).point;\n            const orientation = Point.getTriangleOrientation(mpp, mqp, this.P.pp(0).point);\n            const nextOrientation = Point.getTriangleOrientation(mpp, mqp, mqnp);\n            if (orientation === nextOrientation)\n                t.q2 = this.Q.Next(mq);\n            else\n                t.q1 = this.Q.Prev(mq);\n            ret = true;\n        }\n        return ret;\n    }\n    // void ProcessLeftSideOfTrapez(ref number p1, ref number p2, ref number q2, ref number q1) {\n    //   //the closest vertex is on the left side\n    //   Point pn1 = P.Pnt(p1); Point pn2 = P.Pnt(p2);\n    //   Point qn1 = Q.Pnt(q1); Point qn2 = Q.Pnt(q2);\n    //  //SugiyamaLayoutSettings.Show(new LineSegment(pn1, pn2), new LineSegment(pn2, qn2), new LineSegment(qn2, qn1), new LineSegment(qn1, pn1));\n    //   number ap1 = Point.angle(pn2, pn1, qn1);\n    //   number aq1 = Point.angle(pn1, qn1, qn2);\n    //   Assert.assert(ap1 + aq1 >= Math.PI);\n    //   //the point is on the left side\n    //   if (ap1 >= Math.PI / 2 && aq1 >= Math.PI / 2) {\n    //       q2 = q1; //the vertices of the left side gives the solution\n    //       p2 = p1;\n    //   } else if (ap1 < Math.PI / 2) {\n    //       q2 = q1;\n    //       if (!Point.CanProject(qn1, pn1, pn2))\n    //           p1 = p2;\n    //   } else { //aq1<Pi/2\n    //       p2 = p1;\n    //       if (!Point.CanProject(pn1, qn1, qn2))\n    //           q1 = q2;\n    //   }\n    //}\n    GetAnglesAtTheMedian(mp, mq, mP, mQ, t) {\n        t.a1 = Point.anglePCP(mQ, mP, this.P.pnt(this.P.Prev(mp)));\n        t.a2 = Point.anglePCP(this.P.pnt(this.P.Next(mp)), mP, mQ);\n        t.b1 = Point.anglePCP(this.Q.pnt(this.Q.Next(mq)), mQ, mP);\n        t.b2 = Point.anglePCP(mP, mQ, this.Q.pnt(this.Q.Prev(mq)));\n    }\n    // we know here that p1!=p2 and q1!=q2\n    OnlyOneChunkContainsExactlyTwoVertices(t, l, angles) {\n        const pSideIsShort = t.p2 === this.P.Next(t.p1);\n        const qSideIsShort = t.q1 === this.Q.Next(t.q2);\n        if (pSideIsShort && !qSideIsShort) {\n            this.ProcessShortSide(t, l.mp, l.mq, angles.a1, angles.b1, angles.a2, angles.b2);\n            return true;\n        }\n        if (qSideIsShort && !pSideIsShort) {\n            this.SwapEverything(t, l, angles);\n            this.ProcessShortSide(t, l.mp, l.mq, angles.a1, angles.b1, angles.a2, angles.b2);\n            this.SwapEverything(t, l, angles);\n            return true;\n        }\n        return false;\n    }\n    SwapEverything(t, l, angles) {\n        this.SwapPq();\n        let u = t.p2;\n        t.p2 = t.q1;\n        t.q1 = u;\n        u = t.q2;\n        t.q2 = t.p1;\n        t.p1 = u;\n        u = l.mq;\n        l.mq = l.mp;\n        l.mp = u;\n        u = angles.a2;\n        angles.a2 = angles.b1;\n        angles.b1 = u;\n        u = angles.b2;\n        angles.b2 = angles.a1;\n        angles.a1 = u;\n    }\n    ProcessShortSide(t, mp, mq, a1, b1, a2, b2) {\n        //case 2.1\n        if (mp === t.p2)\n            this.ProcessSide(t, mq, a1, b1, b2);\n        else {\n            if (a2 <= Math.PI) {\n                if (a2 + b2 >= Math.PI) {\n                    if (a2 >= Math.PI / 2)\n                        t.p2 = t.p1;\n                    else\n                        t.q2 = mq;\n                }\n                else {\n                    if (b1 >= Math.PI / 2)\n                        t.q1 = mq;\n                    else if (a2 < b2) {\n                        //SugiyamaLayoutSettings.Show(new LineSegment(P.Pnt(p2), Q.Pnt(q2)), new LineSegment(P.Pnt(p1), Q.Pnt(q1)), new LineSegment(P.Pnt(p1), Q.Pnt(mq)), P.Polyline, Q.Polyline);\n                        if (Point.canProject(this.Q.pnt(mq), this.P.pp(t.p1).point, this.P.pp(t.p2).point))\n                            t.q1 = mq;\n                        else\n                            t.p1 = t.p2;\n                    }\n                }\n            }\n            else {\n                //a2>Pi , case 2.2\n                if (a1 + b1 <= Math.PI)\n                    t.p1 = t.p2;\n                else\n                    t.p2 = t.p1;\n            }\n        }\n    }\n    SwapPq() {\n        const t = this.P;\n        this.P = this.Q;\n        this.Q = t;\n    }\n    ProcessSide(t, mq, a1, b1, b2) {\n        //SugiyamaLayoutSettings.Show(new LineSegment(P.Pnt(p2), Q.Pnt(q2)), new LineSegment(P.Pnt(p1), Q.Pnt(q1)),new LineSegment(P.Pnt(p1), Q.Pnt(mq)), P.Polyline, Q.Polyline);\n        const mQ = this.Q.pnt(mq);\n        if (a1 <= Math.PI) {\n            if (a1 + b1 >= Math.PI) {\n                if (a1 >= Math.PI / 2)\n                    t.p1 = t.p2;\n                else\n                    t.q1 = mq;\n            }\n            else if (b2 >= Math.PI / 2)\n                t.q2 = mq;\n            else if (a1 < b2) {\n                if (Point.canProject(mQ, this.P.pp(t.p1).point, this.P.pp(t.p2).point))\n                    t.q2 = mq;\n                else\n                    t.p2 = t.p1;\n            }\n        }\n        else {\n            //a1>Pi , case 2.2\n            t.p2 = t.p1;\n            if (b1 >= Math.PI)\n                t.q1 = mq;\n            else if (b2 >= Math.PI)\n                t.q2 = mq;\n        }\n    }\n    static OneOfChunksContainsOnlyOneVertex(t, mp, mq, a1, b1) {\n        if (t.p1 === t.p2) {\n            if (b1 >= Math.PI / 2)\n                t.q1 = mq;\n            else\n                t.q2 = mq;\n            return true;\n        }\n        if (t.q1 === t.q2) {\n            if (a1 >= Math.PI / 2)\n                t.p1 = mp;\n            else\n                t.p2 = mp;\n            return true;\n        }\n        return false;\n    }\n    CalculateLeftTangents() {\n        const t = {\n            bisectorPivot: null,\n            bisectorRay: null,\n            p1: 0,\n            p2: 0,\n            q1: 0,\n            q2: 0,\n        };\n        this.FindDividingBisector(t);\n        const pFurthest = this.P.FindTheFurthestVertexFromBisector(t.p1, t.p2, t.bisectorPivot, t.bisectorRay);\n        const qFurthest = this.Q.FindTheFurthestVertexFromBisector(t.q2, t.q1, t.bisectorPivot, t.bisectorRay);\n        this.upperBranchOnP = false;\n        this.lowerBranchOnQ = true;\n        this.leftPLeftQ = this.TangentBetweenBranches(pFurthest, t.p1, qFurthest, t.q1); //we need to take maximally wide branches\n        this.lowerBranchOnQ = false;\n        this.leftPRightQ = this.TangentBetweenBranches(pFurthest, t.p1, qFurthest, t.q2);\n    }\n    // bool QContains(number x ,number y) {\n    //   foreach (Point p of Q.Polyline) {\n    //       if (p.x === x && p.y === y)\n    //           return true;\n    //   }\n    //   return false;\n    //}\n    //bool PContains(number x, number y) {\n    //   foreach (Point p of P.Polyline) {\n    //       if (p.x === x && p.y === y)\n    //           return true;\n    //   }\n    //   return false;\n    //}\n    CalculateRightTangents() {\n        const t = { bisectorPivot: null, bisectorRay: null, p1: 0, p2: 0, q1: 0, q2: 0 };\n        this.FindDividingBisector(t);\n        const pFurthest = this.P.FindTheFurthestVertexFromBisector(t.p1, t.p2, t.bisectorPivot, t.bisectorRay);\n        const qFurthest = this.Q.FindTheFurthestVertexFromBisector(t.q2, t.q1, t.bisectorPivot, t.bisectorRay);\n        //SugiyamaLayoutSettings.Show(ls(p1, q1), ls(p2, q2), ls(pFurthest, qFurthest), P.Polyline, Q.Polyline);\n        this.upperBranchOnP = true;\n        this.lowerBranchOnQ = true;\n        this.rightPLeftQ = this.TangentBetweenBranches(pFurthest, t.p2, qFurthest, t.q1);\n        this.lowerBranchOnQ = false;\n        this.rightPRightQ = this.TangentBetweenBranches(pFurthest, t.p2, qFurthest, t.q2);\n    }\n}\n//# sourceMappingURL=TangentPair.js.map","import { VisibilityEdge } from './VisibilityEdge';\nexport class TollFreeVisibilityEdge extends VisibilityEdge {\n    static constructorVV(source, target) {\n        return new TollFreeVisibilityEdge(source, target, 0);\n    }\n    constructor(source, target, weight = 0) {\n        super(source, target, weight);\n    }\n}\n//# sourceMappingURL=TollFreeVisibilityEdge.js.map","// following https://dl.acm.org/doi/pdf/10.1145/7531.24036?casa_token=eU7GWug-Y98AAAAA%3A4GZQqc2mZBx14I_lLJyQrp6JLhxvxyn9pDaVCAisU2KozgOCW5HbSVYviPBxgN0RWf8GCUshDaW5\n// 'Intersection of Convex Objects in Two and Three Dimensions' by Chazelle, and Dobkin\nvar Behavior;\n(function (Behavior) {\n    Behavior[Behavior[\"Increasing\"] = 0] = \"Increasing\";\n    Behavior[Behavior[\"Decreasing\"] = 1] = \"Decreasing\";\n    Behavior[Behavior[\"Extremum\"] = 2] = \"Extremum\";\n})(Behavior || (Behavior = {}));\n// A real valued function f defined on\n// the integers 0, 1, . . . , n-1 is said to be unimodal if there exists an integer m such that\n// f is strictly increasing (respectively, decreasing) on [ 0, m] and\n// decreasing (respectively, increasing) on [m + 1, n-1]\n// No three sequential elements have the same value\nexport class UnimodalSequence {\n    // the sequence values\n    get Sequence() {\n        return this.f;\n    }\n    set Sequence(value) {\n        this.f = value;\n    }\n    // the length of the sequence: the sequence starts from 0\n    get Length() {\n        return this.length;\n    }\n    set Length(value) {\n        this.length = value;\n    }\n    constructor(sequenceDelegate, length) {\n        this.f = sequenceDelegate;\n        this.length = length;\n    }\n    FindMinimum() {\n        // find out first that the minimum is inside of the domain\n        let a = 0;\n        let b = this.length - 1;\n        let m = a + Math.floor((b - a) / 2);\n        const valAtM = this.f(m);\n        if (valAtM >= this.f(0) && valAtM >= this.f(this.length - 1))\n            return this.f(0) < this.f(this.length - 1) ? 0 : this.length - 1;\n        while (b - a > 1) {\n            m = a + Math.floor((b - a) / 2);\n            switch (this.BehaviourAtIndex(m)) {\n                case Behavior.Decreasing:\n                    a = m;\n                    break;\n                case Behavior.Increasing:\n                    b = m;\n                    break;\n                case Behavior.Extremum:\n                    return m;\n            }\n        }\n        return a === b ? a : this.f(a) <= this.f(b) ? a : b;\n    }\n    BehaviourAtIndex(m) {\n        const seqAtM = this.f(m);\n        if (m === 0) {\n            const seqAt1 = this.f(1);\n            if (seqAt1 === seqAtM) {\n                return Behavior.Extremum;\n            }\n            return seqAt1 > seqAtM ? Behavior.Increasing : Behavior.Decreasing;\n        }\n        if (m === this.length - 1) {\n            const seqAt1 = this.f(this.length - 2);\n            if (seqAt1 === seqAtM) {\n                return Behavior.Extremum;\n            }\n            return seqAt1 > seqAtM ? Behavior.Decreasing : Behavior.Increasing;\n        }\n        const delLeft = seqAtM - this.f(m - 1);\n        const delRight = this.f(m + 1) - seqAtM;\n        if (delLeft * delRight <= 0) {\n            return Behavior.Extremum;\n        }\n        return delLeft > 0 ? Behavior.Increasing : Behavior.Decreasing;\n    }\n    FindMaximum() {\n        // find out first that the maximum is inside of the domain\n        let a = 0;\n        let b = this.length - 1;\n        let m = a + Math.floor((b - a) / 2);\n        const valAtM = this.f(m);\n        if (valAtM <= this.f(0) && valAtM <= this.f(this.length - 1)) {\n            return this.f(0) > this.f(this.length - 1) ? 0 : this.length - 1;\n        }\n        while (b - a > 1) {\n            m = a + Math.floor((b - a) / 2);\n            switch (this.BehaviourAtIndex(m)) {\n                case Behavior.Decreasing:\n                    b = m;\n                    break;\n                case Behavior.Increasing:\n                    a = m;\n                    break;\n                case Behavior.Extremum:\n                    return m;\n            }\n        }\n        return a === b ? a : this.f(a) >= this.f(b) ? a : b;\n    }\n}\n//# sourceMappingURL=UnimodalSequence.js.map","import { Point } from './../../math/geometry/point';\nimport { String } from 'typescript-string-operations';\n// import {Assert} from '../../utils/assert'\n// an edge connecting two VisibilityVertices\nexport class VisibilityEdge {\n    static closeuv(s, t) {\n        return Point.closeDistEps(s.point, VisibilityEdge.u, 0.1) && Point.closeDistEps(t.point, VisibilityEdge.v, 0.1);\n    }\n    constructor(s, t, weight = 1) {\n        this.LengthMultiplier = 1;\n        // Assert.assert(!source.point.equal(target.point), 'Self-edges are not allowed')\n        // Assert.assert(!(VisibilityEdge.closeuv(s, t) || VisibilityEdge.closeuv(t, s)))\n        this.Source = s;\n        this.Target = t;\n        this.Weight = weight;\n    }\n    // edge source point\n    get SourcePoint() {\n        return this.Source.point;\n    }\n    // edge target point\n    get TargetPoint() {\n        return this.Target.point;\n    }\n    get Length() {\n        return this.SourcePoint.sub(this.TargetPoint).length * this.LengthMultiplier;\n    }\n    toString() {\n        return String.Format('{0}->{1} ({2})', this.Source, this.Target, this.Weight);\n    }\n    ReversedClone() {\n        return new VisibilityEdge(this.Target, this.Source);\n    }\n    Clone() {\n        return new VisibilityEdge(this.Source, this.Target);\n    }\n}\nVisibilityEdge.u = new Point(545.833, 840.458);\nVisibilityEdge.v = new Point(606.1667261889578, 786.2917261889578);\nVisibilityEdge.DefaultWeight = 1;\n//# sourceMappingURL=VisibilityEdge.js.map","import { Point, TriangleOrientation } from '../../math/geometry/point';\nimport { PointMap } from '../../utils/PointMap';\nimport { VisibilityEdge } from './VisibilityEdge';\nimport { VisibilityVertex } from './VisibilityVertex';\nexport class VisibilityGraph {\n    constructor() {\n        this.activeVertices = new Set();\n        // the default is just to return a new VisibilityVertex\n        this.VertexFactory = (p) => new VisibilityVertex(p);\n        this.pointToVertexMap = new PointMap();\n    }\n    *edges_() {\n        for (const u of this.pointToVertexMap.values()) {\n            for (const e of u.OutEdges)\n                yield e;\n        }\n    }\n    get Edges() {\n        return this.edges_();\n    }\n    ClearPrevEdgesTable() {\n        for (const v of this.activeVertices)\n            v.prevEdge = null;\n        this.activeVertices.clear();\n    }\n    ShrinkLengthOfPrevEdge(v, lengthMultiplier) {\n        v.prevEdge.LengthMultiplier = lengthMultiplier;\n    }\n    // needed for shortest path calculations\n    PreviosVertex(v) {\n        const prev = v.prevEdge;\n        if (!prev)\n            return null;\n        if (prev.Source === v) {\n            return prev.Target;\n        }\n        return prev.Source;\n    }\n    SetPreviousEdge(v, e) {\n        /*Assert.assert(v === e.Source || v === e.Target)*/\n        this.activeVertices.add(v);\n        v.prevEdge = e;\n    }\n    //  static GetVisibilityGraphForShortestPath(pathStart: Point, pathEnd: Point, obstacles: Array<Polyline>, /* out */sourceVertex: VisibilityVertex, /* out */targetVertex: VisibilityVertex): VisibilityGraph {\n    //      let holes = new Array<Polyline>(VisibilityGraph.OrientHolesClockwise(obstacles));\n    //      let visibilityGraph = VisibilityGraph.CalculateGraphOfBoundaries(holes);\n    //      let polygons = holes.Select(() => {  }, new Polygon(holes)).ToList();\n    //      TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);\n    //      PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathStart, VisibilityKind.Tangent, /* out */sourceVertex);\n    //      PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathEnd, VisibilityKind.Tangent, /* out */targetVertex);\n    //      return visibilityGraph;\n    //  }\n    //  //  Calculates the tangent visibility graph\n    //  public static FillVisibilityGraphForShortestPath(obstacles: Array<Polyline>): VisibilityGraph {\n    //      let holes = new Array<Polyline>(VisibilityGraph.OrientHolesClockwise(obstacles));\n    //      let visibilityGraph = VisibilityGraph.CalculateGraphOfBoundaries(holes);\n    //      let polygons = holes.Select(() => {  }, new Polygon(hole)).ToList();\n    //      TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);\n    //      return visibilityGraph;\n    //  }\n    //  static CalculateGraphOfBoundaries(holes: Array<Polyline>): VisibilityGraph {\n    //      let graphOfHoleBoundaries = new VisibilityGraph();\n    //      for (let polyline: Polyline of holes) {\n    //          graphOfHoleBoundaries.AddHole(polyline);\n    //      }\n    //      return graphOfHoleBoundaries;\n    //  }\n    AddHole(polyline) {\n        let p = polyline.startPoint;\n        while (p !== polyline.endPoint) {\n            this.AddEdgePlPl(p, p.next);\n            p = p.next;\n        }\n        this.AddEdgePlPl(polyline.endPoint, polyline.startPoint);\n    }\n    static *OrientHolesClockwise(holes) {\n        for (const poly of holes) {\n            for (let p = poly.startPoint;; p = p.next) {\n                // Find the first non-collinear segments and see which direction the triangle is.\n                // If it's consistent with Clockwise, then return the polyline, else return its Reverse.\n                const orientation = Point.getTriangleOrientation(p.point, p.next.point, p.next.next.point);\n                if (orientation !== TriangleOrientation.Collinear) {\n                    yield orientation === TriangleOrientation.Clockwise ? poly : poly.reverse();\n                    break;\n                }\n            }\n        }\n    }\n    //  static CheckThatPolylinesAreConvex(holes: Array<Polyline>) {\n    //      for (let polyline of holes) {\n    //          VisibilityGraph.CheckThatPolylineIsConvex(polyline);\n    //      }\n    //  }\n    //  static CheckThatPolylineIsConvex(polyline: Polyline) {\n    //      Assert.assert(polyline.closed, \"Polyline is not closed\");\n    //      let a: PolylinePoint = polyline.startPoint;\n    //      let b: PolylinePoint = a.next;\n    //      let c: PolylinePoint = b.next;\n    //      let orient: TriangleOrientation = Point.getTriangleOrientation(a.point, b.point, c.point);\n    //      while ((c !== polyline.endPoint)) {\n    //          a = a.next;\n    //          b = b.next;\n    //          c = c.next;\n    //          let currentOrient = Point.getTriangleOrientation(a.point, b.point, c.point);\n    //          if ((currentOrient === TriangleOrientation.Collinear)) {\n    //              continue\n    //          }\n    //          if ((orient === TriangleOrientation.Collinear)) {\n    //              orient = currentOrient;\n    //          }\n    //          else if ((orient !== currentOrient)) {\n    //              throw new InvalidOperationException();\n    //          }\n    //      }\n    //      let o = Point.getTriangleOrientation(polyline.endPoint.Point, polyline.startPoint.Point, polyline.startPoint.Next.Point);\n    //      if (((o !== TriangleOrientation.Collinear)\n    //                  && (o !== orient))) {\n    //          throw new InvalidOperationException();\n    //      }\n    //  }\n    //  //  TEST || VERIFY\n    //  //  Enumerate all VisibilityEdges in the VisibilityGraph.\n    //  public get Edges(): Array<VisibilityEdge> {\n    //      return PointToVertexMap.Values.SelectMany(() => {  }, vertex.OutEdges);\n    //  }\n    //  get PointToVertexMap(): Map<Point, VisibilityVertex> {\n    //      return this.pointToVertexMap;\n    //  }\n    //  get VertexCount(): number {\n    //      return this.PointToVertexMap.Count;\n    //  }\n    //  AddVertex(polylinePoint: PolylinePoint): VisibilityVertex {\n    //      return this.AddVertex(polylinePoint.point);\n    //  }\n    AddVertexP(point) {\n        const currentVertex = this.pointToVertexMap.get(point);\n        if (currentVertex) {\n            return currentVertex;\n        }\n        const newVertex = this.VertexFactory(point);\n        this.pointToVertexMap.set(point, newVertex);\n        return newVertex;\n    }\n    AddVertexV(vertex) {\n        /*Assert.assert(\n          !this.pointToVertexMap.hasP(vertex.point),\n          'A vertex already exists at this location',\n        )*/\n        this.pointToVertexMap.set(vertex.point, vertex);\n    }\n    ContainsVertex(point) {\n        return this.pointToVertexMap.has(point);\n    }\n    static AddEdgeVV(source, target) {\n        let visEdge;\n        if ((visEdge = source.get(target))) {\n            return visEdge;\n        }\n        if (source === target) {\n            //Assert.assert(false, 'Self-edges are not allowed')\n            throw new Error('Self-edges are not allowed');\n        }\n        const edge = new VisibilityEdge(source, target);\n        source.OutEdges.insert(edge);\n        target.InEdges.push(edge);\n        return edge;\n    }\n    AddEdgePlPl(source, target) {\n        this.AddEdgePP(source.point, target.point);\n    }\n    static AddEdge(edge) {\n        /*Assert.assert(edge.Source !== edge.Target)*/\n        edge.Source.OutEdges.insert(edge);\n        edge.Target.addInEdge(edge);\n    }\n    AddEdgeF(source, target, edgeCreator) {\n        let sourceV = this.FindVertex(source);\n        let targetV = null;\n        if (sourceV != null) {\n            targetV = this.FindVertex(target);\n            if (targetV != null) {\n                const edge = sourceV.get(targetV);\n                if (edge)\n                    return edge;\n            }\n        }\n        if (sourceV == null) {\n            // then targetV is also null\n            sourceV = this.AddVertexP(source);\n            targetV = this.AddVertexP(target);\n        }\n        else if (targetV == null) {\n            targetV = this.AddVertexP(target);\n        }\n        const edge = edgeCreator(sourceV, targetV);\n        sourceV.OutEdges.insert(edge);\n        targetV.addInEdge(edge);\n        return edge;\n    }\n    AddEdgePP(source, target) {\n        return this.AddEdgeF(source, target, (a, b) => new VisibilityEdge(a, b));\n    }\n    FindVertex(point) {\n        return this.pointToVertexMap.get(point);\n    }\n    Vertices() {\n        return this.pointToVertexMap.values();\n    }\n    RemoveVertex(vertex) {\n        // Assert.assert(PointToVertexMap.ContainsKey(vertex.Point), \"Cannot find vertex in PointToVertexMap\");\n        for (const edge of vertex.OutEdges) {\n            edge.Target.RemoveInEdge(edge);\n        }\n        for (const edge of vertex.InEdges) {\n            edge.Source.RemoveOutEdge(edge);\n        }\n        this.pointToVertexMap.deleteP(vertex.point);\n    }\n    //  RemoveEdge(v1: VisibilityVertex, v2: VisibilityVertex) {\n    //      let edge: VisibilityEdge;\n    //      if (!v1.TryGetEdge(v2, /* out */edge)) {\n    //          return;\n    //      }\n    //      edge.Source.RemoveOutEdge(edge);\n    //      edge.Target.RemoveInEdge(edge);\n    //  }\n    //  RemoveEdge(p1: Point, p2: Point) {\n    //      //  the order of p1 and p2 is not important.\n    //      let edge: VisibilityEdge = this.FindEdge(p1, p2);\n    //      if ((edge == null )) {\n    //          return;\n    //      }\n    //      edge.Source.RemoveOutEdge(edge);\n    //      edge.Target.RemoveInEdge(edge);\n    //  }\n    //  static FindEdge(edge: VisibilityEdge): VisibilityEdge {\n    //      if (edge.Source.TryGetEdge(edge.Target, /* out */edge)) {\n    //          return edge;\n    //      }\n    //      return null;\n    //  }\n    FindEdgePP(source, target) {\n        const sourceV = this.FindVertex(source);\n        if (sourceV == null) {\n            return null;\n        }\n        const targetV = this.FindVertex(target);\n        if (targetV == null) {\n            return null;\n        }\n        return sourceV.get(targetV);\n    }\n    static RemoveEdge(edge) {\n        edge.Source.RemoveOutEdge(edge);\n        // not efficient!\n        edge.Target.RemoveInEdge(edge);\n    }\n    ClearEdges() {\n        for (const visibilityVertex of this.Vertices()) {\n            visibilityVertex.ClearEdges();\n        }\n    }\n}\n//# sourceMappingURL=VisibilityGraph.js.map","export var VisibilityKind;\n(function (VisibilityKind) {\n    VisibilityKind[VisibilityKind[\"Regular\"] = 0] = \"Regular\";\n    VisibilityKind[VisibilityKind[\"Tangent\"] = 1] = \"Tangent\";\n})(VisibilityKind || (VisibilityKind = {}));\n//# sourceMappingURL=VisibilityKind.js.map","import { RBTree } from '../../math/RBTree/rbTree';\nexport class VisibilityVertex {\n    get InEdges() {\n        return this._inEdges;\n    }\n    // this collection is sorted by the target point, in the lexicographical order\n    get OutEdges() {\n        return this._outEdges;\n    }\n    get Degree() {\n        return this._inEdges.length + this.OutEdges.count;\n    }\n    InEdgesLength() {\n        return this._inEdges.length;\n    }\n    addInEdge(e) {\n        this._inEdges.push(e);\n    }\n    get IsTerminal() {\n        return this._isTerminal;\n    }\n    set IsTerminal(value) {\n        this._isTerminal = value;\n    }\n    get IsShortestPathTerminal() {\n        return this._isShortestPathTerminal;\n    }\n    set IsShortestPathTerminal(value) {\n        this._isShortestPathTerminal = value;\n    }\n    constructor(point) {\n        this._inEdges = new Array();\n        this._outEdges = new RBTree((a, b) => this.Compare(a, b));\n        this.point = point;\n    }\n    toString() {\n        return this.point.toString();\n    }\n    // These iterate from the end of the list because Array.Remove is linear in\n    // the number of items, so callers have been optimized where possible to\n    // remove only the last or next-to-last edges (but in some cases such as\n    // rectilinear, this optimization isn't always possible).\n    RemoveOutEdge(edge) {\n        this.OutEdges.remove(edge);\n    }\n    RemoveInEdge(edge) {\n        // eslint-disable-next-line for-direction\n        const i = this._inEdges.indexOf(edge);\n        if (i === -1)\n            return;\n        const last = this._inEdges.length - 1;\n        if (i !== last) {\n            this._inEdges[i] = this._inEdges[last];\n        }\n        this._inEdges.pop();\n    }\n    // avoiding using delegates in calling RBTree.FindFirst because of the memory allocations\n    static FindFirst(tree, targetPoint) {\n        return VisibilityVertex.FindFirst_t(tree.root, tree, targetPoint);\n    }\n    static FindFirst_t(n, tree, targetPoint) {\n        if (n === tree.nil) {\n            return null;\n        }\n        let ret = null;\n        while (n !== tree.nil) {\n            n = n.item.TargetPoint.compareTo(targetPoint) >= 0 ? (ret = n).left : n.right;\n        }\n        return ret;\n    }\n    get(target) {\n        let node = VisibilityVertex.FindFirst(this.OutEdges, target.point);\n        if (node != null) {\n            if (node.item.Target === target) {\n                return node.item;\n            }\n        }\n        node = VisibilityVertex.FindFirst(target.OutEdges, this.point);\n        if (node != null) {\n            if (node.item.Target === this) {\n                return node.item;\n            }\n        }\n        return null;\n    }\n    Compare(a, b) {\n        return a.TargetPoint.compareTo(b.TargetPoint);\n    }\n    ClearEdges() {\n        this._outEdges.clear();\n        this._inEdges = [];\n    }\n}\n//# sourceMappingURL=VisibilityVertex.js.map","import { BasicGraphOnEdges } from './basicGraphOnEdges';\nexport class BasicGraph extends BasicGraphOnEdges {\n    constructor(edges, numberOfVerts) {\n        super();\n        this.SetEdges(edges, numberOfVerts);\n    }\n}\n//# sourceMappingURL=BasicGraph.js.map","// A priority queue based on the binary heap algorithm\nexport class BinaryHeapPriorityQueue {\n    get Count() {\n        return this.heapSize;\n    }\n    // the constructor\n    // we assume that all integers inserted into the queue will be non-negative and less then n\n    constructor(n) {\n        this.heapSize = 0;\n        this._priors = new Array(n);\n        this._heap = new Array(n + 1);\n        // because indexing for A starts from 1\n        this._reverse_heap = new Array(n);\n    }\n    SwapWithParent(i) {\n        const parent = this._heap[i >> 1];\n        this.PutAtI(i >> 1, this._heap[i]);\n        this.PutAtI(i, parent);\n    }\n    Enqueue(o, priority) {\n        this.heapSize++;\n        let i = this.heapSize;\n        this._priors[o] = priority;\n        this.PutAtI(i, o);\n        while (i > 1 && this._priors[this._heap[i >> 1]] > priority) {\n            this.SwapWithParent(i);\n            i >>= 1;\n        }\n    }\n    PutAtI(i, h) {\n        this._heap[i] = h;\n        this._reverse_heap[h] = i;\n    }\n    // return the first element of the queue and removes it from the queue\n    Dequeue() {\n        if (this.heapSize === 0) {\n            throw new Error();\n        }\n        const ret = this._heap[1];\n        if (this.heapSize > 1) {\n            this.PutAtI(1, this._heap[this.heapSize]);\n            let i = 1;\n            while (true) {\n                let smallest = i;\n                const l = i << 1;\n                if (l <= this.heapSize && this._priors[this._heap[l]] < this._priors[this._heap[i]]) {\n                    smallest = l;\n                }\n                const r = l + 1;\n                if (r <= this.heapSize && this._priors[this._heap[r]] < this._priors[this._heap[smallest]]) {\n                    smallest = r;\n                }\n                if (smallest !== i) {\n                    this.SwapWithParent(smallest);\n                }\n                else {\n                    break;\n                }\n                i = smallest;\n            }\n        }\n        this.heapSize--;\n        return ret;\n    }\n    IsEmpty() {\n        return this.heapSize === 0;\n    }\n    DecreasePriority(o, newPriority) {\n        // System.Diagnostics.Debug.WriteLine(\"delcrease \"+ o.ToString()+\" to \"+ newPriority.ToString());\n        this._priors[o] = newPriority;\n        let i = this._reverse_heap[o];\n        while (i > 1) {\n            if (this._priors[this._heap[i]] < this._priors[this._heap[i >> 1]]) {\n                this.SwapWithParent(i);\n            }\n            else {\n                break;\n            }\n            i >>= 1;\n        }\n    }\n}\n//# sourceMappingURL=BinaryHeapPriorityQueue.js.map","// A priority queue based on the binary heap algorithm.\n// This class needs a comparer object to compare elements of the queue.\nexport class BinaryHeapWithComparer {\n    *[Symbol.iterator]() {\n        for (let i = 1; i <= this.heapSize; i++) {\n            yield this.A[i];\n        }\n    }\n    Enqueue(element) {\n        let i = this.heapSize + 1;\n        this.A[i] = element;\n        this.heapSize++;\n        let j = i >> 1;\n        let son;\n        let parent;\n        while (i > 1 && this.Less((son = this.A[i]), (parent = this.A[j]))) {\n            this.A[j] = son;\n            this.A[i] = parent;\n            i = j;\n            j = i >> 1;\n        }\n    }\n    Dequeue() {\n        if (this.heapSize < 1) {\n            throw new Error();\n        }\n        const ret = this.A[1];\n        const candidate = this.A[this.heapSize];\n        this.heapSize--;\n        this.ChangeMinimum(candidate);\n        return ret;\n    }\n    ChangeMinimum(candidate) {\n        this.A[1] = candidate;\n        let j = 1;\n        let i = 2;\n        let done = false;\n        while (i < this.heapSize && !done) {\n            done = true;\n            // both sons exist\n            const leftSon = this.A[i];\n            const rigthSon = this.A[i + 1];\n            const compareResult = this.compare(leftSon, rigthSon);\n            if (compareResult < 0) {\n                // left son is the smallest\n                if (this.compare(leftSon, candidate) < 0) {\n                    this.A[j] = leftSon;\n                    this.A[i] = candidate;\n                    done = false;\n                    j = i;\n                    i = j << 1;\n                }\n            }\n            else {\n                // right son in not the greatest\n                if (this.compare(rigthSon, candidate) < 0) {\n                    this.A[j] = rigthSon;\n                    this.A[i + 1] = candidate;\n                    done = false;\n                    j = i + 1;\n                    i = j << 1;\n                }\n            }\n        }\n        if (i === this.heapSize) {\n            // can we do one more step:\n            const leftSon = this.A[i];\n            if (this.compare(leftSon, candidate) < 0) {\n                this.A[j] = leftSon;\n                this.A[i] = candidate;\n            }\n        }\n    }\n    get Count() {\n        return this.heapSize;\n    }\n    Less(a, b) {\n        return this.compare(a, b) < 0;\n    }\n    constructor(compare) {\n        // array of the heap elems starting at A[1]\n        this.heapSize = 0;\n        this.A = [];\n        this.compare = compare;\n    }\n    GetMinimum() {\n        return this.A[1];\n    }\n}\n//# sourceMappingURL=BinaryHeapWithComparer.js.map","import { Attribute } from './attribute';\nimport { AttributeRegistry } from './attributeRegistry';\nexport class AlgorithmData extends Attribute {\n    clone() {\n        throw new Error('Method not implemented.');\n    }\n    rebind(e) {\n        this.entity = e;\n        this.bind(AttributeRegistry.AlgorithmDataIndex);\n    }\n    constructor(entity, data = null) {\n        super(entity, AttributeRegistry.AlgorithmDataIndex);\n        this.data = data;\n    }\n    static getAlgData(attrCont) {\n        return attrCont.getAttr(AttributeRegistry.AlgorithmDataIndex);\n    }\n}\n//# sourceMappingURL=algorithmData.js.map","/** The class to support attributes of Entity */\nexport class Attribute {\n    /** this in the index of where the attribute is positioned in the attribute array of the entity */\n    bind(index) {\n        if (this.entity)\n            this.entity.setAttr(index, this);\n    }\n    /** The arguments are the underlying entity and the attribute index in the attribute array */\n    constructor(entity, index) {\n        this.entity = entity;\n        this.bind(index);\n    }\n}\n//# sourceMappingURL=attribute.js.map","export class AttributeRegistry {\n}\nAttributeRegistry.GeomObjectIndex = 0;\nAttributeRegistry.DrawingObjectIndex = 1;\nAttributeRegistry.AlgorithmDataIndex = 2;\nAttributeRegistry.ViewerIndex = 3;\n//# sourceMappingURL=attributeRegistry.js.map","import { Queue } from 'queue-typescript';\nexport function mkGraphOnEdges(edges) {\n    const n = new BasicGraphOnEdges();\n    n.SetEdges(edges, BasicGraphOnEdges.vertexCount(edges));\n    return n;\n}\nexport function mkGraphOnEdgesArray(edges) {\n    const n = new BasicGraphOnEdges();\n    n.SetEdges(edges, BasicGraphOnEdges.vertexCount(edges));\n    return n;\n}\nexport function mkGraphOnEdgesN(edges, numberOfVerts) {\n    const n = new BasicGraphOnEdges();\n    n.SetEdges(edges, numberOfVerts);\n    return n;\n}\nexport class BasicGraphOnEdges {\n    constructor() {\n        this.nodeCount = 0;\n    }\n    *incidentEdges(v) {\n        for (const e of this.outEdges[v])\n            yield e;\n        for (const e of this.inEdges[v])\n            yield e;\n    }\n    static deleteFromArray(arr, obj) {\n        const index = arr.indexOf(obj, 0);\n        if (index > -1) {\n            arr.splice(index, 1);\n        }\n    }\n    // the method is not efficient, takes linear time\n    removeEdge(edge) {\n        BasicGraphOnEdges.deleteFromArray(this.edges, edge);\n        if (edge.source !== edge.target) {\n            BasicGraphOnEdges.deleteFromArray(this.outEdges[edge.source], edge);\n            BasicGraphOnEdges.deleteFromArray(this.inEdges[edge.target], edge);\n        }\n        else {\n            BasicGraphOnEdges.deleteFromArray(this.selfEdges[edge.source], edge);\n        }\n    }\n    // This method should be static be\n    // finds the maximum of sources and targets, and return it incremented by 1\n    static vertexCount(edges) {\n        let nov = 0;\n        for (const ie of edges) {\n            if (ie.source >= nov)\n                nov = ie.source;\n            if (ie.target >= nov)\n                nov = ie.target;\n        }\n        return ++nov;\n    }\n    // sets edges of the graph\n    SetEdges(valEdges, nov) {\n        this.edges = valEdges;\n        this.nodeCount = nov;\n        const outEdgesCounts = new Array(this.nodeCount).fill(0);\n        const inEdgesCounts = new Array(this.nodeCount).fill(0);\n        const selfEdgesCounts = new Array(this.nodeCount).fill(0);\n        this.outEdges = new Array(this.nodeCount);\n        this.inEdges = new Array(this.nodeCount);\n        this.selfEdges = new Array(this.nodeCount);\n        for (const e of this.edges) {\n            if (e.source !== e.target) {\n                outEdgesCounts[e.source]++;\n                inEdgesCounts[e.target]++;\n            }\n            else {\n                selfEdgesCounts[e.source]++;\n            }\n        }\n        //allocate now\n        for (let i = 0; i < this.nodeCount; i++) {\n            this.outEdges[i] = new Array(outEdgesCounts[i]);\n            outEdgesCounts[i] = 0; //used later for edge insertion\n            this.inEdges[i] = new Array(inEdgesCounts[i]);\n            inEdgesCounts[i] = 0; //used later for edge insertion\n            this.selfEdges[i] = new Array(selfEdgesCounts[i]);\n            selfEdgesCounts[i] = 0; //used later for edge insertion\n        }\n        //set the edges now\n        for (const e of this.edges) {\n            const u = e.source;\n            const v = e.target;\n            if (u !== v) {\n                this.outEdges[u][outEdgesCounts[u]++] = e;\n                this.inEdges[v][inEdgesCounts[v]++] = e;\n            }\n            else {\n                this.selfEdges[u][selfEdgesCounts[u]++] = e;\n            }\n        }\n    }\n    inEdgesCount(node) {\n        return this.inEdges[node].length;\n    }\n    outEdgesCount(node) {\n        return this.outEdges[node].length;\n    }\n    selfEdgesCount(node) {\n        return this.selfEdges[node].length;\n    }\n    addEdge(e) {\n        this.edges.push(e);\n        if (e.source !== e.target) {\n            this.outEdges[e.source].push(e);\n            this.inEdges[e.target].push(e);\n        }\n        else {\n            this.selfEdges[e.source].push(e);\n        }\n    }\n    // We assume that the graph is connected here\n    *nodesOfConnectedGraph() {\n        if (this.edges.length === 0)\n            return;\n        const enqueed = new Set();\n        const q = new Queue();\n        let i = this.edges[0].source;\n        BasicGraphOnEdges.enqueue(enqueed, q, i);\n        yield i;\n        while (q.length > 0) {\n            i = q.dequeue();\n            for (const e of this.outEdges[i]) {\n                const s = e.target;\n                if (!enqueed.has(s)) {\n                    BasicGraphOnEdges.enqueue(enqueed, q, s);\n                    yield s;\n                }\n            }\n            for (const e of this.inEdges[i]) {\n                const s = e.source;\n                if (!enqueed.has(s)) {\n                    BasicGraphOnEdges.enqueue(enqueed, q, s);\n                    yield s;\n                }\n            }\n        }\n    }\n    *pred(n) {\n        for (const e of this.inEdges[n]) {\n            yield e.source;\n        }\n    }\n    *succ(n) {\n        for (const e of this.outEdges[n]) {\n            yield e.target;\n        }\n    }\n    static enqueue(enqueed, q, i) {\n        q.enqueue(i);\n        enqueed.add(i);\n    }\n}\n//# sourceMappingURL=basicGraphOnEdges.js.map","import { Entity } from './entity';\nimport { Graph } from './graph';\n/** characterize edge if it connects an node and its ancestor */\nexport var ToAncestorEnum;\n(function (ToAncestorEnum) {\n    /** the source and the target are siblings */\n    ToAncestorEnum[ToAncestorEnum[\"None\"] = 0] = \"None\";\n    /** the source is an ancestor of the target */\n    ToAncestorEnum[ToAncestorEnum[\"FromAncestor\"] = 1] = \"FromAncestor\";\n    /** the target is an ancestor of the source */\n    ToAncestorEnum[ToAncestorEnum[\"ToAncestor\"] = 2] = \"ToAncestor\";\n})(ToAncestorEnum || (ToAncestorEnum = {}));\nexport class Edge extends Entity {\n    constructor(s, t) {\n        super();\n        this.source = s;\n        this.target = t;\n        if (s !== t) {\n            s.outEdges.add(this);\n            t.inEdges.add(this);\n        }\n        else {\n            s.selfEdges.add(this);\n        }\n    }\n    add() {\n        if (this.source !== this.target) {\n            this.source.outEdges.add(this);\n            this.target.inEdges.add(this);\n        }\n        else {\n            this.source.selfEdges.add(this);\n        }\n    }\n    remove() {\n        if (this.source !== this.target) {\n            this.source.outEdges.delete(this);\n            this.target.inEdges.delete(this);\n        }\n        else {\n            this.source.selfEdges.delete(this);\n        }\n    }\n    toString() {\n        return '(' + this.source.toString() + '->' + this.target.toString() + ')';\n    }\n    isInterGraphEdge() {\n        return this.source.parent !== this.target.parent;\n    }\n    EdgeToAncestor() {\n        if (this.source instanceof Graph) {\n            if (this.target.isDescendantOf(this.source))\n                return ToAncestorEnum.FromAncestor;\n        }\n        if (this.target instanceof Graph) {\n            if (this.source.isDescendantOf(this.target))\n                return ToAncestorEnum.ToAncestor;\n        }\n        return ToAncestorEnum.None;\n    }\n}\n//# sourceMappingURL=edge.js.map","/**\n * Entity is an attribute container with a parent.\n * It also keeps an array of event functions.\n */\nexport class Entity {\n    constructor() {\n        /** keeps entity attributes: for example, drawing attributes, geometry attributes, etc */\n        this.attrs = [];\n        this._parent = null;\n    }\n    /** adds an event function */\n    addEvent(event) {\n        this.events.push(event);\n    }\n    /** trying to remove an event function */\n    removeEvent(event) {\n        const index = this.events.indexOf(event);\n        if (index >= 0) {\n            this.events = this.events.splice(index, 1);\n        }\n    }\n    /** raises all available events on the given data */\n    raiseEvents(data) {\n        this.events.forEach((event) => event(data));\n    }\n    /** removes all the attributes form the entity */\n    clearAttr() {\n        this.attrs = [];\n    }\n    /** sets the attribute at the given position */\n    setAttr(position, val) {\n        this.attrs[position] = val;\n    }\n    /** gets the attribute at the given position */\n    getAttr(position) {\n        return this.attrs[position];\n    }\n    get parent() {\n        return this._parent;\n    }\n    set parent(value) {\n        this._parent = value;\n    }\n    *getAncestors() {\n        let p = this.parent;\n        while (p != null) {\n            yield p;\n            p = p.parent;\n        }\n    }\n    /**  Determines if this node is a descendant of the given graph.*/\n    isDescendantOf(graph) {\n        for (const p of this.getAncestors()) {\n            if (p === graph)\n                return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=entity.js.map","// Generic version priority queue based on the binary heap algorithm where\nimport { StringBuilder } from 'typescript-string-operations';\nimport { compareNumbers } from '../utils/compare';\nimport { GenericHeapElement } from './genericHeapElement';\n// the priority of each element is passed as a parameter.\nexport class GenericBinaryHeapPriorityQueue {\n    get count() {\n        return this.heapSize;\n    }\n    ContainsElement(key) {\n        return this.cache.has(key);\n    }\n    constructor(compare = compareNumbers) {\n        this.heapSize = 0;\n        this.compare = compare;\n        this.cache = new Map();\n        this.A = [];\n    }\n    SwapWithParent(i) {\n        const parent = this.A[i >> 1];\n        this.PutAtI(i >> 1, this.A[i]);\n        this.PutAtI(i, parent);\n    }\n    Enqueue(element, priority) {\n        let i = ++this.heapSize;\n        const h = new GenericHeapElement(i, priority, element);\n        this.cache.set(element, h);\n        this.A[i] = h;\n        while (i > 1 && this.compare(this.A[i >> 1].priority, priority) > 0) {\n            this.SwapWithParent(i);\n            i >>= 1;\n        }\n    }\n    IsEmpty() {\n        return this.heapSize === 0;\n    }\n    PutAtI(i, h) {\n        this.A[i] = h;\n        h.indexToA = i;\n    }\n    Dequeue() {\n        if (this.heapSize === 0) {\n            throw new Error('dequeue on an empty queue');\n        }\n        const ret = this.A[1].v;\n        this.MoveQueueOneStepForward(ret);\n        return ret;\n    }\n    DequeueAndGetPriority(t) {\n        if (this.heapSize === 0) {\n            throw new Error('dequeue on an empty queue');\n        }\n        const ret = this.A[1].v;\n        t.priority = this.A[1].priority;\n        this.MoveQueueOneStepForward(ret);\n        return ret;\n    }\n    MoveQueueOneStepForward(ret) {\n        this.cache.delete(ret);\n        this.PutAtI(1, this.A[this.heapSize]);\n        let i = 1;\n        while (true) {\n            let smallest = i;\n            const l = i << 1;\n            if (l <= this.heapSize && this.compare(this.A[l].priority, this.A[i].priority) < 0) {\n                smallest = l;\n            }\n            const r = l + 1;\n            if (r <= this.heapSize && this.compare(this.A[r].priority, this.A[smallest].priority) < 0) {\n                smallest = r;\n            }\n            if (smallest !== i) {\n                this.SwapWithParent(smallest);\n            }\n            else {\n                break;\n            }\n            i = smallest;\n        }\n        this.heapSize--;\n    }\n    DecreasePriority(element, newPriority) {\n        const h = this.cache.get(element);\n        // ignore the element if it is not in the queue\n        if (!h) {\n            return;\n        }\n        // var h = cache[element];\n        h.priority = newPriority;\n        let i = h.indexToA;\n        while (i > 1) {\n            if (this.compare(this.A[i].priority, this.A[i >> 1].priority) < 0) {\n                this.SwapWithParent(i);\n            }\n            else {\n                break;\n            }\n            i >>= 1;\n        }\n    }\n    *GetEnumerator() {\n        for (let i = 1; i <= this.heapSize; i++) {\n            yield this.A[i].v;\n        }\n    }\n    //\n    Peek(t) {\n        if (this.count === 0) {\n            t.priority = 0;\n            return;\n        }\n        t.priority = this.A[1].priority;\n        return this.A[1].v;\n    }\n    toString() {\n        const sb = new StringBuilder();\n        for (const i of this.A) {\n            sb.Append(i + ',');\n        }\n        return sb.ToString();\n    }\n}\n//# sourceMappingURL=genericBinaryHeapPriorityQueue.js.map","export class GenericHeapElement {\n    // value\n    constructor(index, priority, v) {\n        this.indexToA = index;\n        this.priority = priority;\n        this.v = v;\n    }\n}\n//# sourceMappingURL=genericHeapElement.js.map","import { Queue } from 'queue-typescript';\nimport { Assert } from '../utils/assert';\n// import {Assert} from '../utils/assert'\nimport { Edge } from './edge';\nimport { Node } from './node';\nimport { NodeCollection } from './nodeCollection';\n/** This class keeps the connection between the nodes and the edges of the graph. The nodes of a Graph can also be Graphs.  */\nexport class Graph extends Node {\n    remove(node) {\n        this.nodeCollection.remove(node);\n    }\n    /** Removes itself from under the parent.\n     *  Also removes all the edges leading out of the graph.\n     */\n    removeSubgraph() {\n        const parent = this.parent;\n        if (parent)\n            parent.removeNode(this);\n        for (const c of this.outGoingEdges()) {\n            if (c.attachedAtSource) {\n                c.node.removeOutEdge(c.edge);\n            }\n            else {\n                c.node.removeInEdge(c.edge);\n            }\n        }\n    }\n    /** returns the objects that show how the edge is adjacent to a node  that is outside of the graph */\n    *outGoingEdges() {\n        for (const e of this.outEdges) {\n            const t = e.target;\n            if (!this.isAncestor(t)) {\n                yield { edge: e, node: t, attachedAtSource: false };\n            }\n        }\n        for (const e of this.inEdges) {\n            const s = e.source;\n            if (!this.isAncestor(s)) {\n                yield { edge: e, node: s, attachedAtSource: true };\n            }\n        }\n        for (const n of this.nodesBreadthFirst) {\n            for (const e of n.outEdges) {\n                const t = e.target;\n                if (t === this)\n                    continue;\n                if (!this.isAncestor(t)) {\n                    yield { edge: e, node: t, attachedAtSource: false };\n                }\n            }\n            for (const e of n.inEdges) {\n                const s = e.source;\n                if (s === this)\n                    continue;\n                if (!this.isAncestor(s)) {\n                    yield { edge: e, node: s, attachedAtSource: true };\n                }\n            }\n        }\n    }\n    isAncestor(entity) {\n        for (const ant of entity.getAncestors()) {\n            if (ant === this) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**  Iterates over all connected components of the graph and for each component\n     * returns all its nodes with \"this\" as the parent\n     */\n    *getClusteredConnectedComponents() {\n        const processed = new Set();\n        const q = new Queue();\n        for (const v of this.nodesBreadthFirst) {\n            if (processed.has(v))\n                continue;\n            processed.add(v);\n            q.enqueue(v);\n            const component = new Set();\n            do {\n                const u = q.dequeue();\n                if (u.parent === this) {\n                    component.add(u);\n                }\n                for (const w of this.reachableFrom(u)) {\n                    if (!processed.has(w)) {\n                        processed.add(w);\n                        q.enqueue(w);\n                    }\n                }\n            } while (q.length > 0);\n            yield Array.from(component);\n        }\n    }\n    *reachableFrom(u) {\n        for (const e of u.outEdges) {\n            yield e.target;\n        }\n        for (const e of u.inEdges) {\n            yield e.source;\n        }\n        if (u instanceof Graph) {\n            yield* u.shallowNodes;\n        }\n        if (u.parent != this) {\n            yield u.parent;\n        }\n    }\n    hasSomeAttrOnIndex(index) {\n        for (const n of this.nodesBreadthFirst) {\n            if (n.getAttr(index))\n                return true;\n        }\n        for (const n of this.deepEdges) {\n            if (n.getAttr(index))\n                return true;\n        }\n        return false;\n    }\n    *graphs() {\n        for (const g of this.nodeCollection.graphs) {\n            yield g;\n        }\n    }\n    noEmptySubgraphs() {\n        for (const g of this.subgraphsBreadthFirst()) {\n            if (g.shallowNodeCount === 0)\n                return false;\n        }\n        return true;\n    }\n    hasSubgraphs() {\n        for (const n of this.shallowNodes)\n            if (n instanceof Graph)\n                return true;\n        return false;\n    }\n    /** iterates breadth first  */\n    *subgraphsBreadthFirst() {\n        for (const n of this.nodesBreadthFirst) {\n            if (n instanceof Graph)\n                yield n;\n        }\n    }\n    isEmpty() {\n        return this.shallowNodeCount === 0;\n    }\n    setEdge(sourceId, targetId) {\n        const s = this.nodeCollection.findShallow(sourceId);\n        if (s == null)\n            return;\n        const t = this.nodeCollection.findShallow(targetId);\n        if (t == null)\n            return;\n        return new Edge(s, t);\n    }\n    /** Iterates over the nodes of the current graph but not entering the subgraphs.\n     *  Yields the top subgraphs among the nodes as well\n     */\n    get shallowNodes() {\n        return this.nodeCollection.nodesShallow;\n    }\n    /** Iterates over all the nodes of including the subgraphs.\n     * The iteration happens in the breadth first pattern.\n     */\n    get nodesBreadthFirst() {\n        return this.nodesBreadthFirst_();\n    }\n    /** iterates breadth first  */\n    *nodesBreadthFirst_() {\n        for (const n of this.nodeCollection.nodesShallow) {\n            yield n;\n            if (n instanceof Graph) {\n                yield* n.nodesBreadthFirst;\n            }\n        }\n    }\n    constructor(id = '__graph__') {\n        super(id);\n        this.nodeCollection = new NodeCollection();\n    }\n    /**\n     * Finds the node with the givin id belonging to a graph or one of its subgraphs.\n     */\n    findNodeRecursive(id) {\n        const n = this.nodeCollection.findShallow(id);\n        if (n) {\n            return n;\n        }\n        for (const g of this.shallowNodes) {\n            if (g instanceof Graph) {\n                const nn = g.findNodeRecursive(id);\n                if (nn)\n                    return nn;\n            }\n        }\n        return null;\n    }\n    /** Returns a node belonging to this graph having the same id.\n     * If a node with the given id belongs to a subgraph than it would no be returned.\n     * To find such a deeper nested node use findNodeRecursive\n     */\n    findNode(id) {\n        return this.nodeCollection.findShallow(id);\n    }\n    /** iterates over the edges of the graph which adjacent to the nodes of the graph:\n     * not iterating over the subgraphs\n     */\n    get shallowEdges() {\n        return this.nodeCollection.edges;\n    }\n    /** iterates over the edges of the graph including subgraphs */\n    get deepEdges() {\n        return this.deepEdgesIt();\n    }\n    *deepEdgesIt() {\n        for (const node of this.nodesBreadthFirst) {\n            for (const e of node.outEdges) {\n                yield e;\n            }\n            for (const e of node.selfEdges) {\n                yield e;\n            }\n            for (const e of node.inEdges) {\n                if (!this.isAncestor(e.source))\n                    yield e;\n            }\n        }\n    }\n    isConsistent() {\n        if (this.parent)\n            return this.parent.isConsistent();\n        return this.eachNodeIdIsUnique() && this.nodeCollection.isConsistent();\n    }\n    nodeIsConsistent(n) {\n        return this.nodeCollection.nodeIsConsistent(n);\n    }\n    /** Detouches all the node's edges and removes the node from the graph.\n     * This method does not change the parent of the node.\n     */\n    removeNode(node) {\n        for (const e of node.outEdges) {\n            e.target.inEdges.delete(e);\n        }\n        for (const e of node.inEdges) {\n            e.source.outEdges.delete(e);\n        }\n        this.nodeCollection.remove(node);\n        for (const p of this.subgraphsBreadthFirst()) {\n            p.removeNode(node);\n        }\n    }\n    /** adds a node to the graph */\n    addNode(n) {\n        Assert.assert(this.findNodeRecursive(n.id) == null);\n        /*Assert.assert(n.parent == null  || n.parent === this)*/\n        n.parent = this;\n        this.nodeCollection.addNode(n);\n        // Assert.assert(this.isConsistent())\n        return n;\n    }\n    get shallowNodeCount() {\n        return this.nodeCollection.nodeShallowCount;\n    }\n    get nodeCountDeep() {\n        let count = this.nodeCollection.size;\n        for (const p of this.shallowNodes) {\n            if (p instanceof Graph) {\n                count += p.nodeCountDeep;\n            }\n        }\n        return count;\n    }\n    get edgeCount() {\n        return this.nodeCollection.edgeCount;\n    }\n    // If n has an ancestor which is the graph child then return it.\n    // Otherwise return null\n    liftNode(n) {\n        while (n != null && n.parent !== this) {\n            n = n.parent;\n        }\n        return n;\n    }\n    /** return the number of all edges in the graph, including the subgraphs */\n    get deepEdgesCount() {\n        let count = 0;\n        for (const p of this.nodesBreadthFirst) {\n            count += p.outDegree + p.selfDegree;\n        }\n        return count;\n    }\n    eachNodeIdIsUnique() {\n        const ids = new Set();\n        for (const n of this.nodesBreadthFirst) {\n            if (ids.has(n.id)) {\n                return false;\n            }\n            ids.add(n.id);\n        }\n        return true;\n    }\n    /** returns all the nodes under graph and the edges with at least one end adjacent to the graph */\n    *allElements() {\n        for (const n of this.allSuccessorsWidthFirst()) {\n            yield n;\n            for (const e of n.selfEdges) {\n                yield e;\n            }\n            for (const e of n.outEdges) {\n                yield e;\n            }\n            for (const e of n.inEdges) {\n                if (!this.isAncestor(e.source)) {\n                    yield e;\n                }\n            }\n        }\n        yield* this.edges; // uses get edges() of Node\n    }\n    *allSuccessorsWidthFirst() {\n        for (const n of this.shallowNodes) {\n            yield n;\n        }\n        for (const n of this.shallowNodes) {\n            if (n instanceof Graph) {\n                yield* n.allSuccessorsWidthFirst();\n            }\n        }\n    }\n    *allSuccessorsDepthFirst() {\n        for (const n of this.shallowNodes) {\n            if (n instanceof Graph) {\n                yield* n.allSuccessorsDepthFirst();\n            }\n            yield n;\n        }\n    }\n}\nexport function* shallowConnectedComponents(graph) {\n    const enqueueed = new Set();\n    const queue = new Queue();\n    for (const n of graph.shallowNodes) {\n        if (enqueueed.has(n))\n            continue;\n        const nodes = new Array();\n        enqueue(n, queue, enqueueed);\n        while (queue.length > 0) {\n            const s = queue.dequeue();\n            nodes.push(s);\n            for (const neighbor of neighbors(s)) {\n                enqueue(neighbor, queue, enqueueed);\n            }\n        }\n        yield nodes;\n    }\n    function* neighbors(n) {\n        for (const e of n.outEdges)\n            yield e.target;\n        for (const e of n.inEdges)\n            yield e.source;\n    }\n    function enqueue(n, queue, enqueueed) {\n        if (!enqueueed.has(n)) {\n            queue.enqueue(n);\n            enqueueed.add(n);\n        }\n    }\n}\n/** sets a new Graph as the parent of the node */\nexport function setNewParent(newParent, node) {\n    if (node.parent) {\n        const oldParent = node.parent;\n        oldParent.remove(node);\n    }\n    newParent.addNode(node);\n    // let p = newParent\n    // while (p.parent) p = p.parent as Graph\n    // Assert.assert(p.isConsistent())\n}\n/** implements the google PageRank.\n * omega is the probability of following a link\n * */\nexport function pagerank(graph, omega) {\n    let p = new Map();\n    const n = graph.nodeCountDeep;\n    let initialVal = 1 / n;\n    for (const v of graph.nodesBreadthFirst) {\n        p.set(v, initialVal);\n    }\n    // repeat 50 times\n    for (let c = 0; c < 50; c++) {\n        initialVal = (1 - omega) / n;\n        const q = new Map();\n        for (const v of graph.nodesBreadthFirst) {\n            q.set(v, initialVal);\n        }\n        //  forward propagation\n        for (const v of graph.nodesBreadthFirst) {\n            let qv = q.get(v);\n            for (const edge of v.inEdges) {\n                const u = edge.source;\n                qv += omega * (p.get(u) / u.outDegree);\n            }\n            q.set(v, qv);\n        }\n        p = q;\n    }\n    return p;\n}\nexport function edgeNodesBelongToSet(e, s) {\n    return s.has(e.source) && s.has(e.target);\n}\n//# sourceMappingURL=graph.js.map","import { Entity } from './entity';\nexport class Label extends Entity {\n    /** parent is the entity having this label */\n    toString() {\n        return 'label of ' + (this.parent ? this.parent.toString() : 'null');\n    }\n    constructor(labelledParent) {\n        super();\n        this.parent = labelledParent;\n    }\n}\n//# sourceMappingURL=label.js.map","import { Entity } from './entity';\n/** Represent a node of a graph: has id, which is a string, and sets of in/out/self edges */\nexport class Node extends Entity {\n    removeOutEdge(edge) {\n        this.outEdges.delete(edge);\n    }\n    removeInEdge(edge) {\n        this.inEdges.delete(edge);\n    }\n    /** the unique, in the parent graph, id of the node */\n    get id() {\n        return this._id;\n    }\n    set id(value) {\n        /*Assert.assert(value != null)*/\n        this._id = value;\n    }\n    toString() {\n        return this.id;\n    }\n    constructor(id) {\n        super();\n        this.inEdges = new Set();\n        this.outEdges = new Set();\n        this.selfEdges = new Set();\n        // Assert.assert(id != null && id.toString() === id)\n        this.id = id;\n    }\n    *_edges() {\n        for (const e of this.inEdges)\n            yield e;\n        for (const e of this.outEdges)\n            yield e;\n        for (const e of this.selfEdges)\n            yield e;\n    }\n    get edges() {\n        return this._edges();\n    }\n    get outDegree() {\n        return this.outEdges.size;\n    }\n    get inDegree() {\n        return this.inEdges.size;\n    }\n    get selfDegree() {\n        return this.selfEdges.size;\n    }\n    get degree() {\n        return this.outDegree + this.inDegree + this.selfDegree;\n    }\n}\n//# sourceMappingURL=node.js.map","import { Graph } from './graph';\nexport class NodeCollection {\n    constructor() {\n        this.nodeMap = new Map();\n    }\n    remove(node) {\n        this.nodeMap.delete(node.id);\n    }\n    get size() {\n        return this.nodeMap.size;\n    }\n    *nodes_() {\n        for (const p of this.nodeMap.values())\n            yield p;\n    }\n    *graphs_() {\n        for (const n of this.nodes_()) {\n            if (n instanceof Graph) {\n                yield n;\n            }\n        }\n    }\n    findShallow(id) {\n        return this.nodeMap.get(id);\n    }\n    get nodesShallow() {\n        return this.nodes_();\n    }\n    get graphs() {\n        return this.graphs_();\n    }\n    *_edges() {\n        // if we go over node.inEdges too then not self edges will be reported twice\n        for (const node of this.nodeMap.values()) {\n            for (const e of node.outEdges) {\n                yield e;\n            }\n            for (const e of node.selfEdges) {\n                yield e;\n            }\n        }\n    }\n    interGraphEdges() {\n        throw new Error('not implemented');\n    }\n    get nodeShallowCount() {\n        return this.nodeMap.size;\n    }\n    // caution: it is a linear by the number of nodes method\n    get edgeCount() {\n        let count = 0;\n        for (const p of this.nodeMap.values()) {\n            count += p.outDegree + p.selfDegree;\n        }\n        return count;\n    }\n    /**  returns the edges of shallow nodes */\n    get edges() {\n        return this._edges();\n    }\n    addNode(node) {\n        this.nodeMap.set(node.id, node);\n    }\n    nodeIsConsistent(n) {\n        for (const e of n.outEdges) {\n            if (e.source !== n) {\n                return false;\n            }\n            if (e.source === e.target) {\n                return false;\n            }\n        }\n        for (const e of n.inEdges) {\n            if (e.target !== n) {\n                return false;\n            }\n            if (e.source === e.target) {\n                return false;\n            }\n        }\n        for (const e of n.selfEdges) {\n            if (e.target !== e.source) {\n                return false;\n            }\n            if (e.source !== n) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isConsistent() {\n        for (const node of this.nodeMap.values()) {\n            if (!this.nodeIsConsistent(node)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=nodeCollection.js.map","// represents the minimal int->int edge\nexport class IntPair {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    get source() {\n        return this.x;\n    }\n    get target() {\n        return this.y;\n    }\n    isDiagonal() {\n        return this.x === this.y;\n    }\n}\n//# sourceMappingURL=IntPair.js.map","import { IntPair } from './IntPair';\nexport class IntPairMap {\n    isEmpty() {\n        if (this.arrayOfMaps.length === 0)\n            return true;\n        for (const t of this.arrayOfMaps) {\n            if (t.size > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    set(x, y, v) {\n        let m = this.arrayOfMaps[x];\n        if (m === undefined)\n            this.arrayOfMaps[x] = m = new Map();\n        m.set(y, v);\n    }\n    setPair(p, v) {\n        this.set(p.x, p.y, v);\n    }\n    delete(x, y) {\n        if (x < 0 || x >= this.arrayOfMaps.length) {\n            return;\n        }\n        const m = this.arrayOfMaps[x];\n        if (m === undefined)\n            return;\n        m.delete(y);\n        if (m.size === 0)\n            this.arrayOfMaps[x] = undefined;\n    }\n    has(x, y) {\n        if (x < 0 || x >= this.arrayOfMaps.length) {\n            return false;\n        }\n        const m = this.arrayOfMaps[x];\n        if (m === undefined)\n            return false;\n        return m.has(y);\n    }\n    get(x, y) {\n        if (x < 0 || x >= this.arrayOfMaps.length) {\n            return null;\n        }\n        const m = this.arrayOfMaps[x];\n        if (m === undefined)\n            return null;\n        return m.get(y);\n    }\n    getI(p) {\n        return this.get(p.x, p.y);\n    }\n    /** n is the maximum of (x + 1) where (x, *) runs over the keys  */\n    constructor() {\n        this.arrayOfMaps = new Array();\n    }\n    *keys() {\n        for (let i = 0; i < this.arrayOfMaps.length; i++) {\n            const map = this.arrayOfMaps[i];\n            if (map === undefined)\n                continue;\n            for (const p of map) {\n                yield new IntPair(i, p[0]);\n            }\n        }\n    }\n    *keyValues() {\n        for (let i = 0; i < this.arrayOfMaps.length; i++) {\n            const map = this.arrayOfMaps[i];\n            if (map === undefined)\n                continue;\n            for (const p of map) {\n                yield [new IntPair(i, p[0]), p[1]];\n            }\n        }\n    }\n    *values() {\n        for (let i = 0; i < this.arrayOfMaps.length; i++) {\n            const map = this.arrayOfMaps[i];\n            if (map === undefined)\n                continue;\n            for (const p of map) {\n                yield p[1];\n            }\n        }\n    }\n    get size() {\n        let r = 0;\n        for (let i = 0; i < this.arrayOfMaps.length; i++) {\n            const map = this.arrayOfMaps[i];\n            if (map === undefined)\n                continue;\n            r += map.size;\n        }\n        return r;\n    }\n}\n//# sourceMappingURL=IntPairMap.js.map","import { IntPair } from './IntPair';\nexport class IntPairSet {\n    has(p) {\n        return this.hasxy(p.x, p.y);\n    }\n    remove(p) {\n        if (p.x < 0 || p.x >= this.arrayOfSets.length) {\n            return;\n        }\n        return this.arrayOfSets[p.x].delete(p.y);\n    }\n    hasxy(x, y) {\n        if (x < 0 || x >= this.arrayOfSets.length) {\n            return false;\n        }\n        const s = this.arrayOfSets[x];\n        return s !== undefined && s.has(y);\n    }\n    constructor() {\n        this.arrayOfSets = new Array();\n    }\n    static mk(ps) {\n        const r = new IntPairSet();\n        for (const p of ps)\n            r.add(p);\n        return r;\n    }\n    *values() {\n        for (let i = 0; i < this.arrayOfSets.length; i++) {\n            const arr = this.arrayOfSets[i];\n            if (!arr)\n                continue;\n            for (const j of arr.values())\n                yield new IntPair(i, j);\n        }\n    }\n    add(p) {\n        let s = this.arrayOfSets[p.x];\n        if (s == null) {\n            this.arrayOfSets[p.x] = s = new Set();\n        }\n        s.add(p.y);\n    }\n    addNN(x, y) {\n        let s = this.arrayOfSets[x];\n        if (s == null) {\n            this.arrayOfSets[x] = s = new Set();\n        }\n        s.add(y);\n    }\n    clear() {\n        for (const s of this.arrayOfSets) {\n            if (s)\n                s.clear();\n        }\n    }\n}\n//# sourceMappingURL=IntPairSet.js.map","import { Point } from '../math/geometry/point';\nexport class PointMap {\n    deleteP(point) {\n        return this.delete(point.x, point.y);\n    }\n    clear() {\n        this.m.clear();\n    }\n    get size() {\n        return this.m.size;\n    }\n    setxy(x, y, v) {\n        this.m.set(getKey(x, y), v);\n    }\n    set(p, v) {\n        this.setxy(p.x, p.y, v);\n    }\n    delete(x, y) {\n        return this.m.delete(getKey(x, y));\n    }\n    hasxy(x, y) {\n        return this.m.has(getKey(x, y));\n    }\n    has(p) {\n        return this.hasxy(p.x, p.y);\n    }\n    getxy(x, y) {\n        return this.m.get(getKey(x, y));\n    }\n    get(p) {\n        return this.getxy(p.x, p.y);\n    }\n    constructor() {\n        this.m = new Map();\n    }\n    *keys() {\n        for (const p of this.m.keys()) {\n            const parts = p.split(',');\n            yield new Point(Number(parts[0]), Number(parts[1]));\n        }\n    }\n    *[Symbol.iterator]() {\n        for (const [p, v] of this.m) {\n            const parts = p.split(',');\n            yield [new Point(Number(parts[0]), Number(parts[1])), v];\n        }\n    }\n    *values() {\n        yield* this.m.values();\n    }\n}\nfunction getKey(x, y) {\n    return x.toString() + ',' + y.toString();\n}\n//# sourceMappingURL=PointMap.js.map","import { Point } from '../math/geometry/point';\nexport class PointSet {\n    delete(point) {\n        return this.deletexy(point.x, point.y);\n    }\n    clear() {\n        this.mapOfSets.clear();\n        this.size_ = 0;\n    }\n    get size() {\n        return this.size_;\n    }\n    static mk(points) {\n        const ret = new PointSet();\n        for (const p of points) {\n            ret.add(p);\n        }\n        return ret;\n    }\n    addxy(x, y) {\n        let m = this.mapOfSets.get(x);\n        if (m == null)\n            this.mapOfSets.set(x, (m = new Set()));\n        if (!m.has(y)) {\n            this.size_++;\n        }\n        m.add(y);\n    }\n    add(p) {\n        this.addxy(p.x, p.y);\n        return this;\n    }\n    deletexy(x, y) {\n        const m = this.mapOfSets.get(x);\n        if (m != null) {\n            if (m.delete(y)) {\n                this.size_--;\n                return true;\n            }\n        }\n        return false;\n    }\n    hasxy(x, y) {\n        return this.mapOfSets.has(x) && this.mapOfSets.get(x).has(y);\n    }\n    has(p) {\n        return this.hasxy(p.x, p.y);\n    }\n    constructor() {\n        this.size_ = 0;\n        this.mapOfSets = new Map();\n    }\n    forEach(callbackfn, thisArg) {\n        for (const p of this) {\n            callbackfn(p, p, thisArg);\n        }\n    }\n    *entries() {\n        for (const p of this) {\n            yield [p, p];\n        }\n    }\n    keys() {\n        return this.values();\n    }\n    *values() {\n        for (const p of this.mapOfSets) {\n            for (const yV of p[1]) {\n                yield new Point(p[0], yV);\n            }\n        }\n    }\n    [(Symbol.toStringTag, Symbol.iterator)]() {\n        return this.values();\n    }\n}\n//# sourceMappingURL=PointSet.js.map","import { GeomConstants } from '../math/geometry/geomConstants';\n// this class behaves like one dimensional bounding box\nexport class RealNumberSpan {\n    constructor() {\n        this.isEmpty = true;\n    }\n    AddValue(x) {\n        if (this.isEmpty) {\n            this.max = x;\n            this.min = x;\n            this.isEmpty = false;\n        }\n        else if (x < this.min) {\n            this.min = x;\n        }\n        else if (x > this.max) {\n            this.max = x;\n        }\n    }\n    get length() {\n        return this.max - this.min;\n    }\n    // 0  if value is close to zero;\n    // 1  if value is strictly greater than zero;\n    // -1 if value is strictly lower than zero;\n    static sign(value) {\n        return value > GeomConstants.distanceEpsilon ? 1 : value < -GeomConstants.distanceEpsilon ? -1 : 0;\n    }\n}\n//# sourceMappingURL=RealNumberSpan.js.map","export class Algorithm {\n    ProgressStep() {\n        // todo: Implement\n    }\n    constructor(cancelToken) {\n        this.cancelToken = cancelToken;\n    }\n}\n//# sourceMappingURL=algorithm.js.map","export class Assert {\n    static assert(p, s = null) {\n        if (!p) {\n            if (s != null) {\n                console.log(s);\n                throw new Error(s);\n            }\n            throw new Error('condition does not hold');\n        }\n    }\n}\n//# sourceMappingURL=assert.js.map","// a place holder for the cancelled flag\nexport class CancelToken {\n    throwIfCanceled() {\n        throw new Error('Algorithm was cancelled');\n    }\n    // Set this flag to true when you want to cancel the layout.\n    get canceled() {\n        return this.canceled_;\n    }\n    set canceled(value) {\n        this.canceled_ = value;\n    }\n}\n//# sourceMappingURL=cancelToken.js.map","import { GeomConstants } from '../math/geometry/geomConstants';\nexport function compareBooleans(a, b) {\n    // return a - b\n    return (a ? 1 : 0) - (b ? 1 : 0);\n}\nexport function compareNumbers(a, b) {\n    const t = a - b;\n    return t < 0 ? -1 : t === 0 ? 0 : 1;\n}\nexport function comparePointsYFirst(a, b) {\n    const cmp = compareNumbers(a.y, b.y);\n    return cmp ? cmp : compareNumbers(a.x, b.x);\n}\nexport function comparePointsXY(a, b) {\n    const cmp = compareNumbers(a.x, b.x);\n    return cmp ? cmp : compareNumbers(a.y, b.y);\n}\nexport function closeDistEps(a, b) {\n    const d = a - b;\n    return -GeomConstants.distanceEpsilon <= d && d <= GeomConstants.distanceEpsilon;\n}\n/** return true iff a >= b + GeomConstants.distanceEpsilon */\nexport function greaterDistEps(a, b) {\n    return compareNumbersDistEps(a, b) > 0;\n}\n/** return true iff a <= b - GeomConstants.distanceEpsilon */\nexport function lessDistEps(a, b) {\n    return compareNumbersDistEps(a, b) < 0;\n}\n/** returns -1 when a-b <= - GeomConstants.distanceEpsilon\n * returns 1 when a-b >=  GeomConstants.distanceEpsilon\n * return 0 otherwise\n */\nexport function compareNumbersDistEps(a, b) {\n    const c = a - b;\n    // The <= and >= here complement the < and > in Close(double, double).\n    if (c <= -GeomConstants.distanceEpsilon) {\n        return -1;\n    }\n    if (c >= GeomConstants.distanceEpsilon) {\n        return 1;\n    }\n    return 0;\n}\n//# sourceMappingURL=compare.js.map","export function copyTo(s, t) {\n    for (let i = 0; i < s.length; i++)\n        t[i] = s[i];\n}\n//# sourceMappingURL=copy.js.map","import { Point } from '..';\nimport { PointPair } from '../math/geometry/pointPair';\nexport class PointPairMap {\n    constructor() {\n        this.m = new Map();\n    }\n    clear() {\n        this.m.clear();\n    }\n    get size() {\n        return this.m.size;\n    }\n    set(pp, v) {\n        this.m.set(getKey(pp), v);\n    }\n    delete(pp) {\n        this.m.delete(getKey(pp));\n    }\n    has(pp) {\n        return this.m.has(getKey(pp));\n    }\n    getPP(p, q) {\n        return this.get(new PointPair(p, q));\n    }\n    get(pp) {\n        return this.m.get(getKey(pp));\n    }\n    *keys() {\n        for (const sKey of this.m.keys()) {\n            const pp = getPP(sKey);\n            yield pp;\n        }\n    }\n    *[Symbol.iterator]() {\n        for (const [x, t] of this.m) {\n            yield [getPP(x), t];\n        }\n    }\n    *values() {\n        yield* this.m.values();\n    }\n}\nfunction getPP(sKey) {\n    const pointString = sKey.split(' ');\n    const firstS = pointString[0];\n    const secondS = pointString[1];\n    // Remove the parentheses and split by comma\n    let parts = firstS.split(',');\n    // Convert the parts to numbers\n    const first = new Point(Number(parts[0]), Number(parts[1]));\n    parts = secondS.split(',');\n    const second = new Point(Number(parts[0]), Number(parts[1]));\n    const pp = new PointPair(first, second);\n    return pp;\n}\nfunction getKeyPP(first, second) {\n    return [localToString(first), localToString(second)].sort().join(' ');\n}\nfunction getKey(pp) {\n    return getKeyPP(pp.first, pp.second);\n}\nfunction localToString(p) {\n    return p.x.toString() + ',' + p.y.toString();\n}\n//# sourceMappingURL=pointPairMap.js.map","// if max is an integer then returns random in the range [0, max-1]\nimport { Random } from 'reliable-random';\nlet generator;\nexport function randomInt(max) {\n    if (generator == null) {\n        generator = new Random(0, 0);\n    }\n    return generator.randint(max);\n}\nexport function initRandom(seed) {\n    generator = new Random(seed, 0);\n}\nexport function random() {\n    if (generator == null) {\n        generator = new Random(0, 0);\n    }\n    return generator.random();\n}\n//# sourceMappingURL=random.js.map","import { PointPair } from '../math/geometry/pointPair';\nimport { PointSet } from './PointSet';\nexport function substractSets(a, b) {\n    const ret = new Set();\n    for (const u of a) {\n        if (!b.has(u))\n            ret.add(u);\n    }\n    return ret;\n}\nexport function substractPointSets(a, b) {\n    const ret = new PointSet();\n    for (const u of a) {\n        if (!b.has(u))\n            ret.add(u);\n    }\n    return ret;\n}\nexport function uniteSets(a, b) {\n    const ret = new Set(a);\n    for (const v of b) {\n        ret.add(v);\n    }\n    return ret;\n}\nexport function addRange(array, addedIterable) {\n    for (const t of addedIterable)\n        array.push(t);\n}\nexport function setIntersection(a, b) {\n    const ret = new Set();\n    if (a.size < b.size) {\n        for (const t of a) {\n            if (b.has(t))\n                ret.add(t);\n        }\n    }\n    else {\n        for (const t of b) {\n            if (a.has(t))\n                ret.add(t);\n        }\n    }\n    return ret;\n}\nexport function setIntersectionOfArray(arr) {\n    if (arr.length === 0)\n        return new Set();\n    let ret = arr[0];\n    for (let i = 1; i < arr.length; i++) {\n        ret = setIntersection(ret, arr[i]);\n    }\n    return ret;\n}\nexport function insertRange(collection, addedArray) {\n    for (const t of addedArray)\n        collection.add(t);\n}\nexport function setsAreEqual(a, b) {\n    if (a.size !== b.size)\n        return false;\n    for (const u of a)\n        if (!b.has(u))\n            return false;\n    return true;\n}\n/** return the concatenated array of items */\nexport function flattenArray(arr, callback) {\n    const ret = [];\n    for (const f of arr) {\n        for (const u of callback(f))\n            ret.push(u);\n    }\n    return ret;\n}\n/** adds val to map.get(key) if the key exists, otherwise creates the key pair and\n * executes the former instruction\n */\nexport function addToMapOfSets(map, key, val) {\n    let s = map.get(key);\n    if (!s) {\n        s = new Set();\n        map.set(key, s);\n    }\n    s.add(val);\n}\nexport function addToMapOfArrays(map, key, val) {\n    let s = map.get(key);\n    if (!s) {\n        s = new Array();\n        map.set(key, s);\n    }\n    s.push(val);\n}\nexport function addToPointPairMap(map, key, val) {\n    let s = map.get(key);\n    if (!s) {\n        s = new Set();\n        map.set(key, s);\n    }\n    s.add(val);\n}\nexport function addToPointMapTuple(map, key, val) {\n    addToPointPairMap(map, new PointPair(key[0], key[1]), val);\n}\nexport function removeFromPointPairMap(map, key, val) {\n    const s = map.get(key);\n    if (s)\n        s.delete(val);\n}\nexport function removeFromPointPairMapTuple(map, key, val) {\n    removeFromPointPairMap(map, new PointPair(key[0], key[1]), val);\n}\nexport function removeFromArray(arr, OverlapRemovalNode) {\n    const i = arr.findIndex((a) => a === OverlapRemovalNode);\n    if (i >= 0) {\n        arr.splice(i, 1);\n    }\n}\n//# sourceMappingURL=setOperations.js.map","export var ArrowTypeEnum;\n(function (ArrowTypeEnum) {\n    ArrowTypeEnum[ArrowTypeEnum[\"normal\"] = 0] = \"normal\";\n    ArrowTypeEnum[ArrowTypeEnum[\"inv\"] = 1] = \"inv\";\n    ArrowTypeEnum[ArrowTypeEnum[\"dot\"] = 2] = \"dot\";\n    ArrowTypeEnum[ArrowTypeEnum[\"invdot\"] = 3] = \"invdot\";\n    ArrowTypeEnum[ArrowTypeEnum[\"odot\"] = 4] = \"odot\";\n    ArrowTypeEnum[ArrowTypeEnum[\"invodot\"] = 5] = \"invodot\";\n    ArrowTypeEnum[ArrowTypeEnum[\"none\"] = 6] = \"none\";\n    ArrowTypeEnum[ArrowTypeEnum[\"tee\"] = 7] = \"tee\";\n    ArrowTypeEnum[ArrowTypeEnum[\"empty\"] = 8] = \"empty\";\n    ArrowTypeEnum[ArrowTypeEnum[\"invempty\"] = 9] = \"invempty\";\n    ArrowTypeEnum[ArrowTypeEnum[\"diamond\"] = 10] = \"diamond\";\n    ArrowTypeEnum[ArrowTypeEnum[\"odiamond\"] = 11] = \"odiamond\";\n    ArrowTypeEnum[ArrowTypeEnum[\"ediamond\"] = 12] = \"ediamond\";\n    ArrowTypeEnum[ArrowTypeEnum[\"crow\"] = 13] = \"crow\";\n    ArrowTypeEnum[ArrowTypeEnum[\"box\"] = 14] = \"box\";\n    ArrowTypeEnum[ArrowTypeEnum[\"obox\"] = 15] = \"obox\";\n    ArrowTypeEnum[ArrowTypeEnum[\"open\"] = 16] = \"open\";\n    ArrowTypeEnum[ArrowTypeEnum[\"halfopen\"] = 17] = \"halfopen\";\n    ArrowTypeEnum[ArrowTypeEnum[\"vee\"] = 18] = \"vee\";\n})(ArrowTypeEnum || (ArrowTypeEnum = {}));\n//# sourceMappingURL=arrowTypeEnum.js.map","export class Color {\n    static mkWithKeyword(a, r, g, b, keyword) {\n        const ret = new Color(a, r, g, b);\n        ret.keyword = keyword;\n        return ret;\n    }\n    static parse(keyword) {\n        switch (keyword.toLowerCase()) {\n            case 'aliceblue':\n                return Color.AliceBlue;\n            case 'antiquewhite':\n                return Color.AntiqueWhite;\n            case 'aqua':\n                return Color.Aqua;\n            case 'aquamarine':\n                return Color.Aquamarine;\n            case 'azure':\n                return Color.Azure;\n            case 'beige':\n                return Color.Beige;\n            case 'bisque':\n                return Color.Bisque;\n            case 'black':\n                return Color.Black;\n            case 'blanchedalmond':\n                return Color.BlanchedAlmond;\n            case 'blue':\n                return Color.Blue;\n            case 'blueviolet':\n                return Color.BlueViolet;\n            case 'brown':\n                return Color.Brown;\n            case 'burlywood':\n                return Color.BurlyWood;\n            case 'cadetblue':\n                return Color.CadetBlue;\n            case 'chartreuse':\n                return Color.Chartreuse;\n            case 'chocolate':\n                return Color.Chocolate;\n            case 'coral':\n                return Color.Coral;\n            case 'cornflowerblue':\n                return Color.CornflowerBlue;\n            case 'cornsilk':\n                return Color.Cornsilk;\n            case 'crimson':\n                return Color.Crimson;\n            case 'cyan':\n                return Color.Cyan;\n            case 'darkblue':\n                return Color.DarkBlue;\n            case 'darkcyan':\n                return Color.DarkCyan;\n            case 'darkgoldenrod':\n                return Color.DarkGoldenrod;\n            case 'darkgray':\n                return Color.DarkGray;\n            case 'darkgreen':\n                return Color.DarkGreen;\n            case 'darkkhaki':\n                return Color.DarkKhaki;\n            case 'darkmagenta':\n                return Color.DarkMagenta;\n            case 'darkolivegreen':\n                return Color.DarkOliveGreen;\n            case 'darkorange':\n                return Color.DarkOrange;\n            case 'darkorchid':\n                return Color.DarkOrchid;\n            case 'darkred':\n                return Color.DarkRed;\n            case 'darksalmon':\n                return Color.DarkSalmon;\n            case 'darkseagreen':\n                return Color.DarkSeaGreen;\n            case 'darkslateblue':\n                return Color.DarkSlateBlue;\n            case 'darkslategray':\n                return Color.DarkSlateGray;\n            case 'darkturquoise':\n                return Color.DarkTurquoise;\n            case 'darkviolet':\n                return Color.DarkViolet;\n            case 'deeppink':\n                return Color.DeepPink;\n            case 'deepskyblue':\n                return Color.DeepSkyBlue;\n            case 'dimgray':\n                return Color.DimGray;\n            case 'dodgerblue':\n                return Color.DodgerBlue;\n            case 'firebrick':\n                return Color.Firebrick;\n            case 'floralwhite':\n                return Color.FloralWhite;\n            case 'forestgreen':\n                return Color.ForestGreen;\n            case 'fuchsia':\n                return Color.Fuchsia;\n            case 'gainsboro':\n                return Color.Gainsboro;\n            case 'ghostwhite':\n                return Color.GhostWhite;\n            case 'gold':\n                return Color.Gold;\n            case 'goldenrod':\n                return Color.Goldenrod;\n            case 'gray':\n                return Color.Gray;\n            case 'green':\n                return Color.Green;\n            case 'greenyellow':\n                return Color.GreenYellow;\n            case 'honeydew':\n                return Color.Honeydew;\n            case 'hotpink':\n                return Color.HotPink;\n            case 'indianred':\n                return Color.IndianRed;\n            case 'indigo':\n                return Color.Indigo;\n            case 'ivory':\n                return Color.Ivory;\n            case 'khaki':\n                return Color.Khaki;\n            case 'lavender':\n                return Color.Lavender;\n            case 'lavenderblush':\n                return Color.LavenderBlush;\n            case 'lawngreen':\n                return Color.LawnGreen;\n            case 'lemonchiffon':\n                return Color.LemonChiffon;\n            case 'lightblue':\n                return Color.LightBlue;\n            case 'lightcoral':\n                return Color.LightCoral;\n            case 'lightcyan':\n                return Color.LightCyan;\n            case 'lightgoldenrodyellow':\n                return Color.LightGoldenrodYellow;\n            case 'lightgray':\n            case 'lightgrey':\n                return Color.LightGray;\n            case 'lightgreen':\n                return Color.LightGreen;\n            case 'lightpink':\n                return Color.LightPink;\n            case 'lightsalmon':\n                return Color.LightSalmon;\n            case 'lightseagreen':\n                return Color.LightSeaGreen;\n            case 'lightskyblue':\n                return Color.LightSkyBlue;\n            case 'lightslategray':\n                return Color.LightSlateGray;\n            case 'lightsteelblue':\n                return Color.LightSteelBlue;\n            case 'lightyellow':\n                return Color.LightYellow;\n            case 'lime':\n                return Color.Lime;\n            case 'limegreen':\n                return Color.LimeGreen;\n            case 'linen':\n                return Color.Linen;\n            case 'magenta':\n                return Color.Magenta;\n            case 'maroon':\n                return Color.Maroon;\n            case 'mediumaquamarine':\n                return Color.MediumAquamarine;\n            case 'mediumblue':\n                return Color.MediumBlue;\n            case 'mediumorchid':\n                return Color.MediumOrchid;\n            case 'mediumpurple':\n                return Color.MediumPurple;\n            case 'mediumseagreen':\n                return Color.MediumSeaGreen;\n            case 'mediumslateblue':\n                return Color.MediumSlateBlue;\n            case 'mediumspringgreen':\n                return Color.MediumSpringGreen;\n            case 'mediumturquoise':\n                return Color.MediumTurquoise;\n            case 'mediumvioletred':\n                return Color.MediumVioletRed;\n            case 'midnightblue':\n                return Color.MidnightBlue;\n            case 'mintcream':\n                return Color.MintCream;\n            case 'mistyrose':\n                return Color.MistyRose;\n            case 'moccasin':\n                return Color.Moccasin;\n            case 'navajowhite':\n                return Color.NavajoWhite;\n            case 'navy':\n                return Color.Navy;\n            case 'oldlace':\n                return Color.OldLace;\n            case 'olive':\n                return Color.Olive;\n            case 'olivedrab':\n                return Color.OliveDrab;\n            case 'orange':\n                return Color.Orange;\n            case 'orangered':\n                return Color.OrangeRed;\n            case 'orchid':\n                return Color.Orchid;\n            case 'palegoldenrod':\n                return Color.PaleGoldenrod;\n            case 'palegreen':\n                return Color.PaleGreen;\n            case 'paleturquoise':\n                return Color.PaleTurquoise;\n            case 'palevioletred':\n                return Color.PaleVioletRed;\n            case 'papayawhip':\n                return Color.PapayaWhip;\n            case 'peachpuff':\n                return Color.PeachPuff;\n            case 'peru':\n                return Color.Peru;\n            case 'pink':\n                return Color.Pink;\n            case 'plum':\n                return Color.Plum;\n            case 'powderblue':\n                return Color.PowderBlue;\n            case 'purple':\n                return Color.Purple;\n            case 'red':\n                return Color.Red;\n            case 'rosybrown':\n                return Color.RosyBrown;\n            case 'royalblue':\n                return Color.RoyalBlue;\n            case 'saddlebrown':\n                return Color.SaddleBrown;\n            case 'salmon':\n                return Color.Salmon;\n            case 'sandybrown':\n                return Color.SandyBrown;\n            case 'seagreen':\n                return Color.SeaGreen;\n            case 'seashell':\n                return Color.SeaShell;\n            case 'sienna':\n                return Color.Sienna;\n            case 'silver':\n                return Color.Silver;\n            case 'skyblue':\n                return Color.SkyBlue;\n            case 'slateblue':\n                return Color.SlateBlue;\n            case 'slategray':\n                return Color.SlateGray;\n            case 'snow':\n                return Color.Snow;\n            case 'springgreen':\n                return Color.SpringGreen;\n            case 'steelblue':\n                return Color.SteelBlue;\n            case 'tan':\n                return Color.Tan;\n            case 'teal':\n                return Color.Teal;\n            case 'thistle':\n                return Color.Thistle;\n            case 'tomato':\n                return Color.Tomato;\n            case 'transparent':\n                return Color.Transparent;\n            case 'turquoise':\n                return Color.Turquoise;\n            case 'violet':\n                return Color.Violet;\n            case 'wheat':\n                return Color.Wheat;\n            case 'white':\n                return Color.White;\n            case 'whitesmoke':\n                return Color.WhiteSmoke;\n            case 'yellow':\n                return Color.Yellow;\n            case 'yellowgreen':\n                return Color.YellowGreen;\n            default:\n                return undefined;\n        }\n    }\n    get keyword() {\n        return this.keyword_;\n    }\n    set keyword(value) {\n        this.keyword_ = value;\n    }\n    // constructor with alpha and red, green, bluee components\n    constructor(a, r, g, b) {\n        this.a = a;\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n    // opaque color\n    static mkRGB(r, g, b) {\n        return new Color(255, r, g, b);\n    }\n    /**  The color opaqueness: changes from 0 to 255 */\n    get A() {\n        return this.a;\n    }\n    set A(value) {\n        this.a = value;\n    }\n    /** The red component: changes form 0 to 255 */\n    get R() {\n        return this.r;\n    }\n    /** The red component: changes form 0 to 255 */\n    set R(value) {\n        this.r = value;\n    }\n    /** The green component: changes form 0 to 255 */\n    get G() {\n        return this.g;\n    }\n    /** The red component: changes form 0 to 255 */\n    set G(value) {\n        this.g = value;\n    }\n    /** The blue component: changes form 0 to 255 */\n    get B() {\n        return this.b;\n    }\n    /** The blue component: changes form 0 to 255 */\n    set B(value) {\n        this.b = value;\n    }\n    static Xex(i) {\n        const s = i.toString(16);\n        if (s.length === 1) {\n            return '0' + s;\n        }\n        return s.substring(s.length - 2, 2);\n    }\n    static equal(a, b) {\n        return a.a === b.a && a.r === b.r && a.b === b.b && a.g === b.g;\n    }\n    // !=\n    toString() {\n        return this.keyword\n            ? this.keyword\n            : '\"#' + Color.Xex(this.R) + Color.Xex(this.G) + Color.Xex(this.B) + (this.A === 255 ? '' : Color.Xex(this.A)) + '\"';\n    }\n    //\n    static get AliceBlue() {\n        return Color.mkWithKeyword(255, 240, 248, 255, 'aliceblue');\n    }\n    //\n    static get AntiqueWhite() {\n        return Color.mkWithKeyword(255, 250, 235, 215, 'antiquewhite');\n    }\n    //\n    static get Aqua() {\n        return Color.mkWithKeyword(255, 0, 255, 255, 'aqua');\n    }\n    //\n    static get Aquamarine() {\n        return Color.mkWithKeyword(255, 127, 255, 212, 'aquamarine');\n    }\n    //\n    static get Azure() {\n        return Color.mkWithKeyword(255, 240, 255, 255, 'azure');\n    }\n    //\n    static get Beige() {\n        return Color.mkWithKeyword(255, 245, 245, 220, 'beige');\n    }\n    //\n    static get Bisque() {\n        return Color.mkWithKeyword(255, 255, 228, 196, 'bisque');\n    }\n    //\n    static get Black() {\n        return Color.mkWithKeyword(255, 0, 0, 0, 'black');\n    }\n    //\n    static get BlanchedAlmond() {\n        return Color.mkWithKeyword(255, 255, 235, 205, 'blanchedalmond');\n    }\n    //\n    static get Blue() {\n        return Color.mkWithKeyword(255, 0, 0, 255, 'blue');\n    }\n    //\n    static get BlueViolet() {\n        return Color.mkWithKeyword(255, 138, 43, 226, 'blueviolet');\n    }\n    //\n    static get Brown() {\n        return Color.mkWithKeyword(255, 165, 42, 42, 'brown');\n    }\n    //\n    static get BurlyWood() {\n        return Color.mkWithKeyword(255, 222, 184, 135, 'burlywood');\n    }\n    //\n    static get CadetBlue() {\n        return Color.mkWithKeyword(255, 95, 158, 160, 'cadetblue');\n    }\n    //\n    static get Chartreuse() {\n        return Color.mkWithKeyword(255, 127, 255, 0, 'chartreuse');\n    }\n    //\n    static get Chocolate() {\n        return Color.mkWithKeyword(255, 210, 105, 30, 'chocolate');\n    }\n    //\n    static get Coral() {\n        return Color.mkWithKeyword(255, 255, 127, 80, 'coral');\n    }\n    //\n    static get CornflowerBlue() {\n        return Color.mkWithKeyword(255, 100, 149, 237, 'cornflowerblue');\n    }\n    //\n    static get Cornsilk() {\n        return Color.mkWithKeyword(255, 255, 248, 220, 'cornsilk');\n    }\n    //\n    static get Crimson() {\n        return Color.mkWithKeyword(255, 220, 20, 60, 'crimson');\n    }\n    //\n    static get Cyan() {\n        return Color.mkWithKeyword(255, 0, 255, 255, 'cyan');\n    }\n    //\n    static get DarkBlue() {\n        return Color.mkWithKeyword(255, 0, 0, 139, 'darkblue');\n    }\n    //\n    static get DarkCyan() {\n        return Color.mkWithKeyword(255, 0, 139, 139, 'darkcyan');\n    }\n    //\n    static get DarkGoldenrod() {\n        return Color.mkWithKeyword(255, 184, 134, 11, 'darkgoldenrod');\n    }\n    //\n    static get DarkGray() {\n        return Color.mkWithKeyword(255, 169, 169, 169, 'darkgray');\n    }\n    //\n    static get DarkGreen() {\n        return Color.mkWithKeyword(255, 0, 100, 0, 'darkgreen');\n    }\n    //\n    static get DarkKhaki() {\n        return Color.mkWithKeyword(255, 189, 183, 107, 'darkkhaki');\n    }\n    //\n    static get DarkMagenta() {\n        return Color.mkWithKeyword(255, 139, 0, 139, 'darkmagenta');\n    }\n    //\n    static get DarkOliveGreen() {\n        return Color.mkWithKeyword(255, 85, 107, 47, 'darkolivegreen');\n    }\n    //\n    static get DarkOrange() {\n        return Color.mkWithKeyword(255, 255, 140, 0, 'darkorange');\n    }\n    //\n    static get DarkOrchid() {\n        return Color.mkWithKeyword(255, 153, 50, 204, 'darkorchid');\n    }\n    //\n    static get DarkRed() {\n        return Color.mkWithKeyword(255, 139, 0, 0, 'darkred');\n    }\n    //\n    static get DarkSalmon() {\n        return Color.mkWithKeyword(255, 233, 150, 122, 'darksalmon');\n    }\n    //\n    static get DarkSeaGreen() {\n        return Color.mkWithKeyword(255, 143, 188, 139, 'darkseagreen');\n    }\n    //\n    static get DarkSlateBlue() {\n        return Color.mkWithKeyword(255, 72, 61, 139, 'darkslateblue');\n    }\n    //\n    static get DarkSlateGray() {\n        return Color.mkWithKeyword(255, 47, 79, 79, 'darkslategray');\n    }\n    //\n    static get DarkTurquoise() {\n        return Color.mkWithKeyword(255, 0, 206, 209, 'darkturquoise');\n    }\n    //\n    static get DarkViolet() {\n        return Color.mkWithKeyword(255, 148, 0, 211, 'darkviolet');\n    }\n    //\n    static get DeepPink() {\n        return Color.mkWithKeyword(255, 255, 20, 147, 'deeppink');\n    }\n    //\n    static get DeepSkyBlue() {\n        return Color.mkWithKeyword(255, 0, 191, 255, 'deepskyblue');\n    }\n    //\n    static get DimGray() {\n        return Color.mkWithKeyword(255, 105, 105, 105, 'dimgray');\n    }\n    //\n    static get DodgerBlue() {\n        return Color.mkWithKeyword(255, 30, 144, 255, 'dodgerblue');\n    }\n    //\n    static get Firebrick() {\n        return Color.mkWithKeyword(255, 178, 34, 34, 'firebrick');\n    }\n    //\n    static get FloralWhite() {\n        return Color.mkWithKeyword(255, 255, 250, 240, 'floralwhite');\n    }\n    //\n    static get ForestGreen() {\n        return Color.mkWithKeyword(255, 34, 139, 34, 'forestgreen');\n    }\n    //\n    static get Fuchsia() {\n        return Color.mkWithKeyword(255, 255, 0, 255, 'fuchsia');\n    }\n    //\n    static get Gainsboro() {\n        return Color.mkWithKeyword(255, 220, 220, 220, 'gainsboro');\n    }\n    //\n    static get GhostWhite() {\n        return Color.mkWithKeyword(255, 248, 248, 255, 'ghostwhite');\n    }\n    //\n    static get Gold() {\n        return Color.mkWithKeyword(255, 255, 215, 0, 'gold');\n    }\n    //\n    static get Goldenrod() {\n        return Color.mkWithKeyword(255, 218, 165, 32, 'goldenrod');\n    }\n    //\n    static get Gray() {\n        return Color.mkWithKeyword(255, 128, 128, 128, 'gray');\n    }\n    //\n    static get Green() {\n        return Color.mkWithKeyword(255, 0, 128, 0, 'green');\n    }\n    //\n    static get GreenYellow() {\n        return Color.mkWithKeyword(255, 173, 255, 47, 'greenyellow');\n    }\n    //\n    static get Honeydew() {\n        return Color.mkWithKeyword(255, 240, 255, 240, 'honeydew');\n    }\n    //\n    static get HotPink() {\n        return Color.mkWithKeyword(255, 255, 105, 180, 'hotpink');\n    }\n    //\n    static get IndianRed() {\n        return Color.mkWithKeyword(255, 205, 92, 92, 'indianred');\n    }\n    //\n    static get Indigo() {\n        return Color.mkWithKeyword(255, 75, 0, 130, 'indigo');\n    }\n    //\n    static get Ivory() {\n        return Color.mkWithKeyword(255, 255, 255, 240, 'ivory');\n    }\n    //\n    static get Khaki() {\n        return Color.mkWithKeyword(255, 240, 230, 140, 'khaki');\n    }\n    //\n    static get Lavender() {\n        return Color.mkWithKeyword(255, 230, 230, 250, 'lavender');\n    }\n    //\n    static get LavenderBlush() {\n        return Color.mkWithKeyword(255, 255, 240, 245, 'lavenderblush');\n    }\n    //\n    static get LawnGreen() {\n        return Color.mkWithKeyword(255, 124, 252, 0, 'lawngreen');\n    }\n    //\n    static get LemonChiffon() {\n        return Color.mkWithKeyword(255, 255, 250, 205, 'lemonchiffon');\n    }\n    //\n    static get LightBlue() {\n        return Color.mkWithKeyword(255, 173, 216, 230, 'lightblue');\n    }\n    //\n    static get LightCoral() {\n        return Color.mkWithKeyword(255, 240, 128, 128, 'lightcoral');\n    }\n    //\n    static get LightCyan() {\n        return Color.mkWithKeyword(255, 224, 255, 255, 'lightcyan');\n    }\n    //\n    static get LightGoldenrodYellow() {\n        return Color.mkWithKeyword(255, 250, 250, 210, 'lightgoldenrodyellow');\n    }\n    //\n    static get LightGray() {\n        return Color.mkWithKeyword(255, 211, 211, 211, 'lightgray');\n    }\n    //\n    static get LightGreen() {\n        return Color.mkWithKeyword(255, 144, 238, 144, 'lightgreen');\n    }\n    //\n    static get LightPink() {\n        return Color.mkWithKeyword(255, 255, 182, 193, 'lightpink');\n    }\n    //\n    static get LightSalmon() {\n        return Color.mkWithKeyword(255, 255, 160, 122, 'lightsalmon');\n    }\n    //\n    static get LightSeaGreen() {\n        return Color.mkWithKeyword(255, 32, 178, 170, 'lightseagreen');\n    }\n    //\n    static get LightSkyBlue() {\n        return Color.mkWithKeyword(255, 135, 206, 250, 'lightskyblue');\n    }\n    //\n    static get LightSlateGray() {\n        return Color.mkWithKeyword(255, 119, 136, 153, 'lightslategray');\n    }\n    //\n    static get LightSteelBlue() {\n        return Color.mkWithKeyword(255, 176, 196, 222, 'lightsteelblue');\n    }\n    //\n    static get LightYellow() {\n        return Color.mkWithKeyword(255, 255, 255, 224, 'lightyellow');\n    }\n    //\n    static get Lime() {\n        return Color.mkWithKeyword(255, 0, 255, 0, 'lime');\n    }\n    //\n    static get LimeGreen() {\n        return Color.mkWithKeyword(255, 50, 205, 50, 'limegreen');\n    }\n    //\n    static get Linen() {\n        return Color.mkWithKeyword(255, 250, 240, 230, 'linen');\n    }\n    //\n    static get Magenta() {\n        return Color.mkWithKeyword(255, 255, 0, 255, 'magenta');\n    }\n    //\n    static get Maroon() {\n        return Color.mkWithKeyword(255, 128, 0, 0, 'maroon');\n    }\n    //\n    static get MediumAquamarine() {\n        return Color.mkWithKeyword(255, 102, 205, 170, 'mediumaquamarine');\n    }\n    //\n    static get MediumBlue() {\n        return Color.mkWithKeyword(255, 0, 0, 205, 'mediumblue');\n    }\n    //\n    static get MediumOrchid() {\n        return Color.mkWithKeyword(255, 186, 85, 211, 'mediumorchid');\n    }\n    //\n    static get MediumPurple() {\n        return Color.mkWithKeyword(255, 147, 112, 219, 'mediumpurple');\n    }\n    //\n    static get MediumSeaGreen() {\n        return Color.mkWithKeyword(255, 60, 179, 113, 'mediumseagreen');\n    }\n    //\n    static get MediumSlateBlue() {\n        return Color.mkWithKeyword(255, 123, 104, 238, 'mediumslateblue');\n    }\n    //\n    static get MediumSpringGreen() {\n        return Color.mkWithKeyword(255, 0, 250, 154, 'mediumspringgreen');\n    }\n    //\n    static get MediumTurquoise() {\n        return Color.mkWithKeyword(255, 72, 209, 204, 'mediumturquoise');\n    }\n    //\n    static get MediumVioletRed() {\n        return Color.mkWithKeyword(255, 199, 21, 133, 'mediumvioletred');\n    }\n    //\n    static get MidnightBlue() {\n        return Color.mkWithKeyword(255, 25, 25, 112, 'midnightblue');\n    }\n    //\n    static get MintCream() {\n        return Color.mkWithKeyword(255, 245, 255, 250, 'mintcream');\n    }\n    //\n    static get MistyRose() {\n        return Color.mkWithKeyword(255, 255, 228, 225, 'mistyrose');\n    }\n    //\n    static get Moccasin() {\n        return Color.mkWithKeyword(255, 255, 228, 181, 'moccasin');\n    }\n    //\n    static get NavajoWhite() {\n        return Color.mkWithKeyword(255, 255, 222, 173, 'navajowhite');\n    }\n    //\n    static get Navy() {\n        return Color.mkWithKeyword(255, 0, 0, 128, 'navy');\n    }\n    //\n    static get OldLace() {\n        return Color.mkWithKeyword(255, 253, 245, 230, 'oldlace');\n    }\n    //\n    static get Olive() {\n        return Color.mkWithKeyword(255, 128, 128, 0, 'olive');\n    }\n    //\n    static get OliveDrab() {\n        return Color.mkWithKeyword(255, 107, 142, 35, 'olivedrab');\n    }\n    //\n    static get Orange() {\n        return Color.mkWithKeyword(255, 255, 165, 0, 'orange');\n    }\n    //\n    static get OrangeRed() {\n        return Color.mkWithKeyword(255, 255, 69, 0, 'orangered');\n    }\n    //\n    static get Orchid() {\n        return Color.mkWithKeyword(255, 218, 112, 214, 'orchid');\n    }\n    //\n    static get PaleGoldenrod() {\n        return Color.mkWithKeyword(255, 238, 232, 170, 'palegoldenrod');\n    }\n    //\n    static get PaleGreen() {\n        return Color.mkWithKeyword(255, 152, 251, 152, 'palegreen');\n    }\n    //\n    static get PaleTurquoise() {\n        return Color.mkWithKeyword(255, 175, 238, 238, 'paleturquoise');\n    }\n    //\n    static get PaleVioletRed() {\n        return Color.mkWithKeyword(255, 219, 112, 147, 'palevioletred');\n    }\n    //\n    static get PapayaWhip() {\n        return Color.mkWithKeyword(255, 255, 239, 213, 'papayawhip');\n    }\n    //\n    static get PeachPuff() {\n        return Color.mkWithKeyword(255, 255, 218, 185, 'peachpuff');\n    }\n    //\n    static get Peru() {\n        return Color.mkWithKeyword(255, 205, 133, 63, 'peru');\n    }\n    //\n    static get Pink() {\n        return Color.mkWithKeyword(255, 255, 192, 203, 'pink');\n    }\n    //\n    static get Plum() {\n        return Color.mkWithKeyword(255, 221, 160, 221, 'plum');\n    }\n    //\n    static get PowderBlue() {\n        return Color.mkWithKeyword(255, 176, 224, 230, 'powderblue');\n    }\n    //\n    static get Purple() {\n        return Color.mkWithKeyword(255, 128, 0, 128, 'purple');\n    }\n    //\n    static get Red() {\n        return Color.mkWithKeyword(255, 255, 0, 0, 'red');\n    }\n    //\n    static get RosyBrown() {\n        return Color.mkWithKeyword(255, 188, 143, 143, 'rosybrown');\n    }\n    //\n    static get RoyalBlue() {\n        return Color.mkWithKeyword(255, 65, 105, 225, 'royalblue');\n    }\n    //\n    static get SaddleBrown() {\n        return Color.mkWithKeyword(255, 139, 69, 19, 'saddlebrown');\n    }\n    //\n    static get Salmon() {\n        return Color.mkWithKeyword(255, 250, 128, 114, 'salmon');\n    }\n    //\n    static get SandyBrown() {\n        return Color.mkWithKeyword(255, 244, 164, 96, 'sandybrown');\n    }\n    //\n    static get SeaGreen() {\n        return Color.mkWithKeyword(255, 46, 139, 87, 'seagreen');\n    }\n    //\n    static get SeaShell() {\n        return Color.mkWithKeyword(255, 255, 245, 238, 'seashell');\n    }\n    //\n    static get Sienna() {\n        return Color.mkWithKeyword(255, 160, 82, 45, 'sienna');\n    }\n    //\n    static get Silver() {\n        return Color.mkWithKeyword(255, 192, 192, 192, 'silver');\n    }\n    //\n    static get SkyBlue() {\n        return Color.mkWithKeyword(255, 135, 206, 235, 'skyblue');\n    }\n    //\n    static get SlateBlue() {\n        return Color.mkWithKeyword(255, 106, 90, 205, 'slateblue');\n    }\n    //\n    static get SlateGray() {\n        return Color.mkWithKeyword(255, 112, 128, 144, 'slategray');\n    }\n    //\n    static get Snow() {\n        return Color.mkWithKeyword(255, 255, 250, 250, 'snow');\n    }\n    //\n    static get SpringGreen() {\n        return Color.mkWithKeyword(255, 0, 255, 127, 'springgreen');\n    }\n    //\n    static get SteelBlue() {\n        return Color.mkWithKeyword(255, 70, 130, 180, 'steelblue');\n    }\n    //\n    static get Tan() {\n        return Color.mkWithKeyword(255, 210, 180, 140, 'tan');\n    }\n    //\n    static get Teal() {\n        return Color.mkWithKeyword(255, 0, 128, 128, 'teal');\n    }\n    //\n    static get Thistle() {\n        return Color.mkWithKeyword(255, 216, 191, 216, 'thistle');\n    }\n    //\n    static get Tomato() {\n        return Color.mkWithKeyword(255, 255, 99, 71, 'tomato');\n    }\n    //\n    static get Transparent() {\n        return Color.mkWithKeyword(0, 255, 255, 255, 'transparent');\n    }\n    //\n    static get Turquoise() {\n        return Color.mkWithKeyword(255, 64, 224, 208, 'turquoise');\n    }\n    //\n    static get Violet() {\n        return Color.mkWithKeyword(255, 238, 130, 238, 'violet');\n    }\n    //\n    static get Wheat() {\n        return Color.mkWithKeyword(255, 245, 222, 179, 'wheat');\n    }\n    //\n    static get White() {\n        return Color.mkWithKeyword(255, 255, 255, 255, 'white');\n    }\n    //\n    static get WhiteSmoke() {\n        return Color.mkWithKeyword(255, 245, 245, 245, 'whitesmoke');\n    }\n    //\n    static get Yellow() {\n        return Color.mkWithKeyword(255, 255, 255, 0, 'yellow');\n    }\n    //\n    static get YellowGreen() {\n        return Color.mkWithKeyword(255, 154, 205, 50, 'yellowgreen');\n    }\n}\n//# sourceMappingURL=color.js.map","export var DirTypeEnum;\n(function (DirTypeEnum) {\n    DirTypeEnum[DirTypeEnum[\"forward\"] = 0] = \"forward\";\n    DirTypeEnum[DirTypeEnum[\"back\"] = 1] = \"back\";\n    DirTypeEnum[DirTypeEnum[\"both\"] = 2] = \"both\";\n    DirTypeEnum[DirTypeEnum[\"none\"] = 3] = \"none\";\n})(DirTypeEnum || (DirTypeEnum = {}));\n//# sourceMappingURL=dirTypeEnum.js.map","import { ArrowTypeEnum } from './arrowTypeEnum';\nimport { DrawingObject } from './drawingObject';\nexport class DrawingEdge extends DrawingObject {\n    constructor(entity, directed) {\n        super(entity);\n        this.directed = true;\n        this.directed = directed;\n        if (directed) {\n            this.arrowhead = ArrowTypeEnum.normal;\n        }\n        else {\n            this.arrowhead = ArrowTypeEnum.none;\n        }\n        this.arrowtail = ArrowTypeEnum.none;\n    }\n    clone() {\n        const ret = new DrawingEdge(null, this.directed);\n        DrawingObject.copyValidFields(this, ret);\n        ret.directed = this.directed;\n        ret.arrowtail = this.arrowtail;\n        ret.arrowhead = this.arrowhead;\n        return ret;\n    }\n}\n//# sourceMappingURL=drawingEdge.js.map","import { Arrowhead, CurveFactory, GeomEdge, GeomGraph, GeomLabel, GeomNode, Graph, Label, Point, Rectangle, Size, SugiyamaLayoutSettings, } from '@msagl/core';\nimport { DrawingObject } from './drawingObject';\nimport { DrawingNode } from './drawingNode';\nimport { ArrowTypeEnum } from './arrowTypeEnum';\nimport { DrawingEdge } from './drawingEdge';\nimport { ShapeEnum } from './shapeEnum';\n/**\n * DrawingGraph is an attribute on Graph.\n * It keeps the attributes for nodes and edges rendering.\n *  It facilitates the geometry creation, mostly for the bounding curves of the nodes, from drawing attributes and labels\n * */\nexport class DrawingGraph extends DrawingNode {\n    constructor() {\n        super(...arguments);\n        /** this node does not belong to the graph,\n         but rather serves as a template for the other node's attributes (like filledColor, style, etc.) */\n        this.graphVisData = {\n            sameRanks: new Array(),\n            minRanks: new Array(),\n            maxRanks: new Array(),\n            sourceRanks: new Array(),\n            sinkRanks: new Array(),\n        };\n    }\n    get defaultNodeObject() {\n        return this._defaultNodeObject;\n    }\n    set defaultNodeObject(value) {\n        this._defaultNodeObject = value;\n    }\n    static getDrawingGraph(g) {\n        return DrawingObject.getDrawingObj(g);\n    }\n    get graph() {\n        return this.entity;\n    }\n    findNode(id) {\n        const gr = this.graph;\n        const n = gr.findNode(id);\n        if (n == null)\n            return null;\n        return DrawingObject.getDrawingObj(n);\n    }\n    hasDirectedEdge() {\n        for (const e of this.graph.deepEdges) {\n            const drawingEdge = DrawingObject.getDrawingObj(e);\n            if (drawingEdge.directed) {\n                return true;\n            }\n        }\n        return false;\n    }\n    createGeometry(textMeasure = (str) => {\n        if (!str)\n            return null;\n        return new Size(str.length * 8 + 8, 20);\n    }) {\n        const geomGraph = new GeomGraph(this.graph);\n        this.textMeasure = textMeasure;\n        const opts = { fontFamily: this.fontname, fontSize: this.fontsize, fontStyle: 'normal' };\n        if (this.labelText)\n            geomGraph.labelSize = textMeasure(this.labelText, opts);\n        for (const n of this.graph.nodesBreadthFirst) {\n            this.createNodeGeometry(n);\n        }\n        for (const e of this.graph.deepEdges) {\n            this.createEdgeGeometry(e);\n        }\n        if (this.rankdir) {\n            // we must have the Sugiyama scheme here\n            const ss = (geomGraph.layoutSettings = new SugiyamaLayoutSettings());\n            ss.layerDirection = this.rankdir;\n        }\n        return geomGraph;\n    }\n    createEdgeGeometry(e) {\n        // if the drawing edge is not defined, we create it as a directed edge\n        const drawingEdge = DrawingEdge.getDrawingObj(e) || new DrawingEdge(e, true);\n        const geomEdge = new GeomEdge(e);\n        if (drawingEdge.arrowhead != ArrowTypeEnum.none) {\n            geomEdge.targetArrowhead = new Arrowhead();\n        }\n        if (drawingEdge.arrowtail != ArrowTypeEnum.none) {\n            geomEdge.sourceArrowhead = new Arrowhead();\n        }\n        if (drawingEdge.labelText) {\n            const size = this.textMeasure(drawingEdge.labelText, {\n                fontSize: drawingEdge.fontsize,\n                fontFamily: drawingEdge.fontname,\n                fontStyle: 'normal',\n            });\n            const label = (e.label = new Label(e));\n            new GeomLabel(label, Rectangle.mkPP(new Point(0, 0), new Point(size.width, size.height)));\n            drawingEdge.measuredTextSize = size;\n        }\n        if (drawingEdge.penwidth) {\n            geomEdge.lineWidth = drawingEdge.penwidth;\n        }\n    }\n    curveByShape(width, height, center, drawingNode) {\n        let curve;\n        switch (drawingNode.shape) {\n            case ShapeEnum.diamond:\n                curve = CurveFactory.mkDiamond(width, height, center);\n                break;\n            case ShapeEnum.ellipse:\n                curve = CurveFactory.mkEllipse(width / 1.6, height / 1.6, center);\n                break;\n            case ShapeEnum.record:\n            case ShapeEnum.box:\n                curve = CurveFactory.mkRectangleWithRoundedCorners(width, height, drawingNode.XRadius, drawingNode.YRadius, center);\n                break;\n            case ShapeEnum.circle:\n                curve = CurveFactory.mkCircle(Math.sqrt(width * width + height * height), center);\n                break;\n            case ShapeEnum.plaintext:\n                break;\n            case ShapeEnum.point:\n                break;\n            case ShapeEnum.mdiamond:\n                break;\n            case ShapeEnum.msquare:\n                break;\n            case ShapeEnum.polygon:\n                break;\n            case ShapeEnum.doublecircle:\n                curve = CurveFactory.mkCircle(Math.sqrt(width * width + height * height) + 2 * drawingNode.penwidth, center);\n                break;\n            case ShapeEnum.house:\n                curve = CurveFactory.createHouse(width, height, center);\n                break;\n            case ShapeEnum.invhouse:\n                curve = CurveFactory.createInvertedHouse(width, height, center);\n                break;\n            case ShapeEnum.parallelogram:\n                curve = CurveFactory.createParallelogram(width, height, center);\n                break;\n            case ShapeEnum.octagon:\n                curve = CurveFactory.createOctagon(width, height, center);\n                break;\n            case ShapeEnum.tripleoctagon:\n                break;\n            case ShapeEnum.triangle:\n                break;\n            case ShapeEnum.trapezium:\n                break;\n            case ShapeEnum.drawFromGeometry:\n                break;\n            case ShapeEnum.hexagon:\n                curve = CurveFactory.createHexagon(width, height, center);\n                break;\n        }\n        return curve !== null && curve !== void 0 ? curve : CurveFactory.mkRectangleWithRoundedCorners(width, height, drawingNode.XRadius, drawingNode.YRadius, center);\n    }\n    createNodeGeometry(n, center = new Point(0, 0)) {\n        if (n instanceof Graph) {\n            const subDg = DrawingObject.getDrawingObj(n) || new DrawingGraph(n);\n            const geomGraph = new GeomGraph(n);\n            if (subDg.labelText) {\n                geomGraph.labelSize = subDg.measuredTextSize = measureTextSize(subDg, this.textMeasure);\n            }\n        }\n        else {\n            // if the drawingNode attribute is not defined, we create a new DrawingNode\n            const drawingNode = DrawingNode.getDrawingObj(n) || new DrawingNode(n);\n            let textSize = new Size(1, 1);\n            if (drawingNode.labelText) {\n                textSize = measureTextSize(drawingNode, this.textMeasure);\n            }\n            drawingNode.measuredTextSize = textSize;\n            const geomNode = new GeomNode(n);\n            const width = textSize.width + drawingNode.LabelMargin * 2;\n            const height = textSize.height + drawingNode.LabelMargin * 2;\n            geomNode.boundaryCurve = this.curveByShape(width, height, center, drawingNode);\n        }\n    }\n    measureLabelSizes(textMeasure) {\n        var _a;\n        for (const n of this.graph.nodesBreadthFirst) {\n            const dn = DrawingNode.getDrawingObj(n);\n            dn.measuredTextSize = (_a = measureTextSize(dn, textMeasure)) !== null && _a !== void 0 ? _a : new Size(1, 1);\n        }\n    }\n}\nfunction measureTextSize(drawingNode, textMeasure) {\n    if (drawingNode.labelText) {\n        return textMeasure(drawingNode.labelText, {\n            fontSize: drawingNode.fontsize,\n            fontFamily: drawingNode.fontname,\n            fontStyle: 'normal', // TODO: find in styles?\n        });\n    }\n    return null;\n}\n//# sourceMappingURL=drawingGraph.js.map","import { DrawingObject } from './drawingObject';\nimport { Color } from './color';\nimport { ShapeEnum } from './shapeEnum';\nexport class DrawingNode extends DrawingObject {\n    clone() {\n        throw new Error('Method not implemented.');\n    }\n    get Padding() {\n        return this.padding;\n    }\n    set Padding(value) {\n        this.padding = Math.max(0, value);\n        // //RaiseVisualsChangedEvent(this, null);\n    }\n    // x radius of the rectangle box\n    get XRadius() {\n        return this.xRad;\n    }\n    set XRadius(value) {\n        this.xRad = value;\n        //RaiseVisualsChangedEvent(this, null);\n    }\n    // y radius of the rectangle box\n    get YRadius() {\n        return this.yRad;\n    }\n    set YRadius(value) {\n        this.yRad = value;\n    }\n    // the default fill color\n    static get DefaultFillColor() {\n        return DrawingNode.defaultFillColor;\n    }\n    static set DefaultFillColor(value) {\n        DrawingNode.defaultFillColor = value;\n    }\n    get ShapeEnum() {\n        return this.shape;\n    }\n    set ShapeEnum(value) {\n        this.shape = value;\n        //RaiseVisualsChangedEvent(this, null);\n    }\n    // the node label margin\n    get LabelMargin() {\n        return this.labelMargin;\n    }\n    set LabelMargin(value) {\n        this.labelMargin = value;\n        //RaiseVisualsChangedEvent(this, null);\n    }\n    constructor(n) {\n        super(n);\n        this.shape = ShapeEnum.box;\n        this.padding = 2;\n        this.xRad = 3;\n        this.yRad = 3;\n        this.labelMargin = 1;\n        // the non adgjacent edges should avoid being closer to the node than Padding\n        this.labelWidthToHeightRatio = 1;\n        if (n != null) {\n            this.labelText = n.id;\n        }\n    }\n    // the label width to height ratio.\n    get LabelWidthToHeightRatio() {\n        return this.labelWidthToHeightRatio;\n    }\n    set LabelWidthToHeightRatio(value) {\n        this.labelWidthToHeightRatio = value;\n    }\n    get node() {\n        return this.entity;\n    }\n    get id() {\n        return this.node ? this.node.id : '';\n    }\n}\nDrawingNode.defaultFillColor = Color.LightGray;\n//# sourceMappingURL=drawingNode.js.map","import { Color } from './color';\nimport { Attribute, AttributeRegistry } from '@msagl/core';\n/** DrawingObject ment to be an attribute on an Entity, with some additional information necessery for rendering. Many fields of this class support of Dot language */\nexport class DrawingObject extends Attribute {\n    rebind(e) {\n        this.entity = e;\n        this.bind(AttributeRegistry.DrawingObjectIndex);\n    }\n    static copyValidFields(source, target) {\n        if (source == null || target == null)\n            return;\n        if (source.color && source.color.keyword && source.color.keyword.toLowerCase() !== 'black') {\n            target.color = source.color;\n        }\n        if (source.fillColor) {\n            target.fillColor = source.fillColor;\n        }\n        if (source.labelfontcolor && source.labelfontcolor.keyword.toLowerCase() !== 'black') {\n            target.labelfontcolor = source.labelfontcolor;\n        }\n        if (source.labelText != null && source.labelText !== '' && source.labelText !== source.id) {\n            target.labelText = source.labelText;\n        }\n        if (source.fontColor && source.fontColor.keyword && source.fontColor.keyword.toLowerCase() !== 'black') {\n            target.fontColor = source.fontColor;\n        }\n        if (source.styles && source.styles.length) {\n            target.styles = source.styles.map((a) => a);\n        }\n        if (source.pencolor && source.pencolor.keyword !== 'black') {\n            target.pencolor = source.pencolor;\n        }\n        if (source.penwidth && source.penwidth !== 1) {\n            target.penwidth = source.penwidth;\n        }\n        if (source.rankdir) {\n            target.rankdir = source.rankdir;\n        }\n        if (source.fontname && source.fontname !== DrawingObject.defaultLabelFontName) {\n            target.fontname = source.fontname;\n        }\n        if (source.margin) {\n            target.margin = source.margin;\n        }\n        if (source.fontsize && source.fontsize !== DrawingObject.defaultLabelFontSize) {\n            target.fontsize = source.fontsize;\n        }\n        if (source.orientation) {\n            target.orientation = source.orientation;\n        }\n        if (source.ranksep) {\n            target.ranksep = source.ranksep;\n        }\n        if (source.arrowtail) {\n            target.arrowtail = source.arrowtail;\n        }\n        if (source.arrowhead) {\n            target.arrowhead = source.arrowhead;\n        }\n        if (source.ordering) {\n            target.ordering = source.ordering;\n        }\n        if (source.bgcolor) {\n            target.bgcolor = source.bgcolor;\n        }\n        if (source.pos) {\n            target.pos = source.pos;\n        }\n        if (source.nodesep) {\n            target.nodesep = source.nodesep;\n        }\n        if (source.arrowsize) {\n            target.arrowsize = source.arrowsize;\n        }\n        if (source.samehead) {\n            target.samehead = source.samehead;\n        }\n        if (source.layersep) {\n            target.layersep = source.layersep;\n        }\n        if (source.clusterRank) {\n            target.clusterRank = source.clusterRank;\n        }\n    }\n    get labelText() {\n        return this._labelText;\n    }\n    set labelText(value) {\n        this._labelText = value;\n    }\n    get arrowhead() {\n        return this._arrowhead;\n    }\n    set arrowhead(value) {\n        this._arrowhead = value;\n    }\n    get id() {\n        return this._id;\n    }\n    set id(value) {\n        this._id = value;\n    }\n    constructor(entity) {\n        super(entity, AttributeRegistry.DrawingObjectIndex);\n        this.labelfontcolor = Color.Black;\n        this.styles = [];\n        this.penwidth = 1;\n        this.fontname = DrawingObject.defaultLabelFontName;\n        this.fontsize = DrawingObject.defaultLabelFontSize;\n    }\n    static getDrawingObj(attrCont) {\n        if (attrCont == null) {\n            return null;\n        }\n        else {\n            return attrCont.getAttr(AttributeRegistry.DrawingObjectIndex);\n        }\n    }\n}\n/** the index of the DrawingObject in the list of attributes of Entity */\n/**  This is the field from the Graph. It is used to keep the connection with the underlying graph */\n// not all attributes can be used in derived classes\nDrawingObject.defaultLabelFontName = 'Times-Roman';\nDrawingObject.defaultLabelFontSize = 12;\n//# sourceMappingURL=drawingObject.js.map","export { ArrowTypeEnum } from './arrowTypeEnum';\nexport { ShapeEnum } from './shapeEnum';\nexport { RankEnum } from './rankEnum';\nexport { StyleEnum } from './styleEnum';\nexport { DirTypeEnum } from './dirTypeEnum';\nexport { OrderingEnum } from './orderingEnum';\nexport { Color } from './color';\nexport { DrawingGraph } from './drawingGraph';\nexport { DrawingEdge } from './drawingEdge';\nexport { DrawingNode } from './drawingNode';\nexport { DrawingObject } from './drawingObject';\nexport { LayoutEditor } from './layoutEditing/layoutEditor';\nexport { InsertionMode } from './layoutEditing/iViewer';\nexport { ModifierKeysEnum } from './layoutEditing/modifierKeys';\nexport { viewerObj } from './layoutEditing/layoutEditor';\nexport { IncrementalDragger } from './layoutEditing/incrementalDragger';\n//# sourceMappingURL=index.js.map","//  pushes the nodes it got bumped to: pushes horizontally or vertically\nimport { RTree, Point, GeomGraph, insertRange } from '@msagl/core';\nimport { createRectangleNodeOnData } from '@msagl/core';\nimport { Queue } from 'queue-typescript';\nexport class BumperPusher {\n    //\n    constructor(pushedNodes, separation, pushingNodes) {\n        this.fixedNodes = new Set();\n        this.separation = separation;\n        this.rtree = new RTree(createRectangleNodeOnData(pushedNodes, (n) => this.GetPaddedBoxOfNode(n)));\n        // LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(rtree.GetAllLeaves().Select(n=>new DebugCurve(n.BoundaryCurve)));\n        this.pushingNodes = pushingNodes;\n    }\n    get FixedNodes() {\n        return this.fixedNodes;\n    }\n    GetPaddedBoxOfNode(n) {\n        const ret = n.boundaryCurve.boundingBox.clone();\n        ret.pad(this.separation / 2);\n        return ret;\n    }\n    //\n    PushNodes() {\n        this.fixedNodes.clear();\n        insertRange(this.fixedNodes, this.pushingNodes);\n        const q = new Queue();\n        for (const pn of this.pushingNodes)\n            q.enqueue(pn);\n        const ret = new Array();\n        while (q.length > 0) {\n            const n = q.dequeue();\n            for (const node of this.PushByNodeAndReportPushedAsFixed(n)) {\n                q.enqueue(node);\n                this.fixedNodes.add(node);\n                ret.push(node);\n            }\n        }\n        return ret;\n    }\n    PushByNodeAndReportPushedAsFixed(pushingNode) {\n        const ret = [];\n        const pushingNodeBox = this.GetPaddedBoxOfNode(pushingNode);\n        for (const rectNode of this.rtree.GetAllLeavesIntersectingRectangle(pushingNodeBox)) {\n            if (this.fixedNodes.has(rectNode.UserData))\n                continue;\n            if (this.PushNodeAndUpdateRTree(pushingNode, rectNode))\n                ret.push(rectNode.UserData);\n        }\n        return ret;\n    }\n    PushNodeAndUpdateRTree(pushingNode, pushed) {\n        const del = pushed.UserData.center.sub(pushingNode.center);\n        const w = pushingNode.width / 2 + pushed.UserData.width / 2;\n        const h = pushingNode.height / 2 + pushed.UserData.height / 2;\n        const absDelXBetweenCenters = Math.abs(del.x);\n        const absDelYBetweenCenters = Math.abs(del.y);\n        const xSep = absDelXBetweenCenters - w;\n        const ySep = absDelYBetweenCenters - h;\n        if (xSep >= this.separation || ySep >= this.separation)\n            return false;\n        if (absDelXBetweenCenters >= absDelYBetweenCenters) {\n            const d = del.x > 0 ? this.separation - xSep : xSep - this.separation;\n            this.PushByX(d, pushed);\n        }\n        else {\n            const d = del.y > 0 ? this.separation - ySep : ySep - this.separation;\n            this.PushByY(d, pushed);\n        }\n        this.UpdateBoundingBoxesOfPushedAndUpParents(pushed);\n        return true;\n    }\n    PushByX(del, pushed) {\n        const delPoint = new Point(del, 0);\n        BumperPusher.PushByPoint(pushed, delPoint);\n    }\n    static PushByPoint(pushed, delPoint) {\n        pushed.UserData.center = pushed.UserData.center.add(delPoint);\n        if (pushed.UserData instanceof GeomGraph) {\n            pushed.UserData.translate(delPoint);\n        }\n    }\n    PushByY(del, pushed) {\n        const delPoint = new Point(0, del);\n        BumperPusher.PushByPoint(pushed, delPoint);\n    }\n    UpdateBoundingBoxesOfPushedAndUpParents(pushed) {\n        pushed.irect = this.GetPaddedBoxOfNode(pushed.UserData);\n        let parent = pushed.Parent;\n        while (parent != null) {\n            parent.irect = parent.Left.irect.add_rect(parent.Right.irect);\n            parent = parent.Parent;\n        }\n    }\n    //\n    UpdateRTreeByChangedNodeBox(cluster, previousBox) {\n        const rectNode = this.FindClusterNode(cluster, previousBox);\n        this.UpdateBoundingBoxesOfPushedAndUpParents(rectNode);\n    }\n    FindClusterNode(cluster, previousBox) {\n        const node = this.rtree.RootNode;\n        return this.FindClusterNodeRecurse(node, cluster, previousBox);\n    }\n    FindClusterNodeRecurse(node, cluster, previousBox) {\n        if (node.UserData != null)\n            return node.UserData === cluster ? node : null;\n        let n0 = null;\n        if (previousBox.intersects(node.left.irect))\n            n0 = this.FindClusterNodeRecurse(node.Left, cluster, previousBox);\n        if (n0 != null)\n            return n0;\n        if (previousBox.intersects(node.right.irect))\n            return this.FindClusterNodeRecurse(node.Right, cluster, previousBox);\n        return null;\n    }\n    FirstPushingNode() {\n        return this.pushingNodes[0];\n    }\n}\n//# sourceMappingURL=bumperPusher.js.map","//      the editor of a graph() layout\nimport { IncrementalDragger } from './incrementalDragger';\nimport { UndoList } from './undoRedoActionsList';\nimport { RelativeFloatingPort, StraightLineEdges, EdgeLabelPlacement, RectilinearInteractiveEditor, Point, GeomEdge, GeomGraph, GeomObject, EdgeRoutingMode, Curve, LineSegment, GeomNode, SplineRouter, Arrowhead, AttributeRegistry, Assert, CornerSite, PointLocation, } from '@msagl/core';\nexport var DraggingMode;\n(function (DraggingMode) {\n    DraggingMode[DraggingMode[\"Incremental\"] = 0] = \"Incremental\";\n    DraggingMode[DraggingMode[\"Default\"] = 1] = \"Default\";\n})(DraggingMode || (DraggingMode = {}));\nexport class GeometryGraphEditor {\n    constructor() {\n        this.edgesToReroute = new Set();\n        this.objectsToDrag = new Set();\n        this.undoList = new UndoList();\n    }\n    updateDeltaForDragUndo(delta) {\n        this.undoList.updateDeltaForDragUndo(delta);\n    }\n    registerDelete(entity) {\n        this.undoList.registerDelete(entity);\n    }\n    registerAdd(entity) {\n        this.undoList.registerAdd(entity);\n    }\n    *entitiesToBeChangedByRedo() {\n        yield* this.undoList.entitiesToBeChangedByRedo();\n    }\n    *entitiesToBeChangedByUndo() {\n        yield* this.undoList.entitiesToBeChangedByUndo();\n    }\n    createUndoPoint() {\n        this.undoList.createUndoPoint();\n    }\n    /**      return the current undo action*/\n    get LayoutSettings() {\n        return this.graph().layoutSettings;\n    }\n    get EdgeRoutingMode() {\n        return this.LayoutSettings.commonSettings.edgeRoutingSettings.EdgeRoutingMode;\n    }\n    /**  returns true if \"undo\" is available */\n    get canUndo() {\n        return this.undoList.canUndo();\n    }\n    /**  returns true if \"redo\" is available*/\n    get canRedo() {\n        return this.undoList.canRedo();\n    }\n    static calculateAttachmentSegment(label) {\n        const edge = GeomObject.getGeom(label.parent.entity);\n        if (edge != null) {\n            GeometryGraphEditor.CalculateAttachedSegmentEnd(label, edge);\n            if (!Point.closeDistEps(label.attachmentSegmentEnd, label.center)) {\n                const x = Curve.intersectionOne(label.boundingBox.perimeter(), LineSegment.mkPP(label.attachmentSegmentEnd, label.center), false);\n                label.attachmentSegmentStart = x != null ? x.x : label.center;\n            }\n            else {\n                label.attachmentSegmentStart = label.center;\n            }\n        }\n    }\n    static CalculateAttachedSegmentEnd(label, edge) {\n        label.attachmentSegmentEnd = edge.curve.value(edge.curve.closestParameter(label.center));\n    }\n    /** drags elements by the delta,\n     * and return the array of entities with the changed geometry\n     *\n     */\n    drag(delta, draggingMode, lastMousePosition) {\n        if (delta.x == 0 && delta.y == 0)\n            return;\n        for (const o of this.objectsToDrag) {\n            this.registerForUndoDrag(o.entity);\n        }\n        if (this.geomEdgeWithSmoothedPolylineExposed == null) {\n            if (this.EdgeRoutingMode !== EdgeRoutingMode.Rectilinear && this.EdgeRoutingMode !== EdgeRoutingMode.RectilinearToCenter) {\n                this.dragObjectsForNonRectilinearCase(delta, draggingMode);\n            }\n            else {\n                this.DragObjectsForRectilinearCase(delta);\n            }\n        }\n        else {\n            // this.EditedEdge != null\n            this.dragPolylineCorner(lastMousePosition, delta);\n        }\n    }\n    registerForUndoDrag(entity) {\n        this.undoList.registerForUndoDrag(entity);\n    }\n    DragObjectsForRectilinearCase(delta) {\n        for (const node of this.objectsToDrag) {\n            if (node instanceof GeomNode) {\n                node.translate(delta);\n            }\n        }\n        RectilinearInteractiveEditor.CreatePortsAndRouteEdges(this.LayoutSettings.commonSettings.NodeSeparation / 3, 1, this.graph().nodesBreadthFirst, this.graph().deepEdges, this.LayoutSettings.commonSettings.edgeRoutingSettings.EdgeRoutingMode);\n        EdgeLabelPlacement.constructorG(this.graph()).run();\n        // for (const e of this.geomGraph.deepEdges) {\n        //   this.UpdateGraphBoundingBoxWithCheck(e)\n        // }\n        // for (const n of this.geomGraph.deepNodes) {\n        //   this.UpdateGraphBoundingBoxWithCheck(n)\n        // }\n        this.propagateChangesToClusterParents();\n        throw new Error('not implemented');\n    }\n    dragObjectsForNonRectilinearCase(delta, draggingMode) {\n        if (draggingMode === DraggingMode.Incremental) {\n            this.DragIncrementally(delta);\n        }\n        else if (false && //debug - not implemented yet! TODO\n            (this.EdgeRoutingMode === EdgeRoutingMode.Spline || this.EdgeRoutingMode === EdgeRoutingMode.SplineBundling)) {\n            this.DragWithSplinesOrBundles(delta);\n        }\n        else {\n            this.dragWithStraightLines(delta);\n        }\n    }\n    dragWithStraightLines(delta) {\n        for (const geomObj of this.objectsToDrag) {\n            if (geomObj instanceof GeomGraph) {\n                geomObj.deepTranslate(delta);\n            }\n            else {\n                geomObj.translate(delta);\n            }\n        }\n        this.propagateChangesToClusterParents();\n        this.routeEdgesAsStraightLines();\n    }\n    propagateChangesToClusterParents() {\n        const touchedWithChangedBorder = new Set();\n        for (const n of this.objectsToDrag) {\n            if (n instanceof GeomNode === false)\n                continue;\n            const geomNode = n;\n            for (const c of geomNode.node.getAncestors()) {\n                const gc = GeomObject.getGeom(c);\n                if (gc !== this.graph() && !this.objectsToDrag.has(gc)) {\n                    touchedWithChangedBorder.add(gc);\n                }\n            }\n        }\n        if (touchedWithChangedBorder.size > 0) {\n            for (const c of this.graph().subgraphsDepthFirst) {\n                const gc = c;\n                if (touchedWithChangedBorder.has(gc)) {\n                    const newBox = gc.getPumpedGraphWithMarginsBox();\n                    if (!newBox.equalEps(gc.boundingBox)) {\n                        this.registerForUndo(gc.entity);\n                        for (const e of gc.selfEdges()) {\n                            this.addToEdgesToReroute(e);\n                        }\n                        for (const e of gc.inEdges()) {\n                            this.addToEdgesToReroute(e);\n                        }\n                        for (const e of gc.outEdges()) {\n                            this.addToEdgesToReroute(e);\n                        }\n                        gc.boundingBox = newBox;\n                    }\n                }\n            }\n        }\n    }\n    addToEdgesToReroute(e) {\n        //    Assert.assert(!this.bothEndsInDragObjects(e))\n        this.edgesToReroute.add(e);\n    }\n    //bothEndsInDragObjects(e: GeomEdge) {\n    //  return this.objectsToDrag.has(e.source) && this.objectsToDrag.has(e.target)\n    //}\n    DragWithSplinesOrBundles(delta) {\n        for (const geomObj of this.objectsToDrag) {\n            if (geomObj instanceof GeomNode) {\n                geomObj.translate(delta);\n            }\n        }\n        this.RunSplineRouterAndPutLabels();\n    }\n    RunSplineRouterAndPutLabels() {\n        const router = SplineRouter.mk5(this.graph(), this.LayoutSettings.commonSettings.edgeRoutingSettings.Padding, this.LayoutSettings.commonSettings.edgeRoutingSettings.PolylinePadding, this.LayoutSettings.commonSettings.edgeRoutingSettings.ConeAngle, this.LayoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings);\n        router.run();\n        const elp = EdgeLabelPlacement.constructorG(this.graph());\n        elp.run();\n    }\n    registerForUndo(e) {\n        this.undoList.registerForUndo(e);\n    }\n    routeEdgesAsStraightLines() {\n        for (const edge of this.edgesToReroute) {\n            this.registerForUndo(edge.entity);\n            StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(edge);\n            if (edge.label) {\n                this.registerForUndo(edge.edge.label);\n            }\n        }\n        const ep = EdgeLabelPlacement.constructorGA(this.graph(), Array.from(this.edgesToReroute));\n        ep.run();\n    }\n    // UpdateGraphBoundingBoxWithCheck_() {\n    //   for (const node of this.graph().shallowNodes) {\n    //     // shallow or deep?\n    //     this.UpdateGraphBoundingBoxWithCheck(node)\n    //   }\n    //   for (const edge of this.graph().edges()) {\n    //     // shallow or deep?\n    //     this.UpdateGraphBoundingBoxWithCheck(edge)\n    //   }\n    // }\n    DragIncrementally(delta) {\n        if (this.incrementalDragger == null) {\n            this.InitIncrementalDragger();\n        }\n        this.incrementalDragger.Drag(delta);\n    }\n    dragPolylineCorner(lastMousePosition, delta) {\n        const site = GeometryGraphEditor.findClosestCornerForEdit(this.geomEdgeWithSmoothedPolylineExposed.smoothedPolyline, lastMousePosition);\n        site.point = site.point.add(delta);\n        if (site.prev == null) {\n            pullSiteToTheNode(this.geomEdgeWithSmoothedPolylineExposed.source, site);\n        }\n        else if (site.next == null) {\n            pullSiteToTheNode(this.geomEdgeWithSmoothedPolylineExposed.target, site);\n        }\n        GeometryGraphEditor.createCurveOnChangedPolyline(this.geomEdgeWithSmoothedPolylineExposed);\n    }\n    static dragEdgeWithSite(delta, e, site) {\n        site.point = site.point.add(delta);\n        GeometryGraphEditor.createCurveOnChangedPolyline(e);\n    }\n    static createCurveOnChangedPolyline(e) {\n        const curve = e.smoothedPolyline.createCurve();\n        if (!Arrowhead.trimSplineAndCalculateArrowheadsII(e, e.source.boundaryCurve, e.target.boundaryCurve, curve, false)) {\n            Arrowhead.createBigEnoughSpline(e);\n        }\n        e.sourcePort = new RelativeFloatingPort(() => e.source.boundaryCurve, () => e.source.center, edgeStart().sub(e.source.center));\n        e.targetPort = new RelativeFloatingPort(() => e.target.boundaryCurve, () => e.target.center, edgeEnd().sub(e.target.center));\n        function edgeStart() {\n            return e.sourceArrowhead ? e.sourceArrowhead.tipPosition : e.curve.start;\n        }\n        function edgeEnd() {\n            return e.targetArrowhead ? e.targetArrowhead.tipPosition : e.curve.end;\n        }\n    }\n    prepareForObjectDragging(markedObjects, dragMode) {\n        this.geomEdgeWithSmoothedPolylineExposed = null;\n        this.calculateObjectToDragAndEdgesToReroute(markedObjects);\n        this.undoList.createUndoPoint();\n        if (dragMode === DraggingMode.Incremental) {\n            this.InitIncrementalDragger();\n        }\n    }\n    PrepareForClusterCollapseChange(changedClusters) {\n        throw new Error('not implemented');\n        // this.InsertToListAndSetTheBoxBefore(new ClustersCollapseExpandUndoRedoAction(this.graph()))\n        // for (const iCluster of changedClusters) {\n        //   throw new Error('not implemented') // this.CurrentUndoAction.AddAffectedObject(iCluster) //\n        // }\n    }\n    InitIncrementalDragger() {\n        this.incrementalDragger = new IncrementalDragger(Array.from(this.objectsToDrag).filter((o) => o instanceof GeomNode), this.graph(), this.LayoutSettings);\n    }\n    clearDraggedSets() {\n        this.objectsToDrag.clear();\n        this.edgesToReroute.clear();\n    }\n    addToObjectsToDrag(geomObj) {\n        this.objectsToDrag.add(geomObj);\n    }\n    /** fills the fields objectsToDrag, edgesToDrag */\n    calculateObjectToDragAndEdgesToReroute(markedObjects) {\n        this.clearDraggedSets();\n        for (const geometryObject of markedObjects) {\n            this.addToObjectsToDrag(geometryObject);\n            const isEdge = geometryObject instanceof GeomEdge;\n            if (isEdge) {\n                this.addToObjectsToDrag(geometryObject.source);\n                this.addToObjectsToDrag(geometryObject.target);\n            }\n        }\n        this.removeClusterSuccessorsFromObjectsToDrag();\n        this.calculateDragSetsForEdges();\n    }\n    removeClusterSuccessorsFromObjectsToDrag() {\n        const listToRemove = new Array();\n        for (const node of this.objectsToDrag) {\n            if (this.hasAncestorInObjectsToDrag(node))\n                listToRemove.push(node);\n        }\n        for (const node of listToRemove) {\n            this.objectsToDrag.delete(node);\n        }\n    }\n    // UpdateGraphBoundingBoxWithCheck(geomObj: GeomObject) {\n    //   const bBox = geomObj.boundingBox.clone()\n    //   const leftTop = new Point(-this.geomGraph.margins.left, this.geomGraph.margins.top)\n    //   const rightBottom = new Point(-this.geomGraph.margins.right, -this.geomGraph.margins.bottom)\n    //   const bounds = this.geomGraph.boundingBox.clone()\n    //   this.GraphBoundingBoxGetsExtended ||=\n    //     bounds.addWithCheck(bBox.leftTop.add(leftTop)) || bounds.addWithCheck(bBox.rightBottom.add(rightBottom))\n    //   this.geomGraph.boundingBox = bounds\n    // }\n    calculateDragSetsForEdges() {\n        // copy this.objectsToDrag to an array because new entities might be added to it\n        for (const geomObj of Array.from(this.objectsToDrag)) {\n            if (geomObj instanceof GeomGraph) {\n                this.addGeomGraphEdgesToRerouteOrDrag(geomObj);\n            }\n            else if (geomObj instanceof GeomNode) {\n                this.addNodeEdgesToRerouteOrDrag(geomObj);\n            }\n            else if (geomObj instanceof GeomEdge && geomObj.edge.label) {\n                this.addToObjectsToDrag(geomObj.edge.label.getAttr(AttributeRegistry.GeomObjectIndex));\n            }\n        }\n    }\n    addNodeEdgesToRerouteOrDrag(node) {\n        Assert.assert(node instanceof GeomGraph == false);\n        for (const edge of node.selfEdges()) {\n            this.addToObjectsToDrag(edge);\n        }\n        for (const edge of node.inEdges()) {\n            if (this.hasSelfOrAncestorInObjectsToDrag(edge.source)) {\n                // has to drag\n                this.addToObjectsToDrag(edge);\n            }\n            else {\n                this.addToEdgesToReroute(edge);\n            }\n        }\n        for (const edge of node.outEdges()) {\n            if (this.hasSelfOrAncestorInObjectsToDrag(edge.target)) {\n                // has to drag\n                this.addToObjectsToDrag(edge);\n            }\n            else {\n                this.addToEdgesToReroute(edge);\n            }\n        }\n        if (node instanceof GeomGraph)\n            for (const n of node.nodesBreadthFirst) {\n                this.addNodeEdgesToRerouteOrDrag(n);\n            }\n    }\n    addGeomGraphEdgesToRerouteOrDrag(subg) {\n        Assert.assert(subg instanceof GeomGraph);\n        for (const edge of subg.selfEdges()) {\n            this.addToObjectsToDrag(edge);\n        }\n        for (const edge of subg.inEdges()) {\n            if (subg.isAncestor(edge.source))\n                continue;\n            if (this.hasSelfOrAncestorInObjectsToDrag(edge.source)) {\n                this.addToObjectsToDrag(edge);\n            }\n            else {\n                this.addToEdgesToReroute(edge);\n            }\n        }\n        for (const edge of subg.outEdges()) {\n            if (subg.isAncestor(edge.target))\n                continue;\n            if (this.hasSelfOrAncestorInObjectsToDrag(edge.target)) {\n                // has to drag\n                this.addToObjectsToDrag(edge);\n            }\n            else {\n                this.addToEdgesToReroute(edge);\n            }\n        }\n        for (const n of subg.nodesBreadthFirst) {\n            for (const e of n.outEdges()) {\n                const target = e.target;\n                if (subg.isAncestor(target))\n                    continue;\n                if (this.hasSelfOrAncestorInObjectsToDrag(target))\n                    this.addToObjectsToDrag(e);\n                else\n                    this.addToEdgesToReroute(e);\n            }\n            for (const e of n.inEdges()) {\n                const source = e.source;\n                if (subg.isAncestor(source))\n                    continue;\n                if (this.hasSelfOrAncestorInObjectsToDrag(source))\n                    this.addToObjectsToDrag(e);\n                else\n                    this.addToEdgesToReroute(e);\n            }\n        }\n    }\n    /** returns true iff the edge is under a cluster belonging to this.objectsToDrag */\n    hasSelfOrAncestorInObjectsToDrag(ent) {\n        while (ent) {\n            if (this.objectsToDrag.has(ent))\n                return true;\n            ent = ent.parent;\n        }\n        return false;\n    }\n    hasAncestorInObjectsToDrag(ent) {\n        ent = ent.parent;\n        while (ent) {\n            if (this.objectsToDrag.has(ent))\n                return true;\n            ent = ent.parent;\n        }\n        return false;\n    }\n    static CalculateMiddleOffsetsForMultiedge(multiedge, node, offsetsInsideOfMultiedge, nodeSeparation) {\n        const middleAngles = GeometryGraphEditor.GetMiddleAnglesOfMultiedge(multiedge, node);\n        const sortedKeys = Array.from(middleAngles.keys()).sort((a, b) => a - b);\n        const edges = sortedKeys.map(key => middleAngles.get(key)); // the edges should be sorted here\n        const separation = nodeSeparation * 6;\n        const k = edges.length / 2;\n        const even = k * 2 === edges.length;\n        let off;\n        if (even) {\n            off = -(separation / 2);\n            for (let j = k - 1; j >= 0; j--) {\n                const edge = edges[j];\n                offsetsInsideOfMultiedge.set(edge, off);\n                off -= separation + (edge.label ? edge.label.width : 0);\n            }\n            off = separation / 2;\n            for (let j = k; j < edges.length; j++) {\n                const edge = edges[j];\n                offsetsInsideOfMultiedge.set(edge, off);\n                off += separation + (edge.label ? edge.label.width : 0);\n            }\n        }\n        else {\n            off = 0;\n            for (let j = k; j >= 0; j--) {\n                const edge = edges[j];\n                offsetsInsideOfMultiedge.set(edge, off);\n                off = separation + (edge.label ? edge.label.width : 0);\n            }\n            off = separation;\n            for (let j = k + 1; j < edges.length; j++) {\n                const edge = edges[j];\n                offsetsInsideOfMultiedge.set(edge, off);\n                off += separation + (edge.label ? edge.label.width : 0);\n            }\n        }\n    }\n    static GetMiddleAnglesOfMultiedge(multiedge, node) {\n        const ret = new Map();\n        const firstEdge = multiedge[0];\n        const a = node.center;\n        const b = GeometryGraphEditor.Middle(firstEdge.curve);\n        ret.set(0, firstEdge);\n        for (let i = 1; i < multiedge.length; i++) {\n            const edge = multiedge[i];\n            const c = GeometryGraphEditor.Middle(edge.curve);\n            let angle = Point.anglePCP(b, a, c);\n            if (angle > Math.PI) {\n                angle -= Math.PI * 2;\n            }\n            ret.set(angle, edge);\n        }\n        return ret;\n    }\n    static Middle(iCurve) {\n        return iCurve.value(0.5 * iCurve.parStart + 0.5 * iCurve.parEnd);\n    }\n    static *GetMultiEdges(node) {\n        const nodeToMultiEdge = new Map();\n        for (const edge of node.outEdges()) {\n            GeometryGraphEditor.GetOrCreateListOfMultiedge(nodeToMultiEdge, edge.target).push(edge);\n        }\n        for (const edge of node.inEdges()) {\n            GeometryGraphEditor.GetOrCreateListOfMultiedge(nodeToMultiEdge, edge.source).push(edge);\n        }\n        for (const list of nodeToMultiEdge.values()) {\n            if (list.length > 1) {\n                yield list;\n            }\n        }\n    }\n    static GetOrCreateListOfMultiedge(nodeToMultiEdge, node) {\n        let ret = nodeToMultiEdge.get(node);\n        if (ret)\n            return ret;\n        nodeToMultiEdge.set(node, (ret = []));\n        return ret;\n    }\n    prepareForGeomEdgeChange(geometryEdge) {\n        Assert.assert(this.geomEdgeWithSmoothedPolylineExposed === geometryEdge);\n        this.createUndoPoint();\n        this.registerForUndo(geometryEdge.edge);\n    }\n    //      Undoes the last editing.\n    undo() {\n        this.undoList.undo();\n    }\n    // createRedoActionIfNeeded() {\n    //   const currentUndo = this.undoList.currentUndo\n    //   if (currentUndo.Next != null) return\n    //   let action: UndoRedoAction\n    //   if (currentUndo instanceof ObjectDragUndoRedoAction) {\n    //     action = new ObjectDragUndoRedoAction(currentUndo.geomGraph)\n    //   } else {\n    //     action = null\n    //     throw new Error('not implemented')\n    //   }\n    //   currentUndo.Next = action\n    //   action.Previous = currentUndo\n    //   for (const e of currentUndo.EditedObjects) {\n    //     action.addRestoreData(e, getRestoreData(e))\n    //   }\n    // }\n    //      redo the dragging\n    redo() {\n        this.undoList.redo();\n    }\n    //      clear the editor\n    clear() {\n        this.objectsToDrag = new Set();\n        this.edgesToReroute.clear();\n        this.undoList = new UndoList();\n    }\n    //      gets the enumerator pointing to the polyline corner before the point\n    static getPreviousCornerSite(edge, point) {\n        let prevSite = edge.smoothedPolyline.headSite;\n        let nextSite = prevSite.next;\n        for (; nextSite != null;) {\n            if (GeometryGraphEditor.betweenSites(prevSite, nextSite, point)) {\n                return prevSite;\n            }\n            prevSite = nextSite;\n            nextSite = nextSite.next;\n        }\n        return null;\n    }\n    static betweenSites(prevSite, nextSite, point) {\n        const par = LineSegment.closestParameterOnLineSegment(point, prevSite.point, nextSite.point);\n        return par > 0.1 && par < 0.9;\n    }\n    //      insert a polyline corner\n    insertSite(edge, point, siteBeforeInsertion) {\n        this.prepareForGeomEdgeChange(edge);\n        // creating the new site\n        const s = CornerSite.mkSiteSPS(siteBeforeInsertion, point, siteBeforeInsertion.next);\n        GeometryGraphEditor.dragEdgeWithSite(new Point(0, 0), edge, s);\n    }\n    //      deletes the polyline corner\n    deleteSite(edge, site) {\n        this.prepareForGeomEdgeChange(edge);\n        Assert.assert(this.geomEdgeWithSmoothedPolylineExposed === edge);\n        site.prev.next = site.next;\n        // removing the site from the list\n        site.next.prev = site.prev;\n        // recalculate the edge geometry  in a correct way\n        GeometryGraphEditor.dragEdgeWithSite(new Point(0, 0), edge, site.prev);\n    }\n    //      finds the polyline corner near the mouse position\n    static findClosestCornerForEdit(sp, mousePoint, minDist = Number.POSITIVE_INFINITY) {\n        if (minDist !== Number.POSITIVE_INFINITY) {\n            minDist *= minDist;\n        }\n        let site = sp.headSite;\n        let bestSite = site;\n        let dist = bestSite.point.sub(mousePoint).lengthSquared;\n        while (site.next != null) {\n            site = site.next;\n            const d = mousePoint.sub(site.point).lengthSquared;\n            if (d < dist) {\n                bestSite = site;\n                dist = d;\n            }\n        }\n        if (dist > minDist)\n            return null;\n        return bestSite;\n    }\n    ReactOnViewChange() {\n        //this.LayoutSettings.Interactor.RunOnViewChange();\n    }\n    ForgetDragging() {\n        this.incrementalDragger = null;\n    }\n}\nfunction pullSiteToTheNode(node, site) {\n    const bc = node.boundaryCurve;\n    const location = Curve.PointRelativeToCurveLocation(site.point, bc);\n    if (location != PointLocation.Outside)\n        return;\n    const ls = LineSegment.mkPP(node.center, site.point);\n    const x = Curve.intersectionOne(ls, bc, false);\n    if (x) {\n        site.point = x.x;\n    }\n}\n//# sourceMappingURL=geomGraphEditor.js.map","/**   the interface for the viewer for editing the graph layout, and the graph */\nexport var InsertionMode;\n(function (InsertionMode) {\n    InsertionMode[InsertionMode[\"Default\"] = 0] = \"Default\";\n    InsertionMode[InsertionMode[\"Node\"] = 1] = \"Node\";\n    InsertionMode[InsertionMode[\"Edge\"] = 2] = \"Edge\";\n})(InsertionMode || (InsertionMode = {}));\n//# sourceMappingURL=iViewer.js.map","import { Curve, GeomGraph, Rectangle, SplineRouter } from '@msagl/core';\nimport { BumperPusher } from './bumperPusher';\nimport { LabelFixture } from './labelFixture';\nexport class IncrementalDragger {\n    get geomGraph() {\n        return this.geomGraph_;\n    }\n    set geomGraph(value) {\n        this.geomGraph_ = value;\n    }\n    //\n    constructor(pushingNodes, graph, layoutSettings) {\n        this.listOfPushers = new Array();\n        this.labelFixtures = new Map();\n        this.geomGraph = graph;\n        this.nodeSeparation = layoutSettings.NodeSeparation;\n        this.layoutSettings = layoutSettings;\n        this.pushingNodesArray = pushingNodes;\n        // Debug.Assert((this.pushingNodesArray.All(() => {  }, (IncrementalDragger.DefaultClusterParent(n) == null ))\n        //                 || (new Set<GeomNode>(this.pushingNodesArray.Select(() => {  }, n.ClusterParent)).Count === 1)), \"dragged nodes have to belong to the same cluster\");\n        this.InitBumperPushers();\n    }\n    InitBumperPushers() {\n        if (this.pushingNodesArray.length === 0) {\n            return;\n        }\n        let gg = GeomGraph.getGeom(this.pushingNodesArray[0].node.parent);\n        let pushingArray = this.pushingNodesArray;\n        do {\n            this.listOfPushers.push(new BumperPusher(gg.shallowNodes, this.nodeSeparation, pushingArray));\n            if (gg.graph.parent) {\n                gg = GeomGraph.getGeom(gg.graph.parent);\n                pushingArray = [gg];\n            }\n            else {\n                break;\n            }\n        } while (true);\n    }\n    RunPushers() {\n        for (let i = 0; i < this.listOfPushers.length; i++) {\n            const bumperPusher = this.listOfPushers[i];\n            bumperPusher.PushNodes();\n            const cluster = bumperPusher.FirstPushingNode().node.parent;\n            if (cluster === this.geomGraph_.graph) {\n                break;\n            }\n            const sg = GeomGraph.getGeom(cluster);\n            const bbox = sg.boundingBox;\n            sg.calculateBoundsFromChildren();\n            const newBox = sg.boundingBox;\n            if (newBox.equalEps(bbox)) {\n                break;\n            }\n            this.listOfPushers[i + 1].UpdateRTreeByChangedNodeBox(sg, bbox);\n        }\n    }\n    Drag(delta) {\n        if (delta.x == null && delta.y == null)\n            return;\n        for (const n of this.pushingNodesArray) {\n            n.translate(delta);\n        }\n        this.RunPushers();\n        this.RouteChangedEdges();\n    }\n    RouteChangedEdges() {\n        this.changedEdges = this.GetChangedEdges(this.GetChangedNodes());\n        this.InitLabelFixtures(this.changedEdges);\n        const router = new SplineRouter(this.geomGraph_, this.changedEdges, this.layoutSettings.commonSettings.edgeRoutingSettings.Padding, this.layoutSettings.commonSettings.edgeRoutingSettings.PolylinePadding, this.layoutSettings.commonSettings.edgeRoutingSettings.ConeAngle, this.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings);\n        router.run();\n        this.PositionLabels(this.changedEdges);\n    }\n    PositionLabels(changedEdges) {\n        for (const edge of changedEdges) {\n            this.PositionEdgeLabel(edge);\n        }\n    }\n    PositionEdgeLabel(edge) {\n        const lf = this.labelFixtures.get(edge);\n        if (lf == null)\n            return;\n        const curve = edge.curve;\n        const lenAtLabelAttachment = curve.length * lf.RelativeLengthOnCurve;\n        const par = curve.getParameterAtLength(lenAtLabelAttachment);\n        const tang = curve.derivative(par);\n        const norm = (lf.RightSide ? tang.rotate90Cw() : tang.rotate90Ccw()).normalize().mul(lf.NormalLength);\n        edge.label.positionCenter(curve.value(par).add(norm));\n    }\n    InitLabelFixtures(edges) {\n        for (const edge of edges) {\n            this.InitLabelFixture(edge);\n        }\n    }\n    InitLabelFixture(edge) {\n        if (edge.label == null) {\n            return;\n        }\n        if (this.labelFixtures.has(edge)) {\n            return;\n        }\n        const attachmentPar = edge.curve.closestParameter(edge.label.center);\n        const curve = edge.curve;\n        const tang = curve.derivative(attachmentPar);\n        const normal = tang.rotate90Cw();\n        const fromCurveToLabel = edge.label.center.sub(curve.value(attachmentPar));\n        const fixture = new LabelFixture(curve.lengthPartial(0, attachmentPar) / curve.length, fromCurveToLabel.dot(normal) > 0, fromCurveToLabel.length);\n        this.labelFixtures.set(edge, fixture);\n    }\n    GetChangedEdges(changedNodes) {\n        const list = [];\n        const box = Rectangle.mkOnRectangles(Array.from(changedNodes).map((n) => n.boundingBox));\n        const boxPoly = box.perimeter();\n        for (const e of this.geomGraph.deepEdges) {\n            if (this.EdgeNeedsRouting(box, e, boxPoly, changedNodes)) {\n                list.push(e);\n            }\n        }\n        return list;\n    }\n    EdgeNeedsRouting(box, edge, boxPolyline, changedNodes) {\n        if (edge.curve == null) {\n            return true;\n        }\n        if (changedNodes.has(edge.source) || changedNodes.has(edge.target)) {\n            return true;\n        }\n        if (edge.source.boundingBox.intersects(box) || edge.target.boundaryCurve.boundingBox.intersects(box)) {\n            return true;\n        }\n        if (!edge.boundingBox.intersects(box)) {\n            return false;\n        }\n        return Curve.intersectionOne(boxPolyline, edge.curve, false) != null;\n    }\n    GetChangedNodes() {\n        const ret = new Set();\n        for (const p of this.listOfPushers) {\n            for (const n of p.FixedNodes)\n                ret.add(n);\n        }\n        return ret;\n    }\n}\n//# sourceMappingURL=incrementalDragger.js.map","/**  to put a label go to RelativeLengthOnCurve position, take normal accordingly to the RightSide and follow NormalLength this direction */\nexport class LabelFixture {\n    constructor(relativeLengthOnCurve, rightSide, normalLength) {\n        this.RelativeLengthOnCurve = relativeLengthOnCurve;\n        this.RightSide = rightSide;\n        this.NormalLength = normalLength;\n    }\n}\n//# sourceMappingURL=labelFixture.js.map","import { Node, Arrowhead, Assert, AttributeRegistry, Curve, Edge, EdgeLabelPlacement, EdgeRoutingMode, GeomEdge, GeomGraph, GeomNode, GeomObject, Graph, Label, LineSegment, Point, Rectangle, RectilinearInteractiveEditor, Size, SmoothedPolyline, StraightLineEdges, layoutGeomGraph, InteractiveEdgeRouter, FloatingPort, PointLocation, CurvePort, } from '@msagl/core';\nimport { DraggingMode, GeometryGraphEditor } from './geomGraphEditor';\nimport { InsertionMode } from './iViewer';\nimport { ArrowTypeEnum } from '../arrowTypeEnum';\nimport { DrawingEdge } from '../drawingEdge';\nimport { DrawingNode } from '../drawingNode';\nimport { DrawingObject } from '../drawingObject';\nimport { ModifierKeysEnum } from './modifierKeys';\nexport function viewerObj(entity) {\n    return entity.getAttr(AttributeRegistry.ViewerIndex);\n}\nfunction geomObjFromIViewerObj(obj) {\n    return GeomObject.getGeom(obj.entity);\n}\nfunction isIViewerNode(obj) {\n    return obj && obj.entity instanceof Node;\n}\nexport class LayoutEditor {\n    resizeLabel(innerText, objectWithEditedLabel) {\n        const dro = objectWithEditedLabel.getAttr(AttributeRegistry.DrawingObjectIndex);\n        dro.labelText = innerText;\n        this.viewer.invalidate(objectWithEditedLabel.getAttr(AttributeRegistry.ViewerIndex));\n    }\n    get hasEdgeInsertionPort() {\n        return this.SourcePort != null || this.TargetPort != null;\n    }\n    get insertingEdge() {\n        return this.insertionMode == InsertionMode.Edge;\n    }\n    createUndoPoint() {\n        this.geomGraphEditor.createUndoPoint();\n    }\n    registerDelete(entity) {\n        this.geomGraphEditor.registerDelete(entity);\n    }\n    registerAdd(entity) {\n        this.geomGraphEditor.registerAdd(entity);\n    }\n    /** unregister the element from everywhere */\n    forget(ent) {\n        this.dragGroup.delete(ent);\n        if (this.edgeWithSmoothedPolylineExposed === ent) {\n            this.edgeWithSmoothedPolylineExposed = null;\n        }\n    }\n    get edgeWithSmoothedPolylineExposed() {\n        return this._edgeWithSmoothedPolylineExposed;\n    }\n    set edgeWithSmoothedPolylineExposed(value) {\n        if (this._edgeWithSmoothedPolylineExposed !== value) {\n            if (this._edgeWithSmoothedPolylineExposed) {\n                this._edgeWithSmoothedPolylineExposed.selectedForEditing = false;\n            }\n        }\n        this._edgeWithSmoothedPolylineExposed = value;\n        if (value) {\n            value.selectedForEditing = true;\n            this.geomGraphEditor.geomEdgeWithSmoothedPolylineExposed = GeomEdge.getGeom(value.edge);\n        }\n        else {\n            this.geomGraphEditor.geomEdgeWithSmoothedPolylineExposed = null;\n        }\n    }\n    get ActiveDraggedObject() {\n        return this.aActiveDraggedObject;\n    }\n    set ActiveDraggedObject(value) {\n        this.aActiveDraggedObject = value;\n    }\n    get interactiveEdgeRouter() {\n        return this._interactiveEdgeRouter;\n    }\n    set interactiveEdgeRouter(value) {\n        this._interactiveEdgeRouter = value;\n    }\n    //  Constructor\n    constructor(viewerPar) {\n        this.RadiusOfPolylineCorner = 10;\n        this.geomEdge = new GeomEdge(null); // keep it to hold the geometry only\n        this.EdgeAttr = new DrawingEdge(null, true);\n        this.arrowheadLength = Arrowhead.defaultArrowheadLength;\n        this.dragGroup = new Set();\n        this.geomGraphEditor = new GeometryGraphEditor();\n        this.mouseMoveThreshold = 0.05;\n        this.sourceLoosePolylineWrap = { loosePolyline: null };\n        this.sourceOfInsertedEdgeWrap = { node: null };\n        this.sourcePortWrap = { port: null };\n        this.targetOfInsertedEdgeWrap = { node: null };\n        this.targetPortWrap = { port: null };\n        this.dragging = false;\n        this.edgeAttr = new DrawingEdge(null, true);\n        this.viewer = viewerPar;\n        this.decorateObjectForDragging = this.defaultObjectDecorator;\n        this.removeObjDraggingDecorations = this.defaultObjectDecoratorRemover;\n        this.DecorateEdgeForDragging = LayoutEditor.TheDefaultEdgeDecoratorStub;\n        this.decorateEdgeLabelForDragging = this.defaultEdgeLabelDecorator;\n        this.RemoveEdgeDraggingDecorations = LayoutEditor.TheDefaultEdgeDecoratorStub;\n        this.geomGraphEditor.graph = () => GeomGraph.getGeom(this._graph);\n    }\n    ViewerObjectUnderMouseCursorChanged(sender, e) {\n        if (this.TargetPort != null) {\n            this.viewer.RemoveTargetPortEdgeRouting();\n            this.TargetPort = null;\n        }\n    }\n    ViewChangeEventHandler(sender, e) {\n        if (this._graph == null) {\n            return;\n        }\n    }\n    /**  current graph under editing */\n    get graph() {\n        return this._graph;\n    }\n    set graph(value) {\n        this._graph = value;\n        this.geomGraphEditor.clear();\n    }\n    //  If the distance between the mouse down point and the mouse up point is greater than the threshold\n    //  then we have a mouse move. Otherwise we have a click.\n    get MouseMoveThreshold() {\n        return this.mouseMoveThreshold;\n    }\n    set MouseMoveThreshold(value) {\n        this.mouseMoveThreshold = value;\n    }\n    get DecorateEdgeForDragging() {\n        return this.decorateEdgeForDragging;\n    }\n    set DecorateEdgeForDragging(value) {\n        this.decorateEdgeForDragging = value;\n    }\n    //  a delegate to remove edge decorations\n    get RemoveEdgeDraggingDecorations() {\n        return this.removeEdgeDraggingDecorations;\n    }\n    set RemoveEdgeDraggingDecorations(value) {\n        this.removeEdgeDraggingDecorations = value;\n    }\n    get NodeInsertPredicate() {\n        return this.nodeInsertPredicate;\n    }\n    set NodeInsertPredicate(value) {\n        this.nodeInsertPredicate = value;\n    }\n    get SourceOfInsertedEdge() {\n        return this.sourceOfInsertedEdgeWrap.node;\n    }\n    set SourceOfInsertedEdge(value) {\n        this.sourceOfInsertedEdgeWrap.node = value;\n    }\n    get TargetOfInsertedEdge() {\n        return this.targetOfInsertedEdgeWrap.node;\n    }\n    set TargetOfInsertedEdge(value) {\n        this.targetOfInsertedEdgeWrap.node = value;\n    }\n    /** gets the port from the wrapper */\n    get SourcePort() {\n        return this.sourcePortWrap.port;\n    }\n    /** set the port for the wrapper */\n    set SourcePort(value) {\n        this.sourcePortWrap.port = value;\n    }\n    /** gets the port from the wrapper */\n    get TargetPort() {\n        return this.targetPortWrap.port;\n    }\n    /** sets the port for the wrapper */\n    set TargetPort(value) {\n        this.targetPortWrap.port = value;\n    }\n    //  returns true if Undo is available\n    get CanUndo() {\n        return this.geomGraphEditor.canUndo;\n    }\n    //  return true if Redo is available\n    get CanRedo() {\n        return this.geomGraphEditor.canRedo;\n    }\n    get insertionMode() {\n        if (this.viewer == null)\n            return InsertionMode.Default;\n        return this.viewer.insertionMode;\n    }\n    set insertionMode(value) {\n        if (this.viewer == null)\n            return;\n        this.viewer.insertionMode = value;\n    }\n    viewerGraphChanged() {\n        this._graph = this.viewer.graph;\n        this.geomGraphEditor.clear();\n        if (this._graph != null && GeomGraph.getGeom(this._graph) != null) {\n            this.geomGraphEditor.clear();\n        }\n        this.ActiveDraggedObject = null;\n        this.dragGroup.clear();\n        this.cleanObstacles();\n    }\n    cleanObstacles() {\n        this.interactiveEdgeRouter = null;\n        this.looseObstaclesToTheirViewerNodes = null;\n        this.SourceOfInsertedEdge = null;\n        this.TargetOfInsertedEdge = null;\n        this.SourcePort = null;\n        this.TargetPort = null;\n        this.viewer.RemoveSourcePortEdgeRouting();\n        this.viewer.RemoveTargetPortEdgeRouting();\n    }\n    RelayoutOnIsCollapsedChanged(iCluster) {\n        this.geomGraphEditor.PrepareForClusterCollapseChange([iCluster]);\n        const geomGraph = GeomGraph.getGeom(iCluster.node);\n        if (geomGraph.isCollapsed) {\n            this.CollapseCluster(iCluster.node);\n        }\n        else {\n            this.ExpandCluster(geomGraph);\n        }\n        // LayoutAlgorithmSettings.ShowGraph(viewer.Graph.GeometryGraph);\n        for (const o of this.geomGraphEditor.entitiesToBeChangedByUndo()) {\n            this.invalidate(o);\n        }\n    }\n    relayout(cluster) {\n        let parent = cluster;\n        while (parent.parent != null) {\n            parent = parent.parent;\n        }\n        layoutGeomGraph(parent); // TODO: this call relayouts everything. Try to optimize.\n        this.MakeExpandedNodesVisible(cluster.entity);\n    }\n    ExpandCluster(cluster) {\n        if (cluster == null)\n            return;\n        this.relayout(cluster);\n    }\n    MakeExpandedNodesVisible(cluster) {\n        for (const node of cluster.shallowNodes) {\n            const iviewerNode = viewerObj(node);\n            LayoutEditor.UnhideNodeEdges(node);\n            iviewerNode.isVisible = true;\n            if (node instanceof Graph) {\n                const geomGraph = node.getAttr(AttributeRegistry.GeomObjectIndex);\n                if (geomGraph.isCollapsed == false)\n                    this.MakeExpandedNodesVisible(node);\n            }\n        }\n    }\n    static UnhideNodeEdges(drn) {\n        for (const e of drn.selfEdges) {\n            const viewerObject = viewerObj(e);\n            viewerObject.isVisible = true;\n        }\n        for (const e of drn.outEdges) {\n            if (viewerObj(e.target).isVisible)\n                viewerObj(e).isVisible = true;\n        }\n        for (const e of drn.inEdges) {\n            if (viewerObj(e.source).isVisible)\n                viewerObj(e).isVisible = true;\n        }\n    }\n    CollapseCluster(graph) {\n        LayoutEditor.HideCollapsed(graph);\n        const geomCluster = GeomGraph.getGeom(graph);\n        const center = geomCluster.center;\n        geomCluster.boundingBox = Rectangle.mkSizeCenter(geomCluster.labelSize, center);\n        this.relayout(geomCluster);\n    }\n    static HideCollapsed(cluster) {\n        for (const n of cluster.shallowNodes) {\n            viewerObj(n).isVisible = false;\n            if (n instanceof Graph) {\n                if (GeomGraph.getGeom(n).isCollapsed == false)\n                    LayoutEditor.HideCollapsed(n);\n            }\n        }\n    }\n    defaultObjectDecorator(obj) {\n        if (obj.entity instanceof Label) {\n            this.decorateEdgeLabelForDragging(obj);\n            return;\n        }\n        const drawingObj = DrawingNode.getDrawingObj(obj.entity);\n        const w = drawingObj.penwidth;\n        if (!obj.unmarkedForDraggingCallback) {\n            obj.unmarkedForDraggingCallback = () => (DrawingObject.getDrawingObj(obj.entity).penwidth = w);\n        }\n        drawingObj.penwidth = Math.max(this.viewer.LineThicknessForEditing, w * 2);\n        this.invalidate(obj.entity);\n    }\n    defaultObjectDecoratorRemover(obj) {\n        const decoratorRemover = obj.unmarkedForDraggingCallback;\n        if (decoratorRemover) {\n            decoratorRemover();\n            obj.unmarkedForDraggingCallback = null;\n            this.invalidate(obj.entity);\n        }\n        const ent = obj.entity;\n        if (ent instanceof Node) {\n            for (const edge of ent.edges) {\n                this.removeObjDraggingDecorations(viewerObj(edge));\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    static TheDefaultEdgeDecoratorStub(edge) { }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    defaultEdgeLabelDecorator(label) {\n        const geomLabel = label.entity.getAttr(AttributeRegistry.GeomObjectIndex);\n        if (label.markedForDragging) {\n            GeometryGraphEditor.calculateAttachmentSegment(geomLabel);\n            label.unmarkedForDraggingCallback = () => {\n                this.invalidate(label.entity);\n            };\n        }\n        this.invalidate(label.entity);\n    }\n    static LeftButtonIsPressed(e) {\n        return (e.buttons & 1) == 1;\n    }\n    static MiddleButtonIsPressed(e) {\n        return (e.buttons & 4) == 4;\n    }\n    static RightButtonIsPressed(e) {\n        return (e.buttons & 2) == 2;\n    }\n    MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e) {\n        if (this.mouseDownScreenPoint == null)\n            return false;\n        const x = e.clientX;\n        const y = e.clientY;\n        const dx = (this.mouseDownScreenPoint.x - x) / this.viewer.DpiX;\n        const dy = (this.mouseDownScreenPoint.y - y) / this.viewer.DpiY;\n        return Math.sqrt(dx * dx + dy * dy) > this.MouseMoveThreshold / 3;\n    }\n    analyzeLeftMouseButtonClick(e) {\n        if (this.edgeWithSmoothedPolylineExposed) {\n            this.toggleCornerForSelectedEdge();\n        }\n        else if (this.viewer.objectUnderMouseCursor) {\n            this.analyzeLeftMouseButtonClickOnObjectUnderCursor(e);\n        }\n    }\n    analyzeLeftMouseButtonClickOnObjectUnderCursor(e) {\n        const obj = this.viewer.objectUnderMouseCursor;\n        const modifierKeyIsPressed = e.ctrlKey || e.shiftKey;\n        const editableObj = obj.entity;\n        if (editableObj instanceof Edge) {\n            const geomEdge = editableObj.getAttr(AttributeRegistry.GeomObjectIndex);\n            if (geomEdge != null && this.viewer.layoutEditingEnabled) {\n                if (geomEdge.smoothedPolyline == null) {\n                    geomEdge.smoothedPolyline = LayoutEditor.CreateUnderlyingPolyline(geomEdge);\n                }\n                if (this.edgeWithSmoothedPolylineExposed !== obj)\n                    this.switchToEdgeEditing(obj);\n            }\n        }\n        else {\n            if (obj.markedForDragging) {\n                this.unselectForDragging(obj);\n            }\n            else {\n                if (!modifierKeyIsPressed) {\n                    this.unselectEverything();\n                }\n                this.selectObjectForDragging(obj);\n            }\n            this.unselectEdge();\n        }\n    }\n    toggleCornerForSelectedEdge() {\n        const corner = GeometryGraphEditor.findClosestCornerForEdit(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).smoothedPolyline, this.mouseDownGraphPoint, this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner);\n        if (corner == null) {\n            this.tryInsertCorner();\n        }\n        else {\n            if (corner.prev == null || corner.next == null) {\n                return; // ignore the source and the target corners\n            }\n            this.geomGraphEditor.createUndoPoint();\n            this.geomGraphEditor.registerForUndo(this.edgeWithSmoothedPolylineExposed.edge);\n            this.geomGraphEditor.deleteSite(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), corner);\n            this.invalidate(this.edgeWithSmoothedPolylineExposed.entity);\n        }\n    }\n    tryInsertCorner() {\n        // we have to be close enough to the curve\n        if (!this.closeEnoughToSelectedEdge()) {\n            this.unselectEdge();\n        }\n        else {\n            const a = GeometryGraphEditor.getPreviousCornerSite(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), this.mouseDownGraphPoint);\n            if (a == null)\n                return;\n            const b = a.next;\n            if (b == null)\n                return;\n            this.geomGraphEditor.insertSite(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), this.mouseDownGraphPoint, a);\n            this.invalidate(this.edgeWithSmoothedPolylineExposed.edge);\n        }\n    }\n    closeEnoughToSelectedEdge() {\n        const curve = GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).curve;\n        const t = curve.closestParameter(this.mouseDownGraphPoint);\n        return curve.value(t).sub(this.mouseDownGraphPoint).length < this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner;\n    }\n    static CreateUnderlyingPolyline(geomEdge) {\n        const ret = SmoothedPolyline.mkFromPoints(LayoutEditor.CurvePoints(geomEdge));\n        return ret;\n    }\n    static *CurvePoints(geomEdge) {\n        yield geomEdge.source.center;\n        const isCurve = geomEdge.curve instanceof Curve;\n        if (isCurve) {\n            const curve = geomEdge.curve;\n            if (curve.segs.length > 0)\n                yield curve.start;\n            for (let i = 0; i < curve.segs.length; i++)\n                yield curve.segs[i].end;\n        }\n        yield geomEdge.target.center;\n    }\n    //         static void SetCoefficientsCorrecty(SmoothedPolyline ret, ICurve curve) {\n    //            //  throw new NotImplementedException();\n    //         }\n    ModifierKeyIsPressed() {\n        const modifierKeyWasUsed = (this.viewer.modifierKeys & ModifierKeysEnum.Control) == ModifierKeysEnum.Control ||\n            (this.viewer.modifierKeys & ModifierKeysEnum.Shift) == ModifierKeysEnum.Shift;\n        return modifierKeyWasUsed;\n    }\n    switchToEdgeEditing(edge) {\n        this.unselectEverything();\n        this.edgeWithSmoothedPolylineExposed = edge;\n        edge.radiusOfPolylineCorner = this.viewer.smoothedPolylineCircleRadius;\n        this.DecorateEdgeForDragging(edge);\n        this.invalidate(edge.entity);\n    }\n    *ViewerNodes() {\n        for (const o of this.viewer.entities) {\n            if (o.entity instanceof Node)\n                yield o.entity.getAttr(AttributeRegistry.ViewerIndex);\n        }\n    }\n    selectObjectForDragging(obj) {\n        if (obj.markedForDragging == false) {\n            obj.markedForDragging = true;\n            this.dragGroup.add(obj);\n            this.decorateObjectForDragging(obj);\n        }\n    }\n    prepareToRemoveFromDragGroup(obj) {\n        obj.markedForDragging = false;\n        this.removeObjDraggingDecorations(obj);\n    }\n    unselectForDragging(obj) {\n        this.prepareToRemoveFromDragGroup(obj);\n        this.dragGroup.delete(obj);\n    }\n    unselectEverything() {\n        for (const obj of this.dragGroup) {\n            this.prepareToRemoveFromDragGroup(obj);\n        }\n        this.dragGroup.clear();\n        this.unselectEdge();\n    }\n    unselectEdge() {\n        if (this.edgeWithSmoothedPolylineExposed != null) {\n            this.edgeWithSmoothedPolylineExposed.selectedForEditing = false;\n            this.removeEdgeDraggingDecorations(this.edgeWithSmoothedPolylineExposed);\n            this.invalidate(this.edgeWithSmoothedPolylineExposed.edge);\n            this.edgeWithSmoothedPolylineExposed = null;\n        }\n    }\n    static *Edges(node) {\n        for (const edge of node.entity.edges) {\n            yield viewerObj(edge);\n        }\n    }\n    // returns true if the editor needs own the events\n    viewerMouseDown(sender, e) {\n        if (!this.viewer.layoutEditingEnabled || this.viewer.graph == null) {\n            return false;\n        }\n        this.viewer.setObjectUnderCursorFromEvent(e);\n        this.mouseDownGraphPoint = this.viewer.screenToSource(e);\n        this.mouseDownScreenPoint = new Point(e.clientX, e.clientY);\n        if (!LayoutEditor.LeftButtonIsPressed(e))\n            return false;\n        this.leftMouseButtonWasPressed = true;\n        if (this.insertingEdge) {\n            // if (this.SourceOfInsertedEdge != null && this.SourcePort != null && this.DraggingStraightLine()) {\n            //   this.viewer.StartDrawingRubberLine(this.sourcePort.port.Location)\n            // }\n            return true;\n        }\n        if (this.insertionMode == InsertionMode.Node) {\n            this.insertNode();\n            return true;\n        }\n        if (this.edgeWithSmoothedPolylineExposed != null) {\n            if (this.mouseIsInsideOfCornerSite(e)) {\n                e.preventDefault();\n            }\n            return true;\n        }\n        const obj = this.viewer.objectUnderMouseCursor;\n        if (obj && !this.viewer.objectUnderMouseCursor.hasOwnProperty('edge')) {\n            this.ActiveDraggedObject = obj;\n            return true;\n        }\n        if (this.ActiveDraggedObject != null) {\n            e.preventDefault();\n            return true;\n        }\n        return false;\n    }\n    insertNode() {\n        const id = this.findNodeID();\n        const node = new Node(id);\n        this._graph.addNode(node);\n        new DrawingNode(node); // it would create the default drawing attribute: TODO: keep a customizable attribute here\n        const vn = this.viewer.createIViewerNodeN(node, this.mouseDownGraphPoint);\n        this.viewer.addNode(vn, true);\n    }\n    findNodeID() {\n        let i = 0;\n        let id = 'node' + i.toString();\n        while (this._graph.findNode(id)) {\n            id = 'node' + ++i;\n        }\n        return id;\n    }\n    viewerMouseMove(sender, e) {\n        if (!this.viewer.layoutEditingEnabled) {\n            return;\n        }\n        if (LayoutEditor.LeftButtonIsPressed(e)) {\n            if (this.ActiveDraggedObject != null || this.activeCornerSite != null) {\n                this.drag(e);\n            }\n            else if (this.insertingEdge) {\n                //e.preventDefault()\n                //e.stopImmediatePropagation()\n                this.mouseMoveInsertEdgeLeftButtonOn(e);\n            }\n            else {\n                this.MouseMoveLiveSelectObjectsForDragging(e);\n            }\n        }\n        else if (this.insertingEdge) {\n            this.mouseMoveInsertEdgeNoButtons(e);\n        }\n    }\n    setDraggingFlag(e) {\n        if (!this.dragging && this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e)) {\n            this.dragging = true;\n        }\n    }\n    TrySetNodePort(e, nodeWrapper, portWr, loosePolylineWrapper) {\n        if (this.graph == null)\n            return;\n        Assert.assert(this.insertingEdge);\n        const mousePos = this.viewer.screenToSource(e);\n        loosePolylineWrapper.loosePolyline = null;\n        if (this.DraggingStraightLine()) {\n            nodeWrapper.node = this.setPortWhenDraggingStraightLine(portWr, mousePos);\n        }\n        else {\n            if (this.interactiveEdgeRouter == null) {\n                this.PrepareForEdgeDragging();\n            }\n            loosePolylineWrapper.loosePolyline = this.interactiveEdgeRouter.GetHitLoosePolyline(mousePos);\n            if (loosePolylineWrapper.loosePolyline != null) {\n                this.SetPortUnderLoosePolyline(mousePos, loosePolylineWrapper.loosePolyline, nodeWrapper, portWr);\n            }\n            else {\n                nodeWrapper.node = null;\n                portWr.port = null;\n            }\n        }\n        return portWr.port != null;\n    }\n    setPortWhenDraggingStraightLine(portWr, mousePos) {\n        if (isIViewerNode(this.viewer.objectUnderMouseCursor)) {\n            const viewerNode = this.viewer.objectUnderMouseCursor;\n            const t = { portParameter: 0 };\n            const geomNode = geomObjFromIViewerObj(viewerNode);\n            if (this.NeedToCreateBoundaryPort(mousePos, viewerNode, t)) {\n                portWr.port = this.CreateOrUpdateCurvePort(t.portParameter, geomNode, portWr.port);\n            }\n            else if (LayoutEditor.PointIsInside(mousePos, geomNode.boundaryCurve)) {\n                portWr.port = this.CreateFloatingPort(geomNode, mousePos);\n            }\n            else {\n                portWr.port = null;\n            }\n            return viewerNode;\n        }\n        portWr.port = null;\n        return null;\n    }\n    CreateOrUpdateCurvePort(t, geomNode, port) {\n        const isCp = port instanceof CurvePort;\n        if (!isCp) {\n            return CurvePort.mk(geomNode.boundaryCurve, t);\n        }\n        const cp = port;\n        cp.parameter = t;\n        cp.curve = geomNode.boundaryCurve;\n        return port;\n    }\n    CreateFloatingPort(geomNode, location) {\n        return new FloatingPort(geomNode.boundaryCurve, location);\n    }\n    SetPortUnderLoosePolyline(mousePos, loosePoly, nodeWr, portWrap) {\n        let dist = Number.POSITIVE_INFINITY;\n        let par = 0;\n        for (const viewerNode of this.GetViewerNodesInsideOfLooseObstacle(loosePoly)) {\n            const curve = viewerNode.entity.getAttr(AttributeRegistry.GeomObjectIndex).boundaryCurve;\n            if (LayoutEditor.PointIsInside(mousePos, curve)) {\n                nodeWr.node = viewerNode;\n                this.SetPortForMousePositionInsideOfNode(mousePos, nodeWr.node, portWrap);\n                return;\n            }\n            const p = curve.closestParameter(mousePos);\n            const d = curve.value(p).sub(mousePos).length;\n            if (d < dist) {\n                par = p;\n                dist = d;\n                nodeWr.node = viewerNode;\n            }\n        }\n        portWrap.port = this.CreateOrUpdateCurvePort(par, geomObjFromIViewerObj(nodeWr.node), portWrap.port);\n    }\n    GetViewerNodesInsideOfLooseObstacle(loosePoly) {\n        if (this.looseObstaclesToTheirViewerNodes == null) {\n            this.InitLooseObstaclesToViewerNodeMap();\n        }\n        const ret = this.looseObstaclesToTheirViewerNodes.get(loosePoly);\n        return ret;\n    }\n    InitLooseObstaclesToViewerNodeMap() {\n        this.looseObstaclesToTheirViewerNodes = new Map();\n        for (const viewerNode of this.ViewerNodes()) {\n            const loosePoly = this.interactiveEdgeRouter.GetHitLoosePolyline(geomObjFromIViewerObj(viewerNode).center);\n            let loosePolyNodes = this.looseObstaclesToTheirViewerNodes.get(loosePoly);\n            if (loosePolyNodes == undefined) {\n                this.looseObstaclesToTheirViewerNodes.set(loosePoly, (loosePolyNodes = new Array()));\n            }\n            loosePolyNodes.push(viewerNode);\n        }\n    }\n    SetPortForMousePositionInsideOfNode(mousePosition, node, port) {\n        const geomNode = geomObjFromIViewerObj(node);\n        const t = { portParameter: 0 };\n        if (this.NeedToCreateBoundaryPort(mousePosition, node, t)) {\n            port.port = this.CreateOrUpdateCurvePort(t.portParameter, geomNode, port.port);\n        }\n        else {\n            port.port = this.CreateFloatingPort(geomNode, mousePosition);\n        }\n    }\n    static PointIsInside(point, iCurve) {\n        return Curve.PointRelativeToCurveLocation(point, iCurve) == PointLocation.Inside;\n    }\n    NeedToCreateBoundaryPort(mousePoint, node, t) {\n        const drawingNode = node.entity.getAttr(AttributeRegistry.DrawingObjectIndex);\n        const curve = geomObjFromIViewerObj(node).boundaryCurve;\n        t.portParameter = curve.closestParameter(mousePoint);\n        const pointOnCurve = curve.value(t.portParameter);\n        const length = mousePoint.sub(pointOnCurve).length;\n        if (length <= this.viewer.smoothedPolylineCircleRadius * 2 + drawingNode.penwidth / 2) {\n            this.TryToSnapToTheSegmentEnd(t, curve, pointOnCurve);\n            return true;\n        }\n        return false;\n    }\n    TryToSnapToTheSegmentEnd(t, c, pointOnCurve) {\n        if (c instanceof Curve) {\n            const sipar = c.getSegIndexParam(t.portParameter);\n            const segPar = sipar.par;\n            const seg = c.segs[sipar.segIndex];\n            if (segPar - seg.parStart < seg.parEnd - segPar) {\n                if (seg.start.sub(pointOnCurve).length < this.viewer.smoothedPolylineCircleRadius * 2) {\n                    t.portParameter -= segPar - seg.parStart;\n                }\n                else if (seg.end.sub(pointOnCurve).length < this.viewer.smoothedPolylineCircleRadius * 2) {\n                    t.portParameter += +(seg.parEnd - segPar);\n                }\n            }\n        }\n    }\n    drag(e) {\n        if (!this.dragging) {\n            if (this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e)) {\n                this.prepareFirstTimeDragging();\n            }\n            else {\n                // the mouse has not moved enough\n                return;\n            }\n        }\n        const currentDragPoint = this.viewer.screenToSource(e);\n        this.handleTheMouseCursorOutOfTheBoundingBox(currentDragPoint);\n        this.geomGraphEditor.drag(currentDragPoint.sub(this._lastDragPoint), this.GetDraggingMode(), this._lastDragPoint);\n        for (const affectedObject of this.geomGraphEditor.entitiesToBeChangedByUndo()) {\n            this.invalidate(affectedObject);\n        }\n        e.stopPropagation();\n        this._lastDragPoint = currentDragPoint;\n    }\n    prepareFirstTimeDragging() {\n        this.dragging = true;\n        // first time we are in dragging\n        if (this.activeCornerSite != null) {\n            this.geomGraphEditor.prepareForGeomEdgeChange(this.edgeWithSmoothedPolylineExposed.edge.getAttr(AttributeRegistry.GeomObjectIndex));\n        }\n        else if (this.ActiveDraggedObject != null) {\n            this.unselectEdge();\n            if (!this.ActiveDraggedObject.markedForDragging) {\n                this.unselectEverything();\n            }\n            this.prepareForDragging();\n        }\n        this._lastDragPoint = this.mouseDownGraphPoint;\n    }\n    handleTheMouseCursorOutOfTheBoundingBox(currentDragPoint) {\n        const w = this.viewer.smoothedPolylineCircleRadius; // some rather small but still visible distance on the screen\n        const mousePointerBox = Rectangle.mkSizeCenter(new Size(w, w), currentDragPoint);\n        const g = GeomGraph.getGeom(this._graph);\n        if (!g.boundingBox.containsRect(mousePointerBox)) {\n            this.geomGraphEditor.registerForUndo(this._graph);\n            g.boundingBox = g.boundingBox.addRec(mousePointerBox);\n            this.invalidate(this._graph);\n        }\n    }\n    prepareForDragging() {\n        this.selectObjectForDragging(this.ActiveDraggedObject);\n        this.geomGraphEditor.prepareForObjectDragging(this.DraggedGeomObjects(), this.GetDraggingMode());\n        //  const currentUndoRedo = this.undoAction\n        // for (const g of this.geomGraphEditor.objectsToDrag) {\n        //   currentUndoRedo.AddAffectedObject(g.entity.getAttr(AttributeRegistry.ViewerIndex))\n        //   currentUndoRedo.AddRestoreData(g.entity, getRestoreData(g.entity))\n        // }\n    }\n    GetDraggingMode() {\n        const incremental = (this.viewer.modifierKeys & ModifierKeysEnum.Shift) == ModifierKeysEnum.Shift || this.viewer.IncrementalDraggingModeAlways;\n        return incremental ? DraggingMode.Incremental : DraggingMode.Default;\n    }\n    static RouteEdgesRectilinearly(viewer) {\n        const geomGraph = viewer.graph.getAttr(AttributeRegistry.GeomObjectIndex);\n        const settings = geomGraph.layoutSettings;\n        RectilinearInteractiveEditor.CreatePortsAndRouteEdges(settings.commonSettings.NodeSeparation / 3, 1, geomGraph.nodesBreadthFirst, geomGraph.deepEdges, settings.commonSettings.edgeRoutingSettings.EdgeRoutingMode);\n        const labelPlacer = EdgeLabelPlacement.constructorG(geomGraph);\n        labelPlacer.run();\n    }\n    *DraggedGeomObjects() {\n        // restrict the dragged elements to be under the same cluster\n        const activeObjCluster = LayoutEditor.GetActiveObjectCluster(this.ActiveDraggedObject);\n        for (const draggObj of this.dragGroup) {\n            if (LayoutEditor.GetActiveObjectCluster(draggObj) == activeObjCluster) {\n                yield GeomObject.getGeom(draggObj.entity);\n            }\n        }\n    }\n    static GetActiveObjectCluster(viewerObject) {\n        return viewerObject.entity.parent;\n    }\n    viewerMouseUp(sender, args) {\n        if (args.defaultPrevented) {\n            return;\n        }\n        if (!this.viewer.layoutEditingEnabled) {\n            return;\n        }\n        this.handleMouseUpOnLayoutEnabled(args);\n    }\n    handleMouseUpOnLayoutEnabled(args) {\n        const click = !this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(args);\n        if (click && this.leftMouseButtonWasPressed) {\n            if (this.viewer.objectUnderMouseCursor != null || this.edgeWithSmoothedPolylineExposed != null) {\n                this.analyzeLeftMouseButtonClick(args);\n                args.preventDefault();\n            }\n            else {\n                this.unselectEverything();\n            }\n        }\n        else if (this.dragging) {\n            if (!this.insertingEdge) {\n                this.geomGraphEditor.updateDeltaForDragUndo(this.mouseDownGraphPoint.sub(this._lastDragPoint));\n                this.interactiveEdgeRouter = null;\n                this.looseObstaclesToTheirViewerNodes = null;\n            }\n            else {\n                this.InsertEdgeOnMouseUp();\n            }\n            const gg = GeomGraph.getGeom(this._graph);\n            const newBox = gg.getPumpedGraphWithMarginsBox();\n            if (!newBox.equal(gg.boundingBox)) {\n                this.geomGraphEditor.registerForUndo(this._graph);\n                gg.boundingBox = newBox;\n                this.invalidate(this._graph);\n                args.preventDefault();\n            }\n        }\n        this.dragging = false;\n        this.geomGraphEditor.ForgetDragging();\n        this.activeCornerSite = null;\n        this.ActiveDraggedObject = null;\n        this.leftMouseButtonWasPressed = false;\n        if (this.TargetPort != null) {\n            this.viewer.RemoveTargetPortEdgeRouting();\n        }\n        if (this.SourcePort != null) {\n            this.viewer.RemoveSourcePortEdgeRouting();\n        }\n        this.TargetOfInsertedEdge = null;\n        this.SourceOfInsertedEdge = null;\n        this.TargetPort = null;\n        this.SourcePort = null;\n    }\n    InsertEdgeOnMouseUp() {\n        this.viewer.stopDrawingRubberEdge();\n        if (this.TargetPort != null) {\n            const e = this.FinishRoutingEdge();\n            this.addEdgeToTheViewer(e);\n        }\n        this.interactiveEdgeRouter.Clean();\n    }\n    addEdgeToTheViewer(e) {\n        const vEdge = this.viewer.createEdgeWithGivenGeometry(e);\n        this.viewer.addEdge(vEdge, true);\n    }\n    mkArrowhead() {\n        const arr = new Arrowhead();\n        arr.length = this.arrowheadLength;\n        return arr;\n    }\n    FinishRoutingEdge() {\n        const e = new Edge(this.sourceOfInsertedEdgeWrap.node.entity, this.targetOfInsertedEdgeWrap.node.entity);\n        e.add();\n        const edgeAttr = this.EdgeAttr.clone();\n        edgeAttr.rebind(e);\n        this.geomEdge.rebind(e);\n        this.geomEdge.sourceArrowhead = edgeAttr.arrowtail == ArrowTypeEnum.none ? null : this.mkArrowhead();\n        this.geomEdge.targetArrowhead = edgeAttr.arrowhead == ArrowTypeEnum.none ? null : this.mkArrowhead();\n        if (this.TargetOfInsertedEdge != this.SourceOfInsertedEdge) {\n            if (!(this.geomEdge.curve instanceof LineSegment)) {\n                this.interactiveEdgeRouter.TryToRemoveInflectionsAndCollinearSegments(this.geomEdge.smoothedPolyline);\n                this.interactiveEdgeRouter.SmoothenCorners(this.geomEdge.smoothedPolyline);\n                this.geomEdge.curve = this.geomEdge.smoothedPolyline.createCurve();\n            }\n            Arrowhead.trimSplineAndCalculateArrowheads(this.geomEdge, this.geomEdge.curve, true);\n        }\n        else {\n            this.geomEdge = LayoutEditor.CreateEdgeGeometryForSelfEdge(this.SourceOfInsertedEdge.entity);\n        }\n        this.viewer.RemoveSourcePortEdgeRouting();\n        this.viewer.RemoveTargetPortEdgeRouting();\n        return e;\n    }\n    static CreateEdgeGeometryForSelfEdge(node) {\n        const edge = new Edge(node, node);\n        const geomEdge = new GeomEdge(edge);\n        StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(geomEdge);\n        return geomEdge;\n    }\n    SelectEntitiesForDraggingWithRectangle(args) {\n        /*\n        const rect = Rectangle.mkPP(this.mouseDownGraphPoint, this.viewer.ScreenToSource(args))\n        for (const node of this.ViewerNodes()) {\n          if (rect.intersects(geomNodeOfIViewerNode(node).boundingBox)) {\n            this.selectObjectForDragging(node)\n          }\n        }\n        if (rect.width > 0) {\n          args.stopImmediatePropagation()\n        }*/\n    }\n    /** it also sets this.activeCornerSite */\n    mouseIsInsideOfCornerSite(e) {\n        const p = this.viewer.screenToSource(e);\n        const lw = this.edgeWithSmoothedPolylineExposed.edge.getAttr(AttributeRegistry.DrawingObjectIndex).penwidth;\n        this.activeCornerSite = GeometryGraphEditor.findClosestCornerForEdit(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).smoothedPolyline, p, this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner + lw);\n        return this.activeCornerSite !== null;\n    }\n    MouseScreenPointIsCloseEnoughToVertex(point, radius) {\n        return point.sub(this.mouseDownGraphPoint).length < radius;\n    }\n    invalidate(ent) {\n        const vo = viewerObj(ent);\n        if (!vo)\n            return;\n        if (vo.entity instanceof Label) {\n            if (vo.markedForDragging) {\n                const geomLabel = GeomObject.getGeom(vo.entity);\n                GeometryGraphEditor.calculateAttachmentSegment(geomLabel);\n            }\n        }\n        else {\n            if (vo.entity instanceof Edge) {\n                if (vo.entity.label) {\n                    this.viewer.invalidate(viewerObj(vo.entity.label));\n                }\n            }\n        }\n        this.viewer.invalidate(vo);\n        if (ent instanceof Graph) {\n            for (const n of ent.nodesBreadthFirst) {\n                this.viewer.invalidate(viewerObj(n));\n            }\n            for (const e of ent.deepEdges) {\n                this.viewer.invalidate(viewerObj(e));\n                if (e.label)\n                    this.viewer.invalidate(viewerObj(e.label));\n            }\n        }\n    }\n    /**   Undoes the editing*/\n    undo() {\n        if (this.geomGraphEditor.canUndo) {\n            const objectsToInvalidate = new Set(this.geomGraphEditor.entitiesToBeChangedByUndo());\n            this.geomGraphEditor.undo();\n            for (const o of objectsToInvalidate) {\n                const vo = viewerObj(o);\n                if (vo.markedForDragging) {\n                    this.dragGroup.add(vo);\n                }\n                else {\n                    this.dragGroup.delete(vo);\n                }\n                this.invalidate(o);\n            }\n        }\n    }\n    /**   Redo the editing*/\n    redo() {\n        if (this.geomGraphEditor.canRedo) {\n            const objectsToInvalidate = new Set(this.geomGraphEditor.entitiesToBeChangedByRedo());\n            this.geomGraphEditor.redo();\n            for (const o of objectsToInvalidate) {\n                const vo = viewerObj(o);\n                if (vo.markedForDragging) {\n                    this.dragGroup.add(vo);\n                }\n                else {\n                    this.dragGroup.delete(vo);\n                }\n                this.invalidate(o);\n            }\n        }\n    }\n    // //  Clear the editor\n    //  Clear() {\n    //     this.UnselectEverything();\n    // }\n    // //  Finds a corner to delete or insert\n    // //  <returns>null if a corner is not found</returns>\n    // // //  create a tight bounding box for the graph\n    // //  FitGraphBoundingBox(graphToFit: IViewerObject) {\n    // //     if ((graphToFit != null)) {\n    // //         this.geomGraphEditor.FitGraphBoundingBox(graphToFit, (<GeometryGraph>(graphToFit.DrawingObject.GeomObject)));\n    // //         this.invalidate();\n    // //     }\n    // // }\n    // // //\n    // //  RegisterNodeAdditionForUndo(node: IViewerNode) {\n    // //     let undoAction = new AddNodeUndoAction(this.graph, this.viewer, node);\n    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(undoAction);\n    // // }\n    // // //  registers the edge addition for undo\n    // //  RegisterEdgeAdditionForUndo(edge: IViewerEdge) {\n    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new AddEdgeUndoAction(this.viewer, edge));\n    // // }\n    // // //\n    // //  RegisterEdgeRemovalForUndo(edge: IViewerEdge) {\n    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new RemoveEdgeUndoAction(this.graph, this.viewer, edge));\n    // // }\n    // // //\n    // //  RegisterNodeForRemoval(node: IViewerNode) {\n    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new RemoveNodeUndoAction(this.viewer, node));\n    // // }\n    static RectRouting(mode) {\n        return mode == EdgeRoutingMode.Rectilinear || mode == EdgeRoutingMode.RectilinearToCenter;\n    }\n    // // EnumerateNodeBoundaryCurves(): IterableIterator<ICurve> {\n    // //     return from;\n    // //     vn;\n    // //     this.ViewerNodes();\n    // //     let GeomNode: select;\n    // //     vn.BoundaryCurve;\n    // // }\n    // //  ForgetEdgeDragging() {\n    // //     if ((this.viewer.Graph == null)) {\n    // //         return;\n    // //     }\n    // //     if (this.DraggingStraightLine()) {\n    // //         return;\n    // //     }\n    // //     if (!LayoutEditor.RectRouting(this.viewer.Graph.LayoutAlgorithmSettings.EdgeRoutingSettings.EdgeRoutingMode)) {\n    // //         InteractiveEdgeRouter = null;\n    // //         this.looseObstaclesToTheirViewerNodes = null;\n    // //     }\n    // // }\n    //  prepares for edge dragging\n    PrepareForEdgeDragging() {\n        if (this.viewer.graph == null) {\n            return;\n        }\n        if (this.DraggingStraightLine()) {\n            return;\n        }\n        const settings = GeomGraph.getGeom(this.viewer.graph).layoutSettings;\n        if (!LayoutEditor.RectRouting(settings.commonSettings.edgeRoutingSettings.EdgeRoutingMode)) {\n            if (this.interactiveEdgeRouter == null) {\n                const padding = settings.commonSettings.NodeSeparation / 3;\n                const loosePadding = 0.65 * padding;\n                this.interactiveEdgeRouter = InteractiveEdgeRouter.constructorANNN(Array.from(this._graph.nodesBreadthFirst).map((n) => GeomNode.getGeom(n).boundaryCurve), padding, loosePadding, 0);\n            }\n        }\n    }\n    // // //  insert a polyline corner at the point befor the prevCorner\n    // //  InsertPolylineCorner(point: Point, previousCorner: CornerSite) {\n    // //     this.geomGraphEditor.InsertSite(this.SelectedEdge.edge.GeometryEdge, point, previousCorner, this.SelectedEdge);\n    // //     this.invalidate(this.SelectedEdge);\n    // // }\n    // // InsertPolylineCorner() {\n    // //     this.geomGraphEditor.InsertSite(this.SelectedEdge.edge.GeometryEdge, this.mouseRightButtonDownPoint, this.cornerInfo.Item1, this.SelectedEdge);\n    // //     this.invalidate(this.SelectedEdge);\n    // // }\n    // // //  delete the polyline corner, shortcut it.\n    // //  DeleteCorner(corner: CornerSite) {\n    // //     this.geomGraphEditor.DeleteSite(this.SelectedEdge.edge.GeometryEdge, corner, this.SelectedEdge);\n    // //     this.invalidate(this.SelectedEdge);\n    // //     this.viewer.OnDragEnd([\n    // //                 this.SelectedEdge]);\n    // // }\n    // // DeleteCorner() {\n    // //     this.geomGraphEditor.DeleteSite(this.SelectedEdge.edge.GeometryEdge, this.cornerInfo.Item1, this.SelectedEdge);\n    // //     this.invalidate(this.SelectedEdge);\n    // //     this.viewer.OnDragEnd([\n    // //                 this.SelectedEdge]);\n    // // }\n    mouseMoveInsertEdgeNoButtons(e) {\n        const oldNode = this.SourceOfInsertedEdge;\n        if (this.TrySetNodePort(e, this.sourceOfInsertedEdgeWrap, this.sourcePortWrap, this.sourceLoosePolylineWrap)) {\n            this.viewer.SetSourcePortForEdgeRouting(this.sourcePortWrap.port.Location);\n        }\n        else if (oldNode != null) {\n            this.viewer.RemoveSourcePortEdgeRouting();\n        }\n    }\n    mouseMoveInsertEdgeLeftButtonOn(e) {\n        if (this.SourcePort != null) {\n            this.setDraggingFlag(e);\n            if (this.dragging) {\n                const loosePolylineWr = { loosePolyline: null };\n                if (this.TrySetNodePort(e, this.targetOfInsertedEdgeWrap, this.targetPortWrap, loosePolylineWr)) {\n                    this.viewer.setTargetPortForEdgeRouting(this.targetPortWrap.port.Location);\n                    this.drawEdgeInteractivelyToPort(loosePolylineWr.loosePolyline, this.DraggingStraightLine());\n                }\n                else {\n                    this.viewer.RemoveTargetPortEdgeRouting();\n                    this.DrawEdgeInteractivelyToLocation(e, this.DraggingStraightLine());\n                }\n            }\n            e.preventDefault();\n        }\n    }\n    MouseMoveLiveSelectObjectsForDragging(e) {\n        this.unselectEverything();\n        if (LeftMouseIsPressed(e) && (this.viewer.modifierKeys & ModifierKeysEnum.Shift) != ModifierKeysEnum.Shift) {\n            this.SelectEntitiesForDraggingWithRectangle(e);\n        }\n    }\n    DrawEdgeInteractivelyToLocation(e, straightLine) {\n        this.DrawEdgeInteractivelyToLocationP(this.viewer.screenToSource(e), straightLine);\n    }\n    DrawEdgeInteractivelyToLocationP(point, straightLine) {\n        this.geomEdge = straightLine ? this.getStraightLineEdge(point) : this.CalculateEdgeInteractivelyToLocation(point);\n        this.viewer.drawRubberEdge(this.geomEdge);\n    }\n    getStraightLineEdge(point) {\n        const g = new GeomEdge(null);\n        g.curve = LineSegment.mkPP(this.SourcePort.Location, point);\n        return g;\n    }\n    CalculateEdgeInteractivelyToLocation(location) {\n        if (this.interactiveEdgeRouter.SourcePort == null) {\n            this.interactiveEdgeRouter.SetSourcePortAndSourceLoosePolyline(this.SourcePort, this.sourceLoosePolylineWrap.loosePolyline);\n        }\n        return this.interactiveEdgeRouter.RouteEdgeToLocation(location);\n    }\n    drawEdgeInteractivelyToPort(portLoosePolyline, straightLine) {\n        this.geomEdge = straightLine\n            ? this.getStraightLineEdge(this.TargetPort.Location)\n            : this.CalculateEdgeInteractively(this.TargetPort, portLoosePolyline);\n        this.viewer.drawRubberEdge(this.geomEdge);\n    }\n    DraggingStraightLine() {\n        if (this.viewer.graph == null) {\n            return true;\n        }\n        return this.interactiveEdgeRouter != null && this.interactiveEdgeRouter.OverlapsDetected;\n    }\n    CalculateEdgeInteractively(targetPortParameter, portLoosePolyline) {\n        if (this.interactiveEdgeRouter.SourcePort == null) {\n            this.interactiveEdgeRouter.SetSourcePortAndSourceLoosePolyline(this.SourcePort, this.sourceLoosePolylineWrap.loosePolyline);\n        }\n        let curve;\n        let smoothedPolyline = null;\n        if (this.SourceOfInsertedEdge == this.TargetOfInsertedEdge) {\n            curve = LineSegment.mkPP(this.SourcePort.Location, this.TargetPort.Location);\n        }\n        else {\n            const boxedPolyline = { smoothedPolyline: null };\n            curve = this.interactiveEdgeRouter.RouteEdgeToPort(targetPortParameter, portLoosePolyline, false, boxedPolyline);\n            smoothedPolyline = boxedPolyline.smoothedPolyline;\n        }\n        const ret = new GeomEdge(null);\n        ret.curve = curve;\n        ret.smoothedPolyline = smoothedPolyline;\n        return ret;\n    }\n}\n// //  ScaleNodeAroundCenter(viewerNode: IViewerNode, scale: number) {\n// //     let nodePosition = viewerNode.node.BoundingBox.Center;\n// //     let scaleMatrix = new PlaneTransformation(scale, 0, 0, 0, scale, 0);\n// //     let translateToOrigin = new PlaneTransformation(1, 0, (nodePosition.X * -1), 0, 1, (nodePosition.Y * -1));\n// //     let translateToNode = new PlaneTransformation(1, 0, nodePosition.X, 0, 1, nodePosition.Y);\n// //     let matrix = (translateToNode\n// //                 * (scaleMatrix * translateToOrigin));\n// //     viewerNode.node.GeomNode.BoundaryCurve = viewerNode.node.GeomNode.BoundaryCurve.Transform(matrix);\n// //     this.invalidate(viewerNode);\n// //     for (let edge of viewerNode.OutEdges.Concat(viewerNode.InEdges).Concat(viewerNode.SelfEdges)) {\n// //         this.RecoverEdge(edge);\n// //     }\n// // }\n// // RecoverEdge(edge: IViewerEdge) {\n// //     let curve = edge.edge.GeometryEdge.UnderlyingPolyline.CreateCurve();\n// //     Arrowheads.TrimSplineAndCalculateArrowheads(edge.edge.GeometryEdge, curve, true, this.Graph.LayoutAlgorithmSettings.EdgeRoutingSettings.KeepOriginalSpline);\n// //     this.invalidate(edge);\n// // }\n// // //\n// //  DetachNode(node: IViewerNode) {\n// //     if ((node == null)) {\n// //         return;\n// //     }\n// //     this.decoratorRemovalsDict.Remove(node);\n// //     for (let edge of LayoutEditor.Edges(node)) {\n// //         this.RemoveObjDraggingDecorations(edge);\n// //     }\n// // }\n// }\nfunction LeftMouseIsPressed(e) {\n    return (e.buttons & 1) == 1;\n}\n//# sourceMappingURL=layoutEditor.js.map","export var ModifierKeysEnum;\n(function (ModifierKeysEnum) {\n    // No modifiers are pressed.\n    ModifierKeysEnum[ModifierKeysEnum[\"None\"] = 0] = \"None\";\n    // THE alt key\n    ModifierKeysEnum[ModifierKeysEnum[\"Alt\"] = 1] = \"Alt\";\n    // the control key\n    ModifierKeysEnum[ModifierKeysEnum[\"Control\"] = 2] = \"Control\";\n    // the shift key\n    ModifierKeysEnum[ModifierKeysEnum[\"Shift\"] = 4] = \"Shift\";\n    // the window logo key\n    ModifierKeysEnum[ModifierKeysEnum[\"Windows\"] = 8] = \"Windows\";\n})(ModifierKeysEnum || (ModifierKeysEnum = {}));\n//# sourceMappingURL=modifierKeys.js.map","import { Assert, Graph, Node, Edge, GeomObject, Label, AttributeRegistry } from '@msagl/core';\nimport { DrawingObject } from '../drawingObject';\n/** support for undo/redo functionality */\nexport class UndoRedoAction {\n    constructor() {\n        this._canUndo = true; // initially\n    }\n    updateDeltaForDragUndo(delta) {\n        const data = this.data;\n        data.delta = delta;\n    }\n    registerUndoDrag(entity) {\n        if (this.data == null) {\n            this.data = { draggedEnts: new Set(), delta: null, changeData: new Map() };\n        }\n        if ('draggedEnts' in this.data) {\n            this.data.draggedEnts.add(entity);\n        }\n    }\n    undo() {\n        Assert.assert(this.canUndo);\n        if (this.data instanceof Map) {\n            for (const [e, v] of this.data) {\n                for (const pair of v) {\n                    // prepare for redo as well\n                    pair.new = e.getAttr(registryIndexOfAttribue(pair.old)).clone();\n                    pair.old.rebind(e);\n                }\n            }\n        }\n        else if (this.data && 'deletedEnts' in this.data) {\n            for (const e of this.data.deletedEnts) {\n                restoreDeletedEntity(e);\n            }\n        }\n        else if ('insertedEnts' in this.data) {\n            for (const ent of this.data.insertedEnts) {\n                const graph = ent.parent;\n                if (ent instanceof Node) {\n                    graph.removeNode(ent);\n                }\n                else if (ent instanceof Edge) {\n                    ent.remove();\n                }\n                else {\n                    throw new Error('not implemented');\n                }\n            }\n        }\n        else if ('draggedEnts' in this.data) {\n            for (const e of this.data.draggedEnts) {\n                const geom = GeomObject.getGeom(e);\n                geom.translate(this.data.delta);\n            }\n            for (const [e, v] of this.data.changeData) {\n                for (const pair of v) {\n                    // prepare for redo as well\n                    pair.new = e.getAttr(registryIndexOfAttribue(pair.old)).clone();\n                    pair.old.rebind(e);\n                }\n            }\n        }\n        else {\n            throw new Error('not implemented');\n        }\n        this.canUndo = false;\n    }\n    redo() {\n        Assert.assert(this.canRedo);\n        if (this.data instanceof Map) {\n            for (const [e, v] of this.data) {\n                for (const pair of v) {\n                    const attr = pair.new;\n                    attr.rebind(e);\n                }\n            }\n        }\n        else if ('deletedEnts' in this.data) {\n            for (const ent of this.data.deletedEnts) {\n                if (ent instanceof Graph) {\n                    ent.removeSubgraph();\n                }\n                else if (ent instanceof Node) {\n                    const graph = ent.parent;\n                    graph.removeNode(ent);\n                }\n                else if (ent instanceof Edge) {\n                    ent.remove();\n                }\n                else if (ent instanceof Label) {\n                    const edge = ent.parent;\n                    edge.label = null;\n                }\n                else {\n                    throw new Error('unexpected type in redo');\n                }\n            }\n        }\n        else if ('draggedEnts' in this.data) {\n            const del = this.data.delta.neg();\n            for (const e of this.data.draggedEnts) {\n                const geom = GeomObject.getGeom(e);\n                geom.translate(del);\n            }\n            for (const [e, v] of this.data.changeData) {\n                for (const pair of v) {\n                    const attr = pair.new;\n                    attr.rebind(e);\n                }\n            }\n        }\n        else if ('insertedEnts' in this.data) {\n            for (const ent of this.data.insertedEnts) {\n                restoreDeletedEntity(ent);\n            }\n        }\n        else {\n            throw new Error('not implemented');\n        }\n        this.canUndo = true;\n    }\n    /** It adds an entry for the entity if the changes does not contain the entity as a key\n     *  Also, only one pair is added for each index.\n     *  'old' will be restored by undo  */\n    addOldNewPair(entity, old) {\n        if (!this.data) {\n            this.data = new Map();\n        }\n        const changesInAttributes = 'draggedEnts' in this.data ? this.data.changeData : this.data;\n        if (!changesInAttributes.has(entity)) {\n            changesInAttributes.set(entity, []);\n        }\n        const index = registryIndexOfAttribue(old);\n        const pairs = changesInAttributes.get(entity);\n        if (pairs[index] != null)\n            return;\n        pairs[index] = { old: old.clone(), new: null };\n    }\n    registerDelete(entity) {\n        if (!this.data)\n            this.data = { deletedEnts: new Set() };\n        const dd = this.data;\n        dd.deletedEnts.add(entity);\n    }\n    registerAdd(entity) {\n        if (!this.data)\n            this.data = { insertedEnts: new Set() };\n        const dd = this.data;\n        dd.insertedEnts.add(entity);\n    }\n    get canRedo() {\n        return !this._canUndo;\n    }\n    /** canUndo = true means that the relevant objects, the keys of restoreDataDictionary, have 'old' attributes set up: ready for undo\n     *  canUndo = false means that the undo has been done already:\n     */\n    get canUndo() {\n        return this._canUndo;\n    }\n    set canUndo(v) {\n        this._canUndo = v;\n    }\n    /** iterates over the affected objects */\n    *entities() {\n        if (!this.data)\n            return;\n        if (this.data instanceof Map)\n            yield* this.data.keys();\n        else if ('draggedEnts' in this.data) {\n            yield* this.data.changeData.keys();\n            yield* this.data.draggedEnts;\n        }\n        else if ('deletedEnts' in this.data)\n            yield* this.data.deletedEnts;\n        else if ('insertedEnts' in this.data)\n            yield* this.data.insertedEnts;\n        else {\n            throw new Error('not implemented');\n        }\n    }\n}\nfunction registryIndexOfAttribue(old) {\n    let index;\n    if (old instanceof GeomObject)\n        index = AttributeRegistry.GeomObjectIndex;\n    else if (old instanceof DrawingObject)\n        index = AttributeRegistry.DrawingObjectIndex;\n    else {\n        // todo: enforce type here\n        index = AttributeRegistry.ViewerIndex;\n    }\n    return index;\n}\nfunction restoreDeletedEntity(ent) {\n    if (ent instanceof Label) {\n        const edge = ent.parent;\n        edge.label = ent;\n    }\n    else if (ent instanceof Graph) {\n        const graph = ent.parent;\n        graph.addNode(ent);\n        /** reattach all the edges, that might be removed.\n         * attaching twice does not have an effect\n         */\n        for (const edge of ent.edges) {\n            edge.add();\n        }\n        for (const n of ent.nodesBreadthFirst) {\n            for (const e of n.outEdges)\n                e.add();\n            for (const e of n.inEdges)\n                e.add();\n        }\n    }\n    else if (ent instanceof Node) {\n        const graph = ent.parent;\n        graph.addNode(ent);\n    }\n    else if (ent instanceof Edge)\n        ent.add();\n}\n//# sourceMappingURL=undoRedoAction.js.map","import { Assert, AttributeRegistry } from '@msagl/core';\nimport { UndoRedoAction } from './undoRedoAction';\nexport class UndoList {\n    updateDeltaForDragUndo(delta) {\n        this.currentBridge.updateDeltaForDragUndo(delta);\n    }\n    registerForUndoDrag(entity) {\n        if (this.currentBridge == null) {\n            this.currentBridge = new UndoRedoAction();\n        }\n        this.currentBridge.registerUndoDrag(entity);\n    }\n    registerDelete(entity) {\n        if (this.currentBridge == null) {\n            this.currentBridge = new UndoRedoAction();\n        }\n        this.currentBridge.registerDelete(entity);\n    }\n    registerAdd(entity) {\n        this.createUndoPoint();\n        this.currentBridge.registerAdd(entity);\n    }\n    *entitiesToBeChangedByRedo() {\n        if (this.currentBridge == null)\n            return;\n        if (this.currentBridge.canRedo) {\n            yield* this.currentBridge.entities();\n        }\n        else if (this.currentBridge.next != null && this.currentBridge.next.canRedo) {\n            yield* this.currentBridge.next.entities();\n        }\n    }\n    *entitiesToBeChangedByUndo() {\n        if (this.currentBridge == null)\n            return;\n        if (this.currentBridge.canUndo) {\n            yield* this.currentBridge.entities();\n        }\n        else if (this.currentBridge.prev != null && this.currentBridge.prev.canUndo) {\n            yield* this.currentBridge.prev.entities();\n        }\n    }\n    /** registers some attributes of the entity for undo */\n    registerForUndo(e) {\n        if (this.currentBridge == null) {\n            this.currentBridge = new UndoRedoAction();\n        }\n        this.currentBridge.addOldNewPair(e, e.getAttr(AttributeRegistry.GeomObjectIndex));\n    }\n    canUndo() {\n        if (this.currentBridge == null)\n            return false;\n        if (this.currentBridge.canUndo)\n            return true;\n        if (this.currentBridge.prev != null && this.currentBridge.prev.canUndo)\n            return true;\n        return false;\n    }\n    canRedo() {\n        if (this.currentBridge == null)\n            return false;\n        if (this.currentBridge.canRedo)\n            return true;\n        if (this.currentBridge.next != null && this.currentBridge.next.canRedo)\n            return true;\n        return false;\n    }\n    undo() {\n        if (!this.canUndo)\n            return;\n        if (this.currentBridge.canUndo) {\n            this.currentBridge.undo();\n        }\n        else {\n            this.currentBridge.prev.undo();\n        }\n        if (this.currentBridge.prev)\n            this.currentBridge = this.currentBridge.prev;\n    }\n    redo() {\n        if (!this.canRedo)\n            return;\n        if (this.currentBridge.canRedo) {\n            this.currentBridge.redo();\n        }\n        else {\n            this.currentBridge.next.redo();\n        }\n        if (this.currentBridge.next) {\n            this.currentBridge = this.currentBridge.next;\n        }\n    }\n    /** If the current undo has not been undone, the adds the \"action\" after the currentUndo and sets currentUndo=action .\n     * Otherwise, when the currentBridge is undone, the current undo is replaced by the action.\n     * In both cases the tail of the current undo, which is reached through this.currentBridge.next, is lost.\n     */\n    createUndoPoint() {\n        const action = new UndoRedoAction();\n        if (!this.currentBridge) {\n            this.currentBridge = action;\n        }\n        else if (this.currentBridge.canUndo) {\n            this.currentBridge.next = action;\n            action.prev = this.currentBridge;\n            this.currentBridge = action;\n        }\n        else {\n            Assert.assert(this.currentBridge.canRedo);\n            // we need to discard this.currentBridge as it is undone already\n            const prev = this.currentBridge.prev;\n            if (prev) {\n                action.prev = prev;\n                prev.next = action;\n            }\n            this.currentBridge = action;\n        }\n    }\n}\n//# sourceMappingURL=undoRedoActionsList.js.map","export var OrderingEnum;\n(function (OrderingEnum) {\n    OrderingEnum[OrderingEnum[\"in\"] = 0] = \"in\";\n    OrderingEnum[OrderingEnum[\"out\"] = 1] = \"out\";\n})(OrderingEnum || (OrderingEnum = {}));\n//# sourceMappingURL=orderingEnum.js.map","export var RankEnum;\n(function (RankEnum) {\n    RankEnum[RankEnum[\"same\"] = 0] = \"same\";\n    RankEnum[RankEnum[\"min\"] = 1] = \"min\";\n    RankEnum[RankEnum[\"source\"] = 2] = \"source\";\n    RankEnum[RankEnum[\"max\"] = 3] = \"max\";\n    RankEnum[RankEnum[\"sink\"] = 4] = \"sink\";\n})(RankEnum || (RankEnum = {}));\n//# sourceMappingURL=rankEnum.js.map","export var ShapeEnum;\n(function (ShapeEnum) {\n    ShapeEnum[ShapeEnum[\"diamond\"] = 0] = \"diamond\";\n    ShapeEnum[ShapeEnum[\"ellipse\"] = 1] = \"ellipse\";\n    ShapeEnum[ShapeEnum[\"box\"] = 2] = \"box\";\n    ShapeEnum[ShapeEnum[\"circle\"] = 3] = \"circle\";\n    ShapeEnum[ShapeEnum[\"record\"] = 4] = \"record\";\n    ShapeEnum[ShapeEnum[\"plaintext\"] = 5] = \"plaintext\";\n    ShapeEnum[ShapeEnum[\"point\"] = 6] = \"point\";\n    ShapeEnum[ShapeEnum[\"mdiamond\"] = 7] = \"mdiamond\";\n    ShapeEnum[ShapeEnum[\"msquare\"] = 8] = \"msquare\";\n    ShapeEnum[ShapeEnum[\"polygon\"] = 9] = \"polygon\";\n    ShapeEnum[ShapeEnum[\"doublecircle\"] = 10] = \"doublecircle\";\n    ShapeEnum[ShapeEnum[\"house\"] = 11] = \"house\";\n    ShapeEnum[ShapeEnum[\"invhouse\"] = 12] = \"invhouse\";\n    ShapeEnum[ShapeEnum[\"parallelogram\"] = 13] = \"parallelogram\";\n    ShapeEnum[ShapeEnum[\"octagon\"] = 14] = \"octagon\";\n    ShapeEnum[ShapeEnum[\"tripleoctagon\"] = 15] = \"tripleoctagon\";\n    ShapeEnum[ShapeEnum[\"triangle\"] = 16] = \"triangle\";\n    ShapeEnum[ShapeEnum[\"trapezium\"] = 17] = \"trapezium\";\n    ShapeEnum[ShapeEnum[\"drawFromGeometry\"] = 18] = \"drawFromGeometry\";\n    ShapeEnum[ShapeEnum[\"hexagon\"] = 19] = \"hexagon\";\n})(ShapeEnum || (ShapeEnum = {}));\n//# sourceMappingURL=shapeEnum.js.map","export var StyleEnum;\n(function (StyleEnum) {\n    //The default style - solid.\n    StyleEnum[StyleEnum[\"none\"] = 0] = \"none\";\n    StyleEnum[StyleEnum[\"dashed\"] = 1] = \"dashed\";\n    StyleEnum[StyleEnum[\"solid\"] = 2] = \"solid\";\n    StyleEnum[StyleEnum[\"invis\"] = 3] = \"invis\";\n    StyleEnum[StyleEnum[\"bold\"] = 4] = \"bold\";\n    StyleEnum[StyleEnum[\"filled\"] = 5] = \"filled\";\n    StyleEnum[StyleEnum[\"diagonals\"] = 6] = \"diagonals\";\n    StyleEnum[StyleEnum[\"dotted\"] = 7] = \"dotted\";\n    StyleEnum[StyleEnum[\"rounded\"] = 8] = \"rounded\";\n})(StyleEnum || (StyleEnum = {}));\n//# sourceMappingURL=styleEnum.js.map","import parse from 'dotparser';\nimport { Edge, Graph, LayerDirectionEnum, Node, setNewParent, GeomObject, GeomNode, GeomEdge, Point, GeomGraph, iCurveToJSON, JSONToICurve, Rectangle, Arrowhead, GeomLabel, Label, AttributeRegistry, Assert, } from '@msagl/core';\nimport { ArrowTypeEnum, DrawingEdge, DrawingGraph, DrawingNode, DrawingObject, RankEnum, ShapeEnum, StyleEnum, OrderingEnum, DirTypeEnum, } from '@msagl/drawing';\nimport { parseColor } from './utils';\nfunction parseAttrOnDrawingObj(entity, drawingObj, o) {\n    for (const attr of o.attr_list) {\n        if (attr.type === 'attr') {\n            const str = attr.eq;\n            switch (attr.id) {\n                // geometry attributes\n                case 'edgeCurve':\n                    {\n                        const geom = getOrCreateGeomObj(entity);\n                        const json = JSON.parse(str);\n                        geom.curve = JSONToICurve(json);\n                    }\n                    break;\n                case 'graphBoundingBox':\n                    {\n                        const geom = getOrCreateGeomObj(entity);\n                        const json = JSON.parse(str);\n                        geom.boundingBox = new Rectangle(json);\n                    }\n                    break;\n                case 'boundaryCurve':\n                    {\n                        const geom = getOrCreateGeomObj(entity);\n                        const json = JSON.parse(str);\n                        const curve = JSONToICurve(json);\n                        if (geom instanceof GeomGraph) {\n                            geom.boundingBox = curve.boundingBox;\n                        }\n                        else {\n                            geom.boundaryCurve = curve;\n                        }\n                    }\n                    break;\n                case 'geomEdge': {\n                    const geom = getOrCreateGeomObj(entity);\n                    break;\n                }\n                case 'sourceArrowhead': {\n                    const geomEdge = getOrCreateGeomObj(entity);\n                    if (geomEdge.sourceArrowhead == null) {\n                        geomEdge.sourceArrowhead = new Arrowhead();\n                    }\n                    break;\n                }\n                case 'targetArrowhead': {\n                    const geomEdge = getOrCreateGeomObj(entity);\n                    if (geomEdge.targetArrowhead == null) {\n                        geomEdge.targetArrowhead = new Arrowhead();\n                    }\n                    break;\n                }\n                case 'sourceArrowheadTip': {\n                    const geomEdge = getOrCreateGeomObj(entity);\n                    if (geomEdge.sourceArrowhead == null) {\n                        geomEdge.sourceArrowhead = new Arrowhead();\n                    }\n                    if (str !== 'none') {\n                        geomEdge.sourceArrowhead.tipPosition = Point.fromJSON(JSON.parse(str));\n                    }\n                    break;\n                }\n                case 'targetArrowheadTip': {\n                    const geomEdge = getOrCreateGeomObj(entity);\n                    if (geomEdge.targetArrowhead == null) {\n                        geomEdge.targetArrowhead = new Arrowhead();\n                    }\n                    if (str !== 'none') {\n                        geomEdge.targetArrowhead.tipPosition = Point.fromJSON(JSON.parse(str));\n                    }\n                    break;\n                }\n                case 'geomEdgeLabel': {\n                    const json = JSON.parse(str);\n                    const edge = entity;\n                    createEdgeLabelIfNeeded(edge);\n                    const geomLabel = new GeomLabel(edge.label, new Rectangle(json));\n                    geomLabel.setBoundingBox(new Rectangle(json));\n                    break;\n                }\n                // end of geometry attributes\n                case 'color':\n                    drawingObj.color = parseColor(str);\n                    break;\n                case 'pencolor':\n                    drawingObj.pencolor = parseColor(str);\n                    break;\n                case 'labelfontcolor':\n                    drawingObj.labelfontcolor = parseColor(str);\n                    break;\n                case 'fontcolor':\n                    drawingObj.fontColor = parseColor(str);\n                    break;\n                case 'fillcolor':\n                    drawingObj.fillColor = parseColor(str);\n                    break;\n                case 'style':\n                    for (const style of stylesEnumFromString(str)) {\n                        drawingObj.styles.push(style);\n                    }\n                    break;\n                case 'shape': {\n                    const dn = drawingObj;\n                    dn.shape = shapeEnumFromString(str);\n                    break;\n                }\n                case 'peripheries':\n                    drawingObj.peripheries = parseInt(str);\n                    break;\n                case 'headlabel':\n                    drawingObj.headlabel = str;\n                    break;\n                case 'label':\n                    // ignore html labels, for example\n                    if (typeof str === 'string') {\n                        // ignore html labels, for example\n                        const find = '\\\\n';\n                        let j = 0;\n                        drawingObj.labelText = '';\n                        do {\n                            const i = str.indexOf(find, j);\n                            if (i >= 0) {\n                                drawingObj.labelText += str.substring(j, i) + '\\n';\n                                j = i + 2;\n                            }\n                            else {\n                                drawingObj.labelText += str.substring(j);\n                                break;\n                            }\n                        } while (true);\n                    }\n                    else if (typeof str === 'number') {\n                        drawingObj.labelText = str.toString();\n                    }\n                    if (entity instanceof Edge) {\n                        createEdgeLabelIfNeeded(entity);\n                    }\n                    break;\n                case 'size':\n                    drawingObj.size = parseFloatTuple(str);\n                    break;\n                case 'pos':\n                    drawingObj.pos = parseFloatTuple(str);\n                    break;\n                case 'rankdir':\n                    drawingObj.rankdir = rankDirEnumFromString(str);\n                    break;\n                case 'fontname':\n                    drawingObj.fontname = str;\n                    break;\n                case 'fontsize':\n                    drawingObj.fontsize = parseFloat(str);\n                    break;\n                case 'width':\n                    drawingObj.width = parseFloat(str);\n                    break;\n                case 'penwidth':\n                    drawingObj.penwidth = parseFloat(str);\n                    break;\n                case 'height':\n                    drawingObj.height = parseFloat(str);\n                    break;\n                case 'margin':\n                    drawingObj.margin = parseFloat(str);\n                    break;\n                case 'len':\n                    drawingObj.len = parseFloat(str);\n                    break;\n                case 'minlen':\n                    drawingObj.minlen = parseFloat(str);\n                    break;\n                case 'rank':\n                    drawingObj.rank = rankEnumFromString(str);\n                    break;\n                case 'charset':\n                    drawingObj.charset = str;\n                    break;\n                case 'orientation':\n                    drawingObj.orientation = str;\n                    break;\n                case 'ratio':\n                    drawingObj.ratio = str;\n                    break;\n                case 'weight':\n                    drawingObj.weight = parseFloat(str);\n                    break;\n                case 'nodesep':\n                    drawingObj.nodesep = parseFloat(str);\n                    break;\n                case 'layersep':\n                    drawingObj.layersep = parseFloat(str);\n                    break;\n                case 'arrowsize':\n                    drawingObj.arrowsize = parseFloat(str);\n                    break;\n                case 'rotate':\n                    drawingObj.rotate = parseFloat(str);\n                    break;\n                case 'ranksep':\n                    drawingObj.ranksep = parseFloat(str);\n                    break;\n                case 'splines':\n                    drawingObj.splines = str === 'true';\n                    break;\n                case 'overlap':\n                    drawingObj.overlap = str === 'true';\n                    break;\n                case 'arrowtail':\n                    drawingObj.arrowtail = arrowTypeEnumFromString(str);\n                    break;\n                case 'taillabel':\n                    drawingObj.taillabel = str;\n                    break;\n                case 'arrowhead':\n                    drawingObj.arrowhead = arrowTypeEnumFromString(str);\n                    break;\n                case 'ordering':\n                    drawingObj.ordering = orderingEnumFromString(str);\n                    break;\n                case 'URL':\n                    drawingObj.URL = str;\n                    break;\n                case 'dir':\n                    drawingObj.dir = dirTypeEnumFromString(str);\n                    break;\n                case 'concentrate':\n                    drawingObj.concentrate = str === 'true';\n                    break;\n                case 'compound':\n                    drawingObj.compound = str === 'true';\n                    break;\n                case 'lhead':\n                    drawingObj.lhead = str;\n                    break;\n                case 'ltail':\n                    drawingObj.ltail = str;\n                    break;\n                case 'bgcolor':\n                    drawingObj.bgcolor = parseColor(str);\n                    break;\n                case 'center':\n                    drawingObj.center = str === true || parseInt(str) === 1;\n                    break;\n                case 'colorscheme':\n                    drawingObj.colorscheme = str;\n                    break;\n                case 'sides':\n                    drawingObj.sides = parseInt(str);\n                    break;\n                case 'distortion':\n                    drawingObj.distortion = parseFloat(str);\n                    break;\n                case 'skew':\n                    drawingObj.skew = parseFloat(str);\n                    break;\n                case 'bb':\n                    drawingObj.bb = parseFloatQuatriple(str);\n                    break;\n                case 'labelloc':\n                    drawingObj.labelloc = str;\n                    break;\n                case 'decorate':\n                    drawingObj.decorate = str === 'true';\n                    break;\n                case 'tailclip':\n                    drawingObj.tailclip = str === 'true';\n                    break;\n                case 'headclip':\n                    drawingObj.headclip = str === 'true';\n                    break;\n                case 'constraint':\n                    drawingObj.constraint = str === 'true';\n                    break;\n                case 'gradientangle':\n                    drawingObj.gradientangle = parseFloat(str);\n                    break;\n                case 'samehead':\n                    drawingObj.samehead = str;\n                    break;\n                case 'href':\n                    drawingObj.href = str;\n                    break;\n                case 'imagepath':\n                    drawingObj.imagepath = str;\n                    break;\n                case 'image':\n                    drawingObj.image = str;\n                    break;\n                case 'labeljust':\n                    drawingObj.labejust = str;\n                    break;\n                case 'layers':\n                    drawingObj.layers = str.split(',');\n                    break;\n                case 'layer':\n                    drawingObj.layer = str;\n                    break;\n                case 'f':\n                    drawingObj.f = parseFloat(str);\n                    break;\n                case 'nojustify':\n                    drawingObj.nojustify = str === 'true';\n                    break;\n                case 'root':\n                    drawingObj.root = str === 'true';\n                    break;\n                case 'page':\n                    drawingObj.page = parseFloatTuple(str);\n                    break;\n                case 'pname':\n                    drawingObj.pname = str;\n                    break;\n                case 'kind':\n                    drawingObj.kind = str;\n                    break;\n                case 'fname':\n                    drawingObj.fname = str;\n                    break;\n                case 'subkind':\n                    drawingObj.subkind = str;\n                    break;\n                case 'area':\n                    drawingObj.area = parseFloat(str);\n                    break;\n                case 'tailport':\n                    drawingObj.tailport = str;\n                    break;\n                case 'headport':\n                    drawingObj.headport = str;\n                    break;\n                case 'wt':\n                    drawingObj.wt = str;\n                    break;\n                case 'id':\n                    if (drawingObj instanceof DrawingNode) {\n                    }\n                    else {\n                        drawingObj.id = str;\n                    }\n                    break;\n                case 'edgetooltip':\n                    drawingObj.edgetooltip = str;\n                    break;\n                case 'headtooltip':\n                    drawingObj.headtooltip = str;\n                    break;\n                case 'tailtooltip':\n                    drawingObj.tailtooltip = str;\n                    break;\n                case 'headURL':\n                    drawingObj.headURL = str;\n                    break;\n                case 'tailURL':\n                    drawingObj.tailURL = str;\n                    break;\n                case 'labelURL':\n                    drawingObj.labelURL = str;\n                    break;\n                case 'edgeurl':\n                    drawingObj.edgeurl = str;\n                    break;\n                case 'shapefile':\n                    drawingObj.shapefile = str;\n                    break;\n                case 'xlabel':\n                    drawingObj.xlabel = str;\n                    break;\n                case 'sametail':\n                    drawingObj.sametail = str;\n                    break;\n                case 'clusterrank':\n                    drawingObj.clusterRank = str;\n                    break;\n                case 'measuredTextSize':\n                    drawingObj.measuredTextSize = JSON.parse(str);\n                    break;\n                default:\n                    break; // remove the comment below to catch unsupported attributes\n                // throw new Error('not implemented for ' + attr.id)\n            }\n        }\n        else {\n            throw new Error('unexpected type ' + attr.type);\n        }\n    }\n    function createEdgeLabelIfNeeded(edge) {\n        if (edge.label == null) {\n            edge.label = new Label(edge);\n        }\n    }\n}\nfunction parseAttrs(o, entity) {\n    const drawingObj = DrawingObject.getDrawingObj(entity);\n    if (o.attr_list == null)\n        return;\n    parseAttrOnDrawingObj(entity, drawingObj, o);\n}\nclass DotParser {\n    constructor(ast) {\n        this.nodeMap = new Map();\n        this.ast = ast;\n    }\n    parseEdge(so, to, graph, directed, o) {\n        let sn;\n        let tn;\n        if (so.type === 'node_id') {\n            const s = so.id.toString();\n            sn = this.nodeMap.get(s);\n            if (sn == null) {\n                sn = this.newNode(s, graph, false);\n            }\n            else {\n                this.tryToMoveToADeeperGraph(sn, graph);\n            }\n        }\n        else {\n            const drObjs = [];\n            for (const ch of so.children) {\n                if (ch.type === 'node_stmt') {\n                    for (const e of this.parseEdge(ch.node_id, to, graph, directed, o))\n                        drObjs.push(e);\n                }\n                else if (ch.type === 'attr_stmt') {\n                }\n                else {\n                    throw new Error('not implemented');\n                }\n            }\n            for (const ch of so.children) {\n                if (ch.type === 'attr_stmt') {\n                    for (const drObj of drObjs)\n                        parseAttrs(ch, drObj);\n                } // ignore anything else\n            }\n            return drObjs;\n        }\n        if (to.type === 'node_id') {\n            const t = to.id.toString();\n            tn = this.nodeMap.get(t);\n            if (tn == null) {\n                tn = this.newNode(t, graph, false);\n            }\n            else {\n                this.tryToMoveToADeeperGraph(tn, graph);\n            }\n        }\n        else if (to.type === 'subgraph') {\n            const subgraphEdges = new Array();\n            for (const ch of to.children) {\n                if (ch.type === 'node_stmt') {\n                    for (const e of this.parseEdge(so, ch.node_id, graph, directed, o))\n                        subgraphEdges.push(e);\n                }\n                else if (ch.type === 'attr_stmt') {\n                }\n                else {\n                    throw new Error('not implemented');\n                }\n            }\n            for (const ch of to.children) {\n                if (ch.type === 'attr_stmt') {\n                    for (const drObj of subgraphEdges)\n                        parseAttrs(ch, drObj);\n                } // ignore anything else\n            }\n            return subgraphEdges;\n        }\n        const edge = new Edge(sn, tn);\n        new DrawingEdge(edge, directed);\n        parseAttrs(o, edge);\n        return [edge];\n    }\n    tryToMoveToADeeperGraph(sn, graph) {\n        Assert.assert(sn.parent != null);\n        const snParent = sn.parent;\n        if (snParent != graph && depth(snParent) < depth(graph)) {\n            snParent.remove(sn);\n            graph.addNode(sn);\n        }\n        function depth(a) {\n            let d = 0;\n            let p = a.parent;\n            while (p) {\n                d++;\n                p = p.parent;\n            }\n            return d;\n        }\n    }\n    newNode(id, g, underSubgraph) {\n        let n = this.nodeMap.get(id);\n        if (n == null) {\n            n = new Node(id);\n            this.nodeMap.set(id, n);\n            g.addNode(n);\n            const dn = new DrawingNode(n);\n            dn.labelText = id;\n            const drGr = DrawingGraph.getDrawingObj(g);\n            DrawingObject.copyValidFields(drGr.defaultNodeObject, dn);\n        }\n        else if (underSubgraph) {\n            // if the node is under a subgraph - change its parent to the subgraph\n            setNewParent(g, n);\n        }\n        return n;\n    }\n    parseNode(o, graph, underSubgraph) {\n        const id = o.node_id.id.toString();\n        const node = this.newNode(id, graph, underSubgraph);\n        if (DrawingObject.getDrawingObj(node) == null) {\n            new DrawingNode(node);\n        }\n        parseAttrs(o, node);\n        return node;\n    }\n    parse() {\n        if (this.ast == null)\n            return null;\n        this.graph = new Graph(this.ast[0].id ? this.ast[0].id.toString() : '__graph__');\n        this.drawingGraph = new DrawingGraph(this.graph);\n        this.parseUnderGraph(this.ast[0].children, this.graph, this.ast[0].type === 'digraph', false);\n        removeEmptySubgraphs(this.graph);\n        createGeomForSubgraphs(this.graph);\n        return this.graph;\n    }\n    parseGraphAttr(o, graph) {\n        if (o.target === 'node') {\n            const dg = DrawingGraph.getDrawingObj(graph);\n            if (dg.defaultNodeObject == null) {\n                dg.defaultNodeObject = new DrawingNode(null);\n            }\n            // but also parse it for the default node attribute\n            parseAttrOnDrawingObj(null, dg.defaultNodeObject, o);\n        }\n        else if (o.target === 'graph') {\n            parseAttrs(o, graph);\n        }\n    }\n    getEntitiesSubg(o, graph, directed) {\n        let ret = [];\n        for (const ch of o.children) {\n            if (ch.type === 'edge_stmt') {\n                for (let i = 0; i < ch.edge_list.length - 1; i++) {\n                    for (const e of this.parseEdge(ch.edge_list[i], ch.edge_list[i + 1], graph, directed, ch))\n                        ret.push(e);\n                }\n            }\n            else if (ch.type === 'attr_stmt') {\n            }\n            else if (ch.type === 'node_stmt') {\n                ret.push(this.parseNode(ch, graph, true));\n            }\n            else if (ch.type === 'subgraph') {\n                if (ch.id != null) {\n                    const subg = new Graph(ch.id.toString());\n                    graph.addNode(subg);\n                    this.nodeMap.set(subg.id, subg);\n                    const sdg = new DrawingGraph(subg);\n                    this.parseUnderGraph(ch.children, subg, directed, true);\n                    ret.push(sdg.graph);\n                    if (subg.isEmpty) {\n                        graph.removeNode(subg);\n                        this.nodeMap.delete(subg.id);\n                    }\n                }\n                else {\n                    ret = ret.concat(this.getEntitiesSubg(ch, graph, directed));\n                }\n            }\n            else {\n                throw new Error('Function not implemented.');\n            }\n        }\n        return ret;\n    }\n    parseUnderGraph(children, graph, directed, underSubgraph) {\n        for (const o of children) {\n            switch (o.type) {\n                case 'node_stmt':\n                    this.parseNode(o, graph, underSubgraph);\n                    break;\n                case 'edge_stmt':\n                    {\n                        const edgeList = o.edge_list;\n                        for (let i = 0; i < edgeList.length - 1; i++)\n                            this.parseEdge(edgeList[i], edgeList[i + 1], graph, directed, o);\n                    }\n                    break;\n                case 'subgraph':\n                    {\n                        // is it really a subgraph?\n                        if (this.process_same_rank(o, DrawingGraph.getDrawingGraph(graph))) {\n                        }\n                        else if (o.id == null) {\n                            const entities = this.getEntitiesSubg(o, graph, directed);\n                            applyAttributesToEntities(o, DrawingGraph.getDrawingGraph(graph), entities);\n                        }\n                        else {\n                            const subg = new Graph(o.id.toString());\n                            this.nodeMap.set(o.id.toString(), subg);\n                            graph.addNode(subg);\n                            new DrawingGraph(subg);\n                            this.parseUnderGraph(o.children, subg, directed, true);\n                            if (subg.isEmpty()) {\n                                graph.remove(subg);\n                                this.nodeMap.delete(subg.id);\n                            }\n                        }\n                    }\n                    break;\n                case 'attr_stmt':\n                    this.parseGraphAttr(o, graph);\n                    break;\n                default:\n                    throw new Error('not implemented');\n            }\n        }\n    }\n    process_same_rank(o, dg) {\n        const attr = o.children[0];\n        if (attr == null)\n            return false;\n        if (attr.type !== 'attr_stmt')\n            return false;\n        const attr_list = attr.attr_list;\n        if (attr_list == null)\n            return false;\n        if (attr_list.length === 0)\n            return false;\n        const attr_0 = attr_list[0];\n        if (attr_0.type !== 'attr')\n            return false;\n        if (attr_0.id !== 'rank')\n            return false;\n        switch (attr_0.eq) {\n            case 'min':\n                for (let i = 1; i < o.children.length; i++) {\n                    const c = o.children[i];\n                    if (c.type === 'node_stmt') {\n                        dg.graphVisData.minRanks.push(c.node_id.id.toString());\n                    }\n                    else {\n                        throw new Error();\n                    }\n                }\n                return true;\n            case 'max':\n                for (let i = 1; i < o.children.length; i++) {\n                    const c = o.children[i];\n                    if (c.type === 'node_stmt') {\n                        dg.graphVisData.minRanks.push(c.node_id.id.toString());\n                    }\n                    else {\n                        throw new Error();\n                    }\n                }\n                return true;\n            case 'same': {\n                const sameRank = [];\n                for (let i = 1; i < o.children.length; i++) {\n                    const c = o.children[i];\n                    if (c.type === 'node_stmt') {\n                        this.newNode(c.node_id.id.toString(), dg.graph, false);\n                        sameRank.push(c.node_id.id.toString());\n                    }\n                    else if (c.type === 'attr_stmt') {\n                        if (c.target === 'node') {\n                            if (dg.defaultNodeObject == null) {\n                                dg.defaultNodeObject = new DrawingNode(null);\n                            }\n                            parseAttrOnDrawingObj(null, dg.defaultNodeObject, c);\n                        }\n                    }\n                }\n                dg.graphVisData.sameRanks.push(sameRank);\n                return true;\n            }\n            case 'source': {\n                for (let i = 1; i < o.children.length; i++) {\n                    const c = o.children[i];\n                    if (c.type === 'node_stmt') {\n                        dg.graphVisData.sourceRanks.push(c.node_id.id.toString());\n                    }\n                    else {\n                        throw new Error();\n                    }\n                }\n                return true;\n            }\n            case 'sink':\n                {\n                    for (let i = 1; i < o.children.length; i++) {\n                        const c = o.children[i];\n                        if (c.type === 'node_stmt') {\n                            dg.graphVisData.sinkRanks.push(c.node_id.id.toString());\n                        }\n                        else {\n                            throw new Error();\n                        }\n                    }\n                }\n                return true;\n            default:\n                throw new Error('incorrect rank');\n                return false;\n        }\n    }\n}\n/** parses a string representing a Graph in DOT Format */\nexport function parseDot(graphStr) {\n    try {\n        const dp = new DotParser(parse(graphStr));\n        return dp.parse();\n    }\n    catch (peg$SyntaxError) {\n        console.log('cannot parse the graph');\n        console.log(peg$SyntaxError.message);\n        console.log('start: line =', peg$SyntaxError.location.start.line, 'col=', peg$SyntaxError.location.start.column, 'offset=', peg$SyntaxError.location.start.offset);\n        console.log('end: line =', peg$SyntaxError.location.end.line, 'col=', peg$SyntaxError.location.end.column, 'offset=', peg$SyntaxError.location.end.offset);\n        console.log('expected=', peg$SyntaxError.expected);\n        console.log('found=', peg$SyntaxError.found);\n        return null;\n    }\n}\n// /** parses a string representing a Graph in JSON Format, corresponding to JSONGraph type */\n// export function parseJSON(graphStr: string): Graph {\n//   try {\n//     const ast: JSONGraph = JSON.parse(graphStr)\n//     const dp = new DotParser([ast])\n//     return dp.parse()\n//   } catch (Error) {\n//\n//     return null\n//   }\n// }\n/** parses JSONGraph type to a Graph */\nexport function parseJSONGraph(jsonObj) {\n    try {\n        const dp = new DotParser([jsonObj]);\n        const ret = dp.parse();\n        return ret;\n    }\n    catch (Error) {\n        console.log(Error.message);\n        return null;\n    }\n}\nfunction* stylesEnumFromString(str) {\n    const styles = str.split(',');\n    for (const t of styles) {\n        const typedStyleString = t;\n        const ret = StyleEnum[typedStyleString];\n        if (ret) {\n            yield ret;\n        }\n    }\n}\nfunction shapeEnumFromString(t) {\n    const typedStyleString = t.toLowerCase();\n    return ShapeEnum[typedStyleString];\n}\nfunction parseFloatTuple(str) {\n    const p = str.split(',');\n    return [parseFloat(p[0]), parseFloat(p[1])];\n}\nfunction rankDirEnumFromString(t) {\n    const typedStyleString = t;\n    return LayerDirectionEnum[typedStyleString];\n}\nfunction rankEnumFromString(t) {\n    const typedStyleString = t;\n    return RankEnum[typedStyleString];\n}\nfunction arrowTypeEnumFromString(t) {\n    const typedStyleString = t;\n    return ArrowTypeEnum[typedStyleString];\n}\nfunction orderingEnumFromString(t) {\n    const typedStyleString = t;\n    return OrderingEnum[typedStyleString];\n}\nfunction dirTypeEnumFromString(t) {\n    const typedStyleString = t;\n    return DirTypeEnum[typedStyleString];\n}\nfunction parseFloatQuatriple(str) {\n    const p = str.split(',');\n    return [parseFloat(p[0]), parseFloat(p[1]), parseFloat(p[2]), parseFloat(p[3])];\n}\nfunction applyAttributesToEntities(o, dg, entities) {\n    for (const ch of o.children) {\n        if (ch.type === 'attr_stmt') {\n            for (const ent of entities)\n                parseAttrs(ch, ent);\n        }\n    }\n}\nfunction removeEmptySubgraphs(graph) {\n    const emptySubgraphList = [];\n    for (const sg of graph.subgraphsBreadthFirst()) {\n        if (sg.isEmpty()) {\n            emptySubgraphList.push(sg);\n        }\n    }\n    for (const sg of emptySubgraphList) {\n        const parent = sg.parent;\n        if (parent) {\n            parent.removeNode(sg);\n        }\n    }\n}\nfunction createGeomForSubgraphs(graph) {\n    for (const sg of graph.subgraphsBreadthFirst()) {\n        if (GeomGraph.getGeom(sg) == null && sg.hasSomeAttrOnIndex(AttributeRegistry.GeomObjectIndex)) {\n            new GeomGraph(sg);\n        }\n    }\n    if (GeomGraph.getGeom(graph) == null && graph.hasSomeAttrOnIndex(AttributeRegistry.GeomObjectIndex)) {\n        new GeomGraph(graph);\n    }\n}\n/** Exports the graph into a JSONGraph object for further serialization */\nexport function graphToJSON(graph) {\n    /** idToLevels are needed to figure out the edge membership efficiently:\n     * Edge belongs to the first Graph which is a common ancestor of the edge source and the edge target.\n     */\n    const idToLevels = getNodeLevels(graph);\n    const ret = { type: getGraphType(graph), id: graph.id, children: createChildren(graph, idToLevels) };\n    return ret;\n}\nfunction edgeStmt(edge) {\n    //create edge_list from one element\n    return {\n        type: 'edge_stmt',\n        edge_list: [\n            { type: 'node_id', id: edge.source.id },\n            { type: 'node_id', id: edge.target.id },\n        ],\n        attr_list: Array.from(getEdgeAttrs(edge)),\n    };\n}\nfunction createChildren(graph, nodeLevels) {\n    const idToStmt = new Map();\n    const children = [];\n    const geomGraph = GeomGraph.getGeom(graph);\n    if (geomGraph) {\n        const attrs = Array.from(getGeomGraphAttrList(geomGraph));\n        children.push({ type: 'attr_stmt', target: 'graph', attr_list: attrs });\n    }\n    addDefaultNodeStmt(children, graph);\n    // fill the map of idToStmh\n    for (const n of graph.nodesBreadthFirst) {\n        idToStmt.set(n.id, getNodeStatement(n));\n    }\n    // attach node and subgraphs stmts to their parents\n    for (const n of graph.nodesBreadthFirst) {\n        if (n.parent === graph) {\n            continue;\n        }\n        const subGraph = idToStmt.get(n.parent.id);\n        subGraph.children.push(idToStmt.get(n.id));\n    }\n    // attach edge statements to their parents\n    for (const e of graph.deepEdges) {\n        const es = edgeStmt(e);\n        const parent = edgeParent(e, nodeLevels);\n        if (parent === graph) {\n            children.push(es);\n        }\n        else {\n            const subGraph = idToStmt.get(parent.id);\n            subGraph.children.push(es);\n        }\n    }\n    for (const n of graph.shallowNodes) {\n        children.push(idToStmt.get(n.id));\n    }\n    return children;\n}\nfunction* getEdgeAttrs(edge) {\n    const geomEdge = GeomObject.getGeom(edge);\n    if (geomEdge) {\n        yield { type: 'attr', id: 'geomEdge', eq: 'none' };\n        if (geomEdge.curve)\n            yield { type: 'attr', id: 'edgeCurve', eq: JSON.stringify(iCurveToJSON(geomEdge.curve)) };\n        if (geomEdge.sourceArrowhead) {\n            yield { type: 'attr', id: 'sourceArrowhead', eq: 'none' };\n            if (geomEdge.sourceArrowhead.tipPosition) {\n                yield { type: 'attr', id: 'sourceArrowheadTip', eq: JSON.stringify(geomEdge.sourceArrowhead.tipPosition.toJSON()) };\n            }\n        }\n        if (geomEdge.targetArrowhead) {\n            yield { type: 'attr', id: 'targetArrowhead', eq: 'none' };\n            if (geomEdge.targetArrowhead.tipPosition) {\n                yield { type: 'attr', id: 'targetArrowheadTip', eq: JSON.stringify(geomEdge.targetArrowhead.tipPosition.toJSON()) };\n            }\n        }\n        if (edge.label) {\n            const bb = edge.label.getAttr(AttributeRegistry.GeomObjectIndex).boundingBox;\n            const rJSON = { left: bb.left, right: bb.right, top: bb.top, bottom: bb.bottom };\n            yield { type: 'attr', id: 'geomEdgeLabel', eq: JSON.stringify(rJSON) };\n        }\n    }\n    yield* attrIter(DrawingObject.getDrawingObj(edge));\n}\nfunction getNodeStatement(node) {\n    const isGraph = node instanceof Graph;\n    if (!isGraph) {\n        return {\n            type: 'node_stmt',\n            node_id: { type: 'node_id', id: node.id },\n            attr_list: Array.from(getNodeAttrList(node)),\n        };\n    }\n    else {\n        const attr_list = Array.from(getGeomGraphAttrList(GeomGraph.getGeom(node)));\n        const children = [];\n        const attr_stmt = { type: 'attr_stmt', target: 'graph', attr_list: attr_list };\n        children.push(attr_stmt);\n        return { type: 'subgraph', children: children, id: node.id };\n    }\n}\nfunction getNodeBoundaryCurve(node) {\n    const bc = GeomNode.getGeom(node).boundaryCurve;\n    return { type: 'attr', id: 'boundaryCurve', eq: JSON.stringify(iCurveToJSON(bc)) };\n}\nfunction* getNodeAttrList(node) {\n    const geomNode = GeomObject.getGeom(node);\n    if (geomNode) {\n        yield getNodeBoundaryCurve(node);\n    }\n    yield* attrIter(DrawingObject.getDrawingObj(node));\n}\nfunction* attrIter(drObj) {\n    if (drObj.color) {\n        yield { type: 'attr', id: 'color', eq: drObj.color.toString() };\n    }\n    if (drObj.fillColor) {\n        yield { type: 'attr', id: 'fillColor', eq: drObj.fillColor.toString() };\n    }\n    if (drObj.labelfontcolor) {\n        yield { type: 'attr', id: 'labelfontcolor', eq: drObj.labelfontcolor.toString() };\n    }\n    if (!(drObj.labelText == null || drObj.labelText === '') && drObj.entity && drObj.labelText !== drObj.id) {\n        yield { type: 'attr', id: 'label', eq: drObj.labelText };\n    }\n    if (drObj.fontColor && drObj.fontColor.keyword.toLowerCase() !== 'black') {\n        yield { type: 'attr', id: 'fontColor', eq: drObj.fontColor.toString() };\n    }\n    if (drObj.styles && drObj.styles.length) {\n        const styleString = drObj.styles.map((s) => StyleEnum[s]).reduce((a, b) => a.concat(',' + b));\n        yield { type: 'attr', id: 'style', eq: styleString };\n    }\n    if (drObj.pencolor && drObj.pencolor.keyword !== 'black') {\n        yield { type: 'attr', id: 'pencolor', eq: drObj.pencolor.toString() };\n    }\n    if (drObj.penwidth && drObj.penwidth !== 1) {\n        yield { type: 'attr', id: 'penwidth', eq: drObj.penwidth.toString() };\n    }\n    if (drObj.rankdir) {\n        yield { type: 'attr', id: 'rankdir', eq: drObj.rankdir.toString() };\n    }\n    if (drObj.fontname && drObj.fontname !== DrawingObject.defaultLabelFontName) {\n        yield { type: 'attr', id: 'fontname', eq: drObj.fontname };\n    }\n    if (drObj.margin) {\n        yield { type: 'attr', id: 'margin', eq: drObj.margin.toString() };\n    }\n    if (drObj.fontsize && drObj.fontsize !== DrawingObject.defaultLabelFontSize) {\n        yield { type: 'attr', id: 'fontsize', eq: drObj.fontsize.toString() };\n    }\n    if (drObj.orientation) {\n        yield { type: 'attr', id: 'orientation', eq: drObj.orientation.toString() };\n    }\n    if (drObj.ranksep) {\n        yield { type: 'attr', id: 'ranksep', eq: drObj.ranksep.toString() };\n    }\n    if (drObj.arrowtail) {\n        yield { type: 'attr', id: 'arrowtail', eq: ArrowTypeEnum[drObj.arrowtail] };\n    }\n    if (drObj.arrowhead) {\n        yield { type: 'attr', id: 'arrowhead', eq: ArrowTypeEnum[drObj.arrowhead] };\n    }\n    if (drObj.ordering) {\n        yield { type: 'attr', id: 'ordering', eq: drObj.ordering.toString() };\n    }\n    if (drObj.bgcolor) {\n        yield { type: 'attr', id: 'bgcolor', eq: drObj.bgcolor.toString() };\n    }\n    if (drObj.pos) {\n        yield { type: 'attr', id: 'pos', eq: drObj.pos.toString() };\n    }\n    if (drObj.nodesep) {\n        yield { type: 'attr', id: 'nodesep', eq: drObj.nodesep.toString() };\n    }\n    if (drObj.arrowsize) {\n        yield { type: 'attr', id: 'arrowsize', eq: drObj.arrowsize.toString() };\n    }\n    if (drObj.samehead) {\n        yield { type: 'attr', id: 'samehead', eq: drObj.samehead.toString() };\n    }\n    if (drObj.layersep) {\n        yield { type: 'attr', id: 'layersep', eq: drObj.layersep.toString() };\n    }\n    if (drObj.clusterRank) {\n        yield { type: 'attr', id: 'clusterrank', eq: drObj.clusterRank.toString() };\n    }\n    if (drObj.measuredTextSize) {\n        yield { type: 'attr', id: 'measuredTextSize', eq: JSON.stringify(drObj.measuredTextSize) };\n    }\n    if (drObj instanceof DrawingNode) {\n        if (drObj.shape && drObj.shape !== ShapeEnum.box) {\n            yield { type: 'attr', id: 'shape', eq: drObj.shape.toString() };\n        }\n        if (drObj.xRad && drObj.xRad !== 3) {\n            yield { type: 'attr', id: 'xRad', eq: drObj.xRad.toString() };\n        }\n        if (drObj.yRad && drObj.yRad !== 3) {\n            yield { type: 'attr', id: 'yRad', eq: drObj.yRad.toString() };\n        }\n        if (drObj.padding && drObj.padding !== 2) {\n            yield { type: 'attr', id: 'padding', eq: drObj.padding.toString() };\n        }\n    }\n}\nfunction getGraphType(graph) {\n    const drGr = DrawingGraph.getDrawingGraph(graph);\n    return drGr.hasDirectedEdge() ? 'digraph' : 'graph';\n}\nfunction edgeParent(e, nodeLevels) {\n    // make the levels equal\n    let s = e.source;\n    let t = e.target;\n    let sLevel = nodeLevels.get(s.id);\n    let tLevel = nodeLevels.get(t.id);\n    while (sLevel > tLevel) {\n        s = s.parent;\n        sLevel--;\n    }\n    while (sLevel < tLevel) {\n        t = t.parent;\n        tLevel--;\n    }\n    // Assert.assert(sLevel === tLevel)\n    while (s.parent !== t.parent) {\n        s = s.parent;\n        t = t.parent;\n    }\n    return s.parent;\n}\n/** The nodes belonging to the root graph have levels 0,\n * In general, a node level is the distance, the number of hops,\n *  from its parent to the root in the\n * tree of graphs.\n */\nfunction getNodeLevels(graph) {\n    const levels = new Map();\n    levels.set(graph.id, 0);\n    getNodeLevelsOnMap(graph, levels);\n    return levels;\n}\nfunction getNodeLevelsOnMap(graph, levels) {\n    const graphLevel = levels.get(graph.id) + 1;\n    for (const n of graph.shallowNodes) {\n        levels.set(n.id, graphLevel);\n        if (n instanceof Graph) {\n            getNodeLevelsOnMap(n, levels);\n        }\n    }\n}\nfunction getOrCreateGeomObj(entity) {\n    var _a;\n    return (_a = GeomObject.getGeom(entity)) !== null && _a !== void 0 ? _a : createNewGeomObj(entity);\n}\nfunction createNewGeomObj(entity) {\n    if (entity instanceof Graph) {\n        return new GeomGraph(entity);\n    }\n    if (entity instanceof Node) {\n        return new GeomNode(entity);\n    }\n    if (entity instanceof Edge) {\n        return new GeomEdge(entity);\n    }\n    throw new Error('unsupported type ' + entity);\n}\nfunction addDefaultNodeStmt(children, graph) {\n    const dg = DrawingGraph.getDrawingObj(graph);\n    if (dg == null)\n        return;\n    const defaultDrawingNode = dg.defaultNodeObject;\n    if (defaultDrawingNode) {\n        children.push({ type: 'attr_stmt', target: 'node', attr_list: Array.from(attrIter(defaultDrawingNode)) });\n    }\n}\nfunction* getGeomGraphAttrList(geomGraph) {\n    if (geomGraph == null)\n        return;\n    const bb = geomGraph.boundingBox;\n    if (bb && bb.isEmpty() === false) {\n        const rJSON = { left: bb.left, right: bb.right, top: bb.top, bottom: bb.bottom };\n        yield { type: 'attr', id: 'graphBoundingBox', eq: JSON.stringify(rJSON) };\n    }\n    if (geomGraph.radX !== 10) {\n        yield { type: 'attr', id: 'radX', eq: geomGraph.radX.toString() };\n    }\n    if (geomGraph.radY !== 10) {\n        yield { type: 'attr', id: 'radY', eq: geomGraph.radY.toString() };\n    }\n}\n/** Each line of the file is a string in Format sourceId\\ttargetId. That is two words separated by a tabulation symbol.\n * The edges are considered directed.\n */\nexport function parseTXT(content) {\n    const graph = new Graph();\n    try {\n        const lines = content.split(/\\r\\n|\\r|\\n/);\n        for (const l of lines) {\n            if (l.length == 0)\n                continue;\n            if (l.charAt(0) == '#')\n                continue;\n            const st = l.split(/\\t| |,/);\n            if (st.length < 2) {\n                console.log('cannot parse', l);\n                return null;\n            }\n            const s = st[0];\n            const t = st[1];\n            const sn = addOrGetNodeWithDrawingAttr(graph, s);\n            const tn = addOrGetNodeWithDrawingAttr(graph, t);\n            const e = new Edge(sn, tn);\n            new DrawingEdge(e, true); // true for directed\n        }\n    }\n    catch (e) {\n        console.log(e.message);\n    }\n    new DrawingGraph(graph);\n    return graph;\n}\nfunction addOrGetNodeWithDrawingAttr(graph, id) {\n    let node = graph.findNode(id);\n    if (node == null) {\n        node = graph.addNode(new Node(id));\n        new DrawingNode(node);\n    }\n    return node;\n}\nexport async function loadGraphFromFile(file) {\n    const content = await file.text();\n    let graph;\n    if (file.name.toLowerCase().endsWith('.json')) {\n        graph = parseJSON(JSON.parse(content));\n    }\n    else if (file.name.toLowerCase().endsWith('.txt') ||\n        file.name.toLowerCase().endsWith('.tsv') ||\n        file.name.toLowerCase().endsWith('.csv')) {\n        graph = parseTXT(content);\n    }\n    else {\n        graph = parseDot(content);\n    }\n    if (graph) {\n        graph.id = file.name;\n    }\n    return graph;\n}\nexport async function loadGraphFromUrl(url) {\n    const fileName = url.slice(url.lastIndexOf('/') + 1);\n    const resp = await fetch(url);\n    let graph;\n    if (fileName.endsWith('.json')) {\n        const json = await resp.json();\n        graph = parseJSON(json);\n    }\n    else if (fileName.endsWith('.txt')) {\n        const content = await resp.text();\n        graph = parseTXT(content);\n    }\n    else {\n        const content = await resp.text();\n        graph = parseDot(content);\n    }\n    if (graph)\n        graph.id = fileName;\n    return graph;\n}\nexport function parseJSON(json) {\n    if ('nodes' in json) {\n        return parseSimpleJSON(json);\n    }\n    return parseJSONGraph(json);\n}\nexport function parseSimpleJSON(json) {\n    const g = new Graph();\n    for (const node of json.nodes) {\n        const id = String(node.id);\n        const n = g.addNode(new Node(id));\n        const dn = new DrawingNode(n);\n        const { label = id, shape = 'box' } = node;\n        dn.labelText = label;\n        dn.ShapeEnum = ShapeEnum[shape];\n        if ('weight' in node) {\n            dn.weight = node.weight;\n        }\n        if ('color' in node) {\n            dn.color = parseColor(node.color);\n        }\n    }\n    for (const edge of json.edges) {\n        const e = g.setEdge(String(edge.source), String(edge.target));\n        const de = new DrawingEdge(e, false);\n        const { arrowhead = 'none', arrowtail = 'none', directed = true } = edge;\n        de.arrowhead = ArrowTypeEnum[arrowhead];\n        de.arrowtail = ArrowTypeEnum[arrowtail];\n        de.directed = directed;\n        if ('weight' in edge) {\n            de.weight = edge.weight;\n        }\n        if ('color' in edge) {\n            de.color = parseColor(edge.color);\n        }\n    }\n    new DrawingGraph(g); // create the DrawingAttribute on the graph\n    return g;\n}\n//# sourceMappingURL=dotparser.js.map","export { parseDot, graphToJSON, parseTXT, parseJSON } from './dotparser';\nimport { loadGraphFromFile, loadGraphFromUrl } from './dotparser';\nexport { loadGraphFromFile, loadGraphFromUrl };\n//# sourceMappingURL=index.js.map","import parseCSSColor from 'parse-color';\nimport { Color } from '@msagl/drawing';\nexport function parseColor(s) {\n    const p = parseCSSColor(s);\n    if (p.keyword != null) {\n        return Color.parse(p.keyword.toString());\n    }\n    if (p != null) {\n        if (p.rgba != null) {\n            return new Color(p.rgba[3], p.rgba[0], p.rgba[1], p.rgba[2]);\n        }\n        if (p.rgb != null) {\n            return Color.mkRGB(p.rgb[0], p.rgb[1], p.rgb[2]);\n        }\n    }\n    return Color.Black;\n}\n//# sourceMappingURL=utils.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { layout } from './layeredLayout';\n\n// Separate from main implementation so it does not trip out tests\naddEventListener('message', async (event) => {\n  const { nodes, edges, config } = event.data;\n  const [newNodes, newEdges] = layout(nodes, edges, config);\n  postMessage({ nodes: newNodes, edges: newEdges });\n});\n"],"names":[],"sourceRoot":""}