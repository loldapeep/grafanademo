/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dotparser/grammar/dot.js":
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { start: peg$parsestart },
      peg$startRuleFunction  = peg$parsestart,

      peg$c0 = "strict",
      peg$c1 = peg$literalExpectation("strict", true),
      peg$c2 = "graph",
      peg$c3 = peg$literalExpectation("graph", true),
      peg$c4 = "digraph",
      peg$c5 = peg$literalExpectation("digraph", true),
      peg$c6 = "{",
      peg$c7 = peg$literalExpectation("{", false),
      peg$c8 = "}",
      peg$c9 = peg$literalExpectation("}", false),
      peg$c10 = function(strict, type, id, children) {
            if (children === null) children = [];
            var ret = {type:type.toLowerCase(), children:children};
            if (strict) { ret.strict = true }
            if (id) { ret.id = id }
            return ret;
          },
      peg$c11 = ";",
      peg$c12 = peg$literalExpectation(";", false),
      peg$c13 = function(s, other) { return other; },
      peg$c14 = function(s, e) { return [s].concat(e); },
      peg$c15 = "=",
      peg$c16 = peg$literalExpectation("=", false),
      peg$c17 = function(left, right) {
          return {
            type:'attr_stmt',
            target:'graph',
            attr_list:[{
              type:'attr',
              id:left,
              eq:right
            }]
          };
        },
      peg$c18 = "node",
      peg$c19 = peg$literalExpectation("node", true),
      peg$c20 = "edge",
      peg$c21 = peg$literalExpectation("edge", true),
      peg$c22 = function(target, attr) {
           return {
             type:'attr_stmt',
             target:target,
             attr_list:attr
           };
        },
      peg$c23 = "[",
      peg$c24 = peg$literalExpectation("[", false),
      peg$c25 = "]",
      peg$c26 = peg$literalExpectation("]", false),
      peg$c27 = function(list, rest) {
          return (list || []).concat(rest || []);
        },
      peg$c28 = function(id, v) {return v},
      peg$c29 = ",",
      peg$c30 = peg$literalExpectation(",", false),
      peg$c31 = function(id, eq, rest) {
              return [{
                type:'attr',
                id:id,
                eq: eq
              }].concat(rest || []);
          },
      peg$c32 = function(id, rhs, attr) {
             var edge_list = [id];
             edge_list = edge_list.concat(rhs.map(function(v){return v.id}));

             return {
               type:'edge_stmt',
               edge_list:edge_list,
               attr_list:attr || []
             };
          },
      peg$c33 = "->",
      peg$c34 = peg$literalExpectation("->", false),
      peg$c35 = "--",
      peg$c36 = peg$literalExpectation("--", false),
      peg$c37 = function(edgeop, id, rest) {
            return [{
              type:'edgeRHS',
              edgeop:edgeop,
              id:id
            }].concat(rest || []);
        },
      peg$c38 = function(id, attr) {
          return {
            type:'node_stmt',
            node_id:id,
            attr_list:attr || []
          };
        },
      peg$c39 = function(id, port) {
            return port ? {
              type:'node_id', id:id, port:port
            } : {
              type:'node_id', id:id
            };
        },
      peg$c40 = peg$otherExpectation("port"),
      peg$c41 = ":",
      peg$c42 = peg$literalExpectation(":", false),
      peg$c43 = function(id, pt) {return pt},
      peg$c44 = function(id, pt) {
          return {
            type:'port',
            id:id,
            compass_pt:pt || null
          };
        },
      peg$c45 = function(pt) {
          return {
            type:'port',
            compass_pt:pt || null
          }
        },
      peg$c46 = "subgraph",
      peg$c47 = peg$literalExpectation("subgraph", true),
      peg$c48 = function(id) {
              return id ? {
                type:'subgraph', id:id
              } : {
                type:'subgraph'
              }
            },
      peg$c49 = function(g, s) {
              g = g || {
                type:'subgraph'
              };
              g.children = s || [];
              return g;
            },
      peg$c50 = "n",
      peg$c51 = peg$literalExpectation("n", false),
      peg$c52 = "ne",
      peg$c53 = peg$literalExpectation("ne", false),
      peg$c54 = "e",
      peg$c55 = peg$literalExpectation("e", false),
      peg$c56 = "se",
      peg$c57 = peg$literalExpectation("se", false),
      peg$c58 = "s",
      peg$c59 = peg$literalExpectation("s", false),
      peg$c60 = "sw",
      peg$c61 = peg$literalExpectation("sw", false),
      peg$c62 = "w",
      peg$c63 = peg$literalExpectation("w", false),
      peg$c64 = "nw",
      peg$c65 = peg$literalExpectation("nw", false),
      peg$c66 = peg$otherExpectation("UNICODE_STRING"),
      peg$c67 = function(first, rest) {
            return first + rest.join('');
          },
      peg$c68 = function(first, rest) {
          return first + rest;
        },
      peg$c69 = "$",
      peg$c70 = peg$literalExpectation("$", false),
      peg$c71 = "_",
      peg$c72 = peg$literalExpectation("_", false),
      peg$c73 = peg$otherExpectation("NUMBER"),
      peg$c74 = "-",
      peg$c75 = peg$literalExpectation("-", false),
      peg$c76 = ".",
      peg$c77 = peg$literalExpectation(".", false),
      peg$c78 = /^[0-9]/,
      peg$c79 = peg$classExpectation([["0", "9"]], false, false),
      peg$c80 = function(n) {
             return parseFloat(text());
          },
      peg$c81 = function(v) {
            return {
              type:'id',
              value:v.slice(1,v.length-1),
              html:true
            };
          },
      peg$c82 = "<",
      peg$c83 = peg$literalExpectation("<", false),
      peg$c84 = ">",
      peg$c85 = peg$literalExpectation(">", false),
      peg$c86 = function(v) {
            return '<' + v.join('') + '>';
          },
      peg$c87 = peg$anyExpectation(),
      peg$c88 = function(v) { return v; },
      peg$c89 = function(v) { return v.join(""); },
      peg$c90 = "\"",
      peg$c91 = peg$literalExpectation("\"", false),
      peg$c92 = function(chars) { return chars.join(""); },
      peg$c93 = function() { return text(); },
      peg$c94 = "\\",
      peg$c95 = peg$literalExpectation("\\", false),
      peg$c96 = function(v) { return v[1] === '"' ? '"' : v[0] + v[1]; },
      peg$c97 = function() { return ""; },
      peg$c98 = /^[\n\r\u2028\u2029]/,
      peg$c99 = peg$classExpectation(["\n", "\r", "\u2028", "\u2029"], false, false),
      peg$c100 = peg$otherExpectation("end of line"),
      peg$c101 = "\n",
      peg$c102 = peg$literalExpectation("\n", false),
      peg$c103 = "\r\n",
      peg$c104 = peg$literalExpectation("\r\n", false),
      peg$c105 = "\r",
      peg$c106 = peg$literalExpectation("\r", false),
      peg$c107 = "\u2028",
      peg$c108 = peg$literalExpectation("\u2028", false),
      peg$c109 = "\u2029",
      peg$c110 = peg$literalExpectation("\u2029", false),
      peg$c111 = /^[^"\\\0-\x1F\x7F]/,
      peg$c112 = peg$classExpectation(["\"", "\\", ["\0", "\x1F"], "\x7F"], true, false),
      peg$c113 = "\\\"",
      peg$c114 = peg$literalExpectation("\\\"", false),
      peg$c115 = function() { return '"'; },
      peg$c116 = function() { return '\\'; },
      peg$c117 = peg$otherExpectation("COMMENT"),
      peg$c118 = peg$otherExpectation("BLOCK_COMMENT"),
      peg$c119 = "/*",
      peg$c120 = peg$literalExpectation("/*", false),
      peg$c121 = "*/",
      peg$c122 = peg$literalExpectation("*/", false),
      peg$c123 = function(v) {return v;},
      peg$c124 = function(v) { return v.join('') },
      peg$c125 = peg$otherExpectation("C_COMMENT"),
      peg$c126 = "//",
      peg$c127 = peg$literalExpectation("//", false),
      peg$c128 = /^[\n]/,
      peg$c129 = peg$classExpectation(["\n"], false, false),
      peg$c130 = function(v) { return v.join(''); },
      peg$c131 = peg$otherExpectation("MACRO_COMMENT"),
      peg$c132 = "#",
      peg$c133 = peg$literalExpectation("#", false),
      peg$c134 = peg$otherExpectation("WHITESPACE"),
      peg$c135 = /^[\n\r]/,
      peg$c136 = peg$classExpectation(["\n", "\r"], false, false),
      peg$c137 = /^[ \t]/,
      peg$c138 = peg$classExpectation([" ", "\t"], false, false),
      peg$c139 = /^[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137-\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148-\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C-\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA-\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9-\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC-\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF-\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F-\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0-\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB-\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE-\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6-\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FC7\u1FD0-\u1FD3\u1FD6-\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6-\u1FF7\u210A\u210E-\u210F\u2113\u212F\u2134\u2139\u213C-\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65-\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73-\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3-\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]/,
      peg$c140 = peg$classExpectation([["a", "z"], "\xB5", ["\xDF", "\xF6"], ["\xF8", "\xFF"], "\u0101", "\u0103", "\u0105", "\u0107", "\u0109", "\u010B", "\u010D", "\u010F", "\u0111", "\u0113", "\u0115", "\u0117", "\u0119", "\u011B", "\u011D", "\u011F", "\u0121", "\u0123", "\u0125", "\u0127", "\u0129", "\u012B", "\u012D", "\u012F", "\u0131", "\u0133", "\u0135", ["\u0137", "\u0138"], "\u013A", "\u013C", "\u013E", "\u0140", "\u0142", "\u0144", "\u0146", ["\u0148", "\u0149"], "\u014B", "\u014D", "\u014F", "\u0151", "\u0153", "\u0155", "\u0157", "\u0159", "\u015B", "\u015D", "\u015F", "\u0161", "\u0163", "\u0165", "\u0167", "\u0169", "\u016B", "\u016D", "\u016F", "\u0171", "\u0173", "\u0175", "\u0177", "\u017A", "\u017C", ["\u017E", "\u0180"], "\u0183", "\u0185", "\u0188", ["\u018C", "\u018D"], "\u0192", "\u0195", ["\u0199", "\u019B"], "\u019E", "\u01A1", "\u01A3", "\u01A5", "\u01A8", ["\u01AA", "\u01AB"], "\u01AD", "\u01B0", "\u01B4", "\u01B6", ["\u01B9", "\u01BA"], ["\u01BD", "\u01BF"], "\u01C6", "\u01C9", "\u01CC", "\u01CE", "\u01D0", "\u01D2", "\u01D4", "\u01D6", "\u01D8", "\u01DA", ["\u01DC", "\u01DD"], "\u01DF", "\u01E1", "\u01E3", "\u01E5", "\u01E7", "\u01E9", "\u01EB", "\u01ED", ["\u01EF", "\u01F0"], "\u01F3", "\u01F5", "\u01F9", "\u01FB", "\u01FD", "\u01FF", "\u0201", "\u0203", "\u0205", "\u0207", "\u0209", "\u020B", "\u020D", "\u020F", "\u0211", "\u0213", "\u0215", "\u0217", "\u0219", "\u021B", "\u021D", "\u021F", "\u0221", "\u0223", "\u0225", "\u0227", "\u0229", "\u022B", "\u022D", "\u022F", "\u0231", ["\u0233", "\u0239"], "\u023C", ["\u023F", "\u0240"], "\u0242", "\u0247", "\u0249", "\u024B", "\u024D", ["\u024F", "\u0293"], ["\u0295", "\u02AF"], "\u0371", "\u0373", "\u0377", ["\u037B", "\u037D"], "\u0390", ["\u03AC", "\u03CE"], ["\u03D0", "\u03D1"], ["\u03D5", "\u03D7"], "\u03D9", "\u03DB", "\u03DD", "\u03DF", "\u03E1", "\u03E3", "\u03E5", "\u03E7", "\u03E9", "\u03EB", "\u03ED", ["\u03EF", "\u03F3"], "\u03F5", "\u03F8", ["\u03FB", "\u03FC"], ["\u0430", "\u045F"], "\u0461", "\u0463", "\u0465", "\u0467", "\u0469", "\u046B", "\u046D", "\u046F", "\u0471", "\u0473", "\u0475", "\u0477", "\u0479", "\u047B", "\u047D", "\u047F", "\u0481", "\u048B", "\u048D", "\u048F", "\u0491", "\u0493", "\u0495", "\u0497", "\u0499", "\u049B", "\u049D", "\u049F", "\u04A1", "\u04A3", "\u04A5", "\u04A7", "\u04A9", "\u04AB", "\u04AD", "\u04AF", "\u04B1", "\u04B3", "\u04B5", "\u04B7", "\u04B9", "\u04BB", "\u04BD", "\u04BF", "\u04C2", "\u04C4", "\u04C6", "\u04C8", "\u04CA", "\u04CC", ["\u04CE", "\u04CF"], "\u04D1", "\u04D3", "\u04D5", "\u04D7", "\u04D9", "\u04DB", "\u04DD", "\u04DF", "\u04E1", "\u04E3", "\u04E5", "\u04E7", "\u04E9", "\u04EB", "\u04ED", "\u04EF", "\u04F1", "\u04F3", "\u04F5", "\u04F7", "\u04F9", "\u04FB", "\u04FD", "\u04FF", "\u0501", "\u0503", "\u0505", "\u0507", "\u0509", "\u050B", "\u050D", "\u050F", "\u0511", "\u0513", "\u0515", "\u0517", "\u0519", "\u051B", "\u051D", "\u051F", "\u0521", "\u0523", "\u0525", "\u0527", ["\u0561", "\u0587"], ["\u1D00", "\u1D2B"], ["\u1D6B", "\u1D77"], ["\u1D79", "\u1D9A"], "\u1E01", "\u1E03", "\u1E05", "\u1E07", "\u1E09", "\u1E0B", "\u1E0D", "\u1E0F", "\u1E11", "\u1E13", "\u1E15", "\u1E17", "\u1E19", "\u1E1B", "\u1E1D", "\u1E1F", "\u1E21", "\u1E23", "\u1E25", "\u1E27", "\u1E29", "\u1E2B", "\u1E2D", "\u1E2F", "\u1E31", "\u1E33", "\u1E35", "\u1E37", "\u1E39", "\u1E3B", "\u1E3D", "\u1E3F", "\u1E41", "\u1E43", "\u1E45", "\u1E47", "\u1E49", "\u1E4B", "\u1E4D", "\u1E4F", "\u1E51", "\u1E53", "\u1E55", "\u1E57", "\u1E59", "\u1E5B", "\u1E5D", "\u1E5F", "\u1E61", "\u1E63", "\u1E65", "\u1E67", "\u1E69", "\u1E6B", "\u1E6D", "\u1E6F", "\u1E71", "\u1E73", "\u1E75", "\u1E77", "\u1E79", "\u1E7B", "\u1E7D", "\u1E7F", "\u1E81", "\u1E83", "\u1E85", "\u1E87", "\u1E89", "\u1E8B", "\u1E8D", "\u1E8F", "\u1E91", "\u1E93", ["\u1E95", "\u1E9D"], "\u1E9F", "\u1EA1", "\u1EA3", "\u1EA5", "\u1EA7", "\u1EA9", "\u1EAB", "\u1EAD", "\u1EAF", "\u1EB1", "\u1EB3", "\u1EB5", "\u1EB7", "\u1EB9", "\u1EBB", "\u1EBD", "\u1EBF", "\u1EC1", "\u1EC3", "\u1EC5", "\u1EC7", "\u1EC9", "\u1ECB", "\u1ECD", "\u1ECF", "\u1ED1", "\u1ED3", "\u1ED5", "\u1ED7", "\u1ED9", "\u1EDB", "\u1EDD", "\u1EDF", "\u1EE1", "\u1EE3", "\u1EE5", "\u1EE7", "\u1EE9", "\u1EEB", "\u1EED", "\u1EEF", "\u1EF1", "\u1EF3", "\u1EF5", "\u1EF7", "\u1EF9", "\u1EFB", "\u1EFD", ["\u1EFF", "\u1F07"], ["\u1F10", "\u1F15"], ["\u1F20", "\u1F27"], ["\u1F30", "\u1F37"], ["\u1F40", "\u1F45"], ["\u1F50", "\u1F57"], ["\u1F60", "\u1F67"], ["\u1F70", "\u1F7D"], ["\u1F80", "\u1F87"], ["\u1F90", "\u1F97"], ["\u1FA0", "\u1FA7"], ["\u1FB0", "\u1FB4"], ["\u1FB6", "\u1FB7"], "\u1FBE", ["\u1FC2", "\u1FC4"], ["\u1FC6", "\u1FC7"], ["\u1FD0", "\u1FD3"], ["\u1FD6", "\u1FD7"], ["\u1FE0", "\u1FE7"], ["\u1FF2", "\u1FF4"], ["\u1FF6", "\u1FF7"], "\u210A", ["\u210E", "\u210F"], "\u2113", "\u212F", "\u2134", "\u2139", ["\u213C", "\u213D"], ["\u2146", "\u2149"], "\u214E", "\u2184", ["\u2C30", "\u2C5E"], "\u2C61", ["\u2C65", "\u2C66"], "\u2C68", "\u2C6A", "\u2C6C", "\u2C71", ["\u2C73", "\u2C74"], ["\u2C76", "\u2C7B"], "\u2C81", "\u2C83", "\u2C85", "\u2C87", "\u2C89", "\u2C8B", "\u2C8D", "\u2C8F", "\u2C91", "\u2C93", "\u2C95", "\u2C97", "\u2C99", "\u2C9B", "\u2C9D", "\u2C9F", "\u2CA1", "\u2CA3", "\u2CA5", "\u2CA7", "\u2CA9", "\u2CAB", "\u2CAD", "\u2CAF", "\u2CB1", "\u2CB3", "\u2CB5", "\u2CB7", "\u2CB9", "\u2CBB", "\u2CBD", "\u2CBF", "\u2CC1", "\u2CC3", "\u2CC5", "\u2CC7", "\u2CC9", "\u2CCB", "\u2CCD", "\u2CCF", "\u2CD1", "\u2CD3", "\u2CD5", "\u2CD7", "\u2CD9", "\u2CDB", "\u2CDD", "\u2CDF", "\u2CE1", ["\u2CE3", "\u2CE4"], "\u2CEC", "\u2CEE", "\u2CF3", ["\u2D00", "\u2D25"], "\u2D27", "\u2D2D", "\uA641", "\uA643", "\uA645", "\uA647", "\uA649", "\uA64B", "\uA64D", "\uA64F", "\uA651", "\uA653", "\uA655", "\uA657", "\uA659", "\uA65B", "\uA65D", "\uA65F", "\uA661", "\uA663", "\uA665", "\uA667", "\uA669", "\uA66B", "\uA66D", "\uA681", "\uA683", "\uA685", "\uA687", "\uA689", "\uA68B", "\uA68D", "\uA68F", "\uA691", "\uA693", "\uA695", "\uA697", "\uA723", "\uA725", "\uA727", "\uA729", "\uA72B", "\uA72D", ["\uA72F", "\uA731"], "\uA733", "\uA735", "\uA737", "\uA739", "\uA73B", "\uA73D", "\uA73F", "\uA741", "\uA743", "\uA745", "\uA747", "\uA749", "\uA74B", "\uA74D", "\uA74F", "\uA751", "\uA753", "\uA755", "\uA757", "\uA759", "\uA75B", "\uA75D", "\uA75F", "\uA761", "\uA763", "\uA765", "\uA767", "\uA769", "\uA76B", "\uA76D", "\uA76F", ["\uA771", "\uA778"], "\uA77A", "\uA77C", "\uA77F", "\uA781", "\uA783", "\uA785", "\uA787", "\uA78C", "\uA78E", "\uA791", "\uA793", "\uA7A1", "\uA7A3", "\uA7A5", "\uA7A7", "\uA7A9", "\uA7FA", ["\uFB00", "\uFB06"], ["\uFB13", "\uFB17"], ["\uFF41", "\uFF5A"]], false, false),
      peg$c141 = /^[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5-\u06E6\u07F4-\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C-\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D-\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA7F8-\uA7F9\uA9CF\uAA70\uAADD\uAAF3-\uAAF4\uFF70\uFF9E-\uFF9F]/,
      peg$c142 = peg$classExpectation([["\u02B0", "\u02C1"], ["\u02C6", "\u02D1"], ["\u02E0", "\u02E4"], "\u02EC", "\u02EE", "\u0374", "\u037A", "\u0559", "\u0640", ["\u06E5", "\u06E6"], ["\u07F4", "\u07F5"], "\u07FA", "\u081A", "\u0824", "\u0828", "\u0971", "\u0E46", "\u0EC6", "\u10FC", "\u17D7", "\u1843", "\u1AA7", ["\u1C78", "\u1C7D"], ["\u1D2C", "\u1D6A"], "\u1D78", ["\u1D9B", "\u1DBF"], "\u2071", "\u207F", ["\u2090", "\u209C"], ["\u2C7C", "\u2C7D"], "\u2D6F", "\u2E2F", "\u3005", ["\u3031", "\u3035"], "\u303B", ["\u309D", "\u309E"], ["\u30FC", "\u30FE"], "\uA015", ["\uA4F8", "\uA4FD"], "\uA60C", "\uA67F", ["\uA717", "\uA71F"], "\uA770", "\uA788", ["\uA7F8", "\uA7F9"], "\uA9CF", "\uAA70", "\uAADD", ["\uAAF3", "\uAAF4"], "\uFF70", ["\uFF9E", "\uFF9F"]], false, false),
      peg$c143 = /^[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58-\u0C59\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0CF1-\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5-\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A-\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      peg$c144 = peg$classExpectation(["\xAA", "\xBA", "\u01BB", ["\u01C0", "\u01C3"], "\u0294", ["\u05D0", "\u05EA"], ["\u05F0", "\u05F2"], ["\u0620", "\u063F"], ["\u0641", "\u064A"], ["\u066E", "\u066F"], ["\u0671", "\u06D3"], "\u06D5", ["\u06EE", "\u06EF"], ["\u06FA", "\u06FC"], "\u06FF", "\u0710", ["\u0712", "\u072F"], ["\u074D", "\u07A5"], "\u07B1", ["\u07CA", "\u07EA"], ["\u0800", "\u0815"], ["\u0840", "\u0858"], "\u08A0", ["\u08A2", "\u08AC"], ["\u0904", "\u0939"], "\u093D", "\u0950", ["\u0958", "\u0961"], ["\u0972", "\u0977"], ["\u0979", "\u097F"], ["\u0985", "\u098C"], ["\u098F", "\u0990"], ["\u0993", "\u09A8"], ["\u09AA", "\u09B0"], "\u09B2", ["\u09B6", "\u09B9"], "\u09BD", "\u09CE", ["\u09DC", "\u09DD"], ["\u09DF", "\u09E1"], ["\u09F0", "\u09F1"], ["\u0A05", "\u0A0A"], ["\u0A0F", "\u0A10"], ["\u0A13", "\u0A28"], ["\u0A2A", "\u0A30"], ["\u0A32", "\u0A33"], ["\u0A35", "\u0A36"], ["\u0A38", "\u0A39"], ["\u0A59", "\u0A5C"], "\u0A5E", ["\u0A72", "\u0A74"], ["\u0A85", "\u0A8D"], ["\u0A8F", "\u0A91"], ["\u0A93", "\u0AA8"], ["\u0AAA", "\u0AB0"], ["\u0AB2", "\u0AB3"], ["\u0AB5", "\u0AB9"], "\u0ABD", "\u0AD0", ["\u0AE0", "\u0AE1"], ["\u0B05", "\u0B0C"], ["\u0B0F", "\u0B10"], ["\u0B13", "\u0B28"], ["\u0B2A", "\u0B30"], ["\u0B32", "\u0B33"], ["\u0B35", "\u0B39"], "\u0B3D", ["\u0B5C", "\u0B5D"], ["\u0B5F", "\u0B61"], "\u0B71", "\u0B83", ["\u0B85", "\u0B8A"], ["\u0B8E", "\u0B90"], ["\u0B92", "\u0B95"], ["\u0B99", "\u0B9A"], "\u0B9C", ["\u0B9E", "\u0B9F"], ["\u0BA3", "\u0BA4"], ["\u0BA8", "\u0BAA"], ["\u0BAE", "\u0BB9"], "\u0BD0", ["\u0C05", "\u0C0C"], ["\u0C0E", "\u0C10"], ["\u0C12", "\u0C28"], ["\u0C2A", "\u0C33"], ["\u0C35", "\u0C39"], "\u0C3D", ["\u0C58", "\u0C59"], ["\u0C60", "\u0C61"], ["\u0C85", "\u0C8C"], ["\u0C8E", "\u0C90"], ["\u0C92", "\u0CA8"], ["\u0CAA", "\u0CB3"], ["\u0CB5", "\u0CB9"], "\u0CBD", "\u0CDE", ["\u0CE0", "\u0CE1"], ["\u0CF1", "\u0CF2"], ["\u0D05", "\u0D0C"], ["\u0D0E", "\u0D10"], ["\u0D12", "\u0D3A"], "\u0D3D", "\u0D4E", ["\u0D60", "\u0D61"], ["\u0D7A", "\u0D7F"], ["\u0D85", "\u0D96"], ["\u0D9A", "\u0DB1"], ["\u0DB3", "\u0DBB"], "\u0DBD", ["\u0DC0", "\u0DC6"], ["\u0E01", "\u0E30"], ["\u0E32", "\u0E33"], ["\u0E40", "\u0E45"], ["\u0E81", "\u0E82"], "\u0E84", ["\u0E87", "\u0E88"], "\u0E8A", "\u0E8D", ["\u0E94", "\u0E97"], ["\u0E99", "\u0E9F"], ["\u0EA1", "\u0EA3"], "\u0EA5", "\u0EA7", ["\u0EAA", "\u0EAB"], ["\u0EAD", "\u0EB0"], ["\u0EB2", "\u0EB3"], "\u0EBD", ["\u0EC0", "\u0EC4"], ["\u0EDC", "\u0EDF"], "\u0F00", ["\u0F40", "\u0F47"], ["\u0F49", "\u0F6C"], ["\u0F88", "\u0F8C"], ["\u1000", "\u102A"], "\u103F", ["\u1050", "\u1055"], ["\u105A", "\u105D"], "\u1061", ["\u1065", "\u1066"], ["\u106E", "\u1070"], ["\u1075", "\u1081"], "\u108E", ["\u10D0", "\u10FA"], ["\u10FD", "\u1248"], ["\u124A", "\u124D"], ["\u1250", "\u1256"], "\u1258", ["\u125A", "\u125D"], ["\u1260", "\u1288"], ["\u128A", "\u128D"], ["\u1290", "\u12B0"], ["\u12B2", "\u12B5"], ["\u12B8", "\u12BE"], "\u12C0", ["\u12C2", "\u12C5"], ["\u12C8", "\u12D6"], ["\u12D8", "\u1310"], ["\u1312", "\u1315"], ["\u1318", "\u135A"], ["\u1380", "\u138F"], ["\u13A0", "\u13F4"], ["\u1401", "\u166C"], ["\u166F", "\u167F"], ["\u1681", "\u169A"], ["\u16A0", "\u16EA"], ["\u1700", "\u170C"], ["\u170E", "\u1711"], ["\u1720", "\u1731"], ["\u1740", "\u1751"], ["\u1760", "\u176C"], ["\u176E", "\u1770"], ["\u1780", "\u17B3"], "\u17DC", ["\u1820", "\u1842"], ["\u1844", "\u1877"], ["\u1880", "\u18A8"], "\u18AA", ["\u18B0", "\u18F5"], ["\u1900", "\u191C"], ["\u1950", "\u196D"], ["\u1970", "\u1974"], ["\u1980", "\u19AB"], ["\u19C1", "\u19C7"], ["\u1A00", "\u1A16"], ["\u1A20", "\u1A54"], ["\u1B05", "\u1B33"], ["\u1B45", "\u1B4B"], ["\u1B83", "\u1BA0"], ["\u1BAE", "\u1BAF"], ["\u1BBA", "\u1BE5"], ["\u1C00", "\u1C23"], ["\u1C4D", "\u1C4F"], ["\u1C5A", "\u1C77"], ["\u1CE9", "\u1CEC"], ["\u1CEE", "\u1CF1"], ["\u1CF5", "\u1CF6"], ["\u2135", "\u2138"], ["\u2D30", "\u2D67"], ["\u2D80", "\u2D96"], ["\u2DA0", "\u2DA6"], ["\u2DA8", "\u2DAE"], ["\u2DB0", "\u2DB6"], ["\u2DB8", "\u2DBE"], ["\u2DC0", "\u2DC6"], ["\u2DC8", "\u2DCE"], ["\u2DD0", "\u2DD6"], ["\u2DD8", "\u2DDE"], "\u3006", "\u303C", ["\u3041", "\u3096"], "\u309F", ["\u30A1", "\u30FA"], "\u30FF", ["\u3105", "\u312D"], ["\u3131", "\u318E"], ["\u31A0", "\u31BA"], ["\u31F0", "\u31FF"], ["\u3400", "\u4DB5"], ["\u4E00", "\u9FCC"], ["\uA000", "\uA014"], ["\uA016", "\uA48C"], ["\uA4D0", "\uA4F7"], ["\uA500", "\uA60B"], ["\uA610", "\uA61F"], ["\uA62A", "\uA62B"], "\uA66E", ["\uA6A0", "\uA6E5"], ["\uA7FB", "\uA801"], ["\uA803", "\uA805"], ["\uA807", "\uA80A"], ["\uA80C", "\uA822"], ["\uA840", "\uA873"], ["\uA882", "\uA8B3"], ["\uA8F2", "\uA8F7"], "\uA8FB", ["\uA90A", "\uA925"], ["\uA930", "\uA946"], ["\uA960", "\uA97C"], ["\uA984", "\uA9B2"], ["\uAA00", "\uAA28"], ["\uAA40", "\uAA42"], ["\uAA44", "\uAA4B"], ["\uAA60", "\uAA6F"], ["\uAA71", "\uAA76"], "\uAA7A", ["\uAA80", "\uAAAF"], "\uAAB1", ["\uAAB5", "\uAAB6"], ["\uAAB9", "\uAABD"], "\uAAC0", "\uAAC2", ["\uAADB", "\uAADC"], ["\uAAE0", "\uAAEA"], "\uAAF2", ["\uAB01", "\uAB06"], ["\uAB09", "\uAB0E"], ["\uAB11", "\uAB16"], ["\uAB20", "\uAB26"], ["\uAB28", "\uAB2E"], ["\uABC0", "\uABE2"], ["\uAC00", "\uD7A3"], ["\uD7B0", "\uD7C6"], ["\uD7CB", "\uD7FB"], ["\uF900", "\uFA6D"], ["\uFA70", "\uFAD9"], "\uFB1D", ["\uFB1F", "\uFB28"], ["\uFB2A", "\uFB36"], ["\uFB38", "\uFB3C"], "\uFB3E", ["\uFB40", "\uFB41"], ["\uFB43", "\uFB44"], ["\uFB46", "\uFBB1"], ["\uFBD3", "\uFD3D"], ["\uFD50", "\uFD8F"], ["\uFD92", "\uFDC7"], ["\uFDF0", "\uFDFB"], ["\uFE70", "\uFE74"], ["\uFE76", "\uFEFC"], ["\uFF66", "\uFF6F"], ["\uFF71", "\uFF9D"], ["\uFFA0", "\uFFBE"], ["\uFFC2", "\uFFC7"], ["\uFFCA", "\uFFCF"], ["\uFFD2", "\uFFD7"], ["\uFFDA", "\uFFDC"]], false, false),
      peg$c145 = /^[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
      peg$c146 = peg$classExpectation(["\u01C5", "\u01C8", "\u01CB", "\u01F2", ["\u1F88", "\u1F8F"], ["\u1F98", "\u1F9F"], ["\u1FA8", "\u1FAF"], "\u1FBC", "\u1FCC", "\u1FFC"], false, false),
      peg$c147 = /^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178-\u0179\u017B\u017D\u0181-\u0182\u0184\u0186-\u0187\u0189-\u018B\u018E-\u0191\u0193-\u0194\u0196-\u0198\u019C-\u019D\u019F-\u01A0\u01A2\u01A4\u01A6-\u01A7\u01A9\u01AC\u01AE-\u01AF\u01B1-\u01B3\u01B5\u01B7-\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A-\u023B\u023D-\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E-\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9-\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0-\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E-\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D-\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A]/,
      peg$c148 = peg$classExpectation([["A", "Z"], ["\xC0", "\xD6"], ["\xD8", "\xDE"], "\u0100", "\u0102", "\u0104", "\u0106", "\u0108", "\u010A", "\u010C", "\u010E", "\u0110", "\u0112", "\u0114", "\u0116", "\u0118", "\u011A", "\u011C", "\u011E", "\u0120", "\u0122", "\u0124", "\u0126", "\u0128", "\u012A", "\u012C", "\u012E", "\u0130", "\u0132", "\u0134", "\u0136", "\u0139", "\u013B", "\u013D", "\u013F", "\u0141", "\u0143", "\u0145", "\u0147", "\u014A", "\u014C", "\u014E", "\u0150", "\u0152", "\u0154", "\u0156", "\u0158", "\u015A", "\u015C", "\u015E", "\u0160", "\u0162", "\u0164", "\u0166", "\u0168", "\u016A", "\u016C", "\u016E", "\u0170", "\u0172", "\u0174", "\u0176", ["\u0178", "\u0179"], "\u017B", "\u017D", ["\u0181", "\u0182"], "\u0184", ["\u0186", "\u0187"], ["\u0189", "\u018B"], ["\u018E", "\u0191"], ["\u0193", "\u0194"], ["\u0196", "\u0198"], ["\u019C", "\u019D"], ["\u019F", "\u01A0"], "\u01A2", "\u01A4", ["\u01A6", "\u01A7"], "\u01A9", "\u01AC", ["\u01AE", "\u01AF"], ["\u01B1", "\u01B3"], "\u01B5", ["\u01B7", "\u01B8"], "\u01BC", "\u01C4", "\u01C7", "\u01CA", "\u01CD", "\u01CF", "\u01D1", "\u01D3", "\u01D5", "\u01D7", "\u01D9", "\u01DB", "\u01DE", "\u01E0", "\u01E2", "\u01E4", "\u01E6", "\u01E8", "\u01EA", "\u01EC", "\u01EE", "\u01F1", "\u01F4", ["\u01F6", "\u01F8"], "\u01FA", "\u01FC", "\u01FE", "\u0200", "\u0202", "\u0204", "\u0206", "\u0208", "\u020A", "\u020C", "\u020E", "\u0210", "\u0212", "\u0214", "\u0216", "\u0218", "\u021A", "\u021C", "\u021E", "\u0220", "\u0222", "\u0224", "\u0226", "\u0228", "\u022A", "\u022C", "\u022E", "\u0230", "\u0232", ["\u023A", "\u023B"], ["\u023D", "\u023E"], "\u0241", ["\u0243", "\u0246"], "\u0248", "\u024A", "\u024C", "\u024E", "\u0370", "\u0372", "\u0376", "\u0386", ["\u0388", "\u038A"], "\u038C", ["\u038E", "\u038F"], ["\u0391", "\u03A1"], ["\u03A3", "\u03AB"], "\u03CF", ["\u03D2", "\u03D4"], "\u03D8", "\u03DA", "\u03DC", "\u03DE", "\u03E0", "\u03E2", "\u03E4", "\u03E6", "\u03E8", "\u03EA", "\u03EC", "\u03EE", "\u03F4", "\u03F7", ["\u03F9", "\u03FA"], ["\u03FD", "\u042F"], "\u0460", "\u0462", "\u0464", "\u0466", "\u0468", "\u046A", "\u046C", "\u046E", "\u0470", "\u0472", "\u0474", "\u0476", "\u0478", "\u047A", "\u047C", "\u047E", "\u0480", "\u048A", "\u048C", "\u048E", "\u0490", "\u0492", "\u0494", "\u0496", "\u0498", "\u049A", "\u049C", "\u049E", "\u04A0", "\u04A2", "\u04A4", "\u04A6", "\u04A8", "\u04AA", "\u04AC", "\u04AE", "\u04B0", "\u04B2", "\u04B4", "\u04B6", "\u04B8", "\u04BA", "\u04BC", "\u04BE", ["\u04C0", "\u04C1"], "\u04C3", "\u04C5", "\u04C7", "\u04C9", "\u04CB", "\u04CD", "\u04D0", "\u04D2", "\u04D4", "\u04D6", "\u04D8", "\u04DA", "\u04DC", "\u04DE", "\u04E0", "\u04E2", "\u04E4", "\u04E6", "\u04E8", "\u04EA", "\u04EC", "\u04EE", "\u04F0", "\u04F2", "\u04F4", "\u04F6", "\u04F8", "\u04FA", "\u04FC", "\u04FE", "\u0500", "\u0502", "\u0504", "\u0506", "\u0508", "\u050A", "\u050C", "\u050E", "\u0510", "\u0512", "\u0514", "\u0516", "\u0518", "\u051A", "\u051C", "\u051E", "\u0520", "\u0522", "\u0524", "\u0526", ["\u0531", "\u0556"], ["\u10A0", "\u10C5"], "\u10C7", "\u10CD", "\u1E00", "\u1E02", "\u1E04", "\u1E06", "\u1E08", "\u1E0A", "\u1E0C", "\u1E0E", "\u1E10", "\u1E12", "\u1E14", "\u1E16", "\u1E18", "\u1E1A", "\u1E1C", "\u1E1E", "\u1E20", "\u1E22", "\u1E24", "\u1E26", "\u1E28", "\u1E2A", "\u1E2C", "\u1E2E", "\u1E30", "\u1E32", "\u1E34", "\u1E36", "\u1E38", "\u1E3A", "\u1E3C", "\u1E3E", "\u1E40", "\u1E42", "\u1E44", "\u1E46", "\u1E48", "\u1E4A", "\u1E4C", "\u1E4E", "\u1E50", "\u1E52", "\u1E54", "\u1E56", "\u1E58", "\u1E5A", "\u1E5C", "\u1E5E", "\u1E60", "\u1E62", "\u1E64", "\u1E66", "\u1E68", "\u1E6A", "\u1E6C", "\u1E6E", "\u1E70", "\u1E72", "\u1E74", "\u1E76", "\u1E78", "\u1E7A", "\u1E7C", "\u1E7E", "\u1E80", "\u1E82", "\u1E84", "\u1E86", "\u1E88", "\u1E8A", "\u1E8C", "\u1E8E", "\u1E90", "\u1E92", "\u1E94", "\u1E9E", "\u1EA0", "\u1EA2", "\u1EA4", "\u1EA6", "\u1EA8", "\u1EAA", "\u1EAC", "\u1EAE", "\u1EB0", "\u1EB2", "\u1EB4", "\u1EB6", "\u1EB8", "\u1EBA", "\u1EBC", "\u1EBE", "\u1EC0", "\u1EC2", "\u1EC4", "\u1EC6", "\u1EC8", "\u1ECA", "\u1ECC", "\u1ECE", "\u1ED0", "\u1ED2", "\u1ED4", "\u1ED6", "\u1ED8", "\u1EDA", "\u1EDC", "\u1EDE", "\u1EE0", "\u1EE2", "\u1EE4", "\u1EE6", "\u1EE8", "\u1EEA", "\u1EEC", "\u1EEE", "\u1EF0", "\u1EF2", "\u1EF4", "\u1EF6", "\u1EF8", "\u1EFA", "\u1EFC", "\u1EFE", ["\u1F08", "\u1F0F"], ["\u1F18", "\u1F1D"], ["\u1F28", "\u1F2F"], ["\u1F38", "\u1F3F"], ["\u1F48", "\u1F4D"], "\u1F59", "\u1F5B", "\u1F5D", "\u1F5F", ["\u1F68", "\u1F6F"], ["\u1FB8", "\u1FBB"], ["\u1FC8", "\u1FCB"], ["\u1FD8", "\u1FDB"], ["\u1FE8", "\u1FEC"], ["\u1FF8", "\u1FFB"], "\u2102", "\u2107", ["\u210B", "\u210D"], ["\u2110", "\u2112"], "\u2115", ["\u2119", "\u211D"], "\u2124", "\u2126", "\u2128", ["\u212A", "\u212D"], ["\u2130", "\u2133"], ["\u213E", "\u213F"], "\u2145", "\u2183", ["\u2C00", "\u2C2E"], "\u2C60", ["\u2C62", "\u2C64"], "\u2C67", "\u2C69", "\u2C6B", ["\u2C6D", "\u2C70"], "\u2C72", "\u2C75", ["\u2C7E", "\u2C80"], "\u2C82", "\u2C84", "\u2C86", "\u2C88", "\u2C8A", "\u2C8C", "\u2C8E", "\u2C90", "\u2C92", "\u2C94", "\u2C96", "\u2C98", "\u2C9A", "\u2C9C", "\u2C9E", "\u2CA0", "\u2CA2", "\u2CA4", "\u2CA6", "\u2CA8", "\u2CAA", "\u2CAC", "\u2CAE", "\u2CB0", "\u2CB2", "\u2CB4", "\u2CB6", "\u2CB8", "\u2CBA", "\u2CBC", "\u2CBE", "\u2CC0", "\u2CC2", "\u2CC4", "\u2CC6", "\u2CC8", "\u2CCA", "\u2CCC", "\u2CCE", "\u2CD0", "\u2CD2", "\u2CD4", "\u2CD6", "\u2CD8", "\u2CDA", "\u2CDC", "\u2CDE", "\u2CE0", "\u2CE2", "\u2CEB", "\u2CED", "\u2CF2", "\uA640", "\uA642", "\uA644", "\uA646", "\uA648", "\uA64A", "\uA64C", "\uA64E", "\uA650", "\uA652", "\uA654", "\uA656", "\uA658", "\uA65A", "\uA65C", "\uA65E", "\uA660", "\uA662", "\uA664", "\uA666", "\uA668", "\uA66A", "\uA66C", "\uA680", "\uA682", "\uA684", "\uA686", "\uA688", "\uA68A", "\uA68C", "\uA68E", "\uA690", "\uA692", "\uA694", "\uA696", "\uA722", "\uA724", "\uA726", "\uA728", "\uA72A", "\uA72C", "\uA72E", "\uA732", "\uA734", "\uA736", "\uA738", "\uA73A", "\uA73C", "\uA73E", "\uA740", "\uA742", "\uA744", "\uA746", "\uA748", "\uA74A", "\uA74C", "\uA74E", "\uA750", "\uA752", "\uA754", "\uA756", "\uA758", "\uA75A", "\uA75C", "\uA75E", "\uA760", "\uA762", "\uA764", "\uA766", "\uA768", "\uA76A", "\uA76C", "\uA76E", "\uA779", "\uA77B", ["\uA77D", "\uA77E"], "\uA780", "\uA782", "\uA784", "\uA786", "\uA78B", "\uA78D", "\uA790", "\uA792", "\uA7A0", "\uA7A2", "\uA7A4", "\uA7A6", "\uA7A8", "\uA7AA", ["\uFF21", "\uFF3A"]], false, false),
      peg$c149 = /^[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/,
      peg$c150 = peg$classExpectation([["\u16EE", "\u16F0"], ["\u2160", "\u2182"], ["\u2185", "\u2188"], "\u3007", ["\u3021", "\u3029"], ["\u3038", "\u303A"], ["\uA6E6", "\uA6EF"]], false, false),
      peg$c151 = /^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/,
      peg$c152 = peg$classExpectation([["0", "9"], ["\u0660", "\u0669"], ["\u06F0", "\u06F9"], ["\u07C0", "\u07C9"], ["\u0966", "\u096F"], ["\u09E6", "\u09EF"], ["\u0A66", "\u0A6F"], ["\u0AE6", "\u0AEF"], ["\u0B66", "\u0B6F"], ["\u0BE6", "\u0BEF"], ["\u0C66", "\u0C6F"], ["\u0CE6", "\u0CEF"], ["\u0D66", "\u0D6F"], ["\u0E50", "\u0E59"], ["\u0ED0", "\u0ED9"], ["\u0F20", "\u0F29"], ["\u1040", "\u1049"], ["\u1090", "\u1099"], ["\u17E0", "\u17E9"], ["\u1810", "\u1819"], ["\u1946", "\u194F"], ["\u19D0", "\u19D9"], ["\u1A80", "\u1A89"], ["\u1A90", "\u1A99"], ["\u1B50", "\u1B59"], ["\u1BB0", "\u1BB9"], ["\u1C40", "\u1C49"], ["\u1C50", "\u1C59"], ["\uA620", "\uA629"], ["\uA8D0", "\uA8D9"], ["\uA900", "\uA909"], ["\uA9D0", "\uA9D9"], ["\uAA50", "\uAA59"], ["\uABF0", "\uABF9"], ["\uFF10", "\uFF19"]], false, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsestart() {
    var s0, s1;

    s0 = [];
    s1 = peg$parsegraph();
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsegraph();
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsegraph() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c0) {
        s2 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c2) {
            s4 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s4 === peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c4) {
              s4 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c5); }
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseID();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 123) {
                    s8 = peg$c6;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c7); }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsestmt_list();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 125) {
                          s11 = peg$c8;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c9); }
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c10(s2, s4, s6, s9);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsestmt();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s4 = peg$c11;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c12); }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$parse_();
            if (s7 !== peg$FAILED) {
              s8 = peg$parsestmt();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_();
                if (s9 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s10 = peg$c11;
                    peg$currPos++;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c12); }
                  }
                  if (s10 === peg$FAILED) {
                    s10 = null;
                  }
                  if (s10 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s7 = peg$c13(s2, s8);
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                s8 = peg$parsestmt();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();
                  if (s9 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s10 = peg$c11;
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c12); }
                    }
                    if (s10 === peg$FAILED) {
                      s10 = null;
                    }
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = s6;
                      s7 = peg$c13(s2, s8);
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c14(s2, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseID();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c15;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseID();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c17(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseattr_stmt();
      if (s0 === peg$FAILED) {
        s0 = peg$parseedge_stmt();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesubgraph();
          if (s0 === peg$FAILED) {
            s0 = peg$parsenode_stmt();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseID();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s2 = peg$c15;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c16); }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseID();
                  if (s3 !== peg$FAILED) {
                    s1 = [s1, s2, s3];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseattr_stmt() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c2) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c3); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c18) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c20) {
          s1 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseattr_list();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c22(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseattr_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c23;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsea_list();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s6 = peg$c25;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c26); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseattr_list();
                  if (s8 === peg$FAILED) {
                    s8 = null;
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c27(s4, s8);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsea_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseID();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s5 = peg$c15;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseID();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c28(s2, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c29;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c30); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 59) {
                s5 = peg$c11;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c12); }
              }
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsea_list();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c31(s2, s3, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseedge_stmt() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesubgraph();
    if (s1 === peg$FAILED) {
      s1 = peg$parsenode_id();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseedgeRHS();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseattr_list();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseedgeRHS() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c33) {
        s2 = peg$c33;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s2 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c35) {
          s2 = peg$c35;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsesubgraph();
          if (s4 === peg$FAILED) {
            s4 = peg$parsenode_id();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseedgeRHS();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c37(s2, s4, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenode_stmt() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsenode_id();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseattr_list();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c38(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenode_id() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseID();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseport();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c39(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseport() {
    var s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      s1 = peg$c41;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c42); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseID();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 58) {
          s4 = peg$c41;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c42); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsecompass_pt();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c43(s2, s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c44(s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s1 = peg$c41;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecompass_pt();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c45(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c40); }
    }

    return s0;
  }

  function peg$parsesubgraph() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c46) {
      s2 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c47); }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseID();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c48(s4);
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 123) {
        s2 = peg$c6;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c7); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsestmt_list();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c8;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c9); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c49(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecompass_pt() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 110) {
      s0 = peg$c50;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c51); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c52) {
        s0 = peg$c52;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 101) {
          s0 = peg$c54;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c55); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c56) {
            s0 = peg$c56;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c57); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 115) {
              s0 = peg$c58;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c59); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c60) {
                s0 = peg$c60;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c61); }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 119) {
                  s0 = peg$c62;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c63); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c64) {
                    s0 = peg$c64;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c65); }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseID() {
    var s0;

    s0 = peg$parseSTRING();
    if (s0 === peg$FAILED) {
      s0 = peg$parseNUMBER_STRING();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNUMBER();
        if (s0 === peg$FAILED) {
          s0 = peg$parseQUOTED_STRING();
          if (s0 === peg$FAILED) {
            s0 = peg$parseHTML_STRING();
          }
        }
      }
    }

    return s0;
  }

  function peg$parseSTRING() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseStringStart();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseStringPart();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseStringPart();
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c67(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }

    return s0;
  }

  function peg$parseNUMBER_STRING() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseNUMBER();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSTRING();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c68(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseStringStart() {
    var s0;

    s0 = peg$parseUnicodeLetter();
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 36) {
        s0 = peg$c69;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 95) {
          s0 = peg$c71;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c72); }
        }
      }
    }

    return s0;
  }

  function peg$parseStringPart() {
    var s0;

    s0 = peg$parseStringStart();
    if (s0 === peg$FAILED) {
      s0 = peg$parseNd();
    }

    return s0;
  }

  function peg$parseNUMBER() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s2 = peg$c74;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c75); }
    }
    if (s2 === peg$FAILED) {
      s2 = null;
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s4 = peg$c76;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c77); }
      }
      if (s4 !== peg$FAILED) {
        s5 = [];
        if (peg$c78.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c79); }
        }
        if (s6 !== peg$FAILED) {
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$c78.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c79); }
            }
          }
        } else {
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        if (peg$c78.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c79); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c78.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c79); }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c76;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c77); }
          }
          if (s6 !== peg$FAILED) {
            s7 = [];
            if (peg$c78.test(input.charAt(peg$currPos))) {
              s8 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c79); }
            }
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$c78.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c79); }
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c80(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c73); }
    }

    return s0;
  }

  function peg$parseHTML_STRING() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsehtml_raw_string();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c81(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsehtml_raw_string() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      s1 = peg$c82;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c83); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsehtml_char();
      if (s3 === peg$FAILED) {
        s3 = peg$parsehtml_raw_string();
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsehtml_char();
        if (s3 === peg$FAILED) {
          s3 = peg$parsehtml_raw_string();
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s3 = peg$c84;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c85); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c86(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsehtml_char() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 62) {
      s4 = peg$c84;
      peg$currPos++;
    } else {
      s4 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c85); }
    }
    if (s4 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 60) {
        s4 = peg$c82;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }
    }
    peg$silentFails--;
    if (s4 === peg$FAILED) {
      s3 = void 0;
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c87); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c88(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 62) {
          s4 = peg$c84;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c85); }
        }
        if (s4 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 60) {
            s4 = peg$c82;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c83); }
          }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c88(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c89(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseQUOTED_STRING() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c90;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c91); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseDoubleStringCharacter();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseDoubleStringCharacter();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c90;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c91); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c92(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDoubleStringCharacter() {
    var s0, s1, s2;

    s0 = peg$parseQuoteEscape();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c90;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c91); }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$parseLineTerminator();
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c93();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseLineContinuation();
      }
    }

    return s0;
  }

  function peg$parseQuoteEscape() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s2 = peg$c94;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c95); }
    }
    if (s2 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c87); }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c96(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseLineContinuation() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s1 = peg$c94;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c95); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseLineTerminatorSequence();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c97();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseLineTerminator() {
    var s0;

    if (peg$c98.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c99); }
    }

    return s0;
  }

  function peg$parseLineTerminatorSequence() {
    var s0, s1;

    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 10) {
      s0 = peg$c101;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c102); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c103) {
        s0 = peg$c103;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c104); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c105;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c106); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 8232) {
            s0 = peg$c107;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c108); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 8233) {
              s0 = peg$c109;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c110); }
            }
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c100); }
    }

    return s0;
  }

  function peg$parseSourceCharacter() {
    var s0;

    if (input.length > peg$currPos) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c87); }
    }

    return s0;
  }

  function peg$parsechars() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsechar();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsechar();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c92(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsechar() {
    var s0, s1, s2;

    if (peg$c111.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c112); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c113) {
        s1 = peg$c113;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c114); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c115();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c94;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c95); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNEWLINE();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c97();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c94;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c95); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c116();
          }
          s0 = s1;
        }
      }
    }

    return s0;
  }

  function peg$parseCOMMENT() {
    var s0, s1;

    peg$silentFails++;
    s0 = peg$parseBLOCK_COMMENT();
    if (s0 === peg$FAILED) {
      s0 = peg$parseC_COMMENT();
      if (s0 === peg$FAILED) {
        s0 = peg$parseMACRO_COMMENT();
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c117); }
    }

    return s0;
  }

  function peg$parseBLOCK_COMMENT() {
    var s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c119) {
      s1 = peg$c119;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c120); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c121) {
        s5 = peg$c121;
        peg$currPos += 2;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c122); }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c87); }
        }
        if (s5 !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c123(s5);
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c121) {
          s5 = peg$c121;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c122); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c123(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c121) {
          s3 = peg$c121;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c122); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c124(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c118); }
    }

    return s0;
  }

  function peg$parseC_COMMENT() {
    var s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c126) {
      s1 = peg$c126;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c127); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (peg$c128.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c129); }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c87); }
        }
        if (s5 !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c88(s5);
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (peg$c128.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c129); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c88(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c128.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c129); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c130(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c125); }
    }

    return s0;
  }

  function peg$parseMACRO_COMMENT() {
    var s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 35) {
      s1 = peg$c132;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c133); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (peg$c128.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c129); }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c87); }
        }
        if (s5 !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c88(s5);
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (peg$c128.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c129); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c88(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c128.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c129); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c130(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c131); }
    }

    return s0;
  }

  function peg$parse_() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    s1 = peg$parseWHITESPACE();
    if (s1 === peg$FAILED) {
      s1 = peg$parseCOMMENT();
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parseWHITESPACE();
      if (s1 === peg$FAILED) {
        s1 = peg$parseCOMMENT();
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c134); }
    }

    return s0;
  }

  function peg$parseNEWLINE() {
    var s0, s1;

    s0 = [];
    if (peg$c135.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c136); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c135.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c136); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseWHITESPACE() {
    var s0, s1;

    s0 = [];
    if (peg$c137.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c138); }
    }
    if (s1 === peg$FAILED) {
      s1 = peg$parseNEWLINE();
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c137.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c138); }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$parseNEWLINE();
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseUnicodeLetter() {
    var s0;

    s0 = peg$parseLu();
    if (s0 === peg$FAILED) {
      s0 = peg$parseLl();
      if (s0 === peg$FAILED) {
        s0 = peg$parseLt();
        if (s0 === peg$FAILED) {
          s0 = peg$parseLm();
          if (s0 === peg$FAILED) {
            s0 = peg$parseLo();
            if (s0 === peg$FAILED) {
              s0 = peg$parseNl();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseLl() {
    var s0;

    if (peg$c139.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c140); }
    }

    return s0;
  }

  function peg$parseLm() {
    var s0;

    if (peg$c141.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c142); }
    }

    return s0;
  }

  function peg$parseLo() {
    var s0;

    if (peg$c143.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c144); }
    }

    return s0;
  }

  function peg$parseLt() {
    var s0;

    if (peg$c145.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c146); }
    }

    return s0;
  }

  function peg$parseLu() {
    var s0;

    if (peg$c147.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c148); }
    }

    return s0;
  }

  function peg$parseNl() {
    var s0;

    if (peg$c149.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c150); }
    }

    return s0;
  }

  function peg$parseNd() {
    var s0;

    if (peg$c151.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c152); }
    }

    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};


/***/ }),

/***/ "./node_modules/dotparser/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parser = __webpack_require__("./node_modules/dotparser/grammar/dot.js");
module.exports = parser.parse;


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/data-structures/base/index.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/data-structures/base/iterable-entry-base.js"), exports);
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/data-structures/base/iterable-element-base.js"), exports);


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/data-structures/base/iterable-element-base.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IterableElementBase = void 0;
class IterableElementBase {
    /**
     * The protected constructor initializes the options for the IterableElementBase class, including the
     * toElementFn function.
     * @param [options] - An optional object that contains the following properties:
     */
    constructor(options) {
        if (options) {
            const { toElementFn } = options;
            if (typeof toElementFn === 'function')
                this._toElementFn = toElementFn;
            else if (toElementFn)
                throw new TypeError('toElementFn must be a function type');
        }
    }
    /**
     * The function returns the _toElementFn property, which is a function that converts a raw element to
     * a specific type.
     * @returns The function `get toElementFn()` is returning either a function that takes a raw element
     * `rawElement` of type `R` and returns an element `E`, or `undefined` if no function is assigned to
     * `_toElementFn`.
     */
    get toElementFn() {
        return this._toElementFn;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function is an implementation of the Symbol.iterator method that returns an IterableIterator.
     * @param {any[]} args - The `args` parameter in the code snippet represents a rest parameter. It
     * allows the function to accept any number of arguments as an array. In this case, the `args`
     * parameter is used to pass any number of arguments to the `_getIterator` method.
     */
    *[Symbol.iterator](...args) {
        yield* this._getIterator(...args);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function returns an iterator that yields all the values in the object.
     */
    *values() {
        for (const item of this) {
            yield item;
        }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `every` function checks if every element in the array satisfies a given predicate.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * the current element being processed, its index, and the array it belongs to. It should return a
     * boolean value indicating whether the element satisfies a certain condition or not.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `predicate` function. If `thisArg` is
     * @returns The `every` method is returning a boolean value. It returns `true` if every element in
     * the array satisfies the provided predicate function, and `false` otherwise.
     */
    every(predicate, thisArg) {
        let index = 0;
        for (const item of this) {
            if (!predicate.call(thisArg, item, index++, this)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The "some" function checks if at least one element in a collection satisfies a given predicate.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * `value`, `index`, and `array`. It should return a boolean value indicating whether the current
     * element satisfies the condition.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as the `this` value when executing the `predicate` function. If `thisArg` is provided,
     * it will be passed as the `this` value to the `predicate` function. If `thisArg
     * @returns a boolean value. It returns true if the predicate function returns true for any element
     * in the collection, and false otherwise.
     */
    some(predicate, thisArg) {
        let index = 0;
        for (const item of this) {
            if (predicate.call(thisArg, item, index++, this)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `forEach` function iterates over each element in an array-like object and calls a callback
     * function for each element.
     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in
     * the array. It takes three arguments: the current element being processed, the index of the current
     * element, and the array that forEach was called upon.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will
     * be passed as the `this` value to the `callbackfn` function. If `thisArg
     */
    forEach(callbackfn, thisArg) {
        let index = 0;
        for (const item of this) {
            callbackfn.call(thisArg, item, index++, this);
        }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `find` function iterates over the elements of an array-like object and returns the first
     * element that satisfies the provided callback function.
     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in
     * the array. It takes three arguments: the current element being processed, the index of the current
     * element, and the array itself. The function should return a boolean value indicating whether the
     * current element matches the desired condition.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will
     * be passed as the `this` value to the `callbackfn` function. If `thisArg
     * @returns The `find` method returns the first element in the array that satisfies the provided
     * callback function. If no element satisfies the callback function, `undefined` is returned.
     */
    find(callbackfn, thisArg) {
        let index = 0;
        for (const item of this) {
            if (callbackfn.call(thisArg, item, index++, this))
                return item;
        }
        return;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function checks if a given element exists in a collection.
     * @param {E} element - The parameter "element" is of type E, which means it can be any type. It
     * represents the element that we want to check for existence in the collection.
     * @returns a boolean value. It returns true if the element is found in the collection, and false
     * otherwise.
     */
    has(element) {
        for (const ele of this) {
            if (ele === element)
                return true;
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `reduce` function iterates over the elements of an array-like object and applies a callback
     * function to reduce them into a single value.
     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in
     * the array. It takes four arguments:
     * @param {U} initialValue - The initialValue parameter is the initial value of the accumulator. It
     * is the value that the accumulator starts with before the reduction operation begins.
     * @returns The `reduce` method is returning the final value of the accumulator after iterating over
     * all the elements in the array and applying the callback function to each element.
     */
    reduce(callbackfn, initialValue) {
        let accumulator = initialValue;
        let index = 0;
        for (const item of this) {
            accumulator = callbackfn(accumulator, item, index++, this);
        }
        return accumulator;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The print function logs the elements of an array to the console.
     */
    print() {
        console.log([...this]);
    }
}
exports.IterableElementBase = IterableElementBase;


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/data-structures/base/iterable-entry-base.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IterableEntryBase = void 0;
class IterableEntryBase {
    // protected _toEntryFn?: (rawElement: R) => BTNEntry<K, V>;
    //
    // /**
    //  * The function returns the value of the _toEntryFn property.
    //  * @returns The function being returned is `this._toEntryFn`.
    //  */
    // get toEntryFn() {
    //   return this._toEntryFn;
    // }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function is an implementation of the Symbol.iterator method that returns an iterable iterator.
     * @param {any[]} args - The `args` parameter in the code snippet represents a rest parameter. It
     * allows the function to accept any number of arguments as an array. In this case, the `args`
     * parameter is used to pass any additional arguments to the `_getIterator` method.
     */
    *[Symbol.iterator](...args) {
        yield* this._getIterator(...args);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function returns an iterator that yields key-value pairs from the object, where the value can
     * be undefined.
     */
    *entries() {
        for (const item of this) {
            yield item;
        }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function returns an iterator that yields the keys of a data structure.
     */
    *keys() {
        for (const item of this) {
            yield item[0];
        }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function returns an iterator that yields the values of a collection.
     */
    *values() {
        for (const item of this) {
            yield item[1];
        }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `every` function checks if every element in a collection satisfies a given condition.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * `value`, `key`, and `index`. It should return a boolean value indicating whether the condition is
     * met for the current element in the iteration.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be
     * passed as the first argument to the `predicate` function. If `thisArg` is not provided
     * @returns The `every` method is returning a boolean value. It returns `true` if every element in
     * the collection satisfies the provided predicate function, and `false` otherwise.
     */
    every(predicate, thisArg) {
        let index = 0;
        for (const item of this) {
            if (!predicate.call(thisArg, item[1], item[0], index++, this)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The "some" function iterates over a collection and returns true if at least one element satisfies
     * a given predicate.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * `value`, `key`, and `index`. It should return a boolean value indicating whether the condition is
     * met for the current element in the iteration.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as the `this` value when executing the `predicate` function. If `thisArg` is provided,
     * it will be passed as the first argument to the `predicate` function. If `thisArg` is
     * @returns a boolean value. It returns true if the predicate function returns true for any pair in
     * the collection, and false otherwise.
     */
    some(predicate, thisArg) {
        let index = 0;
        for (const item of this) {
            if (predicate.call(thisArg, item[1], item[0], index++, this)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `forEach` function iterates over each key-value pair in a collection and executes a callback
     * function for each pair.
     * @param callbackfn - The callback function that will be called for each element in the collection.
     * It takes four parameters: the value of the current element, the key of the current element, the
     * index of the current element, and the collection itself.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. If `thisArg` is provided, it will be
     * used as the `this` value when calling the callback function. If `thisArg` is not provided, `
     */
    forEach(callbackfn, thisArg) {
        let index = 0;
        for (const item of this) {
            const [key, value] = item;
            callbackfn.call(thisArg, value, key, index++, this);
        }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `find` function iterates over the entries of a collection and returns the first value for
     * which the callback function returns true.
     * @param callbackfn - The callback function that will be called for each entry in the collection. It
     * takes three arguments: the value of the entry, the key of the entry, and the index of the entry in
     * the collection. It should return a boolean value indicating whether the current entry matches the
     * desired condition.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will
     * be passed as the `this` value to the `callbackfn` function. If `thisArg
     * @returns The method `find` returns the value of the first element in the iterable that satisfies
     * the provided callback function. If no element satisfies the callback function, `undefined` is
     * returned.
     */
    find(callbackfn, thisArg) {
        let index = 0;
        for (const item of this) {
            const [key, value] = item;
            if (callbackfn.call(thisArg, value, key, index++, this))
                return item;
        }
        return;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function checks if a given key exists in a collection.
     * @param {K} key - The parameter "key" is of type K, which means it can be any type. It represents
     * the key that we want to check for existence in the data structure.
     * @returns a boolean value. It returns true if the key is found in the collection, and false
     * otherwise.
     */
    has(key) {
        for (const item of this) {
            const [itemKey] = item;
            if (itemKey === key)
                return true;
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function checks if a given value exists in a collection.
     * @param {V} value - The parameter "value" is the value that we want to check if it exists in the
     * collection.
     * @returns a boolean value, either true or false.
     */
    hasValue(value) {
        for (const [, elementValue] of this) {
            if (elementValue === value)
                return true;
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `get` function retrieves the value associated with a given key from a collection.
     * @param {K} key - K (the type of the key) - This parameter represents the key that is being
     * searched for in the collection.
     * @returns The `get` method returns the value associated with the specified key if it exists in the
     * collection, otherwise it returns `undefined`.
     */
    get(key) {
        for (const item of this) {
            const [itemKey, value] = item;
            if (itemKey === key)
                return value;
        }
        return;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `reduce` function iterates over key-value pairs and applies a callback function to each pair,
     * accumulating a single value.
     * @param callbackfn - The callback function that will be called for each element in the collection.
     * It takes four arguments: the current accumulator value, the current value of the element, the key
     * of the element, and the index of the element in the collection. It should return the updated
     * accumulator value.
     * @param {U} initialValue - The `initialValue` parameter is the initial value of the accumulator. It
     * is the value that will be used as the first argument to the `callbackfn` function when reducing
     * the elements of the collection.
     * @returns The `reduce` method is returning the final value of the accumulator after iterating over
     * all the elements in the collection.
     */
    reduce(callbackfn, initialValue) {
        let accumulator = initialValue;
        let index = 0;
        for (const item of this) {
            const [key, value] = item;
            accumulator = callbackfn(accumulator, value, key, index++, this);
        }
        return accumulator;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The print function logs the elements of an array to the console.
     */
    print() {
        console.log([...this]);
    }
}
exports.IterableEntryBase = IterableEntryBase;


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/data-structures/linked-list/doubly-linked-list.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DoublyLinkedList = exports.DoublyLinkedListNode = void 0;
const base_1 = __webpack_require__("./node_modules/linked-list-typed/dist/data-structures/base/index.js");
class DoublyLinkedListNode {
    /**
     * The constructor function initializes the value, next, and previous properties of an object.
     * @param {E} value - The "value" parameter is the value that will be stored in the node. It can be of any data type, as it
     * is defined as a generic type "E".
     */
    constructor(value) {
        this._value = value;
        this._next = undefined;
        this._prev = undefined;
    }
    /**
     * The function returns the value of a protected variable.
     * @returns The value of the variable `_value` is being returned.
     */
    get value() {
        return this._value;
    }
    /**
     * The above function sets the value of a variable.
     * @param {E} value - The parameter "value" is of type E, which means it can be any type.
     */
    set value(value) {
        this._value = value;
    }
    /**
     * The "next" function returns the next node in a doubly linked list.
     * @returns The `next` property is being returned. It can be either a `DoublyLinkedListNode<E>`
     * object or `undefined`.
     */
    get next() {
        return this._next;
    }
    /**
     * The "next" property of a DoublyLinkedListNode is set to the provided value.
     * @param {DoublyLinkedListNode<E> | undefined} value - The `value` parameter is of type
     * `DoublyLinkedListNode<E> | undefined`. This means that it can accept either a
     * `DoublyLinkedListNode` object or `undefined` as its value.
     */
    set next(value) {
        this._next = value;
    }
    /**
     * The `prev` function returns the previous node in a doubly linked list.
     * @returns The `prev` property of the `DoublyLinkedListNode` class is being returned. It can either
     * be a `DoublyLinkedListNode` object or `undefined`.
     */
    get prev() {
        return this._prev;
    }
    /**
     * The function sets the previous node of a doubly linked list node.
     * @param {DoublyLinkedListNode<E> | undefined} value - The `value` parameter is of type
     * `DoublyLinkedListNode<E> | undefined`. This means that it can accept either a
     * `DoublyLinkedListNode` object or `undefined` as its value.
     */
    set prev(value) {
        this._prev = value;
    }
}
exports.DoublyLinkedListNode = DoublyLinkedListNode;
/**
 * 1. Node Structure: Each node contains three parts: a data field, a pointer (or reference) to the previous node, and a pointer to the next node. This structure allows traversal of the linked list in both directions.
 * 2. Bidirectional Traversal: Unlike singly linked lists, doubly linked lists can be easily traversed forwards or backwards. This makes insertions and deletions in the list more flexible and efficient.
 * 3. No Centralized Index: Unlike arrays, elements in a linked list are not stored contiguously, so there is no centralized index. Accessing elements in a linked list typically requires traversing from the head or tail node.
 * 4. High Efficiency in Insertion and Deletion: Adding or removing elements in a linked list does not require moving other elements, making these operations more efficient than in arrays.
 */
class DoublyLinkedList extends base_1.IterableElementBase {
    constructor(elements = [], options) {
        super(options);
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        if (elements) {
            for (const el of elements) {
                if (this.toElementFn) {
                    this.push(this.toElementFn(el));
                }
                else
                    this.push(el);
            }
        }
    }
    /**
     * The `head` function returns the first node of a doubly linked list.
     * @returns The method `getHead()` returns either a `DoublyLinkedListNode<E>` object or `undefined`.
     */
    get head() {
        return this._head;
    }
    /**
     * The `tail` function returns the last node of a doubly linked list.
     * @returns The `get tail()` method is returning either a `DoublyLinkedListNode<E>` object or
     * `undefined`.
     */
    get tail() {
        return this._tail;
    }
    /**
     * The function returns the size of an object.
     * @returns The size of the object, which is a number.
     */
    get size() {
        return this._size;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     * where n is the number of elements in the linked list.
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `get first` function returns the first node in a doubly linked list, or undefined if the list is empty.
     * @returns The method `get first()` returns the first node of the doubly linked list, or `undefined` if the list is empty.
     */
    get first() {
        var _a;
        return (_a = this.head) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `get last` function returns the last node in a doubly linked list, or undefined if the list is empty.
     * @returns The method `get last()` returns the last node of the doubly linked list, or `undefined` if the list is empty.
     */
    get last() {
        var _a;
        return (_a = this.tail) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `fromArray` function creates a new instance of a DoublyLinkedList and populates it with the elements from the
     * given array.
     * @param {E[]} data - The `data` parameter is an array of elements of type `E`.
     * @returns The `fromArray` function returns a DoublyLinkedList object.
     */
    static fromArray(data) {
        return new DoublyLinkedList(data);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * The push function adds a new element to the end of a doubly linked list.
     * @param {E} element - The "element" parameter represents the value that you want to add to the
     * doubly linked list.
     * @returns The `push` method is returning a boolean value, `true`.
     */
    push(element) {
        const newNode = new DoublyLinkedListNode(element);
        if (!this.head) {
            this._head = newNode;
            this._tail = newNode;
        }
        else {
            newNode.prev = this.tail;
            this.tail.next = newNode;
            this._tail = newNode;
        }
        this._size++;
        return true;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * The `pop()` function removes and returns the value of the last element in a linked list.
     * @returns The method is returning the value of the removed node.
     */
    pop() {
        if (!this.tail)
            return undefined;
        const removedNode = this.tail;
        if (this.head === this.tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else {
            this._tail = removedNode.prev;
            this.tail.next = undefined;
        }
        this._size--;
        return removedNode.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * The `shift()` function removes and returns the value of the first element in a doubly linked list.
     * @returns The value of the removed node.
     */
    shift() {
        if (!this.head)
            return undefined;
        const removedNode = this.head;
        if (this.head === this.tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else {
            this._head = removedNode.next;
            this.head.prev = undefined;
        }
        this._size--;
        return removedNode.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * The unshift function adds a new element to the beginning of a doubly linked list.
     * @param {E} element - The "element" parameter represents the value of the element that you want to
     * add to the beginning of the doubly linked list.
     * @returns The `unshift` method is returning a boolean value, `true`.
     */
    unshift(element) {
        const newNode = new DoublyLinkedListNode(element);
        if (!this.head) {
            this._head = newNode;
            this._tail = newNode;
        }
        else {
            newNode.next = this.head;
            this.head.prev = newNode;
            this._head = newNode;
        }
        this._size++;
        return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `at` function returns the value at a specified index in a linked list, or undefined if the index is out of bounds.
     * @param {number} index - The index parameter is a number that represents the position of the element we want to
     * retrieve from the list.
     * @returns The method is returning the value at the specified index in the linked list. If the index is out of bounds
     * or the linked list is empty, it will return undefined.
     */
    at(index) {
        if (index < 0 || index >= this.size)
            return undefined;
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        return current.value;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `getNodeAt` returns the node at a given index in a doubly linked list, or undefined if the index is out of
     * range.
     * @param {number} index - The `index` parameter is a number that represents the position of the node we want to
     * retrieve from the doubly linked list. It indicates the zero-based index of the node we want to access.
     * @returns The method `getNodeAt(index: number)` returns a `DoublyLinkedListNode<E>` object if the index is within the
     * valid range of the linked list, otherwise it returns `undefined`.
     */
    getNodeAt(index) {
        if (index < 0 || index >= this.size)
            return undefined;
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        return current;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `findNodeByValue` searches for a node with a specific value in a doubly linked list and returns the
     * node if found, otherwise it returns undefined.
     * @param {E} value - The `value` parameter is the value that we want to search for in the doubly linked list.
     * @returns The function `findNodeByValue` returns a `DoublyLinkedListNode<E>` if a node with the specified value `value`
     * is found in the linked list. If no such node is found, it returns `undefined`.
     */
    getNode(value) {
        let current = this.head;
        while (current) {
            if (current.value === value) {
                return current;
            }
            current = current.next;
        }
        return undefined;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `insert` function inserts a value at a specified index in a doubly linked list.
     * @param {number} index - The index parameter represents the position at which the new value should be inserted in the
     * DoublyLinkedList. It is of type number.
     * @param {E} value - The `value` parameter represents the value that you want to insert into the Doubly Linked List at the
     * specified index.
     * @returns The `insert` method returns a boolean value. It returns `true` if the insertion is successful, and `false`
     * if the index is out of bounds.
     */
    addAt(index, value) {
        if (index < 0 || index > this.size)
            return false;
        if (index === 0) {
            this.unshift(value);
            return true;
        }
        if (index === this.size) {
            this.push(value);
            return true;
        }
        const newNode = new DoublyLinkedListNode(value);
        const prevNode = this.getNodeAt(index - 1);
        const nextNode = prevNode.next;
        newNode.prev = prevNode;
        newNode.next = nextNode;
        prevNode.next = newNode;
        nextNode.prev = newNode;
        this._size++;
        return true;
    }
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     * where n is the number of elements in the linked list.
     */
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     *
     * The `addBefore` function inserts a new value before an existing value or node in a doubly linked list.
     * @param {E | DoublyLinkedListNode<E>} existingValueOrNode - The existing value or node in the doubly linked list
     * before which the new value will be inserted. It can be either the value of the existing node or the existing node
     * itself.
     * @param {E} newValue - The `newValue` parameter represents the value that you want to insert into the doubly linked
     * list.
     * @returns The method returns a boolean value. It returns `true` if the insertion is successful, and `false` if the
     * insertion fails.
     */
    addBefore(existingValueOrNode, newValue) {
        let existingNode;
        if (existingValueOrNode instanceof DoublyLinkedListNode) {
            existingNode = existingValueOrNode;
        }
        else {
            existingNode = this.getNode(existingValueOrNode);
        }
        if (existingNode) {
            const newNode = new DoublyLinkedListNode(newValue);
            newNode.prev = existingNode.prev;
            if (existingNode.prev) {
                existingNode.prev.next = newNode;
            }
            newNode.next = existingNode;
            existingNode.prev = newNode;
            if (existingNode === this.head) {
                this._head = newNode;
            }
            this._size++;
            return true;
        }
        return false;
    }
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     *
     * The `addAfter` function inserts a new node with a given value after an existing node in a doubly linked list.
     * @param {E | DoublyLinkedListNode<E>} existingValueOrNode - The existing value or node in the doubly linked list
     * after which the new value will be inserted. It can be either the value of the existing node or the existing node
     * itself.
     * @param {E} newValue - The value that you want to insert into the doubly linked list.
     * @returns The method returns a boolean value. It returns true if the insertion is successful, and false if the
     * existing value or node is not found in the doubly linked list.
     */
    addAfter(existingValueOrNode, newValue) {
        let existingNode;
        if (existingValueOrNode instanceof DoublyLinkedListNode) {
            existingNode = existingValueOrNode;
        }
        else {
            existingNode = this.getNode(existingValueOrNode);
        }
        if (existingNode) {
            const newNode = new DoublyLinkedListNode(newValue);
            newNode.next = existingNode.next;
            if (existingNode.next) {
                existingNode.next.prev = newNode;
            }
            newNode.prev = existingNode;
            existingNode.next = newNode;
            if (existingNode === this.tail) {
                this._tail = newNode;
            }
            this._size++;
            return true;
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `deleteAt` function removes an element at a specified index from a linked list and returns the removed element.
     * @param {number} index - The index parameter represents the position of the element that needs to be deleted in the
     * data structure. It is of type number.
     * @returns The method `deleteAt` returns the value of the node that was deleted, or `undefined` if the index is out of
     * bounds.
     */
    deleteAt(index) {
        if (index < 0 || index >= this.size)
            return false;
        if (index === 0) {
            this.shift();
            return true;
        }
        if (index === this.size - 1) {
            this.pop();
            return true;
        }
        const removedNode = this.getNodeAt(index);
        const prevNode = removedNode.prev;
        const nextNode = removedNode.next;
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        this._size--;
        return true;
    }
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     *
     * The `delete` function removes a node from a doubly linked list based on either the node itself or its value.
     * @param {E | DoublyLinkedListNode<E>} valOrNode - The `valOrNode` parameter can accept either a value of type `E` or
     * a `DoublyLinkedListNode<E>` object.
     * @returns The `delete` method returns a boolean value. It returns `true` if the value or node was successfully
     * deleted from the doubly linked list, and `false` if the value or node was not found in the list.
     */
    delete(valOrNode) {
        let node;
        if (valOrNode instanceof DoublyLinkedListNode) {
            node = valOrNode;
        }
        else {
            node = this.getNode(valOrNode);
        }
        if (node) {
            if (node === this.head) {
                this.shift();
            }
            else if (node === this.tail) {
                this.pop();
            }
            else {
                const prevNode = node.prev;
                const nextNode = node.next;
                prevNode.next = nextNode;
                nextNode.prev = prevNode;
                this._size--;
            }
            return true;
        }
        return false;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function checks if a variable has a size greater than zero and returns a boolean value.
     * @returns A boolean value is being returned.
     */
    isEmpty() {
        return this.size === 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `clear` function resets the linked list by setting the head, tail, and size to undefined and 0 respectively.
     */
    clear() {
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function returns the index of the first occurrence of a given value in a linked list.
     * @param {E} value - The parameter `value` is of type `E`, which means it can be any data type. It represents the value
     * that we are searching for in the linked list.
     * @returns The method `indexOf` returns the index of the first occurrence of the specified value `value` in the linked
     * list. If the value is not found, it returns -1.
     */
    indexOf(value) {
        let index = 0;
        let current = this.head;
        while (current) {
            if (current.value === value) {
                return index;
            }
            index++;
            current = current.next;
        }
        return -1;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `findBackward` function iterates through a linked list from the last node to the first node and returns the last
     * value that satisfies the given callback function, or undefined if no value satisfies the callback.
     * @param callback - A function that takes a value of type E as its parameter and returns a boolean value. This
     * function is used to determine whether a given value satisfies a certain condition.
     * @returns The method `findBackward` returns the last value in the linked list that satisfies the condition specified by
     * the callback function. If no value satisfies the condition, it returns `undefined`.
     */
    findBackward(callback) {
        let current = this.tail;
        while (current) {
            if (callback(current.value)) {
                return current.value;
            }
            current = current.prev;
        }
        return undefined;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `reverse` function reverses the order of the elements in a doubly linked list.
     */
    reverse() {
        let current = this.head;
        [this._head, this._tail] = [this.tail, this.head];
        while (current) {
            const next = current.next;
            [current.prev, current.next] = [current.next, current.prev];
            current = next;
        }
        return this;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `toArray` function converts a linked list into an array.
     * @returns The `toArray()` method is returning an array of type `E[]`.
     */
    toArray() {
        const array = [];
        let current = this.head;
        while (current) {
            array.push(current.value);
            current = current.next;
        }
        return array;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `toReversedArray` function converts a doubly linked list into an array in reverse order.
     * @returns The `toReversedArray()` function returns an array of type `E[]`.
     */
    toReversedArray() {
        const array = [];
        let current = this.tail;
        while (current) {
            array.push(current.value);
            current = current.prev;
        }
        return array;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone` function creates a new instance of the `DoublyLinkedList` class with the same values
     * as the original list.
     * @returns The `clone()` method is returning a new instance of the `DoublyLinkedList` class, which
     * is a copy of the original list.
     */
    clone() {
        return new DoublyLinkedList(this);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new DoublyLinkedList by iterating over the elements of the current
     * list and applying a callback function to each element, returning only the elements for which the
     * callback function returns true.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the DoublyLinkedList. It takes three arguments: the current element, the index of the current
     * element, and the DoublyLinkedList itself. The callback function should return a boolean value
     * indicating whether the current element should be included
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `DoublyLinkedList` object that contains the
     * elements that pass the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
        const filteredList = new DoublyLinkedList([], { toElementFn: this.toElementFn });
        let index = 0;
        for (const current of this) {
            if (callback.call(thisArg, current, index, this)) {
                filteredList.push(current);
            }
            index++;
        }
        return filteredList;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * The `map` function takes a callback function and returns a new DoublyLinkedList with the results
     * of applying the callback to each element in the original list.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * original DoublyLinkedList. It takes three arguments: current (the current element being
     * processed), index (the index of the current element), and this (the original DoublyLinkedList).
     * The callback function should return a value of type
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to
     * convert the raw element (`RR`) to the desired element type (`T`). It takes the raw element as
     * input and returns the converted element. If this parameter is not provided, the raw element will
     * be used as is.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `DoublyLinkedList` class with elements of type `T` and `RR`.
     */
    map(callback, toElementFn, thisArg) {
        const mappedList = new DoublyLinkedList([], { toElementFn });
        let index = 0;
        for (const current of this) {
            mappedList.push(callback.call(thisArg, current, index, this));
            index++;
        }
        return mappedList;
    }
    /**
     * The function returns an iterator that iterates over the values of a linked list.
     */
    *_getIterator() {
        let current = this.head;
        while (current) {
            yield current.value;
            current = current.next;
        }
    }
}
exports.DoublyLinkedList = DoublyLinkedList;


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/data-structures/linked-list/index.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/data-structures/linked-list/singly-linked-list.js"), exports);
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/data-structures/linked-list/doubly-linked-list.js"), exports);
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/data-structures/linked-list/skip-linked-list.js"), exports);


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/data-structures/linked-list/singly-linked-list.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SinglyLinkedList = exports.SinglyLinkedListNode = void 0;
const base_1 = __webpack_require__("./node_modules/linked-list-typed/dist/data-structures/base/index.js");
class SinglyLinkedListNode {
    /**
     * The constructor function initializes an instance of a class with a given value and sets the next property to undefined.
     * @param {E} value - The "value" parameter is of type E, which means it can be any data type. It represents the value that
     * will be stored in the node of a linked list.
     */
    constructor(value) {
        this._value = value;
        this._next = undefined;
    }
    /**
     * The function returns the value of a protected variable.
     * @returns The value of the variable `_value` is being returned.
     */
    get value() {
        return this._value;
    }
    /**
     * The above function sets the value of a variable.
     * @param {E} value - The parameter "value" is of type E, which means it can be any type.
     */
    set value(value) {
        this._value = value;
    }
    /**
     * The `next` function returns the next node in a singly linked list.
     * @returns The `next` property is being returned. It can be either a `SinglyLinkedListNode<E>`
     * object or `undefined`.
     */
    get next() {
        return this._next;
    }
    /**
     * The "next" property of a SinglyLinkedListNode is set to the provided value.
     * @param {SinglyLinkedListNode<E> | undefined} value - The `value` parameter is of type
     * `SinglyLinkedListNode<E> | undefined`. This means that it can accept either a
     * `SinglyLinkedListNode` object or `undefined` as its value.
     */
    set next(value) {
        this._next = value;
    }
}
exports.SinglyLinkedListNode = SinglyLinkedListNode;
class SinglyLinkedList extends base_1.IterableElementBase {
    constructor(elements = [], options) {
        super(options);
        this._size = 0;
        if (elements) {
            for (const el of elements) {
                if (this.toElementFn) {
                    this.push(this.toElementFn(el));
                }
                else {
                    this.push(el);
                }
            }
        }
    }
    /**
     * The `head` function returns the first node of a singly linked list.
     * @returns The method is returning either a SinglyLinkedListNode object or undefined.
     */
    get head() {
        return this._head;
    }
    /**
     * The `tail` function returns the last node of a singly linked list.
     * @returns The method is returning either a SinglyLinkedListNode object or undefined.
     */
    get tail() {
        return this._tail;
    }
    /**
     * The above function returns the value of the first element in a linked list, or undefined if the
     * list is empty.
     * @returns The value of the first node in the linked list, or undefined if the linked list is empty.
     */
    get first() {
        var _a;
        return (_a = this.head) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * The function returns the value of the last element in a linked list, or undefined if the list is
     * empty.
     * @returns The value of the last node in the linked list, or undefined if the linked list is empty.
     */
    get last() {
        var _a;
        return (_a = this.tail) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * The function returns the size of an object.
     * @returns The size of the object, which is a number.
     */
    get size() {
        return this._size;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     * Linear time, where n is the length of the input array, as it performs a loop to push each element into the linked list.
     * Linear space, as it creates a new node for each element in the array.
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `fromArray` function creates a new SinglyLinkedList instance and populates it with the elements from the given
     * array.
     * @param {E[]} data - The `data` parameter is an array of elements of type `E`.
     * @returns The `fromArray` function returns a `SinglyLinkedList` object.
     */
    static fromArray(data) {
        const singlyLinkedList = new SinglyLinkedList();
        for (const item of data) {
            singlyLinkedList.push(item);
        }
        return singlyLinkedList;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The push function adds a new element to the end of a singly linked list.
     * @param {E} element - The "element" parameter represents the value of the element that you want to
     * add to the linked list.
     * @returns The `push` method is returning a boolean value, `true`.
     */
    push(element) {
        const newNode = new SinglyLinkedListNode(element);
        if (!this.head) {
            this._head = newNode;
            this._tail = newNode;
        }
        else {
            this.tail.next = newNode;
            this._tail = newNode;
        }
        this._size++;
        return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     * Linear time in the worst case, as it may need to traverse the list to find the last element.
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `pop` function removes and returns the value of the last element in a linked list.
     * @returns The method is returning the value of the element that is being popped from the end of the
     * list.
     */
    pop() {
        if (!this.head)
            return undefined;
        if (this.head === this.tail) {
            const value = this.head.value;
            this._head = undefined;
            this._tail = undefined;
            this._size--;
            return value;
        }
        let current = this.head;
        while (current.next !== this.tail) {
            current = current.next;
        }
        const value = this.tail.value;
        current.next = undefined;
        this._tail = current;
        this._size--;
        return value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `shift()` function removes and returns the value of the first element in a linked list.
     * @returns The value of the removed node.
     */
    shift() {
        if (!this.head)
            return undefined;
        const removedNode = this.head;
        this._head = this.head.next;
        this._size--;
        return removedNode.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The unshift function adds a new element to the beginning of a singly linked list.
     * @param {E} element - The "element" parameter represents the value of the element that you want to
     * add to the beginning of the singly linked list.
     * @returns The `unshift` method is returning a boolean value, `true`.
     */
    unshift(element) {
        const newNode = new SinglyLinkedListNode(element);
        if (!this.head) {
            this._head = newNode;
            this._tail = newNode;
        }
        else {
            newNode.next = this.head;
            this._head = newNode;
        }
        this._size++;
        return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `at` returns the value at a specified index in a linked list, or undefined if the index is out of range.
     * @param {number} index - The index parameter is a number that represents the position of the element we want to
     * retrieve from the list.
     * @returns The method `at(index: number): E | undefined` returns the value at the specified index in the linked list, or
     * `undefined` if the index is out of bounds.
     */
    at(index) {
        if (index < 0 || index >= this.size)
            return undefined;
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        return current.value;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `getNodeAt` returns the node at a given index in a singly linked list.
     * @param {number} index - The `index` parameter is a number that represents the position of the node we want to
     * retrieve from the linked list. It indicates the zero-based index of the node we want to access.
     * @returns The method `getNodeAt(index: number)` returns a `SinglyLinkedListNode<E>` object if the node at the
     * specified index exists, or `undefined` if the index is out of bounds.
     */
    getNodeAt(index) {
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        return current;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `deleteAt` function removes an element at a specified index from a linked list and returns the removed element.
     * @param {number} index - The index parameter represents the position of the element that needs to be deleted in the
     * data structure. It is of type number.
     * @returns The method `deleteAt` returns the value of the node that was deleted, or `undefined` if the index is out of
     * bounds.
     */
    deleteAt(index) {
        if (index < 0 || index >= this.size)
            return false;
        if (index === 0) {
            this.shift();
            return true;
        }
        if (index === this.size - 1) {
            this.pop();
            return true;
        }
        const prevNode = this.getNodeAt(index - 1);
        const removedNode = prevNode.next;
        prevNode.next = removedNode.next;
        this._size--;
        return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The delete function removes a node with a specific value from a singly linked list.
     * @param {E | SinglyLinkedListNode<E>} valueOrNode - The `valueOrNode` parameter can accept either a value of type `E`
     * or a `SinglyLinkedListNode<E>` object.
     * @returns The `delete` method returns a boolean value. It returns `true` if the value or node is found and
     * successfully deleted from the linked list, and `false` if the value or node is not found in the linked list.
     */
    delete(valueOrNode) {
        if (!valueOrNode)
            return false;
        let value;
        if (valueOrNode instanceof SinglyLinkedListNode) {
            value = valueOrNode.value;
        }
        else {
            value = valueOrNode;
        }
        let current = this.head, prev = undefined;
        while (current) {
            if (current.value === value) {
                if (prev === undefined) {
                    this._head = current.next;
                    if (current === this.tail) {
                        this._tail = undefined;
                    }
                }
                else {
                    prev.next = current.next;
                    if (current === this.tail) {
                        this._tail = prev;
                    }
                }
                this._size--;
                return true;
            }
            prev = current;
            current = current.next;
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `addAt` function inserts a value at a specified index in a singly linked list.
     * @param {number} index - The index parameter represents the position at which the new value should be inserted in the
     * linked list. It is of type number.
     * @param {E} value - The `value` parameter represents the value that you want to insert into the linked list at the
     * specified index.
     * @returns The `insert` method returns a boolean value. It returns `true` if the insertion is successful, and `false`
     * if the index is out of bounds.
     */
    addAt(index, value) {
        if (index < 0 || index > this.size)
            return false;
        if (index === 0) {
            this.unshift(value);
            return true;
        }
        if (index === this.size) {
            this.push(value);
            return true;
        }
        const newNode = new SinglyLinkedListNode(value);
        const prevNode = this.getNodeAt(index - 1);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
        this._size++;
        return true;
    }
    /**
     * The function checks if the length of a data structure is equal to zero and returns a boolean value indicating
     * whether it is empty or not.
     * @returns A boolean value indicating whether the length of the object is equal to 0.
     */
    isEmpty() {
        return this.size === 0;
    }
    /**
     * The `clear` function resets the linked list by setting the head, tail, and length to undefined and 0 respectively.
     */
    clear() {
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     * Linear time, where n is the length of the list, as it needs to traverse the entire list to convert it to an array.
     * Linear space, as it creates an array with the same length as the list.
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `toArray` function converts a linked list into an array.
     * @returns The `toArray()` method is returning an array of type `E[]`.
     */
    toArray() {
        const array = [];
        let current = this.head;
        while (current) {
            array.push(current.value);
            current = current.next;
        }
        return array;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `reverse` function reverses the order of the nodes in a singly linked list.
     * @returns The reverse() method does not return anything. It has a return type of void.
     */
    reverse() {
        if (!this.head || this.head === this.tail)
            return this;
        let prev = undefined;
        let current = this.head;
        let next = undefined;
        while (current) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        [this._head, this._tail] = [this.tail, this.head];
        return this;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `indexOf` function returns the index of the first occurrence of a given value in a linked list.
     * @param {E} value - The value parameter is the value that you want to find the index of in the linked list.
     * @returns The method is returning the index of the first occurrence of the specified value in the linked list. If the
     * value is not found, it returns -1.
     */
    indexOf(value) {
        let index = 0;
        let current = this.head;
        while (current) {
            if (current.value === value) {
                return index;
            }
            index++;
            current = current.next;
        }
        return -1;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function finds a node in a singly linked list by its value and returns the node if found, otherwise returns
     * undefined.
     * @param {E} value - The value parameter is the value that we want to search for in the linked list.
     * @returns a `SinglyLinkedListNode<E>` if a node with the specified value is found in the linked list. If no node with
     * the specified value is found, the function returns `undefined`.
     */
    getNode(value) {
        let current = this.head;
        while (current) {
            if (current.value === value) {
                return current;
            }
            current = current.next;
        }
        return undefined;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `addBefore` function inserts a new value before an existing value in a singly linked list.
     * @param {E | SinglyLinkedListNode<E>} existingValueOrNode - The existing value or node that you want to insert the
     * new value before. It can be either the value itself or a node containing the value in the linked list.
     * @param {E} newValue - The `newValue` parameter represents the value that you want to insert into the linked list.
     * @returns The method `addBefore` returns a boolean value. It returns `true` if the new value was successfully
     * inserted before the existing value, and `false` otherwise.
     */
    addBefore(existingValueOrNode, newValue) {
        if (!this.head)
            return false;
        let existingValue;
        if (existingValueOrNode instanceof SinglyLinkedListNode) {
            existingValue = existingValueOrNode.value;
        }
        else {
            existingValue = existingValueOrNode;
        }
        if (this.head.value === existingValue) {
            this.unshift(newValue);
            return true;
        }
        let current = this.head;
        while (current.next) {
            if (current.next.value === existingValue) {
                const newNode = new SinglyLinkedListNode(newValue);
                newNode.next = current.next;
                current.next = newNode;
                this._size++;
                return true;
            }
            current = current.next;
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `addAfter` function inserts a new node with a given value after an existing node in a singly linked list.
     * @param {E | SinglyLinkedListNode<E>} existingValueOrNode - The existing value or node in the linked list after which
     * the new value will be inserted. It can be either the value of the existing node or the existing node itself.
     * @param {E} newValue - The value that you want to insert into the linked list after the existing value or node.
     * @returns The method returns a boolean value. It returns true if the new value was successfully inserted after the
     * existing value or node, and false if the existing value or node was not found in the linked list.
     */
    addAfter(existingValueOrNode, newValue) {
        let existingNode;
        if (existingValueOrNode instanceof SinglyLinkedListNode) {
            existingNode = existingValueOrNode;
        }
        else {
            existingNode = this.getNode(existingValueOrNode);
        }
        if (existingNode) {
            const newNode = new SinglyLinkedListNode(newValue);
            newNode.next = existingNode.next;
            existingNode.next = newNode;
            if (existingNode === this.tail) {
                this._tail = newNode;
            }
            this._size++;
            return true;
        }
        return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function counts the number of occurrences of a given value in a linked list.
     * @param {E} value - The value parameter is the value that you want to count the occurrences of in the linked list.
     * @returns The count of occurrences of the given value in the linked list.
     */
    countOccurrences(value) {
        let count = 0;
        let current = this.head;
        while (current) {
            if (current.value === value) {
                count++;
            }
            current = current.next;
        }
        return count;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone` function returns a new instance of the `SinglyLinkedList` class with the same values
     * as the original list.
     * @returns The `clone()` method is returning a new instance of the `SinglyLinkedList` class, which
     * is a clone of the original list.
     */
    clone() {
        return new SinglyLinkedList(this, { toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new SinglyLinkedList by iterating over the elements of the current
     * list and applying a callback function to each element to determine if it should be included in the
     * filtered list.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * list. It takes three arguments: the current element, the index of the current element, and the
     * list itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list or not
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `SinglyLinkedList` object that contains the
     * elements that pass the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
        const filteredList = new SinglyLinkedList([], { toElementFn: this.toElementFn });
        let index = 0;
        for (const current of this) {
            if (callback.call(thisArg, current, index, this)) {
                filteredList.push(current);
            }
            index++;
        }
        return filteredList;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * The `map` function takes a callback function and returns a new SinglyLinkedList with the results
     * of applying the callback to each element in the original list.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the original list. It takes three arguments: `current` (the current element being processed),
     * `index` (the index of the current element), and `this` (the original list). It should return a
     * value
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to
     * convert the raw element (`RR`) to the desired element type (`T`). It takes the raw element as
     * input and returns the converted element. If this parameter is not provided, the raw element will
     * be used as is.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `SinglyLinkedList` class with the mapped elements.
     */
    map(callback, toElementFn, thisArg) {
        const mappedList = new SinglyLinkedList([], { toElementFn });
        let index = 0;
        for (const current of this) {
            mappedList.push(callback.call(thisArg, current, index, this));
            index++;
        }
        return mappedList;
    }
    /**
     * The function `_getIterator` returns an iterable iterator that yields the values of a linked list.
     */
    *_getIterator() {
        let current = this.head;
        while (current) {
            yield current.value;
            current = current.next;
        }
    }
}
exports.SinglyLinkedList = SinglyLinkedList;


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/data-structures/linked-list/skip-linked-list.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkipList = exports.SkipListNode = void 0;
class SkipListNode {
    constructor(key, value, level) {
        this.key = key;
        this.value = value;
        this.forward = new Array(level);
    }
}
exports.SkipListNode = SkipListNode;
class SkipList {
    /**
     * The constructor function initializes a SkipLinkedList object with optional options and elements.
     * @param elements - The `elements` parameter is an iterable containing key-value pairs `[K, V]`. It
     * is used to initialize the SkipLinkedList with the given key-value pairs. If no elements are
     * provided, the SkipLinkedList will be empty.
     * @param {SkipLinkedListOptions} [options] - The `options` parameter is an optional object that can
     * contain two properties:
     */
    constructor(elements = [], options) {
        this._head = new SkipListNode(undefined, undefined, this.maxLevel);
        this._level = 0;
        this._maxLevel = 16;
        this._probability = 0.5;
        if (options) {
            const { maxLevel, probability } = options;
            if (typeof maxLevel === 'number')
                this._maxLevel = maxLevel;
            if (typeof probability === 'number')
                this._probability = probability;
        }
        if (elements) {
            for (const [key, value] of elements)
                this.add(key, value);
        }
    }
    /**
     * The function returns the head node of a SkipList.
     * @returns The method is returning a SkipListNode object with generic key type K and value type V.
     */
    get head() {
        return this._head;
    }
    /**
     * The function returns the value of the protected variable _level.
     * @returns The level property of the object.
     */
    get level() {
        return this._level;
    }
    /**
     * The function returns the maximum level.
     * @returns The value of the variable `_maxLevel` is being returned.
     */
    get maxLevel() {
        return this._maxLevel;
    }
    /**
     * The function returns the probability value.
     * @returns The probability value stored in the protected variable `_probability` is being returned.
     */
    get probability() {
        return this._probability;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Get the value of the first element (the smallest element) in the Skip List.
     * @returns The value of the first element, or undefined if the Skip List is empty.
     */
    get first() {
        const firstNode = this.head.forward[0];
        return firstNode ? firstNode.value : undefined;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Get the value of the last element (the largest element) in the Skip List.
     * @returns The value of the last element, or undefined if the Skip List is empty.
     */
    get last() {
        let current = this.head;
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i]) {
                current = current.forward[i];
            }
        }
        return current.value;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The add function adds a new node with a given key and value to a Skip List data structure.
     * @param {K} key - The key parameter represents the key of the node that needs to be added to the skip list.
     * @param {V} value - The "value" parameter represents the value associated with the key that is being added to the Skip
     * List.
     */
    add(key, value) {
        const newNode = new SkipListNode(key, value, this._randomLevel());
        const update = new Array(this.maxLevel).fill(this.head);
        let current = this.head;
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].key < key) {
                current = current.forward[i];
            }
            update[i] = current;
        }
        for (let i = 0; i < newNode.forward.length; i++) {
            newNode.forward[i] = update[i].forward[i];
            update[i].forward[i] = newNode;
        }
        if (!newNode.forward[0]) {
            this._level = Math.max(this.level, newNode.forward.length);
        }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `get` retrieves the value associated with a given key from a skip list data structure.
     * @param {K} key - The `key` parameter is the key of the element that we want to retrieve from the data structure.
     * @returns The method `get(key: K)` returns the value associated with the given key if it exists in the data structure,
     * otherwise it returns `undefined`.
     */
    get(key) {
        let current = this.head;
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].key < key) {
                current = current.forward[i];
            }
        }
        current = current.forward[0];
        if (current && current.key === key) {
            return current.value;
        }
        return undefined;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * The function checks if a key exists in a data structure.
     * @param {K} key - The parameter "key" is of type K, which represents the type of the key being
     * checked.
     * @returns a boolean value.
     */
    has(key) {
        return this.get(key) !== undefined;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `delete` function removes a node with a specific key from a Skip List data structure.
     * @param {K} key - The key parameter represents the key of the node that needs to be removed from the skip list.
     * @returns The `delete` method returns a boolean value. It returns `true` if the key was successfully removed from the
     * skip list, and `false` if the key was not found in the skip list.
     */
    delete(key) {
        const update = new Array(this.maxLevel).fill(this.head);
        let current = this.head;
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].key < key) {
                current = current.forward[i];
            }
            update[i] = current;
        }
        current = current.forward[0];
        if (current && current.key === key) {
            for (let i = 0; i < this.level; i++) {
                if (update[i].forward[i] !== current) {
                    break;
                }
                update[i].forward[i] = current.forward[i];
            }
            while (this.level > 0 && !this.head.forward[this.level - 1]) {
                this._level--;
            }
            return true;
        }
        return false;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Get the value of the first element in the Skip List that is greater than the given key.
     * @param key - the given key.
     * @returns The value of the first element greater than the given key, or undefined if there is no such element.
     */
    higher(key) {
        let current = this.head;
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].key <= key) {
                current = current.forward[i];
            }
        }
        const nextNode = current.forward[0];
        return nextNode ? nextNode.value : undefined;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Get the value of the last element in the Skip List that is less than the given key.
     * @param key - the given key.
     * @returns The value of the last element less than the given key, or undefined if there is no such element.
     */
    lower(key) {
        let current = this.head;
        let lastLess = undefined;
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].key < key) {
                current = current.forward[i];
            }
            if (current.key < key) {
                lastLess = current;
            }
        }
        return lastLess ? lastLess.value : undefined;
    }
    /**
     * Time Complexity: O(maxLevel)
     * Space Complexity: O(1)
     * where maxLevel is the maximum level of the SkipList, as it may iterate up to maxLevel times in the worst case.
     */
    /**
     * Time Complexity: O(maxLevel)
     * Space Complexity: O(1)
     *
     * The function "_randomLevel" generates a random level based on a given probability and maximum level.
     * @returns the level, which is a number.
     */
    _randomLevel() {
        let level = 1;
        while (Math.random() < this.probability && level < this.maxLevel) {
            level++;
        }
        return level;
    }
}
exports.SkipList = SkipList;


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/index.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
// export { DoublyLinkedListNode, DoublyLinkedList, SinglyLinkedListNode, SinglyLinkedList } from 'data-structure-typed';
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/data-structures/linked-list/index.js"), exports);
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/types/data-structures/linked-list/index.js"), exports);
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/types/common.js"), exports);


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/types/common.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/types/data-structures/linked-list/doubly-linked-list.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/types/data-structures/linked-list/index.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/types/data-structures/linked-list/singly-linked-list.js"), exports);
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/types/data-structures/linked-list/doubly-linked-list.js"), exports);
__exportStar(__webpack_require__("./node_modules/linked-list-typed/dist/types/data-structures/linked-list/skip-linked-list.js"), exports);


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/types/data-structures/linked-list/singly-linked-list.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/linked-list-typed/dist/types/data-structures/linked-list/skip-linked-list.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/linked-list-typescript/lib/src/index.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class LinkedList {
    constructor(...values) {
        this._head = this._tail = null;
        this._length = 0;
        if (values.length > 0) {
            values.forEach((value) => {
                this.append(value);
            });
        }
    }
    *iterator() {
        let currentItem = this._head;
        while (currentItem) {
            yield currentItem.value;
            currentItem = currentItem.next;
        }
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    get head() {
        return this._head ? this._head.value : null;
    }
    get tail() {
        return this._tail ? this._tail.value : null;
    }
    get length() {
        return this._length;
    }
    // Adds the element at a specific position inside the linked list
    insert(val, previousItem, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
            return false;
        }
        let newItem = new LinkedListItem(val);
        let currentItem = this._head;
        if (!currentItem) {
            return false;
        }
        else {
            while (true) {
                if (currentItem.value === previousItem) {
                    newItem.next = currentItem.next;
                    newItem.prev = currentItem;
                    currentItem.next = newItem;
                    if (newItem.next) {
                        newItem.next.prev = newItem;
                    }
                    else {
                        this._tail = newItem;
                    }
                    this._length++;
                    return true;
                }
                else {
                    if (currentItem.next) {
                        currentItem = currentItem.next;
                    }
                    else {
                        // can't locate previousItem
                        return false;
                    }
                }
            }
        }
    }
    // Adds the element at the end of the linked list
    append(val, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
            return false;
        }
        let newItem = new LinkedListItem(val);
        if (!this._tail) {
            this._head = this._tail = newItem;
        }
        else {
            this._tail.next = newItem;
            newItem.prev = this._tail;
            this._tail = newItem;
        }
        this._length++;
        return true;
    }
    // Add the element at the beginning of the linked list
    prepend(val, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
            return false;
        }
        let newItem = new LinkedListItem(val);
        if (!this._head) {
            this._head = this._tail = newItem;
        }
        else {
            newItem.next = this._head;
            this._head.prev = newItem;
            this._head = newItem;
        }
        this._length++;
        return true;
    }
    remove(val) {
        let currentItem = this._head;
        if (!currentItem) {
            return;
        }
        if (currentItem.value === val) {
            this._head = currentItem.next;
            this._head.prev = null;
            currentItem.next = currentItem.prev = null;
            this._length--;
            return currentItem.value;
        }
        else {
            while (true) {
                if (currentItem.value === val) {
                    if (currentItem.next) { // special case for last element
                        currentItem.prev.next = currentItem.next;
                        currentItem.next.prev = currentItem.prev;
                        currentItem.next = currentItem.prev = null;
                    }
                    else {
                        currentItem.prev.next = null;
                        this._tail = currentItem.prev;
                        currentItem.next = currentItem.prev = null;
                    }
                    this._length--;
                    return currentItem.value;
                }
                else {
                    if (currentItem.next) {
                        currentItem = currentItem.next;
                    }
                    else {
                        return;
                    }
                }
            }
        }
    }
    removeHead() {
        let currentItem = this._head;
        // empty list
        if (!currentItem) {
            return;
        }
        // single item list
        if (!this._head.next) {
            this._head = null;
            this._tail = null;
            // full list
        }
        else {
            this._head.next.prev = null;
            this._head = this._head.next;
            currentItem.next = currentItem.prev = null;
        }
        this._length--;
        return currentItem.value;
    }
    removeTail() {
        let currentItem = this._tail;
        // empty list
        if (!currentItem) {
            return;
        }
        // single item list
        if (!this._tail.prev) {
            this._head = null;
            this._tail = null;
            // full list
        }
        else {
            this._tail.prev.next = null;
            this._tail = this._tail.prev;
            currentItem.next = currentItem.prev = null;
        }
        this._length--;
        return currentItem.value;
    }
    first(num) {
        let iter = this.iterator();
        let result = [];
        let n = Math.min(num, this.length);
        for (let i = 0; i < n; i++) {
            let val = iter.next();
            result.push(val.value);
        }
        return result;
    }
    toArray() {
        return [...this];
    }
    isDuplicate(val) {
        let set = new Set(this.toArray());
        return set.has(val);
    }
}
exports.LinkedList = LinkedList;
class LinkedListItem {
    constructor(val) {
        this.value = val;
        this.next = null;
        this.prev = null;
    }
}
exports.LinkedListItem = LinkedListItem;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/parse-color/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var convert = __webpack_require__("./node_modules/parse-color/node_modules/color-convert/index.js");

module.exports = function (cstr) {
    var m, conv, parts, alpha;
    if (m = /^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
        var name = m[1];
        var base = name.replace(/a$/, '');
        var size = base === 'cmyk' ? 4 : 3;
        conv = convert[base];
        
        parts = m[2].replace(/^\s+|\s+$/g, '')
            .split(/\s*,\s*/)
            .map(function (x, i) {
                if (/%$/.test(x) && i === size) {
                    return parseFloat(x) / 100;
                }
                else if (/%$/.test(x)) {
                    return parseFloat(x);
                }
                return parseFloat(x);
            })
        ;
        if (name === base) parts.push(1);
        alpha = parts[size] === undefined ? 1 : parts[size];
        parts = parts.slice(0, size);
        
        conv[base] = function () { return parts };
    }
    else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
        var base = cstr.replace(/^#/,'');
        var size = base.length;
        conv = convert.rgb;
        parts = base.split(size === 3 ? /(.)/ : /(..)/);
        parts = parts.filter(Boolean)
            .map(function (x) {
                if (size === 3) {
                    return parseInt(x + x, 16);
                }
                else {
                    return parseInt(x, 16)
                }
            })
        ;
        alpha = 1;
        conv.rgb = function () { return parts };
        if (!parts[0]) parts[0] = 0;
        if (!parts[1]) parts[1] = 0;
        if (!parts[2]) parts[2] = 0;
    }
    else {
        conv = convert.keyword;
        conv.keyword = function () { return cstr };
        parts = cstr;
        alpha = 1;
    }
    
    var res = {
        rgb: undefined,
        hsl: undefined,
        hsv: undefined,
        cmyk: undefined,
        keyword: undefined,
        hex: undefined
    };
    try { res.rgb = conv.rgb(parts) } catch (e) {}
    try { res.hsl = conv.hsl(parts) } catch (e) {}
    try { res.hsv = conv.hsv(parts) } catch (e) {}
    try { res.cmyk = conv.cmyk(parts) } catch (e) {}
    try { res.keyword = conv.keyword(parts) } catch (e) {}
    
    if (res.rgb) res.hex = '#' + res.rgb.map(function (x) {
        var s = x.toString(16);
        if (s.length === 1) return '0' + s;
        return s;
    }).join('');
    
    if (res.rgb) res.rgba = res.rgb.concat(alpha);
    if (res.hsl) res.hsla = res.hsl.concat(alpha);
    if (res.hsv) res.hsva = res.hsv.concat(alpha);
    if (res.cmyk) res.cmyka = res.cmyk.concat(alpha);
    
    return res;
};


/***/ }),

/***/ "./node_modules/parse-color/node_modules/color-convert/conversions.js":
/***/ ((module) => {

/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}


/***/ }),

/***/ "./node_modules/parse-color/node_modules/color-convert/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var conversions = __webpack_require__("./node_modules/parse-color/node_modules/color-convert/conversions.js");

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;

/***/ }),

/***/ "./node_modules/queue-typescript/lib/src/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const linked_list_typescript_1 = __webpack_require__("./node_modules/linked-list-typescript/lib/src/index.js");
class Queue extends linked_list_typescript_1.LinkedList {
    constructor(...values) {
        super(...values);
    }
    get front() {
        return this.head;
    }
    enqueue(val) {
        this.append(val);
    }
    dequeue() {
        return this.removeHead();
    }
}
exports.Queue = Queue;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/reliable-random/dist/index.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Random: () => (/* binding */ Random)
/* harmony export */ });
/**
 * A random constant that is part of the random generation algorithm.
 */
const RANDOM_CONSTANT = BigInt('6364136223846793005');
/**
 * A mask of 32 set bits. Used to ensure values stay within a 32 bit range.
 */
const U32_MASK = (BigInt(1) << BigInt(32)) - BigInt(1);
/**
 * A mask of 64 set bits. Used to ensure values stay within a 64 bit range.
 */
const U64_MASK = (BigInt(1) << BigInt(64)) - BigInt(1);
class Random {
    /**
     * A PRNG class. Provides two main methods:
     *
     * - `random` - Produces a "continuous" standard uniform distribution.
     * - `randint` - Produces a discrete uniform distribution.
     *
     * For more details, check the individual methods.
     *
     * @param initState The seed to initialise the state of the generator.
     * @param initSequence The seed to initialise the sequence number of the
     * generator.
     */
    // The state and sequence are stored as bigints, but anything that is
    // coercible to a bigint should be a valid seed.
    constructor(initState, initSequence) {
        this._state = BigInt(0);
        this._inc = ((BigInt(initSequence) << BigInt(1)) | BigInt(1)) & U64_MASK;
        this._random_b();
        this._state = (this._state + BigInt(initState)) & U64_MASK;
        this._random_b();
    }
    /**
     * This is the source of randomness for all other random methods.
     *
     * Produces a uniformly distributed 32-bit unsigned integer as a bigint.
     *
     * Although the produced number is 32 bits; the implementation requires that
     * the state of the generator be a 64 bit unsigned integer. Since the js
     * Number datatype cannot reliably handle integers that large, we use the
     * BigInt class for the calculation.
     */
    _random_b() {
        const old = this._state;
        this._state = (old * RANDOM_CONSTANT + this._inc) & U64_MASK;
        const xorshifted = ((old >> BigInt(18)) ^ old) >> BigInt(27);
        const rightRot = old >> BigInt(59);
        const leftRot = rightRot ^ BigInt(31);
        return ((xorshifted >> rightRot) | (xorshifted << leftRot)) & U32_MASK;
    }
    /**
     * Advances the internal state of the generator `delta` steps. Delta can be
     * negative to reverse.
     *
     * This is calculated in a very similar way to the square and multiply method
     * for taking the power of a number. As you may expect, it is calculated in
     * log(delta) time.
     */
    _advance(delta) {
        // The period is 2 ^ 64.
        // If delta is negative, we make it positive and go around the other way.
        delta &= U64_MASK;
        /** The accumulated multiplier */
        let mult_acc = BigInt(1);
        /** The current multiplier */
        let mult_curr = RANDOM_CONSTANT;
        /** The accumulated increment */
        let plus_acc = BigInt(0);
        let plus_curr = this._inc;
        while (delta > 0) {
            if (delta & BigInt(1)) {
                mult_acc = (mult_acc * mult_curr) & U64_MASK;
                plus_acc = (plus_acc * mult_curr + plus_curr) & U64_MASK;
            }
            plus_curr = ((mult_curr + BigInt(1)) * plus_curr) & U64_MASK;
            mult_curr = (mult_curr * mult_curr) & U64_MASK;
            delta >>= BigInt(1);
        }
        this._state = (mult_acc * this._state + plus_acc) & U64_MASK;
    }
    /**
     * Produces a uniformly distributed integer, r, with 0 ≤ r < bound.
     *
     * To produce a uniformly distributed integer in the range [low, high):
     *
     * ```js
     * const i = low + rand.randint(high - low)
     * ```
     *
     * @param bound The lower bound for the number.
     */
    randint(bound) {
        if (bound > U32_MASK) {
            throw new TypeError(`Bound too large: ${bound}`);
        }
        if (bound <= 0) {
            throw new TypeError(`Empty sample space for r: 0 ≤ r < ${bound}`);
        }
        const bound_big = BigInt(bound);
        // By excluding the integers less than this threshold, we can be sure that
        // the final value will be uniformly distributed in the intended range.
        const threshold = (U32_MASK ^ bound_big) % bound_big;
        // The uniformity of _random_b makes sure that this loop will exit
        // eventually.
        for (;;) {
            const r = this._random_b();
            if (r >= threshold) {
                return Number(r % bound_big);
            }
        }
    }
    /**
     * Generates an approximately uniformly distributed number, r, with 0 ≤ r < 1.
     *
     * @returns The number r.
     */
    random() {
        return Number(this._random_b()) / Math.pow(2, 32);
    }
}




/***/ }),

/***/ "./node_modules/stack-typescript/lib/src/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const linked_list_typescript_1 = __webpack_require__("./node_modules/linked-list-typescript/lib/src/index.js");
class Stack extends linked_list_typescript_1.LinkedList {
    constructor(...values) {
        super(...values);
    }
    get top() {
        return this.head;
    }
    get size() {
        return this.length;
    }
    push(val) {
        this.prepend(val);
    }
    pop() {
        return this.removeHead();
    }
}
exports.Stack = Stack;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/typescript-string-operations/dist/index.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:!0})),exports.StringBuilder=exports.String=exports.formatString=exports.joinString=exports.isNullOrWhiteSpace=exports.emptyString=void 0;const EOL="\r\n";function isNullOrWhiteSpace(value){return String.isNullOrWhiteSpace(value)}function joinString(delimiter,...args){return String.join(delimiter,...args)}function formatString(format,...args){return String.format(format,...args)}exports.emptyString="",exports.isNullOrWhiteSpace=isNullOrWhiteSpace,exports.joinString=joinString,exports.formatString=formatString;class String{static regexNumber=/{(\d+(:\w*)?)}/g;static regexObject=/{(\w+(:\w*)?)}/g;static empty="";static Empty="";static IsNullOrWhiteSpace(value){return String.isNullOrWhiteSpace(value)}static Join(delimiter,...args){return String.join(delimiter,...args)}static Format(format,...args){return String.format(format,...args)}static isNullOrWhiteSpace(value){try{return null==value||"undefined"==value?!0:value.toString().replace(/\s/g,"").length<1}catch(e){return console.log(e),!1}}static join(delimiter,...args){try{var firstArg=args[0];if(Array.isArray(firstArg)||firstArg instanceof Array){let tempString=String.empty;for(let i=0;i<firstArg.length;i++){var current=firstArg[i];i<firstArg.length-1?tempString+=current+delimiter:tempString+=current}return tempString}if("object"==typeof firstArg){let tempString=String.empty;const objectArg=firstArg;return Object.keys(firstArg).forEach(element=>{tempString+=objectArg[element]+delimiter}),tempString=tempString.slice(0,tempString.length-delimiter.length)}var stringArray=args;return String.joinString(delimiter,...stringArray)}catch(e){return console.log(e),String.empty}}static format(format,...args){try{return format.match(String.regexNumber)?String.formatString(String.regexNumber,format,args):format.match(String.regexObject)?String.formatString(String.regexObject,format,args,!0):format}catch(e){return console.log(e),String.empty}}static formatString(regex,format,args,parseByObject=!1){return format.replace(regex,function(match,x){var s=match.split(":");1<s.length&&(x=s[0].replace("{",""),match=s[1].replace("}",""));let arg;return null==(arg=(parseByObject?args[0]:args)[x])||null==arg||match.match(/{\d+}/)||void 0!==(arg=String.parsePattern(match,arg))&&null!=arg?arg:String.empty})}static parsePattern(match,arg){switch(match){case"L":return arg=arg.toLocaleLowerCase();case"U":return arg=arg.toLocaleUpperCase();case"d":if("string"==typeof arg)return String.getDisplayDateFromString(arg);if(arg instanceof Date)return String.format("{0:00}.{1:00}.{2:0000}",arg.getDate(),arg.getMonth(),arg.getFullYear());break;case"s":if("string"==typeof arg)return String.getSortableDateFromString(arg);if(arg instanceof Date)return String.format("{0:0000}-{1:00}-{2:00}",arg.getFullYear(),arg.getMonth(),arg.getDate());break;case"n":{var replacedString=(arg="string"!=typeof arg?arg.toString():arg).replace(/,/g,".");if(isNaN(parseFloat(replacedString))||replacedString.length<=3)break;replacedString=replacedString.split(/\D+/g);let parts=replacedString;var replacedString=(parts=1<replacedString.length?[String.joinString("",...replacedString.splice(0,replacedString.length-1)),replacedString[replacedString.length-1]]:parts)[0],mod=replacedString.length%3,output=0<mod?replacedString.substring(0,mod):String.empty,replacedString=replacedString.substring(mod).match(/.{3}/g);return arg=output+"."+String.join(".",replacedString)+(1<parts.length?","+parts[1]:"")}case"x":return this.decimalToHexString(arg);case"X":return this.decimalToHexString(arg,!0)}return"number"!=typeof arg&&isNaN(arg)||isNaN(+match)||String.isNullOrWhiteSpace(arg)?arg:String.formatNumber(arg,match)}static decimalToHexString(value,upperCase=!1){value=parseFloat(value).toString(16);return upperCase?value.toLocaleUpperCase():value}static getDisplayDateFromString(input){var splitted=input.split("-");if(splitted.length<=1)return input;let day=splitted[splitted.length-1];input=splitted[splitted.length-2],splitted=splitted[splitted.length-3];return(day=(day=day.split("T")[0]).split(" ")[0])+`.${input}.`+splitted}static getSortableDateFromString(input){var splitted=input.replace(",","").split(".");if(splitted.length<=1)return input;input=splitted[splitted.length-1].split(" ");let time=String.empty,result=(1<input.length&&(time=input[input.length-1]),splitted[splitted.length-1].split(" ")[0]+`-${splitted[splitted.length-2]}-`+splitted[splitted.length-3]);return!String.isNullOrWhiteSpace(time)&&1<time.length?result+="T"+time:result+="T00:00:00",result}static formatNumber(input,formatTemplate){var formatTemplate=formatTemplate.length,input=input.toString();return formatTemplate<=input.length?input:(formatTemplate=formatTemplate-input.length,++formatTemplate,new Array(formatTemplate).join("0")+input)}static joinString(delimiter,...args){let temp=String.empty;for(let i=0;i<args.length;i++)if(!("string"==typeof args[i]&&String.isNullOrWhiteSpace(args[i])||"number"!=typeof args[i]&&"string"!=typeof args[i])){var arg=""+args[i];temp+=arg;for(let i2=i+1;i2<args.length;i2++)if(!String.isNullOrWhiteSpace(args[i2])){temp+=delimiter,i=i2-1;break}}return temp}}exports.String=String;class StringBuilder{Values;constructor(value=""){this.Values=[],String.isNullOrWhiteSpace(value)||(this.Values=new Array(value))}toString(){return this.Values.join(String.empty)}ToString(){return this.toString()}append(value){this.Values.push(value)}Append(value){this.append(value)}appendLine(value){this.Values.push(EOL+value)}AppendLine(value){this.appendLine(value)}appendFormat(format,...args){this.Values.push(String.format(format,...args))}AppendFormat(format,...args){this.appendFormat(format,...args)}appendLineFormat(format,...args){this.Values.push(EOL+String.format(format,...args))}AppendLineFormat(format,...args){return this.appendLineFormat(format,...args)}clear(){this.Values=[]}Clear(){this.clear()}}exports.StringBuilder=StringBuilder;

/***/ }),

/***/ "./public/app/plugins/panel/nodeGraph/layeredLayout.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   layout: () => (/* binding */ layout)
/* harmony export */ });
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _msagl_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/parser/dist/index.js");



/**
 * Use d3 force layout to lay the nodes in a sensible way. This function modifies the nodes adding the x,y positions
 * and also fills in node references in edges instead of node ids.
 */
function layout(nodes, edges) {
  const { mappedEdges, DOTToIdMap } = createMappings(nodes, edges);

  const dot = graphToDOT(mappedEdges, DOTToIdMap);
  const graph = (0,_msagl_parser__WEBPACK_IMPORTED_MODULE_1__.parseDot)(dot);
  const geomGraph = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph(graph);
  for (const e of graph.deepEdges) {
    new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge(e);
  }

  for (const n of graph.nodesBreadthFirst) {
    const gn = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomNode(n);
    gn.boundaryCurve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkCircle(50, new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0));
  }
  geomGraph.layoutSettings = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.SugiyamaLayoutSettings();
  geomGraph.layoutSettings.layerDirection = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.LayerDirectionEnum.LR;
  geomGraph.layoutSettings.LayerSeparation = 60;
  geomGraph.layoutSettings.commonSettings.NodeSeparation = 40;
  (0,_msagl_core__WEBPACK_IMPORTED_MODULE_0__.layoutGeomGraph)(geomGraph);

  const nodesMap = {};
  for (const node of geomGraph.nodesBreadthFirst) {
    nodesMap[DOTToIdMap[node.id]] = {
      obj: node,
    };
  }

  for (const node of nodes) {
    nodesMap[node.id] = {
      ...nodesMap[node.id],
      datum: {
        ...node,
        x: nodesMap[node.id].obj.center.x,
        y: nodesMap[node.id].obj.center.y,
      },
    };
  }
  const edgesMapped = edges.map((e) => {
    return {
      ...e,
      source: nodesMap[e.source].datum,
      target: nodesMap[e.target].datum,
    };
  });

  // This section checks if there are separate disjointed subgraphs. If so it groups nodes for each and then aligns
  // each subgraph, so it starts on a single vertical line. Otherwise, they are laid out randomly from left to right.
  const subgraphs = [];
  for (const e of edgesMapped) {
    const sourceGraph = subgraphs.find((g) => g.nodes.has(e.source));
    const targetGraph = subgraphs.find((g) => g.nodes.has(e.target));
    if (sourceGraph && targetGraph) {
      // if the node sets are not the same we merge them
      if (sourceGraph !== targetGraph) {
        targetGraph.nodes.forEach(sourceGraph.nodes.add, sourceGraph.nodes);
        subgraphs.splice(subgraphs.indexOf(targetGraph), 1);
        sourceGraph.top = Math.min(sourceGraph.top, targetGraph.top);
        sourceGraph.bottom = Math.max(sourceGraph.bottom, targetGraph.bottom);
        sourceGraph.left = Math.min(sourceGraph.left, targetGraph.left);
        sourceGraph.right = Math.max(sourceGraph.right, targetGraph.right);
      }
      // if the sets are the same nothing to do.
    } else if (sourceGraph) {
      sourceGraph.nodes.add(e.target);
      sourceGraph.top = Math.min(sourceGraph.top, e.target.y);
      sourceGraph.bottom = Math.max(sourceGraph.bottom, e.target.y);
      sourceGraph.left = Math.min(sourceGraph.left, e.target.x);
      sourceGraph.right = Math.max(sourceGraph.right, e.target.x);
    } else if (targetGraph) {
      targetGraph.nodes.add(e.source);
      targetGraph.top = Math.min(targetGraph.top, e.source.y);
      targetGraph.bottom = Math.max(targetGraph.bottom, e.source.y);
      targetGraph.left = Math.min(targetGraph.left, e.source.x);
      targetGraph.right = Math.max(targetGraph.right, e.source.x);
    } else {
      // we don't have these nodes
      subgraphs.push({
        top: Math.min(e.source.y, e.target.y),
        bottom: Math.max(e.source.y, e.target.y),
        left: Math.min(e.source.x, e.target.x),
        right: Math.max(e.source.x, e.target.x),
        nodes: new Set([e.source, e.target]),
      });
    }
  }

  let top = 0;
  let left = 0;
  for (const g of subgraphs) {
    if (top === 0) {
      top = g.bottom + 200;
      left = g.left;
    } else {
      const topDiff = top - g.top;
      const leftDiff = left - g.left;
      for (const n of g.nodes) {
        n.x += leftDiff;
        n.y += topDiff;
      }
      top += g.bottom - g.top + 200;
    }
  }

  const finalNodes = Object.values(nodesMap).map((v) => v.datum);

  centerNodes(finalNodes);
  return [finalNodes, edgesMapped];
}

// We create mapping because the DOT language we use later to create the graph doesn't support arbitrary IDs. So we
// map our IDs to just an index of the node so the IDs are safe for the DOT parser and also create and inverse mapping
// for quick lookup.
function createMappings(nodes, edges) {
  // Edges where the source and target IDs are the indexes we use for layout
  const mappedEdges = [];

  // Key is an ID of the node and value is new ID which is just iteration index
  const idToDOTMap = {};

  // Key is an iteration index and value is actual ID of the node
  const DOTToIdMap = {};

  let index = 0;
  for (const node of nodes) {
    idToDOTMap[node.id] = index.toString(10);
    DOTToIdMap[index.toString(10)] = node.id;
    index++;
  }

  for (const edge of edges) {
    mappedEdges.push({ source: idToDOTMap[edge.source], target: idToDOTMap[edge.target] });
  }

  return {
    mappedEdges,
    DOTToIdMap,
    idToDOTMap,
  };
}

function graphToDOT(edges, nodeIDsMap) {
  let dot = `
  digraph G {
    rankdir="LR"; TBbalance="min"
  `;
  for (const edge of edges) {
    dot += edge.source + '->' + edge.target + ' ' + '[ minlen=3 ]\n';
  }
  dot += nodesDOT(nodeIDsMap);
  dot += '}';
  return dot;
}

function nodesDOT(nodeIdsMap) {
  let dot = '';
  for (const node of Object.keys(nodeIdsMap)) {
    dot += node + ' [fixedsize=true, width=1.2, height=1.7] \n';
  }
  return dot;
}

/**
 * Makes sure that the center of the graph based on its bound is in 0, 0 coordinates.
 * Modifies the nodes directly.
 */
function centerNodes(nodes) {
  const bounds = graphBounds(nodes);
  for (let node of nodes) {
    node.x = node.x - bounds.center.x;
    node.y = node.y - bounds.center.y;
  }
}

/**
 * Get bounds of the graph meaning the extent of the nodes in all directions.
 */
function graphBounds(nodes) {
  if (nodes.length === 0) {
    return { top: 0, right: 0, bottom: 0, left: 0, center: { x: 0, y: 0 } };
  }

  const bounds = nodes.reduce(
    (acc, node) => {
      if (node.x > acc.right) {
        acc.right = node.x;
      }
      if (node.x < acc.left) {
        acc.left = node.x;
      }
      if (node.y > acc.bottom) {
        acc.bottom = node.y;
      }
      if (node.y < acc.top) {
        acc.top = node.y;
      }
      return acc;
    },
    { top: Infinity, right: -Infinity, bottom: -Infinity, left: Infinity }
  );

  const y = bounds.top + (bounds.bottom - bounds.top) / 2;
  const x = bounds.left + (bounds.right - bounds.left) / 2;

  return {
    ...bounds,
    center: {
      x,
      y,
    },
  };
}


/***/ }),

/***/ "./node_modules/@msagl/core/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Arrowhead: () => (/* reexport safe */ _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_52__.Arrowhead),
/* harmony export */   Assert: () => (/* reexport safe */ _utils_assert__WEBPACK_IMPORTED_MODULE_15__.Assert),
/* harmony export */   Attribute: () => (/* reexport safe */ _structs_attribute__WEBPACK_IMPORTED_MODULE_12__.Attribute),
/* harmony export */   AttributeRegistry: () => (/* reexport safe */ _structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_55__.AttributeRegistry),
/* harmony export */   BezierSeg: () => (/* reexport safe */ _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_49__.BezierSeg),
/* harmony export */   BundlingSettings: () => (/* reexport safe */ _routing_BundlingSettings__WEBPACK_IMPORTED_MODULE_44__.BundlingSettings),
/* harmony export */   CancelToken: () => (/* reexport safe */ _utils_cancelToken__WEBPACK_IMPORTED_MODULE_36__.CancelToken),
/* harmony export */   CornerSite: () => (/* reexport safe */ _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_28__.CornerSite),
/* harmony export */   Curve: () => (/* reexport safe */ _math_geometry_curve__WEBPACK_IMPORTED_MODULE_48__.Curve),
/* harmony export */   CurveFactory: () => (/* reexport safe */ _math_geometry__WEBPACK_IMPORTED_MODULE_27__.CurveFactory),
/* harmony export */   CurvePort: () => (/* reexport safe */ _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_25__.CurvePort),
/* harmony export */   DebugCurve: () => (/* reexport safe */ _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_33__.DebugCurve),
/* harmony export */   Edge: () => (/* reexport safe */ _structs_edge__WEBPACK_IMPORTED_MODULE_39__.Edge),
/* harmony export */   EdgeLabelPlacement: () => (/* reexport safe */ _layout_edgeLabelPlacement__WEBPACK_IMPORTED_MODULE_20__.EdgeLabelPlacement),
/* harmony export */   EdgeRoutingMode: () => (/* reexport safe */ _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_42__.EdgeRoutingMode),
/* harmony export */   EdgeRoutingSettings: () => (/* reexport safe */ _routing_EdgeRoutingSettings__WEBPACK_IMPORTED_MODULE_46__.EdgeRoutingSettings),
/* harmony export */   Ellipse: () => (/* reexport safe */ _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_47__.Ellipse),
/* harmony export */   Entity: () => (/* reexport safe */ _structs_entity__WEBPACK_IMPORTED_MODULE_53__.Entity),
/* harmony export */   EventHandler: () => (/* reexport safe */ _layout_core_geomObject__WEBPACK_IMPORTED_MODULE_8__.EventHandler),
/* harmony export */   FastIncrementalLayoutSettings: () => (/* reexport safe */ _layout_incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_56__.IPsepColaSetting),
/* harmony export */   FloatingPort: () => (/* reexport safe */ _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_24__.FloatingPort),
/* harmony export */   GeomEdge: () => (/* reexport safe */ _layout_core_geomEdge__WEBPACK_IMPORTED_MODULE_0__.GeomEdge),
/* harmony export */   GeomGraph: () => (/* reexport safe */ _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_3__.GeomGraph),
/* harmony export */   GeomLabel: () => (/* reexport safe */ _layout_core_geomLabel__WEBPACK_IMPORTED_MODULE_6__.GeomLabel),
/* harmony export */   GeomNode: () => (/* reexport safe */ _layout_core_geomNode__WEBPACK_IMPORTED_MODULE_7__.GeomNode),
/* harmony export */   GeomObject: () => (/* reexport safe */ _layout_core_geomObject__WEBPACK_IMPORTED_MODULE_8__.GeomObject),
/* harmony export */   Graph: () => (/* reexport safe */ _structs_graph__WEBPACK_IMPORTED_MODULE_13__.Graph),
/* harmony export */   GreedyRectanglePacking: () => (/* reexport safe */ _math_geometry_rectanglePacking_RectanglePacking__WEBPACK_IMPORTED_MODULE_32__.GreedyRectanglePacking),
/* harmony export */   IntPairMap: () => (/* reexport safe */ _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_16__.IntPairMap),
/* harmony export */   InteractiveEdgeRouter: () => (/* reexport safe */ _routing_interactiveEdgeRouter__WEBPACK_IMPORTED_MODULE_23__.InteractiveEdgeRouter),
/* harmony export */   IntersectionInfo: () => (/* reexport safe */ _math_geometry_intersectionInfo__WEBPACK_IMPORTED_MODULE_29__.IntersectionInfo),
/* harmony export */   JSONToICurve: () => (/* reexport safe */ _math_geometry_icurve__WEBPACK_IMPORTED_MODULE_54__.JSONToICurve),
/* harmony export */   Label: () => (/* reexport safe */ _structs_label__WEBPACK_IMPORTED_MODULE_14__.Label),
/* harmony export */   LayerDirectionEnum: () => (/* reexport safe */ _layout_layered_layerDirectionEnum__WEBPACK_IMPORTED_MODULE_37__.LayerDirectionEnum),
/* harmony export */   LayeredLayout: () => (/* reexport safe */ _layout_layered_layeredLayout__WEBPACK_IMPORTED_MODULE_35__.LayeredLayout),
/* harmony export */   LineSegment: () => (/* reexport safe */ _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_50__.LineSegment),
/* harmony export */   MdsLayoutSettings: () => (/* reexport safe */ _layout_mds_mDSLayoutSettings__WEBPACK_IMPORTED_MODULE_41__.MdsLayoutSettings),
/* harmony export */   Node: () => (/* reexport safe */ _structs_node__WEBPACK_IMPORTED_MODULE_40__.Node),
/* harmony export */   OptimalRectanglePacking: () => (/* reexport safe */ _math_geometry_rectanglePacking_OptimalRectanglePacking__WEBPACK_IMPORTED_MODULE_30__.OptimalRectanglePacking),
/* harmony export */   PackingConstants: () => (/* reexport safe */ _math_geometry_rectanglePacking_PackingConstants__WEBPACK_IMPORTED_MODULE_31__.PackingConstants),
/* harmony export */   PivotMDS: () => (/* reexport safe */ _layout_mds_pivotMDS__WEBPACK_IMPORTED_MODULE_18__.PivotMDS),
/* harmony export */   PlaneTransformation: () => (/* reexport safe */ _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_9__.PlaneTransformation),
/* harmony export */   Point: () => (/* reexport safe */ _math_geometry__WEBPACK_IMPORTED_MODULE_27__.Point),
/* harmony export */   PointLocation: () => (/* reexport safe */ _math_geometry__WEBPACK_IMPORTED_MODULE_27__.PointLocation),
/* harmony export */   Polyline: () => (/* reexport safe */ _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_51__.Polyline),
/* harmony export */   PolylinePoint: () => (/* reexport safe */ _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_17__.PolylinePoint),
/* harmony export */   Port: () => (/* reexport safe */ _layout_core_port__WEBPACK_IMPORTED_MODULE_26__.Port),
/* harmony export */   RTree: () => (/* reexport safe */ _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_10__.BinaryRTree),
/* harmony export */   Rectangle: () => (/* reexport safe */ _math_geometry__WEBPACK_IMPORTED_MODULE_27__.Rectangle),
/* harmony export */   RectangleNode: () => (/* reexport safe */ _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_1__.RectangleNode),
/* harmony export */   RectilinearEdgeRouter: () => (/* reexport safe */ _routing_rectilinear_RectilinearEdgeRouter__WEBPACK_IMPORTED_MODULE_45__.RectilinearEdgeRouter),
/* harmony export */   RectilinearInteractiveEditor: () => (/* reexport safe */ _routing_rectilinear_RectilinearInteractiveEditor__WEBPACK_IMPORTED_MODULE_19__.RectilinearInteractiveEditor),
/* harmony export */   RelativeFloatingPort: () => (/* reexport safe */ _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_22__.RelativeFloatingPort),
/* harmony export */   Size: () => (/* reexport safe */ _math_geometry__WEBPACK_IMPORTED_MODULE_27__.Size),
/* harmony export */   SmoothedPolyline: () => (/* reexport safe */ _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_11__.SmoothedPolyline),
/* harmony export */   SplineRouter: () => (/* reexport safe */ _routing_splineRouter__WEBPACK_IMPORTED_MODULE_43__.SplineRouter),
/* harmony export */   StraightLineEdges: () => (/* reexport safe */ _routing_StraightLineEdges__WEBPACK_IMPORTED_MODULE_21__.StraightLineEdges),
/* harmony export */   SugiyamaLayoutSettings: () => (/* reexport safe */ _layout_layered_sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_34__.SugiyamaLayoutSettings),
/* harmony export */   TileData: () => (/* reexport safe */ _layout_core_tile__WEBPACK_IMPORTED_MODULE_5__.Tile),
/* harmony export */   TileMap: () => (/* reexport safe */ _layout_core_tileMap__WEBPACK_IMPORTED_MODULE_4__.TileMap),
/* harmony export */   buildRTree: () => (/* reexport safe */ _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_3__.buildRTree),
/* harmony export */   buildRTreeWithInterpolatedEdges: () => (/* reexport safe */ _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_3__.buildRTreeWithInterpolatedEdges),
/* harmony export */   clipWithRectangle: () => (/* reexport safe */ _math_geometry_curve__WEBPACK_IMPORTED_MODULE_48__.clipWithRectangle),
/* harmony export */   createRectangleNodeOnData: () => (/* reexport safe */ _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_1__.createRectangleNodeOnData),
/* harmony export */   geometryIsCreated: () => (/* reexport safe */ _layout_driver__WEBPACK_IMPORTED_MODULE_38__.geometryIsCreated),
/* harmony export */   getGeomIntersectedObjects: () => (/* reexport safe */ _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_3__.getGeomIntersectedObjects),
/* harmony export */   iCurveToJSON: () => (/* reexport safe */ _math_geometry_icurve__WEBPACK_IMPORTED_MODULE_54__.iCurveToJSON),
/* harmony export */   insertRange: () => (/* reexport safe */ _utils_setOperations__WEBPACK_IMPORTED_MODULE_2__.insertRange),
/* harmony export */   interpolateICurve: () => (/* reexport safe */ _math_geometry__WEBPACK_IMPORTED_MODULE_27__.interpolateICurve),
/* harmony export */   intersectedObjects: () => (/* reexport safe */ _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_3__.intersectedObjects),
/* harmony export */   layoutGeomGraph: () => (/* reexport safe */ _layout_driver__WEBPACK_IMPORTED_MODULE_38__.layoutGeomGraph),
/* harmony export */   layoutGeomGraphInternal: () => (/* reexport safe */ _layout_driver__WEBPACK_IMPORTED_MODULE_38__.layoutGeomGraphDetailed),
/* harmony export */   layoutGraphWithMds: () => (/* reexport safe */ _layout_mds_pivotMDS__WEBPACK_IMPORTED_MODULE_18__.layoutGraphWithMds),
/* harmony export */   layoutGraphWithSugiayma: () => (/* reexport safe */ _layout_layered_layeredLayout__WEBPACK_IMPORTED_MODULE_35__.layoutGraphWithSugiayma),
/* harmony export */   layoutIsCalculated: () => (/* reexport safe */ _layout_driver__WEBPACK_IMPORTED_MODULE_38__.layoutIsCalculated),
/* harmony export */   pageRank: () => (/* reexport safe */ _structs_graph__WEBPACK_IMPORTED_MODULE_13__.pagerank),
/* harmony export */   parameterSpan: () => (/* reexport safe */ _math_geometry__WEBPACK_IMPORTED_MODULE_27__.parameterSpan),
/* harmony export */   routeEdges: () => (/* reexport safe */ _layout_driver__WEBPACK_IMPORTED_MODULE_38__.routeEdges),
/* harmony export */   routeRectilinearEdges: () => (/* reexport safe */ _layout_driver__WEBPACK_IMPORTED_MODULE_38__.routeRectilinearEdges),
/* harmony export */   setNewParent: () => (/* reexport safe */ _structs_graph__WEBPACK_IMPORTED_MODULE_13__.setNewParent)
/* harmony export */ });
/* harmony import */ var _layout_core_geomEdge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomEdge.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");
/* harmony import */ var _layout_core_tileMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/tileMap.js");
/* harmony import */ var _layout_core_tile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/tile.js");
/* harmony import */ var _layout_core_geomLabel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomLabel.js");
/* harmony import */ var _layout_core_geomNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomNode.js");
/* harmony import */ var _layout_core_geomObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomObject.js");
/* harmony import */ var _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/planeTransformation.js");
/* harmony import */ var _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js");
/* harmony import */ var _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js");
/* harmony import */ var _structs_attribute__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attribute.js");
/* harmony import */ var _structs_graph__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/graph.js");
/* harmony import */ var _structs_label__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/label.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/assert.js");
/* harmony import */ var _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairMap.js");
/* harmony import */ var _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js");
/* harmony import */ var _layout_mds_pivotMDS__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/pivotMDS.js");
/* harmony import */ var _routing_rectilinear_RectilinearInteractiveEditor__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearInteractiveEditor.js");
/* harmony import */ var _layout_edgeLabelPlacement__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/edgeLabelPlacement.js");
/* harmony import */ var _routing_StraightLineEdges__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/StraightLineEdges.js");
/* harmony import */ var _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/relativeFloatingPort.js");
/* harmony import */ var _routing_interactiveEdgeRouter__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/interactiveEdgeRouter.js");
/* harmony import */ var _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/floatingPort.js");
/* harmony import */ var _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/curvePort.js");
/* harmony import */ var _layout_core_port__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/port.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/cornerSite.js");
/* harmony import */ var _math_geometry_intersectionInfo__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/intersectionInfo.js");
/* harmony import */ var _math_geometry_rectanglePacking_OptimalRectanglePacking__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/OptimalRectanglePacking.js");
/* harmony import */ var _math_geometry_rectanglePacking_PackingConstants__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/PackingConstants.js");
/* harmony import */ var _math_geometry_rectanglePacking_RectanglePacking__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/RectanglePacking.js");
/* harmony import */ var _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/debugCurve.js");
/* harmony import */ var _layout_layered_sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/sugiyamaLayoutSettings.js");
/* harmony import */ var _layout_layered_layeredLayout__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layeredLayout.js");
/* harmony import */ var _utils_cancelToken__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/cancelToken.js");
/* harmony import */ var _layout_layered_layerDirectionEnum__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layerDirectionEnum.js");
/* harmony import */ var _layout_driver__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/driver.js");
/* harmony import */ var _structs_edge__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/edge.js");
/* harmony import */ var _structs_node__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/node.js");
/* harmony import */ var _layout_mds_mDSLayoutSettings__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/mDSLayoutSettings.js");
/* harmony import */ var _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/EdgeRoutingMode.js");
/* harmony import */ var _routing_splineRouter__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/splineRouter.js");
/* harmony import */ var _routing_BundlingSettings__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/BundlingSettings.js");
/* harmony import */ var _routing_rectilinear_RectilinearEdgeRouter__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearEdgeRouter.js");
/* harmony import */ var _routing_EdgeRoutingSettings__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/EdgeRoutingSettings.js");
/* harmony import */ var _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/bezierSeg.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/arrowhead.js");
/* harmony import */ var _structs_entity__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/entity.js");
/* harmony import */ var _math_geometry_icurve__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/icurve.js");
/* harmony import */ var _structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attributeRegistry.js");
/* harmony import */ var _layout_incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/iPsepColaSettings.js");
































































//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/commonLayoutSettings.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CommonLayoutSettings: () => (/* binding */ CommonLayoutSettings)
/* harmony export */ });
/* harmony import */ var _routing_EdgeRoutingSettings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/EdgeRoutingSettings.js");

/** The common data of layout settings: it specifies the minumal allowed distance between the nodes,  the minimal size of the resulting bounding box, settings for edge routing, and the ratio for the graph boxes packing algorithm  */
class CommonLayoutSettings {
    constructor() {
        this.edgeRoutingSettings = new _routing_EdgeRoutingSettings__WEBPACK_IMPORTED_MODULE_0__.EdgeRoutingSettings();
        this.nodeSeparation = 10;
        this.packingAspectRatio = 1.5;
    }
    static fromJSON(s) {
        const ret = new CommonLayoutSettings();
        if (s.nodeSeparation != 10) {
            ret.nodeSeparation = s.nodeSeparation;
        }
        if (s.packingAspectRatio) {
            ret.packingAspectRatio = s.packingAspectRatio;
        }
        if (s.edgeRoutingSettings) {
            ret.edgeRoutingSettings = _routing_EdgeRoutingSettings__WEBPACK_IMPORTED_MODULE_0__.EdgeRoutingSettings.fromJSON(s.edgeRoutingSettings);
        }
        return ret;
    }
    toJSON() {
        let differentFromDefault = false;
        const ret = {};
        if (this.nodeSeparation != 10) {
            ret.nodeSeparation = this.nodeSeparation;
            differentFromDefault = true;
        }
        if (this.packingAspectRatio != 1.5) {
            ret.packingAspectRatio = this.packingAspectRatio;
            differentFromDefault = true;
        }
        if ((ret.edgeRoutingSettings = this.edgeRoutingSettings.toJSON())) {
            differentFromDefault = true;
        }
        return differentFromDefault ? ret : undefined;
    }
    get NodeSeparation() {
        return this.nodeSeparation;
    }
    set NodeSeparation(value) {
        this.nodeSeparation = value;
    }
    get PackingAspectRatio() {
        return this.packingAspectRatio;
    }
    set PackingAspectRatio(value) {
        this.packingAspectRatio = value;
    }
}
//# sourceMappingURL=commonLayoutSettings.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/RRect.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RRect: () => (/* binding */ RRect)
/* harmony export */ });
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");


class RRect extends _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_0__.Rectangle {
    constructor(t) {
        super(t);
        this.radX = t.radX;
        this.radY = t.radY;
        this.roundedRect_ = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkRectangleWithRoundedCorners(this.width, this.height, t.radX, t.radY, this.center);
    }
    onUpdated() {
        if (!this.isEmpty) {
            this.roundedRect_ = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkRectangleWithRoundedCorners(this.width, this.height, this.radX, this.radY, this.center);
        }
    }
    isOk() {
        if (this.isEmpty()) {
            return true;
        }
        return this.roundedRect_.boundingBox.equalEps(this);
    }
    setRect(value) {
        this.left = value.left;
        this.right = value.right;
        this.top = value.top;
        this.bottom = value.bottom;
        if (!this.isEmpty()) {
            this.roundedRect_ = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkRectangleWithRoundedCorners(value.width, value.height, this.radX, this.radY, this.center);
        }
    }
}
//# sourceMappingURL=RRect.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/arrowhead.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Arrowhead: () => (/* binding */ Arrowhead)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");





class Arrowhead {
    toJSON() {
        let str = '{';
        if (this.tipPosition) {
            str += '"tipPosition": ' + this.tipPosition.toJSON();
        }
        str += '}';
        return str;
    }
    clone() {
        const r = new Arrowhead();
        r.length = this.length;
        r.width = this.width;
        r.tipPosition = this.tipPosition;
        return r;
    }
    constructor() {
        this.length = Arrowhead.defaultArrowheadLength;
        this.width = 0;
        // just for debug
        this.length = Arrowhead.defaultArrowheadLength;
    }
    // the edgeGeometry.Curve is trimmed already by the node boundaries</param>
    static calculateArrowheads(edge) {
        if (edge.sourceArrowhead == null && edge.targetArrowhead == null)
            return true;
        const parStart = Arrowhead.findTrimStartForArrowheadAtSource(edge);
        if (parStart == null) {
            return false;
        }
        const parEnd = Arrowhead.findTrimEndForArrowheadAtTarget(edge);
        if (parEnd == null) {
            return false;
        }
        if (parStart > parEnd - _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon ||
            _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.closeIntersectionPoints(edge.curve.value(parStart), edge.curve.value(parEnd)))
            return false; //after the trim nothing would be left of the curve
        const c = edge.curve.trim(parStart, parEnd);
        if (c == null)
            return false;
        if (edge.sourceArrowhead != null)
            edge.sourceArrowhead.tipPosition = edge.curve.start;
        if (edge.targetArrowhead != null)
            edge.targetArrowhead.tipPosition = edge.curve.end;
        edge.curve = c;
        return true;
    }
    static getIntersectionsWithArrowheadCircle(curve, arrowheadLength, circleCenter) {
        const e = _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_3__.Ellipse.mkFullEllipseNNP(arrowheadLength, arrowheadLength, circleCenter);
        return _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.getAllIntersections(e, curve, true);
    }
    // we need to pass arrowhead length here since the original length mibh
    static findTrimEndForArrowheadAtTarget(edgeGeometry) {
        const eps = _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon * _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon;
        //Assert.assert((edgeGeometry.Curve.End - edgeGeometry.Curve.start).LengthSquared > eps);
        let p = edgeGeometry.curve.parEnd;
        if (edgeGeometry.targetArrowhead == null || edgeGeometry.targetArrowhead.length <= _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon)
            return p;
        const curve = edgeGeometry.curve;
        let arrowheadLength = edgeGeometry.targetArrowhead.length;
        let newCurveEnd;
        let intersections;
        let reps = 10;
        do {
            reps--;
            if (reps === 0)
                return;
            intersections = Arrowhead.getIntersectionsWithArrowheadCircle(curve, arrowheadLength, curve.end);
            p = intersections.length !== 0 ? Math.max(...intersections.map((x) => x.par1)) : curve.parEnd;
            newCurveEnd = edgeGeometry.curve.value(p);
            arrowheadLength /= 2;
        } while (newCurveEnd.sub(curve.start).lengthSquared < eps || intersections.length === 0);
        //we would like to have at least something left from the curve
        return p;
    }
    static findTrimStartForArrowheadAtSource(edgeGeometry) {
        if (edgeGeometry.sourceArrowhead == null || edgeGeometry.sourceArrowhead.length <= _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon)
            return edgeGeometry.curve.parStart;
        const eps = _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon * _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon;
        /*Assert.assert(
          edgeGeometry.curve.end.sub(edgeGeometry.curve.start).lengthSquared > eps,
        )*/
        let arrowheadLength = edgeGeometry.sourceArrowhead.length;
        let newStart;
        const curve = edgeGeometry.curve;
        let intersections;
        let reps = 10;
        let p;
        while (--reps > 0) {
            intersections = Arrowhead.getIntersectionsWithArrowheadCircle(curve, arrowheadLength, curve.start);
            if (intersections.length === 0)
                return curve.parStart;
            p = Math.min(...intersections.map((x) => x.par1));
            newStart = intersections.filter((x) => x.par1 === p)[0].x;
            // check that something is left from the curve
            if (newStart.sub(curve.end).lengthSquared >= eps)
                return p;
            arrowheadLength /= 2;
        }
    }
    // trim the edge curve with the node boundaries
    static trimSplineAndCalculateArrowheads(edge, spline, narrowestInterval) {
        return Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, spline, narrowestInterval);
    }
    // trim the edge curve with the node boundaries
    static trimSplineAndCalculateArrowheadsII(edgeGeometry, sourceBoundary, targetBoundary, spline, narrowestInterval) {
        edgeGeometry.curve = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.trimEdgeSplineWithNodeBoundaries(sourceBoundary, targetBoundary, spline, narrowestInterval);
        if (edgeGeometry.curve == null)
            return false;
        if ((edgeGeometry.sourceArrowhead == null || edgeGeometry.sourceArrowhead.length < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) &&
            (edgeGeometry.targetArrowhead == null || edgeGeometry.targetArrowhead.length < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon))
            return true; //there are no arrowheads
        let success = false;
        const sourceArrowheadSavedLength = edgeGeometry.sourceArrowhead != null ? edgeGeometry.sourceArrowhead.length : 0;
        const targetArrowheadSavedLength = edgeGeometry.targetArrowhead != null ? edgeGeometry.targetArrowhead.length : 0;
        const len = edgeGeometry.curve.end.sub(edgeGeometry.curve.start).length;
        if (edgeGeometry.sourceArrowhead != null)
            edgeGeometry.sourceArrowhead.length = Math.min(len, sourceArrowheadSavedLength);
        if (edgeGeometry.targetArrowhead != null)
            edgeGeometry.targetArrowhead.length = Math.min(len, targetArrowheadSavedLength);
        let count = 10;
        while (((edgeGeometry.sourceArrowhead != null && edgeGeometry.sourceArrowhead.length > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon) ||
            (edgeGeometry.targetArrowhead != null && edgeGeometry.targetArrowhead.length > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon)) &&
            !success) {
            success = Arrowhead.calculateArrowheads(edgeGeometry);
            if (!success) {
                if (edgeGeometry.sourceArrowhead != null)
                    edgeGeometry.sourceArrowhead.length *= 0.5;
                if (edgeGeometry.targetArrowhead != null)
                    edgeGeometry.targetArrowhead.length *= 0.5;
            }
            count--;
            if (count === 0)
                break;
        }
        if (!success) {
            //to avoid drawing the arrowhead to (0,0)
            if (edgeGeometry.sourceArrowhead != null)
                edgeGeometry.sourceArrowhead.tipPosition = spline.start;
            if (edgeGeometry.targetArrowhead != null)
                edgeGeometry.targetArrowhead.tipPosition = spline.end;
        }
        if (edgeGeometry.sourceArrowhead != null)
            edgeGeometry.sourceArrowhead.length = sourceArrowheadSavedLength;
        if (edgeGeometry.targetArrowhead != null)
            edgeGeometry.targetArrowhead.length = targetArrowheadSavedLength;
        return success;
    }
    /** Creates a spline between two nodes big enough to draw arrowheads */
    static createBigEnoughSpline(edge) {
        const a = edge.source.center;
        let b = edge.target.center;
        const bMinA = b.sub(a);
        const l = bMinA.length;
        let perp;
        if (l < 0.001) {
            perp = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);
            b = a.add(perp.rotate(Math.PI / 2));
        }
        else {
            perp = bMinA.rotate(Math.PI / 2);
        }
        let maxArrowLength = 1;
        if (edge.sourceArrowhead != null) {
            maxArrowLength += edge.sourceArrowhead.length;
        }
        if (edge.targetArrowhead != null) {
            maxArrowLength += edge.targetArrowhead.length;
        }
        perp = perp.normalize().mul(1.5 * maxArrowLength);
        for (let i = 1; i < 10000; i = i * 2) {
            const seg = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.createBezierSegN(a, b, perp, i);
            if (Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, seg, false)) {
                return;
            }
        }
        Arrowhead.createEdgeCurveWithNoTrimming(edge, a, b);
    }
    // this method should never be called: it is a super emergency measure
    static createEdgeCurveWithNoTrimming(edge, a, b) {
        const ab = b.sub(a).normalize();
        let lineStart = a;
        let lineEnd = b;
        const targetArrow = edge.targetArrowhead;
        if (targetArrow != null) {
            targetArrow.tipPosition = b;
            lineEnd = b.sub(ab.mul(targetArrow.length));
        }
        const sourceArrow = edge.sourceArrowhead;
        if (sourceArrow != null) {
            sourceArrow.tipPosition = a;
            lineStart = a.add(ab.mul(sourceArrow.length));
        }
        edge.curve = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(lineStart, lineEnd);
    }
}
Arrowhead.defaultArrowheadLength = 5;
//# sourceMappingURL=arrowhead.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/curvePort.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CurvePort: () => (/* binding */ CurvePort)
/* harmony export */ });
/* harmony import */ var _port__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/port.js");

class CurvePort extends _port__WEBPACK_IMPORTED_MODULE_0__.Port {
    get Location() {
        return this.curve.value(this.parameter);
    }
    set Location(value) {
        throw new Error('Method should not be called.');
    }
    // constructor
    static mk(curve, parameter) {
        const ret = new CurvePort();
        ret.curve = curve;
        ret.parameter = parameter;
        return ret;
    }
    get Parameter() {
        return this.parameter;
    }
    set Parameter(value) {
        this.parameter = value;
    }
    get Curve() {
        return this.curve;
    }
    set Curve(value) {
        this.curve = value;
    }
}
//# sourceMappingURL=curvePort.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/floatingPort.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FloatingPort: () => (/* binding */ FloatingPort)
/* harmony export */ });
/* harmony import */ var _port__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/port.js");

class FloatingPort extends _port__WEBPACK_IMPORTED_MODULE_0__.Port {
    // a curve associated with the port
    // constructor
    constructor(curve, location) {
        super();
        this.curve = this.curve;
        this.location = location.clone();
    }
    // the location of the port
    get Location() {
        return this.location;
    }
    set Location(value) {
        this.location = value;
    }
    // translate the port location by delta
    Translate(delta) {
        this.location = this.location.add(delta);
    }
    // the port's curve
    get Curve() {
        return this.curve;
    }
    set Curve(value) {
        this.curve = value;
    }
}
//# sourceMappingURL=floatingPort.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/geomEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomEdge: () => (/* binding */ GeomEdge)
/* harmony export */ });
/* harmony import */ var _geomObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomObject.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js");
/* harmony import */ var _geomLabel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomLabel.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attributeRegistry.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/bezierSeg.js");









class GeomEdge extends _geomObject__WEBPACK_IMPORTED_MODULE_0__.GeomObject {
    *getSmoothPolyPoints() {
        yield this.source.center;
        if (this.curve instanceof _math_geometry__WEBPACK_IMPORTED_MODULE_6__.Curve) {
            yield* this.getCurvePoints(this.curve);
        }
        else if (this.curve instanceof _math_geometry__WEBPACK_IMPORTED_MODULE_6__.LineSegment) {
            yield this.curve.start;
            yield this.curve.end;
        }
        else if (this.curve instanceof _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_7__.Ellipse) {
            yield this.curve.start;
            yield this.curve.value((this.curve.parStart + this.curve.parEnd) / 0.5);
            yield this.curve.end;
        }
        else if (this.curve instanceof _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_8__.BezierSeg) {
            yield this.curve.start;
            yield this.curve.value(0.25);
            yield this.curve.value(0.75);
            yield this.curve.end;
        }
        yield this.target.center;
    }
    *getCurvePoints(curve) {
        for (const e of curve.segs) {
            yield e.start;
            if (e instanceof _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_8__.BezierSeg) {
                const p = topOfBezierSeg(e);
                if (p)
                    yield p;
            }
        }
        yield curve.end;
    }
    static getGeom(e) {
        return _geomObject__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(e);
    }
    /** clones but does not bind to the entity */
    clone() {
        const geomEdge = new GeomEdge(null);
        if (this.smoothedPolyline)
            geomEdge.smoothedPolyline = this.smoothedPolyline.clone();
        geomEdge.curve = this.curve.clone();
        if (this.sourceArrowhead != null) {
            geomEdge.sourceArrowhead = this.sourceArrowhead.clone();
        }
        if (this.targetArrowhead != null) {
            geomEdge.targetArrowhead = this.targetArrowhead.clone();
        }
        return geomEdge;
    }
    get label() {
        return this.edge != null && this.edge.label != null ? _geomObject__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(this.edge.label) : null;
    }
    set label(value) {
        this.edge.label.setAttr(_structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_5__.AttributeRegistry.GeomObjectIndex, value);
    }
    RaiseLayoutChangeEvent(delta) {
        this.edge.raiseEvents(delta);
    }
    requireRouting() {
        this.curve = null;
        this.smoothedPolyline = null;
    }
    translate(delta) {
        if (delta.x === 0 && delta.y === 0)
            return;
        // RaiseLayoutChangeEvent(delta);
        if (this.curve != null)
            this.curve.translate(delta);
        if (this.smoothedPolyline != null)
            for (let s = this.smoothedPolyline.headSite, s0 = this.smoothedPolyline.headSite; s != null; s = s.next, s0 = s0.next)
                s.point = s0.point.add(delta);
        if (this.sourceArrowhead != null && this.sourceArrowhead.tipPosition)
            this.sourceArrowhead.tipPosition = this.sourceArrowhead.tipPosition.add(delta);
        if (this.targetArrowhead != null && this.targetArrowhead.tipPosition)
            this.targetArrowhead.tipPosition = this.targetArrowhead.tipPosition.add(delta);
        if (this.edge.label) {
            const geomLabel = _geomLabel__WEBPACK_IMPORTED_MODULE_3__.GeomLabel.getGeom(this.edge.label);
            if (geomLabel)
                geomLabel.translate(delta);
        }
    }
    GetMaxArrowheadLength() {
        let l = 0;
        if (this.sourceArrowhead != null) {
            l = this.sourceArrowhead.length;
        }
        if (this.targetArrowhead != null && this.targetArrowhead.length > l) {
            return this.targetArrowhead.length;
        }
        return l;
    }
    transform(matrix) {
        if (this.curve == null)
            return;
        this.curve = this.curve.transform(matrix);
        if (this.smoothedPolyline != null)
            for (let s = this.smoothedPolyline.headSite, s0 = this.smoothedPolyline.headSite; s != null; s = s.next, s0 = s0.next)
                s.point = matrix.multiplyPoint(s.point);
        if (this.sourceArrowhead != null) {
            this.sourceArrowhead.tipPosition = matrix.multiplyPoint(this.sourceArrowhead.tipPosition);
        }
        if (this.targetArrowhead != null) {
            this.targetArrowhead.tipPosition = matrix.multiplyPoint(this.targetArrowhead.tipPosition);
        }
    }
    get edge() {
        return this.entity;
    }
    get source() {
        return _geomObject__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(this.edge.source);
    }
    /** iterates over the source arrowhead corner points */
    *sourceArrowheadPoints(angle) {
        if (this.sourceArrowhead == null)
            return;
        yield this.sourceArrowhead.tipPosition;
        let d = this.sourceArrowhead.tipPosition.sub(this.curve.start);
        // assume that the arrowhead angle is 25 degrees
        d = d.rotate90Cw().mul(Math.tan(angle * 0.5 * (Math.PI / 180.0)));
        yield d.add(this.curve.start);
        yield this.curve.start.sub(d);
    }
    /** iterates over the target arrowhead corner points */
    *targetArrowheadPoints(angle) {
        if (this.targetArrowhead == null)
            return;
        yield this.targetArrowhead.tipPosition;
        let d = this.targetArrowhead.tipPosition.sub(this.curve.end);
        // assume that the arrowhead angle is 25 degrees
        d = d.rotate90Cw().mul(Math.tan(angle * 0.5 * (Math.PI / 180.0)));
        yield d.add(this.curve.end);
        yield this.curve.end.sub(d);
    }
    get boundingBox() {
        const rect = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkEmpty();
        if (this.smoothedPolyline != null)
            for (const p of this.smoothedPolyline)
                rect.add(p);
        if (this.curve != null)
            rect.addRecSelf(this.curve.boundingBox);
        for (const p of this.sourceArrowheadPoints(25)) {
            rect.add(p);
        }
        for (const p of this.targetArrowheadPoints(25)) {
            rect.add(p);
        }
        if (this.label) {
            rect.addRecSelf(this.label.boundingBox);
        }
        const del = this.lineWidth;
        rect.left -= del;
        rect.top += del;
        rect.right += del;
        rect.bottom -= del;
        return rect;
    }
    isInterGraphEdge() {
        return this.edge.isInterGraphEdge();
    }
    get target() {
        return _geomObject__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(this.edge.target);
    }
    constructor(edge) {
        super(edge);
        this.lineWidth = 1;
    }
    toString() {
        return this.source.toString() + '->' + this.target;
    }
    static RouteSelfEdge(boundaryCurve, howMuchToStickOut, t) {
        // we just need to find the box of the corresponding node
        const w = boundaryCurve.boundingBox.width;
        const h = boundaryCurve.boundingBox.height;
        const center = boundaryCurve.boundingBox.center;
        const p0 = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point(center.x - w / 4, center.y);
        const p1 = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point(center.x - w / 4, center.y - h / 2 - howMuchToStickOut);
        const p2 = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point(center.x + w / 4, center.y - h / 2 - howMuchToStickOut);
        const p3 = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point(center.x + w / 4, center.y);
        t.smoothedPolyline = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_2__.SmoothedPolyline.mkFromPoints([p0, p1, p2, p3]);
        return t.smoothedPolyline.createCurve();
    }
    underCollapsedGraph() {
        return this.source.underCollapsedGraph() || this.target.underCollapsedGraph();
    }
    EdgeToAncestor() {
        return this.edge.EdgeToAncestor();
    }
}
function topOfBezierSeg(e) {
    return _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.lineLineIntersection(e.b[0], e.b[1], e.b[2], e.b[3]);
}
//# sourceMappingURL=geomEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/geomGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomGraph: () => (/* binding */ GeomGraph),
/* harmony export */   buildRTree: () => (/* binding */ buildRTree),
/* harmony export */   buildRTreeWithInterpolatedEdges: () => (/* binding */ buildRTreeWithInterpolatedEdges),
/* harmony export */   getGeomIntersectedObjects: () => (/* binding */ getGeomIntersectedObjects),
/* harmony export */   intersectedObjects: () => (/* binding */ intersectedObjects),
/* harmony export */   optimalPackingRunner: () => (/* binding */ optimalPackingRunner),
/* harmony export */   pumpTheBoxToTheGraph: () => (/* binding */ pumpTheBoxToTheGraph)
/* harmony export */ });
/* harmony import */ var _structs_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/graph.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _geomObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomObject.js");
/* harmony import */ var _geomNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomNode.js");
/* harmony import */ var _geomEdge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomEdge.js");
/* harmony import */ var _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/planeTransformation.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_rectanglePacking_OptimalRectanglePacking__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/OptimalRectanglePacking.js");
/* harmony import */ var _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _RRect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/RRect.js");
/* harmony import */ var _structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attributeRegistry.js");
/* harmony import */ var _structs_edge__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/edge.js");
/* harmony import */ var _structs_node__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/node.js");
/* harmony import */ var _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/pointPair.js");















// packs the subgraphs and set the bounding box of the parent graph
function optimalPackingRunner(geomGraph, subGraphs) {
    const subgraphsRects = subGraphs.map((g) => [g, g.boundingBox]); // g.boundingBox is a clone of the graph rectangle
    const rectangles = subgraphsRects.map((t) => t[1]);
    const packing = new _math_geometry_rectanglePacking_OptimalRectanglePacking__WEBPACK_IMPORTED_MODULE_7__.OptimalRectanglePacking(rectangles, 1.5);
    packing.run();
    for (const [g, rect] of subgraphsRects) {
        const delta = rect.leftBottom.sub(g.boundingBox.leftBottom);
        g.translate(delta);
    }
    geomGraph.boundingBox = new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle({
        left: 0,
        bottom: 0,
        right: packing.PackedWidth,
        top: packing.PackedHeight,
    });
}
/** GeomGraph is an attribute on a Graph. The underlying Graph keeps all structural information but GeomGraph holds the geometry data, and the layout settings */
class GeomGraph extends _geomNode__WEBPACK_IMPORTED_MODULE_3__.GeomNode {
    isAncestor(source) {
        return this.graph.isAncestor(source.node);
    }
    deepTranslate(delta) {
        for (const n of this.nodesBreadthFirst) {
            if (n instanceof GeomGraph) {
                n.boundingBox = n.boundingBox.translate(delta);
            }
            else {
                n.translate(delta);
            }
            for (const e of n.selfEdges()) {
                e.translate(delta);
            }
            for (const e of n.outEdges()) {
                if (this.graph.isAncestor(e.target.node))
                    e.translate(delta);
            }
        }
        this.boundingBox = this.boundingBox.translate(delta);
    }
    /** it is a rather shallow clone */
    clone() {
        const gg = new GeomGraph(null);
        gg.boundingBox = this.boundingBox.clone();
        gg.layoutSettings = this.layoutSettings;
        gg.margins = this.margins;
        gg.radX = this.radX;
        gg.radY = this.radY;
        return gg;
    }
    /** Calculate bounding box from children, not updating the bounding boxes recursively. */
    calculateBoundsFromChildren() {
        const bb = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkEmpty();
        for (const n of this.shallowNodes) {
            bb.addRecSelf(n.boundingBoxWithPadding);
        }
        bb.padEverywhere(this.margins);
        return bb;
    }
    *allSuccessorsWidthFirst() {
        for (const n of this.graph.allSuccessorsWidthFirst()) {
            yield _geomNode__WEBPACK_IMPORTED_MODULE_3__.GeomNode.getGeom(n);
        }
    }
    static getGeom(attrCont) {
        return _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(attrCont);
    }
    edgeCurveOrArrowheadsIntersectRect(geomEdge, rect) {
        for (const p of geomEdge.sourceArrowheadPoints(25)) {
            if (rect.contains(p))
                return true;
        }
        for (const p of geomEdge.targetArrowheadPoints(25)) {
            if (rect.contains(p))
                return true;
        }
        const curveUnderTest = geomEdge.curve;
        const perimeter = rect.perimeter();
        return (_math_geometry__WEBPACK_IMPORTED_MODULE_9__.Curve.intersectionOne(curveUnderTest, perimeter, false) != null ||
            _math_geometry__WEBPACK_IMPORTED_MODULE_9__.Curve.PointRelativeToCurveLocation(curveUnderTest.start, perimeter) === _math_geometry__WEBPACK_IMPORTED_MODULE_9__.PointLocation.Inside);
    }
    isEmpty() {
        return this.graph.isEmpty();
    }
    setSettingsRecursively(ls) {
        this.layoutSettings = ls;
        for (const n of this.nodesBreadthFirst) {
            const gg = n;
            gg.layoutSettings = ls;
        }
    }
    get layoutSettings() {
        return this._layoutSettings;
    }
    // recursively sets the same settings for subgraphs
    set layoutSettings(value) {
        this._layoutSettings = value;
    }
    get labelSize() {
        return this._labelSize;
    }
    set labelSize(value) {
        this._labelSize = value;
    }
    get boundingBox() {
        if (this.rrect)
            return this.rrect.clone();
        else
            return null;
    }
    set boundingBox(value) {
        if (value) {
            this.rrect.setRect(value);
        }
        else {
            this.rrect.roundedRect_ = null;
        }
        // Assert.assert(this.bbIsCorrect())
    }
    transform(matrix) {
        if (matrix.isIdentity())
            return;
        for (const n of this.shallowNodes) {
            n.transform(matrix);
        }
        for (const e of this.shallowEdges) {
            e.transform(matrix);
            if (e.label)
                e.label.transform(matrix);
        }
        this.boundingBox =
            this.rrect == null || this.rrect.isEmpty() ? this.pumpTheBoxToTheGraphWithMargins() : this.boundingBox.transform(matrix);
    }
    /** Contrary to the deepTranslate() it also translates edges leading out of the graph */
    translate(delta) {
        if (delta.x === 0 && delta.y === 0)
            return;
        this.deepTranslate(delta);
    }
    get nodesBreadthFirst() {
        return this.nodesBreadthFirstIter();
    }
    *nodesBreadthFirstIter() {
        for (const n of this.graph.nodesBreadthFirst) {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(n);
        }
    }
    setEdge(s, t) {
        const structEdge = this.graph.setEdge(s, t);
        return new _geomEdge__WEBPACK_IMPORTED_MODULE_4__.GeomEdge(structEdge);
    }
    /** this does not change the graph bounding box */
    getPumpedGraphWithMarginsBox() {
        const t = { b: _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkEmpty() };
        pumpTheBoxToTheGraph(this, t);
        t.b.padEverywhere(this.margins);
        return t.b;
    }
    /** sets the bounding box and the boundary curve as well */
    pumpTheBoxToTheGraphWithMargins() {
        return (this.boundingBox = this.getPumpedGraphWithMarginsBox());
    }
    // Fields which are set by Msagl
    // return the center of the curve bounding box
    get center() {
        return this.boundingBox || this.boundingBox.isEmpty ? this.boundingBox.center : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_6__.Point(0, 0);
    }
    set center(value) {
        // Assert.assert(this.bbIsCorrect())
        const del = value.sub(this.center);
        const t = new _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_5__.PlaneTransformation(1, 0, del.x, 0, 1, del.y);
        this.transform(t);
    }
    get left() {
        return this.boundingBox.left;
    }
    get right() {
        return this.boundingBox.right;
    }
    get top() {
        return this.boundingBox.top;
    }
    get bottom() {
        return this.boundingBox.bottom;
    }
    CheckClusterConsistency() {
        throw new Error('Method not implemented.');
    }
    get edgeCount() {
        return this.graph.edgeCount;
    }
    get boundaryCurve() {
        // Assert.assert(this.rrect.isOk())
        return this.rrect.roundedRect_;
    }
    set boundaryCurve(value) {
        throw new Error();
    }
    get shallowNodes() {
        return this.shallowNodes_();
    }
    *shallowNodes_() {
        for (const n of this.graph.shallowNodes)
            yield _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(n);
    }
    /** iterates over the edges of the graph which adjacent to the nodes of the graph:
     * not iterating over the subgraphs
     */
    /** iterates over the edges of the graph including subgraphs */
    get deepEdges() {
        return this.deepEdgesIt();
    }
    *deepEdgesIt() {
        for (const e of this.graph.deepEdges) {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(e);
        }
    }
    get shallowEdges() {
        return this.shallowEdgesIt();
    }
    *shallowEdgesIt() {
        for (const e of this.graph.shallowEdges) {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(e);
        }
    }
    static mk(id, labelSize = new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Size(0, 0)) {
        const g = new GeomGraph(new _structs_graph__WEBPACK_IMPORTED_MODULE_0__.Graph(id));
        g.labelSize = labelSize;
        return g;
    }
    get Clusters() {
        return this.subgraphs();
    }
    /** iterates over all subgraphs  */
    *subgraphs() {
        for (const g of this.graph.subgraphsBreadthFirst()) {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(g);
        }
    }
    static mkWithGraphAndLabel(graph, labelSize) {
        const g = new GeomGraph(graph);
        g.labelSize = labelSize;
        return g;
    }
    constructor(graph) {
        super(graph);
        /** The empty space between the graph inner entities and its boundary */
        this.margins = { left: 10, top: 10, bottom: 10, right: 10 };
        /** The X radius of the rounded rectangle border */
        this.radX = 10;
        /** The Y radius of the rounded rectangle border */
        this.radY = 10;
        this.rrect = new _RRect__WEBPACK_IMPORTED_MODULE_10__.RRect({ left: 0, right: -1, top: 20, bottom: 0, radX: this.radX, radY: this.radY });
    }
    get deepNodeCount() {
        let n = 0;
        for (const v of this.graph.nodesBreadthFirst)
            n++;
        return n;
    }
    get subgraphsDepthFirst() {
        return this.getSubgraphsDepthFirst();
    }
    *getSubgraphsDepthFirst() {
        for (const n of this.graph.allSuccessorsDepthFirst()) {
            if (n instanceof _structs_graph__WEBPACK_IMPORTED_MODULE_0__.Graph)
                yield GeomGraph.getGeom(n);
        }
    }
    get uniformMargins() {
        return Math.max(this.margins.left, this.margins.right, this.margins.right, this.margins.bottom);
    }
    set uniformMargins(value) {
        this.margins.left = this.margins.right = this.margins.right = this.margins.bottom = value;
    }
    get height() {
        return this.boundingBox.height;
    }
    get width() {
        return this.boundingBox.width;
    }
    get shallowNodeCount() {
        return this.graph.shallowNodeCount;
    }
    get graph() {
        return this.entity;
    }
    liftNode(n) {
        const liftedNode = this.graph.liftNode(n.node);
        return liftedNode ? _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(liftedNode) : null;
    }
    findNode(id) {
        const n = this.graph.findNode(id);
        if (!n)
            return null;
        return _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(n);
    }
    addNode(gn) {
        this.graph.addNode(gn.node);
        return gn;
    }
    addLabelToGraphBB(rect) {
        if (this.labelSize) {
            rect.top += this.labelSize.height + 2; // 2 for label margin
            if (rect.width < this.labelSize.width) {
                rect.width = this.labelSize.width;
            }
        }
    }
}
function pumpTheBoxToTheGraph(igraph, t) {
    for (const e of igraph.shallowEdges) {
        if (!isProperEdge(e))
            continue;
        const cb = e.curve.boundingBox;
        // cb.pad(e.lineWidth)
        t.b.addRecSelf(cb);
        if (e.edge.label != null) {
            const labelGeom = _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(e.edge.label);
            if (labelGeom) {
                t.b.addRecSelf(labelGeom.boundingBox);
            }
        }
    }
    for (const n of igraph.shallowNodes) {
        if ('shallowEdges' in n) {
            pumpTheBoxToTheGraph(n, t);
        }
        if (n.underCollapsedGraph() || !n.boundingBox)
            continue;
        t.b.addRecSelf(n.boundingBox);
    }
    if (igraph instanceof GeomGraph) {
        igraph.addLabelToGraphBB(t.b);
    }
    function isProperEdge(geomEdge) {
        if (geomEdge == null)
            return false;
        if (geomEdge.curve == null)
            return false;
        if (geomEdge.underCollapsedGraph())
            return false;
        if (igraph instanceof GeomGraph) {
            const graph = igraph.entity;
            return graph.isAncestor(geomEdge.source.entity) && graph.isAncestor(geomEdge.target.entity);
        }
        else {
            return true;
        }
    }
}
/** iterate over the graph objects intersected by a rectangle: by default, return only the intersected nodes */
function* intersectedObjects(rtree, rect, onlyNodes = true) {
    const result = rtree.GetAllIntersecting(rect);
    if (onlyNodes) {
        for (const r of result) {
            if (r instanceof _structs_node__WEBPACK_IMPORTED_MODULE_13__.Node)
                yield r;
        }
    }
    else {
        // nodes and edges
        for (const r of result) {
            if (r instanceof _structs_node__WEBPACK_IMPORTED_MODULE_13__.Node || r instanceof _structs_edge__WEBPACK_IMPORTED_MODULE_12__.Edge)
                yield r;
        }
    }
}
function buildRTree(graph) {
    const data = Array.from(graph.nodesBreadthFirst)
        .concat(Array.from(graph.deepEdges))
        .map((o) => [_geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(o).boundingBox, o]);
    return (0,_math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_8__.mkRTree)(data);
}
function* getGeomIntersectedObjects(tree, slack, point) {
    if (!tree)
        return;
    const rect = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkSizeCenter(new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Size(slack * 2), point);
    for (const t of tree.RootNode.AllHitItems(rect, null)) {
        if ('edge' in t) {
            if (dist(point, t.pp._first, t.pp._second) < slack) {
                yield _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(t.edge);
            }
        }
        else {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(t);
        }
    }
    function dist(p, s, e) {
        const l = e.sub(s);
        const len = l.length;
        if (len < 1.0 / 10) {
            return p.sub(_math_geometry_point__WEBPACK_IMPORTED_MODULE_6__.Point.middle(s, e)).length;
        }
        const perp = l.rotate90Cw();
        return Math.abs(p.sub(s).dot(perp)) / len;
    }
}
function buildRTreeWithInterpolatedEdges(graph, slack) {
    if (graph == null)
        return null;
    const nodes = Array.from(graph.nodesBreadthFirst).map((n) => [_geomNode__WEBPACK_IMPORTED_MODULE_3__.GeomNode.getGeom(n).boundingBox, n]);
    const edgesPlusEdgeLabels = [];
    for (const e of graph.deepEdges) {
        const ge = e.getAttr(_structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_11__.AttributeRegistry.GeomObjectIndex);
        if (!ge)
            continue;
        if (ge.label) {
            edgesPlusEdgeLabels.push([ge.label.boundingBox, e.label]);
        }
        if (!ge.curve)
            continue;
        const poly = (0,_math_geometry__WEBPACK_IMPORTED_MODULE_9__.interpolateICurve)(ge.curve, slack / 2);
        if (ge.sourceArrowhead) {
            edgesPlusEdgeLabels.push([
                _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(ge.sourceArrowhead.tipPosition, ge.curve.start),
                { edge: e, pp: new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_14__.PointPair(ge.sourceArrowhead.tipPosition, ge.curve.start) },
            ]);
        }
        for (let i = 0; i < poly.length - 1; i++) {
            edgesPlusEdgeLabels.push([_math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(poly[i], poly[i + 1]), { edge: e, pp: new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_14__.PointPair(poly[i], poly[i + 1]) }]);
        }
        if (ge.targetArrowhead) {
            edgesPlusEdgeLabels.push([
                _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(ge.curve.end, ge.targetArrowhead.tipPosition),
                { edge: e, pp: new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_14__.PointPair(ge.curve.end, ge.targetArrowhead.tipPosition) },
            ]);
        }
    }
    const t = nodes.concat(edgesPlusEdgeLabels);
    return (0,_math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_8__.mkRTree)(t);
}
//# sourceMappingURL=geomGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/geomLabel.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomLabel: () => (/* binding */ GeomLabel)
/* harmony export */ });
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _geomObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomObject.js");



class GeomLabel extends _geomObject__WEBPACK_IMPORTED_MODULE_2__.GeomObject {
    /** clones but does not bind to the entity and does not set the parent edge*/
    clone() {
        const ret = new GeomLabel(null, null);
        ret.isPositioned = this.isPositioned;
        ret._boundingBox = this._boundingBox.clone();
        ret.attachmentSegmentEnd = this.attachmentSegmentEnd;
        ret.attachmentSegmentStart = this.attachmentSegmentStart;
        return ret;
    }
    get isPositioned() {
        return this._isPositioned;
    }
    set isPositioned(value) {
        this._isPositioned = value;
    }
    constructor(entity, size) {
        super(entity);
        this._isPositioned = false;
        if (size) {
            this.boundingBox = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkPP(new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0), new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(size.width, size.height));
        }
    }
    get boundingBox() {
        return this._boundingBox;
    }
    set boundingBox(value) {
        this._boundingBox = value;
    }
    setBoundingBox(b) {
        this.isPositioned = true;
        this._boundingBox = b;
    }
    get width() {
        return this.boundingBox.width;
    }
    set width(value) {
        this.boundingBox.width = value;
    }
    get height() {
        return this.boundingBox.height;
    }
    set height(value) {
        this.boundingBox.height = value;
    }
    get center() {
        return this.boundingBox.center;
    }
    set center(value) {
        this.boundingBox.center = value;
    }
    translate(delta) {
        if (this.isPositioned)
            this.center = this.center.add(delta);
    }
    transform(m) {
        if (this.isPositioned)
            this.center = m.multiplyPoint(this.center);
    }
    positionCenter(p) {
        this.boundingBox.center = p;
        this.isPositioned = true;
    }
}
//# sourceMappingURL=geomLabel.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/geomNode.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomNode: () => (/* binding */ GeomNode)
/* harmony export */ });
/* harmony import */ var _math_geometry_curveFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curveFactory.js");
/* harmony import */ var _geomObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomObject.js");
/* harmony import */ var _structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attributeRegistry.js");
// A node of a GeomGraph



class GeomNode extends _geomObject__WEBPACK_IMPORTED_MODULE_1__.GeomObject {
    constructor() {
        super(...arguments);
        this.padding = 1;
    }
    /** clones but does not bind to the entity */
    clone() {
        const ret = new GeomNode(null);
        if (this.boundaryCurve)
            ret.boundaryCurve = this.boundaryCurve.clone();
        return ret;
    }
    translate(delta) {
        if (delta.x === 0 && delta.y === 0)
            return;
        this.boundaryCurve.translate(delta);
    }
    toJSON() {
        return { boundaryCurve: this.boundaryCurve, padding: this.padding };
    }
    get node() {
        return this.entity;
    }
    get boundaryCurve() {
        return this._boundaryCurve;
    }
    set boundaryCurve(value) {
        if (value != null &&
            value.boundingBox &&
            (value.boundingBox.height < GeomNode.minHeight || value.boundingBox.width < GeomNode.minWidth)) {
            value = _math_geometry_curveFactory__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkCircle(GeomNode.minWidth, value.boundingBox.center);
        }
        this._boundaryCurve = value;
    }
    get id() {
        return this.node.id;
    }
    toString() {
        return this.id;
    }
    // Creates a Node instance
    static mkNode(curve, node) {
        const n = new GeomNode(node);
        n.boundaryCurve = curve;
        return n;
    }
    // Fields which are set by Msagl
    // return the center of the curve bounding box
    get center() {
        return this.boundaryCurve.boundingBox.center;
    }
    set center(value) {
        const del = value.sub(this.center);
        this.boundaryCurve.translate(del);
    }
    // sets the bounding curve scaled to fit the targetBounds
    fitBoundaryCurveToTarget(targetBounds) {
        if (this.boundaryCurve != null) {
            // RoundedRect is special, rather then simply scaling the geometry we want to keep the corner radii constant
            const radii = _math_geometry_curveFactory__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.isRoundedRect(this.boundaryCurve);
            if (radii == null) {
                /*Assert.assert(this.boundaryCurve.boundingBox.width > 0)*/
                /*Assert.assert(this.boundaryCurve.boundingBox.height > 0)*/
                const scaleX = targetBounds.width / this.boundaryCurve.boundingBox.width;
                const scaleY = targetBounds.height / this.boundaryCurve.boundingBox.height;
                this.boundaryCurve = this.boundaryCurve.scaleFromOrigin(scaleX, scaleY);
                this.boundaryCurve.translate(targetBounds.center.sub(this.boundaryCurve.boundingBox.center));
            }
            else {
                this.boundaryCurve = _math_geometry_curveFactory__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkRectangleWithRoundedCorners(targetBounds.width, targetBounds.height, radii.radX, radii.radY, targetBounds.center);
            }
        }
    }
    static getGeom(attrCont) {
        return attrCont.getAttr(_structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_2__.AttributeRegistry.GeomObjectIndex);
    }
    *inEdges() {
        for (const e of this.node.inEdges) {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(e);
        }
    }
    *outEdges() {
        for (const e of this.node.outEdges) {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(e);
        }
    }
    *selfEdges() {
        for (const e of this.node.selfEdges) {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(e);
        }
    }
    /** creates a new rectangle equal to the padded  */
    get boundingBoxWithPadding() {
        const ret = this.boundingBox.clone();
        ret.pad(this.padding);
        return ret;
    }
    // the bounding box of the node
    get boundingBox() {
        return this.boundaryCurve ? this.boundaryCurve.boundingBox : null;
    }
    set boundingBox(value) {
        if (!this.boundaryCurve) {
            return;
        }
        if (Math.abs(value.width - this.width) < 0.0001 && Math.abs(value.height - this.height) < 0.0001) {
            this.center = value.center;
        }
        else {
            this.fitBoundaryCurveToTarget(value);
        }
    }
    // width of the node does not include the padding
    get width() {
        return this.boundaryCurve.boundingBox.width;
    }
    // height of the node does not including the padding
    get height() {
        return this.boundaryCurve.boundingBox.height;
    }
    transform(t) {
        if (this.boundaryCurve != null) {
            this.boundaryCurve = this.boundaryCurve.transform(t);
        }
    }
    underCollapsedGraph() {
        const graph = this.node.parent;
        if (graph == null)
            return false;
        const gGraph = _geomObject__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(graph);
        if (gGraph == null)
            return false;
        if (gGraph.isCollapsed) {
            return true;
        }
        return gGraph.underCollapsedGraph();
    }
    *getAncestors() {
        for (const g of this.node.getAncestors()) {
            yield _geomObject__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(g);
        }
    }
}
GeomNode.minHeight = 2;
GeomNode.minWidth = 3;
//# sourceMappingURL=geomNode.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/geomObject.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventHandler: () => (/* binding */ EventHandler),
/* harmony export */   GeomObject: () => (/* binding */ GeomObject)
/* harmony export */ });
/* harmony import */ var _structs_attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attribute.js");
/* harmony import */ var _structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attributeRegistry.js");


/** represents a set of functions to handle an event */
class EventHandler {
    constructor() {
        this.actions = new Set();
    }
    forEach(action) {
        this.actions.forEach((a) => a(action, null));
    }
    subscribe(f) {
        this.actions.add(f);
    }
    unsubscribe(f) {
        this.actions.delete(f);
    }
    raise(a, b) {
        this.actions.forEach((f) => f(a, b));
    }
}
class GeomObject extends _structs_attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute {
    constructor(entity) {
        super(entity, _structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.GeomObjectIndex);
    }
    static getGeom(attrCont) {
        if (attrCont == null)
            return null;
        return attrCont.getAttr(_structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.GeomObjectIndex);
    }
    get parent() {
        const p = this.entity.parent;
        return p ? GeomObject.getGeom(p) : null;
    }
    rebind(e) {
        this.entity = e;
        this.bind(_structs_attributeRegistry__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.GeomObjectIndex);
    }
    *getAncestors() {
        let p = this.parent;
        while (p != null) {
            yield p;
            p = p.parent;
        }
    }
}
//# sourceMappingURL=geomObject.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/hookUpAnywhereFromInsidePort.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HookUpAnywhereFromInsidePort: () => (/* binding */ HookUpAnywhereFromInsidePort)
/* harmony export */ });
/* harmony import */ var _port__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/port.js");
// This port is for an edge connecting a node inside of the curve going out of the curve and creating a hook to
// connect to the curve

class HookUpAnywhereFromInsidePort extends _port__WEBPACK_IMPORTED_MODULE_0__.Port {
    mk(boundaryCurve, hookSize) {
        const ret = new HookUpAnywhereFromInsidePort(boundaryCurve);
        ret.HookSize = hookSize;
        return ret;
    }
    constructor(boundaryCurve) {
        super();
        this.adjustmentAngle = Math.PI / 10;
        this.hookSize = 9;
        this.curve = boundaryCurve;
        this.location = this.curve().start;
    }
    // returns a point on the boundary curve
    get Location() {
        return this.location;
    }
    // Gets the boundary curve of the port.
    get Curve() {
        return this.curve();
    }
    SetLocation(p) {
        this.location = p;
    }
    // We are trying to correct the last segment of the polyline by make it perpendicular to the Port.Curve.
    // For this purpose we trim the curve by the cone of the angle 2*adjustment angle and project the point before the last of the polyline to this curve.
    get AdjustmentAngle() {
        return this.adjustmentAngle;
    }
    set AdjustmentAngle(value) {
        this.adjustmentAngle = value;
    }
    // the size of the self-loop
    get HookSize() {
        return this.hookSize;
    }
    set HookSize(value) {
        this.hookSize = value;
    }
}
//# sourceMappingURL=hookUpAnywhereFromInsidePort.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/port.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Port: () => (/* binding */ Port)
/* harmony export */ });
class Port {
}
//# sourceMappingURL=port.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/relativeFloatingPort.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RelativeFloatingPort: () => (/* binding */ RelativeFloatingPort)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _floatingPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/floatingPort.js");


class RelativeFloatingPort extends _floatingPort__WEBPACK_IMPORTED_MODULE_1__.FloatingPort {
    static mk(boundaryDelegate, centerDelegate) {
        return new RelativeFloatingPort(boundaryDelegate, centerDelegate, new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0));
    }
    // the delegate returning center
    get CenterDelegate() {
        return this.centerDelegate;
    }
    set CenterDelegate(value) {
        this.centerDelegate = value;
    }
    // the delegate returning center
    get CurveDelegate() {
        return this.curveDelegate;
    }
    set CurveDelegate(value) {
        this.curveDelegate = value;
    }
    //
    //        // The node where we calculate our location and Curve from
    //
    //        public Node RelativeTo { get; private set; }
    // An offset relative to the Center of the Node that we use to calculate Location
    get LocationOffset() {
        return this.locationOffset;
    }
    set LocationOffset(value) {
        this.locationOffset = value;
    }
    // Create a port relative to a specific node with an offset for the port Location from the nodes center
    constructor(curveDelegate, centerDelegate, locationOffset) {
        super(null, centerDelegate().add(locationOffset));
        this.LocationOffset = locationOffset;
        this.CurveDelegate = curveDelegate;
        this.CenterDelegate = centerDelegate;
    }
    //
    // // Create a port relative to the center of a specific node
    //
    // public constructor (curveDelegate: Func<ICurve>, centerDelegate: Func<Point>) :
    //        this(curveDelegate, centerDelegate, new Point()) {
    // }
    // Get the location = CenterDelegate() + LocationOffset
    get Location() {
        return this.CenterDelegate().add(this.LocationOffset);
    }
    // Get the curve from the node's BoundaryCurve
    get Curve() {
        return this.CurveDelegate();
    }
}
//# sourceMappingURL=relativeFloatingPort.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/tile.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tile: () => (/* binding */ Tile)
/* harmony export */ });
/* harmony import */ var _geomNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomNode.js");
/* harmony import */ var _geomLabel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomLabel.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/assert.js");




/** keeps the data needed to render a tile, and some fields for optimizations */
class Tile {
    get curveClips() {
        return this._curveClips;
    }
    set curveClips(value) {
        this._curveClips = value;
    }
    constructor(rect) {
        this._curveClips = [];
        this.arrowheads = [];
        this.nodes = [];
        this.labels = [];
        this.rect = rect;
        this._curveClips = [];
    }
    addCurveClip(cc) {
        _utils_assert__WEBPACK_IMPORTED_MODULE_3__.Assert.assert(!(cc.curve instanceof _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve), 'CurveClip.curve should not be a Curve!');
        this._curveClips.push(cc);
    }
    isEmpty() {
        return this._curveClips.length == 0 && this.arrowheads.length == 0 && this.nodes.length == 0 && this.labels.length == 0;
    }
    initCurveClips() {
        this._curveClips = [];
    }
    /** clears all arrays but does not touch this.rect */
    clear() {
        this.arrowheads = [];
        this.nodes = [];
        this.labels = [];
        this._curveClips = [];
    }
    /** returns the number of entities that will be rendered for a tile: each bundle is counted as one entity */
    get entityCount() {
        return this._curveClips.length + this.arrowheads.length + this.labels.length + this.nodes.length;
    }
    addElement(data) {
        if (data instanceof _geomNode__WEBPACK_IMPORTED_MODULE_0__.GeomNode) {
            this.nodes.push(data);
        }
        else if (data instanceof _geomLabel__WEBPACK_IMPORTED_MODULE_1__.GeomLabel) {
            this.labels.push(data);
        }
        else if ('curve' in data) {
            if (data.curve instanceof _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve) {
                for (const seg of data.curve.segs) {
                    this.addCurveClip({ edge: data.edge, curve: seg, startPar: seg.parStart, endPar: seg.parEnd });
                }
            }
            else {
                this.addCurveClip(data);
            }
        }
        else {
            this.arrowheads.push(data);
        }
    }
}
//# sourceMappingURL=tile.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/core/tileMap.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TileMap: () => (/* binding */ TileMap)
/* harmony export */ });
/* harmony import */ var _structs_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/graph.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _geomEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomEdge.js");
/* harmony import */ var _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairMap.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _geomGraph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _tile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/tile.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _routing_splineRouter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/splineRouter.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/assert.js");











//const debCount = 0
/** keeps the data needed to render the tile hierarchy */
class TileMap {
    /** retrieves the data for a single tile(x-y-z) */
    getTileData(x, y, z) {
        const mapOnLevel = this.levels[z];
        if (!mapOnLevel)
            return null;
        return mapOnLevel.get(x, y);
    }
    /** retrieves all the tiles of z-th level */
    *getTilesOfLevel(z) {
        const tm = this.levels[z];
        if (tm == null)
            return;
        for (const [key, val] of tm.keyValues()) {
            yield { x: key.x, y: key.y, data: val };
        }
    }
    /** geomGraph  - the graph to work with.
     * The topLevelTileRect serves as the only tile of the top level.
     */
    constructor(geomGraph, topLevelTileRect) {
        this.numberOfNodesOnLevel = [];
        this.nodeScales = [];
        /** the maximal number visual elements vizible in a tile */
        this.tileCapacity = 5000; // in the number of elements
        /** the tiles of level z is represented by levels[z] */
        this.levels = [];
        this.nodeIndexInSortedNodes = new Map();
        this.geomGraph = geomGraph;
        this.topLevelTileRect = topLevelTileRect;
        this.tileSizes = [];
        this.tileSizes.push(topLevelTileRect.size);
    }
    getMinTileSize() {
        let w = 0;
        let h = 0;
        let n = 0;
        for (const node of this.geomGraph.nodesBreadthFirst) {
            if (node instanceof _geomGraph__WEBPACK_IMPORTED_MODULE_5__.GeomGraph)
                continue;
            if (n == 0) {
                w = node.width;
                h = node.height;
            }
            else {
                w = (n * w + node.width) / (n + 1);
                h = (n * h + node.height) / (n + 1);
            }
            n++;
        }
        return new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Size(w * 10, h * 10);
    }
    fillTheLowestLayer() {
        const tileMap = new _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_3__.IntPairMap();
        const topLevelTile = new _tile__WEBPACK_IMPORTED_MODULE_7__.Tile(this.topLevelTileRect);
        const arrows = topLevelTile.arrowheads;
        const geomLabels = topLevelTile.labels;
        for (const e of this.geomGraph.graph.deepEdges) {
            addEdgeToTiles(e);
        }
        // geomLabels and arrowheads are sorted, because edges are sorted: all arrays of TileData are sorted by rank
        topLevelTile.nodes = Array.from(this.geomGraph.nodesBreadthFirst);
        tileMap.set(0, 0, topLevelTile);
        this.levels.push(tileMap);
        function addEdgeToTiles(e) {
            const geomEdge = _geomEdge__WEBPACK_IMPORTED_MODULE_2__.GeomEdge.getGeom(e);
            const c = _geomEdge__WEBPACK_IMPORTED_MODULE_2__.GeomEdge.getGeom(e).curve;
            if (c instanceof _math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__.Curve) {
                for (const seg of c.segs) {
                    topLevelTile.addElement({ edge: e, curve: seg, startPar: seg.parStart, endPar: seg.parEnd });
                }
            }
            else {
                topLevelTile.addElement({ edge: e, curve: c, startPar: c.parStart, endPar: c.parEnd });
            }
            if (geomEdge.sourceArrowhead) {
                arrows.push({ edge: geomEdge.edge, tip: geomEdge.sourceArrowhead.tipPosition, base: geomEdge.curve.start });
            }
            if (geomEdge.targetArrowhead) {
                arrows.push({ edge: geomEdge.edge, tip: geomEdge.targetArrowhead.tipPosition, base: geomEdge.curve.end });
            }
            if (geomEdge.label) {
                geomLabels.push(geomEdge.label);
            }
        }
    }
    /**
     * Creates tilings for levels from 0 to z, including the level z.
     * The method does not necesserely creates all levels until z, but can exit earlier
     *  if all tiles either has size smaller or equal than this.minTileSize or have at most this.tileCapacityMin elements.
     * Returns the number of created levels.
     */
    buildUpToLevel(z) {
        this.fillTheLowestLayer();
        this.minTileSize = this.getMinTileSize();
        this.pageRank = (0,_structs_graph__WEBPACK_IMPORTED_MODULE_0__.pagerank)(this.geomGraph.graph, 0.85);
        if (!this.needToSubdivide())
            return 1; // we have only one layer
        for (let i = 1; i <= z; i++) {
            if (this.subdivideLevel(i)) {
                break;
            }
        }
        this.sortedNodes = Array.from(this.pageRank.keys()).sort(this.compareByPagerank.bind(this));
        for (let i = 0; i < this.sortedNodes.length; i++) {
            this.nodeIndexInSortedNodes.set(this.sortedNodes[i], i);
        }
        // filter out entities that are not visible on lower layers.
        // do not filter the uppermost layer: it should show everything
        for (let i = 0; i < this.levels.length - 1; i++) {
            this.numberOfNodesOnLevel.push(this.filterOutEntities(this.levels[i], i));
        }
        this.numberOfNodesOnLevel.push(this.sortedNodes.length);
        // for (let i = 0; i < this.levels.length; i++) {
        //   this.checkLevel(i)
        // }
        const sr = new _routing_splineRouter__WEBPACK_IMPORTED_MODULE_9__.SplineRouter(this.geomGraph, []);
        for (let i = this.levels.length - 2; i >= 0; i--) {
            const activeNodes = this.setOfNodesOnTheLevel(i);
            sr.rerouteOnSubsetOfNodes(activeNodes);
            this.regenerateCurveClipsUpToLevel(i, activeNodes);
        }
        // for (let i = 0; i < this.levels.length; i++) {
        //   this.checkLevel(i)
        // }
        this.calculateNodeRank();
        //this.makeSomeNodesVizible()
        //Assert.assert(this.lastLayerHasAllNodes())
        return this.levels.length;
    }
    // private makeSomeNodesVizible() {
    //   for (let levelIndex = 0; levelIndex < this.levels.length - 1; levelIndex++) {
    //     this.calculateNodeAdditionalScales(levelIndex)
    //   }
    // }
    // calculateNodeAdditionalScalesOnLevelZero() {
    //   const tree = new RTree()
    //   // we always get at least one intersection with the whole graph record
    //   tree.batchInsert([
    //     {
    //       x: this.geomGraph.left,
    //       y: this.geomGraph.bottom,
    //       width: this.geomGraph.width,
    //       height: this.geomGraph.height,
    //       data: {node: this.geomGraph.graph, nodeBB: this.geomGraph.boundingBox},
    //     },
    //   ]) // to init with the whole
    //   const scales = new Map<Node, number>()
    //   this.nodeScales.push(scales)
    //   // with this scale the node will be rendered at level[this.level.length -1]
    //   let scale = Math.pow(2, this.levels.length - 1)
    //   for (let j = 0; j < this.numberOfNodesOnLevel[0]; j++) {
    //     const n = this.sortedNodes[j]
    //     scale = this.findMaxScaleToNotIntersectTree(n, tree, scale)
    //     if (scale < 1.1) break // getting almost no enlargement
    //     scales.set(n, scale)
    //   }
    // }
    // findMaxScaleToNotIntersectTree(n: Node, tree: RTree, maxScale: number): number {
    //   const geomNode = GeomNode.getGeom(n)
    //   let nodeBB = geomNode.boundingBox
    //   // make sure that we are not rendering the node outside of  the the graph bounding box
    //   maxScale = Math.min(this.keepInsideGraphBoundingBox(nodeBB), maxScale)
    //   const ret = this.intersectWithTreeAndGetScale(tree, nodeBB, maxScale)
    //   // use the resulting bounding box and insert it to the tree
    //   nodeBB = geomNode.boundingBox.clone()
    //   nodeBB.scaleAroundCenter(ret)
    //   tree.insert({x: nodeBB.left, y: nodeBB.bottom, width: nodeBB.width, height: nodeBB.height, data: {node: n, nodeBB: nodeBB}})
    //   return ret
    // }
    /** returns the maximal scale keeping nodeBB inside of the graph bounding box */
    keepInsideGraphBoundingBox(nodeBB) {
        const graphBB = this.geomGraph.boundingBox;
        const w = nodeBB.width / 2;
        const h = nodeBB.height / 2;
        const keepInsideScale = Math.min(
        // left stays inside
        (nodeBB.center.x - graphBB.left) / w, 
        // top stays inside
        (graphBB.top - nodeBB.center.y) / h, 
        // right stays inside
        (graphBB.right - nodeBB.center.x) / w, 
        //bottom stays inside
        (nodeBB.center.y - graphBB.bottom) / h);
        return keepInsideScale;
    }
    // intersectWithTreeAndGetScale(tree: RTree, nodeBB: Rectangle, maxScale: number): number {
    //   const xx = tree.search({x: nodeBB.left, y: nodeBB.bottom, width: nodeBB.width, height: nodeBB.height}) as {
    //     node: Node
    //     nodeBB: Rectangle
    //   }[]
    //   if (xx.length == 1) return maxScale // there is always one intersection with the whole graph
    //   let scale = maxScale
    //   for (const x of xx) {
    //     if (x.node == this.geomGraph.graph) continue
    //     scale = this.diminishScaleToAvoidTree(x.node, x.nodeBB, nodeBB)
    //     if (scale == 1) return scale // no separation
    //   }
    //   return scale
    // }
    diminishScaleToAvoidTree(intersectedNode, intersectedRect, nodeBB) {
        _utils_assert__WEBPACK_IMPORTED_MODULE_10__.Assert.assert(intersectedRect.intersects(nodeBB));
        let scaleX;
        const x = nodeBB.center.x;
        const y = nodeBB.center.y;
        const h = nodeBB.height / 2;
        const w = nodeBB.width / 2;
        if (x < intersectedRect.left) {
            scaleX = (intersectedRect.left - x) / h;
        }
        else if (x > intersectedRect.right) {
            scaleX = (x - intersectedRect.right) / h;
        }
        else {
            return 1;
        }
        let scaleY;
        if (y < intersectedRect.bottom) {
            scaleY = (intersectedRect.bottom - y) / w;
        }
        else if (y > intersectedRect.top) {
            scaleY = (y - intersectedRect.top) / w;
        }
        else {
            return scaleX;
        }
        return Math.min(scaleX, scaleY);
    }
    // calculateNodeAdditionalScales(levelIndex: number) {
    //   const tree = new RTree()
    //   // we always get at least one intersection with the whole graph record
    //   tree.batchInsert([
    //     {
    //       x: this.geomGraph.left,
    //       y: this.geomGraph.bottom,
    //       width: this.geomGraph.width,
    //       height: this.geomGraph.height,
    //       data: {node: this.geomGraph.graph, nodeBB: this.geomGraph.boundingBox},
    //     },
    //   ]) // to init with the whole graph bounding box
    //   const scales = new Map<Node, number>()
    //   this.nodeScales.push(scales)
    //   let scale = Math.pow(2, this.levels.length - 1 - levelIndex)
    //   for (let j = 0; j < this.numberOfNodesOnLevel[levelIndex]; j++) {
    //     const n = this.sortedNodes[j]
    //     scale = this.findMaxScaleToNotIntersectTree(n, tree, scale)
    //     if (scale <= 1) break
    //     scales.set(n, scale)
    //   }
    // }
    // findMaxScale(n: Node, levelIndex: number, tree: RTree, maxScale: number): number {
    //   const geomNode = GeomNode.getGeom(n)
    //   let boundingBox = geomNode.boundingBox.clone()
    //   boundingBox.scaleAroundCenter(maxScale)
    //   let ret = maxScale
    //   while (ret > 1 && treeIntersectsRect(tree, boundingBox)) {
    //     ret /= 2
    //     if (ret < 1) ret = 1
    //   }
    //   boundingBox = geomNode.boundingBox.clone()
    //   boundingBox.scaleAroundCenter(ret)
    //   tree.insert({x: boundingBox.left, y: boundingBox.bottom, width: boundingBox.width, height: boundingBox.height})
    //   return ret
    // }
    needToSubdivide() {
        let needSubdivide = false;
        for (const tile of this.levels[0].values()) {
            if (tile.entityCount > this.tileCapacity) {
                needSubdivide = true;
                break;
            }
        }
        return needSubdivide;
    }
    setOfNodesOnTheLevel(i) {
        const ret = new Set();
        for (const t of this.levels[i].values()) {
            for (const node of t.nodes) {
                ret.add(node.node);
            }
        }
        return ret;
    }
    // checkLevel(i: number) {
    //   const [edgeMap, nodeSet] = this.getEntityDataFromLevel(i)
    //   for (const [e, entDataArray] of edgeMap) {
    //     this.checkEntityDataArray(e, entDataArray, nodeSet)
    //   }
    // }
    // checkEntityDataArray(e: Entity, entDataArray: EntityDataInTile[], nodeSet: Set<Node>) {
    //   if (e instanceof Edge) {
    //     if (!nodeSet.has(e.source)) {
    //       Assert.assert(false)
    //     }
    //     if (!nodeSet.has(e.target)) {
    //       Assert.assert(false)
    //     }
    //     let connectedToSource = false
    //     let connectedToTarget = false
    //     const ge = GeomEdge.getGeom(e)
    //     const sb = ge.source.boundingBox
    //     const tb = ge.target.boundingBox
    //     for (const cc of entDataArray) {
    //       if ('curve' in cc.data) {
    //         Assert.assert(cc.data.edge === e)
    //         const curve = cc.data.curve
    //         if (sb.contains(curve.start)) connectedToSource = true
    //         if (tb.contains(curve.end)) connectedToTarget = true
    //       }
    //     }
    //     Assert.assert(connectedToSource && connectedToTarget)
    //   }
    // }
    regenerateCurveClipsUpToLevel(levelIndex, activeNodes) {
        this.clearCurveClipsInLevelsUpTo(levelIndex);
        for (const t of this.levels[0].values()) {
            this.regenerateCurveClipsUnderTileUpToLevel(t, levelIndex, activeNodes);
        }
    }
    clearCurveClipsInLevelsUpTo(levelIndex) {
        for (let i = 0; i <= levelIndex; i++) {
            for (const t of this.levels[i].values()) {
                t.initCurveClips();
            }
        }
    }
    regenerateCurveClipsUnderTileUpToLevel(t, levelIndex, activeNodes) {
        t.arrowheads = [];
        t.initCurveClips();
        for (const geomEdge of this.geomGraph.deepEdges) {
            if (!(0,_structs_graph__WEBPACK_IMPORTED_MODULE_0__.edgeNodesBelongToSet)(geomEdge.edge, activeNodes))
                continue;
            if (geomEdge.curve instanceof _math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__.Curve) {
                for (const seg of geomEdge.curve.segs) {
                    t.addElement({ edge: geomEdge.edge, curve: seg, startPar: seg.parStart, endPar: seg.parEnd });
                }
            }
            else {
                t.addElement({ edge: geomEdge.edge, curve: geomEdge.curve, startPar: geomEdge.curve.parStart, endPar: geomEdge.curve.parEnd });
            }
            if (geomEdge.sourceArrowhead) {
                t.arrowheads.push({ edge: geomEdge.edge, tip: geomEdge.sourceArrowhead.tipPosition, base: geomEdge.curve.start });
            }
            if (geomEdge.targetArrowhead) {
                t.arrowheads.push({ edge: geomEdge.edge, tip: geomEdge.targetArrowhead.tipPosition, base: geomEdge.curve.end });
            }
        }
        // do not change the labels
        // Now the root tile(s) is ready
        for (let i = 1; i <= levelIndex; i++) {
            this.regenerateCurveClipsWhenPreviosLayerIsDone(i);
            this.removeEmptyTiles(i);
        }
    }
    removeEmptyTiles(i) {
        const level = this.levels[i];
        const keysToDelete = [];
        for (const [k, t] of level.keyValues()) {
            if (t.isEmpty()) {
                keysToDelete.push(k);
            }
        }
        for (const k of keysToDelete) {
            level.delete(k.x, k.y);
        }
    }
    regenerateCurveClipsWhenPreviosLayerIsDone(z) {
        for (const [key, tile] of this.levels[z - 1].keyValues()) {
            this.subdivideTile(key, z, tile, /** for regenerate */ true);
        }
    }
    // regenerateUnderOneTile(key: IntPair, upperTile: Tile, z: number) {
    //   const subTilesRects = createSubTileRects()
    //   const clipsPerRect = this.regenerateCurveClipsUnderTile(upperTile, subTilesRects)
    //   pushRegeneratedClips(this.levels[z])
    //   cleanArrowheadsInSubtiles(this.levels[z])
    //   pushArrowheadsToSubtiles(this.levels[z])
    //   cleanUpSubtilesAboveTile(this.levels[z])
    //   function cleanUpSubtilesAboveTile(level: IntPairMap<Tile>) {
    //     for (let i = 0; i < 2; i++)
    //       for (let j = 0; j < 2; j++) {
    //         const ti = 2 * key.x + i
    //         const tj = 2 * key.y + j
    //         const tile = level.get(ti, tj)
    //         if (tile == null) continue
    //         if (tile.isEmpty()) {
    //           level.delete(ti, tj)
    //         }
    //       }
    //   }
    //   function pushArrowheadsToSubtiles(level: IntPairMap<Tile>) {
    //     for (const arrowhead of upperTile.arrowheads) {
    //       const arrowheadBox = Rectangle.mkPP(arrowhead.base, arrowhead.tip)
    //       const d = arrowhead.tip.sub(arrowhead.base).div(3)
    //       const dRotated = d.rotate90Cw()
    //       arrowheadBox.add(arrowhead.base.add(dRotated))
    //       arrowheadBox.add(arrowhead.base.sub(dRotated))
    //       for (let i = 0; i < 2; i++)
    //         for (let j = 0; j < 2; j++) {
    //           const k = 2 * i + j
    //           if (arrowheadBox.intersects(subTilesRects[k])) {
    //             const ti = 2 * key.x + i
    //             const tj = 2 * key.y + j
    //             level.get(ti, tj).arrowheads.push(arrowhead)
    //           }
    //         }
    //     }
    //   }
    //   function cleanArrowheadsInSubtiles(levelMap: IntPairMap<Tile>) {
    //     for (let i = 0; i < 2; i++)
    //       for (let j = 0; j < 2; j++) {
    //         const ti = 2 * key.x + i
    //         const tj = 2 * key.y + j
    //         const tile = levelMap.get(ti, tj)
    //         if (tile == null) {
    //           continue
    //         }
    //         tile.arrowheads = []
    //       }
    //   }
    //   function pushRegeneratedClips(levelMap: IntPairMap<Tile>) {
    //     for (let i = 0; i < 2; i++)
    //       for (let j = 0; j < 2; j++) {
    //         const k = 2 * i + j
    //         const clips = clipsPerRect[k]
    //         const ti = 2 * key.x + i
    //         const tj = 2 * key.y + j
    //         let tile = levelMap.get(ti, tj)
    //         if (tile == null) {
    //           if (clips.length) {
    //             levelMap.set(ti, tj, (tile = new Tile(subTilesRects[k])))
    //           } else {
    //             continue
    //           }
    //         }
    //         tile.initCurveClips()
    //         for (const clip of clips) {
    //           tile.addElement({edge: clip.edge, curve: clip.curve})
    //         }
    //       }
    //   }
    //   function createSubTileRects() {
    //     const subTilesRects = new Array<Rectangle>()
    //     const w = upperTile.rect.width / 2
    //     const h = upperTile.rect.height / 2
    //     for (let i = 0; i < 2; i++)
    //       for (let j = 0; j < 2; j++) {
    //         const tileRect = new Rectangle({
    //           left: upperTile.rect.left + w * i,
    //           right: upperTile.rect.left + w * (i + 1),
    //           bottom: upperTile.rect.bottom + h * j,
    //           top: upperTile.rect.bottom + h * (j + 1),
    //         })
    //         subTilesRects.push(tileRect)
    //       }
    //     return subTilesRects
    //   }
    // }
    // lastLayerHasAllNodes(): boolean {
    //   const lastLayerNodes = new Set<Node>()
    //   for (const tile of this.levels[this.levels.length - 1].values()) {
    //     for (const n of tile.nodes) {
    //       lastLayerNodes.add(n.node)
    //     }
    //   }
    //   const gNodes = new Set<Node>(this.geomGraph.graph.nodesBreadthFirst)
    //   return setsAreEqual(gNodes, lastLayerNodes)
    // }
    calculateNodeRank() {
        this.nodeRank = new Map();
        const n = this.sortedNodes.length;
        const log_n_10 = Math.log10(n);
        for (let i = 0; i < n; i++) {
            this.nodeRank.set(this.sortedNodes[i], log_n_10 - Math.log10(i + 1));
        }
    }
    compareByPagerank(u, v) {
        return this.pageRank.get(v) - this.pageRank.get(u);
    }
    /** Fills the tiles up to the capacity.
     * Returns the number of inserted node.
     * An edge and its attributes is inserted just after its source and the target are inserted.
     * The nodes are sorted by rank here.  */
    filterOutEntities(levelToReduce, z) {
        // create a map,edgeToIndexOfPrevLevel, from the prevLevel edges to integers,
        // For each edge edgeToIndexOfPrevLevel.get(edge) = min {i: edge == tile.getCurveClips[i].edge}
        const dataByEntityMap = this.transferDataOfLevelToMap(levelToReduce);
        let k = 0;
        for (; k < this.sortedNodes.length; k++) {
            const node = this.sortedNodes[k];
            if (!this.addNodeToLevel(levelToReduce, node, dataByEntityMap)) {
                break;
            }
        }
        this.removeEmptyTiles(z);
        //dumpTiles(levelToReduce, z)
        return k;
    }
    /** Goes over all tiles where 'node' had presence and tries to add.
     *  If the above succeeds then all edges leading to the higher ranking nodes added without consulting with tileCapacity. The edge attributes added as well
     */
    addNodeToLevel(levelToReduce, node, dataByEntity) {
        const entityToData = dataByEntity.get(node);
        for (const edt of entityToData) {
            const tile = edt.tile;
            if (tile.entityCount >= this.tileCapacity) {
                return false;
            }
        }
        for (const edt of entityToData) {
            const tile = edt.tile;
            const data = edt.data;
            tile.addElement(data);
        }
        for (const e of node.selfEdges) {
            const ed = dataByEntity.get(e);
            for (const edt of ed) {
                const tile = edt.tile;
                const data = edt.data;
                tile.addElement(data);
            }
            if (e.label) {
                for (const edt of dataByEntity.get(e.label)) {
                    const tile = edt.tile;
                    const data = edt.data;
                    tile.addElement(data);
                }
            }
        }
        const nodeIndex = this.nodeIndexInSortedNodes.get(node);
        for (const e of node.inEdges) {
            const source = e.source;
            const sourceIndex = this.nodeIndexInSortedNodes.get(source);
            if (sourceIndex > nodeIndex)
                continue;
            for (const edt of dataByEntity.get(e)) {
                const tile = edt.tile;
                const data = edt.data;
                tile.addElement(data);
            }
            if (e.label) {
                for (const edt of dataByEntity.get(e.label)) {
                    const tile = edt.tile;
                    const data = edt.data;
                    tile.addElement(data);
                }
            }
        }
        for (const e of node.outEdges) {
            const target = e.target;
            const targetIndex = this.nodeIndexInSortedNodes.get(target);
            if (targetIndex > nodeIndex)
                continue;
            for (const edt of dataByEntity.get(e)) {
                const tile = edt.tile;
                const data = edt.data;
                tile.addElement(data);
            }
            if (e.label) {
                if (dataByEntity.get(e.label))
                    for (const edt of dataByEntity.get(e.label)) {
                        const tile = edt.tile;
                        const data = edt.data;
                        tile.addElement(data);
                    }
            }
        }
        return true;
    }
    transferDataOfLevelToMap(levelToReduce) {
        const entityToData = new Map();
        for (const tile of levelToReduce.values()) {
            for (const clip of tile.curveClips) {
                const edge = clip.edge;
                const arr = getCreateEntityDataArray(edge);
                arr.push({ tile: tile, data: clip });
            }
            for (const label of tile.labels) {
                const edge = label.parent.edge;
                const arr = getCreateEntityDataArray(edge);
                arr.push({ tile: tile, data: label });
            }
            for (const gnode of tile.nodes) {
                const node = gnode.node;
                const arr = getCreateEntityDataArray(node);
                arr.push({ tile: tile, data: gnode });
            }
            for (const arrowhead of tile.arrowheads) {
                const edge = arrowhead.edge;
                const arr = getCreateEntityDataArray(edge);
                arr.push({ tile: tile, data: arrowhead });
            }
            tile.clear();
        }
        return entityToData;
        function getCreateEntityDataArray(ent) {
            let arr = entityToData.get(ent);
            if (!arr) {
                entityToData.set(ent, (arr = new Array()));
            }
            return arr;
        }
    }
    /** It is assumed that the previous level z-1 have been calculated.
     * Returns true if every edge is appears in some tile as the first edge
     */
    subdivideLevel(z) {
        console.log('subdivideLevel', z);
        const tilesInRow = Math.pow(2, z);
        this.levels[z] = new _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_3__.IntPairMap();
        /** the width and the height of z-th level tile */
        const allTilesAreSmall = this.subdivideTilesOnLevel(z);
        if (allTilesAreSmall) {
            console.log('done subdividing at level', z, 'because each tile contains less than', this.tileCapacity);
            return true;
        }
        const { w, h } = this.getWHOnLevel(z);
        if (w <= this.minTileSize.width && h <= this.minTileSize.height) {
            console.log('done subdividing at level', z, ' because of tile size = ', w, h, 'is less than ', this.minTileSize);
            return true;
        }
        return false;
    }
    countClips(z) {
        let count = 0;
        for (const tile of this.levels[z].values()) {
            count += tile.curveClips.length;
        }
        return count;
    }
    getWHOnLevel(z) {
        for (let i = this.tileSizes.length; i <= z; i++) {
            const s = this.tileSizes[i - 1];
            this.tileSizes.push(new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Size(s.width / 2, s.height / 2));
        }
        return { w: this.tileSizes[z].width, h: this.tileSizes[z].height };
    }
    subdivideTilesOnLevel(z) {
        const tileCount = 0;
        let allTilesAreSmall = true;
        for (const [key, tile] of this.levels[z - 1].keyValues()) {
            const res = this.subdivideTile(key, z, tile, false);
            allTilesAreSmall && (allTilesAreSmall = res.allSmall);
        }
        this.removeEmptyTiles(z);
        console.log('generated', this.levels[z].size, 'tiles');
        return allTilesAreSmall;
    }
    subdivideTile(
    /** the tile key */
    key, z, // the level above the lowerTile level
    /** this is the tile we are subdividing */
    lowerTile, regenerate) {
        const { w, h } = this.getWHOnLevel(z);
        /** this is the map we collect new tiles to */
        const levelTiles = this.levels[z];
        const xp = key.x;
        const yp = key.y;
        const left = this.topLevelTileRect.left + xp * w * 2;
        const bottom = this.topLevelTileRect.bottom + yp * h * 2;
        /** tiles under the upper tile */
        const keys = new Array(4);
        // fill the keys
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 2; j++) {
                keys[i * 2 + j] = new _utils_IntPair__WEBPACK_IMPORTED_MODULE_8__.IntPair(xp * 2 + i, yp * 2 + j);
            }
        }
        if (!regenerate) {
            this.generateSubtilesWithoutTileClips(left, w, bottom, h, keys, lowerTile, z);
        }
        const horizontalMiddleLine = new _math_geometry__WEBPACK_IMPORTED_MODULE_6__.LineSegment(left, bottom + h, left + 2 * w, bottom + h);
        const verticalMiddleLine = new _math_geometry__WEBPACK_IMPORTED_MODULE_6__.LineSegment(left + w, bottom, left + w, bottom + 2 * h);
        subdivideWithCachedClipsAboveTile();
        let r = 0;
        let allSmall = true;
        for (const key of keys) {
            const tile = levelTiles.get(key.x, key.y);
            if (tile == null)
                continue;
            r++;
            if (tile.entityCount > this.tileCapacity) {
                allSmall = false;
            }
        }
        return { count: r, allSmall: allSmall };
        // local functions
        function subdivideWithCachedClipsAboveTile() {
            //create temparary PointPairMap to store the result of the intersection
            // each entry in the map is an array of curves corresponding to the intersections with one subtile
            for (const clip of lowerTile.curveClips) {
                // Assert.assert(upperTile.rect.containsRect(cs.curve.boundingBox))
                const cs = clip.curve;
                const xs = intersectWithMiddleLines(cs, clip.startPar, clip.endPar);
                _utils_assert__WEBPACK_IMPORTED_MODULE_10__.Assert.assert(xs.length >= 2);
                if (xs.length == 2) {
                    const t = (xs[0] + xs[1]) / 2;
                    const p = cs.value(t);
                    const i = p.x <= left + w ? 0 : 1;
                    const j = p.y <= bottom + h ? 0 : 1;
                    const k = 2 * i + j;
                    const key = keys[k];
                    let tile = levelTiles.getI(key);
                    if (!tile) {
                        const l = left + i * w;
                        const b = bottom + j * h;
                        tile = new _tile__WEBPACK_IMPORTED_MODULE_7__.Tile(new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle({ left: l, bottom: b, top: b + h, right: l + w }));
                        levelTiles.setPair(key, tile);
                    }
                    tile.addCurveClip({ curve: cs, edge: clip.edge, startPar: xs[0], endPar: xs[1] });
                }
                else
                    for (let u = 0; u < xs.length - 1; u++) {
                        const t = (xs[u] + xs[u + 1]) / 2;
                        const p = cs.value(t);
                        const i = p.x <= left + w ? 0 : 1;
                        const j = p.y <= bottom + h ? 0 : 1;
                        const k = 2 * i + j;
                        //const tr = cs.trim(xs[u][1], xs[u + 1][1])
                        const key = keys[k];
                        let tile = levelTiles.getI(key);
                        if (!tile) {
                            const l = left + i * w;
                            const b = bottom + j * h;
                            tile = new _tile__WEBPACK_IMPORTED_MODULE_7__.Tile(new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle({ left: l, bottom: b, top: b + h, right: l + w }));
                            levelTiles.setPair(key, tile);
                        }
                        tile.addCurveClip({ curve: cs, edge: clip.edge, startPar: xs[u], endPar: xs[u + 1] });
                    }
            }
        }
        function intersectWithMiddleLines(seg, start, end) {
            // point, parameter
            let xs = Array.from(_math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__.Curve.getAllIntersections(seg, horizontalMiddleLine, true))
                .concat(Array.from(_math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__.Curve.getAllIntersections(seg, verticalMiddleLine, true)))
                .map((x) => x.par0);
            xs.sort((a, b) => a - b);
            return [start].concat(xs.filter((x) => x >= start && x <= end)).concat(end);
        }
    }
    /** returns the updated value of allTilesAreSmall */
    addSubtilesToLevel(tdArr, levelTiles, xp, yp, allTilesAreSmall) {
        //debCount++
        for (let i = 0; i < 2; i++)
            for (let j = 0; j < 2; j++) {
                const tile = tdArr[i * 2 + j];
                if (!tile.isEmpty()) {
                    levelTiles.set(2 * xp + i, 2 * yp + j, tile);
                    // try {
                    //   if (debCount % 10 === 0) {
                    //     const cc = Array.from(tile.getCurveClips())
                    //     // SvgDebugWriter.dumpDebugCurves(
                    //     //   './tmp/tile' + debCount + '-' + (2 * xp + i) + '-' + (2 * yp + j) + '.svg',
                    //     //   cc
                    //     //     .map((c) => DebugCurve.mkDebugCurveCI('Green', c.curve))
                    //     //     .concat([DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Black', tile.rect.perimeter())])
                    //     //     .concat(tile.nodes.map((n) => DebugCurve.mkDebugCurveCI('Red', n.boundaryCurve)))
                    //     //     .concat(tile.arrowheads.map((t) => LineSegment.mkPP(t.base, t.tip)).map((l) => DebugCurve.mkDebugCurveWCI(1, 'Blue', l))),
                    //     // )
                    //   }
                    // } catch (e) {}
                    if (allTilesAreSmall && tile.entityCount > this.tileCapacity) {
                        //console.log('found a tile at level', z, ' with ', tile.elementCount, 'elements, which is greater than', this.tileCapacity)
                        allTilesAreSmall = false;
                    }
                }
            }
        return allTilesAreSmall;
    }
    generateSubtilesWithoutTileClips(left, w, bottom, h, keysAbove, upperTile, z) {
        let k = 0;
        for (let i = 0; i < 2; i++)
            for (let j = 0; j < 2; j++) {
                const tileRect = new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle({
                    left: left + w * i,
                    right: left + w * (i + 1),
                    bottom: bottom + h * j,
                    top: bottom + h * (j + 1),
                });
                const tile = this.generateOneSubtileExceptEdgeClips(upperTile, tileRect);
                if (tile) {
                    this.levels[z].set(keysAbove[k].x, keysAbove[k].y, tile);
                }
                k++;
            }
    }
    innerClips(curve, verticalMiddleLine, horizontalMiddleLine) {
        //debCount++
        const ret = [];
        // Assert.assert(upperTile.rect.containsRect(cs.curve.boundingBox))
        const xs = Array.from(_math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__.Curve.getAllIntersections(curve, horizontalMiddleLine, true)).concat(Array.from(_math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__.Curve.getAllIntersections(curve, verticalMiddleLine, true)));
        xs.sort((a, b) => a.par0 - b.par0);
        const filteredXs = [curve.parStart];
        for (let i = 0; i < xs.length; i++) {
            const ii = xs[i];
            if (ii.par0 > filteredXs[filteredXs.length - 1] + _math_geometry__WEBPACK_IMPORTED_MODULE_6__.GeomConstants.distanceEpsilon) {
                filteredXs.push(ii.par0);
            }
        }
        if (curve.parEnd > filteredXs[filteredXs.length - 1] + _math_geometry__WEBPACK_IMPORTED_MODULE_6__.GeomConstants.distanceEpsilon) {
            filteredXs.push(curve.parEnd);
        }
        if (filteredXs.length <= 2) {
            ret.push(curve);
            return ret;
        }
        for (let u = 0; u < filteredXs.length - 1; u++) {
            ret.push(curve.trim(filteredXs[u], filteredXs[u + 1]));
        }
        // if (debCount == 3) {
        //   console.log(ret)
        //   const trs = []
        //   for (let i = 0; i < ret.length; i++) {
        //     trs.push(DebugCurve.mkDebugCurveWCI(i + 1, 'Black', ret[i]))
        //   }
        //   SvgDebugWriter.dumpDebugCurves(
        //     './tmp/innerClips.svg',
        //     [
        //       DebugCurve.mkDebugCurveTWCI(150, 2, 'Yellow', verticalMiddleLine),
        //       DebugCurve.mkDebugCurveTWCI(100, 2, 'Magenta', horizontalMiddleLine),
        //       DebugCurve.mkDebugCurveTWCI(100, 5, 'Blue', curve),
        //     ].concat(trs),
        //   )
        // }
        return ret;
    }
    generateOneSubtileExceptEdgeClips(upperTile, tileRect) {
        const tile = new _tile__WEBPACK_IMPORTED_MODULE_7__.Tile(tileRect);
        for (const n of upperTile.nodes) {
            if (n.boundingBox.intersects(tileRect)) {
                tile.nodes.push(n);
            }
        }
        for (const lab of upperTile.labels) {
            if (lab.boundingBox.intersects(tileRect)) {
                tile.labels.push(lab);
            }
        }
        for (const arrowhead of upperTile.arrowheads) {
            const arrowheadBox = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(arrowhead.base, arrowhead.tip);
            const d = arrowhead.tip.sub(arrowhead.base).div(3);
            const dRotated = d.rotate90Cw();
            arrowheadBox.add(arrowhead.base.add(dRotated));
            arrowheadBox.add(arrowhead.base.sub(dRotated));
            if (arrowheadBox.intersects(tileRect))
                tile.arrowheads.push(arrowhead);
        }
        if (tile.isEmpty())
            return null;
        return tile;
    }
}
// function treeIntersectsRect(tree: RTree, boundingBox: Rectangle): boolean {
//   const bb = {x: boundingBox.left, y: boundingBox.bottom, width: boundingBox.width, height: boundingBox.height}
//   const a = tree.search(bb)
//   return a && a.length > 0
// }
// function dumpTiles(tileMap: IntPairMap<Tile>, z: number) {
//   for (const [p, tile] of tileMap.keyValues()) {
//     try {
//       const cc = Array.from(tile.getCurveClips()).map((c) => c.curve)
//       SvgDebugWriter.dumpDebugCurves(
//         './tmp/filteredTile' + z + '-' + p.x + '-' + p.y + '.svg',
//         cc
//           .map((c) => DebugCurve.mkDebugCurveCI('Green', c))
//           .concat([DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Black', tile.rect.perimeter())])
//           .concat(tile.nodes.map((n) => DebugCurve.mkDebugCurveCI('Red', n.boundaryCurve)))
//           .concat(tile.arrowheads.map((t) => LineSegment.mkPP(t.base, t.tip)).map((l) => DebugCurve.mkDebugCurveWCI(1, 'Blue', l))),
//       )
//     } catch (Error) {
//       console.log(Error.message)
//     }
//   }
// }
//# sourceMappingURL=tileMap.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/driver.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   enforceLayoutSettings: () => (/* binding */ enforceLayoutSettings),
/* harmony export */   geometryIsCreated: () => (/* binding */ geometryIsCreated),
/* harmony export */   getEdgeRoutingSettingsFromAncestorsOrDefault: () => (/* binding */ getEdgeRoutingSettingsFromAncestorsOrDefault),
/* harmony export */   getSettingsFromAncestor: () => (/* binding */ getSettingsFromAncestor),
/* harmony export */   layoutGeomGraph: () => (/* binding */ layoutGeomGraph),
/* harmony export */   layoutGeomGraphDetailed: () => (/* binding */ layoutGeomGraphDetailed),
/* harmony export */   layoutIsCalculated: () => (/* binding */ layoutIsCalculated),
/* harmony export */   routeEdges: () => (/* binding */ routeEdges),
/* harmony export */   routeRectilinearEdges: () => (/* binding */ routeRectilinearEdges)
/* harmony export */ });
/* harmony import */ var _routing_rectilinear_RectilinearEdgeRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearEdgeRouter.js");
/* harmony import */ var _core_geomGraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");
/* harmony import */ var _structs_edge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/edge.js");
/* harmony import */ var _structs_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/graph.js");
/* harmony import */ var _core_geomEdge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomEdge.js");
/* harmony import */ var _layered_sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/sugiyamaLayoutSettings.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _mds_pivotMDS__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/pivotMDS.js");
/* harmony import */ var _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/EdgeRoutingMode.js");
/* harmony import */ var _routing_StraightLineEdges__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/StraightLineEdges.js");
/* harmony import */ var _routing_splineRouter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/splineRouter.js");
/* harmony import */ var _routing_EdgeRoutingSettings__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/EdgeRoutingSettings.js");
/* harmony import */ var _core_geomObject__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomObject.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");
/* harmony import */ var _edgeLabelPlacement__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/edgeLabelPlacement.js");
/* harmony import */ var _incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/iPsepColaSettings.js");
/* harmony import */ var _initialLayout_initialLayout__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/initialLayout/initialLayout.js");

















// function routeEdges(
//  geomG: GeomGraph,
//  edgeRoutingSettings: EdgeRoutingSettings,
//  cornerFitRadius = 3,
// ) {
//  if (edgeRoutingSettings.edgeRoutingMode !== EdgeRoutingMode.Rectilinear) {
//    // TODO: enable other modes
//    routeStraightEdges(geomG)
//  } else {
//    if (edgeRoutingSettings.EdgeRoutingMode === EdgeRoutingMode.Rectilinear)
//      routeRectilinearEdges(geomG, edgeRoutingSettings.padding, cornerFitRadius)
//  }
// }
// function routeStraightEdges(geomG: GeomGraph) {
//  for (const u of geomG.deepNodes) {
//    for (const e of u.outEdges()) {
//      if (e.curve == null ) StraightLineEdges.RouteEdge(e, 0)
//    }
//    for (const e of u.selfEdges()) {
//      if (e.curve == null ) StraightLineEdges.RouteEdge(e, 0)
//    }
//  }
// }
function settingsTag(ss) {
    if (ss instanceof _layered_sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_5__.SugiyamaLayoutSettings) {
        return 0;
    }
    if (ss instanceof _incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_15__.IPsepColaSetting) {
        return 1;
    }
    if (ss instanceof ___WEBPACK_IMPORTED_MODULE_6__.MdsLayoutSettings) {
        return 2;
    }
    if (ss instanceof ___WEBPACK_IMPORTED_MODULE_6__.FastIncrementalLayoutSettings) {
        return 3;
    }
    throw new Error('not implemented');
}
function enforceLayoutSettings(geomGraph, ss) {
    if (!geomGraph.layoutSettings || settingsTag(geomGraph.layoutSettings) !== settingsTag(ss))
        geomGraph.layoutSettings = ss;
    for (const n of geomGraph.shallowNodes) {
        if (n instanceof _core_geomGraph__WEBPACK_IMPORTED_MODULE_1__.GeomGraph) {
            enforceLayoutSettings(n, geomGraph.layoutSettings);
        }
    }
}
function createSettingsIfNeeded(geomGraph) {
    if (!geomGraph.layoutSettings) {
        geomGraph.layoutSettings = figureOutSettings(geomGraph);
    }
}
function getSettingsFromAncestor(geomGraph) {
    let p = geomGraph.parent;
    while (p) {
        if (p.layoutSettings) {
            return p.layoutSettings;
        }
        p = p.parent;
    }
    return null;
}
function figureOutSettings(geomGraph) {
    const settings = getSettingsFromAncestor(geomGraph);
    if (settings)
        return settings;
    const tooLargeForLayered = geomGraph.graph.shallowNodeCount > 2000 || geomGraph.graph.deepEdgesCount > 4000;
    if (tooLargeForLayered) {
        return new _incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_15__.IPsepColaSetting();
    }
    let directed = false;
    for (const e of geomGraph.deepEdges) {
        if (e.sourceArrowhead != null || e.targetArrowhead != null) {
            directed = true;
            break;
        }
    }
    return directed ? new _layered_sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_5__.SugiyamaLayoutSettings() : new _incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_15__.IPsepColaSetting();
}
function layoutEngine(geomGraph, cancelToken, edgeLenght = () => 1) {
    createSettingsIfNeeded(geomGraph);
    if (geomGraph.layoutSettings instanceof _layered_sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_5__.SugiyamaLayoutSettings) {
        const ll = new ___WEBPACK_IMPORTED_MODULE_6__.LayeredLayout(geomGraph, geomGraph.layoutSettings, cancelToken);
        ll.run();
    }
    else if (geomGraph.layoutSettings instanceof ___WEBPACK_IMPORTED_MODULE_6__.MdsLayoutSettings) {
        const pivotMds = new _mds_pivotMDS__WEBPACK_IMPORTED_MODULE_7__.PivotMDS(geomGraph, cancelToken, edgeLenght, geomGraph.layoutSettings);
        pivotMds.run();
    }
    else if (geomGraph.layoutSettings instanceof _incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_15__.IPsepColaSetting) {
        const layout = new _initialLayout_initialLayout__WEBPACK_IMPORTED_MODULE_16__.InitialLayout(geomGraph, geomGraph.layoutSettings);
        layout.SingleComponent = true;
        layout.run();
    }
    else {
        throw new Error('not implemented');
    }
}
function layoutGeomGraph(geomGraph, cancelToken = null) {
    createSettingsIfNeeded(geomGraph);
    layoutGeomGraphDetailed(geomGraph, cancelToken, layoutEngine, routeEdges, _core_geomGraph__WEBPACK_IMPORTED_MODULE_1__.optimalPackingRunner);
    shiftToFirstQuarter(geomGraph);
}
function getEdgeRoutingSettingsFromAncestorsOrDefault(geomGraph) {
    do {
        if (geomGraph.layoutSettings && geomGraph.layoutSettings.commonSettings.edgeRoutingSettings) {
            return geomGraph.layoutSettings.commonSettings.edgeRoutingSettings;
        }
        const parent = geomGraph.graph.parent;
        if (parent) {
            geomGraph = _core_geomObject__WEBPACK_IMPORTED_MODULE_12__.GeomObject.getGeom(parent);
        }
        else {
            break;
        }
    } while (true);
    const ers = new _routing_EdgeRoutingSettings__WEBPACK_IMPORTED_MODULE_11__.EdgeRoutingSettings();
    ers.EdgeRoutingMode = _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_8__.EdgeRoutingMode.Spline;
    return ers;
}
function routeEdges(geomGraph, edgesToRoute, cancelToken) {
    const ers = getEdgeRoutingSettingsFromAncestorsOrDefault(geomGraph);
    if (ers.EdgeRoutingMode === _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_8__.EdgeRoutingMode.Rectilinear) {
        routeRectilinearEdges(geomGraph, edgesToRoute, cancelToken);
    }
    else if (ers.EdgeRoutingMode === _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_8__.EdgeRoutingMode.Spline || ers.EdgeRoutingMode === _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_8__.EdgeRoutingMode.SplineBundling) {
        (0,_routing_splineRouter__WEBPACK_IMPORTED_MODULE_10__.routeSplines)(geomGraph, edgesToRoute, cancelToken);
    }
    else if (ers.EdgeRoutingMode === _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_8__.EdgeRoutingMode.StraightLine) {
        (0,_routing_StraightLineEdges__WEBPACK_IMPORTED_MODULE_9__.straightLineEdgePatcher)(geomGraph, edgesToRoute, cancelToken);
    }
    else if (ers.EdgeRoutingMode !== _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_8__.EdgeRoutingMode.None) {
        new _routing_splineRouter__WEBPACK_IMPORTED_MODULE_10__.SplineRouter(geomGraph, edgesToRoute).run();
    }
    positionLabelsIfNeeded(geomGraph, edgesToRoute);
}
/** Lays out a GeomGraph, which is possibly disconnected and might have sub-graphs */
function layoutGeomGraphDetailed(geomG, cancelToken, layoutEngine, edgeRouter, packing, randomSeed = 1, 
/** used only for PivotMDS */
edgeLength = () => 1) {
    if (geomG.graph.isEmpty()) {
        return;
    }
    // @ts-ignore
    const gn = geomG.shallowNodes.next();
    if (geomG.parent == null) {
        //console.log('loading graph', geomG.id, 'with', geomG.deepNodeCount, 'nodes, and', geomG.graph.deepEdgesCount, 'edges')
        //console.time('layout')
        // go over some intitial settings only on the top level
        (0,_utils_random__WEBPACK_IMPORTED_MODULE_13__.initRandom)(randomSeed);
        requireLabelPositioning(geomG);
    }
    const removedEdges = removeEdgesLeadingOutOfGraphOrCollapsingToSelfEdges();
    layoutShallowSubgraphs(geomG);
    const liftedEdges = createLiftedEdges(geomG.graph);
    const connectedGraphs = getConnectedComponents(geomG);
    layoutComps();
    liftedEdges.forEach((e) => {
        e[0].edge.remove();
        e[1].add();
    });
    // restore the parent
    connectedGraphs.forEach((g) => {
        for (const n of g.graph.shallowNodes)
            n.parent = geomG.graph;
    });
    removedEdges.forEach((e) => e.add());
    //the final touches
    if (geomG.graph.parent == null) {
        //console.timeEnd('layout')
        //console.time('routing')
        const edgesToRoute = getUnroutedEdges(geomG);
        edgeRouter(geomG, edgesToRoute, cancelToken);
        positionLabelsIfNeeded(geomG, edgesToRoute);
        geomG.pumpTheBoxToTheGraphWithMargins();
        //console.timeEnd('routing')
    }
    // end of layoutGeomGraphDetailed body
    function getUnroutedEdges(g) {
        const edges = [];
        for (const n of g.nodesBreadthFirst) {
            for (const e of n.outEdges())
                if (e.curve == null)
                    edges.push(e);
            for (const e of n.selfEdges())
                if (e.curve == null)
                    edges.push(e);
        }
        return edges;
    }
    function layoutShallowSubgraphs(geomG) {
        for (const n of geomG.shallowNodes) {
            if (n instanceof _core_geomGraph__WEBPACK_IMPORTED_MODULE_1__.GeomGraph) {
                layoutGeomGraphDetailed(n, cancelToken, layoutEngine, edgeRouter, packing);
            }
        }
    }
    function removeEdgesLeadingOutOfGraphOrCollapsingToSelfEdges() {
        const ret = new Set();
        const graphUnderSurgery = geomG.graph;
        if (graphUnderSurgery.parent == null)
            return ret;
        for (const n of graphUnderSurgery.shallowNodes) {
            for (const e of n.outEdges) {
                const lifted = graphUnderSurgery.liftNode(e.target);
                if (lifted == null || lifted === n) {
                    ret.add(e);
                }
            }
            for (const e of n.inEdges) {
                const lifted = graphUnderSurgery.liftNode(e.source);
                if (lifted == null || lifted === n) {
                    ret.add(e);
                }
            }
        }
        for (const e of ret)
            e.remove();
        return ret;
    }
    function layoutComps() {
        if (connectedGraphs.length === 1) {
            layoutEngine(geomG, cancelToken, edgeLength);
        }
        else {
            for (const cg of connectedGraphs) {
                layoutEngine(cg, cancelToken, edgeLength);
                cg.boundingBox = cg.pumpTheBoxToTheGraphWithMargins();
            }
            packing(geomG, connectedGraphs);
        }
    }
} // end of layoutGeomGraphDetailed
// returns arrays of pairs (new lifted GeomEdge, existing Edge)
function createLiftedEdges(graph) {
    const liftedEdges = new Array();
    for (const u of graph.nodesBreadthFirst) {
        const liftedU = graph.liftNode(u);
        if (liftedU == null)
            continue;
        for (const uv of u.outEdges.values()) {
            const v = uv.target;
            const liftedV = graph.liftNode(v);
            if (liftedV == null || (liftedU === u && liftedV === v) || liftedU === liftedV) {
                continue;
            }
            uv.remove();
            const newLiftedEdge = new _structs_edge__WEBPACK_IMPORTED_MODULE_2__.Edge(liftedU, liftedV);
            const newLiftedGeomEdge = new _core_geomEdge__WEBPACK_IMPORTED_MODULE_4__.GeomEdge(newLiftedEdge);
            liftedEdges.push([newLiftedGeomEdge, uv]);
        }
    }
    return liftedEdges;
}
function getConnectedComponents(parentGeomGraph) {
    var _a;
    const parentGraph = parentGeomGraph.graph;
    const comps = (0,_structs_graph__WEBPACK_IMPORTED_MODULE_3__.shallowConnectedComponents)(parentGraph);
    const ret = [];
    let i = 0;
    for (const comp of comps) {
        const g = new _structs_graph__WEBPACK_IMPORTED_MODULE_3__.Graph(parentGraph.id + i++);
        g.parent = parentGraph;
        const geomG = new _core_geomGraph__WEBPACK_IMPORTED_MODULE_1__.GeomGraph(g);
        geomG.layoutSettings = (_a = parentGeomGraph.layoutSettings) !== null && _a !== void 0 ? _a : figureOutSettings(parentGeomGraph);
        for (const n of comp) {
            n.parent = g;
            g.addNode(n); // this changes the parent - should be restored to graph
        }
        ret.push(geomG);
    }
    return ret;
}
/** route edges with segments paralles to either X or Y axes */
function routeRectilinearEdges(geomG, edgesToRoute, cancelToken, nodePadding = 1, cornerFitRadius = 3, edgeSeparatian = 3) {
    const rr = _routing_rectilinear_RectilinearEdgeRouter__WEBPACK_IMPORTED_MODULE_0__.RectilinearEdgeRouter.constructorGNAN(geomG, edgesToRoute, nodePadding, cornerFitRadius);
    rr.edgeSeparatian = edgeSeparatian;
    rr.run();
}
function positionLabelsIfNeeded(geomG, edges) {
    if (edges.length === 0)
        return;
    const ep = _edgeLabelPlacement__WEBPACK_IMPORTED_MODULE_14__.EdgeLabelPlacement.constructorGA(geomG, edges);
    ep.run();
}
/** mark labels as required positoning */
function requireLabelPositioning(geomG) {
    for (const e of geomG.deepEdges) {
        if (e.label)
            e.label.isPositioned = false;
    }
}
function geometryIsCreated(graph) {
    if (_core_geomGraph__WEBPACK_IMPORTED_MODULE_1__.GeomGraph.getGeom(graph) == null)
        return false;
    for (const n of graph.shallowNodes) {
        const gn = _core_geomObject__WEBPACK_IMPORTED_MODULE_12__.GeomObject.getGeom(n);
        if (gn == null || gn.boundaryCurve == null)
            return false;
        if (n instanceof _structs_graph__WEBPACK_IMPORTED_MODULE_3__.Graph) {
            if (geometryIsCreated(n) === false) {
                return false;
            }
        }
    }
    for (const e of graph.edges) {
        const ge = _core_geomEdge__WEBPACK_IMPORTED_MODULE_4__.GeomEdge.getGeom(e);
        if (ge == null)
            return false;
    }
    return true;
}
function layoutIsCalculated(graph) {
    const geomGraph = _core_geomGraph__WEBPACK_IMPORTED_MODULE_1__.GeomGraph.getGeom(graph);
    if (geomGraph == null)
        return false;
    if (geomGraph.boundingBox == null || geomGraph.boundingBox.isEmpty())
        return false;
    for (const n of graph.shallowNodes) {
        const gn = _core_geomObject__WEBPACK_IMPORTED_MODULE_12__.GeomObject.getGeom(n);
        if (gn == null || gn.boundaryCurve == null)
            return false;
        if (n instanceof _structs_graph__WEBPACK_IMPORTED_MODULE_3__.Graph) {
            if (layoutIsCalculated(n) === false)
                return false;
        }
    }
    for (const e of graph.deepEdges) {
        const ge = _core_geomEdge__WEBPACK_IMPORTED_MODULE_4__.GeomEdge.getGeom(e);
        if (ge == null || ge.curve == null)
            return false;
    }
    // todo: consider adding more checks. For example, check that the bounding boxes of subgraphs make sense, and the edge curves are attached to the nodes
    return true;
}
function shiftToFirstQuarter(geomGraph) {
    const lb = geomGraph.boundingBox.leftBottom;
    if (lb.x < 0 || lb.y < 0) {
        const delta = new ___WEBPACK_IMPORTED_MODULE_6__.Point(-lb.x, -lb.y);
        geomGraph.translate(delta);
    }
}
//# sourceMappingURL=driver.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/edgeLabelPlacement.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeLabelPlacement: () => (/* binding */ EdgeLabelPlacement),
/* harmony export */   LabelPlacementResult: () => (/* binding */ LabelPlacementResult),
/* harmony export */   PlacementSide: () => (/* binding */ PlacementSide)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _core_geomGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");





var LabelPlacementResult;
(function (LabelPlacementResult) {
    /**
       Placement result meaning that another label was overlapped
      */
    LabelPlacementResult[LabelPlacementResult["OverlapsOtherLabels"] = 0] = "OverlapsOtherLabels";
    /**
      Placement result meaning that the label overlaps a node, but not a label
      */
    LabelPlacementResult[LabelPlacementResult["OverlapsNodes"] = 1] = "OverlapsNodes";
    /**
      Placement result meaning that the label overlaps an edge, but not a node or label.
      */
    LabelPlacementResult[LabelPlacementResult["OverlapsEdges"] = 2] = "OverlapsEdges";
    /**
      Placement result meaning that the label overlaps nothing.
      */
    LabelPlacementResult[LabelPlacementResult["OverlapsNothing"] = Number.MAX_VALUE] = "OverlapsNothing";
})(LabelPlacementResult || (LabelPlacementResult = {}));
var PlacementSide;
(function (PlacementSide) {
    /**
      //Places the label on any side
      */
    PlacementSide[PlacementSide["Any"] = 0] = "Any";
    /**
      //Places the label on the port side of the edge.
      //Port is the left side of the edge if you were facing away from the source and towards the target.
      */
    PlacementSide[PlacementSide["Port"] = 1] = "Port";
    /**
      //Places the label on the starboard side of the edge.
      //Starboard is the right side of the edge if you were facing away from the source and towards the target.
      */
    PlacementSide[PlacementSide["Starboard"] = 2] = "Starboard";
    /**
      //Places the label on the top side of the line.
      //If the line is vertical, the label is placed on the left.
      */
    PlacementSide[PlacementSide["Top"] = 3] = "Top";
    /**
      //Places the label on the bottom side of the line.
      //If the line is vertical, the label is placed on the right.
      */
    PlacementSide[PlacementSide["Bottom"] = 4] = "Bottom";
    /**
      //Places the label on the left side of the line.
      //If the line is horizontal, the label is placed on the top.
      */
    PlacementSide[PlacementSide["Left"] = 5] = "Left";
    /**
      //Places the label on the right side of the line.
      //If the line is horizontal, the label is placed on the bottom.
      */
    PlacementSide[PlacementSide["Right"] = 6] = "Right";
})(PlacementSide || (PlacementSide = {}));
class PointSet {
}
class PointSetList {
    constructor() {
        this.points = [];
        this.coveredLength = 0;
    }
    AddFirst(p) {
        if (this.points.length !== 0) {
            const q = this.points[0];
            this.coveredLength = this.coveredLength + p.Center.sub(q.Center).length;
        }
        this.points.unshift(p);
        return this.coveredLength;
    }
    AddLast(p) {
        if (this.points.length !== 0) {
            const q = this.points[this.points.length - 1];
            this.coveredLength = this.coveredLength + p.Center.sub(q.Center).length;
        }
        this.points.push(p);
        return this.coveredLength;
    }
}
var PlacementStrategy;
(function (PlacementStrategy) {
    //Try to place the label running along the curve path
    PlacementStrategy[PlacementStrategy["AlongCurve"] = 0] = "AlongCurve";
    //Standard horizontal label
    PlacementStrategy[PlacementStrategy["Horizontal"] = 1] = "Horizontal";
})(PlacementStrategy || (PlacementStrategy = {}));
class PortObstacle {
    constructor(p) {
        this.location = p;
        this.boundingBox = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.rectangleOnPoint(p);
    }
}
class RectangleObstacle {
    constructor(box, data) {
        this.data = data;
        this.boundingBox = box;
    }
}
class LabelInfo {
    constructor(edgePoints) {
        this.innerPoints = [];
        this.outerPoints = [];
        this.placementSide = PlacementSide.Any;
        this.placementOffset = 0.5;
        this.edgePoints = edgePoints;
        this.placementSide;
    }
}
/** The class to place labels */
class EdgeLabelPlacement extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_2__.Algorithm {
    //     The granularity with which to break up a curve into sub points.
    get CollisionGranularity() {
        return this.granularity;
    }
    set CollisionGranularity(value) {
        this.granularity = value;
    }
    //     Constructs an edge label placer that places all labels in the graph.
    static constructorG(graph) {
        return new EdgeLabelPlacement(Array.from(graph.nodesBreadthFirst), Array.from(graph.deepEdges).filter((e) => e.label));
    }
    //     Constructs an edge label placer that places the given labels in the graph.
    static constructorGA(graph, edges) {
        return new EdgeLabelPlacement(Array.from(graph.nodesBreadthFirst), edges.filter((e) => e.label));
    }
    //     Constructs a edge label placer that will only avoid overlaps with the given nodes and edges.
    constructor(nodes, edges) {
        super(null);
        this.placementStrategy = [PlacementStrategy.Horizontal, PlacementStrategy.AlongCurve];
        this.obstacleMaps = [];
        this.edgeInfos = new Map();
        this.granularity = EdgeLabelPlacement.MinGranularity;
        /**      True if the edge collision granularity should be degraded as the number of edges increases. */
        this.ScaleCollisionGranularity = true;
        this.granularity = this.ScaleCollisionGranularity ? this.interpolateGranularity(edges.length) : EdgeLabelPlacement.MinGranularity;
        this.InitializeObstacles(nodes, edges);
        this.edges = edges;
    }
    interpolateGranularity(edgeCount) {
        if (edgeCount <= EdgeLabelPlacement.LowerEdgeBound) {
            return EdgeLabelPlacement.MaxGranularity;
        }
        if (edgeCount >= EdgeLabelPlacement.UpperEdgeBound) {
            return EdgeLabelPlacement.MinGranularity;
        }
        const delta = (EdgeLabelPlacement.UpperEdgeBound - EdgeLabelPlacement.LowerEdgeBound) / (edgeCount - EdgeLabelPlacement.LowerEdgeBound);
        return Math.ceil(EdgeLabelPlacement.MinGranularity + delta);
    }
    InitializeObstacles(nodes, edgeList) {
        const edgeObstacles = this.GetEdgeObstacles(edgeList);
        this.obstacleMaps[1] = (0,_math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__.mkRTree)(nodes.map((n) => [n.boundingBox, new RectangleObstacle(n.boundingBox, n)]));
        // later we init obstacleMaps[0] to lableObstacleMap
        this.obstacleMaps[2] = (0,_math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__.mkRTree)(edgeObstacles.map((e) => [e.boundingBox, new RectangleObstacle(e.boundingBox, e)]));
        // Avoiding edge overlaps is lowest priority, so put it last
    }
    static CurvePoints(curve, granularity) {
        const points = [];
        const delta = curve.end.sub(curve.start).lengthSquared / (granularity * granularity);
        EdgeLabelPlacement.SubdivideCurveSegment(points, curve, delta, curve.parStart, curve.parEnd);
        points.sort(EdgeLabelPlacement.compareByArgument);
        return points;
    }
    static compareByArgument(x, y) {
        if (x[0] < y[0]) {
            return -1;
        }
        if (x[0] > y[0]) {
            return 1;
        }
        return 0;
    }
    static SubdivideCurveSegment(list, curve, delta2, start, end) {
        if (list.length > 64) {
            //LN I saw this function never finishing for a very long curve
            return;
        }
        const startPoint = curve.value(start);
        const endPoint = curve.value(end);
        if (startPoint.sub(endPoint).lengthSquared > delta2) {
            const mid = (start + end) / 2.0;
            EdgeLabelPlacement.SubdivideCurveSegment(list, curve, delta2, start, mid);
            EdgeLabelPlacement.SubdivideCurveSegment(list, curve, delta2, mid, end);
        }
        else {
            list.push([start, startPoint]);
        }
    }
    //Places the given labels at their default positions.  Only avoids overlaps with the edge and source/target node that the label is connected to.
    static PlaceLabelsAtDefaultPositions(cancelToken, edges) {
        for (const edge of edges) {
            if (edge.label) {
                const placer = new EdgeLabelPlacement([edge.source, edge.target], [edge]);
                placer.run();
            }
        }
    }
    GetEdgeObstacles(edges) {
        const edgeObstacles = [];
        for (const e of edges) {
            if (e.curve == null)
                continue;
            const curvePoints = EdgeLabelPlacement.CurvePoints(e.curve, this.CollisionGranularity);
            this.edgeInfos.set(e, new LabelInfo(curvePoints));
            for (const p of curvePoints) {
                edgeObstacles.push(new PortObstacle(p[1]));
            }
        }
        return edgeObstacles;
    }
    /**       Adds the label to the label obstacle map.*/
    AddLabelObstacle(label) {
        if (this.labelObstacleMap == null) {
            this.labelObstacleMap = (0,_math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__.mkRTree)([[label.boundingBox, label]]);
            this.obstacleMaps[0] = this.labelObstacleMap;
        }
        else {
            this.labelObstacleMap.Add(label.boundingBox, label);
        }
    }
    //     Places the given labels.
    run() {
        // Place labels on short edges before labels on long edges, since short edges have less options.
        this.edges.sort((a, b) => {
            return this.edgeInfos.get(a).edgePoints.length - this.edgeInfos.get(b).edgePoints.length;
        });
        for (const edge of this.edges) {
            this.PlaceLabel(edge);
        }
    }
    //     Places the given label in an available location.
    PlaceLabel(edge) {
        let placed = false;
        for (const s of this.placementStrategy) {
            switch (s) {
                case PlacementStrategy.AlongCurve:
                    placed = this.PlaceEdgeLabelOnCurve(edge.label);
                    break;
                case PlacementStrategy.Horizontal:
                    placed = this.PlaceEdgeLabelHorizontally(edge);
                    break;
                default:
                    throw new Error('unexpected case');
            }
            if (placed) {
                break;
            }
        }
        if (placed) {
            this.CalculateCenterLabelInfoCenter(edge.label);
        }
        else {
            this.PlaceLabelAtFirstPosition(edge.label);
        }
    }
    getLabelInfo(label) {
        const ge = label.parent;
        return this.edgeInfos.get(ge);
    }
    //     Places the label at the first position requested.  Ignores all overlaps.
    PlaceLabelAtFirstPosition(label) {
        const edge = label.parent;
        const curve = edge.curve;
        const points = this.edgeInfos.get(edge).edgePoints;
        const index = this.StartIndex(label, points.map((p) => p[1]));
        const point = points[index][1];
        let derivative = curve.derivative(points[index][0]);
        // If the curve is a line of length (close to) 0, the derivative may be (close to) 0.
        // Pick a direction in that case.
        if (derivative.length < _math_geometry__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon) {
            derivative = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(1, 1);
        }
        derivative = derivative.normalize();
        const widthHeight = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Size(label.width, label.height);
        const labelInfo = this.getLabelInfo(label);
        const side = EdgeLabelPlacement.GetPossibleSides(labelInfo.placementSide, derivative)[0];
        const bounds = EdgeLabelPlacement.GetLabelBounds(point, derivative, widthHeight, side);
        this.SetLabelBounds(this.getLabelInfo(label), bounds);
    }
    StartIndex(label, points) {
        const labelInfo = this.getLabelInfo(label);
        return Math.min(points.length - 1, Math.max(0, Math.floor(points.length * labelInfo.placementOffset)));
    }
    CalculateCenterLabelInfoCenter(label) {
        const labelInfo = this.getLabelInfo(label);
        let cen = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
        for (const p of labelInfo.innerPoints) {
            cen = cen.add(p);
        }
        for (const p of labelInfo.outerPoints) {
            cen = cen.add(p);
        }
        label.positionCenter(cen.div(labelInfo.innerPoints.length + labelInfo.outerPoints.length));
    }
    PlaceEdgeLabelHorizontally(edge) {
        const label = edge.label;
        // approximate label with a rectangle
        // process candidate points for label ordered by priority
        // check candidate point for conflicts - if none then stop and keep placement
        const labelInfo = this.getLabelInfo(label);
        const curvePoints = labelInfo.edgePoints;
        const wh = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Size(label.width, label.height);
        let bestConflictIndex = -1;
        let bestRectangle = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkEmpty();
        const curve = edge.curve;
        for (const index of EdgeLabelPlacement.ExpandingSearch(this.StartIndex(label, curvePoints.map((p) => p[1])), 0, curvePoints.length)) {
            const cp = curvePoints[index];
            let der = curve.derivative(cp[0]);
            if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(der.lengthSquared, 0)) {
                continue;
            }
            der = der.normalize();
            for (const side of EdgeLabelPlacement.GetPossibleSides(this.getLabelInfo(label).placementSide, der)) {
                const queryRect = EdgeLabelPlacement.GetLabelBounds(cp[1], der, wh, side);
                const conflictIndex = this.ConflictIndexRL(queryRect, label);
                if (conflictIndex > bestConflictIndex) {
                    bestConflictIndex = conflictIndex;
                    bestRectangle = queryRect;
                    // If the best location was found, we're done
                    if (bestConflictIndex === Number.MAX_VALUE) {
                        break;
                    }
                }
            }
            // If the best location was found, we're done
            if (bestConflictIndex === Number.MAX_VALUE) {
                break;
            }
        }
        if (bestConflictIndex >= 0) {
            this.SetLabelBounds(this.getLabelInfo(label), bestRectangle);
            const r = new RectangleObstacle(bestRectangle, null);
            this.AddLabelObstacle(r);
            const labelInfo = this.getLabelInfo(label);
            if (bestConflictIndex === 0)
                labelInfo.placementResult = LabelPlacementResult.OverlapsOtherLabels;
            else if (bestConflictIndex === 1)
                labelInfo.placementResult = LabelPlacementResult.OverlapsNodes;
            else if (bestConflictIndex === 2)
                labelInfo.placementResult = LabelPlacementResult.OverlapsEdges;
            else
                labelInfo.placementResult = LabelPlacementResult.OverlapsNothing;
            return true;
        }
        return false;
    }
    //     Gets the label placement bounds for the given location, side, and label size.
    // The point along a curve that the label should be placed near.
    // The derivative of the curve at the point position.
    // The width and height of the label.
    // The side (1 or -1) of the line to place the label on.
    // <returns>The label's desired position.</returns>
    static GetLabelBounds(point, derivative, size, side) {
        const o = derivative.rotate(Math.PI / 2).mul(side);
        const labelPos = point.add(o);
        const oLength = 1;
        let left = o.x > 0 ? labelPos.x : labelPos.x - size.width;
        let bottom = o.y > 0 ? labelPos.y : labelPos.y - size.height;
        // If the line is near horizontal, shift the placement
        // to make it naturally transistion from o.X being negative to positive.
        if (Math.abs(o.x) < 0.75) {
            // _________  /
            // |______w_|/
            //     \   o/
            //      \  /
            //       \/ <-- right angle
            //       /
            //      /
            // Get the angle, 'o', between the line and the label
            const horizontalAngle = Math.acos(Math.abs(o.y) / oLength);
            // Get the distance, 'w', from the tip of the normal to the line
            const horizontalShift = oLength / Math.sin(horizontalAngle);
            const verticalShift = oLength / Math.cos(horizontalAngle);
            // Shift the label by this amount, or by half the width.  Whichever is smaller
            left += (o.x > 0 ? -1 : 1) * Math.min(horizontalShift, size.width / 2.0);
            bottom += (o.y > 0 ? 1 : -1) * verticalShift;
        }
        else if (Math.abs(o.y) < 0.75) {
            const verticalAngle = Math.acos(Math.abs(o.x) / oLength);
            const verticalShift = oLength / Math.sin(verticalAngle);
            const horizontalShift = oLength / Math.cos(verticalAngle);
            left += (o.x > 0 ? 1 : -1) * horizontalShift;
            bottom += (o.y > 0 ? -1 : 1) * Math.min(verticalShift, size.height / 2.0);
        }
        return _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkLeftBottomSize(left, bottom, size);
    }
    //     Sets the label's position to be the given bounds.
    SetLabelBounds(labelInfo, bounds) {
        labelInfo.innerPoints = [bounds.leftTop, bounds.rightTop];
        labelInfo.outerPoints = [bounds.leftBottom, bounds.rightBottom];
    }
    //     Gets the possible sides for the given label and the given derivative point.
    // <returns>An enumeration of the possible sides (-1 or 1).</returns>
    static GetPossibleSides(side, derivative) {
        if (derivative.length === 0) {
            side = PlacementSide.Any;
        }
        switch (side) {
            case PlacementSide.Port:
                return [-1];
                break;
            case PlacementSide.Starboard:
                return [1];
            case PlacementSide.Top:
                if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(derivative.x, 0)) {
                    // If the line is vertical, Top becomes Left
                    return EdgeLabelPlacement.GetPossibleSides(PlacementSide.Left, derivative);
                }
                return [1];
            case PlacementSide.Bottom:
                if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(derivative.x, 0)) {
                    // If the line is vertical, Bottom becomes Right
                    return EdgeLabelPlacement.GetPossibleSides(PlacementSide.Right, derivative);
                }
                return [derivative.x < 0 ? -1 : 1];
            case PlacementSide.Left:
                if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(derivative.y, 0)) {
                    // If the line is horizontal, Left becomes Top
                    return EdgeLabelPlacement.GetPossibleSides(PlacementSide.Top, derivative);
                }
                return [derivative.y < 0 ? -1 : 1];
            case PlacementSide.Right:
                if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(derivative.y, 0)) {
                    // If the line is horizontal, Right becomes Bottom
                    return EdgeLabelPlacement.GetPossibleSides(PlacementSide.Bottom, derivative);
                }
                return [derivative.y < 0 ? 1 : -1];
            default:
                return [-1, 1];
        }
    }
    static *ExpandingSearch(start, min, max) {
        let upper = start + 1;
        let lower = upper;
        while (lower > min) {
            yield --lower;
        }
        while (upper < max) {
            yield upper++;
        }
    }
    static PointSetLength(ps) {
        let l = 0;
        let q = null;
        for (const p of ps) {
            if (q != null) {
                l += q.sub(p.Center).length;
            }
            q = p.Center;
        }
        return l;
    }
    PlaceEdgeLabelOnCurve(label) {
        // approximate label with a set of circles
        // generate list of candidate points for label ordered by priority
        // check candidate point for conflicts - if none then stop and keep placement
        const edge = label.parent;
        const labelInfo = this.getLabelInfo(label);
        labelInfo.innerPoints = null;
        const curvePoints = labelInfo.edgePoints;
        const distanceFromCurve = 3;
        const radius = label.height / 2;
        const wh = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Size(radius, radius);
        const labelLength = label.width;
        for (const index of EdgeLabelPlacement.ExpandingSearch(this.StartIndex(label, curvePoints), 0, curvePoints.length)) {
            const sides = this.GetSidesAndEdgeCurve(label, edge, curvePoints, index);
            for (const side of sides) {
                const placedPoints = new PointSetList();
                const t = { coveredLength: 0 };
                this.ProcessExpandingSearchOnSide(index, curvePoints, edge.curve, side, radius, distanceFromCurve, wh, t, placedPoints, labelLength);
                if (t.coveredLength >= labelLength) {
                    this.CaseOfCoveredLengthGreaterThanLabelLength(label, placedPoints, t.coveredLength, labelLength, wh);
                    return true;
                }
            }
        }
        return false;
    }
    CaseOfCoveredLengthGreaterThanLabelLength(label, placedPoints, coveredLength, labelLength, wh) {
        const innerPoints = new Array();
        const outerPoints = new Array();
        const orderedPoints = Array.from(placedPoints.points);
        const excess = coveredLength - labelLength;
        if (excess > 0) {
            // move back the last point
            let q = orderedPoints[orderedPoints.length - 1];
            let p = orderedPoints[orderedPoints.length - 2];
            let v = q.Center.sub(p.Center);
            let length = v.length;
            if (excess > length) {
                q = orderedPoints[0];
                p = orderedPoints[1];
                v = q.Center.sub(p.Center);
                length = v.length;
            }
            const w = v.mul((length - excess) / length);
            q.Center = p.Center.add(w);
            q.Inner = p.Inner.add(w);
            q.Outer = p.Outer.add(w);
        }
        this.GoOverOrderedPointsAndAddLabelObstacels(orderedPoints, innerPoints, outerPoints, wh);
        // placed all points in label so we are done
        const labelInfo = this.getLabelInfo(label);
        labelInfo.innerPoints = innerPoints;
        labelInfo.outerPoints = outerPoints;
    }
    GoOverOrderedPointsAndAddLabelObstacels(orderedPoints, innerPoints, outerPoints, wh) {
        for (const p of orderedPoints) {
            const center = p.Center;
            innerPoints.push(p.Inner);
            outerPoints.push(p.Outer);
            const r = new RectangleObstacle(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkSizeCenter(new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Size(wh.width * 2, wh.height * 2), center), null);
            this.AddLabelObstacle(r);
        }
    }
    ProcessExpandingSearchOnSide(index, curvePoints, curve, side, radius, distanceFromCurve, wh, t, placedPoints, labelLength) {
        for (const i of EdgeLabelPlacement.ExpandingSearch(index, 0, curvePoints.length)) {
            const [par, pnt] = curvePoints[i];
            const der = curve.derivative(par);
            if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(der.lengthSquared, 0)) {
                continue;
            }
            const o = der
                .rotate(Math.PI / 2)
                .normalize()
                .mul(side);
            const labelPos = pnt.add(o.mul(radius + distanceFromCurve));
            if (!this.Conflict(labelPos, radius, wh)) {
                // found a valid candidate position
                const ps = new PointSet();
                ps.Center = labelPos;
                ps.Inner = pnt.add(o.mul(distanceFromCurve));
                ps.Outer = pnt.add(o.mul(2.0 * radius + distanceFromCurve));
                t.coveredLength = i <= index ? placedPoints.AddFirst(ps) : placedPoints.AddLast(ps);
                if (t.coveredLength >= labelLength) {
                    break;
                }
            }
            else {
                // not going to work!
                break;
            }
        }
    }
    GetSidesAndEdgeCurve(label, e, curvePoints, index) {
        const initialDer = e.curve.derivative(curvePoints[index][0]);
        return EdgeLabelPlacement.GetPossibleSides(this.getLabelInfo(label).placementSide, initialDer);
    }
    //     Determines if the query point intersects with any of the obstacles.
    // <returns>True if the query point itnersects with any of the obstacles.</returns>
    Conflict(labelPos, radius, wh) {
        return this.ConflictIndex(labelPos, radius, wh) !== Number.MAX_VALUE;
    }
    //    Determines the index of the first obstacle map that the rectangle intersects.
    //    Clusters that are parents/grandparents of the label's source/target nodes are not considered intersection.
    // <returns>The index of the first obstacle map that the rectangle intersects. int.MaxValue if there is no intersection.</returns>
    ConflictIndexRL(queryRect, label) {
        const edge = label.parent;
        const source = edge.source;
        const target = edge.target;
        for (let i = 0; i < this.obstacleMaps.length; i++) {
            if (this.obstacleMaps[i] == null) {
                continue;
            }
            for (const obstacle of this.obstacleMaps[i].GetAllIntersecting(queryRect)) {
                // If we're overlapping a node...
                if (i === LabelPlacementResult.OverlapsNodes) {
                    // ...and the node is a cluster...
                    const isRectangleObstacle = obstacle instanceof RectangleObstacle;
                    if (isRectangleObstacle) {
                        const isCluster = obstacle.data instanceof _core_geomGraph__WEBPACK_IMPORTED_MODULE_4__.GeomGraph;
                        // ...and the cluster is a grandparent of the source or target...
                        if (isCluster && (source.node.isDescendantOf(obstacle.data.graph) || target.node.isDescendantOf(obstacle.data))) {
                            // ...don't consider the overlap to be a conflict.
                            continue;
                        }
                    }
                }
                return i;
            }
        }
        return Number.MAX_VALUE;
    }
    /**   Determines the index of the first obstacle map that the point intersects.
      Returns the index of the first obstacle map that the point intersects. int.MaxValue if there is no intersection.*/
    ConflictIndex(labelPos, radius, wh) {
        const queryRect = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.creatRectangleWithSize(new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Size(wh.width * 2, wh.height * 2), labelPos);
        const r2 = radius * radius;
        for (let i = 0; i < this.obstacleMaps.length; i++) {
            if (this.obstacleMaps[i] == null) {
                continue;
            }
            for (let i = 0; i < this.obstacleMaps.length; i++) {
                if (this.obstacleMaps[i] == null)
                    continue;
                for (const c of this.obstacleMaps[i].GetAllIntersecting(queryRect)) {
                    if (c instanceof PortObstacle) {
                        if (labelPos.sub(c.location).lengthSquared < r2)
                            return i;
                    }
                    else
                        return i;
                }
            }
            return Number.MAX_VALUE;
        }
    }
}
/**       The default and minimum granularity for breaking up a curve into many points.*/
EdgeLabelPlacement.MinGranularity = 5;
/**       The maximum granulairty for breaking up a curve into many points.*/
EdgeLabelPlacement.MaxGranularity = 50;
/**       The number of edges at which to start increasing the granularity.*/
EdgeLabelPlacement.LowerEdgeBound = 500;
/**       The number of edges at which to stop increasing the granularity.*/
EdgeLabelPlacement.UpperEdgeBound = 3000;
//# sourceMappingURL=edgeLabelPlacement.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/MstLineSweeper.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MstLineSweeper: () => (/* binding */ MstLineSweeper)
/* harmony export */ });
/* harmony import */ var _math_geometry_Interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/Interval.js");
/* harmony import */ var _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js");
/* harmony import */ var _structs_BinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/BinaryHeapPriorityQueue.js");
/* harmony import */ var _gTreeOverlapRemoval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/gTreeOverlapRemoval.js");




class MstLineSweeper {
    constructor(proximityEdges, nodeSizes, nodePositions, forLayers) {
        this._numberOfOverlaps = 0;
        this._proximityEdges = proximityEdges;
        this._nodeSizes = nodeSizes;
        this._nodePositions = nodePositions;
        this._forLayers = forLayers;
        /*Assert.assert(nodePositions.length === nodeSizes.length)*/
        this._q = new _structs_BinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_2__.BinaryHeapPriorityQueue(nodeSizes.length * 2);
    }
    Run() {
        this.InitQueue();
        this.FindOverlaps();
        return this._numberOfOverlaps;
    }
    FindOverlaps() {
        while (this._q.Count > 0) {
            let i = this._q.Dequeue();
            if (i < this._nodePositions.length) {
                this.FindOverlapsWithInterval(i);
                this.AddIntervalToTree(i);
            }
            else {
                i -= this._nodePositions.length;
                this.RemoveIntervalFromTree(i);
            }
        }
    }
    RemoveIntervalFromTree(i) {
        this._intervalTree.Remove(this.GetInterval(i), i);
    }
    AddIntervalToTree(i) {
        const interval = this.GetInterval(i);
        if (this._intervalTree == null) {
            this._intervalTree = (0,_math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__.mkRTree)([]);
        }
        this._intervalTree.Add(interval, i);
    }
    FindOverlapsWithInterval(i) {
        if (this._intervalTree == null) {
            return;
        }
        const interval = this.GetInterval(i);
        for (const j of this._intervalTree.GetAllIntersecting(interval)) {
            const edge = _gTreeOverlapRemoval__WEBPACK_IMPORTED_MODULE_3__.GTreeOverlapRemoval.GetIdealEdge(i, j, this._nodePositions[i], this._nodePositions[j], this._nodeSizes);
            if (edge.overlapFactor <= 1) {
                return;
            }
            this._proximityEdges.push(edge);
            this._numberOfOverlaps++;
        }
    }
    GetInterval(i) {
        const w = this._nodeSizes[i].width / 2;
        const nodeCenterX = this._nodePositions[i].x;
        return new _math_geometry_Interval__WEBPACK_IMPORTED_MODULE_0__.Interval(nodeCenterX - w, nodeCenterX + w);
    }
    InitQueue() {
        for (let i = 0; i < this._nodeSizes.length; i++) {
            const h = this._nodeSizes[i].height / 2;
            const nodeCenterY = this._nodePositions[i].y;
            this._q.Enqueue(i, nodeCenterY - h);
            // enqueue the bottom event
            this._q.Enqueue(this._nodeSizes.length + i, nodeCenterY + h);
            // enqueue the top event
        }
    }
}
//# sourceMappingURL=MstLineSweeper.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/MstOnDelaunayTriangulation.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MstOnDelaunayTriangulation: () => (/* binding */ MstOnDelaunayTriangulation)
/* harmony export */ });
/* harmony import */ var _math_graphAlgorithms_MinimumSpanningTreeByPrim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/graphAlgorithms/MinimumSpanningTreeByPrim.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairMap.js");




// Computes the minimum spanning tree on a triangulation or on a set of edges given by a list of tuples
class MstOnDelaunayTriangulation {
    // Computes the minimum spanning tree on a set of edges
    static GetMst(proximityEdges, size) {
        if (proximityEdges.length === 0) {
            return null;
        }
        const intPairs = proximityEdges.map((t) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__.IntPair(t.source, t.target));
        const weighting = new _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_3__.IntPairMap();
        for (let i = 0; i < proximityEdges.length; i++) {
            weighting.setPair(intPairs[i], proximityEdges[i]);
        }
        const graph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__.mkGraphOnEdgesN)(intPairs, size);
        const mstOnBasicGraph = new _math_graphAlgorithms_MinimumSpanningTreeByPrim__WEBPACK_IMPORTED_MODULE_0__.MinimumSpanningTreeByPrim(graph, (intPair) => weighting.get(intPair.source, intPair.target).weight, intPairs[0].source);
        return mstOnBasicGraph.GetTreeEdges().map((e) => weighting.get(e.source, e.target));
    }
    // Computes the minimum spanning tree on a DT with given weights.
    static GetMstOnCdt(cdt, weights) {
        const siteArray = Array.from(cdt.PointsToSites.values());
        const siteIndex = new Map();
        for (let i = 0; i < siteArray.length; i++) {
            siteIndex.set(siteArray[i], i);
        }
        const intPairsToCdtEdges = MstOnDelaunayTriangulation.GetEdges(siteArray, siteIndex);
        const graph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__.mkGraphOnEdgesArray)(Array.from(intPairsToCdtEdges.keys()));
        const mstOnBasicGraph = new _math_graphAlgorithms_MinimumSpanningTreeByPrim__WEBPACK_IMPORTED_MODULE_0__.MinimumSpanningTreeByPrim(graph, (e) => weights(intPairsToCdtEdges.get(e.source, e.target)), 0);
        return mstOnBasicGraph.GetTreeEdges().map((e) => intPairsToCdtEdges.get(e.source, e.target));
    }
    static GetEdges(siteArray, siteIndex) {
        const d = new _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_3__.IntPairMap();
        for (let i = 0; i < siteArray.length; i++) {
            const site = siteArray[i];
            const sourceIndex = siteIndex.get(site);
            for (const e of site.Edges) {
                d.set(sourceIndex, siteIndex.get(e.lowerSite), e);
            }
        }
        return d;
    }
}
//# sourceMappingURL=MstOnDelaunayTriangulation.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/OverlapRemovalSettings.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlapRemovalSettings: () => (/* binding */ OverlapRemovalSettings)
/* harmony export */ });
// Settings for Overlap Removal process. Usage of the properties depends on the algorithm.
class OverlapRemovalSettings {
    constructor() {
        this.epsilon = 0.01;
        this.iterationsMax = 1000;
        this.stopOnMaxIterat = false;
        this.nodeSeparation = 4;
        this.randomizationSeed = 1;
        this.randomizationShift = 0.1;
    }
    // If true, the overlap iteration process stops after maxIterat iterations.
    get StopOnMaxIterat() {
        return this.stopOnMaxIterat;
    }
    set StopOnMaxIterat(value) {
        this.stopOnMaxIterat = value;
    }
    // Epsilon
    get Epsilon() {
        return this.epsilon;
    }
    set Epsilon(value) {
        this.epsilon = value;
    }
    // Number of maxIterat to be made. In each iteration overlap is partly removed.
    get IterationsMax() {
        return this.iterationsMax;
    }
    set IterationsMax(value) {
        this.iterationsMax = value;
    }
    // Minimal distance between nodes.
    get NodeSeparation() {
        return this.nodeSeparation;
    }
    set NodeSeparation(value) {
        this.nodeSeparation = value;
    }
    //
    get RandomizationSeed() {
        return this.randomizationSeed;
    }
    set RandomizationSeed(value) {
        this.randomizationSeed = value;
    }
    //
    get RandomizationShift() {
        return this.randomizationShift;
    }
    set RandomizationShift(value) {
        this.randomizationShift = value;
    }
    // Clones the settings together with the stressmajorization settings
    Clone() {
        const settings = new OverlapRemovalSettings();
        settings.Epsilon = this.Epsilon;
        settings.IterationsMax = this.IterationsMax;
        settings.StopOnMaxIterat = this.StopOnMaxIterat;
        settings.NodeSeparation = this.NodeSeparation;
        settings.RandomizationSeed = this.RandomizationSeed;
        settings.RandomizationShift = this.randomizationShift;
        return settings;
    }
}
//# sourceMappingURL=OverlapRemovalSettings.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/gTreeOverlapRemoval.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GTreeOverlapRemoval: () => (/* binding */ GTreeOverlapRemoval)
/* harmony export */ });
/* harmony import */ var reliable_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/reliable-random/dist/index.esm.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _routing_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
/* harmony import */ var _MstLineSweeper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/MstLineSweeper.js");
/* harmony import */ var _MstOnDelaunayTriangulation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/MstOnDelaunayTriangulation.js");
/* harmony import */ var _OverlapRemovalSettings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/OverlapRemovalSettings.js");









// Overlap Removal using Minimum Spanning Tree on the delaunay triangulation. The edge weight corresponds to the amount of overlap between two nodes.
class GTreeOverlapRemoval {
    // Settings to be used for the overlap removal, not all of them are used.
    constructor(settings, nodes) {
        this._settings = settings;
        this._nodes = nodes;
    }
    // Removes the overlap by using the default settings.
    static RemoveOverlaps(nodes, nodeSeparation) {
        const settings = new _OverlapRemovalSettings__WEBPACK_IMPORTED_MODULE_8__.OverlapRemovalSettings();
        settings.RandomizationShift = 1;
        settings.NodeSeparation = nodeSeparation;
        const mst = new GTreeOverlapRemoval(settings, nodes);
        mst.RemoveOverlaps();
    }
    // Removes the overlaps for the given graph.
    RemoveOverlaps() {
        if (this._nodes.length < 3) {
            this.RemoveOverlapsOnTinyGraph();
            return;
        }
        const t = { nodePositions: new Array(), nodeSizes: new Array() };
        InitNodePositionsAndBoxes(this._settings, this._nodes, t, this._settings.RandomizationShift);
        this.lastRunNumberIterations = 0;
        while (this.OneIteration(t.nodePositions, t.nodeSizes, false)) {
            this.lastRunNumberIterations++;
        }
        while (this.OneIteration(t.nodePositions, t.nodeSizes, true)) {
            this.lastRunNumberIterations++;
        }
        for (let i = 0; i < this._nodes.length; i++) {
            this._nodes[i].center = t.nodePositions[i];
        }
    }
    RemoveOverlapsOnTinyGraph() {
        if (this._nodes.length === 1) {
            return;
        }
        if (this._nodes.length === 2) {
            const a = this._nodes[0];
            const b = this._nodes[1];
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.closeDistEps(a.center, b.center)) {
                b.center = b.center.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(0.001, 0));
            }
            const idealDist = this.GetIdealDistanceBetweenTwoNodes(a, b);
            const o = _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.middle(a.center, b.center);
            let dir = a.center.sub(b.center);
            const dist = dir.length;
            dir = dir.mul(0.5 * (idealDist / dist));
            a.center = o.add(dir);
            b.center = o.sub(dir);
        }
    }
    GetIdealDistanceBetweenTwoNodes(a, b) {
        const ab = a.center.sub(b.center);
        const dx = Math.abs(ab.x);
        const dy = Math.abs(ab.y);
        const w = (a.width + b.width) / 2 + this._settings.NodeSeparation;
        const h = (a.height + b.height) / 2 + this._settings.NodeSeparation;
        let scaleX = Number.POSITIVE_INFINITY;
        let scaleY = Number.POSITIVE_INFINITY;
        if (dx > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
            scaleX = w / dx;
        }
        if (dy > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
            scaleY = h / dy;
        }
        return Math.min(scaleX, scaleY) * ab.length;
    }
    static AvgEdgeLength(nodes) {
        let count = 0;
        let avgEdgeLength = 0;
        for (const n of nodes) {
            for (const edge of n.outEdges()) {
                avgEdgeLength += n.center.sub(edge.target.center).length;
                count++;
            }
        }
        return count > 0 ? avgEdgeLength / count : 1;
    }
    // Does one iterations in which a miniminum spanning tree is
    // determined on the delaunay triangulation and finally the tree is extended to resolve the overlaps.
    OneIteration(nodePositions, nodeSizes, scanlinePhase) {
        const ts = new Array();
        for (let i = 0; i < nodePositions.length; i++) {
            ts.push([nodePositions[i], i]);
        }
        const cdt = _routing_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_4__.Cdt.constructor_(ts);
        cdt.run();
        const siteIndex = new Map();
        for (let i = 0; i < nodePositions.length; i++) {
            siteIndex.set(cdt.PointsToSites.get(nodePositions[i]), i);
        }
        let numCrossings = 0;
        const proximityEdges = new Array();
        for (const site of cdt.PointsToSites.values()) {
            for (const edge of site.Edges) {
                const point1 = edge.upperSite.point;
                const point2 = edge.lowerSite.point;
                const i = siteIndex.get(edge.upperSite);
                const j = siteIndex.get(edge.lowerSite);
                /*Assert.assert(Point.closeDistEps(point1, nodePositions[i]))*/
                /*Assert.assert(Point.closeDistEps(point2, nodePositions[j]))*/
                const mstEdge = GTreeOverlapRemoval.GetIdealEdge(i, j, point1, point2, nodeSizes);
                proximityEdges.push(mstEdge);
                if (mstEdge.overlapFactor > 1) {
                    numCrossings++;
                }
            }
        }
        if (numCrossings === 0 || scanlinePhase) {
            const additionalCrossings = this.FindProximityEdgesWithSweepLine(proximityEdges, nodeSizes, nodePositions);
            if (numCrossings === 0 && additionalCrossings === 0) {
                //                    if(nodeSizes.Length>100)
                //                    ShowAndMoveBoxesRemoveLater(null, proximityEdges, nodeSizes, nodePositions, -1);
                return false;
            }
            if (numCrossings === 0 && !scanlinePhase) {
                return false;
            }
        }
        const treeEdges = _MstOnDelaunayTriangulation__WEBPACK_IMPORTED_MODULE_7__.MstOnDelaunayTriangulation.GetMst(proximityEdges, nodePositions.length);
        GTreeOverlapRemoval.MoveNodePositions(treeEdges, nodePositions, treeEdges[0].source);
        return true;
    }
    FindProximityEdgesWithSweepLine(proximityEdges, nodeSizes, nodePositions) {
        const mstLineSweeper = new _MstLineSweeper__WEBPACK_IMPORTED_MODULE_6__.MstLineSweeper(proximityEdges, nodeSizes, nodePositions, this._overlapForLayers);
        return mstLineSweeper.Run();
    }
    // Returns an edge with: i, j, t(overlapFactor), ideal distance, edge weight.
    static GetIdealEdge(i, j, point1, point2, nodeSizes) {
        const t = { overlapFactor: 0 };
        const idealDist = GTreeOverlapRemoval.GetIdealEdgeLength(i, j, point1, point2, nodeSizes, t);
        const length = point1.sub(point2).length;
        const box1 = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_3__.Rectangle.mkSizeCenter(nodeSizes[i], point1);
        const box2 = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_3__.Rectangle.mkSizeCenter(nodeSizes[j], point2);
        const weight = t.overlapFactor > 1 ? length - idealDist : GTreeOverlapRemoval.GetDistanceRects(box1, box2);
        return {
            source: Math.min(i, j),
            target: Math.max(i, j),
            overlapFactor: t.overlapFactor,
            idealDistance: idealDist,
            weight: weight,
        };
    }
    // Returns the ideal edge length, such that the overlap is removed.
    static GetIdealEdgeLength(i, j, point1, point2, nodeBoxes, wrapTRes) {
        const p1p2 = point1.sub(point2);
        const dist = p1p2.length;
        const dx = Math.abs(p1p2.x);
        const dy = Math.abs(p1p2.y);
        const h = (nodeBoxes[i].width + nodeBoxes[j].width) / 2;
        const w = (nodeBoxes[i].height + nodeBoxes[j].height) / 2;
        if (dx >= h || dy >= w) {
            // no overlap
            wrapTRes.overlapFactor = 1;
            return p1p2.length;
        }
        let t;
        const accuracy = 1e-10;
        if (dx > accuracy) {
            if (dy > accuracy) {
                t = Math.min(h / dx, w / dy);
            }
            else {
                t = h / dx;
            }
        }
        else if (dy > accuracy) {
            t = w / dy;
        }
        else {
            // the points almost coincide : this should not happen.
            // Anyway, they will be moved away on some random vector
            wrapTRes.overlapFactor = 2; // important that is greater than 1
            return Math.sqrt(h * h + w * w) / 4;
        }
        /*Assert.assert(t >= 1)*/
        t = Math.max(t, 1.001); // to be  on the safe side
        wrapTRes.overlapFactor = t;
        return t * dist;
    }
    // Returns the distance between two given rectangles or zero if they intersect.
    static GetDistanceRects(a, b) {
        if (a.intersects(b)) {
            return 0;
        }
        let dy = 0;
        let dx = 0;
        if (a.right < b.left) {
            dx = a.left - b.right;
        }
        else if (b.right < a.left) {
            dx = a.left - b.right;
        }
        if (a.top < b.bottom) {
            dy = b.bottom - a.top;
        }
        else if (b.top < a.bottom) {
            dy = a.bottom - b.top;
        }
        const euclid = Math.sqrt(dx * dx + dy * dy);
        return euclid;
    }
    /*
    // Shows the current state of the algorithm for debug purposes.
    ShowAndMoveBoxesRemoveLater(treeEdges: Array<MstEdge>, proximityEdges: Array<MstEdge>, nodeSizes: Size[], nodePos: Point[], rootId: number) {
      let l = new Array<DebugCurve>();
      for (let tuple of proximityEdges) {
        l.Add(new DebugCurve(100, 0.5, "black", new LineSegment(nodePos[tuple.Item1], nodePos[tuple.Item2])));
      }
  
      // just for debug
      let nodeBoxes = new Array(nodeSizes.length);
      for (let i: number = 0; (i < nodePos.length); i++) {
        nodeBoxes[i] = new Rectangle(nodeSizes[i], nodePos[i]);
      }
  
      l.AddRange(nodeBoxes.Select(() => { }, new DebugCurve(100, 0.3, "green", b.Perimeter())));
      if ((treeEdges != null)) {
        l.AddRange(treeEdges.Select(() => { }, new DebugCurve(200, GTreeOverlapRemoval.GetEdgeWidth(e), "red", new LineSegment(nodePos[e.Item1], nodePos[e.Item2]))));
      }
  
      if ((rootId >= 0)) {
        l.Add(new DebugCurve(100, 10, "blue", CurveFactory.CreateOctagon(30, 30, nodePos[rootId])));
      }
  
      LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    }
  
    static GetEdgeWidth(edge: MstEdge): number {
      if ((edge.Item3 > 1)) {
        return 6;
      }
  
      return 2;
    }
  */
    // Lets the tree grow according to the ideal distances.
    static MoveNodePositions(treeEdges, nodePositions, rootNodeId) {
        const posOld = nodePositions.map((p) => p.clone());
        const visited = new Set();
        visited.add(rootNodeId);
        for (let i = 0; i < treeEdges.length; i++) {
            const e = treeEdges[i];
            if (visited.has(e.source)) {
                GTreeOverlapRemoval.MoveNode(e.source, e.target, posOld, nodePositions, visited, e.idealDistance);
            }
            else {
                /*Assert.assert(visited.has(e.target))*/ // hmm, why does this hold?
                GTreeOverlapRemoval.MoveNode(e.target, e.source, posOld, nodePositions, visited, e.idealDistance);
            }
        }
    }
    static MoveNode(standingNode, movingNode, oldPos, newPos, visited, idealDist) {
        let dir = oldPos[movingNode].sub(oldPos[standingNode]);
        dir = dir.mul(idealDist / dir.length + 0.01);
        newPos[movingNode] = newPos[standingNode].add(dir);
        visited.add(movingNode);
    }
    //
    GetLastRunIterations() {
        return this.lastRunNumberIterations;
    }
}
function InitNodePositionsAndBoxes(overlapRemovalSettings, nodes, t, randomizeShift) {
    t.nodePositions = nodes.map((v) => v.center);
    if (randomizeShift)
        randomizePoints(t.nodePositions, new reliable_random__WEBPACK_IMPORTED_MODULE_0__.Random(0, 0), randomizeShift);
    t.nodeSizes = nodes.map((n) => {
        const s = n.boundingBox.size;
        s.width += overlapRemovalSettings.NodeSeparation; // this pad with both sides by overlapRemovalSettings.NodeSeparation/2
        s.height += overlapRemovalSettings.NodeSeparation;
        return s;
    });
}
/** When randomizeAll is true then the points are shifter randomly at the small distance between 0 and epsilon.
 * Otherwise the points are shifted just to avoid the exact repetition.
 */
function randomizePoints(points, random, randomizationShift) {
    const pointSet = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_5__.PointSet();
    for (let i = 0; i < points.length; i++) {
        let p = points[i];
        if (randomizationShift || pointSet.has(p)) {
            do {
                const newX = p.x + (2 * random.random() - 1) * randomizationShift;
                const newY = p.y + (2 * random.random() - 1) * randomizationShift;
                p = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(newX, newY);
            } while (pointSet.has(p));
        }
        points[i] = p;
        pointSet.add(p);
    }
}
//# sourceMappingURL=gTreeOverlapRemoval.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/incremental/fiEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FiEdge: () => (/* binding */ FiEdge)
/* harmony export */ });
/* harmony import */ var _fiNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/fiNode.js");

class FiEdge {
    constructor(mEdge) {
        this._length = 1;
        this.mEdge = mEdge;
        this.sourceFiNode = (0,_fiNode__WEBPACK_IMPORTED_MODULE_0__.getFiNode)(this.mEdge.source);
        this.targetFiNode = (0,_fiNode__WEBPACK_IMPORTED_MODULE_0__.getFiNode)(this.mEdge.target);
    }
    get source() {
        return this.sourceFiNode.index;
    }
    get target() {
        return this.targetFiNode.index;
    }
    get length() {
        return this._length;
    }
    set length(value) {
        this._length = value;
    }
    vector() {
        return this.sourceFiNode.geomNode.center.sub(this.targetFiNode.geomNode.center);
    }
}
//# sourceMappingURL=fiEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/incremental/fiNode.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FiNode: () => (/* binding */ FiNode),
/* harmony export */   getFiNode: () => (/* binding */ getFiNode)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _structs_algorithmData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/algorithmData.js");
//  Wrapper for GeomNode node to add force and velocity vectors


function getFiNode(filNode) {
    const algData = _structs_algorithmData__WEBPACK_IMPORTED_MODULE_1__.AlgorithmData.getAlgData(filNode.node);
    if (algData == null)
        return null;
    return algData.data;
}
class FiNode {
    //  local cache of node center (which in the MSAGL node has to be computed from the bounding box)
    get Center() {
        return this.center;
    }
    set Center(value) {
        this.geomNode.center = value;
        this.center = value;
    }
    //  When mNode's bounds change we need to update our local
    //  previous and current center to MSAGL node center
    //  and update width and height
    ResetBounds() {
        this.previousCenter = this.geomNode.center;
        this.center = this.geomNode.center;
        this.Width = this.geomNode.width;
        this.Height = this.geomNode.height;
    }
    constructor(index, mNode) {
        this.force = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
        this.stayWeight = 1;
        this.index = index;
        this.geomNode = mNode;
        this.ResetBounds();
    }
    //  Update the current X or Y coordinate of the node center from the result of a solve
    ToString() {
        return 'FINode(' + (this.index + ('):' + this.geomNode));
    }
}
//# sourceMappingURL=fiNode.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/incremental/iPsepCola.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IPsepCola: () => (/* binding */ IPsepCola)
/* harmony export */ });
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _fiEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/fiEdge.js");
/* harmony import */ var _fiNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/fiNode.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _core_floatingPort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/floatingPort.js");
/* harmony import */ var _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/algorithmData.js");
/* harmony import */ var _math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/graphAlgorithms/ConnectedComponentCalculator.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/assert.js");
/* harmony import */ var _multipole_kdTree__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/multipole/kdTree.js");
/* harmony import */ var _multipole_multipoleCoefficients__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/multipole/multipoleCoefficients.js");
/* harmony import */ var _core_geomObject__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomObject.js");
/* harmony import */ var _structs_graph__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/graph.js");
/* harmony import */ var _core_geomNode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomNode.js");














/**
  Using a force directed layout strategy with approximate computation of long-range node-node repulsive forces to achieve O(n log n) running time per iteration.
  It can be invoked on an existing layout (for example, as computed by MDS) to beautify it.

*/
class IPsepCola extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__.Algorithm {
    //  Create the graph data structures.
    constructor(geometryGraph, settings, initialConstraintLevel) {
        super(null);
        this.clustersInfo = new Map();
        this.clusterEdges = new Array();
        this.graph = geometryGraph;
        this.settings = settings;
        this.initFiNodesEdges();
        this.edges = Array.from(this.graph.shallowEdges).map((gn) => _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__.AlgorithmData.getAlgData(gn.edge).data);
        this.nodes = Array.from(this.graph.shallowNodes).map((gn) => _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__.AlgorithmData.getAlgData(gn.node).data);
        this.components = new Array();
        if (!this.settings.InterComponentForces) {
            this.basicGraph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__.mkGraphOnEdgesN)(this.edges, this.nodes.length);
            for (const componentNodes of (0,_math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_7__.GetConnectedComponents)(this.basicGraph)) {
                const vs = new Array(componentNodes.length);
                let vi = 0;
                for (const v of componentNodes) {
                    vs[vi++] = this.nodes[v];
                }
                this.components.push(vs);
            }
        }
        else {
            this.components.push(this.nodes);
        }
        this.computeWeight(geometryGraph);
        // if (this.getRB(this.graph) == null) {
        //   this.setRB(this.graph, new RectangularClusterBoundary())
        // }
        this.setCurrentConstraintLevel(initialConstraintLevel);
    }
    initFiNodesEdges() {
        let i = 0;
        for (const gn of this.graph.shallowNodes) {
            const fiNode = new _fiNode__WEBPACK_IMPORTED_MODULE_3__.FiNode(i++, gn);
            new _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__.AlgorithmData(gn.node, fiNode); //this will bind the new fiNode with the underlying Node
        }
        for (const e of this.graph.shallowEdges) {
            // if (e.source instanceof GeomGraph || e.target instanceof GeomGraph) {
            // continue
            //} else {
            const fiEdge = new _fiEdge__WEBPACK_IMPORTED_MODULE_2__.FiEdge(e);
            new _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__.AlgorithmData(e.edge, fiEdge);
            //}
        }
    }
    //  Controls which constraints are applied of CalculateLayout.  Setter enforces feasibility at that level.
    getCurrentConstraintLevel() {
        return this.currentConstraintLevel;
    }
    setCurrentConstraintLevel(value) {
        this.currentConstraintLevel = value;
        this.settings.Unconverge();
    }
    //  Add constraint to constraints lists.  Warning, no check that dictionary alread holds a list for the level.
    //  Make sure you call AddConstraintLevel first (perf).
    //  Check for constraint level of dictionary, if it doesn't exist add the list at that level.
    ResetNodePositions() {
        for (const v of this.nodes) {
            v.ResetBounds();
        }
    }
    AddRepulsiveForce(v, repulsion) {
        //  scale repulsion
        v.force = repulsion.mul(10 * this.settings.RepulsiveForceConstant);
    }
    AddLogSpringForces(e, duv, d) {
        const l = duv.length;
        const f = 0.0007 * this.settings.AttractiveForceConstant * l * Math.log((l + 0.1) / (d + 0.1));
        e.sourceFiNode.force = e.sourceFiNode.force.add(duv.mul(f));
        e.targetFiNode.force = e.targetFiNode.force.sub(duv.mul(f));
    }
    AddSquaredSpringForces(e, duv, d) {
        /*
      double l = duv.Length,
                       d2 = d*d + 0.1,
                       f = settings.AttractiveForceConstant*(l - d)/d2;
                e.source.force += f*duv;
                e.target.force -= f*duv;
                */
        const l = duv.length;
        const d2 = d * d + 0.1;
        const f = (this.settings.AttractiveForceConstant * (l - d)) / d2;
        e.sourceFiNode.force = e.sourceFiNode.force.add(duv.mul(f));
        e.targetFiNode.force = e.targetFiNode.force.sub(duv.mul(f));
    }
    AddSpringForces(e) {
        let duv;
        if (this.settings.RespectEdgePorts) {
            let sourceLocation = e.sourceFiNode.Center;
            let targetLocation = e.targetFiNode.Center;
            const sourcePort = e.mEdge.sourcePort;
            if (sourcePort instanceof _core_floatingPort__WEBPACK_IMPORTED_MODULE_5__.FloatingPort) {
                sourceLocation = sourcePort.Location;
            }
            const targetPort = e.mEdge.targetPort;
            if (targetPort instanceof _core_floatingPort__WEBPACK_IMPORTED_MODULE_5__.FloatingPort) {
                targetLocation = targetPort.Location;
            }
            duv = sourceLocation.sub(targetLocation);
        }
        else {
            duv = e.vector();
        }
        if (this.settings.LogScaleEdgeForces) {
            this.AddLogSpringForces(e, duv, e.length);
        }
        else {
            this.AddSquaredSpringForces(e, duv, e.length);
        }
    }
    static AddGravityForce(origin, gravity, v) {
        if (v == null)
            return;
        //  compute and add gravity  v.force -= 0.0001*gravity*(origin - v.Center);
        v.force = v.force.sub(origin.sub(v.Center).mul(gravity * 0.0001));
    }
    ComputeRepulsiveForces(vs) {
        const n = vs.length;
        if (n > 16 && this.settings.ApproximateRepulsion) {
            const ps = new Array(vs.length);
            //  before calculating forces we perturb each center by a small vector of a unique
            //  but deterministic direction (by walking around a circle of n steps) - this allows
            //  the KD-tree to decompose even when some nodes are at exactly the same position
            const angleDelta = 2 * (Math.PI / n);
            let angle = 0;
            for (let i = 0; i < n; i++) {
                ps[i] = new _multipole_kdTree__WEBPACK_IMPORTED_MODULE_9__.Particle(vs[i].Center.add(new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Point(Math.cos(angle), Math.sin(angle)).mul(1e-5)));
                angle += angleDelta;
            }
            const kdTree = new _multipole_kdTree__WEBPACK_IMPORTED_MODULE_9__.KDTree(ps, 8);
            kdTree.ComputeForces(5);
            for (let i = 0; i < vs.length; i++) {
                this.AddRepulsiveForce(vs[i], ps[i].force);
            }
        }
        else {
            for (const u of vs) {
                let fu = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0);
                for (const v of vs) {
                    if (u != v) {
                        fu = fu.add(_multipole_multipoleCoefficients__WEBPACK_IMPORTED_MODULE_10__.MultipoleCoefficients.Force(u.Center, v.Center));
                    }
                }
                this.AddRepulsiveForce(u, fu);
            }
        }
    }
    SetBarycenter(root) {
        const w = this.clustersInfo.get(root);
        if (w != undefined)
            return w.barycenter;
        let center = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0);
        //  If these are empty then Weight is 0 and barycenter becomes NaN.
        //  If there are no child clusters with nodes, then Weight stays 0.
        if (root.shallowNodeCount || hasSomeClusters(root)) {
            const clusterInfo = this.clustersInfo.get(root);
            if (clusterInfo == undefined || clusterInfo.weight == undefined) {
                this.computeWeight(root);
            }
            if (clusterInfo.weight != null) {
                for (const v of root.shallowNodes) {
                    if (v instanceof _core_geomNode__WEBPACK_IMPORTED_MODULE_13__.GeomNode) {
                        center = center.add(v.center);
                    }
                    else {
                        center = center.add(this.SetBarycenter(v).mul(this.clustersInfo.get(v).weight));
                    }
                }
                this.clustersInfo.get(root).barycenter = center = center.div(clusterInfo.weight);
            }
        }
        else {
            this.clustersInfo.get(root).barycenter = center;
        }
        return center;
    }
    computeWeight(root) {
        let w = 0;
        for (const n of root.shallowNodes) {
            if (n.entity instanceof _structs_graph__WEBPACK_IMPORTED_MODULE_12__.Graph) {
                w += this.computeWeight(n);
            }
            else {
                w++;
            }
        }
        let info = this.clustersInfo.get(root);
        if (info == null) {
            this.clustersInfo.set(root, (info = { barycenter: new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0) }));
        }
        info.weight = w;
        return w;
    }
    AddClusterForces(root) {
        if (root == null) {
            return;
        }
        //  SetBarycenter is recursive.
        this.SetBarycenter(root);
        //  The cluster edges draw the barycenters of the connected clusters together
        for (const e of this.clusterEdges) {
            //  foreach cluster keep a force vector.  Replace ForEachNode calls below with a simple
            //  addition to this force vector.  Traverse top down, tallying up force vectors of children
            //  to be the sum of their parents.
            const gn1 = _core_geomObject__WEBPACK_IMPORTED_MODULE_11__.GeomObject.getGeom(e.source);
            const gn2 = _core_geomObject__WEBPACK_IMPORTED_MODULE_11__.GeomObject.getGeom(e.target);
            const n1 = _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__.AlgorithmData.getAlgData(e.source).data;
            const n2 = _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__.AlgorithmData.getAlgData(e.target).data;
            const c1_is_cluster = gn1.hasOwnProperty('shallowNodes');
            const center1 = c1_is_cluster ? this.clustersInfo.get(gn1).barycenter : gn1.center;
            const c2_is_cluster = gn2.hasOwnProperty('shallowNodes');
            const center2 = c2_is_cluster ? this.clustersInfo.get(gn2).barycenter : gn2.center;
            let duv = center1.sub(center2);
            const l = duv.length;
            const f = 1e-8 * (this.settings.AttractiveInterClusterForceConstant * (l * Math.log(l + 0.1)));
            duv = duv.mul(f);
            if (c1_is_cluster) {
                const ig = gn1;
                for (const v of ig.shallowNodes) {
                    const fv = _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__.AlgorithmData.getAlgData(v.node).data;
                    fv.force = fv.force.add(duv);
                }
            }
            else {
                n1.force = n1.force.add(duv);
            }
            if (c2_is_cluster) {
                const ig = gn2;
                for (const v of ig.shallowNodes) {
                    const fv = _structs_algorithmData__WEBPACK_IMPORTED_MODULE_6__.AlgorithmData.getAlgData(v.node).data;
                    fv.force = fv.force.sub(duv);
                }
            }
            else {
                n2.force = n2.force.sub(duv);
            }
        }
        for (const c of root.subgraphsDepthFirst) {
            const cCenter = this.clustersInfo.get(c).barycenter;
            for (const v of c.shallowNodes) {
                IPsepCola.AddGravityForce(cCenter, this.settings.ClusterGravity, (0,_fiNode__WEBPACK_IMPORTED_MODULE_3__.getFiNode)(v));
            }
        }
    }
    //  Aggregate all the forces affecting each node
    ComputeForces() {
        if (this.components != null) {
            for (const c of this.components)
                this.ComputeRepulsiveForces(c);
        }
        else {
            this.ComputeRepulsiveForces(this.nodes);
        }
        this.edges.forEach((e) => this.AddSpringForces(e));
        for (const c of this.components) {
            let origin = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0);
            for (let i = 0; i < c.length; i++) {
                origin = origin.add(c[i].Center);
            }
            origin = origin.div(c.length);
            let maxForce = Number.NEGATIVE_INFINITY;
            for (let i = 0; i < c.length; i++) {
                const v = c[i];
                IPsepCola.AddGravityForce(origin, this.settings.GravityConstant, v);
                if (v.force.length > maxForce) {
                    maxForce = v.force.length;
                }
            }
            if (maxForce > 100) {
                for (let i = 0; i < c.length; i++) {
                    c[i].force = c[i].force.mul(100 / maxForce);
                }
            }
        }
        //  This is the only place where ComputeForces (and hence verletIntegration) considers clusters.
        //  It's just adding a "gravity" force on nodes inside each cluster towards the barycenter of the cluster.
        this.AddClusterForces(this.graph);
    }
    //  Checks if solvers need to be applied, i.e. if there are user constraints or
    //  generated constraints (such as non-overlap) that need satisfying
    //  Force directed layout is basically an iterative approach to solving a bunch of differential equations.
    //  Different integration schemes are possible for applying the forces iteratively.  Euler is the simplest:
    //   v_(i+1) = v_i + a dt
    //   x_(i+1) = x_i + v_(i+1) dt
    //
    //  Verlet is much more stable (and not really much more complicated):
    //   x_(i+1) = x_i + (x_i - x_(i-1)) + a dt dt
    VerletIntegration() {
        //  The following sets the Centers of all nodes to a (not necessarily feasible) configuration that reduces the cost (forces)
        const energy0 = this.energy;
        this.energy = this.ComputeDescentDirection(1);
        this.UpdateStepSize(energy0);
        let displacementSquared = 0;
        for (let i = 0; i < this.nodes.length; i++) {
            const v = this.nodes[i];
            displacementSquared += v.Center.sub(v.previousCenter).lengthSquared;
        }
        return displacementSquared;
    }
    ComputeDescentDirection(alpha) {
        this.ResetForceVectors();
        //  velocity is the distance travelled last time step
        if (this.settings.ApplyForces) {
            this.ComputeForces();
        }
        let lEnergy = 0;
        for (const v of this.nodes) {
            lEnergy = lEnergy + v.force.lengthSquared;
            let dx = v.Center.sub(v.previousCenter).mul(this.settings.Friction);
            const a = v.force.mul(-this.stepSize * alpha);
            v.previousCenter = v.Center;
            _utils_assert__WEBPACK_IMPORTED_MODULE_8__.Assert.assert(!Number.isNaN(a.x), '!double.IsNaN(a.X)');
            _utils_assert__WEBPACK_IMPORTED_MODULE_8__.Assert.assert(!Number.isNaN(a.y), '!double.IsNaN(a.Y)');
            _utils_assert__WEBPACK_IMPORTED_MODULE_8__.Assert.assert(Number.isFinite(a.x), '!double.IsInfinity(a.X)');
            _utils_assert__WEBPACK_IMPORTED_MODULE_8__.Assert.assert(Number.isFinite(a.y), '!double.IsInfinity(a.Y)');
            dx = dx.add(a);
            dx = dx.div(v.stayWeight);
            v.Center = v.Center.add(dx);
        }
        return lEnergy;
    }
    ResetForceVectors() {
        for (const v of this.nodes) {
            v.force = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0);
        }
    }
    //  Adapt StepSize based on change of energy.
    //  Five sequential improvements of energy mean we increase the stepsize.
    //  Any increase of energy means we reduce the stepsize.
    UpdateStepSize(energy0) {
        if (this.energy < energy0) {
            if (++this.progress >= 3) {
                this.progress = 0;
                this.stepSize /= this.settings.Decay;
            }
        }
        else {
            this.progress = 0;
            this.stepSize *= this.settings.Decay;
        }
    }
    RungeKuttaIntegration() {
        const y0 = new Array(this.nodes.length);
        const k1 = new Array(this.nodes.length);
        const k2 = new Array(this.nodes.length);
        const k3 = new Array(this.nodes.length);
        const k4 = new Array(this.nodes.length);
        const energy0 = this.energy;
        for (let i = 0; i < this.nodes.length; i++) {
            this.nodes[i].previousCenter = this.nodes[i].Center;
            y0[i] = this.nodes[i].Center;
        }
        const alpha = 3;
        this.ComputeDescentDirection(alpha);
        for (let i = 0; i < this.nodes.length; i++) {
            k1[i] = this.nodes[i].Center.sub(this.nodes[i].previousCenter);
            this.nodes[i].Center = y0[i].add(k1[i].mul(0.5));
        }
        this.ComputeDescentDirection(alpha);
        for (let i = 0; i < this.nodes.length; i++) {
            k2[i] = this.nodes[i].Center.sub(this.nodes[i].previousCenter);
            this.nodes[i].previousCenter = y0[i];
            this.nodes[i].Center = y0[i].add(k2[i].mul(0.5));
        }
        this.ComputeDescentDirection(alpha);
        for (let i = 0; i < this.nodes.length; i++) {
            k3[i] = this.nodes[i].Center.sub(this.nodes[i].previousCenter);
            this.nodes[i].previousCenter = y0[i];
            this.nodes[i].Center = y0[i].add(k3[i]);
        }
        this.energy = this.ComputeDescentDirection(alpha);
        for (let i = 0; i < this.nodes.length; i++) {
            k4[i] = this.nodes[i].Center.sub(this.nodes[i].previousCenter);
            this.nodes[i].previousCenter = y0[i];
            /* (k1[i] + 2.0*k2[i] + 2.0*k3[i] + k4[i])/6.0;*/
            const dx = k1[i].add(k2[i].mul(2).add(k3[i].mul(2)).add(k4[i])).div(6);
            this.nodes[i].Center = y0[i].add(dx);
        }
        this.UpdateStepSize(energy0);
        return this.nodes.reduce((prevSum, v) => v.Center.sub(v.previousCenter).lengthSquared + prevSum, 0);
    }
    //  Apply a small number of iterations of the layout.
    //  The idea of incremental layout is that settings.minorIterations should be a small number (e.g. 3) and
    //  CalculateLayout should be invoked of a loop, e.g.:
    //
    //  while(settings.RemainingIterations > 0) {
    //     fastIncrementalLayout.CalculateLayout();
    //     InvokeYourProcedureToRedrawTheGraphOrHandleInteractionEtc();
    //  }
    //
    //  In the verletIntegration step above, the RemainingIterations is used to control damping.
    run() {
        this.settings.Converged = false;
        this.settings.EdgeRoutesUpToDate = false;
        if (this.settings.Iterations++ == 0) {
            this.stepSize = this.settings.InitialStepSize;
            this.energy = Number.MAX_VALUE;
            this.progress = 0;
        }
        //this.StartListenToLocalProgress(this.settings.MinorIterations);
        for (let i = 0; i < this.settings.MinorIterations; i++) {
            const d2 = this.settings.RungeKuttaIntegration ? this.RungeKuttaIntegration() : this.VerletIntegration();
            if (d2 < this.settings.DisplacementThreshold || this.settings.Iterations > this.settings.MaxIterations) {
                this.settings.Converged = true;
                //      this.ProgressComplete();
                break;
            }
            this.ProgressStep();
        }
    }
}
function hasSomeClusters(g) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const _ of g.Clusters) {
        return true;
    }
    return false;
}
//# sourceMappingURL=iPsepCola.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/incremental/iPsepColaSettings.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IPsepColaSetting: () => (/* binding */ IPsepColaSetting)
/* harmony export */ });
/* harmony import */ var _commonLayoutSettings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/commonLayoutSettings.js");
/* harmony import */ var _iPsepCola__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/iPsepCola.js");


class IPsepColaSetting {
    get edgeRoutingSettings() {
        return this.commonSettings.edgeRoutingSettings;
    }
    set edgeRoutingSettings(value) {
        this.commonSettings.edgeRoutingSettings = value;
    }
    get PackingAspectRatio() {
        return this.commonSettings.PackingAspectRatio;
    }
    set PackingAspectRatio(value) {
        this.commonSettings.PackingAspectRatio = value;
    }
    get NodeSeparation() {
        return this.commonSettings.NodeSeparation;
    }
    set NodeSeparation(value) {
        this.commonSettings.NodeSeparation = value;
    }
    //  Stop after maxIterations completed
    get MaxIterations() {
        return this.maxIterations;
    }
    set MaxIterations(value) {
        this.maxIterations = value;
    }
    //  Number of iterations in inner loop.
    get MinorIterations() {
        return this.minorIterations;
    }
    set MinorIterations(value) {
        this.minorIterations = value;
    }
    //  Number of iterations completed
    get Iterations() {
        return this.iterations;
    }
    set Iterations(value) {
        this.iterations = value;
    }
    //  number of times to project over all constraints at each layout iteration
    get ProjectionIterations() {
        return this.projectionIterations;
    }
    set ProjectionIterations(value) {
        this.projectionIterations = value;
    }
    //  Rather than computing the exact repulsive force between all pairs of nodes (which would take O(n^2) time for n nodes)
    //  use a fast inexact technique (that takes O(n log n) time)
    get ApproximateRepulsion() {
        return this.approximateRepulsion;
    }
    set ApproximateRepulsion(value) {
        this.approximateRepulsion = value;
    }
    //  StepSize taken at each iteration (a coefficient of the force on each node) adapts depending on change in
    //  potential energy at each step.  With this scheme changing the InitialStepSize doesn't have much effect
    //  because if it is too large or too small it will be quickly updated by the algorithm anyway.
    get InitialStepSize() {
        return this.initialStepSize;
    }
    set InitialStepSize(value) {
        if (value <= 0 || value > 2) {
            throw new Error('ForceScalar should be greater than 0 and less than 2 (if we let you set it to 0 nothing would happen, greater than 2 would most likely be very unstable!)');
        }
        this.initialStepSize = value;
    }
    //  FrictionalDecay isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
    get Decay() {
        return this.decay;
    }
    set Decay(value) {
        if (value < 0.1 || value > 1) {
            throw new Error('Setting decay too small gives no progress.  1==no decay, 0.1==minimum allowed value');
        }
        this.decay = value;
    }
    //  Friction isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
    get Friction() {
        return this.friction;
    }
    set Friction(value) {
        if (value < 0 || value > 1) {
            throw new Error('Setting friction less than 0 or greater than 1 would just be strange.  1==no friction, 0==no conservation of velocity');
        }
        this.friction = value;
    }
    //  strength of repulsive force between each pair of nodes.  A setting of 1.0 should work OK.
    get RepulsiveForceConstant() {
        return this.repulsiveForceConstant;
    }
    set RepulsiveForceConstant(value) {
        this.repulsiveForceConstant = value;
    }
    //  strength of attractive force between pairs of nodes joined by an edge.  A setting of 1.0 should work OK.
    get AttractiveForceConstant() {
        return this.attractiveForceConstant;
    }
    set AttractiveForceConstant(value) {
        this.attractiveForceConstant = value;
    }
    //  gravity is a constant force applied to all nodes attracting them to the Origin
    //  and keeping disconnected components from flying apart.  A setting of 1.0 should work OK.
    get GravityConstant() {
        return this.gravity;
    }
    set GravityConstant(value) {
        this.gravity = value;
    }
    //  If the following is false forces will not be considered between each component and each component will have its own gravity origin.
    get InterComponentForces() {
        return this.interComponentForces;
    }
    set InterComponentForces(value) {
        this.interComponentForces = value;
    }
    //  If the following is false forces will not be applied, but constraints will still be satisfied.
    get ApplyForces() {
        return this.applyForces;
    }
    set ApplyForces(value) {
        this.applyForces = value;
    }
    constructor() {
        this.commonSettings = new _commonLayoutSettings__WEBPACK_IMPORTED_MODULE_0__.CommonLayoutSettings();
        //  Stop after maxIterations completed
        this.maxIterations = 100;
        this.clusterMargin = 10;
        this.minorIterations = 3;
        this.projectionIterations = 5;
        this.approximateRepulsion = true;
        //  RungaKutta integration potentially gives smoother increments, but is more expensive
        this.RungeKuttaIntegration = false;
        this.initialStepSize = 1.4;
        this.decay = 0.9;
        this.friction = 0.8;
        this.repulsiveForceConstant = 1;
        this.attractiveForceConstant = 1;
        this.gravity = 1;
        this.interComponentForces = true;
        this.applyForces = true;
        //  Avoid overlaps between nodes boundaries, and if there are any
        //  clusters, then between each cluster boundary and nodes that are not
        //  part of that cluster.
        this.AvoidOverlaps = true;
        this.approximateRouting = true;
        this.logScaleEdgeForces = true;
        this.displacementThreshold = 0.1;
        this.maxConstraintLevel = 2;
        this.minConstraintLevel = 0;
        this.attractiveInterClusterForceConstant = 1;
        this.clusterGravity = 1;
        this.commonSettings.NodeSeparation *= 2;
    }
    //  restart layout, use e.g. after a mouse drag or non-structural change to the graph
    ResetLayout() {
        this.Unconverge();
        if (this.algorithm != null) {
            this.algorithm.ResetNodePositions();
        }
    }
    /**   reset iterations and convergence status*/
    Unconverge() {
        this.iterations = 0;
        this.converged = false;
    }
    InitializeLayoutGN(graph, initialConstraintLevel) {
        this.InitializeLayout(graph, initialConstraintLevel);
    }
    //  Initialize the layout algorithm
    InitializeLayout(graph, initialConstraintLevel) {
        this.algorithm = new _iPsepCola__WEBPACK_IMPORTED_MODULE_1__.IPsepCola(graph, this, initialConstraintLevel);
        this.ResetLayout();
    }
    //
    Uninitialize() {
        this.algorithm = null;
    }
    //
    get IsInitialized() {
        return this.algorithm != null;
    }
    //
    IncrementalRunG(graph) {
        this.IncrementalRunGF(graph);
    }
    SetupIncrementalRun(graph) {
        if (!this.IsInitialized) {
            this.InitializeLayout(graph, this.MaxConstraintLevel);
        }
        else if (this.IsDone) {
            //  If we were already done from last time but we are doing more work then something has changed.
            this.ResetLayout();
        }
    }
    //  Run the FastIncrementalLayout instance incrementally
    IncrementalRunGF(graph) {
        this.SetupIncrementalRun(graph);
        this.algorithm.run();
        // graph.UpdateBoundingBox()
    }
    //
    IncrementalRun(cancelToken, graph) {
        if (cancelToken != null) {
            cancelToken.throwIfCanceled();
        }
        this.SetupIncrementalRun(graph);
        this.algorithm.cancelToken = cancelToken;
        this.algorithm.run();
        // graph.UpdateBoundingBox()
    }
    Clone() {
        return IPsepColaSetting.ctorClone(this);
    }
    //  If RouteEdges is true then the following is checked to see whether to do optimal shortest path routing
    //  or use a sparse visibility graph spanner to do approximate---but much faster---shortest path routing
    get ApproximateRouting() {
        return this.approximateRouting;
    }
    set ApproximateRouting(value) {
        this.approximateRouting = value;
    }
    //  If true then attractive forces across edges are computed as:
    //  AttractiveForceConstant * actualLength * Math.Log((actualLength + epsilon) / (idealLength + epsilon))
    //  where epsilon is a small positive constant to avoid divide by zero or taking the log of zero.
    //  Note that LogScaleEdges can lead to ghost forces in highly constrained scenarios.
    //  If false then a the edge force is based on (actualLength - idealLength)^2, which works better with
    //  lots of constraints.
    get LogScaleEdgeForces() {
        return this.logScaleEdgeForces;
    }
    set LogScaleEdgeForces(value) {
        this.logScaleEdgeForces = value;
    }
    //  If the amount of total squared displacement after a particular iteration falls below DisplacementThreshold then Converged is set to true.
    //  Make DisplacementThreshold larger if you want layout to finish sooner - but not necessarily make as much progress towards a good layout.
    get DisplacementThreshold() {
        return this.displacementThreshold;
    }
    set DisplacementThreshold(value) {
        this.displacementThreshold = value;
    }
    //  Set to true if displacement from the last iteration was less than DisplacementThreshold.
    //  The caller should invoke FastIncrementalLayout.CalculateLayout() in a loop, e.g.:
    //
    //   while(!settings.Converged)
    //   {
    //     layout.CalculateLayout();
    //     redrawGraphOrHandleInteractionOrWhatever();
    //   }
    //
    //  RemainingIterations affects damping.
    get Converged() {
        return this.converged;
    }
    set Converged(value) {
        this.converged = value;
    }
    //  Return iterations as a percentage of MaxIterations.  Useful for reporting progress, e.g. in a progress bar.
    get PercentDone() {
        if (this.Converged) {
            return 100;
        }
        else {
            return ((100 * this.iterations) / this.MaxIterations);
        }
    }
    //  Not quite the same as Converged:
    get IsDone() {
        return this.Converged || this.iterations >= this.MaxIterations;
    }
    //  Returns an estimate of the cost function calculated in the most recent iteration.
    //  It's a float because FastIncrementalLayout.Energy is a volatile float so it
    //  can be safely read from other threads
    get Energy() {
        if (this.algorithm != null) {
            return this.algorithm.energy;
        }
        return 0;
    }
    //
    get MaxConstraintLevel() {
        return this.maxConstraintLevel;
    }
    set MaxConstraintLevel(value) {
        if (this.maxConstraintLevel != value) {
            this.maxConstraintLevel = value;
            if (this.IsInitialized) {
                this.Uninitialize();
            }
        }
    }
    //
    get MinConstraintLevel() {
        return this.minConstraintLevel;
    }
    set MinConstraintLevel(value) {
        this.minConstraintLevel = value;
    }
    //  Constraint level ranges from Min to MaxConstraintLevel.
    //  0 = no constraints
    //  1 = only structural constraints
    //  2 = all constraints including non-overlap constraints
    //
    //  A typical run of FastIncrementalLayout will apply it at each constraint level, starting at 0 to
    //  obtain an untangled unconstrained layout, then 1 to introduce structural constraints and finally 2 to beautify.
    //  Running only at level 2 will most likely leave the graph stuck in a tangled local minimum.
    getCurrentConstraintLevel() {
        if (this.algorithm == null) {
            return 0;
        }
        return this.algorithm.getCurrentConstraintLevel();
    }
    setCurrentConstraintLevel(value) {
        this.algorithm.setCurrentConstraintLevel(value);
    }
    //  Attractive strength of edges connected to clusters
    get AttractiveInterClusterForceConstant() {
        return this.attractiveInterClusterForceConstant;
    }
    set AttractiveInterClusterForceConstant(value) {
        this.attractiveInterClusterForceConstant = value;
    }
    //  Shallow copy the settings
    static ctorClone(previousSettings) {
        const ret = new IPsepColaSetting();
        ret.maxIterations = previousSettings.maxIterations;
        ret.minorIterations = previousSettings.minorIterations;
        ret.projectionIterations = previousSettings.projectionIterations;
        ret.approximateRepulsion = previousSettings.approximateRepulsion;
        ret.initialStepSize = previousSettings.initialStepSize;
        ret.RungeKuttaIntegration = previousSettings.RungeKuttaIntegration;
        ret.decay = previousSettings.decay;
        ret.friction = previousSettings.friction;
        ret.repulsiveForceConstant = previousSettings.repulsiveForceConstant;
        ret.attractiveForceConstant = previousSettings.attractiveForceConstant;
        ret.gravity = previousSettings.gravity;
        ret.interComponentForces = previousSettings.interComponentForces;
        ret.applyForces = previousSettings.applyForces;
        ret.AvoidOverlaps = previousSettings.AvoidOverlaps;
        ret.RespectEdgePorts = previousSettings.RespectEdgePorts;
        ret.RouteEdges = previousSettings.RouteEdges;
        ret.approximateRouting = previousSettings.approximateRouting;
        ret.logScaleEdgeForces = previousSettings.logScaleEdgeForces;
        ret.displacementThreshold = previousSettings.displacementThreshold;
        ret.minConstraintLevel = previousSettings.minConstraintLevel;
        ret.maxConstraintLevel = previousSettings.maxConstraintLevel;
        ret.attractiveInterClusterForceConstant = previousSettings.attractiveInterClusterForceConstant;
        ret.clusterGravity = previousSettings.clusterGravity;
        ret.PackingAspectRatio = previousSettings.PackingAspectRatio;
        ret.NodeSeparation = previousSettings.NodeSeparation;
        ret.clusterMargin = previousSettings.clusterMargin;
        return ret;
    }
    //  Controls how tightly members of clusters are pulled together
    get ClusterGravity() {
        return this.clusterGravity;
    }
    set ClusterGravity(value) {
        this.clusterGravity = value;
    }
    //      creates the settings that seems working
    //  <returns></returns>
    static CreateFastIncrementalLayoutSettings() {
        const f = new IPsepColaSetting();
        f.ApplyForces = false;
        f.ApproximateRepulsion = true;
        f.ApproximateRouting = true;
        f.AttractiveForceConstant = 1.0;
        f.AttractiveInterClusterForceConstant = 1.0;
        f.AvoidOverlaps = true;
        f.ClusterGravity = 1.0;
        f.Decay = 0.9;
        f.DisplacementThreshold = 0.00000005;
        f.Friction = 0.8;
        f.GravityConstant = 1.0;
        f.InitialStepSize = 2.0;
        f.InterComponentForces = false;
        f.Iterations = 0;
        f.LogScaleEdgeForces = false;
        f.MaxConstraintLevel = 2;
        f.MaxIterations = 20;
        f.MinConstraintLevel = 0;
        f.MinorIterations = 1;
        f.ProjectionIterations = 5;
        f.RepulsiveForceConstant = 2.0;
        f.RespectEdgePorts = false;
        f.RouteEdges = false;
        f.RungeKuttaIntegration = true;
        f.NodeSeparation = 20;
        return f;
    }
}
//# sourceMappingURL=iPsepColaSettings.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/incremental/multipole/disc.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Disc: () => (/* binding */ Disc)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/assert.js");


class Disc {
    /**   disc centre*/
    get Center() {
        return this.c;
    }
    /**   Radius of disc */
    get Radius() {
        return this.r;
    }
    //  squared distance from the centre of this disc to point
    //  <returns></returns>
    Distance2(point) {
        const dy = this.c.y - point.y;
        const dx = this.c.x - point.x;
        return dx * dx + dy * dy;
    }
    //  Test if point is contained in this disc
    //  <returns></returns>
    Contains(point) {
        return this.Distance2(point) - 1e-7 <= this.r2;
    }
    //  test if all specified points (apart from the except list) are contained in this disc
    //  <returns>true if all points are contained in the disc</returns>
    ContainsPN(points, except) {
        for (let i = 0; i < points.length; i++) {
            if (except.findIndex((j) => j == i) == -1 && !this.Contains(points[i])) {
                return false;
            }
        }
        return true;
    }
    //  create a zero radius disc centred at center
    static constructorP(center) {
        const r = new Disc();
        r.c = center;
        r.r = 0;
        r.r2 = 0;
        return r;
    }
    //  find the point mid-way between two points
    static midPoint(startPoint, endPoint) {
        return new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point((endPoint.x + startPoint.x) / 2, (endPoint.y + startPoint.y) / 2);
    }
    //  Create the smallest possible disc with the specified points on the boundary
    static constructorPP(firstBoundaryPoint, secondBoundaryPoint) {
        const d = new Disc();
        d.c = Disc.midPoint(firstBoundaryPoint, secondBoundaryPoint);
        d.r2 = d.Distance2(firstBoundaryPoint);
        d.r = Math.sqrt(d.r2);
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(d.OnBoundary(firstBoundaryPoint));
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(d.OnBoundary(secondBoundaryPoint));
        return d;
    }
    //  test if a point lies on (within a small delta of) the boundary of this disc
    //  <returns></returns>
    OnBoundary(point) {
        const d = this.Distance2(point);
        return Math.abs(d - this.r2) / (d + this.r2) < 1e-5;
    }
    //  computes the centre of the disc with the 3 specified points on the boundary
    //  <returns></returns>
    static centre(p1, p2, p3) {
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(p2.x != p1.x);
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(p3.x != p2.x);
        const ma = (p2.y - p1.y) / (p2.x - p1.x);
        const mb = (p3.y - p2.y) / (p3.x - p2.x);
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(mb != ma);
        //  collinear points not allowed
        let y;
        const x = (ma * mb * (p1.y - p3.y) + mb * (p1.x + p2.x) - ma * (p2.x + p3.x)) / (2 * (mb - ma));
        if (Math.abs(ma) > Math.abs(mb)) {
            y = (p1.y + p2.y) / 2 - (x - (p1.x + p2.x) / 2) / ma;
        }
        else {
            y = (p2.y + p3.y) / 2 - (x - (p2.x + p3.x) / 2) / mb;
        }
        return new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);
    }
    //  if the area of the triangle formed by the 3 points is 0 then the points are collinear
    //  <returns></returns>
    static Collinear(p1, p2, p3) {
        return p1.x * (p2.y - p3.y) + (p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) == 0;
    }
    //  Create a disc with the specified points on the boundary
    static constructorPPP(p1, p2, p3) {
        Disc.count++;
        const d = new Disc();
        if (Disc.Collinear(p1, p2, p3)) {
            const LL = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(Math.min(p1.x, Math.min(p2.x, p3.x)), Math.min(p1.y, Math.max(p2.y, p3.y)));
            const UR = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(Math.max(p1.x, Math.max(p2.x, p3.x)), Math.max(p1.y, Math.max(p2.y, p3.y)));
            d.c = Disc.midPoint(LL, UR);
            d.r2 = d.Distance2(UR);
            d.r = Math.sqrt(d.r2);
        }
        else {
            const dx12 = p2.x - p1.x;
            const dx23 = p3.x - p2.x;
            const dx13 = p3.x - p1.x;
            if (dx12 != 0) {
                if (dx23 != 0) {
                    d.c = Disc.centre(p1, p2, p3);
                }
                else {
                    _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(dx13 != 0);
                    d.c = Disc.centre(p2, p1, p3);
                }
            }
            else {
                _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(dx23 != 0);
                //  because points are not collinear
                d.c = Disc.centre(p2, p3, p1);
            }
            d.r2 = d.Distance2(p1);
            d.r = Math.sqrt(d.r2);
            _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(d.OnBoundary(p1));
            _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(d.OnBoundary(p2));
            _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(d.OnBoundary(p3));
        }
        return d;
    }
}
Disc.count = 0;
//# sourceMappingURL=disc.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/incremental/multipole/kdTree.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KDTree: () => (/* binding */ KDTree),
/* harmony export */   Particle: () => (/* binding */ Particle)
/* harmony export */ });
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _minimumEnclosingDisc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/multipole/minimumEnclosingDisc.js");
/* harmony import */ var _multipoleCoefficients__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/multipole/multipoleCoefficients.js");




var Dim;
(function (Dim) {
    Dim[Dim["Horizontal"] = 0] = "Horizontal";
    Dim[Dim["Vertical"] = 1] = "Vertical";
})(Dim || (Dim = {}));
class KdNode {
    intersects(v) {
        const d = v.med.Center.sub(this.med.Center);
        const l = d.length;
        return l < v.med.Radius + this.med.Radius;
    }
}
class InternalKdNode extends KdNode {
    constructor(med, left, right) {
        super();
        this.med = med;
        this.parent = left.parent;
        if (this.parent != null) {
            if (this.parent.leftChild == left) {
                this.parent.leftChild = this;
            }
            else {
                //Assert.assert(this.parent.rightChild == left)
                this.parent.rightChild = this;
            }
        }
        this.leftChild = left;
        this.rightChild = right;
        left.parent = this;
        right.parent = this;
    }
    computeMultipoleCoefficients(precision) {
        this.leftChild.computeMultipoleCoefficients(precision);
        this.rightChild.computeMultipoleCoefficients(precision);
        this.multipoleCoefficients = _multipoleCoefficients__WEBPACK_IMPORTED_MODULE_3__.MultipoleCoefficients.constructorPMM(this.med.Center, this.leftChild.multipoleCoefficients, this.rightChild.multipoleCoefficients);
    }
}
class LeafKdNode extends KdNode {
    constructor(particles) {
        super();
        //Assert.assert(particles[0].length == particles[1].length)
        this.particles = particles;
        this.ComputeMinimumEnclosingDisc();
    }
    computeMultipoleCoefficients(precision) {
        this.multipoleCoefficients = _multipoleCoefficients__WEBPACK_IMPORTED_MODULE_3__.MultipoleCoefficients.constructorNPA(precision, this.med.Center, this.ps);
    }
    ComputeMinimumEnclosingDisc() {
        const n = this.Size();
        this.ps = new Array(n);
        for (let i = 0; i < n; i++) {
            this.ps[i] = this.particles[0][i].point;
        }
        return (this.med = _minimumEnclosingDisc__WEBPACK_IMPORTED_MODULE_2__.MinimumEnclosingDisc.LinearComputation(this.ps));
    }
    Min(d) {
        return this.particles[d][0].pos(d);
    }
    Size() {
        return this.particles[0].length;
    }
    Max(d) {
        return this.particles[d][this.Size() - 1].pos(d);
    }
    Dimension(d) {
        return this.Max(d) - this.Min(d);
    }
    Split(t) {
        const splitDirection = this.Dimension(Dim.Horizontal) > this.Dimension(Dim.Vertical) ? Dim.Horizontal : Dim.Vertical;
        const nonSplitDirection = splitDirection == Dim.Horizontal ? Dim.Vertical : Dim.Horizontal;
        const n = this.Size();
        const nLeft = n >> 1;
        const nRight = n - nLeft;
        const leftParticles = [new Array(nLeft), new Array(nLeft)];
        const rightParticles = [new Array(nRight), new Array(nRight)];
        let rCtr = 0;
        let lCtr = 0;
        for (let i = 0; i < n; i++) {
            const p = this.particles[splitDirection][i];
            if (i < nLeft) {
                leftParticles[splitDirection][i] = p;
                p.splitLeft = true;
            }
            else {
                rightParticles[splitDirection][i - nLeft] = p;
                p.splitLeft = false;
            }
        }
        for (let i = 0; i < n; i++) {
            const p = this.particles[nonSplitDirection][i];
            if (p.splitLeft) {
                leftParticles[nonSplitDirection][lCtr++] = p;
            }
            else {
                rightParticles[nonSplitDirection][rCtr++] = p;
            }
        }
        // Assert.assert(lCtr == nLeft)
        // Assert.assert(rCtr == nRight)
        const parentMED = this.med;
        this.particles = leftParticles;
        this.ComputeMinimumEnclosingDisc();
        t.rightSibling = new LeafKdNode(rightParticles);
        return new InternalKdNode(parentMED, this, t.rightSibling);
    }
    ComputeForces() {
        for (const u of this.particles[0]) {
            for (const v of this.particles[0]) {
                if (u != v) {
                    u.force = u.force.add(_multipoleCoefficients__WEBPACK_IMPORTED_MODULE_3__.MultipoleCoefficients.Force(u.point, v.point));
                }
            }
        }
    }
}
class Particle {
    pos(d) {
        return d == Dim.Horizontal ? this.point.x : this.point.y;
    }
    //  Create particle at point
    constructor(point) {
        this.point = point;
        this.force = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0);
    }
}
//  A KDTree recursively divides particles of a 2D space into a balanced tree structure by doing horizontal splits for wide bounding boxes and vertical splits for tall bounding boxes.
class KDTree {
    particlesBy(d) {
        return this.particles.map((t) => t).sort((a, b) => a.pos(d) - b.pos(d));
    }
    //  Create a KDTree over the specified particles, with the leaf partitions each containing bucketSize particles.
    constructor(particles, bucketSize) {
        this.particles = particles;
        const ps = new Array();
        ps.push(this.particlesBy(Dim.Horizontal));
        ps.push(this.particlesBy(Dim.Vertical));
        this.leaves = new Array();
        let l = new LeafKdNode(ps);
        this.leaves.push(l);
        const t = { rightSibling: null };
        this.root = l.Split(t);
        this.leaves.push(t.rightSibling);
        const splitQueue = new SplitQueue(bucketSize);
        splitQueue.EnqueueLL(l, t.rightSibling);
        while (splitQueue.length > 0) {
            l = splitQueue.dequeue();
            l.Split(t);
            this.leaves.push(t.rightSibling);
            splitQueue.EnqueueLL(l, t.rightSibling);
        }
    }
    //  Compute forces between particles using multipole approximations.
    ComputeForces(precision) {
        this.root.computeMultipoleCoefficients(precision);
        for (const l of this.leaves) {
            l.ComputeForces();
            const stack = new Array();
            stack.push(this.root);
            while (stack.length > 0) {
                const v = stack.pop();
                if (!l.intersects(v)) {
                    for (const p of l.particles[0]) {
                        p.force = p.force.sub(v.multipoleCoefficients.ApproximateForce(p.point));
                    }
                }
                else {
                    if (v instanceof LeafKdNode) {
                        for (const p of l.particles[0]) {
                            for (const q of v.particles[0]) {
                                if (p != q) {
                                    p.force = p.force.add(_multipoleCoefficients__WEBPACK_IMPORTED_MODULE_3__.MultipoleCoefficients.Force(p.point, q.point));
                                }
                            }
                        }
                    }
                    else {
                        const n = v;
                        stack.push(n.leftChild);
                        stack.push(n.rightChild);
                    }
                }
            }
        }
    }
}
class SplitQueue extends queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue {
    constructor(B) {
        super();
        this.B = B;
    }
    EnqueueLL(l, r) {
        if (l.Size() > this.B) {
            this.enqueue(l);
        }
        if (r.Size() > this.B) {
            this.enqueue(r);
        }
    }
}
//# sourceMappingURL=kdTree.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/incremental/multipole/minimumEnclosingDisc.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MinimumEnclosingDisc: () => (/* binding */ MinimumEnclosingDisc),
/* harmony export */   MoveToFront: () => (/* binding */ MoveToFront)
/* harmony export */ });
/* harmony import */ var linked_list_typed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/linked-list-typed/dist/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/assert.js");
/* harmony import */ var _disc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/multipole/disc.js");
//  implementation of the "MoveToFront" method for computing the minimum enclosing disc of a collection of points.
//  Runs in time linear in the number of points.  After Welzl'1991.



class MinDisc {
    constructor(ps, b) {
        this.boundary = b;
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(b.length <= 3);
        switch (b.length) {
            case 0:
                this.disc = null;
                break;
            case 1:
                this.disc = _disc__WEBPACK_IMPORTED_MODULE_2__.Disc.constructorP(ps[b[0]]);
                break;
            case 2:
                this.disc = _disc__WEBPACK_IMPORTED_MODULE_2__.Disc.constructorPP(ps[b[0]], ps[b[1]]);
                break;
            case 3:
                this.disc = _disc__WEBPACK_IMPORTED_MODULE_2__.Disc.constructorPPP(ps[b[0]], ps[b[1]], ps[b[2]]);
                break;
        }
    }
    contains(p) {
        if (this.disc == null) {
            return false;
        }
        return this.disc.Contains(p);
    }
}
class MoveToFront {
    //  Constructs the minimum enclosing disc for the specified points
    constructor(ps) {
        this.ps = ps;
        this.L = new linked_list_typed__WEBPACK_IMPORTED_MODULE_0__.SinglyLinkedList();
        for (let i = 0; i < this.ps.length; i++) {
            this.L.push(i);
        }
        const md = this.mtf_md(null, new Array());
        this.disc = md.disc;
        this.boundary = md.boundary;
    }
    collinear3(b) {
        if (b.length == 3) {
            return _disc__WEBPACK_IMPORTED_MODULE_2__.Disc.Collinear(this.ps[b[0]], this.ps[b[1]], this.ps[b[2]]);
        }
        return false;
    }
    mtf_md(lPtr, b) {
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(b.length <= 3);
        let md = new MinDisc(this.ps, b);
        if (b.length == 3) {
            return md;
        }
        let lnode = this.L.head;
        while (lnode != null && lnode != lPtr) {
            const lnext = lnode.next;
            const p = lnode.value;
            if (!md.contains(this.ps[p])) {
                const _b = Array.from(b);
                _b.push(p);
                _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(!this.collinear3(_b), 'Collinear points on boundary of minimal enclosing disc');
                md = this.mtf_md(lnode, _b);
                this.L.delete(lnode);
                this.L.unshift(lnode.value);
            }
            lnode = lnext;
        }
        return md;
    }
}
/** static methods for obtaining a minimum enclosing disc of a collection of points */
class MinimumEnclosingDisc {
    //  linear-time computation using the move-to-front heuristic by Welzl
    //  <returns>Smallest disc that encloses all the points</returns>
    static LinearComputation(points) {
        const m = new MoveToFront(points);
        return m.disc;
    }
    //  Computing the minimum enclosing disc the slow stupid way.  Just for testing purposes.
    //  <returns>Smallest disc that encloses all the points</returns>
    static SlowComputation(points) {
        const n = points.length;
        let mc = null;
        let b = null;
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i != j) {
                    const c = _disc__WEBPACK_IMPORTED_MODULE_2__.Disc.constructorPP(points[i], points[j]);
                    if (c.ContainsPN(points, [i, j])) {
                        if (mc == null || mc.Radius > c.Radius) {
                            mc = c;
                            b = [i, j];
                        }
                    }
                }
                for (let k = 0; k < n; k++) {
                    if (k != i && k != j && !_disc__WEBPACK_IMPORTED_MODULE_2__.Disc.Collinear(points[i], points[j], points[k])) {
                        const c3 = _disc__WEBPACK_IMPORTED_MODULE_2__.Disc.constructorPPP(points[i], points[j], points[k]);
                        if (c3.ContainsPN(points, [i, j, k])) {
                            if (mc == null || mc.Radius > c3.Radius) {
                                mc = c3;
                                b = [i, j, k];
                            }
                        }
                    }
                }
            }
        }
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(b != null);
        return mc;
    }
}
//# sourceMappingURL=minimumEnclosingDisc.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/incremental/multipole/multipoleCoefficients.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultipoleCoefficients: () => (/* binding */ MultipoleCoefficients)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/assert.js");


class MultipoleCoefficients {
    static constructorNPA(precision, center, points) {
        const r = new MultipoleCoefficients();
        r.p = precision;
        r.z0 = new Complex(center.x, center.y);
        r.a = new Array(precision);
        for (let k = 0; k < precision; k++) {
            r.a[k] = r.compute(k, points);
        }
        return r;
    }
    static constructorPMM(center, m1, m2) {
        const r = new MultipoleCoefficients();
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(m1.p == m2.p);
        r.p = m1.p;
        r.z0 = new Complex(center.x, center.y);
        const m2a = m2.shift(r.z0);
        const m1a = m1.shift(r.z0);
        r.a = new Array(r.p);
        for (let i = 0; i < r.p; i++) {
            r.a[i] = add(m1a[i], m2a[i]);
        }
        return r;
    }
    static factorial(n) {
        let f = 1;
        for (let i = 2; i <= n; i++) {
            f *= i;
        }
        return f;
    }
    static binomial(n, k) {
        return MultipoleCoefficients.factorial(n) / (MultipoleCoefficients.factorial(k) * MultipoleCoefficients.factorial(n - k));
    }
    sum(l, z0_minus_z1) {
        let s = Complex.constructorN(0);
        for (let k = 1; k <= l; k++) {
            const bi = Complex.constructorN(MultipoleCoefficients.binomial(l - 1, k - 1));
            s = add(s, prod(this.a[k], prod(Complex.Pow(z0_minus_z1, l - k), bi)));
        }
        return s;
    }
    shift(z1) {
        const b = new Array(this.p);
        const a0 = (b[0] = this.a[0]);
        const z0_minus_z1 = min(this.z0, z1);
        for (let l = 1; l < this.p; l++) {
            /*  Complex lz = new Complex(l);
                b[l] = -a0 * Complex.Pow(z0_minus_z1, l) / lz + sum(l, z0_minus_z1);
            */
            const lz = Complex.constructorN(l);
            b[l] = add(prod(neg(a0), div(Complex.Pow(z0_minus_z1, l), lz)), this.sum(l, z0_minus_z1));
        }
        return b;
    }
    //  Compute kth multipole coefficient of a set of points ps around a centre z0
    compute(k, ps) {
        const m = ps.length;
        let ak = Complex.constructorN(0);
        if (k == 0) {
            ak.re = m;
        }
        else {
            for (let i = 0; i < m; i++) {
                const q = ps[i];
                const pc = new Complex(q.x, q.y);
                ak = min(ak, Complex.Pow(min(pc, this.z0), k));
            }
            ak.divideBy(k);
        }
        return ak;
    }
    //  Compute approximate force at point v due to potential energy moments
    ApproximateForce(v) {
        const z = new Complex(v.x, v.y);
        const z_minus_z0 = min(z, this.z0);
        let fz = div(this.a[0], z_minus_z0);
        let z_minus_z0_to_k_plus_1 = z_minus_z0;
        let k = 0;
        while (true) {
            fz = min(fz, div(prodN(this.a[k], k), z_minus_z0_to_k_plus_1));
            k++;
            if (k == this.p) {
                break;
            }
            z_minus_z0_to_k_plus_1 = prod(z_minus_z0_to_k_plus_1, z_minus_z0);
        }
        return new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(fz.re, -fz.im);
    }
    //  Force on point u due to point v.
    //  If v and u at the same position it returns a small vector to separate them
    static Force(u, v) {
        const duv = v.sub(u);
        const l = duv.lengthSquared;
        if (l < 0.1) {
            if (l != 0) {
                return duv.div(0.1);
            }
            return new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);
        }
        return duv.div(l);
    }
}
class Complex {
    constructor(re, im) {
        this.re = re;
        this.im = im;
    }
    static constructorN(re) {
        return new Complex(re, 0);
    }
    divideBy(r) {
        this.re /= r;
        this.im /= r;
    }
    static Pow(a, k) {
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(k >= 0);
        switch (k) {
            case 0:
                return Complex.constructorN(1);
                break;
            case 1:
                return a;
                break;
            case 2:
                return prod(a, a);
                break;
            case 3:
                return prod(a, prod(a, a));
                break;
            default:
                return prod(Complex.Pow(a, k / 2), Complex.Pow(a, k / 2 + (k % 2)));
        }
    }
}
function add(a, b) {
    return new Complex(a.re + b.re, a.im + b.im);
}
function prod(a, b) {
    return new Complex(a.re * b.re - a.im * b.im, a.re * b.im + b.re * a.im);
}
function prodN(a, b) {
    return new Complex(a.re * b, a.im * b);
}
function min(a, b) {
    return new Complex(a.re - b.re, a.im - b.im);
}
function neg(a) {
    return new Complex(-a.re, -a.im);
}
function div(a, b) {
    const d = b.re * b.re + b.im * b.im;
    if (d == 0) {
        return Complex.constructorN(0.0);
    }
    const c1 = a.re * b.re + a.im * b.im;
    const c2 = a.im * b.re - a.re * b.im;
    return new Complex(c1 / d, c2 / d);
}
//# sourceMappingURL=multipoleCoefficients.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/initialLayout/geomConnectedComponent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomConnectedComponent: () => (/* binding */ GeomConnectedComponent)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _core_geomGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");



class GeomConnectedComponent {
    constructor(topNodes) {
        this.topNodes = topNodes;
    }
    get nodesBreadthFirst() {
        return this.nodesBreadthFirst_();
    }
    *nodesBreadthFirst_() {
        for (const n of this.topNodes) {
            yield ___WEBPACK_IMPORTED_MODULE_1__.GeomNode.getGeom(n);
            if (n instanceof ___WEBPACK_IMPORTED_MODULE_1__.Graph) {
                for (const nn of n.nodesBreadthFirst) {
                    yield ___WEBPACK_IMPORTED_MODULE_1__.GeomNode.getGeom(nn);
                }
            }
        }
    }
    get Clusters() {
        return this.clusters();
    }
    *clusters() {
        for (const n of this.topNodes)
            if (n instanceof ___WEBPACK_IMPORTED_MODULE_1__.Graph)
                yield ___WEBPACK_IMPORTED_MODULE_1__.GeomGraph.getGeom(n);
    }
    get subgraphsDepthFirst() {
        return this.subgraphsDepthFirst_();
    }
    *subgraphsDepthFirst_() {
        for (const n of this.topNodes) {
            if (n instanceof ___WEBPACK_IMPORTED_MODULE_1__.Graph) {
                const gn = ___WEBPACK_IMPORTED_MODULE_1__.GeomGraph.getGeom(n);
                yield* gn.subgraphsDepthFirst;
                yield gn;
            }
        }
    }
    get shallowEdges() {
        return this.edges_();
    }
    *edges_() {
        for (const n of this.topNodes) {
            for (const e of n.outEdges)
                yield ___WEBPACK_IMPORTED_MODULE_1__.GeomEdge.getGeom(e);
            for (const e of n.selfEdges)
                yield ___WEBPACK_IMPORTED_MODULE_1__.GeomEdge.getGeom(e);
        }
    }
    get shallowNodes() {
        return this.shallowNodes_();
    }
    *shallowNodes_() {
        for (const n of this.topNodes)
            yield ___WEBPACK_IMPORTED_MODULE_1__.GeomNode.getGeom(n);
    }
    pumpTheBoxToTheGraphWithMargins() {
        const t = { b: _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkEmpty() };
        (0,_core_geomGraph__WEBPACK_IMPORTED_MODULE_2__.pumpTheBoxToTheGraph)(this, t);
        return (this.boundingBox = t.b);
    }
    get shallowNodeCount() {
        return this.topNodes.length;
    }
    translate(delta) {
        if (this.boundingBox)
            this.boundingBox.center = this.boundingBox.center.add(delta);
        for (const n of this.topNodes) {
            const gn = ___WEBPACK_IMPORTED_MODULE_1__.GeomNode.getGeom(n);
            gn.translate(delta);
        }
        // todo :test the edges!
    }
}
//# sourceMappingURL=geomConnectedComponent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/initialLayout/initialLayout.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InitialLayout: () => (/* binding */ InitialLayout)
/* harmony export */ });
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _incremental_iPsepCola__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/iPsepCola.js");
/* harmony import */ var _incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/incremental/iPsepColaSettings.js");
/* harmony import */ var _mds_mDSGraphLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/mDSGraphLayout.js");
/* harmony import */ var _mds_pivotMDS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/pivotMDS.js");
/* harmony import */ var _geomConnectedComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/initialLayout/geomConnectedComponent.js");
/* harmony import */ var _layoutAlgorithmHelpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/initialLayout/layoutAlgorithmHelpers.js");
/* harmony import */ var _gTreeOverlapRemoval_gTreeOverlapRemoval__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/gTreeOverlapRemoval.js");
/* harmony import */ var _mds_mDSLayoutSettings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/mDSLayoutSettings.js");









//  Methods for obtaining an initial layout of a graph using various means.
class InitialLayout extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__.Algorithm {
    //  Static layout of graph by gradually adding constraints.
    //  Uses PivotMds to find initial layout.
    //  Breaks the graph into connected components (nodes of the same cluster are considered
    //  connected whether or not there is an edge between them), then lays out each component
    //  individually.  Finally, a simple packing is applied.
    //  ratio as close as possible to the PackingAspectRatio property (not currently used).
    constructor(graph, settings) {
        super(null);
        //  Set to true if the graph specified is a single connected component with no clusters
        this.SingleComponent = false;
        this.graph = graph;
        this.settings = _incremental_iPsepColaSettings__WEBPACK_IMPORTED_MODULE_2__.IPsepColaSetting.ctorClone(settings);
        this.settings.ApplyForces = true;
        this.settings.InterComponentForces = true;
        this.settings.RungeKuttaIntegration = false;
        this.settings.RespectEdgePorts = false;
    }
    //  The actual layout process
    run() {
        if (this.SingleComponent) {
            this.componentCount = 1;
            this.LayoutComponent(this.graph);
        }
        else {
            const components = Array.from(this.graph.graph.getClusteredConnectedComponents()).map((topNodes) => new _geomConnectedComponent__WEBPACK_IMPORTED_MODULE_5__.GeomConnectedComponent(topNodes));
            this.componentCount = components.length;
            for (const component of components) {
                this.LayoutComponent(component);
            }
            this.graph.boundingBox = _mds_mDSGraphLayout__WEBPACK_IMPORTED_MODULE_3__.MdsGraphLayout.PackGraphs(components, this.settings.commonSettings);
            // for (let c of this.graph.subgraphs()) {
            //     let copy = (<GraphConnectedComponents.AlgorithmDataNodeWrap>(c.AlgorithmData));
            //     let copyCluster = (<Cluster>(copy.node));
            //     Assert.assert((copyCluster != null));
            //     c.RectangularBoundary = copyCluster.RectangularBoundary;
            //     c.RectangularBoundary.GenerateFixedConstraints = c.RectangularBoundary.GenerateFixedConstraintsDefault;
            //     c.BoundingBox = c.RectangularBoundary.Rect;
            //     c.RaiseLayoutDoneEvent();
            // }
        }
    }
    LayoutComponent(component) {
        if (component.shallowNodeCount > 1) {
            //  for small graphs (below 100 nodes) do extra iterations
            this.settings.MaxIterations = _layoutAlgorithmHelpers__WEBPACK_IMPORTED_MODULE_6__.LayoutAlgorithmHelpers.NegativeLinearInterpolation(component.shallowNodeCount, 50, 500, 5, 10);
            this.settings.MinorIterations = _layoutAlgorithmHelpers__WEBPACK_IMPORTED_MODULE_6__.LayoutAlgorithmHelpers.NegativeLinearInterpolation(component.shallowNodeCount, 50, 500, 3, 20);
            if (this.settings.MinConstraintLevel == 0) {
                //  run PivotMDS with a largish Scale so that the layout comes back oversized.
                //  subsequent incremental iterations do a better job of untangling when they're pulling it in
                //  rather than pushing it apart.
                const mdsSettings = new _mds_mDSLayoutSettings__WEBPACK_IMPORTED_MODULE_8__.MdsLayoutSettings();
                mdsSettings.removeOverlaps = false;
                mdsSettings.IterationsWithMajorization = 0;
                const pivotMDS = new _mds_pivotMDS__WEBPACK_IMPORTED_MODULE_4__.PivotMDS(component, null, () => 1, new _mds_mDSLayoutSettings__WEBPACK_IMPORTED_MODULE_8__.MdsLayoutSettings());
                pivotMDS.run();
            }
            const fil = new _incremental_iPsepCola__WEBPACK_IMPORTED_MODULE_1__.IPsepCola(component, this.settings, this.settings.MinConstraintLevel);
            //Assert.assert(this.settings.Iterations == 0)
            for (const level of this.GetConstraintLevels(component)) {
                if (level > this.settings.MaxConstraintLevel) {
                    break;
                }
                if (level > this.settings.MinConstraintLevel) {
                    fil.setCurrentConstraintLevel(level);
                }
                do {
                    fil.run();
                } while (!this.settings.IsDone);
            }
            if (this.settings.AvoidOverlaps) {
                _gTreeOverlapRemoval_gTreeOverlapRemoval__WEBPACK_IMPORTED_MODULE_7__.GTreeOverlapRemoval.RemoveOverlaps(Array.from(this.graph.shallowNodes), this.settings.NodeSeparation);
            }
        }
        component.pumpTheBoxToTheGraphWithMargins();
        //  Pad the graph with margins so the packing will be spaced out.
        component.uniformMargins = this.settings.NodeSeparation;
        //  Zero the graph
        component.translate(component.boundingBox.leftBottom.mul(-1));
    }
    /** returns 0, 1 or 2:
     *   Get the distinct ConstraintLevels that need to be applied to layout.
      Used by InitialLayout.
     Will only include ConstraintLevel == 2 if AvoidOverlaps is on and there are fewer than 2000 nodes
     */
    GetConstraintLevels(component) {
        const keys = new Set();
        keys.add(0);
        if (this.settings.AvoidOverlaps && component.shallowNodeCount < 2000) {
            keys.add(2);
        }
        return keys;
    }
}
//# sourceMappingURL=initialLayout.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/initialLayout/layoutAlgorithmHelpers.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayoutAlgorithmHelpers: () => (/* binding */ LayoutAlgorithmHelpers)
/* harmony export */ });
class LayoutAlgorithmHelpers {
    //  Linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
    //  <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
    static LinearInterpolation(value, lowerThreshold, upperThreshold, minResult, maxResult) {
        if (value < lowerThreshold) {
            return minResult;
        }
        if (value > upperThreshold) {
            return maxResult;
        }
        const fraction = (value - lowerThreshold) / (upperThreshold - lowerThreshold);
        return minResult + (fraction * (maxResult - minResult));
    }
    //  Negatively linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
    //  <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
    static NegativeLinearInterpolation(value, lowerThreshold, upperThreshold, minResult, maxResult) {
        if (value < lowerThreshold) {
            return maxResult;
        }
        if (value > upperThreshold) {
            return minResult;
        }
        const fraction = (value - lowerThreshold) / (upperThreshold - lowerThreshold);
        return minResult + ((1 - fraction) * (maxResult - minResult));
    }
}
//# sourceMappingURL=layoutAlgorithmHelpers.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/Balancing.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Balancing: () => (/* binding */ Balancing)
/* harmony export */ });
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
// balances the layers by moving vertices with


// balances the layers by moving vertices with
// the same number of input-output edges to feasible layers with fewer nodes
class Balancing extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__.Algorithm {
    static Balance(dag, layering, nodeCount, cancelObj) {
        const b = new Balancing(dag, layering, nodeCount, cancelObj);
        b.run();
    }
    constructor(dag, layering, nodeCount, cancelToken) {
        super(cancelToken);
        this.jumpers = new Set();
        this.possibleJumperFeasibleIntervals = new Map();
        this.nodeCount = nodeCount;
        this.dag = dag;
        this.layering = layering;
        this.Init();
    }
    run() {
        while (this.jumpers.size > 0)
            this.Jump(this.ChooseJumper());
    }
    Init() {
        this.CalculateLayerCounts();
        this.InitJumpers();
    }
    Jump(jumper) {
        this.jumpers.delete(jumper);
        const upLow = this.possibleJumperFeasibleIntervals.get(jumper);
        const ji = this.CalcJumpInfo(upLow.x, upLow.y, jumper);
        if (ji == null)
            return;
        this.layering[jumper] = ji.layerToJumpTo;
        const jumperCount = this.nodeCount[jumper];
        this.vertsCounts[ji.jumperLayer] -= jumperCount;
        this.vertsCounts[ji.layerToJumpTo] += jumperCount;
        this.UpdateRegionsForPossibleJumpersAndInsertJumpers(ji.jumperLayer, jumper);
    }
    IsJumper(v) {
        return this.possibleJumperFeasibleIntervals.has(v);
    }
    // some other jumpers may stop being ones if the jump
    // was just in to their destination layer, so before the actual
    // jump we have to recheck if the jump makes sense
    //
    UpdateRegionsForPossibleJumpersAndInsertJumpers(jumperLayer, jumper) {
        const neighborPossibleJumpers = new Set();
        //update possible jumpers neighbors
        for (const v of this.dag.pred(jumper))
            if (this.IsJumper(v)) {
                this.CalculateRegionAndInsertJumper(v);
                neighborPossibleJumpers.add(v);
            }
        for (const v of this.dag.succ(jumper))
            if (this.IsJumper(v)) {
                this.CalculateRegionAndInsertJumper(v);
                neighborPossibleJumpers.add(v);
            }
        const possibleJumpersToUpdate = new Array();
        for (const kv of this.possibleJumperFeasibleIntervals) {
            if (!neighborPossibleJumpers.has(kv[0]))
                if (kv[1].x > jumperLayer && kv[1].y < jumperLayer)
                    possibleJumpersToUpdate.push(kv[0]);
        }
        for (const v of possibleJumpersToUpdate)
            this.CalculateRegionAndInsertJumper(v);
    }
    InitJumpers() {
        const deltas = new Array(this.dag.nodeCount).fill(0);
        for (const ie of this.dag.edges) {
            deltas[ie.source] -= ie.weight;
            deltas[ie.target] += ie.weight;
        }
        this.possibleJumperFeasibleIntervals = new Map();
        for (let i = 0; i < this.dag.nodeCount; i++)
            if (deltas[i] === 0)
                this.CalculateRegionAndInsertJumper(i);
    }
    CalculateRegionAndInsertJumper(i) {
        const ip = new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(this.Up(i), this.Down(i));
        this.possibleJumperFeasibleIntervals.set(i, ip);
        this.InsertJumper(ip.x, ip.y, i);
    }
    InsertJumper(upLayer, lowLayer, jumper) {
        const ji = this.CalcJumpInfo(upLayer, lowLayer, jumper);
        if (ji != null)
            this.jumpers.add(jumper);
    }
    // layerToJumpTo is -1 if there is no jump
    CalcJumpInfo(upLayer, lowLayer, jumper) {
        const jumperLayer = this.layering[jumper];
        let layerToJumpTo = -1;
        let min = this.vertsCounts[jumperLayer] - 2 * this.nodeCount[jumper];
        // jump makes sense if some layer has less than min vertices
        for (let i = upLayer - 1; i > jumperLayer; i--)
            if (this.vertsCounts[i] < min) {
                min = this.vertsCounts[i];
                layerToJumpTo = i;
            }
        for (let i = jumperLayer - 1; i > lowLayer; i--)
            if (this.vertsCounts[i] < min) {
                min = this.vertsCounts[i];
                layerToJumpTo = i;
            }
        if (layerToJumpTo === -1)
            return;
        return { jumperLayer: jumperLayer, layerToJumpTo: layerToJumpTo };
    }
    // Up returns the first infeasible layer up from i that i cannot jump to
    Up(i) {
        let ret = Number.MAX_SAFE_INTEGER;
        //minimum of incoming edge sources layeres
        for (const ie of this.dag.inEdges[i]) {
            const r = this.layering[ie.source] - ie.separation + 1;
            if (r < ret)
                ret = r;
        }
        if (ret === Number.MAX_SAFE_INTEGER)
            ret = this.layering[i] + 1;
        return ret;
    }
    // Returns the first infeasible layer down from i that i cannot jump to
    Down(i) {
        let ret = Number.NEGATIVE_INFINITY;
        for (const ie of this.dag.outEdges[i]) {
            const r = this.layering[ie.target] + ie.separation - 1;
            if (r > ret)
                ret = r;
        }
        if (ret === Number.NEGATIVE_INFINITY)
            ret = this.layering[i] - 1;
        return ret;
    }
    CalculateLayerCounts() {
        /*Assert.assert(this.layering.length > 0)*/
        this.vertsCounts = new Array(Math.max(...this.layering) + 1).fill(0);
        for (const r of this.layering) {
            this.vertsCounts[r] += this.nodeCount[r];
        }
    }
    ChooseJumper() {
        //just return the first available
        for (const jumper of this.jumpers)
            return jumper;
        throw new Error('there are no jumpers to choose');
    }
}
//# sourceMappingURL=Balancing.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/CycleRemoval.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CycleRemoval: () => (/* binding */ CycleRemoval)
/* harmony export */ });
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairMap.js");


var VertStatus;
(function (VertStatus) {
    VertStatus[VertStatus["NotVisited"] = 0] = "NotVisited";
    VertStatus[VertStatus["InStack"] = 1] = "InStack";
    VertStatus[VertStatus["Visited"] = 2] = "Visited";
})(VertStatus || (VertStatus = {}));
class StackStruct {
    constructor(v, i) {
        this.v = v;
        this.i = i;
    }
}
class CycleRemoval {
    static getFeedbackSetWithConstraints(arg0, arg1) {
        throw new Error('Method not implemented.');
    }
    static push(stack, status, v, i) {
        status[v] = VertStatus.InStack;
        stack.push(new StackStruct(v, i));
    }
    static getFeedbackSet(graph) {
        const feedbackSet = new _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_1__.IntPairMap();
        if (graph == null || graph.nodeCount === 0)
            return [];
        const status = new Array(graph.nodeCount).fill(VertStatus.NotVisited);
        for (let vertex = 0; vertex < graph.nodeCount; vertex++) {
            if (status[vertex] === VertStatus.Visited)
                continue;
            /*Assert.assert(status[vertex] !== VertStatus.InStack)*/
            const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack(); //avoiding the recursion
            let i = 0; // the index in the outEnum
            CycleRemoval.push(stack, status, vertex, i);
            while (stack.size > 0) {
                const s = stack.pop();
                vertex = s.v;
                status[vertex] = VertStatus.Visited;
                i = s.i;
                let outEnum = graph.outEdges[vertex];
                for (; i < outEnum.length; i++) {
                    const e = outEnum[i];
                    if (e.source === e.target)
                        continue;
                    const targetStatus = status[e.target];
                    if (targetStatus === VertStatus.InStack) {
                        feedbackSet.set(e.source, e.target, e);
                    }
                    else if (targetStatus === VertStatus.NotVisited) {
                        //have to go deeper
                        CycleRemoval.push(stack, status, vertex, i + 1);
                        vertex = e.target;
                        status[e.target] = VertStatus.Visited;
                        outEnum = graph.outEdges[vertex];
                        i = -1;
                    }
                }
            }
        }
        return Array.from(feedbackSet.values());
    }
}
//# sourceMappingURL=CycleRemoval.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/Database.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Database: () => (/* binding */ Database)
/* harmony export */ });
/* harmony import */ var _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairMap.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");


class Database {
    *RegularMultiedges() {
        for (const [k, v] of this.Multiedges.keyValues())
            if (k.x !== k.y)
                yield v;
    }
    *AllIntEdges() {
        for (const l of this.Multiedges.values())
            for (const e of l)
                yield e;
    }
    addFeedbackSet(feedbackSet) {
        for (const e of feedbackSet) {
            const ip = new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(e.source, e.target);
            const ipr = new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(e.target, e.source);
            //we shuffle reversed edges into the other multiedge
            const listToShuffle = this.Multiedges.get(ip.x, ip.y);
            for (const er of listToShuffle)
                er.reverse();
            if (this.Multiedges.has(ipr.x, ipr.y)) {
                const m = this.Multiedges.get(ipr.x, ipr.y);
                for (const e of listToShuffle)
                    m.push(e);
            }
            else {
                this.Multiedges.set(ipr.x, ipr.y, listToShuffle);
            }
            this.Multiedges.delete(ip.x, ip.y);
        }
    }
    constructor(n) {
        this.MultipleMiddles = new Set();
        this.Multiedges = new _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_0__.IntPairMap();
    }
    registerOriginalEdgeInMultiedges(edge) {
        let o = this.Multiedges.get(edge.source, edge.target);
        if (o == null) {
            this.Multiedges.set(edge.source, edge.target, (o = []));
        }
        o.push(edge);
    }
    *SkeletonEdges() {
        for (const [k, v] of this.Multiedges.keyValues()) {
            if (k.x !== k.y)
                yield v[0];
        }
    }
    GetMultiedge(source, target) {
        return this.GetMultiedgeI(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(source, target));
    }
    GetMultiedgeI(ip) {
        if (this.Multiedges.has(ip.x, ip.y))
            return this.Multiedges.get(ip.x, ip.y);
        return new Array();
    }
}
//# sourceMappingURL=Database.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/EdgePathsInserter.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgePathsInserter: () => (/* binding */ EdgePathsInserter)
/* harmony export */ });
/* harmony import */ var _LayerArrays__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/LayerArrays.js");
/* harmony import */ var _layerEdge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layerEdge.js");
/* harmony import */ var _LayerInserter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/LayerInserter.js");
/* harmony import */ var _ProperLayeredGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/ProperLayeredGraph.js");
// This class is used of the case when there are multiple edges, but there is no need to duplicate layers.




// We just insert dummy nodes for edge middles without distorting the order of vertices of the layers.
class EdgePathsInserter {
    get NLayering() {
        return this.Nla.y;
    }
    static InsertPaths(layeredGraph, la, db, intGraphP) {
        const li = new EdgePathsInserter(layeredGraph, la, db, intGraphP);
        li.InsertPaths();
        return {
            layeredGraph: li.NLayeredGraph,
            la: li.Nla,
        };
    }
    constructor(layeredGraph, la, database, intGraphP) {
        this.virtNodesToIntEdges = new Map();
        this.la = la;
        this.database = database;
        this.layeredGraph = layeredGraph;
        this.intGraph = intGraphP;
    }
    InsertPaths() {
        /*Assert.assert(layersAreCorrect(this.la))*/
        this.CreateFullLayeredGraph();
        this.InitNewLayering();
        this.MapVirtualNodesToEdges();
        this.WidenOriginalLayers();
        /*Assert.assert(layersAreCorrect(this.la))*/
    }
    WidenOriginalLayers() {
        for (let i = 0; i < this.la.Layers.length; i++) {
            const layer = this.Nla.Layers[i];
            let offset = 0;
            for (const v of this.la.Layers[i]) {
                const e = this.virtNodesToIntEdges.get(v);
                if (e != null) {
                    const layerOffsetInTheEdge = this.NLayering[e.source] - this.NLayering[v];
                    const list = this.database.Multiedges.get(e.source, e.target);
                    for (const ie of list) {
                        if (!this.EdgeIsFlat(ie)) {
                            if (ie !== e) {
                                const u = ie.LayerEdges[layerOffsetInTheEdge].Source;
                                layer[offset] = u;
                                this.Nla.x[u] = offset++;
                            }
                            else {
                                layer[offset] = v;
                                this.Nla.x[v] = offset++;
                            }
                        }
                    }
                }
                else {
                    layer[offset] = v;
                    this.Nla.x[v] = offset++;
                }
            }
        }
    }
    EdgeIsFlat(ie) {
        return this.la.y[ie.source] === this.la.y[ie.target];
    }
    MapVirtualNodesToEdges() {
        for (const list of this.database.RegularMultiedges())
            for (const e of list)
                if (!this.EdgeIsFlat(e))
                    //the edge is not flat
                    for (const le of e.LayerEdges)
                        if (le.Target !== e.target) {
                            this.virtNodesToIntEdges.set(le.Target, e);
                        }
    }
    CreateFullLayeredGraph() {
        let currentVV = this.layeredGraph.NodeCount;
        for (const [k, list] of this.database.Multiedges.keyValues()) {
            if (k.x !== k.y) {
                //not a self edge
                let first = true;
                let span = 0;
                for (const e of list) {
                    if (first) {
                        first = false;
                        span = e.LayerSpan;
                    }
                    else {
                        e.LayerEdges = new Array(span);
                        if (span === 1)
                            e.LayerEdges[0] = new _layerEdge__WEBPACK_IMPORTED_MODULE_1__.LayerEdge(e.source, e.target, e.CrossingWeight);
                        else {
                            for (let i = 0; i < span; i++) {
                                const bVV = { currentVV: currentVV };
                                const source = EdgePathsInserter.GetSource(bVV, e, i);
                                currentVV = bVV.currentVV;
                                const target = EdgePathsInserter.GetTarget(currentVV, e, i, span);
                                e.LayerEdges[i] = new _layerEdge__WEBPACK_IMPORTED_MODULE_1__.LayerEdge(source, target, e.CrossingWeight);
                            }
                        }
                    }
                    _LayerInserter__WEBPACK_IMPORTED_MODULE_2__.LayerInserter.RegisterDontStepOnVertex(this.database, e);
                }
            }
        }
        this.NLayeredGraph = new _ProperLayeredGraph__WEBPACK_IMPORTED_MODULE_3__.ProperLayeredGraph(this.intGraph);
    }
    static GetTarget(currentVV, e, i, span) {
        if (i < span - 1)
            return currentVV;
        return e.target;
    }
    static GetSource(boxedVV, e, i) {
        if (i === 0)
            return e.source;
        return boxedVV.currentVV++;
    }
    InitNewLayering() {
        this.Nla = new _LayerArrays__WEBPACK_IMPORTED_MODULE_0__.LayerArrays(new Array(this.NLayeredGraph.NodeCount));
        for (let i = 0; i < this.layeredGraph.NodeCount; i++)
            this.NLayering[i] = this.la.y[i];
        for (const [k, list] of this.database.Multiedges.keyValues()) {
            if (k.x !== k.y && this.la.y[k.x] !== this.la.y[k.y]) {
                //not a self edge and not a flat edge
                let layer = 0;
                let first = true;
                for (const e of list) {
                    if (first) {
                        first = false;
                        layer = this.la.y[e.source];
                    }
                    let cl = layer - 1;
                    for (const le of e.LayerEdges)
                        this.NLayering[le.Target] = cl--;
                }
            }
        }
        // number[][] newLayers = new number[la.Layers.length][];
        const newLayers = new Array(this.la.Layers.length);
        //count new layer widths
        const counts = new Array(newLayers.length).fill(0);
        for (const l of this.NLayering)
            counts[l]++;
        for (let i = 0; i < counts.length; i++)
            newLayers[i] = new Array(counts[i]);
        this.Nla = new _LayerArrays__WEBPACK_IMPORTED_MODULE_0__.LayerArrays(this.NLayering);
        this.Nla.Layers = newLayers;
    }
}
//# sourceMappingURL=EdgePathsInserter.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/HierarchyCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HierarchyCalculator: () => (/* binding */ HierarchyCalculator)
/* harmony export */ });
/* harmony import */ var _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogram.js");

class HierarchyCalculator {
    static Calculate(nodes, groupSplitThresholdPar = 0) {
        const calc = new HierarchyCalculator(nodes, groupSplitThresholdPar);
        return calc.Calculate();
    }
    constructor(nodes, groupSplitThresholdPar) {
        this.groupSplitThreshold = 2;
        this.initialNodes = nodes;
        this.groupSplitThreshold = groupSplitThresholdPar;
    }
    Calculate() {
        return this.Calc(this.initialNodes);
    }
    Calc(nodes) {
        if (nodes.length === 0) {
            return null;
        }
        if (nodes.length === 1) {
            return nodes[0];
        }
        // Finding the seeds
        const b0 = nodes[0].parallelogram;
        // the first seed
        let seed0 = 1;
        let area = _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_0__.Parallelogram.parallelogramOfTwo(b0, nodes[seed0].parallelogram).area;
        for (let i = 2; i < nodes.length; i++) {
            const area0 = _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_0__.Parallelogram.parallelogramOfTwo(b0, nodes[i].parallelogram).area;
            if (area0 > area) {
                seed0 = i;
                area = area0;
            }
        }
        // Got the first seed seed0
        // Now looking for a seed for the second group
        let seed1;
        // the compiler forces me to init it
        // init seed1
        for (let i = 0; i < nodes.length; i++) {
            if (i !== seed0) {
                seed1 = i;
                break;
            }
        }
        area = _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_0__.Parallelogram.parallelogramOfTwo(nodes[seed0].parallelogram, nodes[seed1].parallelogram).area;
        // Now try to improve the second seed
        for (let i = 0; i < nodes.length; i++) {
            if (i === seed0) {
                continue;
            }
            const area1 = _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_0__.Parallelogram.parallelogramOfTwo(nodes[seed0].parallelogram, nodes[i].parallelogram).area;
            if (area1 > area) {
                seed1 = i;
                area = area1;
            }
        }
        // We have two seeds at hand. Build two groups.
        const gr0 = new Array();
        const gr1 = new Array();
        gr0.push(nodes[seed0]);
        gr1.push(nodes[seed1]);
        let box0 = nodes[seed0].parallelogram;
        let box1 = nodes[seed1].parallelogram;
        // divide nodes on two groups
        for (let i = 0; i < nodes.length; i++) {
            if (i === seed0 || i === seed1) {
                continue;
            }
            const box0_ = _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_0__.Parallelogram.parallelogramOfTwo(box0, nodes[i].parallelogram);
            const delta0 = box0_.area - box0.area;
            const box1_ = _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_0__.Parallelogram.parallelogramOfTwo(box1, nodes[i].parallelogram);
            const delta1 = box1_.area - box1.area;
            // keep the tree roughly balanced
            if (gr0.length * this.groupSplitThreshold < gr1.length) {
                gr0.push(nodes[i]);
                box0 = box0_;
            }
            else if (gr1.length * this.groupSplitThreshold < gr0.length) {
                gr1.push(nodes[i]);
                box1 = box1_;
            }
            else if (delta0 < delta1) {
                gr0.push(nodes[i]);
                box0 = box0_;
            }
            else {
                gr1.push(nodes[i]);
                box1 = box1_;
            }
        }
        return {
            parallelogram: _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_0__.Parallelogram.parallelogramOfTwo(box0, box1),
            node: { children: [this.Calc(gr0), this.Calc(gr1)] },
            seg: undefined,
            leafBoxesOffset: undefined,
        };
    }
}
//# sourceMappingURL=HierarchyCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/HorizontalConstraintsForSugiyama.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HorizontalConstraintsForSugiyama: () => (/* binding */ HorizontalConstraintsForSugiyama)
/* harmony export */ });
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairSet.js");
/* harmony import */ var _CycleRemoval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/CycleRemoval.js");




function mktuple(a, b) {
    return [a, b];
}
class HorizontalConstraintsForSugiyama {
    constructor() {
        this.leftRightConstraints = new Array();
        this.leftRightNeighbors = new Array();
        // node is mapped to the block root
        this.nodeToBlockRoot = new Map();
        this.upDownVerticalConstraints = new Array();
        // The right most node to the left of the  block is called a block root. The root does not belong to its block.
        this.BlockRootToBlock = new Map();
    }
    get IsEmpty() {
        return this.leftRightNeighbors.length === 0 && this.upDownVerticalConstraints.length === 0 && this.leftRightConstraints.length === 0;
    }
    AddSameLayerNeighbors(neighbors) {
        for (let i = 0; i < neighbors.length - 1; i++)
            this.AddSameLayerNeighborsPair(neighbors[i], neighbors[i + 1]);
    }
    AddSameLayerNeighborsPair(leftNode, rightNode) {
        this.leftRightNeighbors.push([leftNode, rightNode]);
    }
    NodeToBlockRootSoft(i) {
        const blockRoot = this.nodeToBlockRoot.get(i);
        return blockRoot ? blockRoot : i;
    }
    CreateMappingOfNeibBlocks() {
        const graph = this.BasicGraphFromLeftRightIntNeibs();
        for (let root = 0; root < graph.nodeCount; root++)
            if (graph.inEdges[root].length === 0 && !this.nodeToBlockRoot.has(root)) {
                const block = new Array();
                let current = root;
                for (let outEdges = graph.outEdges[current]; outEdges.length > 0; outEdges = graph.outEdges[current]) {
                    current = outEdges[0].y;
                    block.push(current);
                    this.nodeToBlockRoot.set(current, root);
                }
                if (block.length > 0)
                    this.BlockRootToBlock.set(root, block);
            }
    }
    BasicGraphFromLeftRightIntNeibs() {
        return (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__.mkGraphOnEdges)(Array.from(this.LeftRightIntNeibs.values()).map((p) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(p.x, p.y)));
    }
    NodeIndex(node) {
        const index = this.nodeIdToIndex.get(node.id);
        return index ? index : -1;
    }
    PrepareForOrdering(nodeToIndexParameter, yLayers) {
        this.nodeIdToIndex = nodeToIndexParameter;
        this.MapNodesToToIntegers(yLayers);
        this.CreateMappingOfNeibBlocks();
        this.LiftLeftRightRelationsToNeibBlocks();
        //MakeUpDownRelationsMonotone(yLayers);
    }
    //see UpDownMonotone.png
    //       void MakeUpDownRelationsMonotone(number[] yLayers) {
    //           BasicGraph<IntPair> upDownGraph = new BasicGraph<IntPair>(from c in this.verticalInts select new IntPair(c.First,c.Second));
    //           Array<Tuple<number, number>> upDownToRemove = new Array<Tuple<number, number>>();
    //           foreach (Array<number> componentNodes of ConnectedComponentCalculator<IntPair>.GetComponents(GraphOfLeftRightRelations())) {
    //               ResolveConflictsUboveComponent(upDownGraph, componentNodes, upDownToRemove, yLayers);
    //               ResolveConflictsBelowComponent(upDownGraph, componentNodes, upDownToRemove, yLayers);
    //           }
    //
    //           foreach (var v of upDownToRemove)
    //               this.verticalInts.Remove(v);
    //       }
    //makes left-right relations to be between neighb blocks and removes cycles in these relations
    LiftLeftRightRelationsToNeibBlocks() {
        this.LeftRighInts = _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_2__.IntPairSet.mk(this.leftRightConstraints
            .map((p) => mktuple(this.NodeIndex(p[0]), this.NodeIndex(p[1])))
            .filter((p) => p[0] !== -1 && p[1] !== -1)
            .map((ip) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(this.NodeToBlockRootSoft(ip[0]), this.NodeToBlockRootSoft(ip[1])))
            .filter((ip) => ip.x !== ip.x));
        const feedbackSet = _CycleRemoval__WEBPACK_IMPORTED_MODULE_3__.CycleRemoval.getFeedbackSet((0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__.mkGraphOnEdges)(Array.from(this.LeftRighInts.values())));
        for (const ip of feedbackSet)
            this.LeftRighInts.remove(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(ip.source, ip.target));
    }
    MapNodesToToIntegers(yLayers) {
        this.LeftRightIntNeibs = _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_2__.IntPairSet.mk(Array.from(this.leftRightNeighbors.values())
            .map((p) => [this.NodeIndex(p[0]), this.NodeIndex(p[1])])
            .filter((t) => t[0] !== -1 && t[1] !== -1)
            .map((t) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(t[0], t[1])));
        //as we follow yLayers there will not be cycles in verticalIntConstraints
        this.VerticalInts = _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_2__.IntPairSet.mk(this.upDownVerticalConstraints
            .map((p) => [this.NodeIndex(p[0]), this.NodeIndex(p[1])])
            .filter((p) => p[0] !== -1 && p[1] !== -1 && yLayers[p[0]] > yLayers[p[1]])
            .map((p) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(p[0], p[1])));
    }
}
//# sourceMappingURL=HorizontalConstraintsForSugiyama.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/LayerArrays.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayerArrays: () => (/* binding */ LayerArrays),
/* harmony export */   layerHasDublicatesOrUndef: () => (/* binding */ layerHasDublicatesOrUndef),
/* harmony export */   layersAreCorrect: () => (/* binding */ layersAreCorrect)
/* harmony export */ });
/* harmony import */ var _utils_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/copy.js");

class LayerArrays {
    constructor(verticesToLayers) {
        this.initialize(verticesToLayers);
    }
    initialize(verticesToLayers) {
        this.y = verticesToLayers;
        this.verticesToX = null;
        this.layers = null;
    }
    // Returns the same arrays but with no empty layers.
    DropEmptyLayers() {
        const drop = new Array(this.Layers.length);
        let dropVal = 0;
        for (let i = 0; i < this.Layers.length; i++) {
            drop[i] = dropVal;
            if (this.Layers[i].length === 0)
                dropVal++;
        }
        if (dropVal === 0)
            return this;
        //we do have empty layers
        const ny = new Array(this.y.length);
        for (let i = 0; i < ny.length; i++)
            ny[i] = this.y[i] - drop[this.y[i]];
        //copy the layers itself
        const nls = new Array(this.layers.length - dropVal);
        for (let i = 0; i < this.layers.length; i++) {
            if (this.layers[i].length > 0)
                nls[i - drop[i]] = Array.from(this.layers[i]);
        }
        const la = new LayerArrays(ny);
        la.layers = nls;
        return la;
    }
    updateLayers(ulayers) {
        if (this.layers == null)
            this.InitLayers();
        for (let i = 0; i < this.layers.length; i++)
            (0,_utils_copy__WEBPACK_IMPORTED_MODULE_0__.copyTo)(ulayers[i], this.layers[i]);
        this.UpdateXFromLayers();
    }
    UpdateXFromLayers() {
        if (this.layers == null)
            this.InitLayers();
        if (this.verticesToX == null)
            this.verticesToX = new Array(this.y.length);
        for (const layer of this.layers) {
            let i = 0;
            for (const v of layer)
                this.verticesToX[v] = i++;
        }
    }
    // gives the order of the vertices in the y-layer
    // <value></value>
    get x() {
        if (this.verticesToX != null)
            return this.verticesToX;
        this.verticesToX = new Array(this.y.length);
        this.UpdateXFromLayers();
        return this.verticesToX;
    }
    // returns the layer hierarchy where the order of the layers is reversed
    ReversedClone() {
        const rv = new Array(this.y.length);
        const lastLayer = this.Layers.length - 1; //call Layers to ensure that the layers are calculated
        for (let i = 0; i < this.y.length; i++)
            rv[i] = lastLayer - this.y[i];
        return new LayerArrays(rv);
    }
    // Layers[i] is the array of vertices of i-th layer
    get Layers() {
        if (this.layers != null)
            return this.layers;
        this.InitLayers();
        return this.layers;
    }
    set Layers(value) {
        this.layers = value;
    }
    InitLayers() {
        //find the number of layers
        let nOfLayers = 0;
        for (const l of this.y) {
            if (l + 1 > nOfLayers)
                nOfLayers = l + 1;
        }
        const counts = new Array(nOfLayers).fill(0);
        //find the number of vertices in the layer
        for (const l of this.y)
            counts[l]++;
        this.layers = new Array(nOfLayers);
        for (let i = 0; i < nOfLayers; i++) {
            this.layers[i] = new Array(counts[i]);
            counts[i] = 0; //we reuse these counts below
        }
        for (let i = 0; i < this.y.length; i++) {
            const l = this.y[i];
            this.layers[l][counts[l]++] = i;
        }
        /*Assert.assert(layersAreCorrect(this))*/
    }
}
function layersAreCorrect(layerArrays) {
    if (layerArrays.layers == null)
        return true;
    for (const layer of layerArrays.layers) {
        if (layerHasDublicatesOrUndef(layer)) {
            return false;
        }
    }
    return true;
}
function layerHasDublicatesOrUndef(layer) {
    const s = new Set();
    for (const v of layer) {
        if (v == null) {
            return true;
        }
        if (s.has(v))
            return true;
        s.add(v);
    }
    return false;
}
//# sourceMappingURL=LayerArrays.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/LayerInserter.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayerInserter: () => (/* binding */ LayerInserter)
/* harmony export */ });
/* harmony import */ var _EdgePathsInserter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/EdgePathsInserter.js");
/* harmony import */ var _LayerArrays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/LayerArrays.js");
/* harmony import */ var _layerEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layerEdge.js");
/* harmony import */ var _ProperLayeredGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/ProperLayeredGraph.js");




// Preparing the graph for x-coordinate calculation by inserting dummy nodes into the layers
class LayerInserter {
    constructor(layeredGraph, la, database, intGraphP) {
        this.la = la;
        this.database = database;
        this.layeredGraph = layeredGraph;
        this.intGraph = intGraphP;
    }
    // the entry point of the class
    static InsertLayers(layeredGraph, la, db, intGraphP) {
        const li = new LayerInserter(layeredGraph, la, db, intGraphP);
        li.InsertLayers();
        return {
            layeredGraph: li.nLayeredGraph,
            la: li.Nla.DropEmptyLayers(),
        };
    }
    // new Y-layering
    get NLayering() {
        return this.Nla.y;
    }
    // does the main work
    InsertLayers() {
        this.EditOldLayering();
        this.CreateFullLayeredGraph();
        this.InitNewLayering();
        this.MapVirtualNodesToEdges();
        this.FillUnsortedNewOddLayers();
        this.WidenOriginalLayers();
        this.SortNewOddLayers();
    }
    // virtual nodes inside of an edge should be of the form i,i+1, ....
    EditOldLayering() {
        let curVNode = this.intGraph.nodeCount;
        for (const list of this.database.RegularMultiedges()) {
            let span = 0;
            const e = list[0];
            span = e.LayerSpan * 2;
            if (span > 0) {
                //ignoring flat edges
                for (const le of e.LayerEdges) {
                    if (le.Target !== e.target) {
                        curVNode++;
                        this.UpdateOldLayer(curVNode++, le.Target);
                    }
                }
                curVNode += (span - 1) * (list.length - 1) + 1;
            }
        }
    }
    UpdateOldLayer(replacingNode, prevNode) {
        const x = this.la.x[prevNode];
        const y = this.la.y[prevNode];
        const layer = this.la.Layers[y];
        layer[x] = replacingNode;
        //  this.la.x[replacingNode] = x;
        // this.la.y[replacingNode] = y;
    }
    // Original layers are represented by even layers of the new layering.
    // Here we add new virtices of such layers and
    // set new x-offsets of original and dummy vertices of these layers.
    WidenOriginalLayers() {
        for (let i = 0; i < this.la.Layers.length; i++) {
            const layer = this.Nla.Layers[i * 2];
            let offset = 0;
            for (const v of this.la.Layers[i]) {
                const e = this.virtNodesToIntEdges[v];
                if (e != null) {
                    const layerOffsetInTheEdge = this.NLayering[e.source] - this.NLayering[v];
                    const list = this.database.Multiedges.get(e.source, e.target);
                    for (const ie of list) {
                        if (ie !== e) {
                            const u = ie.LayerEdges[layerOffsetInTheEdge].Source;
                            layer[offset] = u;
                            this.Nla.x[u] = offset++;
                        }
                        else {
                            layer[offset] = v;
                            this.Nla.x[v] = offset++;
                        }
                    }
                }
                else {
                    layer[offset] = v;
                    this.Nla.x[v] = offset++;
                }
            }
        }
    }
    // filling new layers not corresponding to the original layers
    FillUnsortedNewOddLayers() {
        const c = new Array(this.Nla.Layers.length).fill(0);
        for (let i = this.intGraph.nodeCount; i < this.nLayeredGraph.NodeCount; i++) {
            const layer = this.NLayering[i];
            if (layer % 2 === 1) {
                //new layers have odd numbers
                this.Nla.Layers[layer][c[layer]++] = i;
            }
        }
    }
    // create the mapping from the vertices to edges to which they belong
    MapVirtualNodesToEdges() {
        this.virtNodesToIntEdges = new Array(this.NLayering.length);
        for (const e of this.database.AllIntEdges())
            if (e.source !== e.target && e.LayerEdges != null)
                for (const le of e.LayerEdges)
                    if (le.Target !== e.target)
                        this.virtNodesToIntEdges[le.Target] = e;
    }
    // Creating buckets for multi edges and allocating the graph.
    CreateFullLayeredGraph() {
        this.totalNodes = this.intGraph.nodeCount;
        for (const list of this.database.RegularMultiedges()) {
            let span = 0;
            let first = true;
            for (const e of list) {
                if (first) {
                    first = false;
                    span = e.LayerSpan * 2;
                }
                if (span > 0) {
                    e.LayerEdges = new Array(span);
                    for (let i = 0; i < span; i++) {
                        const bT = { currentVV: this.totalNodes };
                        const source = _EdgePathsInserter__WEBPACK_IMPORTED_MODULE_0__.EdgePathsInserter.GetSource(bT, e, i);
                        this.totalNodes = bT.currentVV;
                        const target = _EdgePathsInserter__WEBPACK_IMPORTED_MODULE_0__.EdgePathsInserter.GetTarget(this.totalNodes, e, i, span);
                        e.LayerEdges[i] = new _layerEdge__WEBPACK_IMPORTED_MODULE_2__.LayerEdge(source, target, e.CrossingWeight);
                    }
                    LayerInserter.RegisterDontStepOnVertex(this.database, e);
                }
            }
        }
        this.nLayeredGraph = new _ProperLayeredGraph__WEBPACK_IMPORTED_MODULE_3__.ProperLayeredGraph(this.intGraph);
    }
    // Sort new odd layers by the sum of x-coordinatates of predecessors and the successors of
    // dummy nodes.
    SortNewOddLayers() {
        for (let i = 1; i < this.Nla.Layers.length; i += 2) {
            const sd = new Map();
            const layer = this.Nla.Layers[i];
            for (const v of layer) {
                //find unique predecessor and successor
                let predecessor = -1;
                for (const ie of this.nLayeredGraph.InEdges(v))
                    predecessor = ie.Source;
                let successor = -1;
                for (const ie of this.nLayeredGraph.OutEdges(v))
                    successor = ie.Target;
                const x = this.Nla.x[predecessor] + this.Nla.x[successor];
                if (sd.has(x)) {
                    const o = sd.get(x);
                    if (typeof o === 'number') {
                        const l = new Array();
                        l.push(o);
                        l.push(v);
                        sd.set(x, l);
                    }
                    else {
                        const l = o;
                        l.push(v);
                    }
                }
                else {
                    sd.set(x, v);
                }
            }
            // Create a sorted array from the Map
            const sortedEntries = Array.from(sd.entries()).sort((a, b) => a[0] - b[0]);
            //fill the layer according to this order
            let c = 0;
            for (const v of sortedEntries.map(e => e[1]))
                if (typeof v === 'number') {
                    layer[c++] = v;
                }
                else {
                    for (const k of v) {
                        layer[c++] = k;
                    }
                }
            //update X now
            for (let m = 0; m < layer.length; m++)
                this.Nla.x[layer[m]] = m;
        }
    }
    // Allocating new layering and filling its y-layers
    InitNewLayering() {
        this.Nla = new _LayerArrays__WEBPACK_IMPORTED_MODULE_1__.LayerArrays(new Array(this.totalNodes));
        for (let i = 0; i < this.layeredGraph.NodeCount; i++)
            this.NLayering[i] = this.la.y[i] * 2;
        for (const [ip, v] of this.database.Multiedges.keyValues()) {
            if (ip.x !== ip.y && this.la.y[ip.x] !== this.la.y[ip.y]) {
                //not a self edge and not a flat edge
                const top = this.la.y[ip.x] * 2;
                for (const e of v) {
                    let layer = top - 1;
                    //Assert.assert(e.LayerEdges !== undefined && e.LayerEdges != null)
                    for (const le of e.LayerEdges)
                        if (le.Target !== e.target)
                            this.NLayering[le.Target] = layer--;
                }
            }
        }
        const newLayers = new Array(2 * this.la.Layers.length - 1);
        //count new layer widths
        const counts = new Array(newLayers.length).fill(0);
        for (const l of this.NLayering)
            counts[l]++;
        for (let i = 0; i < counts.length; i++)
            newLayers[i] = new Array(counts[i]);
        this.Nla = new _LayerArrays__WEBPACK_IMPORTED_MODULE_1__.LayerArrays(this.NLayering);
        this.Nla.Layers = newLayers;
    }
    // mark the vertex as one representing a label
    // or a middle of a multi edge
    static RegisterDontStepOnVertex(db, parent) {
        if (db.Multiedges.get(parent.source, parent.target).length > 1) {
            const e = parent.LayerEdges[Math.floor(parent.LayerEdges.length / 2)];
            db.MultipleMiddles.add(e.Source);
        }
    }
}
//# sourceMappingURL=LayerInserter.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/NodeKind.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeKind: () => (/* binding */ NodeKind)
/* harmony export */ });
var NodeKind;
(function (NodeKind) {
    NodeKind[NodeKind["Top"] = 0] = "Top";
    NodeKind[NodeKind["Internal"] = 1] = "Internal";
    NodeKind[NodeKind["Bottom"] = 2] = "Bottom";
})(NodeKind || (NodeKind = {}));
//# sourceMappingURL=NodeKind.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/ProperLayeredGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProperLayeredGraph: () => (/* binding */ ProperLayeredGraph)
/* harmony export */ });
/* harmony import */ var _structs_BasicGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/BasicGraph.js");

// a class representing a graph where every edge goes down only one layer
class ProperLayeredGraph {
    constructor(intGraph) {
        this.Initialize(intGraph);
    }
    Initialize(intGraph) {
        this.BaseGraph = intGraph;
        this.totalNumberOfNodes = intGraph.nodeCount;
        for (const edge of this.BaseGraph.edges) {
            if (edge.LayerEdges == null)
                continue;
            for (const layerEdge of edge.LayerEdges) {
                const m = Math.max(layerEdge.Source, layerEdge.Target) + 1;
                if (m > this.totalNumberOfNodes)
                    this.totalNumberOfNodes = m;
            }
        }
        this.firstVirtualNode = Number.POSITIVE_INFINITY;
        for (const e of this.BaseGraph.edges) {
            if (e.LayerEdges == null) {
                continue;
            }
            for (let i = 1; i < e.LayerEdges.length; i++) {
                const le = e.LayerEdges[i];
                // Assert.assert(le.Source !== e.source)
                this.firstVirtualNode = Math.min(this.firstVirtualNode, le.Source);
            }
        }
        if (this.firstVirtualNode === Number.POSITIVE_INFINITY) {
            this.firstVirtualNode = this.BaseGraph.nodeCount;
            this.totalNumberOfNodes = this.BaseGraph.nodeCount;
        }
        this.virtualNodesToInEdges = new Array(this.totalNumberOfNodes - this.firstVirtualNode);
        this.virtualNodesToOutEdges = new Array(this.totalNumberOfNodes - this.firstVirtualNode);
        for (const e of this.BaseGraph.edges)
            if (e.LayerSpan > 0)
                for (const le of e.LayerEdges) {
                    if (le.Target !== e.target)
                        this.virtualNodesToInEdges[le.Target - this.firstVirtualNode] = le;
                    if (le.Source !== e.source)
                        this.virtualNodesToOutEdges[le.Source - this.firstVirtualNode] = le;
                }
    }
    // enumerates over the graph edges
    *edges_() {
        for (const ie of this.BaseGraph.edges) {
            if (ie.LayerSpan > 0)
                for (const le of ie.LayerEdges)
                    yield le;
        }
    }
    get Edges() {
        return this.edges_();
    }
    // enumerates over edges of a node
    *InEdges(node) {
        if (node < this.BaseGraph.nodeCount)
            //original node
            for (const e of this.BaseGraph.inEdges[node]) {
                if (e.source !== e.target && e.LayerEdges != null)
                    yield ProperLayeredGraph.LastEdge(e);
            }
        else if (node >= this.firstVirtualNode)
            yield this.InEdgeOfVirtualNode(node);
    }
    static LastEdge(e) {
        return e.LayerEdges[e.LayerEdges.length - 1];
    }
    InEdgeOfVirtualNode(node) {
        return this.virtualNodesToInEdges[node - this.firstVirtualNode];
    }
    // enumerates over the node outcoming edges
    *OutEdges(node) {
        if (node < this.BaseGraph.nodeCount)
            //original node
            for (const e of this.BaseGraph.outEdges[node]) {
                if (e.source !== e.target && e.LayerEdges != null)
                    yield ProperLayeredGraph.FirstEdge(e);
            }
        else if (node >= this.firstVirtualNode)
            yield this.OutEdgeOfVirtualNode(node);
    }
    OutDegreeIsMoreThanOne(node) {
        if (node < this.BaseGraph.nodeCount)
            //original node
            return this.BaseGraph.outEdges[node].length > 1;
        else
            return false;
    }
    InDegreeIsMoreThanOne(node) {
        if (node < this.BaseGraph.nodeCount)
            //original node
            return this.BaseGraph.inEdges[node].length > 1;
        else
            return false;
    }
    OutEdgeOfVirtualNode(node) {
        return this.virtualNodesToOutEdges[node - this.firstVirtualNode];
    }
    static FirstEdge(e) {
        return e.LayerEdges[0];
    }
    // returns the number of incoming edges for an edge
    InEdgesCount(node) {
        return this.RealInEdgesCount(node);
    }
    RealInEdgesCount(node) {
        return node < this.BaseGraph.nodeCount ? this.BaseGraph.inEdges[node].filter((e) => e.LayerEdges != null).length : 1;
    }
    // returns the number of outcoming edges for an edge
    OutEdgesCount(node) {
        return this.RealOutEdgesCount(node);
    }
    RealOutEdgesCount(node) {
        return node < this.BaseGraph.nodeCount ? this.BaseGraph.outEdges[node].filter((l) => l.LayerEdges != null).length : 1;
    }
    // returns the node count
    get NodeCount() {
        return this.totalNumberOfNodes;
    }
    IsRealNode(node) {
        return node < this.BaseGraph.nodeCount;
    }
    IsVirtualNode(node) {
        return !this.IsRealNode(node);
    }
    ReversedClone() {
        const reversedEdges = this.CreateReversedEdges();
        return new ProperLayeredGraph(new _structs_BasicGraph__WEBPACK_IMPORTED_MODULE_0__.BasicGraph(reversedEdges, this.BaseGraph.nodeCount));
    }
    CreateReversedEdges() {
        const ret = new Array();
        for (const e of this.BaseGraph.edges)
            if (!e.isSelfEdge())
                ret.push(e.reversedClone());
        return ret;
    }
    *Succ(node) {
        for (const le of this.OutEdges(node))
            yield le.Target;
    }
    *Pred(node) {
        for (const le of this.InEdges(node))
            yield le.Source;
    }
}
//# sourceMappingURL=ProperLayeredGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/RefinerBetweenTwoLayers.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RefinerBetweenTwoLayers: () => (/* binding */ RefinerBetweenTwoLayers),
/* harmony export */   getAnchorDebugCurve: () => (/* binding */ getAnchorDebugCurve)
/* harmony export */ });
/* harmony import */ var _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/cornerSite.js");
/* harmony import */ var _math_geometry_curveFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curveFactory.js");
/* harmony import */ var _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/debugCurve.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");
/* harmony import */ var _NodeKind__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/NodeKind.js");



//import{ {DebugCurve} from '../../math/geometry/}DebugCurve'





class RefinerBetweenTwoLayers {
    constructor(topNodeP, bottomNodeP, topSiteP, layerArraysP, layeredGraphP, originalGraphP, anchorsP, layerSeparation) {
        this.topNode = topNodeP;
        this.bottomNode = bottomNodeP;
        this.topSite = topSiteP;
        this.bottomSite = topSiteP.next;
        this.currentTopSite = topSiteP;
        this.currentBottomSite = topSiteP.next;
        this.layerArrays = layerArraysP;
        this.layeredGraph = layeredGraphP;
        this.originalGraph = originalGraphP;
        this.anchors = anchorsP;
        this.layerSeparation = layerSeparation;
    }
    static Refine(topNodeP, bottomNode, topSiteP, anchors, layerArraysP, layeredGraph, originalGraph, layerSeparation) {
        const refiner = new RefinerBetweenTwoLayers(topNodeP, bottomNode, topSiteP, layerArraysP, layeredGraph, originalGraph, anchors, layerSeparation);
        refiner.Refine();
    }
    Refine() {
        this.Init();
        while (this.InsertSites()) { }
    }
    FixCorner(start, corner, end) {
        if (start.equal(corner)) {
            return corner;
        }
        const a = _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.ClosestPointAtLineSegment(corner, start, end);
        let offsetInTheChannel = corner.sub(a);
        const y = Math.abs(offsetInTheChannel.y);
        const sep = this.layerSeparation / 2;
        if (y > sep) {
            offsetInTheChannel = offsetInTheChannel.mul(sep / (y * 2));
        }
        return offsetInTheChannel.add(corner);
    }
    InsertSites() {
        if ((0,_utils_random__WEBPACK_IMPORTED_MODULE_6__.randomInt)(2) === 0) {
            return this.CalculateNewTopSite() || this.CalculateNewBottomSite();
        }
        else {
            return this.CalculateNewBottomSite() || this.CalculateNewTopSite();
        }
    }
    // circimvating from the side
    CalculateNewBottomSite() {
        const mainSeg = this.currentBottomSite.point.sub(this.currentTopSite.point);
        let cotan = RefinerBetweenTwoLayers.absCotan(mainSeg);
        let vOfNewSite;
        let someBottomCorners = false;
        for (const p of this.bottomCorners()) {
            const cornerCotan = RefinerBetweenTwoLayers.absCotan(p.sub(this.currentBottomSite.point));
            if (cornerCotan < cotan) {
                cotan = cornerCotan;
                vOfNewSite = p;
                someBottomCorners = true;
            }
        }
        if (!someBottomCorners) {
            return false;
        }
        if (!(0,_utils_compare__WEBPACK_IMPORTED_MODULE_5__.closeDistEps)(cotan, RefinerBetweenTwoLayers.absCotan(mainSeg))) {
            this.currentBottomSite = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_0__.CornerSite.mkSiteSPS(this.currentTopSite, this.FixCorner(this.currentTopSite.point, vOfNewSite, this.currentBottomSite.point), this.currentBottomSite);
            // consider a different FixCorner
            return true;
        }
        return false;
        // no progress
    }
    static absCotan(mainSeg) {
        return Math.abs(mainSeg.x / mainSeg.y);
    }
    CalculateNewTopSite() {
        const mainSeg = this.currentBottomSite.point.sub(this.currentTopSite.point);
        let cotan = RefinerBetweenTwoLayers.absCotan(mainSeg);
        let vOfNewSite;
        let someTopCorners = false;
        for (const p of this.topCorners()) {
            const cornerCotan = RefinerBetweenTwoLayers.absCotan(p.sub(this.currentTopSite.point));
            if (cornerCotan < cotan) {
                cotan = cornerCotan;
                vOfNewSite = p;
                someTopCorners = true;
            }
        }
        if (!someTopCorners) {
            return false;
        }
        if (!(0,_utils_compare__WEBPACK_IMPORTED_MODULE_5__.closeDistEps)(cotan, RefinerBetweenTwoLayers.absCotan(mainSeg))) {
            this.currentTopSite = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_0__.CornerSite.mkSiteSPS(this.currentTopSite, this.FixCorner(this.currentTopSite.point, vOfNewSite, this.currentBottomSite.point), this.currentBottomSite);
            // consider a different FixCorner
            return true;
        }
        return false;
        // no progress
    }
    // private CornerSite AvoidBottomLayer() {
    //    Point corner;
    //    if (StickingCornerFromTheBottomLayer(out corner)) {
    //        corner = FixCorner(this.currentTopSite.v, corner, this.currentBottomSite.v);
    //        return new CornerSite(this.currentTopSite, corner, this.currentBottomSite);
    //    } else
    //        return null;
    // }
    // private CornerSite AvoidTopLayer() {
    //    Point corner;
    //    if (StickingCornerFromTheTopLayer(out corner)) {
    //        corner = FixCorner(this.currentTopSite.v, corner, this.currentBottomSite.v);
    //        return new CornerSite(this.currentTopSite, corner, this.currentBottomSite);
    //    } else
    //        return null;
    // }
    // private bool StickingCornerFromTheTopLayer(out Point corner) {
    //    corner = this.currentBottomSite.v;
    //    foreach (Point l of this.topCorners()) {
    //        Point p = l;
    //        if (this.counterClockwise(ref currentTopSite.v, ref p, ref corner))
    //            corner = p;
    //    }
    //    return corner !== this.currentBottomSite.v;
    // }
    // private bool StickingCornerFromTheBottomLayer(out Point corner) {
    //    corner = this.currentTopSite.v;
    //    foreach (Point l of this.bottomCorners()) {
    //        Point p = l;
    //        if (this.counterClockwise(ref currentBottomSite.v, ref p, ref corner))
    //            corner = p;
    //    }
    //    return corner !== this.currentTopSite.v;
    // }
    Init() {
        if (this.IsTopToTheLeftOfBottom()) {
            this.topCorners = () => this.CornersToTheRightOfTop();
            this.bottomCorners = () => this.CornersToTheLeftOfBottom();
        }
        else {
            this.topCorners = () => this.CornersToTheLeftOfTop();
            this.bottomCorners = () => this.CornersToTheRightOfBottom();
        }
    }
    IsTopToTheLeftOfBottom() {
        return this.topSite.point.x < this.topSite.next.point.x;
    }
    *NodeCorners(node) {
        for (const p of this.anchors[node].polygonalBoundary.polylinePoints()) {
            yield p.point;
        }
    }
    *CornersToTheLeftOfBottom() {
        const bottomPosition = this.layerArrays.x[this.bottomNode];
        const leftMost = this.currentTopSite.point.x;
        const rightMost = this.currentBottomSite.point.x;
        for (const node of this.LeftFromTheNode(this.NodeLayer(this.bottomNode), bottomPosition, _NodeKind__WEBPACK_IMPORTED_MODULE_7__.NodeKind.Bottom, leftMost, rightMost)) {
            for (const p of this.NodeCorners(node)) {
                if (p.y > this.currentBottomSite.point.y && RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p)) {
                    yield p;
                }
            }
        }
    }
    *CornersToTheLeftOfTop() {
        const topPosition = this.layerArrays.x[this.topNode];
        const leftMost = this.currentBottomSite.point.x;
        const rightMost = this.currentTopSite.point.x;
        for (const node of this.LeftFromTheNode(this.NodeLayer(this.topNode), topPosition, _NodeKind__WEBPACK_IMPORTED_MODULE_7__.NodeKind.Top, leftMost, rightMost)) {
            for (const p of this.NodeCorners(node)) {
                if (p.y < this.currentTopSite.point.y && RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p)) {
                    yield p;
                }
            }
        }
    }
    *CornersToTheRightOfBottom() {
        const bottomPosition = this.layerArrays.x[this.bottomNode];
        const leftMost = this.currentBottomSite.point.x;
        const rightMost = this.currentTopSite.point.x;
        for (const node of this.RightFromTheNode(this.NodeLayer(this.bottomNode), bottomPosition, _NodeKind__WEBPACK_IMPORTED_MODULE_7__.NodeKind.Bottom, leftMost, rightMost)) {
            for (const p of this.NodeCorners(node)) {
                if (p.y > this.currentBottomSite.point.y && RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p)) {
                    yield p;
                }
            }
        }
    }
    *CornersToTheRightOfTop() {
        const topPosition = this.layerArrays.x[this.topNode];
        const leftMost = this.currentTopSite.point.x;
        const rightMost = this.currentBottomSite.point.x;
        for (const node of this.RightFromTheNode(this.NodeLayer(this.topNode), topPosition, _NodeKind__WEBPACK_IMPORTED_MODULE_7__.NodeKind.Top, leftMost, rightMost)) {
            for (const p of this.NodeCorners(node)) {
                if (p.y < this.currentTopSite.point.y && RefinerBetweenTwoLayers.PossibleCorner(leftMost, rightMost, p)) {
                    yield p;
                }
            }
        }
    }
    static PossibleCorner(leftMost, rightMost, p) {
        return p.x > leftMost && p.x < rightMost;
    }
    NodeLayer(j) {
        return this.layerArrays.Layers[this.layerArrays.y[j]];
    }
    IsLabel(u) {
        return this.anchors[u].hasLabel;
    }
    NodeUCanBeCrossedByNodeV(u, v) {
        if (this.IsLabel(u) || this.IsLabel(v)) {
            return false;
        }
        if (this.IsVirtualVertex(u) && this.IsVirtualVertex(v) && this.AdjacentEdgesIntersect(u, v)) {
            return true;
        }
        return false;
    }
    AdjacentEdgesIntersect(u, v) {
        return this.Intersect(this.IncomingEdge(u), this.IncomingEdge(v)) || this.Intersect(this.OutcomingEdge(u), this.OutcomingEdge(v));
    }
    Intersect(e, m) {
        return (this.layerArrays.x[e.Source] - this.layerArrays.x[m.Source]) * (this.layerArrays.x[e.Target] - this.layerArrays.x[m.Target]) < 0;
    }
    IncomingEdge(u) {
        for (const le of this.layeredGraph.InEdges(u)) {
            return le;
        }
        throw new Error();
    }
    // here u is a virtual vertex
    OutcomingEdge(u) {
        for (const le of this.layeredGraph.OutEdges(u)) {
            return le;
        }
        throw new Error();
    }
    IsVirtualVertex(v) {
        return v >= this.originalGraph.shallowNodeCount;
    }
    *RightFromTheNode(layer, vPosition, nodeKind, leftMostX, rightMostX) {
        let b = 0;
        let t = 0;
        if (nodeKind === _NodeKind__WEBPACK_IMPORTED_MODULE_7__.NodeKind.Bottom) {
            b = Number.MAX_VALUE;
        }
        // we don't have bottom boundaries here since they will be cut off
        if (nodeKind === _NodeKind__WEBPACK_IMPORTED_MODULE_7__.NodeKind.Top) {
            t = Number.MAX_VALUE;
        }
        // we don't have top boundaries here since they will be cut off
        const v = layer[vPosition];
        for (let i = vPosition + 1; i < layer.length; i++) {
            const u = layer[i];
            if (this.NodeUCanBeCrossedByNodeV(u, v)) {
                continue;
            }
            const anchor = this.anchors[u];
            if (anchor.left >= rightMostX) {
                break;
            }
            if (anchor.right > leftMostX) {
                if (anchor.topAnchor > t + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
                    t = anchor.topAnchor;
                    yield u;
                }
                else if (anchor.bottomAnchor > b + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
                    b = anchor.bottomAnchor;
                    yield u;
                }
            }
        }
    }
    *LeftFromTheNode(layer, vPosition, nodeKind, leftMostX, rightMostX) {
        let b = 0;
        let t = 0;
        if (nodeKind === _NodeKind__WEBPACK_IMPORTED_MODULE_7__.NodeKind.Bottom) {
            b = Number.MAX_VALUE;
        }
        // we don't have bottom boundaries here since they will be cut off
        if (nodeKind === _NodeKind__WEBPACK_IMPORTED_MODULE_7__.NodeKind.Top) {
            t = Number.MAX_VALUE;
        }
        // we don't have top boundaries here since they will be cut off
        const v = layer[vPosition];
        for (let i = vPosition - 1; i > -1; i--) {
            const u = layer[i];
            if (this.NodeUCanBeCrossedByNodeV(u, v)) {
                continue;
            }
            const anchor = this.anchors[u];
            if (anchor.right <= leftMostX) {
                break;
            }
            if (anchor.left < rightMostX) {
                if (anchor.topAnchor > t + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
                    t = anchor.topAnchor;
                    yield u;
                }
                else if (anchor.bottomAnchor > b + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
                    b = anchor.bottomAnchor;
                    yield u;
                }
            }
        }
    }
}
function getAnchorDebugCurve(a) {
    return _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(100, 1, 'black', a.polygonalBoundary);
}
function getCornerDebugCurve(p, color) {
    return _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(200, 2, color, _math_geometry_curveFactory__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkCircle(10, p));
}
//# sourceMappingURL=RefinerBetweenTwoLayers.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/anchor.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Anchor: () => (/* binding */ Anchor)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
// Defines the anchors for a node; anchors can be not symmetrical in general
//
//          |TopAnchor
//Left anchor|
// ======Origin==================RightAnchor
//          |
//          |
//          |BottomAnchor




class Anchor {
    // ToString
    toString() {
        return 'la:ra ' + this.la + ' ' + this.ra + ' ta:ba ' + this.ta + ' ' + this.ba + ' x:y ' + this.x_ + ' ' + this.y_;
    }
    // distance for the center of the node to its left boundary
    get leftAnchor() {
        return this.la;
    }
    set leftAnchor(value) {
        //the absence of this check allows a situation when an edge crosses its label or
        // a label which does not belong to the edge
        //      if(value<-Curve.DistEps)
        //      throw new Exception("assigning negative value to a anchor");
        this.la = Math.max(value, 0);
    }
    // distance from the center of the node to its right boundary
    get rightAnchor() {
        return this.ra;
    }
    set rightAnchor(value) {
        //  if(value<-Curve.DistEps)
        //  throw new Exception("assigning negative value to a anchor: "+value );
        this.ra = Math.max(value, 0);
    }
    // distance from the center of the node to its top boundary
    get topAnchor() {
        return this.ta;
    }
    set topAnchor(value) {
        //if(value<-Curve.DistEps)
        //throw new Exception("assigning negative value to a anchor");
        this.ta = Math.max(value, 0);
    }
    get bottomAnchor() {
        return this.ba;
    }
    set bottomAnchor(value) {
        //if(value<-Curve.DistEps)
        //throw new Error();//"assigning negative value to a anchor");
        this.ba = Math.max(value, 0);
    }
    // Left boundary of the node
    get left() {
        return this.x_ - this.la;
    }
    // right boundary of the node
    get right() {
        return this.x_ + this.ra;
    }
    // top boundary of the node
    get top() {
        return this.y_ + this.ta;
    }
    set top(value) {
        this.y_ += value - this.ta;
    }
    // bottom of the node
    get bottom() {
        return this.y_ - this.ba;
    }
    set bottom(value) {
        this.y_ += value - this.ba;
    }
    get leftTop() {
        return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.left, this.top);
    }
    get leftBottom() {
        return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.left, this.bottom);
    }
    // this.right bottom of the node
    get rightBottom() {
        return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.right, this.bottom);
    }
    get node() {
        return this.node_;
    }
    set node(value) {
        this.node_ = value;
        this.polygonalBoundary_ = null;
    }
    // Right top of the node
    get rightTop() {
        return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.right, this.top);
    }
    constructor(labelCornersPreserveCoefficient) {
        this.padding = 0;
        this.alreadySitsOnASpline = false;
        // An anchor for an edge label with the label to the left of the spline has its height equal to the one of the label
        // Its rightAnchor is a reserved space for the spline and the leftAnchor is equal to the label width.
        this.labelIsToTheLeftOfTheSpline = false;
        // An anchor for an edge label with the label to the right of the spline has its height equal to the one of the label
        // Its leftAnchor is a reserved space for the spline and the rightAnchor is equal to the label width.
        this.labelIsToTheRightOfTheSpline = false;
        /*Assert.assert(
          0 <= labelCornersPreserveCoefficient &&
            labelCornersPreserveCoefficient <= 1,
        )*/
        this.labelCornersPreserveCoefficient = labelCornersPreserveCoefficient;
    }
    // constructor
    static mkAnchor(leftAnchor, rightAnchor, topAnchor, bottomAnchor, node, labelCornersPreserveCoefficient) {
        const a = new Anchor(labelCornersPreserveCoefficient);
        a.la = leftAnchor;
        a.ra = rightAnchor;
        a.ta = topAnchor;
        a.ba = bottomAnchor;
        a.node = node;
        return a;
    }
    // the x position
    get x() {
        return this.x_;
    }
    set x(value) {
        this.polygonalBoundary_ = null;
        this.x_ = value;
    }
    get y() {
        return this.y_;
    }
    set y(value) {
        this.polygonalBoundary_ = null;
        this.y_ = value;
    }
    // Center of the node
    get origin() {
        return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y);
    }
    get width() {
        return this.la + this.ra;
    }
    get height() {
        return this.ta + this.ba;
    }
    // set to true if the anchor has been introduced for a label
    get hasLabel() {
        return this.labelIsToTheLeftOfTheSpline || this.labelIsToTheLeftOfTheSpline;
    }
    get LabelWidth() {
        if (this.labelIsToTheLeftOfTheSpline)
            return this.leftAnchor;
        if (this.labelIsToTheRightOfTheSpline)
            return this.rightAnchor;
        throw new Error();
    }
    // the polygon representing the boundary of a node
    get polygonalBoundary() {
        if (this.polygonalBoundary_ != null)
            return this.polygonalBoundary_;
        return (this.polygonalBoundary_ = Anchor.pad(this.creatPolygonalBoundaryWithoutPadding(), this.padding));
    }
    static pad(curve, padding) {
        if (padding === 0)
            return curve;
        if (Anchor.curveIsConvex(curve)) {
            return Anchor.padConvexCurve(curve, padding);
        }
        else
            return Anchor.padConvexCurve(curve.boundingBox.perimeter(), padding);
    }
    static padCorner(poly, p0, p1, p2, padding) {
        const cornerInfo = Anchor.getPaddedCorner(p0, p1, p2, padding);
        poly.addPoint(cornerInfo.a);
        if (cornerInfo.numberOfPoints === 2)
            poly.addPoint(cornerInfo.b);
    }
    static padConvexCurve(poly, padding) {
        const ret = new _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_1__.Polyline();
        Anchor.padCorner(ret, poly.endPoint.prev, poly.endPoint, poly.startPoint, padding);
        Anchor.padCorner(ret, poly.endPoint, poly.startPoint, poly.startPoint.next, padding);
        for (let pp = poly.startPoint; pp.next.next != null; pp = pp.next)
            Anchor.padCorner(ret, pp, pp.next, pp.next.next, padding);
        ret.closed = true;
        return ret;
    }
    static getPaddedCorner(first, second, third, padding) {
        const u = first.point;
        const v = second.point;
        const w = third.point;
        const ccw = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(u, v, w) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Counterclockwise;
        const uv = v.sub(u);
        //uvPerp has to look outside of the curve
        const uvPerp = uv.rotate((ccw ? -Math.PI : Math.PI) / 2).normalize();
        //l is bisector of the corner (u,v,w) pointing out of the corner - outside of the polyline
        const l = uv.normalize().add(v.sub(w).normalize());
        if (l.length < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.intersectionEpsilon) {
            return {
                a: v.add(uvPerp.mul(padding)),
                b: null,
                numberOfPoints: 1,
            };
        }
        const d = l.normalize().mul(padding);
        const dp = d.rotate(Math.PI / 2);
        //look for a in the form d+x*dp + v
        //we need to have:  padding = (d+x*dp)*uvPerp
        const xp = (padding - d.dot(uvPerp)) / dp.dot(uvPerp);
        return {
            a: d.add(dp.mul(xp)).add(v),
            b: d.sub(dp.mul(xp)).add(v),
            numberOfPoints: 2, //number of points to add
        };
    }
    static *orientations(poly) {
        yield _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(poly.endPoint.point, poly.startPoint.point, poly.startPoint.next.point);
        yield _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(poly.endPoint.prev.point, poly.endPoint.point, poly.startPoint.point);
        let pp = poly.startPoint;
        while (pp.next.next != null) {
            yield _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(pp.point, pp.next.point, pp.next.next.point);
            pp = pp.next;
        }
    }
    static curveIsConvex(poly) {
        let orientation = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear;
        for (const or of Anchor.orientations(poly)) {
            if (or === _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear)
                continue;
            if (orientation === _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear)
                orientation = or;
            else if (or !== orientation)
                return false;
        }
        return true;
    }
    //private static number TurnAfterSeg(Curve curve, int i) {
    //   return Point.SignedDoubledTriangleArea(curve.segs[i].start, curve.segs[i].End, curve.segs[(i + 1) / curve.segs.Count].End);
    //}
    creatPolygonalBoundaryWithoutPadding() {
        if (this.hasLabel)
            return this.labelIsToTheLeftOfTheSpline ? this.polygonOnLeftLabel() : this.polygonOnRightLabel();
        else if (this.nodeBoundary == null)
            return this.standardRectBoundary();
        else
            return _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.polylineAroundClosedCurve(this.nodeBoundary);
    }
    get nodeBoundary() {
        return this.node == null ? null : this.node.boundaryCurve;
    }
    standardRectBoundary() {
        const poly = new _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_1__.Polyline();
        poly.addPoint(this.leftTop);
        poly.addPoint(this.rightTop);
        poly.addPoint(this.rightBottom);
        poly.addPoint(this.leftBottom);
        poly.closed = true;
        return poly;
    }
    polygonOnLeftLabel() {
        const t = this.left + (1 - this.labelCornersPreserveCoefficient) * this.LabelWidth;
        const poly = _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_1__.Polyline.mkClosedFromPoints([
            new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(t, this.top),
            this.rightTop,
            this.rightBottom,
            new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(t, this.bottom),
            new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.left, this.y),
        ]);
        return poly;
    }
    polygonOnRightLabel() {
        const t = this.right - (1 - this.labelCornersPreserveCoefficient) * this.LabelWidth;
        const poly = _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_1__.Polyline.mkClosedFromPoints([
            new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(t, this.top),
            new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.right, this.y),
            new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(t, this.bottom),
            this.leftBottom,
            this.leftTop,
        ]);
        return poly;
    }
    move(p) {
        this.x += p.x;
        this.y += p.y;
    }
}
//# sourceMappingURL=anchor.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/layerDirectionEnum.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayerDirectionEnum: () => (/* binding */ LayerDirectionEnum)
/* harmony export */ });
var LayerDirectionEnum;
(function (LayerDirectionEnum) {
    LayerDirectionEnum[LayerDirectionEnum["TB"] = 0] = "TB";
    LayerDirectionEnum[LayerDirectionEnum["LR"] = 1] = "LR";
    LayerDirectionEnum[LayerDirectionEnum["BT"] = 2] = "BT";
    LayerDirectionEnum[LayerDirectionEnum["RL"] = 3] = "RL";
    LayerDirectionEnum[LayerDirectionEnum["None"] = 4] = "None";
})(LayerDirectionEnum || (LayerDirectionEnum = {}));
//# sourceMappingURL=layerDirectionEnum.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/layerEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayerEdge: () => (/* binding */ LayerEdge)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");

class LayerEdge {
    constructor(source, target, crossingWeight, weight = 1) {
        this.Source = source;
        this.Target = target;
        this.CrossingWeight = crossingWeight;
        this.Weight = weight;
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0}->{1}', this.Source, this.Target);
    }
}
//# sourceMappingURL=layerEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/layeredLayout.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayeredLayout: () => (/* binding */ LayeredLayout),
/* harmony export */   layoutGraphWithSugiayma: () => (/* binding */ layoutGraphWithSugiayma)
/* harmony export */ });
/* harmony import */ var _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/RealNumberSpan.js");
/* harmony import */ var _structs_BasicGraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/BasicGraph.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/polyIntEdge.js");
/* harmony import */ var _sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/sugiyamaLayoutSettings.js");
/* harmony import */ var _CycleRemoval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/CycleRemoval.js");
/* harmony import */ var _Database__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/Database.js");
/* harmony import */ var _LayerArrays__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/LayerArrays.js");
/* harmony import */ var _core_geomEdge__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomEdge.js");
/* harmony import */ var _core_geomGraph__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");
/* harmony import */ var _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairMap.js");
/* harmony import */ var _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairSet.js");
/* harmony import */ var _Balancing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/Balancing.js");
/* harmony import */ var _ProperLayeredGraph__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/ProperLayeredGraph.js");
/* harmony import */ var _layerEdge__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layerEdge.js");
/* harmony import */ var _EdgePathsInserter__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/EdgePathsInserter.js");
/* harmony import */ var _LayerInserter__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/LayerInserter.js");
/* harmony import */ var _ordering_ordering__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/ordering/ordering.js");
/* harmony import */ var _ordering_metroMapOrdering__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/ordering/metroMapOrdering.js");
/* harmony import */ var _layering_NetworkSimplexForGeneralGraph__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layering/NetworkSimplexForGeneralGraph.js");
/* harmony import */ var _anchor__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/anchor.js");
/* harmony import */ var _xCoordsWithAlignment__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/xCoordsWithAlignment.js");
/* harmony import */ var _xLayoutGraph__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/xLayoutGraph.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _layering_NetworkSimplex__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layering/NetworkSimplex.js");
/* harmony import */ var _routing__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/routing.js");
/* harmony import */ var _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/planeTransformation.js");
/* harmony import */ var _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/EdgeRoutingMode.js");
/* harmony import */ var _driver__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/driver.js");
/* harmony import */ var _routing_StraightLineEdges__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/StraightLineEdges.js");































function layeredLayoutRunner(geomGraph, cancelToken) {
    const ll = new LayeredLayout(geomGraph, geomGraph.layoutSettings, cancelToken);
    ll.run();
}
/** Executes the layered layout following the Sugiyama Scheme.
 * Cancel token allows to cancel the layout run(is ignored by now).
 * If "transformToScreen" is true then the y-coordinate of the graph will be reversed:
 * and the graph will be positioned in the first quadrand with left-bottom = (0,0)
 */
function layoutGraphWithSugiayma(geomGraph, cancelToken, transformToScreen) {
    const ss = geomGraph.layoutSettings ? geomGraph.layoutSettings : new _sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_5__.SugiyamaLayoutSettings();
    (0,_driver__WEBPACK_IMPORTED_MODULE_29__.enforceLayoutSettings)(geomGraph, ss);
    (0,_driver__WEBPACK_IMPORTED_MODULE_29__.layoutGeomGraphDetailed)(geomGraph, cancelToken, layeredLayoutRunner, _driver__WEBPACK_IMPORTED_MODULE_29__.routeEdges, _core_geomGraph__WEBPACK_IMPORTED_MODULE_10__.optimalPackingRunner);
    if (transformToScreen) {
        const flip = new _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_27__.PlaneTransformation(1, 0, -geomGraph.boundingBox.left, 0, -1, geomGraph.top);
        geomGraph.transform(flip);
    }
}
class LayeredLayout extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_3__.Algorithm {
    /** return true if the ratio is less than 1/50 or greater than 50 */
    get extremeAspectRatio() {
        const bb = this.originalGraph.boundingBox;
        const ratio = bb.width / bb.height;
        return ratio < 1 / 50 || ratio > 50;
    }
    get verticalConstraints() {
        return this.sugiyamaSettings.verticalConstraints;
    }
    get HorizontalConstraints() {
        return this.sugiyamaSettings.horizontalConstraints;
    }
    constructor(originalGraph, settings, cancelToken) {
        super(cancelToken);
        this.LayersAreDoubled = false;
        if (originalGraph == null)
            return;
        this.originalGraph = originalGraph;
        this.sugiyamaSettings = settings;
        //enumerate the nodes - maps node indices to strings
        const nodeArray = Array.from(originalGraph.shallowNodes);
        this.nodeIdToIndex = new Map();
        let index = 0;
        for (const n of nodeArray) {
            this.nodeIdToIndex.set(n.id, index++);
        }
        const intEdges = [];
        for (const edge of this.originalGraph.shallowEdges) {
            /*Assert.assert(!(edge.source == null  || edge.target == null ))*/
            const source = this.nodeIdToIndex.get(edge.source.id);
            if (source == null)
                continue;
            const target = this.nodeIdToIndex.get(edge.target.id);
            if (target == null)
                continue;
            const intEdge = new _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__.PolyIntEdge(source, target, edge);
            intEdges.push(intEdge);
        }
        this.IntGraph = new _structs_BasicGraph__WEBPACK_IMPORTED_MODULE_1__.BasicGraph(intEdges, originalGraph.shallowNodeCount);
        this.IntGraph.nodes = nodeArray;
        this.database = new _Database__WEBPACK_IMPORTED_MODULE_7__.Database(nodeArray.length);
        for (const e of this.IntGraph.edges)
            this.database.registerOriginalEdgeInMultiedges(e);
        this.cycleRemoval();
    }
    run() {
        if (this.originalGraph.shallowNodeCount === 0) {
            this.originalGraph.boundingBox = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_24__.Rectangle.mkEmpty();
            return;
        }
        preRunTransform(this.originalGraph, this.sugiyamaSettings.transform);
        this.engineLayerArrays = this.calculateLayers();
        if (this.sugiyamaSettings.edgeRoutingSettings.EdgeRoutingMode === _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_28__.EdgeRoutingMode.SugiyamaSplines) {
            this.runPostLayering();
        }
        postRunTransform(this.originalGraph, this.sugiyamaSettings.transform);
    }
    runPostLayering() {
        const routingSettings = this.sugiyamaSettings.commonSettings.edgeRoutingSettings;
        const mode = this.constrainedOrdering != null ? _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_28__.EdgeRoutingMode.Spline : routingSettings.EdgeRoutingMode;
        if (this.extremeAspectRatio) {
            (0,_routing_StraightLineEdges__WEBPACK_IMPORTED_MODULE_30__.straightLineEdgePatcher)(this.originalGraph, Array.from(this.originalGraph.deepEdges), this.cancelToken);
        }
        else if (mode === _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_28__.EdgeRoutingMode.SugiyamaSplines) {
            this.calculateEdgeSplines();
        }
        else {
            (0,_driver__WEBPACK_IMPORTED_MODULE_29__.routeEdges)(this.originalGraph, Array.from(this.originalGraph.deepEdges), this.cancelToken);
        }
    }
    SetLabels() {
        throw new Error('not implementedt');
        // const edgeLabeller = new EdgeLabelPlacement(originalGraph)
        // edgeLabeller.run()
    }
    cycleRemoval() {
        const verticalConstraints = this.sugiyamaSettings.verticalConstraints;
        const feedbackSet = verticalConstraints.isEmpty
            ? _CycleRemoval__WEBPACK_IMPORTED_MODULE_6__.CycleRemoval.getFeedbackSet(this.IntGraph)
            : verticalConstraints.getFeedbackSetExternal(this.IntGraph, this.nodeIdToIndex);
        this.database.addFeedbackSet(feedbackSet);
    }
    calculateLayers() {
        this.CreateGluedDagSkeletonForLayering();
        const layerArrays = this.CalculateLayerArrays();
        this.UpdateNodePositionData();
        return layerArrays;
    }
    UpdateNodePositionData() {
        for (let i = 0; i < this.IntGraph.nodeCount && i < this.database.Anchors.length; i++)
            this.IntGraph.nodes[i].center = this.database.Anchors[i].origin;
        if (this.sugiyamaSettings.GridSizeByX > 0) {
            for (let i = 0; i < this.originalGraph.shallowNodeCount; i++) {
                this.SnapLeftSidesOfTheNodeToGrid(i, this.sugiyamaSettings.GridSizeByX);
            }
        }
    }
    SnapLeftSidesOfTheNodeToGrid(i, gridSize) {
        const node = this.IntGraph.nodes[i];
        const anchor = this.database.Anchors[i];
        anchor.leftAnchor -= gridSize / 2;
        anchor.rightAnchor -= gridSize / 2;
        const left = node.boundingBox.left;
        const k = Math.floor(left / gridSize);
        const delta = left - k * gridSize;
        if (Math.abs(delta) < 0.001) {
            return;
        }
        // we are free to shift at least gridSize horizontally
        // find the minimal shift
        if (Math.abs(delta) <= gridSize / 2) {
            node.center = node.center.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(-delta, 0));
            // shifting to the left
        }
        else {
            node.center = node.center.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(gridSize - delta, 0));
            // shifting to the right
        }
        anchor.x = node.center.x;
    }
    GetCurrentHeight() {
        const span = new _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_0__.RealNumberSpan();
        for (const anchor of this.NodeAnchors()) {
            span.AddValue(anchor.top);
            span.AddValue(anchor.bottom);
        }
        return span.length;
    }
    *NodeAnchors() {
        const n = Math.min(this.IntGraph.nodeCount, this.anchors.length);
        for (let i = 0; i < n; i++)
            yield this.anchors[i];
    }
    GetCurrentWidth() {
        const span = new _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_0__.RealNumberSpan();
        for (const anchor of this.NodeAnchors()) {
            span.AddValue(anchor.left);
            span.AddValue(anchor.right);
        }
        return span.length;
    }
    ExtendLayeringToUngluedSameLayerVertices(p) {
        const vc = this.verticalConstraints;
        for (let i = 0; i < p.length; i++)
            p[i] = p[vc.nodeToRepr(i)];
        return p;
    }
    calculateEdgeSplines() {
        const routing = new _routing__WEBPACK_IMPORTED_MODULE_26__.Routing(this.sugiyamaSettings, this.originalGraph, this.database, this.engineLayerArrays, this.properLayeredGraph, this.IntGraph);
        routing.run();
    }
    YLayeringAndOrdering(layering) {
        let yLayers = layering.GetLayers();
        _Balancing__WEBPACK_IMPORTED_MODULE_13__.Balancing.Balance(this.gluedDagSkeletonForLayering, yLayers, this.GetNodeCountsOfGluedDag(), null);
        yLayers = this.ExtendLayeringToUngluedSameLayerVertices(yLayers);
        let layerArrays = new _LayerArrays__WEBPACK_IMPORTED_MODULE_8__.LayerArrays(yLayers);
        /*Assert.assert(layersAreCorrect(layerArrays))*/
        if (this.HorizontalConstraints == null || this.HorizontalConstraints.IsEmpty) {
            layerArrays = this.YLayeringAndOrderingWithoutHorizontalConstraints(layerArrays);
            return layerArrays;
        }
        throw new Error('not implemented');
        // this.constrainedOrdering = new ConstrainedOrdering(
        //  this.originalGraph,
        //  this.IntGraph,
        //  layerArrays.y,
        //  this.nodeIdToIndex,
        //  this.database,
        //  this.sugiyamaSettings,
        // )
        // this.constrainedOrdering.Calculate()
        // this.properLayeredGraph = this.constrainedOrdering.ProperLayeredGraph
        // // SugiyamaLayoutSettings.ShowDatabase(this.database);
        // return this.constrainedOrdering.LayerArrays
    }
    // Creating a proper layered graph, a graph where each
    // edge goes only one layer down from the i+1-th layer to the i-th layer.
    CreateProperLayeredGraph(layering) {
        const n = layering.length;
        let nOfVV = 0;
        for (const e of this.database.SkeletonEdges()) {
            const span = EdgeSpan(layering, e);
            // Assert.assert(span >= 0)
            if (span > 0) {
                e.LayerEdges = new Array(span);
            }
            let pe = 0; //offset in the string
            if (span > 1) {
                //we create span-2 dummy nodes and span new edges
                let d0 = n + nOfVV++;
                let layerEdge = new _layerEdge__WEBPACK_IMPORTED_MODULE_15__.LayerEdge(e.source, d0, e.CrossingWeight, e.weight);
                e.LayerEdges[pe++] = layerEdge;
                //create span-2 internal edges all from dummy nodes
                for (let j = 0; j < span - 2; j++) {
                    d0++;
                    nOfVV++;
                    layerEdge = new _layerEdge__WEBPACK_IMPORTED_MODULE_15__.LayerEdge(d0 - 1, d0, e.CrossingWeight, e.weight);
                    e.LayerEdges[pe++] = layerEdge;
                }
                layerEdge = new _layerEdge__WEBPACK_IMPORTED_MODULE_15__.LayerEdge(d0, e.target, e.CrossingWeight, e.weight);
                e.LayerEdges[pe] = layerEdge;
            }
            else if (span === 1) {
                const layerEdge = new _layerEdge__WEBPACK_IMPORTED_MODULE_15__.LayerEdge(e.source, e.target, e.CrossingWeight, e.weight);
                e.LayerEdges[pe] = layerEdge;
            }
        }
        const extendedVertexLayering = new Array(this.originalGraph.shallowNodeCount + nOfVV).fill(0);
        for (const e of this.database.SkeletonEdges())
            if (e.LayerEdges != null) {
                let l = layering[e.source];
                extendedVertexLayering[e.source] = l--;
                for (const le of e.LayerEdges)
                    extendedVertexLayering[le.Target] = l--;
            }
            else {
                extendedVertexLayering[e.source] = layering[e.source];
                extendedVertexLayering[e.target] = layering[e.target];
            }
        this.properLayeredGraph = new _ProperLayeredGraph__WEBPACK_IMPORTED_MODULE_14__.ProperLayeredGraph(new _structs_BasicGraph__WEBPACK_IMPORTED_MODULE_1__.BasicGraph(Array.from(this.database.SkeletonEdges()), layering.length));
        this.properLayeredGraph.BaseGraph.nodes = this.IntGraph.nodes;
        return new _LayerArrays__WEBPACK_IMPORTED_MODULE_8__.LayerArrays(extendedVertexLayering);
    }
    YLayeringAndOrderingWithoutHorizontalConstraints(layerArraysIn) {
        /*Assert.assert(layersAreCorrect(layerArraysIn))*/
        const layerArrays = this.CreateProperLayeredGraph(layerArraysIn.y);
        /*Assert.assert(layersAreCorrect(layerArrays))*/
        _ordering_ordering__WEBPACK_IMPORTED_MODULE_18__.Ordering.OrderLayers(this.properLayeredGraph, layerArrays, this.originalGraph.shallowNodeCount, this.sugiyamaSettings, this.cancelToken);
        _ordering_metroMapOrdering__WEBPACK_IMPORTED_MODULE_19__.MetroMapOrdering.UpdateLayerArrays1(this.properLayeredGraph, layerArrays);
        /*Assert.assert(layersAreCorrect(layerArrays))*/
        return layerArrays;
    }
    CalculateYLayers() {
        const layerArrays = this.YLayeringAndOrdering(new _layering_NetworkSimplexForGeneralGraph__WEBPACK_IMPORTED_MODULE_20__.NetworkSimplexForGeneralGraph(this.gluedDagSkeletonForLayering, this.cancelToken));
        /*Assert.assert(layersAreCorrect(layerArrays))*/
        if (this.constrainedOrdering != null)
            return layerArrays;
        return this.InsertLayersIfNeeded(layerArrays);
    }
    InsertLayersIfNeeded(layerArrays) {
        this.InsertVirtualEdgesIfNeeded(layerArrays);
        const r = this.AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays);
        if (r.needToInsertLayers) {
            const t = _LayerInserter__WEBPACK_IMPORTED_MODULE_17__.LayerInserter.InsertLayers(this.properLayeredGraph, layerArrays, this.database, this.IntGraph);
            this.properLayeredGraph = t.layeredGraph;
            layerArrays = t.la;
            this.LayersAreDoubled = true;
        }
        else if (r.multipleEdges) {
            const t = _EdgePathsInserter__WEBPACK_IMPORTED_MODULE_16__.EdgePathsInserter.InsertPaths(this.properLayeredGraph, layerArrays, this.database, this.IntGraph);
            this.properLayeredGraph = t.layeredGraph;
            layerArrays = t.la;
            /*Assert.assert(layersAreCorrect(layerArrays))*/
        }
        this.RecreateIntGraphFromDataBase();
        return layerArrays;
    }
    RecreateIntGraphFromDataBase() {
        let edges = new Array();
        for (const list of this.database.Multiedges.values())
            edges = edges.concat(list);
        this.IntGraph.SetEdges(edges, this.IntGraph.nodeCount);
    }
    InsertVirtualEdgesIfNeeded(layerArrays) {
        if (this.constrainedOrdering != null)
            //if there are constraints we handle multiedges correctly
            return;
        // If there are an even number of multi-edges between two nodes then
        // add a virtual edge in the multi-edge dict to improve the placement, but only in case when the edge goes down only one layer.
        for (const [k, v] of this.database.Multiedges.keyValues())
            if (v.length % 2 === 0 && layerArrays.y[k.x] - 1 === layerArrays.y[k.y]) {
                const e = new _core_geomEdge__WEBPACK_IMPORTED_MODULE_9__.GeomEdge(null);
                const newVirtualEdge = new _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__.PolyIntEdge(k.x, k.y, e);
                newVirtualEdge.IsVirtualEdge = true;
                v.splice(v.length / 2, 0, newVirtualEdge);
                this.IntGraph.addEdge(newVirtualEdge);
            }
    }
    AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays) {
        let needToInsertLayers = false;
        let multipleEdges = false;
        for (const ie of this.IntGraph.edges)
            if (ie.hasLabel && layerArrays.y[ie.source] !== layerArrays.y[ie.target]) {
                //if an edge is a flat edge then
                needToInsertLayers = true;
                break;
            }
        if (needToInsertLayers === false && this.constrainedOrdering == null)
            //if we have constrains the multiple edges have been already represented in layers
            for (const [k, v] of this.database.Multiedges.keyValues())
                if (v.length > 1) {
                    multipleEdges = true;
                    if (layerArrays.y[k.x] - layerArrays.y[k.y] === 1) {
                        //there is a multi edge spanning exactly one layer; unfortunately we need to introduce virtual vertices for
                        //the edges middle points
                        needToInsertLayers = true;
                        break;
                    }
                }
        return {
            needToInsertLayers: needToInsertLayers,
            multipleEdges: multipleEdges,
        };
    }
    UseBrandesXCalculations(layerArrays) {
        return layerArrays.x.length >= this.sugiyamaSettings.BrandesThreshold;
    }
    CalculateAnchorsAndYPositions(layerArrays) {
        this.anchors = CalculateAnchorSizes(this.database, this.properLayeredGraph, this.originalGraph, this.IntGraph, this.sugiyamaSettings);
        CalcInitialYAnchorLocations(layerArrays, 500, this.originalGraph, this.database, this.IntGraph, this.sugiyamaSettings, this.LayersAreDoubled);
    }
    // put some labels to the left of the splines if it makes sense
    OptimizeEdgeLabelsLocations() {
        for (let i = 0; i < this.anchors.length; i++) {
            const a = this.anchors[i];
            if (a.labelIsToTheRightOfTheSpline) {
                //by default the label is put to the right of the spline
                const sp = this.GetSuccessorAndPredecessor(i);
                if (!TryToPutLabelOutsideOfAngle(a, sp.predecessor, sp.successor)) {
                    const sumNow = sp.predecessor.origin.sub(a.origin).length + sp.successor.origin.sub(a.origin).length;
                    const nx = a.right - a.leftAnchor; //new potential anchor center
                    const xy = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(nx, a.y);
                    const sumWouldBe = sp.predecessor.origin.sub(xy).length + sp.successor.origin.sub(xy).length;
                    if (sumWouldBe < sumNow)
                        //we need to swap
                        PutLabelToTheLeft(a);
                }
            }
        }
    }
    GetSuccessorAndPredecessor(i) {
        let predecessor;
        for (const ie of this.properLayeredGraph.InEdges(i))
            predecessor = ie.Source; // there will be only one
        let successor;
        for (const ie of this.properLayeredGraph.OutEdges(i))
            successor = ie.Target; //there will be only one
        //we compare the sum of length of projections of edges (predecessor,i), (i,successor) to x in cases when the label is to the right and to the left
        return {
            predecessor: this.anchors[predecessor],
            successor: this.anchors[successor],
        };
    }
    CalculateLayerArrays() {
        const layerArrays = this.CalculateYLayers();
        if (this.constrainedOrdering == null) {
            this.CalculateAnchorsAndYPositions(layerArrays);
            if (this.UseBrandesXCalculations(layerArrays))
                this.CalculateXPositionsByBrandes(layerArrays);
            else
                this.CalculateXLayersByGansnerNorth(layerArrays);
        }
        else
            this.anchors = this.database.Anchors;
        this.OptimizeEdgeLabelsLocations();
        this.engineLayerArrays = layerArrays;
        this.StraightensShortEdges();
        this.CalculateOriginalGraphBox();
        // address this.sugiyamaSettings.AspectRatio at the final stage
        return layerArrays;
    }
    StretchToDesiredAspectRatio(aspectRatio, desiredAR) {
        if (aspectRatio > desiredAR) {
            this.StretchInYDirection(aspectRatio / desiredAR);
        }
        else if (aspectRatio < desiredAR) {
            this.StretchInXDirection(desiredAR / aspectRatio);
        }
    }
    StretchInYDirection(scaleFactor) {
        const center = (this.originalGraph.boundingBox.top + this.originalGraph.boundingBox.bottom) / 2;
        for (const a of this.database.Anchors) {
            a.bottomAnchor = a.bottomAnchor * scaleFactor;
            a.topAnchor = a.topAnchor * scaleFactor;
            a.y = center + scaleFactor * (a.y - center);
        }
        const h = this.originalGraph.height * scaleFactor;
        this.originalGraph.boundingBox = new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_24__.Rectangle({
            left: this.originalGraph.boundingBox.left,
            top: center + h / 2,
            right: this.originalGraph.boundingBox.right,
            bottom: center - h / 2,
        });
    }
    StretchInXDirection(scaleFactor) {
        const center = (this.originalGraph.boundingBox.left + this.originalGraph.boundingBox.right) / 2;
        for (const a of this.database.Anchors) {
            a.leftAnchor = a.leftAnchor * scaleFactor;
            a.rightAnchor = a.rightAnchor * scaleFactor;
            a.x = center + scaleFactor * (a.x - center);
        }
        const w = this.originalGraph.width * scaleFactor;
        this.originalGraph.boundingBox = new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_24__.Rectangle({
            left: center - w / 2,
            top: this.originalGraph.boundingBox.top,
            right: center + w / 2,
            bottom: this.originalGraph.boundingBox.bottom,
        });
    }
    CalculateOriginalGraphBox() {
        if (this.anchors.length === 0)
            return;
        const box = new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_24__.Rectangle({
            left: this.anchors[0].left,
            top: this.anchors[0].top,
            right: this.anchors[0].right,
            bottom: this.anchors[0].bottom,
        });
        for (let i = 1; i < this.anchors.length; i++) {
            const a = this.anchors[i];
            box.add(a.leftTop);
            box.add(a.rightBottom);
        }
        if (this.originalGraph.labelSize) {
            this.originalGraph.addLabelToGraphBB(box);
        }
        box.padEverywhere(this.originalGraph.margins);
        this.originalGraph.boundingBox = box;
    }
    StraightensShortEdges() {
        // it seems this heuristic is not needed for small graphs
        if (this.anchors.length < 20)
            return;
        // eslint-disable-next-line no-empty
        for (; this.StraightenEdgePaths();) { }
    }
    StraightenEdgePaths() {
        let ret = false;
        for (const e of this.database.AllIntEdges())
            if (e.LayerSpan === 2)
                ret = this.ShiftVertexWithNeighbors(e.LayerEdges[0].Source, e.LayerEdges[0].Target, e.LayerEdges[1].Target) || ret;
        return ret;
        //foreach (LayerEdge[][] edgeStrings of this.dataBase.RefinedEdges.Values)
        //   if (edgeStrings[0].length === 2)
        //       foreach (LayerEdge[] edgePath of edgeStrings)
        //           ret = ShiftVertexWithNeighbors(edgePath[0].Source, edgePath[0].Target, edgePath[1].Target) || ret;
        //return ret;
    }
    ShiftVertexWithNeighbors(u, i, v) {
        const upper = this.database.Anchors[u];
        const lower = this.database.Anchors[v];
        const iAnchor = this.database.Anchors[i];
        // calculate the ideal x position for i
        // (x- upper.x)/(iAnchor.y-upper.y)=(lower.x-upper.x)/(lower.y-upper.y)
        const x = (iAnchor.y - upper.y) * ((lower.x - upper.x) / (lower.y - upper.y)) + upper.x;
        const eps = 0.0001;
        if (x > iAnchor.x + eps) {
            return this.TryShiftToTheRight(x, i);
        }
        if (x < iAnchor.x - eps) {
            return this.TryShiftToTheLeft(x, i);
        }
        return false;
    }
    TryShiftToTheLeft(x, v) {
        const layer = this.engineLayerArrays.Layers[this.engineLayerArrays.y[v]];
        const vPosition = this.engineLayerArrays.x[v];
        if (vPosition > 0) {
            const uAnchor = this.database.Anchors[layer[vPosition - 1]];
            const allowedX = Math.max(uAnchor.right + (this.sugiyamaSettings.NodeSeparation + this.database.Anchors[v].leftAnchor), x);
            if (allowedX < this.database.Anchors[v].x - 1) {
                this.database.Anchors[v].x = allowedX;
                return true;
            }
            return false;
        }
        this.database.Anchors[v].x = x;
        return true;
    }
    TryShiftToTheRight(x, v) {
        const layer = this.engineLayerArrays.Layers[this.engineLayerArrays.y[v]];
        const vPosition = this.engineLayerArrays.x[v];
        if (vPosition < layer.length - 1) {
            const uAnchor = this.database.Anchors[layer[vPosition + 1]];
            const allowedX = Math.min(uAnchor.left - (this.sugiyamaSettings.NodeSeparation - this.database.Anchors[v].rightAnchor), x);
            if (allowedX > this.database.Anchors[v].x + 1) {
                this.database.Anchors[v].x = allowedX;
                return true;
            }
            return false;
        }
        this.database.Anchors[v].x = x;
        return true;
    }
    CalculateXLayersByGansnerNorth(layerArrays) {
        this.xLayoutGraph = this.CreateXLayoutGraph(layerArrays);
        this.CalculateXLayersByGansnerNorthOnProperLayeredGraph();
    }
    CalculateXLayersByGansnerNorthOnProperLayeredGraph() {
        const xLayers = new _layering_NetworkSimplex__WEBPACK_IMPORTED_MODULE_25__.NetworkSimplex(this.xLayoutGraph, null).GetLayers();
        //TestYXLayers(layerArrays, xLayers);//this will not be called in the release version
        for (let i = 0; i < this.database.Anchors.length; i++)
            this.anchors[i].x = xLayers[i];
    }
    // // A quote from Gansner93.
    // // The method involves constructing an auxiliary graph as illustrated in figure 4-2.
    // // This transformation is the graphical analogue of the algebraic
    // // transformation mentioned above for removing the absolute values
    // // from the optimization problem. The nodes of the auxiliary graph G^ are the nodes of
    // // the original graph G plus, for every edge e in G, there is a new node ne.
    // // There are two kinds of edges in G^. One edge class encodes the
    // // cost of the original edges. Every edge e = (u,v) in G is replaced by two edges (ne ,u)
    // // and (ne, v) with d = 0 and w = w(e)W(e). The other class of edges separates nodes in the same layer.
    // // If v is the left neighbor of w, then G^ has an edge f = e(v,w) with d( f ) = r(v,w) and
    // // w( f ) = 0. This edge forces the nodes to be sufficiently
    // // separated but does not affect the cost of the layout.
    CreateXLayoutGraph(layerArrays) {
        let nOfVerts = this.properLayeredGraph.NodeCount;
        // create edges of XLayoutGraph
        const edges = new Array();
        for (const e of this.properLayeredGraph.Edges) {
            const n1 = new _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__.PolyIntEdge(nOfVerts, e.Source, null);
            const n2 = new _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__.PolyIntEdge(nOfVerts, e.Target, null);
            n2.weight = e.Weight;
            n1.weight = e.Weight;
            n1.separation = 0;
            // these edge have 0 separation
            n2.separation = 0;
            nOfVerts++;
            edges.push(n1);
            edges.push(n2);
        }
        for (const layer of layerArrays.Layers) {
            for (let i = layer.length - 1; i > 0; i--) {
                const source = layer[i];
                const target = layer[i - 1];
                const ie = new _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__.PolyIntEdge(source, target, null);
                const sourceAnchor = this.database.Anchors[source];
                const targetAnchor = this.database.Anchors[target];
                const sep = sourceAnchor.leftAnchor + (targetAnchor.rightAnchor + this.sugiyamaSettings.NodeSeparation);
                ie.separation = Math.ceil(sep + 0.5);
                edges.push(ie);
            }
        }
        const ret = new _xLayoutGraph__WEBPACK_IMPORTED_MODULE_23__.XLayoutGraph(this.IntGraph, this.properLayeredGraph, layerArrays, edges, nOfVerts);
        ret.SetEdgeWeights();
        return ret;
    }
    CalculateXPositionsByBrandes(layerArrays) {
        _xCoordsWithAlignment__WEBPACK_IMPORTED_MODULE_22__.XCoordsWithAlignment.CalculateXCoordinates(layerArrays, this.properLayeredGraph, this.originalGraph.shallowNodeCount, this.database.Anchors, this.sugiyamaSettings.NodeSeparation);
    }
    GluedDagSkeletonEdges() {
        const ret = new _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_11__.IntPairMap();
        for (const [k, v] of this.database.Multiedges.keyValues()) {
            if (k.isDiagonal())
                continue;
            const e = this.verticalConstraints.gluedIntEdge(v[0]);
            if (e.source !== e.target)
                ret.set(e.source, e.target, e);
        }
        const gluedUpDownConstraints = Array.from(this.verticalConstraints.gluedUpDownIntConstraints.values()).map((p) => CreateUpDownConstrainedIntEdge(p, null));
        for (const e of gluedUpDownConstraints)
            ret.set(e.source, e.target, e);
        return Array.from(ret.values());
    }
    static CalcAnchorsForOriginalNode(i, intGraph, anchors, database, settings) {
        const t = {
            leftAnchor: 0,
            rightAnchor: 0,
            topAnchor: 0,
            bottomAnchor: 0,
        };
        //that's what we would have without the label and multiedges
        if (intGraph.nodes != null) {
            const node = intGraph.nodes[i];
            ExtendStandardAnchors(t, node, settings);
        }
        RightAnchorMultiSelfEdges(i, t, database, settings);
        const hw = settings.MinNodeWidth / 2;
        if (t.leftAnchor < hw)
            t.leftAnchor = hw;
        if (t.rightAnchor < hw)
            t.rightAnchor = hw;
        const hh = settings.MinNodeHeight / 2;
        if (t.topAnchor < hh)
            t.topAnchor = hh;
        if (t.bottomAnchor < hh)
            t.bottomAnchor = hh;
        anchors[i] = _anchor__WEBPACK_IMPORTED_MODULE_21__.Anchor.mkAnchor(t.leftAnchor, t.rightAnchor, t.topAnchor, t.bottomAnchor, intGraph.nodes[i], settings.LabelCornersPreserveCoefficient);
        anchors[i].padding = intGraph.nodes[i].padding;
    }
    CreateGluedDagSkeletonForLayering() {
        this.gluedDagSkeletonForLayering = new _structs_BasicGraph__WEBPACK_IMPORTED_MODULE_1__.BasicGraph(this.GluedDagSkeletonEdges(), this.originalGraph.shallowNodeCount);
        this.SetGluedEdgesWeights();
    }
    SetGluedEdgesWeights() {
        const gluedPairsToGluedEdge = new _utils_IntPairMap__WEBPACK_IMPORTED_MODULE_11__.IntPairMap();
        for (const ie of this.gluedDagSkeletonForLayering.edges)
            gluedPairsToGluedEdge.set(ie.source, ie.target, ie);
        for (const [k, v] of this.database.Multiedges.keyValues())
            if (k.x !== k.y) {
                const gluedPair = this.verticalConstraints.gluedIntPair(k);
                if (gluedPair.x === gluedPair.y)
                    continue;
                const gluedIntEdge = gluedPairsToGluedEdge.get(gluedPair.x, gluedPair.y);
                for (const ie of v)
                    gluedIntEdge.weight += ie.weight;
            }
    }
    GetNodeCountsOfGluedDag() {
        if (this.verticalConstraints.isEmpty) {
            return new Array(this.IntGraph.nodeCount).fill(1);
        }
        return this.verticalConstraints.getGluedNodeCounts();
    }
}
function SnapDeltaUp(y, gridSize) {
    if (gridSize === 0)
        return 0;
    // how much to snap?
    const k = Math.floor(y / gridSize);
    const delta = y - k * gridSize;
    /*Assert.assert(delta >= 0 && delta < gridSize)*/
    if (Math.abs(delta) < 0.0001) {
        // do not snap
        return 0;
    }
    return gridSize - delta;
}
function LayerIsOriginal(yLayer, origNodeCount) {
    for (const j of yLayer)
        if (j < origNodeCount)
            return true;
    return false;
}
function CalculateAnchorSizes(database, properLayeredGraph, originalGraph, intGraph, settings) {
    const anchors = (database.Anchors = new Array(properLayeredGraph.NodeCount));
    for (let i = 0; i < anchors.length; i++)
        anchors[i] = new _anchor__WEBPACK_IMPORTED_MODULE_21__.Anchor(settings.LabelCornersPreserveCoefficient);
    //go over the old vertices
    for (let i = 0; i < originalGraph.shallowNodeCount; i++)
        LayeredLayout.CalcAnchorsForOriginalNode(i, intGraph, anchors, database, settings);
    //go over virtual vertices
    for (const intEdge of database.AllIntEdges())
        if (intEdge.LayerEdges != null) {
            for (const layerEdge of intEdge.LayerEdges) {
                const v = layerEdge.Target;
                if (v !== intEdge.target) {
                    const anchor = anchors[v];
                    if (!database.MultipleMiddles.has(v)) {
                        anchor.leftAnchor = anchor.rightAnchor = VirtualNodeWidth() / 2.0;
                        anchor.topAnchor = anchor.bottomAnchor = VirtualNodeHeight(settings) / 2.0;
                    }
                    else {
                        anchor.leftAnchor = anchor.rightAnchor = VirtualNodeWidth() * 4;
                        anchor.topAnchor = anchor.bottomAnchor = VirtualNodeHeight(settings) / 2.0;
                    }
                }
            }
            //fix label vertices
            if (intEdge.hasLabel) {
                const lj = intEdge.LayerEdges[intEdge.LayerEdges.length / 2].Source;
                const a = anchors[lj];
                const w = intEdge.labelWidth, h = intEdge.labelHeight;
                a.rightAnchor = w;
                a.leftAnchor = VirtualNodeWidth() * 8;
                if (a.topAnchor < h / 2.0)
                    a.topAnchor = a.bottomAnchor = h / 2.0;
                a.labelIsToTheRightOfTheSpline = true;
            }
        }
    return anchors;
}
function VirtualNodeWidth() {
    return 1;
}
// the height of dummy nodes
function VirtualNodeHeight(settings) {
    return (settings.MinNodeHeight * 1.5) / 8;
}
function SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax) {
    let flatEdgesHeight = 0;
    if (i > 0) {
        //looking for flat edges on the previous level
        //we stack labels of multiple flat edges on top of each other
        const flatPairs = GetFlatPairs(layerArrays.Layers[i - 1], layerArrays.y, intGraph);
        if (flatPairs.length) {
            const dyOfFlatEdge = settings.LayerSeparation / 3;
            const ym = ymax;
            flatEdgesHeight = Math.max(...flatPairs.map((pair) => SetFlatEdgesLabelsHeightAndPositionts(pair, ym, dyOfFlatEdge, database)));
        }
    }
    return flatEdgesHeight;
}
// returnst the height of the graph+spaceBeforeMargins
function CalcInitialYAnchorLocations(layerArrays, spaceBeforeMargins, originalGraph, database, intGraph, settings, layersAreDoubled) {
    const anchors = database.Anchors;
    let ymax = originalGraph.margins.top + spaceBeforeMargins; //setting up y coord - going up by y-layers
    let i = 0;
    for (const yLayer of layerArrays.Layers) {
        let bottomAnchorMax = 0;
        let topAnchorMax = 0;
        for (const j of yLayer) {
            const p = anchors[j];
            if (p.bottomAnchor > bottomAnchorMax)
                bottomAnchorMax = p.bottomAnchor;
            if (p.topAnchor > topAnchorMax)
                topAnchorMax = p.topAnchor;
        }
        MakeVirtualNodesTall(yLayer, bottomAnchorMax, topAnchorMax, originalGraph.shallowNodeCount, database.Anchors);
        const flatEdgesHeight = SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax);
        const layerCenter = ymax + bottomAnchorMax + flatEdgesHeight;
        let layerTop = layerCenter + topAnchorMax;
        if (NeedToSnapTopsToGrid(settings)) {
            layerTop += SnapDeltaUp(layerTop, settings.GridSizeByY);
            for (const j of yLayer)
                anchors[j].top = layerTop;
        }
        else if (NeedToSnapBottomsToGrid(settings)) {
            let layerBottom = layerCenter - bottomAnchorMax;
            layerBottom += SnapDeltaUp(layerBottom, layerBottom);
            for (const j of yLayer) {
                anchors[j].bottom = layerBottom;
                layerTop = Math.max(anchors[j].top, layerTop);
            }
        }
        else
            for (const j of yLayer)
                anchors[j].y = layerCenter;
        const layerSep = settings.ActualLayerSeparation(layersAreDoubled);
        ymax = layerTop + layerSep;
        i++;
    }
    // for the last layer
    SetFlatEdgesForLayer(database, layerArrays, i, intGraph, settings, ymax);
}
function CreateUpDownConstrainedIntEdge(intPair, e) {
    const intEdge = new _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__.PolyIntEdge(intPair.x, intPair.y, e);
    intEdge.weight = 0;
    //we do not want the edge weight to contribute in to the sum but just take the constraint into account
    intEdge.separation = 1;
    return intEdge;
}
function EdgeSpan(layers, e) {
    return layers[e.source] - layers[e.target];
}
function MakeVirtualNodesTall(yLayer, bottomAnchorMax, topAnchorMax, originalNodeCount, anchors) {
    if (LayerIsOriginal(yLayer, originalNodeCount))
        for (const j of yLayer)
            if (j >= originalNodeCount) {
                const p = anchors[j];
                p.bottomAnchor = bottomAnchorMax;
                p.topAnchor = topAnchorMax;
            }
}
function NeedToSnapTopsToGrid(settings) {
    return settings.SnapToGridByY === _sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_5__.SnapToGridByY.Top;
}
function NeedToSnapBottomsToGrid(settings) {
    return settings.SnapToGridByY === _sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_5__.SnapToGridByY.Bottom;
}
function TryToPutLabelOutsideOfAngle(a, predecessor, successor) {
    if (a.labelIsToTheRightOfTheSpline) {
        if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.getTriangleOrientation(predecessor.origin, a.origin, successor.origin) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Clockwise)
            return true;
        const la = a.leftAnchor;
        const ra = a.rightAnchor;
        const x = a.x;
        PutLabelToTheLeft(a);
        if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.getTriangleOrientation(predecessor.origin, a.origin, successor.origin) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise)
            return true;
        a.x = x;
        a.leftAnchor = la;
        a.rightAnchor = ra;
        a.labelIsToTheRightOfTheSpline = true;
        a.labelIsToTheLeftOfTheSpline = false;
        return false;
    }
    return false;
}
function PutLabelToTheLeft(a) {
    const r = a.right;
    const t = a.leftAnchor;
    a.leftAnchor = a.rightAnchor;
    a.rightAnchor = t;
    a.x = r - a.rightAnchor;
    a.labelIsToTheLeftOfTheSpline = true;
    a.labelIsToTheRightOfTheSpline = false;
}
function GetFlatPairs(layer, layering, intGraph) {
    const pairs = new _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_12__.IntPairSet();
    for (const v of layer) {
        if (v >= intGraph.nodeCount)
            continue;
        for (const edge of intGraph.outEdges[v])
            if (layering[edge.source] === layering[edge.target])
                pairs.addNN(edge.source, edge.target);
    }
    return Array.from(pairs.values());
}
function SetFlatEdgesLabelsHeightAndPositionts(pair, ymax, dy, database) {
    let height = 0;
    const list = database.GetMultiedgeI(pair);
    for (const edge of list) {
        height += dy;
        const label = edge.edge.label;
        if (label != null) {
            label.positionCenter(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(label.center.x, ymax + height + label.height / 2));
            height += label.height;
        }
    }
    return height;
}
function ExtendStandardAnchors(t, node, settings) {
    t.rightAnchor = t.leftAnchor = (node.width + settings.GridSizeByX) / 2;
    t.topAnchor = t.bottomAnchor = node.height / 2;
}
function RightAnchorMultiSelfEdges(i, t, database, settings) {
    const delta = WidthOfSelfEdge(database, i, t, settings);
    t.rightAnchor += delta;
}
function WidthOfSelfEdge(database, i, t, settings) {
    let delta = 0;
    const multiedges = database.GetMultiedge(i, i);
    //it could be a multiple self edge
    if (multiedges.length > 0) {
        for (const e of multiedges)
            if (e.edge.label != null) {
                t.rightAnchor += e.edge.label.width;
                if (t.topAnchor < e.edge.label.height / 2.0)
                    t.topAnchor = t.bottomAnchor = e.edge.label.height / 2.0;
            }
        delta += (settings.NodeSeparation + settings.MinNodeWidth) * multiedges.length;
    }
    return delta;
}
function preRunTransform(geomGraph, m) {
    if (m.isIdentity()) {
        return;
    }
    const matrixInverse = m.inverse();
    for (const n of geomGraph.shallowNodes) {
        n.transform(matrixInverse);
    }
    // calculate new label widths and heights
    for (const e of geomGraph.shallowEdges) {
        if (e.label != null) {
            const r = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_24__.Rectangle.mkPP(matrixInverse.multiplyPoint(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(0, 0)), matrixInverse.multiplyPoint(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(e.label.width, e.label.height)));
            e.label.width = r.width;
            e.label.height = r.height;
        }
    }
}
function postRunTransform(geometryGraph, transform) {
    if (transform.isIdentity())
        return;
    for (const n of geometryGraph.shallowNodes) {
        n.transform(transform);
    }
    // restore labels widths and heights
    for (const e of geometryGraph.shallowEdges) {
        if (e.label != null) {
            const r = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_24__.Rectangle.mkPP(transform.multiplyPoint(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(0, 0)), transform.multiplyPoint(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(e.label.width, e.label.height)));
            e.label.width = r.width;
            e.label.height = r.height;
        }
    }
    TransformEdges(geometryGraph, transform);
    if (geometryGraph.graph.parent == null) {
        geometryGraph.boundingBox = null;
    }
}
function TransformEdges(geometryGraph, m) {
    for (const e of geometryGraph.shallowEdges) {
        if (e.label) {
            e.label.transform(m);
        }
        TransformEdgeCurve(m, e);
    }
}
function TransformEdgeCurve(transformation, e) {
    if (e.curve != null) {
        e.curve = e.curve.transform(transformation);
        const eg = e;
        if (eg.sourceArrowhead != null) {
            eg.sourceArrowhead.tipPosition = transformation.multiplyPoint(eg.sourceArrowhead.tipPosition);
        }
        if (eg.targetArrowhead != null) {
            eg.targetArrowhead.tipPosition = transformation.multiplyPoint(eg.targetArrowhead.tipPosition);
        }
        TransformUnderlyingPolyline(e, transformation);
    }
}
function TransformUnderlyingPolyline(e, transformation) {
    if (e.smoothedPolyline != null) {
        for (let s = e.smoothedPolyline.headSite; s != null; s = s.next) {
            s.point = transformation.multiplyPoint(s.point);
        }
    }
}
//# sourceMappingURL=layeredLayout.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/layering/NetworkSimplex.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkSimplex: () => (/* binding */ NetworkSimplex)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _longestPathLayering__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layering/longestPathLayering.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _networkEdge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layering/networkEdge.js");
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");






function CreateGraphWithIEEdges(bg) {
    const ieEdges = new Array();
    for (const e of bg.edges)
        ieEdges.push(new _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge(e));
    return (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_2__.mkGraphOnEdgesN)(ieEdges, bg.nodeCount);
}
class StackStruct {
    constructor(v, outEnum, i, // points to outEnum
    inEnum, j) {
        this.v = v;
        this.outEnum = outEnum;
        this.i = i;
        this.inEnum = inEnum;
        this.j = j;
    }
}
// The implementation follows "A technique for Drawing Directed Graphs", Gansner, Koutsofios, North, Vo.
class NetworkSimplex {
    get weight() {
        return this.graph.edges.map((e) => e.weight * (this.layers[e.source] - this.layers[e.target])).reduce((sum, w) => sum + w, 0);
    }
    get nodeCount() {
        return this.vertices.length;
    }
    setLow(v, l) {
        this.vertices[v].low = l;
    }
    setLim(v, l) {
        this.vertices[v].lim = l;
    }
    setParent(v, e) {
        this.vertices[v].parent = e;
    }
    constructor(graph, cancelToken) {
        // fields
        this.layers = null;
        this.treeVertices = [];
        this.vertices = [];
        this.leaves = [];
        this.graph = CreateGraphWithIEEdges(graph);
        this.networkCancelToken = cancelToken;
        for (let i = 0; i < this.graph.nodeCount; i++) {
            this.vertices.push({
                inTree: false,
                lim: -1,
                low: -1,
                parent: null,
            });
        }
    }
    GetLayers() {
        if (this.layers == null)
            this.run();
        return this.layers;
    }
    shiftLayerToZero() {
        const minLayer = Math.min(...this.layers);
        for (let i = 0; i < this.layers.length; i++)
            this.layers[i] -= minLayer;
    }
    addVertexToTree(v) {
        this.vertices[v].inTree = true;
    }
    vertexInTree(v) {
        return this.vertices[v].inTree;
    }
    lim(v) {
        return this.vertices[v].lim;
    }
    low(v) {
        return this.vertices[v].low;
    }
    parent(v) {
        return this.vertices[v].parent;
    }
    // The function feasibleTree constructs an initial feasible spanning tree.
    feasibleTree() {
        this.initLayers();
        while (this.tightTree() < this.nodeCount) {
            const e = this.getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();
            if (e == null)
                break; //all edges are tree edges
            let slack = this.slack(e);
            /*Assert.assert(slack !== 0, 'the tree should be tight')*/
            if (this.vertexInTree(e.source))
                slack = -slack;
            //shift the tree rigidly up or down and make e tight
            // since the slack is minimal the layering remains feasible
            for (const i of this.treeVertices)
                this.layers[i] += slack;
        }
        this.initCutValues();
    }
    // A treeEdge, belonging to the tree, divides the vertices to source and target components
    // If v belongs to the source component we return 1
    // otherwise we return 0
    vertexSourceTargetVal(v, treeEdge) {
        /*Assert.assert(treeEdge.inTree)*/
        const s = treeEdge.source;
        const t = treeEdge.target;
        if (this.lim(s) > this.lim(t))
            if (this.lim(v) <= this.lim(t) && this.low(t) <= this.lim(v))
                //s belongs to the tree root component
                return 0;
            else
                return 1;
        //t belongs to the tree root component
        else if (this.lim(v) <= this.lim(s) && this.low(s) <= this.lim(v))
            return 1;
        else
            return 0;
    }
    // a convenient wrapper of IncEdges incident to v
    incidentEdges(v) {
        return this.graph.incidentEdges(v);
    }
    allLowCutsHaveBeenDone(v) {
        for (const ie of this.incidentEdges(v))
            if (ie.inTree && ie.cut === _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity && ie !== this.parent(v))
                return false;
        return true;
    }
    // treeEdge, belonging to the tree, divides the vertices to source and target components
    // e does not belong to the tree . If e goes from the source component to target component
    // then the return value is 1,
    // if e goes from the target component ot the source then the return value is -1
    // otherwise return zero
    edgeSourceTargetVal(e, treeEdge) {
        // if (e.inTree || treeEdge.inTree === false)
        // throw new Exception("wrong params for EdgeSOurceTargetVal");
        return this.vertexSourceTargetVal(e.source, treeEdge) - this.vertexSourceTargetVal(e.target, treeEdge);
    }
    // initCutValues computes the cut values of the tree edges.
    // For each tree edge, this is computed by marking the nodes as belonging to the source or
    // target component, and then performing the sum of the signed weights of all
    // edges whose source and target are in different components, the sign being negative for those edges
    // going from the source to the target component.
    // To reduce this cost, we note that the cut values can be computed using information local to an edge
    // if the search is ordered from the leaves of the feasible tree inward. It is trivial to compute the
    // cut value of a tree edge with one of its endpoints a leaf in the tree,
    // since either the source or the target component consists of a single node.
    // Now, assuming the cut values are known for all the edges incident on a given
    // node except one, the cut value of the remaining edge is the sum of the known cut
    // values plus a term dependent only on the edges incident to the given node.
    initCutValues() {
        this.initLimLowAndParent();
        //going up from the leaves following parents
        let front = new stack_typescript__WEBPACK_IMPORTED_MODULE_4__.Stack();
        for (const i of this.leaves)
            front.push(i);
        let newFront = new stack_typescript__WEBPACK_IMPORTED_MODULE_4__.Stack();
        while (front.length > 0) {
            while (front.length > 0) {
                const w = front.pop();
                const cutEdge = this.parent(w);
                if (cutEdge == null)
                    continue;
                let cut = 0;
                for (const e of this.incidentEdges(w)) {
                    if (e.inTree === false) {
                        const e0Val = this.edgeSourceTargetVal(e, cutEdge);
                        if (e0Val !== 0)
                            cut += e0Val * e.weight;
                    } //e0 is a tree edge
                    else {
                        if (e === cutEdge)
                            cut += e.weight;
                        else {
                            const impact = cutEdge.source === e.target || cutEdge.target === e.source ? 1 : -1;
                            const edgeContribution = this.edgeContribution(e, w);
                            cut += edgeContribution * impact;
                        }
                    }
                }
                cutEdge.cut = cut;
                const v = cutEdge.source === w ? cutEdge.target : cutEdge.source;
                if (this.allLowCutsHaveBeenDone(v))
                    newFront.push(v);
            }
            //swap new front and front
            const t = front;
            front = newFront;
            newFront = t;
        }
    }
    // e is a tree edge for which the cut has been calculted already.
    // EdgeContribution gives an amount that edge e brings to the cut of parent(w).
    // The contribution is the cut value minus the weight of e. Let S be the component of e source.
    // We should also substruct W(ie) for every ie going from S to w and add W(ie) going from w to S.
    // These numbers appear in e.cut but with opposite signs.
    edgeContribution(e, w) {
        let ret = e.cut - e.weight;
        for (const ie of this.incidentEdges(w)) {
            if (ie.inTree === false) {
                const sign = this.edgeSourceTargetVal(ie, e);
                if (sign === -1)
                    ret += ie.weight;
                else if (sign === 1)
                    ret -= ie.weight;
            }
        }
        return ret;
    }
    // A quote:
    // Another valuable optimization, similar to a technique described in [Ch],
    // is to perform a postorder traversal of the tree, starting from some fixed
    // root node vroot, and labeling each node v with its postorder
    // traversal number lim(v), the least number low(v) of any descendant in the search,
    // and the edge parent(v) by which the node was reached (see figure 2-5).
    // This provides an inexpensive way to test whether a node lies in the
    // source or target component of a tree edge, and thus whether a non-tree edge
    // crosses between the two components. For example, if e = (u,v) is a
    // tree edge and vroot is in the source component of the edge (i.e., lim(u) less lim(v)),
    // then a node w is in the target component of e if and only if low(u) is less or equal than lim(w)
    // is less or equal than lim(u). These numbers can also be used to update the tree efficiently
    // during the network simplex iterations. If f = (w,x) is the entering edge, the
    // only edges whose cut values must be adjusted are those in the path
    // connecting w and x in the tree. This path is determined by following
    // the parent edges back from w and x until the least common ancestor is reached,
    // i.e., the first node l such that low(l) is less or equal lim(w) than ,
    // lim(x) is less or equal than lim(l).
    // Of course, these postorder parameters must also be adjusted when
    // exchanging tree edges, but only for nodes below l.
    initLimLowAndParent() {
        this.initLowLimParentAndLeavesOnSubtree(1, 0);
    }
    // initializes lim and low in the subtree
    initLowLimParentAndLeavesOnSubtree(curLim, v) {
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_4__.Stack();
        let outEnum = this.graph.outEdges[v];
        let i = -1;
        let inEnum = this.graph.inEdges[v];
        let j = -1;
        stack.push(new StackStruct(v, outEnum, i, inEnum, j)); //vroot is 0 here
        this.vertices[v].low = curLim;
        while (stack.length > 0) {
            const ss = stack.pop();
            v = ss.v;
            outEnum = ss.outEnum;
            i = ss.i;
            inEnum = ss.inEnum;
            j = ss.j;
            //for sure we will have a descendant with the lowest number curLim since curLim may only grow
            //from the current value
            let done;
            do {
                done = true;
                while (++i < outEnum.length) {
                    const e = outEnum[i];
                    if (!e.inTree || this.vertices[e.target].low > 0)
                        continue;
                    stack.push(new StackStruct(v, outEnum, i, inEnum, j));
                    v = e.target;
                    this.setParent(v, e);
                    this.setLow(v, curLim);
                    outEnum = this.graph.outEdges[v];
                    i = -1;
                    inEnum = this.graph.inEdges[v];
                    j = -1;
                }
                while (++j < inEnum.length) {
                    const e = inEnum[j];
                    if (!e.inTree || this.vertices[e.source].low > 0) {
                        continue;
                    }
                    stack.push(new StackStruct(v, outEnum, i, inEnum, j));
                    v = e.source;
                    this.setLow(v, curLim);
                    this.setParent(v, e);
                    outEnum = this.graph.outEdges[v];
                    i = -1;
                    inEnum = this.graph.inEdges[v];
                    j = -1;
                    done = false;
                    break;
                }
            } while (!done);
            //finally done with v
            this.setLim(v, curLim++);
            if (this.lim(v) === this.low(v))
                this.leaves.push(v);
        }
    }
    // here we update values lim and low for the subtree with the root l
    updateLimLowLeavesAndParentsUnderNode(l) {
        //first we zero all low values in the subtree since they are an indication when positive that
        //the node has been processed
        //We are updating leaves also
        const llow = this.vertices[l].low;
        const llim = this.vertices[l].lim;
        this.leaves = [];
        for (let i = 0; i < this.nodeCount; i++) {
            if (llow <= this.vertices[i].lim && this.vertices[i].lim <= llim)
                this.setLow(i, 0);
            else if (this.low(i) === this.lim(i))
                this.leaves.push(i);
        }
        this.initLowLimParentAndLeavesOnSubtree(llow, l);
    }
    slack(e) {
        const ret = this.layers[e.source] - this.layers[e.target] - e.separation;
        /*Assert.assert(
          ret >= -GeomConstants.tolerance,
          'separation is not satisfied',
        )*/
        return ret;
    }
    // one of the returned edge vertices does not belong to the tree but another does
    getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack() {
        let eret = null;
        let minSlack = _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity;
        for (const v of this.treeVertices) {
            for (const e of this.graph.outEdges[v]) {
                if (this.vertexInTree(e.source) && this.vertexInTree(e.target))
                    continue;
                const slack = this.slack(e);
                if (slack < minSlack) {
                    eret = e;
                    minSlack = slack;
                    if (slack === 1)
                        return e;
                }
            }
            for (const e of this.graph.inEdges[v]) {
                if (this.vertexInTree(e.source) && this.vertexInTree(e.target))
                    continue;
                const slack = this.slack(e);
                if (slack < minSlack) {
                    eret = e;
                    minSlack = slack;
                    if (slack === 1)
                        return e;
                }
            }
        }
        return eret;
    }
    // The function TightTree finds a maximal tree of tight edges containing
    // some fixed node and returns the number of nodes in the tree.
    // Note that such a maximal tree is just a spanning tree for the subgraph
    // induced by all nodes reachable from the fixed node in the underlying
    // undirected graph using only tight edges. In particular, all such trees have the same number of nodes.
    // The function also builds the tree. It returns the number of verices in the tight tree
    tightTree() {
        this.treeVertices = [];
        for (const ie of this.graph.edges)
            ie.inTree = false;
        for (let i = 1; i < this.nodeCount; i++)
            this.vertices[i].inTree = false;
        //the vertex 0 is a fixed node
        this.vertices[0].inTree = true;
        this.treeVertices.push(0);
        const q = new stack_typescript__WEBPACK_IMPORTED_MODULE_4__.Stack();
        q.push(0);
        while (q.length > 0) {
            const v = q.pop();
            for (const e of this.graph.outEdges[v]) {
                if (this.vertexInTree(e.target))
                    continue;
                if (this.layers[e.source] - this.layers[e.target] === e.separation) {
                    q.push(e.target);
                    this.addVertexToTree(e.target);
                    this.treeVertices.push(e.target);
                    e.inTree = true;
                }
            }
            for (const e of this.graph.inEdges[v]) {
                if (this.vertexInTree(e.source))
                    continue;
                if (this.layers[e.source] - this.layers[e.target] === e.separation) {
                    q.push(e.source);
                    this.addVertexToTree(e.source);
                    this.treeVertices.push(e.source);
                    e.inTree = true;
                }
            }
        }
        return this.treeVertices.length;
    }
    // leaveEnterEdge finds a non-tree edge to replace e.
    // This is done by breaking the tree, by removing e, into
    // the source and the target componentx.
    // All edges going from the source component to the
    // target are considered for the replacement, and an edge with the minimum
    // slack being chosen. This maintains feasibility.
    leaveEnterEdge() {
        let leavingEdge;
        let enteringEdge;
        let minCut = 0;
        for (const e of this.graph.edges) {
            if (e.inTree) {
                if (e.cut < minCut) {
                    minCut = e.cut;
                    leavingEdge = e;
                }
            }
        }
        if (leavingEdge == null)
            return null;
        //now we are looking for a non-tree edge with a minimal slack belonging to TS
        let continuation = false;
        let minSlack = _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity;
        for (const f of this.graph.edges) {
            const slack = this.slack(f);
            if (f.inTree === false &&
                this.edgeSourceTargetVal(f, leavingEdge) === -1 &&
                (slack < minSlack || (slack === minSlack && (continuation = (0,_utils_random__WEBPACK_IMPORTED_MODULE_5__.randomInt)(2) === 1)))) {
                minSlack = slack;
                enteringEdge = f;
                if (minSlack === 0 && !continuation)
                    break;
                continuation = false;
            }
        }
        if (enteringEdge == null) {
            throw new Error();
        }
        return { leaving: leavingEdge, entering: enteringEdge };
    }
    // If f = (w,x) is the entering edge, the
    // only edges whose cut values must be adjusted are those in the path
    // connecting w and x in the tree, excluding e. This path is determined by
    // following the parent edges back from w and x until the least common ancestor is
    // reached, i.e., the first node l such that low(l) less or equal lim(w) ,lim(x) less or equal lim(l).
    // Of course, these postorder parameters must also be adjusted when
    // exchanging tree edges, but only for nodes below l.
    // e - exiting edge, f - entering edge
    exchange(e, f) {
        const l = this.commonPredecessorOfSourceAndTargetOfF(f);
        this.createPathForCutUpdates(e, f, l);
        this.updateLimLowLeavesAndParentsUnderNode(l);
        this.updateCuts(e);
        this.updateLayersUnderNode(l);
    }
    updateLayersUnderNode(l) {
        //update the layers under l
        const front = new stack_typescript__WEBPACK_IMPORTED_MODULE_4__.Stack();
        front.push(l);
        //set layers to infinity under l
        for (let i = 0; i < this.nodeCount; i++)
            if (this.low(l) <= this.lim(i) && this.lim(i) <= this.lim(l) && i !== l)
                this.layers[i] = _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity;
        while (front.length > 0) {
            const u = front.pop();
            for (const oe of this.graph.outEdges[u]) {
                if (oe.inTree && this.layers[oe.target] === _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity) {
                    this.layers[oe.target] = this.layers[u] - oe.separation;
                    front.push(oe.target);
                }
            }
            for (const ie of this.graph.inEdges[u]) {
                if (ie.inTree && this.layers[ie.source] === _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity) {
                    this.layers[ie.source] = this.layers[u] + ie.separation;
                    front.push(ie.source);
                }
            }
        }
    }
    updateCuts(e) {
        //going up from the leaves of the branch following parents
        let front = new stack_typescript__WEBPACK_IMPORTED_MODULE_4__.Stack();
        let newFront = new stack_typescript__WEBPACK_IMPORTED_MODULE_4__.Stack();
        //We start cut updates from the vertices of e. It will work only if in the new tree
        // the  parents of the vertices of e are end edges on the path connecting the two vertices.
        //Let  e be (w,x) and let f be (u,v). Let T be the tree containing e but no f,
        //and T0 be the tree without with e but containg f. Let us consider the path with no edge repetitions from u to v in T.
        //It has to contain e since there is a path from u to v in T containing e, because v lies in the component of w in T
        //and u lies in the component of x in T, if there is a path without e then we have a cycle in T.
        // Now if we remove e from this path and add f to it we get a path without edge repetitions connecting w to x.
        // The edge adjacent in this path to w is parent(w) in T0, and the edge of the path adjacent to x is
        //parent(x) in T0. If it is not true then we can get a cycle by constructing another path from w to x going up through the
        //parents to the common ancessor of w and x.
        front.push(e.source);
        front.push(e.target);
        while (front.length > 0) {
            while (front.length > 0) {
                const w = front.pop();
                const cutEdge = this.parent(w); //have to find the cut of cutEdge
                if (cutEdge == null)
                    continue;
                if (cutEdge.cut !== _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity)
                    continue; //the value of this cut has not been changed
                let cut = 0;
                for (const ce of this.incidentEdges(w)) {
                    if (ce.inTree === false) {
                        cut += this.edgeSourceTargetVal(ce, cutEdge) * ce.weight;
                    } //e0 is a tree edge
                    else {
                        if (ce === cutEdge)
                            cut += ce.weight;
                        else {
                            const impact = cutEdge.source === ce.target || cutEdge.target === ce.source ? 1 : -1;
                            const edgeContribution = this.edgeContribution(ce, w);
                            cut += edgeContribution * impact;
                        }
                    }
                }
                cutEdge.cut = cut;
                const u = cutEdge.source === w ? cutEdge.target : cutEdge.source;
                if (this.allLowCutsHaveBeenDone(u))
                    newFront.push(u);
            }
            //swap newFrontAndFront
            const t = front;
            front = newFront;
            newFront = t;
        }
    }
    createPathForCutUpdates(e, f, l) {
        //we mark the path by setting the cut value to infinity
        let v = f.target;
        while (v !== l) {
            const p = this.parent(v);
            p.cut = _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity;
            v = p.source === v ? p.target : p.source;
        }
        f.cut = _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity; //have to do it because f will be in the path between end points of e in the new tree
        //remove e from the tree and put f inside of it
        e.inTree = false;
        f.inTree = true;
    }
    commonPredecessorOfSourceAndTargetOfF(f) {
        //find the common predecessor of f.source and f.target
        let fMin, fmax;
        if (this.lim(f.source) < this.lim(f.target)) {
            fMin = this.lim(f.source);
            fmax = this.lim(f.target);
        }
        else {
            fMin = this.lim(f.target);
            fmax = this.lim(f.source);
        }
        //it is the best to walk up from the highest of nodes f
        //but we don't know the depths
        //so just start walking up from the source
        let l = f.source;
        while ((this.low(l) <= fMin && fmax <= this.lim(l)) === false) {
            const p = this.parent(l);
            p.cut = _networkEdge__WEBPACK_IMPORTED_MODULE_3__.NetworkEdge.infinity;
            l = p.source === l ? p.target : p.source;
        }
        return l;
    }
    checkCutValues() {
        for (const e of this.graph.edges) {
            if (e.inTree) {
                let cut = 0;
                for (const f of this.graph.edges) {
                    cut += this.edgeSourceTargetVal(f, e) * f.weight;
                }
                if (e.cut !== cut)
                    console.log(typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('cuts are wrong for {0}; should be {1} but is {2}', e, cut, e.cut));
            }
        }
    }
    initLayers() {
        const lp = new _longestPathLayering__WEBPACK_IMPORTED_MODULE_1__.LongestPathLayering(this.graph);
        return (this.layers = lp.GetLayers());
    }
    run() {
        if (this.graph.edges.length === 0 && this.graph.nodeCount === 0) {
            this.layers = [];
        }
        else {
            this.feasibleTree();
            let leaveEnter;
            while ((leaveEnter = this.leaveEnterEdge()) != null) {
                this.exchange(leaveEnter.leaving, leaveEnter.entering);
            }
            this.shiftLayerToZero();
        }
    }
}
//# sourceMappingURL=NetworkSimplex.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/layering/NetworkSimplexForGeneralGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkSimplexForGeneralGraph: () => (/* binding */ NetworkSimplexForGeneralGraph)
/* harmony export */ });
/* harmony import */ var _structs_BasicGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/BasicGraph.js");
/* harmony import */ var _polyIntEdge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/polyIntEdge.js");
/* harmony import */ var _NetworkSimplex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layering/NetworkSimplex.js");



class NetworkSimplexForGeneralGraph {
    GetLayers() {
        return new _NetworkSimplex__WEBPACK_IMPORTED_MODULE_2__.NetworkSimplex(this.graph, this.Cancel).GetLayers();
    }
    ShrunkComponent(dictionary) {
        const edges = [];
        for (const p of dictionary) {
            const v = p[0];
            const newEdgeSource = p[1];
            for (const e of this.graph.outEdges[v]) {
                const pe = new _polyIntEdge__WEBPACK_IMPORTED_MODULE_1__.PolyIntEdge(newEdgeSource, dictionary.get(e.target), e.edge);
                pe.separation = e.separation;
                pe.weight = e.weight;
                edges.push(pe);
            }
        }
        return new _structs_BasicGraph__WEBPACK_IMPORTED_MODULE_0__.BasicGraph(edges, dictionary.size);
    }
    constructor(graph, cancelObject) {
        this.graph = graph;
        this.Cancel = cancelObject;
    }
}
//# sourceMappingURL=NetworkSimplexForGeneralGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/layering/longestPathLayering.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LongestPathLayering: () => (/* binding */ LongestPathLayering)
/* harmony export */ });
/* harmony import */ var _math_graphAlgorithms_topologicalSort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/graphAlgorithms/topologicalSort.js");

// Layering the DAG by longest path
class LongestPathLayering {
    GetLayers() {
        //sort the vertices in topological order
        const topoOrder = _math_graphAlgorithms_topologicalSort__WEBPACK_IMPORTED_MODULE_0__.TopologicalSort.getOrderOnGraph(this.graph);
        // Assert.assert(this.checkTopoOrder(topoOrder))
        // initially all nodes belong to the same layer 0
        const layering = new Array(this.graph.nodeCount).fill(0);
        //going backward from leaves
        let k = this.graph.nodeCount;
        while (k-- > 0) {
            const v = topoOrder[k];
            for (const e of this.graph.inEdges[v]) {
                const u = e.source;
                const l = layering[v] + e.separation;
                if (layering[u] < l)
                    layering[u] = l;
            }
        }
        return layering;
    }
    checkTopoOrder(topoOrder) {
        for (const e of this.graph.edges) {
            if (edgeIsOff(e, topoOrder)) {
                return false;
            }
        }
        return true;
    }
    constructor(graph) {
        this.graph = graph;
    }
}
function edgeIsOff(e, topoOrder) {
    const i = topoOrder.findIndex((x) => x === e.source);
    const j = topoOrder.findIndex((x) => x === e.target);
    if (i === -1 || j === -1 || i >= j) {
        return true;
    }
    return false;
}
//# sourceMappingURL=longestPathLayering.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/layering/networkEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkEdge: () => (/* binding */ NetworkEdge)
/* harmony export */ });
class NetworkEdge {
    constructor(e) {
        this.inTree = false;
        this.cut = NetworkEdge.infinity;
        this.iedge = e;
    }
    get source() {
        return this.iedge.source;
    }
    get target() {
        return this.iedge.target;
    }
    get separation() {
        return this.iedge.separation;
    }
    get crossingWeight() {
        return this.iedge.CrossingWeight;
    }
    get weight() {
        return this.iedge.weight;
    }
}
NetworkEdge.infinity = Number.MAX_SAFE_INTEGER;
//# sourceMappingURL=networkEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/ordering/edgeComparerBySource.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeComparerBySource: () => (/* binding */ EdgeComparerBySource)
/* harmony export */ });
class EdgeComparerBySource {
    constructor(X) {
        this.x = X;
    }
    Compare(a, b) {
        const r = this.x[a.Source] - this.x[b.Source];
        if (r !== 0)
            return r;
        return this.x[a.Target] - this.x[b.Target];
    }
}
//# sourceMappingURL=edgeComparerBySource.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/ordering/edgeComparerByTarget.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeComparerByTarget: () => (/* binding */ EdgeComparerByTarget)
/* harmony export */ });
class EdgeComparerByTarget {
    constructor(X) {
        this.x = X;
    }
    Compare(a, b) {
        const r = this.x[a.Target] - this.x[b.Target];
        if (r !== 0)
            return r;
        return this.x[a.Source] - this.x[b.Source];
    }
}
//# sourceMappingURL=edgeComparerByTarget.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/ordering/metroMapOrdering.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MetroMapOrdering: () => (/* binding */ MetroMapOrdering)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
// Following "Improving Layered Graph Layouts with Edge Bundling" and
// "Two polynomial time algorithms for the bundle-Line crossing minimization problem"
// Postprocessing minimizing crossings step that works on the layered graph



class MetroMapOrdering {
    constructor(properLayeredGraph, layerArrays, nodePositions) {
        this.properLayeredGraph = properLayeredGraph;
        this.layerArrays = layerArrays;
        this.nodePositions = nodePositions;
    }
    // Reorder only points having identical nodePositions
    static UpdateLayerArrays0(properLayeredGraph, layerArrays, nodePositions) {
        new MetroMapOrdering(properLayeredGraph, layerArrays, nodePositions).UpdateLayerArrays();
    }
    // Reorder virtual nodes between the same pair of real nodes
    static UpdateLayerArrays1(properLayeredGraph, layerArrays) {
        /*Assert.assert(layersAreCorrect(layerArrays))*/
        const nodePositions = MetroMapOrdering.BuildInitialNodePositions(properLayeredGraph, layerArrays);
        /*Assert.assert(layersAreCorrect(layerArrays))*/
        this.UpdateLayerArrays0(properLayeredGraph, layerArrays, nodePositions);
        /*Assert.assert(layersAreCorrect(layerArrays))*/
    }
    static BuildInitialNodePositions(properLayeredGraph, layerArrays) {
        const result = new Map();
        for (let i = 0; i < layerArrays.Layers.length; i++) {
            let curr = 0;
            let prev = 0;
            while (curr < layerArrays.Layers[i].length) {
                while (curr < layerArrays.Layers[i].length && properLayeredGraph.IsVirtualNode(layerArrays.Layers[i][curr])) {
                    curr++;
                }
                for (let j = prev; j < curr; j++) {
                    result.set(layerArrays.Layers[i][j], new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(i, prev));
                }
                if (curr < layerArrays.Layers[i].length) {
                    result.set(layerArrays.Layers[i][curr], new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(i, curr));
                }
                curr++;
                prev = curr;
            }
        }
        return result;
    }
    UpdateLayerArrays() {
        // algo stuff here
        let ordering = this.CreateInitialOrdering();
        ordering = this.BuildOrdering(ordering);
        this.RestoreLayerArrays(ordering);
    }
    CreateInitialOrdering() {
        const initialOrdering = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_2__.PointMap();
        for (const layer of this.layerArrays.Layers) {
            for (const node of layer) {
                const p = this.nodePositions.get(node);
                if (!initialOrdering.hasxy(p.x, p.y)) {
                    initialOrdering.setxy(p.x, p.y, []);
                }
                initialOrdering.getxy(p.x, p.y).push(node);
            }
        }
        return initialOrdering;
    }
    BuildOrdering(initialOrdering) {
        // run through nodes points and build order
        const result = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_2__.PointMap();
        const inverseOrder = new Map();
        for (const layer of this.layerArrays.Layers) {
            for (const node of layer) {
                // already processed
                const p = this.nodePositions.get(node);
                if (result.hasxy(p.x, p.y)) {
                    continue;
                }
                this.BuildNodeOrdering(initialOrdering.get(p), inverseOrder);
                result.set(p, initialOrdering.get(p));
            }
        }
        return result;
    }
    BuildNodeOrdering(result, inverseToOrder) {
        result.sort(this.Comparison(inverseToOrder));
        for (let i = 0; i < result.length; i++) {
            inverseToOrder.set(result[i], i);
        }
    }
    firstSucc(node) {
        for (const s of this.properLayeredGraph.Succ(node)) {
            return s;
        }
    }
    firstPred(node) {
        for (const s of this.properLayeredGraph.Pred(node)) {
            return s;
        }
    }
    Comparison(inverseToOrder) {
        return (node1, node2) => {
            /*Assert.assert(
              this.properLayeredGraph.IsVirtualNode(node1) &&
                this.properLayeredGraph.IsVirtualNode(node2),
            )*/
            const succ1 = this.firstSucc(node1);
            const succ2 = this.firstSucc(node2);
            let pred1 = this.firstPred(node1);
            let pred2 = this.firstPred(node2);
            const succPoint1 = this.nodePositions.get(succ1);
            const succPoint2 = this.nodePositions.get(succ2);
            const predPoint1 = this.nodePositions.get(pred1);
            const predPoint2 = this.nodePositions.get(pred2);
            if (!succPoint1.equal(succPoint2)) {
                if (!predPoint1.equal(predPoint2)) {
                    return predPoint1.compareTo(predPoint2);
                }
                return succPoint1.compareTo(succPoint2);
            }
            if (this.properLayeredGraph.IsVirtualNode(succ1)) {
                if (!predPoint1.equal(predPoint2)) {
                    return predPoint1.compareTo(predPoint2);
                }
                const o1 = inverseToOrder.get(succ1);
                const o2 = inverseToOrder.get(succ2);
                /*Assert.assert(o1 !== -1 && o2 !== -1)*/
                return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(o1, o2);
            }
            while (this.nodePositions.get(pred1).equal(this.nodePositions.get(pred2)) && this.properLayeredGraph.IsVirtualNode(pred1)) {
                pred1 = this.firstPred(pred1);
                pred2 = this.firstPred(pred2);
            }
            if (this.nodePositions.get(pred1).equal(this.nodePositions.get(pred2))) {
                return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(node1, node2);
            }
            return this.nodePositions.get(pred1).compareTo(this.nodePositions.get(pred2));
        };
    }
    RestoreLayerArrays(ordering) {
        for (const layer of this.layerArrays.Layers) {
            let tec = 0;
            let pred = 0;
            while (tec < layer.length) {
                while (tec < layer.length && this.nodePositions.get(layer[pred]).equal(this.nodePositions.get(layer[tec]))) {
                    tec++;
                }
                const t = ordering.get(this.nodePositions.get(layer[pred]));
                for (let j = pred; j < tec; j++) {
                    layer[j] = t[j - pred];
                }
                pred = tec;
            }
        }
        this.layerArrays.UpdateXFromLayers();
    }
}
//# sourceMappingURL=metroMapOrdering.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/ordering/ordering.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetCrossingsTotal: () => (/* binding */ GetCrossingsTotal),
/* harmony export */   Ordering: () => (/* binding */ Ordering)
/* harmony export */ });
/* harmony import */ var _utils_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/copy.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");
/* harmony import */ var _orderingMeasure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/ordering/orderingMeasure.js");
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var _edgeComparerBySource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/ordering/edgeComparerBySource.js");
/* harmony import */ var _edgeComparerByTarget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/ordering/edgeComparerByTarget.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
// Following "A technique for Drawing Directed Graphs" of Gansner, Koutsofios, North and Vo








// Works on the layered graph.
// See GraphLayout.pdfhttps://www.researchgate.net/profile/Lev_Nachmanson/publication/30509007_Drawing_graphs_with_GLEE/links/54b6b2930cf2e68eb27edf71/Drawing-graphs-with-GLEE.pdf
function HeadOfTheCoin() {
    return (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randomInt)(2) === 0;
}
// This method can be improved: see the paper Simple And Efficient ...
function GetCrossingCountFromStrip(bottom, properLayeredGraph, layerArrays) {
    const topVerts = layerArrays.Layers[bottom + 1];
    const bottomVerts = layerArrays.Layers[bottom];
    if (bottomVerts.length <= topVerts.length)
        return GetCrossingCountFromStripWhenBottomLayerIsShorter(bottomVerts, properLayeredGraph, layerArrays);
    else
        return GetCrossingCountFromStripWhenTopLayerIsShorter(topVerts, bottomVerts, properLayeredGraph, layerArrays);
}
function GetCrossingCountFromStripWhenTopLayerIsShorter(topVerts, bottomVerts, properLayeredGraph, layerArrays) {
    const edges = EdgesOfStrip(bottomVerts, properLayeredGraph);
    const comparer = new _edgeComparerByTarget__WEBPACK_IMPORTED_MODULE_5__.EdgeComparerByTarget(layerArrays.x);
    edges.sort((a, b) => comparer.Compare(a, b));
    //find first n such that 2^n >=topVerts.length
    let n = 1;
    while (n < topVerts.length)
        n *= 2;
    //init the accumulator tree
    const tree = new Array(2 * n - 1).fill(0);
    n--; // the first bottom node starts from n now
    let cc = 0; //number of crossings
    for (const edge of edges) {
        let index = n + layerArrays.x[edge.Source];
        const ew = edge.CrossingWeight;
        tree[index] += ew;
        while (index > 0) {
            if (index % 2 !== 0)
                cc += ew * tree[index + 1]; //intersect everything accumulated in the right sibling
            index = Math.floor((index - 1) / 2);
            tree[index] += ew;
        }
    }
    return cc;
}
// see: Simple and Efficient Bilayer Cross Counting, by Wilhelm Barth, Petra Mutzel
function GetCrossingCountFromStripWhenBottomLayerIsShorter(bottomVerts, properLayeredGraph, layerArrays) {
    const edges = EdgesOfStrip(bottomVerts, properLayeredGraph);
    const comparer = new _edgeComparerBySource__WEBPACK_IMPORTED_MODULE_4__.EdgeComparerBySource(layerArrays.x);
    edges.sort((a, b) => comparer.Compare(a, b));
    //find first n such that 2^n >=bottomVerts.length
    let n = 1;
    while (n < bottomVerts.length)
        n *= 2;
    //init accumulator
    const tree = new Array(2 * n - 1).fill(0);
    n--; // the first bottom node starts from n now
    let cc = 0; //number of crossings
    for (const edge of edges) {
        let index = n + layerArrays.x[edge.Target];
        const ew = edge.CrossingWeight;
        tree[index] += ew;
        while (index > 0) {
            if (index % 2 !== 0)
                cc += ew * tree[index + 1]; //intersect everything accumulated in the right sibling
            index = Math.floor((index - 1) / 2);
            tree[index] += ew;
        }
    }
    return cc;
}
function EdgesOfStrip(bottomVerts, properLayeredGraph) {
    return (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_7__.flattenArray)(bottomVerts, (v) => properLayeredGraph.InEdges(v));
}
function GetCrossingsTotal(properLayeredGraph, layerArrays) {
    let x = 0;
    for (let i = 0; i < layerArrays.Layers.length - 1; i++)
        x += GetCrossingCountFromStrip(i, properLayeredGraph, layerArrays);
    return x;
}
class Ordering extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_6__.Algorithm {
    get NoGainStepsBound() {
        return this.SugSettings.NoGainAdjacentSwapStepsBound * this.SugSettings.NoGainStepsForOrderingMultiplier;
    }
    // gets the random seed for some random choices inside of layer ordering
    get SeedOfRandom() {
        return (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randomInt)(100);
    }
    constructor(graphPar, tryReverse, layerArraysParam, startOfVirtualNodes, hasCrossWeights, settings, cancelToken) {
        super(cancelToken);
        this.tryReverse = true;
        // Gets or sets the number of of passes over all layers to rung adjacent exchanges, where every pass goes '
        // all way up to the top layer and down to the lowest layer
        this.MaxNumberOfAdjacentExchanges = 50;
        this.cancelToken = cancelToken;
        this.tryReverse = tryReverse;
        this.startOfVirtNodes = startOfVirtualNodes;
        this.layerArrays = layerArraysParam;
        this.layering = layerArraysParam.y;
        this.nOfLayers = layerArraysParam.Layers.length;
        this.layers = layerArraysParam.Layers;
        this.properLayeredGraph = graphPar;
        this.hasCrossWeights = hasCrossWeights;
        this.SugSettings = settings;
    }
    // an upper limit on a number of passes in layer ordering
    get MaxOfIterations() {
        return this.SugSettings.MaxNumberOfPassesInOrdering * this.SugSettings.NoGainStepsForOrderingMultiplier;
    }
    static OrderLayers(graph, layerArrays, startOfVirtualNodes, settings, cancelToken) {
        let hasCrossWeight = false;
        for (const le of graph.Edges)
            if (le.CrossingWeight !== 1) {
                hasCrossWeight = true;
                break;
            }
        const o = new Ordering(graph, true, layerArrays, startOfVirtualNodes, hasCrossWeight, settings, cancelToken);
        o.run();
    }
    run() {
        // #if DEBUGORDERING
        // if (graph.NumberOfVertices !== layering.length)
        //  throw new System.Exception("the layering does not correspond to the graph");
        // for (IntEdge e of graph.Edges)
        // if (layering[e.Source] - layering[e.Target] !== 1)
        //  throw new System.Exception("the edge in the graph does not span exactly one layer:" + e);
        // #endif
        this.Calculate();
        if ( /*orderingMeasure.x>0 &&*/this.tryReverse) {
            const secondLayers = this.layerArrays.ReversedClone();
            const revOrdering = new Ordering(this.properLayeredGraph.ReversedClone(), false, secondLayers, this.startOfVirtNodes, this.hasCrossWeights, this.SugSettings, this.cancelToken);
            revOrdering.run();
            if (_orderingMeasure__WEBPACK_IMPORTED_MODULE_2__.OrderingMeasure.less(revOrdering.measure, this.measure)) {
                for (let j = 0; j < this.nOfLayers; j++)
                    (0,_utils_copy__WEBPACK_IMPORTED_MODULE_0__.copyTo)(secondLayers.Layers[j], this.layerArrays.Layers[this.nOfLayers - 1 - j]);
                this.layerArrays.UpdateXFromLayers();
            }
        }
    }
    Calculate() {
        this.Init();
        this.layerArraysCopy = Ordering.CloneLayers(this.layers, this.layerArraysCopy);
        let countOfNoGainSteps = 0;
        this.measure = new _orderingMeasure__WEBPACK_IMPORTED_MODULE_2__.OrderingMeasure(this.layerArraysCopy, GetCrossingsTotal(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes);
        //Stopwatch sw = Stopwatch.StartNew();
        for (let i = 0; i < this.MaxOfIterations && countOfNoGainSteps < this.NoGainStepsBound && !this.measure.IsPerfect(); i++) {
            const up = i % 2 === 0;
            this.LayerByLayerSweep(up);
            this.AdjacentExchange();
            const newMeasure = new _orderingMeasure__WEBPACK_IMPORTED_MODULE_2__.OrderingMeasure(this.layerArrays.Layers, GetCrossingsTotal(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes);
            if (_orderingMeasure__WEBPACK_IMPORTED_MODULE_2__.OrderingMeasure.less(this.measure, newMeasure)) {
                this.Restore();
                countOfNoGainSteps++;
            }
            else if (_orderingMeasure__WEBPACK_IMPORTED_MODULE_2__.OrderingMeasure.less(newMeasure, this.measure) || HeadOfTheCoin()) {
                countOfNoGainSteps = 0;
                this.layerArraysCopy = Ordering.CloneLayers(this.layers, this.layerArraysCopy);
                this.measure = newMeasure;
            }
        }
    }
    static CloneLayers(layers, layerArraysCopy) {
        if (layerArraysCopy == null) {
            layerArraysCopy = new Array(layers.length);
            for (let i = 0; i < layers.length; i++)
                layerArraysCopy[i] = layers[i].map((i) => i);
        }
        else
            for (let i = 0; i < layers.length; i++)
                (0,_utils_copy__WEBPACK_IMPORTED_MODULE_0__.copyTo)(layers[i], layerArraysCopy[i]);
        return layerArraysCopy;
    }
    Restore() {
        this.layerArrays.updateLayers(this.layerArraysCopy);
    }
    LayerByLayerSweep(up) {
        if (up) {
            for (let i = 1; i < this.nOfLayers; i++)
                this.SweepLayer(i, true);
        }
        else
            for (let i = this.nOfLayers - 2; i >= 0; i--)
                this.SweepLayer(i, false);
    }
    // the layer layer-1 is fixed if
    // upperLayer us true and layer+1 is fixed in
    // the opposite case
    // the layer with index "layer" is updated
    // of the strip</param>
    SweepLayer(layer, upperLayer) {
        const l = this.layers[layer];
        const medianValues = new Array(l.length);
        for (let i = 0; i < medianValues.length; i++)
            medianValues[i] = this.WMedian(l[i], upperLayer);
        this.Sort(layer, medianValues);
        //update X
        const vertices = this.layerArrays.Layers[layer];
        for (let i = 0; i < vertices.length; i++)
            this.layerArrays.x[vertices[i]] = i;
    }
    // sorts layerToSort according to medianValues
    // if medianValues[i] is -1 then layer[i] does not move
    Sort(layerToSort, medianValues) {
        const s = new Map();
        const vertices = this.layers[layerToSort];
        let i = 0;
        for (const m of medianValues) {
            const v = vertices[i++];
            if (m === -1.0)
                continue;
            if (!s.has(m))
                s.set(m, v);
            else {
                const o = s.get(m);
                if (!(typeof o === 'number')) {
                    const al = o;
                    if (HeadOfTheCoin())
                        al.push(v);
                    else {
                        //stick it in the middle
                        const j = (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randomInt)(al.length);
                        const k = al[j];
                        al[j] = v;
                        al.push(k);
                    }
                }
                else {
                    const io = o;
                    const al = new Array();
                    s.set(m, al);
                    if (HeadOfTheCoin()) {
                        al.push(io);
                        al.push(v);
                    }
                    else {
                        al.push(v);
                        al.push(io);
                    }
                }
            }
        }
        const senum = Array.from(s).sort((a, b) => a[0] - b[0]).map(a => a[1]);
        let j = 0;
        for (i = 0; i < vertices.length;) {
            if (medianValues[i] !== -1) {
                const o = senum[j++];
                if (typeof o === 'number')
                    vertices[i++] = o;
                else {
                    const al = o;
                    for (const v of al) {
                        //find the first empty spot
                        while (medianValues[i] === -1)
                            i++;
                        vertices[i++] = v;
                    }
                }
            }
            else
                i++;
        }
    }
    WMedian(node, theMedianGoingDown) {
        let edges;
        let p;
        if (theMedianGoingDown) {
            edges = this.properLayeredGraph.OutEdges(node);
            p = this.properLayeredGraph.OutEdgesCount(node);
        }
        else {
            edges = this.properLayeredGraph.InEdges(node);
            p = this.properLayeredGraph.InEdgesCount(node);
        }
        if (p === 0)
            return -1.0;
        const parray = new Array(p); //we do not have multiple edges
        let i = 0;
        if (theMedianGoingDown)
            for (const e of edges)
                parray[i++] = this.X[e.Target];
        else
            for (const e of edges)
                parray[i++] = this.X[e.Source];
        parray.sort((a, b) => a - b);
        const m = Math.floor(p / 2);
        if (p % 2 === 1)
            return parray[m];
        if (p === 2)
            return 0.5 * (parray[0] + parray[1]);
        const left = parray[m - 1] - parray[0];
        const right = parray[p - 1] - parray[m];
        return Math.floor((parray[m - 1] * left + parray[m] * right) / (left + right));
    }
    // Just depth search and assign the index saying when the node was visited
    Init() {
        const counts = new Array(this.nOfLayers).fill(0);
        //the initial layers are set by following the order of the
        //depth first traversal inside one layer
        const q = new stack_typescript__WEBPACK_IMPORTED_MODULE_3__.Stack();
        //enqueue all sources of the graph
        for (let i = 0; i < this.properLayeredGraph.NodeCount; i++)
            if (this.properLayeredGraph.InEdgesCount(i) === 0)
                q.push(i);
        const visited = new Array(this.properLayeredGraph.NodeCount).fill(false);
        while (q.size > 0) {
            const u = q.pop();
            const l = this.layerArrays.y[u];
            this.layerArrays.Layers[l][counts[l]] = u;
            this.layerArrays.x[u] = counts[l];
            counts[l]++;
            for (const v of this.properLayeredGraph.Succ(u))
                if (!visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
        }
        this.X = this.layerArrays.x;
    }
    AdjacentExchange() {
        this.InitArrays();
        let count = 0;
        let progress = true;
        while (progress && count++ < this.MaxNumberOfAdjacentExchanges) {
            progress = false;
            for (let i = 0; i < this.layers.length; i++)
                progress = this.AdjExchangeLayer(i) || progress;
            for (let i = this.layers.length - 2; i >= 0; i--)
                progress = this.AdjExchangeLayer(i) || progress;
        }
    }
    AllocArrays() {
        const n = this.properLayeredGraph.NodeCount;
        this.predecessors = new Array(n);
        this.successors = new Array(n);
        this.pOrder = new Array(n);
        this.sOrder = new Array(n);
        if (this.hasCrossWeights) {
            this.outCrossingCount = new Array(n);
            this.inCrossingCount = new Array(n);
        }
        for (let i = 0; i < n; i++) {
            let count = this.properLayeredGraph.InEdgesCount(i);
            this.predecessors[i] = new Array(count);
            if (this.hasCrossWeights) {
                const inCounts = (this.inCrossingCount[i] = new Map());
                for (const le of this.properLayeredGraph.InEdges(i))
                    inCounts.set(le.Source, le.CrossingWeight);
            }
            this.pOrder[i] = new Map();
            count = this.properLayeredGraph.OutEdgesCount(i);
            this.successors[i] = new Array(count);
            this.sOrder[i] = new Map();
            if (this.hasCrossWeights) {
                const outCounts = (this.outCrossingCount[i] = new Map());
                for (const le of this.properLayeredGraph.OutEdges(i))
                    outCounts.set(le.Target, le.CrossingWeight);
            }
        }
    }
    // Is called just after median layer swap is done
    InitArrays() {
        if (this.successors == null)
            this.AllocArrays();
        for (let i = 0; i < this.properLayeredGraph.NodeCount; i++) {
            this.pOrder[i] = new Map();
            this.sOrder[i] = new Map();
        }
        for (const t of this.layers)
            this.InitPsArraysForLayer(t);
    }
    // calculates the number of intersections between edges adjacent to u and v
    CalcPair(u, v) {
        const su = this.successors[u];
        const sv = this.successors[v];
        const pu = this.predecessors[u];
        const pv = this.predecessors[v];
        if (!this.hasCrossWeights) {
            return {
                cuv: this.CountOnArrays(su, sv) + this.CountOnArrays(pu, pv),
                cvu: this.CountOnArrays(sv, su) + this.CountOnArrays(pv, pu),
            };
        }
        else {
            const uOutCrossCounts = this.outCrossingCount[u];
            const vOutCrossCounts = this.outCrossingCount[v];
            const uInCrossCounts = this.inCrossingCount[u];
            const vInCrossCounts = this.inCrossingCount[v];
            return {
                cuv: this.CountOnArraysUV(su, sv, uOutCrossCounts, vOutCrossCounts) + this.CountOnArraysUV(pu, pv, uInCrossCounts, vInCrossCounts),
                cvu: this.CountOnArraysUV(sv, su, vOutCrossCounts, uOutCrossCounts) + this.CountOnArraysUV(pv, pu, vInCrossCounts, uInCrossCounts),
            };
        }
    }
    // Sweep layer from left to right and fill S,P arrays as we go.
    // The arrays P and S will be sorted according to X. Note that we will not keep them sorted
    // as we doing adjacent swaps. Initial sorting only needed to calculate initial clr,crl values.
    InitPsArraysForLayer(layer) {
        for (const l of layer) {
            for (const p of this.properLayeredGraph.Pred(l)) {
                const so = this.sOrder[p];
                const sHasNow = so.size;
                this.successors[p][sHasNow] = l; //l takes the first available slot in S[p]
                so.set(l, sHasNow);
            }
            for (const s of this.properLayeredGraph.Succ(l)) {
                const po = this.pOrder[s];
                const pHasNow = po.size;
                this.predecessors[s][pHasNow] = l; //l take the first available slot in P[s]
                po.set(l, pHasNow);
            }
        }
    }
    CountOnArrays(unbs, vnbs) {
        let ret = 0;
        const vl = vnbs.length - 1;
        let j = -1; //the right most position of vnbs to the left from the current u neighbor
        let vnbsSeenAlready = 0;
        for (const uNeighbor of unbs) {
            const xu = this.X[uNeighbor];
            for (; j < vl && this.X[vnbs[j + 1]] < xu; j++)
                vnbsSeenAlready++;
            ret += vnbsSeenAlready;
        }
        return ret;
    }
    // every inversion between unbs and vnbs gives an intersecton
    CountOnArraysUV(unbs, vnbs, uCrossingCounts, vCrossingCount) {
        let ret = 0;
        const vl = vnbs.length - 1;
        let j = -1; //the right most position of vnbs to the left from the current u neighbor
        let vCrossingNumberSeenAlready = 0;
        for (const uNeib of unbs) {
            const xu = this.X[uNeib];
            let vnb;
            for (; j < vl && this.X[(vnb = vnbs[j + 1])] < xu; j++)
                vCrossingNumberSeenAlready += vCrossingCount.get(vnb);
            ret += vCrossingNumberSeenAlready * uCrossingCounts.get(uNeib);
        }
        return ret;
    }
    AdjExchangeLayer(i) {
        const layer = this.layers[i];
        const gain = this.ExchangeWithGainWithNoDisturbance(layer);
        if (gain)
            return true;
        this.DisturbLayer(layer);
        return this.ExchangeWithGainWithNoDisturbance(layer);
    }
    //in this routine u and v are adjacent, and u is to the left of v before the swap
    Swap(u, v) {
        const left = this.X[u];
        const right = this.X[v];
        const ln = this.layering[u]; //layer number
        const layer = this.layers[ln];
        layer[left] = v;
        layer[right] = u;
        this.X[u] = right;
        this.X[v] = left;
        //update sorted arrays POrders and SOrders
        //an array should be updated only in case it contains both u and v.
        // More than that, v has to follow u in an the array.
        this.UpdateSsContainingUv(u, v);
        this.UpdatePsContainingUv(u, v);
    }
    UpdatePsContainingUv(u, v) {
        if (this.successors[u].length <= this.successors[v].length)
            for (const a of this.successors[u]) {
                const porder = this.pOrder[a];
                //of course porder contains u, let us see if it contains v
                if (porder.has(v)) {
                    const vOffset = porder.get(v);
                    //swap u and v in the array P[coeff]
                    const p = this.predecessors[a];
                    p[vOffset - 1] = v;
                    p[vOffset] = u;
                    //update sorder itself
                    porder.set(v, vOffset - 1);
                    porder.set(u, vOffset);
                }
            }
        else
            for (const a of this.successors[v]) {
                const porder = this.pOrder[a];
                //of course porder contains u, let us see if it contains v
                if (porder.has(u)) {
                    const vOffset = porder.get(v);
                    //swap u and v in the array P[coeff]
                    const p = this.predecessors[a];
                    p[vOffset - 1] = v;
                    p[vOffset] = u;
                    //update sorder itself
                    porder.set(v, vOffset - 1);
                    porder.set(u, vOffset);
                }
            }
    }
    UpdateSsContainingUv(u, v) {
        if (this.predecessors[u].length <= this.predecessors[v].length)
            for (const a of this.predecessors[u]) {
                const sorder = this.sOrder[a];
                //of course sorder contains u, let us see if it contains v
                if (sorder.has(v)) {
                    const vOffset = sorder.get(v);
                    //swap u and v in the array S[coeff]
                    const s = this.successors[a];
                    s[vOffset - 1] = v;
                    s[vOffset] = u;
                    //update sorder itself
                    sorder.set(v, vOffset - 1);
                    sorder.set(u, vOffset);
                }
            }
        else
            for (const a of this.predecessors[v]) {
                const sorder = this.sOrder[a];
                //of course sorder contains u, let us see if it contains v
                if (sorder.has(u)) {
                    const vOffset = sorder.get(v);
                    //swap u and v in the array S[coeff]
                    const s = this.successors[a];
                    s[vOffset - 1] = v;
                    s[vOffset] = u;
                    //update sorder itself
                    sorder.set(v, vOffset - 1);
                    sorder.set(u, vOffset);
                }
            }
    }
    DisturbLayer(layer) {
        for (let i = 0; i < layer.length - 1; i++)
            this.AdjacentSwapToTheRight(layer, i);
    }
    ExchangeWithGainWithNoDisturbance(layer) {
        let wasGain = false;
        let gain;
        do {
            gain = this.ExchangeWithGain(layer);
            wasGain = wasGain || gain;
        } while (gain);
        return wasGain;
    }
    ExchangeWithGain(layer) {
        //find a first pair giving some gain
        for (let i = 0; i < layer.length - 1; i++)
            if (this.SwapWithGain(layer[i], layer[i + 1])) {
                this.SwapToTheLeft(layer, i);
                this.SwapToTheRight(layer, i + 1);
                return true;
            }
        return false;
    }
    SwapToTheLeft(layer, i) {
        for (let j = i - 1; j >= 0; j--)
            this.AdjacentSwapToTheRight(layer, j);
    }
    SwapToTheRight(layer, i) {
        for (let j = i; j < layer.length - 1; j++)
            this.AdjacentSwapToTheRight(layer, j);
    }
    // swaps i-th element with i+1
    AdjacentSwapToTheRight(layer, i) {
        const u = layer[i];
        const v = layer[i + 1];
        const gain = this.SwapGain(u, v);
        if (gain > 0 || (gain === 0 && HeadOfTheCoin()))
            this.Swap(u, v);
    }
    SwapGain(u, v) {
        const r = this.CalcPair(u, v);
        return r.cuv - r.cvu;
    }
    UvAreOfSameKind(u, v) {
        return (u < this.startOfVirtNodes && v < this.startOfVirtNodes) || (u >= this.startOfVirtNodes && v >= this.startOfVirtNodes);
    }
    NeighborsForbidTheSwap(u, v) {
        return this.UpperNeighborsForbidTheSwap(u, v) || this.LowerNeighborsForbidTheSwap(u, v);
    }
    LowerNeighborsForbidTheSwap(u, v) {
        let uCount;
        let vCount;
        if ((uCount = this.properLayeredGraph.OutEdgesCount(u)) === 0 || (vCount = this.properLayeredGraph.OutEdgesCount(v)) === 0)
            return false;
        return this.X[this.successors[u][uCount >> 1]] < this.X[this.successors[v][vCount >> 1]];
    }
    UpperNeighborsForbidTheSwap(u, v) {
        const uCount = this.properLayeredGraph.InEdgesCount(u);
        const vCount = this.properLayeredGraph.InEdgesCount(v);
        if (uCount === 0 || vCount === 0)
            return false;
        return this.X[this.predecessors[u][uCount >> 1]] < this.X[this.predecessors[v][vCount >> 1]];
    }
    CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(layer, separatorPosition, separator) {
        const kind = this.GetKindDelegate(separator);
        let leftGroupSize = 0;
        for (let i = separatorPosition - 1; i >= 0 && !kind(layer[i]); i--)
            leftGroupSize++;
        let rightGroupSize = 0;
        for (let i = separatorPosition + 1; i < layer.length && !kind(layer[i]); i++)
            rightGroupSize++;
        return leftGroupSize - rightGroupSize;
    }
    IsOriginal(v) {
        return v < this.startOfVirtNodes;
    }
    IsVirtual(v) {
        return v >= this.startOfVirtNodes;
    }
    GetKindDelegate(v) {
        return this.IsVirtual(v) ? this.IsVirtual : this.IsOriginal;
    }
    // swaps two vertices only if reduces the number of intersections
    SwapWithGain(u, v) {
        const gain = this.SwapGain(u, v);
        if (gain > 0) {
            this.Swap(u, v);
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=ordering.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/ordering/orderingMeasure.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrderingMeasure: () => (/* binding */ OrderingMeasure)
/* harmony export */ });
class OrderingMeasure {
    constructor(layerArraysPar, numOfCrossings, virtualVertexStart) {
        this.numberOfCrossings = numOfCrossings;
        this.la = layerArraysPar;
        this.virtVertexStart = virtualVertexStart;
    }
    LayerGroupDisbalance(l, origGroupOptSize, virtGroupOptSize) {
        if (origGroupOptSize === 1)
            return this.LayerGroupDisbalanceWithOrigSeparators(l, virtGroupOptSize);
        else
            return this.LayerGroupDisbalanceWithVirtSeparators(l, origGroupOptSize);
    }
    LayerGroupDisbalanceWithVirtSeparators(l, origGroupOptSize) {
        let ret = 0;
        for (let i = 0; i < l.length;) {
            const r = this.CurrentOrigGroupDelta(i, l, origGroupOptSize);
            i = r.i;
            ret += r.ret;
        }
        return ret;
    }
    CurrentOrigGroupDelta(i, l, origGroupOptSize) {
        let groupSize = 0;
        let j = i;
        for (; j < l.length && l[j] < this.virtVertexStart; j++)
            groupSize++;
        i = j + 1;
        return { ret: Math.abs(origGroupOptSize - groupSize), i };
    }
    LayerGroupDisbalanceWithOrigSeparators(l, virtGroupOptSize) {
        let ret = 0;
        for (let i = 0; i < l.length;) {
            const r = this.CurrentVirtGroupDelta(i, l, virtGroupOptSize);
            ret += r.ret;
            i = r.i;
        }
        return ret;
    }
    CurrentVirtGroupDelta(i, l, virtGroupOptSize) {
        let groupSize = 0;
        let j = i;
        for (; j < l.length && l[j] >= this.virtVertexStart; j++)
            groupSize++;
        i = j + 1;
        return { ret: Math.abs(virtGroupOptSize - groupSize), i: i };
    }
    static less(a, b) {
        return a.numberOfCrossings < b.numberOfCrossings;
    }
    static greater(a, b) {
        return a.numberOfCrossings > b.numberOfCrossings;
    }
    IsPerfect() {
        return this.numberOfCrossings === 0;
    }
}
//# sourceMappingURL=orderingMeasure.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/polyIntEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolyIntEdge: () => (/* binding */ PolyIntEdge)
/* harmony export */ });
/* harmony import */ var _layerEdge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layerEdge.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");




class Routing {
    static FindClosestPoints(segmentInFrontOfLabel, labelSide) {
        const minDistOutput = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.minDistWithinIntervals(segmentInFrontOfLabel, labelSide, segmentInFrontOfLabel.parStart, segmentInFrontOfLabel.parEnd, labelSide.parStart, labelSide.parEnd, (segmentInFrontOfLabel.parStart + segmentInFrontOfLabel.parEnd) / 2, (labelSide.parStart + labelSide.parEnd) / 2);
        if (minDistOutput) {
            return {
                curveClosestPoint: minDistOutput.aX,
                labelSideClosest: minDistOutput.bX,
            };
        }
        return;
    }
    static GetSegmentInFrontOfLabel(edgeCurve, labelY) {
        if (edgeCurve instanceof _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve) {
            for (const seg of edgeCurve.segs)
                if ((seg.start.y - labelY) * (seg.end.y - labelY) <= 0)
                    return seg;
        }
        else {
            /*Assert.assert(false)*/
        }
        return null;
    }
    static ShiftLabel(e, curveClosestPoint, labelSideClosest) {
        const w = e.lineWidth / 2;
        const shift = curveClosestPoint.sub(labelSideClosest);
        const shiftLength = shift.length;
        //  SugiyamaLayoutSettings.Show(e.Curve, shiftLength > 0 ? new LineSegment(curveClosestPoint, labelSideClosest) : null, PolyFromBox(e.label.boundingBox));
        if (shiftLength > w)
            e.label.positionCenter(e.label.center.add(shift.div(shiftLength * (shiftLength - w))));
    }
    static updateLabel(e, anchor) {
        let labelSide = null;
        if (anchor.labelIsToTheRightOfTheSpline) {
            e.label.positionCenter(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.Point(anchor.x + anchor.rightAnchor / 2, anchor.y));
            labelSide = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(e.label.boundingBox.leftTop, e.label.boundingBox.leftBottom);
        }
        else if (anchor.labelIsToTheLeftOfTheSpline) {
            e.label.positionCenter(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.Point(anchor.x - anchor.leftAnchor / 2, anchor.y));
            labelSide = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(e.label.boundingBox.rightTop, e.label.boundingBox.rightBottom);
        }
        const segmentInFrontOfLabel = Routing.GetSegmentInFrontOfLabel(e.curve, e.label.center.y);
        if (segmentInFrontOfLabel == null)
            return;
        if (_math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.getAllIntersections(e.curve, _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.polyFromBox(e.label.boundingBox), false).length === 0) {
            const t = Routing.FindClosestPoints(segmentInFrontOfLabel, labelSide);
            if (t) {
                //shift the label if needed
                Routing.ShiftLabel(e, t.curveClosestPoint, t.labelSideClosest);
            }
            else {
                let curveClosestPoint;
                let labelSideClosest;
                //assume that the distance is reached at the ends of labelSideClosest
                const u = segmentInFrontOfLabel.closestParameter(labelSide.start);
                const v = segmentInFrontOfLabel.closestParameter(labelSide.end);
                if (segmentInFrontOfLabel.value(u).sub(labelSide.start).length < segmentInFrontOfLabel.value(v).sub(labelSide.end).length) {
                    curveClosestPoint = segmentInFrontOfLabel.value(u);
                    labelSideClosest = labelSide.start;
                }
                else {
                    curveClosestPoint = segmentInFrontOfLabel.value(v);
                    labelSideClosest = labelSide.end;
                }
                Routing.ShiftLabel(e, curveClosestPoint, labelSideClosest);
            }
        }
    }
}
// An edge with source and target represented as integers,
// they point to the array of Nodes of the graph
class PolyIntEdge {
    get CrossingWeight() {
        return 1;
    }
    constructor(source, target, geomEdge, weight = 1, separation = 1) {
        this.reversed = false;
        this.source = source;
        this.target = target;
        this.edge = geomEdge;
        this.weight = weight;
        this.separation = separation;
    }
    get hasLabel() {
        return this.edge.label != null;
    }
    get labelWidth() {
        return this.edge.label.width;
    }
    get labelHeight() {
        return this.edge.label.height;
    }
    // This function changes the edge by swapping source and target.
    reverse() {
        const t = this.source;
        this.source = this.target;
        this.target = t;
        this.reversed = !this.reversed;
    }
    toString() {
        return 'edge(' + this.source + '->' + this.target + ')';
    }
    get curve() {
        return this.edge.curve;
    }
    set curve(value) {
        this.edge.curve = value;
    }
    get underlyingPolyline() {
        return this.edge.smoothedPolyline;
    }
    get LayerSpan() {
        return this.LayerEdges != null ? this.LayerEdges.length : 0;
    }
    isSelfEdge() {
        return this.source === this.target;
    }
    reversedClone() {
        const ret = new PolyIntEdge(this.target, this.source, this.edge);
        if (this.LayerEdges != null) {
            const len = this.LayerEdges.length;
            ret.LayerEdges = new Array(len);
            for (let i = 0; i < len; i++) {
                const le = this.LayerEdges[len - 1 - i];
                ret.LayerEdges[i] = new _layerEdge__WEBPACK_IMPORTED_MODULE_0__.LayerEdge(le.Target, le.Source, le.CrossingWeight);
            }
            ret.LayerEdges[0].Source = this.target;
            ret.LayerEdges[this.LayerEdges.length - 1].Target = this.source;
        }
        return ret;
    }
    get count() {
        return this.LayerEdges.length;
    }
    getNode(i) {
        if (i >= 0) {
            if (i < this.LayerEdges.length)
                return this.LayerEdges[i].Source;
            if (i === this.LayerEdges.length)
                return this.LayerEdges[i - 1].Target;
        }
        throw new Error('wrong index ' + i);
    }
    updateEdgeLabelPosition(anchors) {
        if (this.edge.label != null) {
            const m = this.LayerEdges.length / 2;
            const layerEdge = this.LayerEdges[m];
            Routing.updateLabel(this.edge, anchors[layerEdge.Source]);
        }
    }
    [Symbol.iterator]() {
        return this.nodes();
    }
    // enumerates over virtual virtices corresponding to the original edge
    *nodes() {
        yield this.LayerEdges[0].Source;
        for (const le of this.LayerEdges)
            yield le.Target;
    }
}
//# sourceMappingURL=polyIntEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/routing.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Routing: () => (/* binding */ Routing)
/* harmony export */ });
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/sugiyamaLayoutSettings.js");
/* harmony import */ var _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/cornerSite.js");
/* harmony import */ var _NodeKind__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/NodeKind.js");
/* harmony import */ var _core_arrowhead__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/arrowhead.js");
/* harmony import */ var _smoothedPolylineCalculator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/smoothedPolylineCalculator.js");
/* harmony import */ var _routing_splineRouter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/splineRouter.js");
/* harmony import */ var _edgeLabelPlacement__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/edgeLabelPlacement.js");







//import { FlatEdgeRouter } from './FlatEdgeRouter'






// The class responsible for the routing of splines
class Routing extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_5__.Algorithm {
    constructor(settings, originalGraph, dbP, yLayerArrays, properLayeredGraph, intGraph) {
        super(null); // todo: init with the not null canceltoken
        this.settings = settings;
        this.OriginalGraph = originalGraph;
        this.Database = dbP;
        this.ProperLayeredGraph = properLayeredGraph;
        this.LayerArrays = yLayerArrays;
        this.IntGraph = intGraph;
    }
    // Executes the actual algorithm.
    run() {
        this.createSplines();
    }
    // The method does the main work.
    createSplines() {
        this.createRegularSplines();
        this.createSelfSplines();
        if (this.IntGraph != null) {
            this.RouteFlatEdges();
        }
        if (this.OriginalGraph.graph.parent == null) {
            // TODO: just creating straigh line edges for missing ones, hook up SplineRouter
            this.RouteUnroutedEdges();
        }
    }
    RouteUnroutedEdges() {
        const edgesToRoute = [];
        for (const e of this.OriginalGraph.deepEdges) {
            if (!e.curve)
                edgesToRoute.push(e);
        }
        if (edgesToRoute.length == 0) {
            return;
        }
        const sugSettings = this.OriginalGraph.layoutSettings ? this.OriginalGraph.layoutSettings : new _sugiyamaLayoutSettings__WEBPACK_IMPORTED_MODULE_6__.SugiyamaLayoutSettings();
        const ers = sugSettings.commonSettings.edgeRoutingSettings;
        const sr = new _routing_splineRouter__WEBPACK_IMPORTED_MODULE_11__.SplineRouter(this.OriginalGraph, edgesToRoute, ers.padding, ers.polylinePadding, ers.coneAngle, ers.bundlingSettings, this.cancelToken);
        sr.run();
        const elp = _edgeLabelPlacement__WEBPACK_IMPORTED_MODULE_12__.EdgeLabelPlacement.constructorGA(this.OriginalGraph, edgesToRoute);
        elp.run();
    }
    RouteFlatEdges() {
        // throw new Error('not implemented')
        // const flatEdgeRouter = new FlatEdgeRouter(this.settings, this)
        // flatEdgeRouter.run()
    }
    createRegularSplines() {
        for (const intEdgeList of this.Database.RegularMultiedges()) {
            if (betterRouteAsSplines(intEdgeList))
                continue;
            // Here we try to optimize multi-edge routing
            const m = intEdgeList.length;
            const optimizeShortEdges = m === 1 && this.MayOptimizeEdge(intEdgeList[0]);
            for (let i = Math.floor(m / 2); i < m; i++) {
                this.createSplineForNonSelfEdge(intEdgeList[i], optimizeShortEdges);
            }
            for (let i = Math.floor(m / 2) - 1; i >= 0; i--) {
                this.createSplineForNonSelfEdge(intEdgeList[i], optimizeShortEdges);
            }
        }
    }
    MayOptimizeEdge(intEdge) {
        return !(this.ProperLayeredGraph.OutDegreeIsMoreThanOne(intEdge.source) ||
            this.ProperLayeredGraph.InDegreeIsMoreThanOne(intEdge.target) ||
            hasSelfEdge(intEdge.edge.source) ||
            hasSelfEdge(intEdge.edge.target));
    }
    createSelfSplines() {
        for (const [k, v] of this.Database.Multiedges.keyValues()) {
            const ip = k;
            if (ip.x === ip.y) {
                const anchor = this.Database.Anchors[ip.x];
                let offset = anchor.leftAnchor;
                for (const intEdge of v) {
                    const dx = this.settings.NodeSeparation + (this.settings.MinNodeWidth + offset);
                    const dy = anchor.bottomAnchor / 2;
                    const p0 = anchor.origin;
                    const p1 = p0.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(0, dy));
                    const p2 = p0.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(dx, dy));
                    const p3 = p0.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(dx, -dy));
                    const p4 = p0.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(0, -dy));
                    let s = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_7__.CornerSite.mkSiteP(p0);
                    const polyline = new _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_4__.SmoothedPolyline(s);
                    s = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_7__.CornerSite.mkSiteSP(s, p1);
                    s = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_7__.CornerSite.mkSiteSP(s, p2);
                    s = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_7__.CornerSite.mkSiteSP(s, p3);
                    s = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_7__.CornerSite.mkSiteSP(s, p4);
                    _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_7__.CornerSite.mkSiteSP(s, p0);
                    const c = polyline.createCurve();
                    intEdge.curve = c;
                    offset = dx;
                    if (intEdge.edge.label != null) {
                        offset += intEdge.edge.label.width;
                        const curveMiddle = c.value((c.parStart + c.parEnd) / 2);
                        const center = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(curveMiddle.x + intEdge.labelWidth / 2, anchor.y);
                        const del = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(intEdge.edge.label.width / 2, intEdge.edge.label.height / 2);
                        const box = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_3__.Rectangle.mkPP(center.add(del), center.sub(del));
                        intEdge.edge.label.width = box.width;
                        intEdge.edge.label.height = box.height;
                        intEdge.edge.label.positionCenter(center);
                    }
                    _core_arrowhead__WEBPACK_IMPORTED_MODULE_9__.Arrowhead.trimSplineAndCalculateArrowheadsII(intEdge.edge, intEdge.edge.source.boundaryCurve, intEdge.edge.target.boundaryCurve, c, false);
                }
            }
        }
    }
    createSplineForNonSelfEdge(es, optimizeShortEdges) {
        if (es.LayerEdges != null) {
            this.drawSplineBySmothingThePolyline(es, optimizeShortEdges);
            if (!es.IsVirtualEdge) {
                es.updateEdgeLabelPosition(this.Database.Anchors);
                _core_arrowhead__WEBPACK_IMPORTED_MODULE_9__.Arrowhead.trimSplineAndCalculateArrowheadsII(es.edge, es.edge.source.boundaryCurve, es.edge.target.boundaryCurve, es.curve, true);
            }
        }
    }
    drawSplineBySmothingThePolyline(edgePath, optimizeShortEdges) {
        const scalc = new _smoothedPolylineCalculator__WEBPACK_IMPORTED_MODULE_10__.SmoothedPolylineCalculator(edgePath, this.Database.Anchors, this.OriginalGraph, this.settings, this.LayerArrays, this.ProperLayeredGraph, this.Database);
        const spline = scalc.getSpline(optimizeShortEdges);
        if (edgePath.reversed) {
            edgePath.curve = spline.reverse();
        }
        else {
            edgePath.curve = spline;
        }
    }
    // void UpdateEdgeLabelPosition(LayerEdge[][] list, int i) {
    //    IntEdge e;
    //    int labelNodeIndex;
    //    if (Engine.GetLabelEdgeAndVirtualNode(list, i, out e, out labelNodeIndex)) {
    //        UpdateLabel(e, labelNodeIndex, db.Anchors);
    //    }
    // }
    static UpdateLabel(e, anchor) {
        let labelSide = null;
        if (anchor.labelIsToTheRightOfTheSpline) {
            e.label.positionCenter(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(anchor.x + anchor.rightAnchor / 2, anchor.y));
            labelSide = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(e.label.boundingBox.leftTop, e.label.boundingBox.leftBottom);
        }
        else if (anchor.labelIsToTheLeftOfTheSpline) {
            e.label.positionCenter(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point(anchor.x - anchor.leftAnchor / 2, anchor.y));
            labelSide = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(e.label.boundingBox.rightTop, e.label.boundingBox.rightBottom);
        }
        const segmentInFrontOfLabel = Routing.GetSegmentInFrontOfLabel(e.curve, e.label.center.y);
        if (segmentInFrontOfLabel == null) {
            return;
        }
        if (_math_geometry_curve__WEBPACK_IMPORTED_MODULE_0__.Curve.getAllIntersections(e.curve, _math_geometry_curve__WEBPACK_IMPORTED_MODULE_0__.Curve.polyFromBox(e.label.boundingBox), false).length === 0) {
            const t = {
                curveClosestPoint: undefined,
                labelSideClosest: undefined,
            };
            if (Routing.FindClosestPoints(t, segmentInFrontOfLabel, labelSide)) {
                // shift the label if needed
                Routing.ShiftLabel(e, t);
            }
            else {
                // assume that the distance is reached at the ends of labelSideClosest
                const u = segmentInFrontOfLabel.closestParameter(labelSide.start);
                const v = segmentInFrontOfLabel.closestParameter(labelSide.end);
                if (segmentInFrontOfLabel.value(u).sub(labelSide.start).length < segmentInFrontOfLabel.value(v).sub(labelSide.end).length) {
                    t.curveClosestPoint = segmentInFrontOfLabel.value(u);
                    t.labelSideClosest = labelSide.start;
                }
                else {
                    t.curveClosestPoint = segmentInFrontOfLabel.value(v);
                    t.labelSideClosest = labelSide.end;
                }
                Routing.ShiftLabel(e, t);
            }
        }
    }
    static ShiftLabel(e, t) {
        const w = e.lineWidth / 2;
        const shift = t.curveClosestPoint.sub(t.labelSideClosest);
        const shiftLength = shift.length;
        //   SugiyamaLayoutSettings.Show(e.Curve, shiftLength > 0 ? new LineSegment(curveClosestPoint, labelSideClosest) : null, PolyFromBox(e.label.boundingBox));
        if (shiftLength > w) {
            e.label.positionCenter(e.label.center.add(shift.div(shiftLength * (shiftLength - w))));
        }
    }
    static FindClosestPoints(t, segmentInFrontOfLabel, labelSide) {
        const di = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_0__.Curve.minDistWithinIntervals(segmentInFrontOfLabel, labelSide, segmentInFrontOfLabel.parStart, segmentInFrontOfLabel.parEnd, labelSide.parStart, labelSide.parEnd, (segmentInFrontOfLabel.parStart + segmentInFrontOfLabel.parEnd) / 2, (labelSide.parStart + labelSide.parEnd) / 2);
        if (di) {
            t.curveClosestPoint = di.aX;
            t.labelSideClosest = di.bX;
            return true;
        }
        return false;
    }
    static GetSegmentInFrontOfLabel(edgeCurve, labelY) {
        if (edgeCurve instanceof _math_geometry_curve__WEBPACK_IMPORTED_MODULE_0__.Curve) {
            const curve = edgeCurve;
            for (const seg of curve.segs) {
                if ((seg.start.y - labelY) * (seg.end.y - labelY) <= 0) {
                    return seg;
                }
            }
        }
        else {
            /*Assert.assert(false)*/
        }
        // not implemented
        return null;
    }
    static GetNodeKind(vertexOffset, edgePath) {
        return vertexOffset === 0 ? _NodeKind__WEBPACK_IMPORTED_MODULE_8__.NodeKind.Top : vertexOffset < edgePath.count ? _NodeKind__WEBPACK_IMPORTED_MODULE_8__.NodeKind.Internal : _NodeKind__WEBPACK_IMPORTED_MODULE_8__.NodeKind.Bottom;
    }
}
function betterRouteAsSplines(intEdgeList) {
    if (intEdgeList.length < 4)
        return false;
    for (const pie of intEdgeList)
        if (pie.edge.label)
            return false;
    return true;
}
function hasSelfEdge(geomNode) {
    return geomNode.node.selfEdges.size > 0;
}
//# sourceMappingURL=routing.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/smoothedPolylineCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SmoothedPolylineCalculator: () => (/* binding */ SmoothedPolylineCalculator)
/* harmony export */ });
/* harmony import */ var _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/cornerSite.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogram.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js");
/* harmony import */ var _HierarchyCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/HierarchyCalculator.js");
/* harmony import */ var _routing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/routing.js");
/* harmony import */ var _NodeKind__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/NodeKind.js");
/* harmony import */ var _RefinerBetweenTwoLayers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/RefinerBetweenTwoLayers.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");












class SmoothedPolylineCalculator {
    // Creates a smoothed polyline
    constructor(edgePathPar, anchorsP, origGraph, settings, la, layerGraph, databaseP) {
        this.thinRightNodes = new Array();
        this.thinWestNodes = new Array();
        this.database = databaseP;
        this.edgePath = edgePathPar;
        this.anchors = anchorsP;
        this.layerArrays = la;
        this.originalGraph = origGraph;
        this.settings = settings;
        this.layeredGraph = layerGraph;
        this.eastHierarchy = this.BuildEastHierarchy();
        this.westHierarchy = this.BuildWestHierarchy();
    }
    BuildEastHierarchy() {
        const boundaryAnchorsCurves = this.FindEastBoundaryAnchorCurves();
        const l = new Array();
        for (const c of boundaryAnchorsCurves) {
            l.push(c.pNodeOverICurve());
        }
        this.thinEastHierarchy = _HierarchyCalculator__WEBPACK_IMPORTED_MODULE_7__.HierarchyCalculator.Calculate(this.thinRightNodes);
        return _HierarchyCalculator__WEBPACK_IMPORTED_MODULE_7__.HierarchyCalculator.Calculate(l);
    }
    BuildWestHierarchy() {
        const boundaryAnchorCurves = this.FindWestBoundaryAnchorCurves();
        const l = new Array();
        for (const a of boundaryAnchorCurves) {
            l.push(a.pNodeOverICurve());
        }
        this.thinWestHierarchy = _HierarchyCalculator__WEBPACK_IMPORTED_MODULE_7__.HierarchyCalculator.Calculate(this.thinWestNodes);
        return _HierarchyCalculator__WEBPACK_IMPORTED_MODULE_7__.HierarchyCalculator.Calculate(l);
    }
    FindEastBoundaryAnchorCurves() {
        const ret = new Array();
        let uOffset = 0;
        for (const u of this.edgePath) {
            let westMostAnchor = null;
            for (const v of this.EastBoundaryNodesOfANode(u, _routing__WEBPACK_IMPORTED_MODULE_8__.Routing.GetNodeKind(uOffset, this.edgePath))) {
                const a = this.anchors[v];
                if (westMostAnchor == null || westMostAnchor.origin.x > a.origin.x) {
                    westMostAnchor = a;
                }
                ret.push(a.polygonalBoundary);
            }
            if (westMostAnchor != null) {
                this.thinRightNodes.push(_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkLinePXY(westMostAnchor.origin, this.originalGraph.right, westMostAnchor.y).pNodeOverICurve());
            }
            uOffset++;
        }
        // if (Routing.db) {
        //    var l = new Array<DebugCurve>();
        //       l.AddRange(db.Anchors.Select(a=>new DebugCurve(100,1,"red", a.PolygonalBoundary)));
        //    l.AddRange(thinRightNodes.Select(n=>n.parallelogram).Select(p=>new Polyline(p.Vertex(VertexId.Corner), p.Vertex(VertexId.VertexA),
        //        p.Vertex(VertexId.OtherCorner), p.Vertex(VertexId.VertexB))).Select(c=>new DebugCurve(100,3,"brown", c)));
        //    foreach (var le of this.edgePath.LayerEdges)
        //        l. push(new DebugCurve(100, 1, "blue", LineSegment.mkPP(db.anchors[le.Source].Origin, db.anchors[le.Target].Origin)));
        //   LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
        //    // Database(db, thinRightNodes.Select(p=>new Polyline(p.parallelogram.Vertex(VertexId.Corner), p.parallelogram.Vertex(VertexId.VertexA),
        //        //p.parallelogram.Vertex(VertexId.OtherCorner), p.parallelogram.Vertex(VertexId.VertexB)){Closed=true}).ToArray());
        // }
        return ret;
    }
    FindWestBoundaryAnchorCurves() {
        const ret = [];
        let uOffset = 0;
        for (const u of this.edgePath.nodes()) {
            let eastMost = -1;
            for (const v of this.LeftBoundaryNodesOfANode(u, _routing__WEBPACK_IMPORTED_MODULE_8__.Routing.GetNodeKind(uOffset, this.edgePath))) {
                if (eastMost === -1 || this.layerArrays.x[v] > this.layerArrays.x[eastMost]) {
                    eastMost = v;
                }
                ret.push(this.anchors[v].polygonalBoundary);
            }
            if (eastMost !== -1) {
                const a = this.anchors[eastMost];
                this.thinWestNodes.push(_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkLinePXY(a.origin, this.originalGraph.left, a.origin.y).pNodeOverICurve());
            }
            uOffset++;
        }
        return ret;
    }
    *FillRightTopAndBottomVerts(layer, vPosition, nodeKind) {
        let b = 0;
        let t = 0;
        if (nodeKind === _NodeKind__WEBPACK_IMPORTED_MODULE_9__.NodeKind.Bottom) {
            b = Number.MAX_VALUE;
            // we don't have bottom boundaries here since they will be cut off
        }
        else if (nodeKind === _NodeKind__WEBPACK_IMPORTED_MODULE_9__.NodeKind.Top) {
            t = Number.MAX_VALUE;
            // we don't have top boundaries here since they will be cut off
        }
        const v = layer[vPosition];
        for (let i = vPosition + 1; i < layer.length; i++) {
            const u = layer[i];
            const anchor = this.anchors[u];
            if (anchor.topAnchor > t) {
                if (!this.NodeUCanBeCrossedByNodeV(u, v)) {
                    t = anchor.topAnchor;
                    if (anchor.bottomAnchor > b) {
                        b = anchor.bottomAnchor;
                    }
                    yield u;
                }
            }
            else if (anchor.bottomAnchor > b) {
                if (!this.NodeUCanBeCrossedByNodeV(u, v)) {
                    b = anchor.bottomAnchor;
                    if (anchor.topAnchor > t) {
                        t = anchor.topAnchor;
                    }
                    yield u;
                }
            }
        }
    }
    *FillLeftTopAndBottomVerts(layer, vPosition, nodeKind) {
        let b = 0;
        let t = 0;
        if (nodeKind === _NodeKind__WEBPACK_IMPORTED_MODULE_9__.NodeKind.Top) {
            t = Number.MAX_VALUE; // there are no top vertices - they are cut down by the top boundaryCurve curve
        }
        else if (nodeKind === _NodeKind__WEBPACK_IMPORTED_MODULE_9__.NodeKind.Bottom) {
            b = Number.MAX_VALUE; // there are no bottom vertices - they are cut down by the top boundaryCurve curve
        }
        const v = layer[vPosition];
        for (let i = vPosition - 1; i >= 0; i--) {
            const u = layer[i];
            const anchor = this.anchors[u];
            if (anchor.topAnchor > t + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon) {
                if (!this.NodeUCanBeCrossedByNodeV(u, v)) {
                    t = anchor.topAnchor;
                    b = Math.max(b, anchor.bottomAnchor);
                    yield u;
                }
            }
            else if (anchor.bottomAnchor > b + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon) {
                if (!this.NodeUCanBeCrossedByNodeV(u, v)) {
                    t = Math.max(t, anchor.topAnchor);
                    b = anchor.bottomAnchor;
                    yield u;
                }
            }
        }
    }
    IsVirtualVertex(v) {
        return v >= this.originalGraph.shallowNodeCount;
    }
    IsLabel(u) {
        return this.anchors[u].hasLabel;
    }
    NodeUCanBeCrossedByNodeV(u, v) {
        if (this.IsLabel(u)) {
            return false;
        }
        if (this.IsLabel(v)) {
            return false;
        }
        if (this.IsVirtualVertex(u) && this.IsVirtualVertex(v) && this.EdgesIntersectSomewhere(u, v)) {
            return true;
        }
        return false;
    }
    EdgesIntersectSomewhere(u, v) {
        if (this.UVAreMiddlesOfTheSameMultiEdge(u, v)) {
            return false;
        }
        return this.IntersectAbove(u, v) || this.IntersectBelow(u, v);
    }
    UVAreMiddlesOfTheSameMultiEdge(u, v) {
        if (this.database.MultipleMiddles.has(u) &&
            this.database.MultipleMiddles.has(v) &&
            this.SourceOfTheOriginalEdgeContainingAVirtualNode(u) === this.SourceOfTheOriginalEdgeContainingAVirtualNode(v)) {
            return true;
        }
        return false;
    }
    SourceOfTheOriginalEdgeContainingAVirtualNode(u) {
        while (this.IsVirtualVertex(u)) {
            u = this.IncomingEdge(u).Source;
        }
        return u;
    }
    IntersectBelow(u, v) {
        do {
            const eu = this.OutcomingEdge(u);
            const ev = this.OutcomingEdge(v);
            if (this.Intersect(eu, ev)) {
                return true;
            }
            u = eu.Target;
            v = ev.Target;
        } while (this.IsVirtualVertex(u) && this.IsVirtualVertex(v));
        return u === v;
    }
    IntersectAbove(u, v) {
        do {
            const eu = this.IncomingEdge(u);
            const ev = this.IncomingEdge(v);
            if (this.Intersect(eu, ev)) {
                return true;
            }
            u = eu.Source;
            v = ev.Source;
        } while (this.IsVirtualVertex(u) && this.IsVirtualVertex(v));
        return u === v;
    }
    Intersect(e, m) {
        const a = this.layerArrays.x[e.Source] - this.layerArrays.x[m.Source];
        const b = this.layerArrays.x[e.Target] - this.layerArrays.x[m.Target];
        return (a > 0 && b < 0) || (a < 0 && b > 0);
        // return (layerArrays.x[e.Source] - layerArrays.x[m.Source]) * (layerArrays.x[e.Target] - layerArrays.x[m.Target]) < 0;
    }
    IncomingEdge(u) {
        return this.layeredGraph.InEdgeOfVirtualNode(u);
    }
    // here u is a virtual vertex
    OutcomingEdge(u) {
        return this.layeredGraph.OutEdgeOfVirtualNode(u);
    }
    EastBoundaryNodesOfANode(i, nodeKind) {
        return this.FillRightTopAndBottomVerts(this.NodeLayer(i), this.layerArrays.x[i], nodeKind);
    }
    NodeLayer(i) {
        return this.layerArrays.Layers[this.layerArrays.y[i]];
    }
    LeftBoundaryNodesOfANode(i, nodeKind) {
        return this.FillLeftTopAndBottomVerts(this.NodeLayer(i), this.layerArrays.x[i], nodeKind);
    }
    getSpline(optimizeShortEdges) {
        this.createRefinedPolyline(optimizeShortEdges);
        return this.createSmoothedPolyline();
    }
    // Poly(): Curve {
    //  const c: Curve = new Curve()
    //  for (let s = this.headSite; s.next != null; s = s.next) {
    //    c.addSegment(
    //      new BezierSeg(s.point, Point.convSum(1 / 3, s.point, s.next.point), Point.convSum(2 / 3, s.point, s.next.point), s.next.point),
    //    )
    //  }
    //  return c
    // }
    get GetPolyline() {
        /*Assert.assert(this.headSite != null)*/
        return new _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_6__.SmoothedPolyline(this.headSite);
    }
    LineSegIntersectBound(a, b) {
        const l = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(a, b);
        return (SmoothedPolylineCalculator.CurveIntersectsHierarchy(l, this.westHierarchy) ||
            SmoothedPolylineCalculator.CurveIntersectsHierarchy(l, this.thinWestHierarchy) ||
            SmoothedPolylineCalculator.CurveIntersectsHierarchy(l, this.eastHierarchy) ||
            SmoothedPolylineCalculator.CurveIntersectsHierarchy(l, this.thinEastHierarchy));
    }
    SegIntersectWestBound(a, b) {
        return (SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.westHierarchy) ||
            SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.thinWestHierarchy));
    }
    SegIntersectEastBound(a, b) {
        return (SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.eastHierarchy) ||
            SmoothedPolylineCalculator.SegIntersectsBound(a, b, this.thinEastHierarchy));
    }
    TryToRemoveInflectionCorner(t) {
        if (!t.s.next ||
            !t.s.prev ||
            (t.s.turn === _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Counterclockwise && this.SegIntersectEastBound(t.s.prev, t.s.next)) ||
            (t.s.turn === _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Clockwise && this.SegIntersectWestBound(t.s.prev, t.s.next))) {
            t.cut = false;
            t.s = t.s.next;
            return;
        }
        // we have a cut
        const nextS = t.s.next;
        t.s.prev.next = nextS;
        // forget about s
        nextS.prev = t.s.prev;
        t.s = nextS;
        t.cut = true;
    }
    static SegIntersectsBound(a, b, hierarchy) {
        return SmoothedPolylineCalculator.CurveIntersectsHierarchy(_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(a.point, b.point), hierarchy);
    }
    static CurveIntersectsHierarchy(lineSeg, hierarchy) {
        if (hierarchy == null) {
            return false;
        }
        if (!_math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_4__.Parallelogram.intersect(lineSeg.pNodeOverICurve().parallelogram, hierarchy.parallelogram)) {
            return false;
        }
        if (hierarchy.node.hasOwnProperty('children')) {
            const n = hierarchy.node;
            const ret = SmoothedPolylineCalculator.CurveIntersectsHierarchy(lineSeg, n.children[0]) ||
                SmoothedPolylineCalculator.CurveIntersectsHierarchy(lineSeg, n.children[1]);
            return ret;
        }
        return _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.intersectionOne(lineSeg, hierarchy.seg, false) != null;
    }
    static Flat(i) {
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.getTriangleOrientation(i.prev.point, i.point, i.next.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Collinear;
    }
    Reverse() {
        const ret = new SmoothedPolylineCalculator(this.edgePath, this.anchors, this.originalGraph, this.settings, this.layerArrays, this.layeredGraph, this.database);
        let site = this.headSite;
        let v = null;
        while (site != null) {
            ret.headSite = site.clone();
            ret.headSite.next = v;
            if (v != null) {
                v.prev = ret.headSite;
            }
            v = ret.headSite;
            site = site.next;
        }
        return ret;
    }
    createRefinedPolyline(optimizeShortEdges) {
        this.CreateInitialListOfSites();
        let topSite = this.headSite;
        let bottomSite;
        for (let i = 0; i < this.edgePath.count; i++) {
            bottomSite = topSite.next;
            this.RefineBeetweenNeighborLayers(topSite, this.EdgePathNode(i), this.EdgePathNode(i + 1));
            topSite = bottomSite;
        }
        this.TryToRemoveInflections();
        if (optimizeShortEdges) {
            this.OptimizeShortPath();
        }
        //Assert.assert(this.)
    }
    RefineBeetweenNeighborLayers(topSite, topNode, bottomNode) {
        _RefinerBetweenTwoLayers__WEBPACK_IMPORTED_MODULE_10__.RefinerBetweenTwoLayers.Refine(topNode, bottomNode, topSite, this.anchors, this.layerArrays, this.layeredGraph, this.originalGraph, this.settings.LayerSeparation);
    }
    CreateInitialListOfSites() {
        let currentSite = (this.headSite = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_0__.CornerSite.mkSiteP(this.EdgePathPoint(0)));
        for (let i = 1; i <= this.edgePath.count; i++) {
            currentSite = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_0__.CornerSite.mkSiteSP(currentSite, this.EdgePathPoint(i));
        }
    }
    get TailSite() {
        let s = this.headSite;
        while (s.next != null) {
            s = s.next;
        }
        return s;
    }
    OptimizeForThreeSites() {
        /*Assert.assert(this.edgePath.LayerEdges.length === 2)*/
        const top = this.EdgePathNode(0);
        const bottom = this.EdgePathNode(2);
        const a = this.anchors[top];
        const b = this.anchors[bottom];
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_11__.closeDistEps)(a.x, b.x)) {
            return;
        }
        const t = { ax: a.x, bx: b.x, sign: 0 };
        if (!this.FindLegalPositions(a, b, t)) {
            return;
        }
        const ratio = (a.y - b.y) / (a.bottom - b.top);
        const xc = 0.5 * (t.ax + t.bx);
        const half = t.sign * ((t.ax - t.bx) * 0.5);
        t.ax = xc + ratio * (half * t.sign);
        t.bx = xc - ratio * (half * t.sign);
        this.headSite.point = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(t.ax, a.y);
        const ms = this.headSite.next;
        const mY = ms.point.y;
        ms.point = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(this.MiddlePos(t.ax, t.bx, a, b, mY), mY);
        ms.next.point = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(t.bx, b.y);
        const ma = this.anchors[this.EdgePathNode(1)];
        ma.x = ms.point.x;
    }
    OptimizeForTwoSites() {
        /*Assert.assert(this.edgePath.LayerEdges.length === 1)*/
        const top = this.EdgePathNode(0);
        const bottom = this.EdgePathNode(1);
        const a = this.anchors[top];
        const b = this.anchors[bottom];
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_11__.closeDistEps)(a.x, b.x)) {
            return;
        }
        const t = { ax: a.x, bx: b.x, sign: 0 };
        if (!this.FindPositions(a, b, t)) {
            return;
        }
        const ratio = (a.y - b.y) / (a.bottom - b.top);
        const xc = 0.5 * (t.ax + t.bx);
        const half = t.sign * ((t.ax - t.bx) * 0.5);
        t.ax = xc + ratio * (half * t.sign);
        t.bx = xc - ratio * (half * t.sign);
        this.headSite.point = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(t.ax, a.y);
        this.headSite.next.point = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(t.bx, b.y);
    }
    FindLegalPositions(a, b, t) {
        if (!this.FindPositions(a, b, t)) {
            return false;
        }
        return this.PositionsAreLegal(t.ax, t.bx, t.sign, a, b, this.EdgePathNode(1));
    }
    FindPositions(a, b, t) {
        let overlapMax;
        let overlapMin;
        if (t.ax < t.bx) {
            t.sign = 1;
            overlapMin = Math.max(t.ax, b.left);
            overlapMax = Math.min(a.right, t.bx);
        }
        else {
            t.sign = -1;
            overlapMin = Math.max(a.left, t.bx);
            overlapMax = Math.min(b.right, t.ax);
        }
        if (overlapMin <= overlapMax) {
            t.bx = 0.5 * (overlapMin + overlapMax);
            t.ax = 0.5 * (overlapMin + overlapMax);
        }
        else {
            if (this.OriginToOriginSegCrossesAnchorSide(a, b)) {
                return false;
            }
            if (t.sign === 1) {
                t.ax = a.right - 0.1 * a.rightAnchor;
                t.bx = b.left;
            }
            else {
                t.ax = a.left + 0.1 * a.leftAnchor;
                t.bx = b.right;
            }
        }
        return true;
    }
    OriginToOriginSegCrossesAnchorSide(a, b) {
        /*Assert.assert(a.y > b.y)*/
        const seg = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(a.origin, b.origin);
        return ((a.x < b.x && _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.CurvesIntersect(seg, _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(a.rightBottom, a.rightTop))) ||
            _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.CurvesIntersect(seg, _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(b.leftBottom, a.leftTop)) ||
            (a.x > b.x && _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.CurvesIntersect(seg, _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(a.leftBottom, a.leftTop))) ||
            _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.CurvesIntersect(seg, _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(b.rightBottom, a.rightTop)));
    }
    OptimizeShortPath() {
        if (this.edgePath.count > 2) {
            return;
        }
        if (this.edgePath.count === 2 &&
            this.headSite.next.next != null &&
            this.headSite.next.next.next == null &&
            this.anchors[this.EdgePathNode(1)].node == null) {
            this.OptimizeForThreeSites();
        }
        else if (this.edgePath.count === 1) {
            this.OptimizeForTwoSites();
        }
    }
    PositionsAreLegal(sax, sbx, sign, a, b, middleNodeIndex) {
        if (!(0,_utils_compare__WEBPACK_IMPORTED_MODULE_11__.closeDistEps)(sax, sbx) && (sax - sbx) * sign > 0) {
            return false;
        }
        const mAnchor = this.anchors[middleNodeIndex];
        const mx = this.MiddlePos(sax, sbx, a, b, mAnchor.y);
        if (!this.MiddleAnchorLegal(mx, middleNodeIndex, mAnchor)) {
            return false;
        }
        return !this.LineSegIntersectBound(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(sax, a.bottom), new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(sbx, b.top));
    }
    MiddleAnchorLegal(mx, middleNodeIndex, mAnchor) {
        const mLayer = this.NodeLayer(middleNodeIndex);
        const pos = this.layerArrays.x[middleNodeIndex];
        const shift = mx - mAnchor.x;
        if (pos > 0) {
            const l = this.anchors[mLayer[pos - 1]];
            if (l.right > shift + mAnchor.left) {
                return false;
            }
        }
        if (pos < mLayer.length - 1) {
            const r = this.anchors[mLayer[pos + 1]];
            if (r.left < shift + mAnchor.right) {
                return false;
            }
        }
        return true;
    }
    MiddlePos(sax, sbx, a, b, mY) {
        const u = a.y - mY;
        const l = mY - b.y;
        /*Assert.assert(u >= 0 && l >= 0)*/
        return (sax * u + sbx * l) / (u + l);
    }
    TryToRemoveInflections() {
        if (this.TurningAlwaySameDirection()) {
            return;
        }
        let progress = true;
        while (progress) {
            progress = false;
            for (const t = { s: this.headSite, cut: false }; t.s;) {
                this.TryToRemoveInflectionCorner(t);
                progress = t.cut || progress;
            }
        }
    }
    TurningAlwaySameDirection() {
        let sign = 0;
        // undecided
        for (let s = this.headSite.next; s != null && s.next != null; s = s.next) {
            const nsign = s.turn;
            if (sign === 0) {
                // try to set the sign
                if (nsign > 0) {
                    sign = 1;
                }
                else if (nsign < 0) {
                    sign = -1;
                }
            }
            else if (sign * nsign < 0) {
                return false;
            }
        }
        return true;
    }
    EdgePathPoint(i) {
        return this.anchors[this.EdgePathNode(i)].origin;
    }
    EdgePathNode(i) {
        return i === this.edgePath.count ? this.edgePath.LayerEdges[this.edgePath.count - 1].Target : this.edgePath.LayerEdges[i].Source;
    }
    createSmoothedPolyline() {
        this.RemoveVerticesWithNoTurns();
        let curve = new _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve();
        const a = this.headSite;
        const t = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.findCorner(a);
        // the corner other end
        if (t !== undefined) {
            this.createFilletCurve(curve, { a: a, b: t.b, c: t.c });
            curve = this.ExtendCurveToEndpoints(curve);
        }
        else {
            curve.addSegment(_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(this.headSite.point, this.TailSite.point));
        }
        /*Assert.assert(this.curveIsLegal(curve))*/
        return curve;
    }
    curveIsLegal(curve) {
        return true;
        for (const n of this.layeredGraph.BaseGraph.nodes) {
            let i = this.edgePath.getNode(0);
            if (n === this.layeredGraph.BaseGraph.nodes[i])
                continue;
            i = this.edgePath.getNode(this.edgePath.LayerEdges.length);
            if (n === this.layeredGraph.BaseGraph.nodes[i])
                continue;
            const nc = n.boundaryCurve;
            if (_math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.CurvesIntersect(nc, curve)) {
                //  SvgDebugWriter.dumpICurves('./tmp/cross.svg', [nc, curve])
                return false;
            }
        }
        return true;
    }
    RemoveVerticesWithNoTurns() {
        while (this.RemoveVerticesWithNoTurnsOnePass()) { }
    }
    RemoveVerticesWithNoTurnsOnePass() {
        let ret = false;
        for (let s = this.headSite; s.next != null && s.next.next != null; s = s.next) {
            if (SmoothedPolylineCalculator.Flat(s.next)) {
                ret = true;
                s.next = s.next.next;
                // crossing out s.next
                s.next.prev = s;
            }
        }
        return ret;
    }
    ExtendCurveToEndpoints(curve) {
        let p = this.headSite.point;
        if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.closeDistEps(p, curve.start)) {
            const nc = new _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve();
            nc.addSegs([_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p, curve.start), curve]);
            curve = nc;
        }
        p = this.TailSite.point;
        if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.closeDistEps(p, curve.end)) {
            curve.addSegment(_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(curve.end, p));
        }
        return curve;
    }
    createFilletCurve(curve, t) {
        for (; true;) {
            this.AddSmoothedCorner(t.a, t.b, t.c, curve);
            t.a = t.b;
            t.b = t.c;
            if (t.b.next != null) {
                t.c = t.b.next;
            }
            else {
                break;
            }
        }
    }
    AddSmoothedCorner(a, b, c, curve) {
        let k = 0.5;
        let seg;
        do {
            seg = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.createBezierSeg(k, k, a, b, c);
            // SvgDebugWriter.dumpDebugCurves(
            //  './tmp/' + ++SmoothedPolylineCalculator.count + 'sm.svg',
            //  this.getDebugCurvesForCorner(a, b, c),
            // )
            b.previouisBezierCoefficient = k;
            k /= 2;
        } while (this.BezierSegIntersectsBoundary(seg));
        k *= 2;
        // that was the last k
        if (k < 0.5) {
            // one time try a smoother seg
            k = 0.5 * (k + k * 2);
            const nseg = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.createBezierSeg(k, k, a, b, c);
            if (!this.BezierSegIntersectsBoundary(nseg)) {
                b.nextBezierCoefficient = k;
                b.previouisBezierCoefficient = k;
                seg = nseg;
            }
        }
        if (curve.segs.length > 0 && !_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.closeDistEps(curve.end, seg.start)) {
            curve.addSegment(_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(curve.end, seg.start));
        }
        curve.addSegment(seg);
    }
    // getDebugCurvesForCorner(
    //  a: CornerSite,
    //  b: CornerSite,
    //  c: CornerSite,
    // ): //import{('../../math/geometry/debugCurve').}DebugCurve[] {
    //  let r = []
    //  r = r.concat(getHierDC(this.thinWestHierarchy, 'Red'))
    //  r = r.concat(getHierDC(this.westHierarchy, 'Orange'))
    //  r = r.concat(getHierDC(this.eastHierarchy, 'Blue'))
    //  r = r.concat(getHierDC(this.thinEastHierarchy, 'Green'))
    //  for (const a of this.anchors) {
    //    r.push(DebugCurve.mkDebugCurveTWCI(100, 0.3, 'Gray', a.polygonalBoundary))
    //  }
    //  r.push(
    //    DebugCurve.mkDebugCurveTWCI(
    //      100,
    //      2,
    //      'Blue',
    //      LineSegment.mkPP(a.point, b.point),
    //    ),
    //  )
    //  r.push(
    //    DebugCurve.mkDebugCurveTWCI(
    //      100,
    //      2,
    //      'Blue',
    //      LineSegment.mkPP(b.point, c.point),
    //    ),
    //  )
    //  const p = new Polyline()
    //  for (let i = 0; i <= this.edgePath.count; i++) {
    //    p.addPoint(this.EdgePathPoint(i))
    //  }
    //  r.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Yellow', p))
    //  return r
    // }
    BezierSegIntersectsBoundary(seg) {
        const side = _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.signedDoubledTriangleArea(seg.B(0), seg.B(1), seg.B(2));
        if (side < 0) {
            return this.BezierSegIntersectsTree(seg, this.thinWestHierarchy) || this.BezierSegIntersectsTree(seg, this.westHierarchy);
        }
        else {
            return this.BezierSegIntersectsTree(seg, this.thinEastHierarchy) || this.BezierSegIntersectsTree(seg, this.eastHierarchy);
        }
    }
    BezierSegIntersectsTree(seg, tree) {
        if (tree == null)
            return false;
        if (_math_geometry_parallelogram__WEBPACK_IMPORTED_MODULE_4__.Parallelogram.intersect(seg.pNodeOverICurve().parallelogram, tree.parallelogram)) {
            if (tree.node.hasOwnProperty('children')) {
                const n = tree.node;
                return this.BezierSegIntersectsTree(seg, n.children[0]) || this.BezierSegIntersectsTree(seg, n.children[1]);
            }
            else {
                return SmoothedPolylineCalculator.BezierSegIntersectsBoundary(seg, tree.seg);
            }
        }
        else {
            return false;
        }
    }
    static BezierSegIntersectsBoundary(seg, ic) {
        for (const x of _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.getAllIntersections(seg, ic, false)) {
            if (ic instanceof _math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve) {
                const c = ic;
                if (_math_geometry_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.realCutWithClosedCurve(x, c, false)) {
                    return true;
                }
            }
            else {
                // curve is from a thin hierarchy that's forbidden to touch
                return true;
            }
        }
        return false;
    }
}
// function getHierDC(hierarchy: PN, color: string): DebugCurve[] {
//  if (hierarchy == null  || hierarchy.node == null ) return []
//  if (hierarchy.node.hasOwnProperty('children')) {
//    const n = hierarchy.node as PNInternal
//    return getHierDC(n.children[0], color).concat(
//      getHierDC(n.children[1], color),
//    )
//  }
//  return [DebugCurve.mkDebugCurveTWCI(100, 0.5, color, hierarchy.seg)]
// }
//# sourceMappingURL=smoothedPolylineCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/sugiyamaLayoutSettings.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SnapToGridByY: () => (/* binding */ SnapToGridByY),
/* harmony export */   SugiyamaLayoutSettings: () => (/* binding */ SugiyamaLayoutSettings)
/* harmony export */ });
/* harmony import */ var _verticalConstraintsForSugiyama__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/verticalConstraintsForSugiyama.js");
/* harmony import */ var _HorizontalConstraintsForSugiyama__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/HorizontalConstraintsForSugiyama.js");
/* harmony import */ var _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/layerDirectionEnum.js");
/* harmony import */ var _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/planeTransformation.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/EdgeRoutingMode.js");
/* harmony import */ var _commonLayoutSettings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/commonLayoutSettings.js");







var SnapToGridByY;
(function (SnapToGridByY) {
    SnapToGridByY[SnapToGridByY["None"] = 0] = "None";
    SnapToGridByY[SnapToGridByY["Top"] = 1] = "Top";
    SnapToGridByY[SnapToGridByY["Bottom"] = 2] = "Bottom";
})(SnapToGridByY || (SnapToGridByY = {}));
/** Settings for layered layout: it specifies if the direction of the layers, distance between the layers, etc*/
class SugiyamaLayoutSettings {
    get NodeSeparation() {
        return this.commonSettings.NodeSeparation;
    }
    get edgeRoutingSettings() {
        return this.commonSettings.edgeRoutingSettings;
    }
    set edgeRoutingSettings(value) {
        this.commonSettings.edgeRoutingSettings = value;
    }
    toJSON() {
        const r = {};
        if (this.sameRanks)
            r.sameRanks = this.sameRanks;
        if (this.verticalConstraints)
            r.verticalConstraints = this.verticalConstraints;
        if (this.horizontalConstraints)
            r.horizontalConstraints = this.horizontalConstraints;
        if (this.NoGainAdjacentSwapStepsBound != 5)
            r.horizontalConstraints = this.horizontalConstraints;
        if (this.NoGainStepsForOrderingMultiplier != 1)
            r.RepetitionCoefficientForOrdering = this.NoGainStepsForOrderingMultiplier;
        if (this.AspectRatio)
            r.AspectRatio = this.AspectRatio;
        if (this.MaxNumberOfPassesInOrdering != 24)
            r.MaxNumberOfPassesInOrdering = this.MaxNumberOfPassesInOrdering;
        if (this.BrandesThreshold != 600)
            r.BrandesThreshold = this.BrandesThreshold;
        if (this.LabelCornersPreserveCoefficient != 0.1)
            r.LabelCornersPreserveCoefficient = this.LabelCornersPreserveCoefficient;
        if (this.MinNodeHeight != (72 * 0.5) / 4)
            r.MinNodeHeight = this.MinNodeHeight;
        if (this.MinNodeWidth != (72 * 0.75) / 4)
            r.MinNodeWidth = this.MinNodeWidth;
        if (this.SnapToGridByY != SnapToGridByY.None)
            r.SnapToGridByY = this.SnapToGridByY;
        if (this.yLayerSep != 10 * 3)
            r.yLayerSep = this.yLayerSep;
        if (this.transform)
            r.transform = this.transform.elements;
        if (this.GridSizeByY)
            r.GridSizeByY = this.GridSizeByY;
        if (this.GridSizeByX)
            r.GridSizeByX = this.GridSizeByX;
        r.commonLayoutSettings = this.commonSettings.toJSON();
        return r;
    }
    static fromJSON(s) {
        const r = new SugiyamaLayoutSettings();
        if (s.sameRanks)
            r.sameRanks = s.sameRanks;
        if (s.verticalConstraints)
            r.verticalConstraints = s.verticalConstraints;
        if (s.horizontalConstraints)
            r.horizontalConstraints = s.horizontalConstraints;
        if (s.NoGainAdjacentSwapStepsBound)
            r.horizontalConstraints = s.horizontalConstraints;
        if (s.RepetitionCoefficientForOrdering)
            r.NoGainStepsForOrderingMultiplier = s.RepetitionCoefficientForOrdering;
        if (s.AspectRatio)
            r.AspectRatio = s.AspectRatio;
        if (s.MaxNumberOfPassesInOrdering)
            r.MaxNumberOfPassesInOrdering = s.MaxNumberOfPassesInOrdering;
        if (s.BrandesThreshold)
            r.BrandesThreshold = s.BrandesThreshold;
        if (s.LabelCornersPreserveCoefficient)
            r.LabelCornersPreserveCoefficient = s.LabelCornersPreserveCoefficient;
        if (s.MinNodeHeight)
            r.MinNodeHeight = s.MinNodeHeight;
        if (s.MinNodeWidth)
            r.MinNodeWidth = r.MinNodeWidth;
        if (s.SnapToGridByY)
            r.SnapToGridByY = s.SnapToGridByY;
        if (s.yLayerSep)
            r.yLayerSep = s.yLayerSep;
        if (s.transform)
            r.transform = new _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_3__.PlaneTransformation(s.transform[0][0], s.transform[0][1], s.transform[0][2], s.transform[1][0], s.transform[1][1], s.transform[1][2]);
        if (s.GridSizeByY)
            r.GridSizeByY = s.GridSizeByY;
        if (s.GridSizeByX)
            r.GridSizeByX = s.GridSizeByX;
        if (s.commonLayoutSettings)
            r.commonSettings = _commonLayoutSettings__WEBPACK_IMPORTED_MODULE_6__.CommonLayoutSettings.fromJSON(s.commonLayoutSettings);
        return r;
    }
    /** the minimum distance between two layer horizontal lines passing througt the node centers */
    get LayerSeparation() {
        return this.yLayerSep;
    }
    set LayerSeparation(value) {
        this.yLayerSep = Math.max(10 * 3, value);
    }
    ActualLayerSeparation(layersAreDoubled) {
        return layersAreDoubled ? this.LayerSeparation / 2.0 : this.LayerSeparation;
    }
    constructor() {
        this.commonSettings = new _commonLayoutSettings__WEBPACK_IMPORTED_MODULE_6__.CommonLayoutSettings();
        this.verticalConstraints = new _verticalConstraintsForSugiyama__WEBPACK_IMPORTED_MODULE_0__.VerticalConstraintsForSugiyama();
        this.horizontalConstraints = new _HorizontalConstraintsForSugiyama__WEBPACK_IMPORTED_MODULE_1__.HorizontalConstraintsForSugiyama();
        this.NoGainAdjacentSwapStepsBound = 5;
        /** the adjacent swaps will proceed by NoGainAdjacentSwapStepsBound*NoGainStepsForOrderingMultiplier  */
        this.NoGainStepsForOrderingMultiplier = 1;
        /**  Aspect ratio of the layout. Ignored it zero.*/
        this.AspectRatio = 0;
        /** the maximum number of going up and down through the layers to untangle the edges */
        this.MaxNumberOfPassesInOrdering = 24;
        /**  When the number of vertices in the proper layered graph
         is at least threshold  we switch to a fast, but not so accurate,
         method for x-coordinates calculations. */
        this.BrandesThreshold = 600;
        /**  The coefficient for the label corners preserve heuristic,
         * that allows for an edge to pass through the bounding box of a label, close to its corner*/
        this.LabelCornersPreserveCoefficient = 0.1;
        /** the minimal node size */
        this.MinNodeHeight = (72 * 0.5) / 4;
        this.MinNodeWidth = (72 * 0.75) / 4;
        /**  The grid snapping mode: snap up, down on neither */
        this.SnapToGridByY = SnapToGridByY.None;
        /** the minimum distance between two layer horizontal lines passing througt the node centers */
        this.yLayerSep = 10 * 3;
        /** the transform can be an identity, or rotation on Pi/2, -Pi/2, or Pi */
        this.transform = _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_3__.PlaneTransformation.getIdentity();
        this.GridSizeByY = 0;
        this.GridSizeByX = 0;
        this.commonSettings.edgeRoutingSettings.EdgeRoutingMode = _routing_EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_5__.EdgeRoutingMode.SugiyamaSplines;
    }
    transformIsRotation(ang) {
        const p = _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_3__.PlaneTransformation.rotation(ang);
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 3; j++)
                if (!(0,_utils_compare__WEBPACK_IMPORTED_MODULE_4__.closeDistEps)(p.elements[i][j], this.transform.elements[i][j]))
                    return false;
        }
        return true;
    }
    get layerDirection() {
        if (this.transformIsRotation(0))
            return _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__.LayerDirectionEnum.TB;
        if (this.transformIsRotation(Math.PI / 2))
            return _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__.LayerDirectionEnum.LR;
        if (this.transformIsRotation(-Math.PI / 2))
            return _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__.LayerDirectionEnum.RL;
        if (this.transformIsRotation(Math.PI))
            return _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__.LayerDirectionEnum.BT;
        throw new Error('unexpected layout direction');
    }
    set layerDirection(value) {
        switch (value) {
            case _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__.LayerDirectionEnum.TB:
                this.transform = _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_3__.PlaneTransformation.getIdentity();
                break;
            case _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__.LayerDirectionEnum.LR:
                this.transform = _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_3__.PlaneTransformation.rotation(Math.PI / 2);
                break;
            case _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__.LayerDirectionEnum.RL:
                this.transform = _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_3__.PlaneTransformation.rotation(-Math.PI / 2);
                break;
            case _layerDirectionEnum__WEBPACK_IMPORTED_MODULE_2__.LayerDirectionEnum.BT:
                this.transform = _math_geometry_planeTransformation__WEBPACK_IMPORTED_MODULE_3__.PlaneTransformation.rotation(Math.PI);
                break;
            default:
                throw new Error('unexpected layout direction');
        }
    }
}
//# sourceMappingURL=sugiyamaLayoutSettings.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/verticalConstraintsForSugiyama.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VerticalConstraintsForSugiyama: () => (/* binding */ VerticalConstraintsForSugiyama)
/* harmony export */ });
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _CycleRemoval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/CycleRemoval.js");
/* harmony import */ var _polyIntEdge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/polyIntEdge.js");
/* harmony import */ var _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairSet.js");
/* harmony import */ var _math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/graphAlgorithms/ConnectedComponentCalculator.js");






class VerticalConstraintsForSugiyama {
    constructor() {
        /*  getFeedbackSet(
            intGraph: BasicGraph<Node, PolyIntEdge>,
            nodeIdToIndex: Map<string, number>,
          ): import('../../structs/iedge').IEdge[] {
            throw new Error('Method not implemented.')
          }
          */
        // nodes that are pinned to the max layer
        this.maxLayerOfGeomGraph = new Set();
        // nodes that are pinned to the min layer
        this.minLayerOfGeomGraph = new Set();
        // set of couple of nodes belonging to the same layer
        this.sameLayerConstraints = new Array();
        this.upDownConstraints = new Array();
        this.gluedUpDownIntConstraints = new _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_4__.IntPairSet();
        // Maps each node participating in same layer relation to its representative on the layer.
        this.sameLayerDictionaryOfRepresentatives = new Map();
        this.representativeToItsLayer = new Map();
        this.maxLayerInt = new Array();
        this.minLayerInt = new Array();
        this.sameLayerInts = new Array();
        // contains also pinned max and min pairs
        this.upDownInts = new Array();
    }
    getFeedbackSetExternal(intGraph, nodeIdToIndex) {
        throw new Error('Method not implemented.');
    }
    // pins a node to max layer
    pinNodeToMaxLayer(node) {
        this.maxLayerOfGeomGraph.add(node);
    }
    // pins a node to min layer
    pinNodeToMinLayer(node) {
        this.minLayerOfGeomGraph.add(node);
    }
    get isEmpty() {
        return (this.maxLayerOfGeomGraph.size === 0 &&
            this.minLayerOfGeomGraph.size === 0 &&
            this.sameLayerConstraints.length === 0 &&
            this.upDownConstraints.length === 0);
    }
    clear() {
        this.maxLayerOfGeomGraph.clear();
        this.minLayerOfGeomGraph.clear();
        this.sameLayerConstraints = [];
        this.upDownConstraints = [];
    }
    getFeedbackSetImp(intGraph, nodeIdToIndex) {
        this.nodeIdToIndex = nodeIdToIndex;
        this.intGraph = intGraph;
        this.maxRepresentative = -1;
        this.minRepresentative = -1;
        this.createIntegerConstraints();
        this.glueTogetherSameConstraintsMaxAndMin();
        this.addMaxMinConstraintsToGluedConstraints();
        this.removeCyclesFromGluedConstraints();
        return this.getFeedbackSet();
    }
    removeCyclesFromGluedConstraints() {
        const graph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__.mkGraphOnEdgesN)(Array.from(this.gluedUpDownIntConstraints.values()), this.intGraph.nodeCount);
        const feedbackSet = _CycleRemoval__WEBPACK_IMPORTED_MODULE_2__.CycleRemoval.getFeedbackSetWithConstraints(graph, null);
        //feedbackSet contains all glued constraints making constraints cyclic
        for (const p of feedbackSet) {
            this.gluedUpDownIntConstraints.remove(p);
        }
    }
    addMaxMinConstraintsToGluedConstraints() {
        if (this.maxRepresentative !== -1)
            for (let i = 0; i < this.intGraph.nodeCount; i++) {
                const j = this.nodeToRepr(i);
                if (j !== this.maxRepresentative)
                    this.gluedUpDownIntConstraints.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(this.maxRepresentative, j));
            }
        if (this.minRepresentative !== -1)
            for (let i = 0; i < this.intGraph.nodeCount; i++) {
                const j = this.nodeToRepr(i);
                if (j !== this.minRepresentative)
                    this.gluedUpDownIntConstraints.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(j, this.minRepresentative));
            }
    }
    glueTogetherSameConstraintsMaxAndMin() {
        this.createDictionaryOfSameLayerRepresentatives();
        const array = this.upDownInts.map(this.gluedIntPairNN);
        this.gluedUpDownIntConstraints = new _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_4__.IntPairSet();
    }
    gluedIntPairNN(p) {
        return new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(this.nodeToRepr(p[0]), this.nodeToRepr(p[1]));
    }
    gluedIntPairI(p) {
        return new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(this.nodeToRepr(p.source), this.nodeToRepr(p.target));
    }
    gluedIntPair(p) {
        return new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(this.nodeToRepr(p.source), this.nodeToRepr(p.target));
    }
    gluedIntEdge(intEdge) {
        const sourceRepr = this.nodeToRepr(intEdge.source);
        const targetRepr = this.nodeToRepr(intEdge.target);
        const ie = new _polyIntEdge__WEBPACK_IMPORTED_MODULE_3__.PolyIntEdge(sourceRepr, targetRepr, intEdge.edge);
        ie.separation = intEdge.separation;
        ie.weight = 0;
        return ie;
    }
    nodeToRepr(node) {
        const repr = this.sameLayerDictionaryOfRepresentatives.get(node);
        return repr ? repr : node;
    }
    createDictionaryOfSameLayerRepresentatives() {
        const graphOfSameLayers = this.createGraphOfSameLayers();
        for (const comp of (0,_math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_5__.GetConnectedComponents)(graphOfSameLayers))
            this.glueSameLayerNodesOfALayer(comp);
    }
    createGraphOfSameLayers() {
        return (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__.mkGraphOnEdgesN)(this.createEdgesOfSameLayers(), this.intGraph.nodeCount);
    }
    createEdgesOfSameLayers() {
        const ret = new Array();
        if (this.maxRepresentative !== -1) {
            this.maxLayerInt
                .filter((v) => v !== this.maxRepresentative)
                .map((v) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(this.maxRepresentative, v))
                .forEach((p) => ret.push(p));
        }
        if (this.minRepresentative !== -1) {
            this.minLayerInt
                .filter((v) => v !== this.minRepresentative)
                .map((v) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(this.minRepresentative, v))
                .forEach((p) => ret.push(p));
        }
        this.sameLayerInts.forEach((t) => ret.push(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_1__.IntPair(t[0], t[1])));
        return ret;
    }
    // maps all nodes of the component to one random representative
    glueSameLayerNodesOfALayer(sameLayerNodes) {
        if (sameLayerNodes.length > 1) {
            let representative = -1;
            if (this.componentsIsMaxLayer(sameLayerNodes)) {
                for (const v of sameLayerNodes)
                    this.sameLayerDictionaryOfRepresentatives.set(v, (representative = this.maxRepresentative));
            }
            else if (this.componentIsMinLayer(sameLayerNodes)) {
                for (const v of sameLayerNodes)
                    this.sameLayerDictionaryOfRepresentatives.set(v, (representative = this.minRepresentative));
            }
            else {
                for (const v of sameLayerNodes) {
                    if (representative === -1)
                        representative = v;
                    this.sameLayerDictionaryOfRepresentatives.set(v, representative);
                }
            }
            this.representativeToItsLayer.set(representative, sameLayerNodes);
        }
    }
    componentIsMinLayer(component) {
        return component.findIndex((p) => this.minRepresentative === p) >= 0;
    }
    componentsIsMaxLayer(component) {
        return component.findIndex((p) => this.maxRepresentative === p) >= 0;
    }
    createIntegerConstraints() {
        this.createMaxIntConstraints();
        this.createMinIntConstraints();
        this.createUpDownConstraints();
        this.createSameLayerConstraints();
    }
    createSameLayerConstraints() {
        this.sameLayerInts = this.createIntConstraintsFromStringCouples(this.sameLayerConstraints);
    }
    createUpDownConstraints() {
        this.upDownInts = this.createIntConstraintsFromStringCouples(this.upDownConstraints);
    }
    createIntConstraintsFromStringCouples(list) {
        return list.map((couple) => [this.nodeIndex(couple[0]), this.nodeIndex(couple[1])]).filter((t) => t[0] !== -1 && t[1] !== -1);
    }
    createMinIntConstraints() {
        this.minLayerInt = this.createIntConstraintsFromExtremeLayer(this.minLayerOfGeomGraph);
        if (this.minLayerInt.length > 0)
            this.minRepresentative = this.minLayerInt[0];
    }
    createMaxIntConstraints() {
        this.maxLayerInt = this.createIntConstraintsFromExtremeLayer(this.maxLayerOfGeomGraph);
        if (this.maxLayerInt.length > 0)
            this.maxRepresentative = this.maxLayerInt[0];
    }
    createIntConstraintsFromExtremeLayer(setOfNodes) {
        //return new Array<number>(from node in setOfNodes let index = NodeIndex(node) where index !== -1 select index);
        return Array.from(setOfNodes)
            .map((n) => this.nodeIndex(n))
            .filter((i) => i !== -1);
    }
    nodeIndex(node) {
        const index = this.nodeIdToIndex.get(node.node.id);
        return index ? index : -1;
    }
    getFeedbackSet() {
        this.gluedIntGraph = this.createGluedGraph();
        return Array.from(this.unglueIntPairs(_CycleRemoval__WEBPACK_IMPORTED_MODULE_2__.CycleRemoval.getFeedbackSetWithConstraints(this.gluedIntGraph, this.gluedUpDownIntConstraints)));
    }
    *unglueIntPairs(gluedEdges) {
        for (const gluedEdge of gluedEdges)
            for (const ungluedEdge of this.unglueEdge(gluedEdge))
                yield ungluedEdge;
    }
    *unglueEdge(gluedEdge) {
        for (const source of this.unglueNode(gluedEdge.source))
            for (const edge of this.intGraph.outEdges[source])
                if (this.nodeToRepr(edge.target) === gluedEdge.target)
                    yield edge;
    }
    createGluedGraph() {
        const set = new _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_4__.IntPairSet();
        this.intGraph.edges.forEach((e) => set.add(this.gluedIntPairI(e)));
        return (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__.mkGraphOnEdgesN)(Array.from(set.values()), this.intGraph.nodeCount);
        //return new BasicGraphOnEdges<IntPair>(new Set<IntPair>(from edge in this.intGraph.Edges select GluedIntPair(edge)), this.intGraph.NodeCount);
    }
    unglueNode(node) {
        const layer = this.representativeToItsLayer.get(node);
        if (layer)
            return layer;
        return [node];
    }
    getGluedNodeCounts() {
        const ret = new Array(this.nodeIdToIndex.size).fill(0);
        for (let node = 0; node < ret.length; node++)
            ret[this.nodeToRepr(node)]++;
        return ret;
    }
}
//# sourceMappingURL=verticalConstraintsForSugiyama.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/xCoordsWithAlignment.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XCoordsWithAlignment: () => (/* binding */ XCoordsWithAlignment)
/* harmony export */ });
/* harmony import */ var _math_graphAlgorithms_topologicalSort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/graphAlgorithms/topologicalSort.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairSet.js");
/* harmony import */ var _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/polyIntEdge.js");
// The implementation follows
// "Fast and Simple Horizontal Coordinate Assignment" of Ulrik Brandes and Boris K�opf
// The paper has two serious bugs that this code resolves.





class XCoordsWithAlignment {
    get CurrentEnumRightUp() {
        return (this.LR ? 0 : 1) + 2 * (this.BT ? 0 : 1);
    }
    // Returns true if v is a virtual vertex
    IsVirtual(v) {
        return v >= this.nOfOriginalVertices;
    }
    Source(edge) {
        return this.BT ? edge.Source : edge.Target;
    }
    Target(edge) {
        return this.BT ? edge.Target : edge.Source;
    }
    static CalculateXCoordinates(layerArrays, layeredGraph, nOfOriginalVs, anchors, nodeSeparation) {
        const x = new XCoordsWithAlignment(layerArrays, layeredGraph, nOfOriginalVs, anchors, nodeSeparation);
        x.Calculate();
    }
    Calculate() {
        this.SortInAndOutEdges();
        this.RightUpSetup();
        this.CalcBiasedAlignment();
        this.LeftUpSetup();
        this.CalcBiasedAlignment();
        this.RightDownSetup();
        this.CalcBiasedAlignment();
        this.LeftDownSetup();
        this.CalcBiasedAlignment();
        this.HorizontalBalancing();
    }
    // We need to find a median of a vertex neighbors from a specific layer. That is, if we have a vertex v and edges (v,coeff), (v,side1), (v,cornerC)
    // going down, and X[coeff]<X[side1]<X[cornerC], then side1 is the median.
    // There is an algorithm that finds the median with expected linear number of steps,
    // see for example http://www.ics.uci.edu/~eppstein/161/960125.html. However, I think we are better off
    // with sorting, since we are taking median at least twice.
    // Notice, that the sorting should be done only for original vertices since dummy vertices
    // have only one incoming edge and one outcoming edge.
    // Consider here reusing the sorting that comes from the ordering step,
    // if it is not broken by layer insertions.
    SortInAndOutEdges() {
        this.FillLowMedians();
        this.FillUpperMedins();
    }
    FillUpperMedins() {
        this.upperMedians = new Array(this.graph.NodeCount);
        for (let i = 0; i < this.graph.NodeCount; i++) {
            this.FillUpperMediansForNode(i);
        }
    }
    CompareByX(a, b) {
        return this.la.x[a] - this.la.x[b];
    }
    FillUpperMediansForNode(i) {
        let count = this.graph.InEdgesCount(i);
        if (count > 0) {
            const predecessors = new Array(count);
            count = 0;
            for (const e of this.graph.InEdges(i)) {
                predecessors[count++] = e.Source;
            }
            predecessors.sort((a, b) => this.CompareByX(a, b));
            const m = Math.floor(count / 2);
            if (m * 2 === count) {
                this.upperMedians[i] = new _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__.IntPair(predecessors[m - 1], predecessors[m]);
            }
            else {
                this.upperMedians[i] = predecessors[m];
            }
        }
        else {
            this.upperMedians[i] = -1;
        }
    }
    FillLowMedians() {
        this.lowMedians = new Array(this.graph.NodeCount);
        for (let i = 0; i < this.graph.NodeCount; i++) {
            this.FillLowMediansForNode(i);
        }
    }
    FillLowMediansForNode(i) {
        let count = this.graph.OutEdgesCount(i);
        if (count > 0) {
            const successors = new Array(count);
            count = 0;
            for (const e of this.graph.OutEdges(i)) {
                successors[count++] = e.Target;
            }
            successors.sort((a, b) => this.CompareByX(a, b));
            const m = Math.floor(count / 2);
            if (m * 2 === count) {
                this.lowMedians[i] = new _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__.IntPair(successors[m - 1], successors[m]);
            }
            else {
                this.lowMedians[i] = successors[m];
            }
        }
        else {
            this.lowMedians[i] = -1;
        }
    }
    HorizontalBalancing() {
        let leastWidthAssignment = -1;
        const a = new Array(4);
        const b = new Array(4);
        let leastWidth = Number.MAX_VALUE;
        for (let i = 0; i < 4; i++) {
            const t = { a: 0, b: 0 };
            this.AssignmentBounds(i, t);
            a[i] = t.a;
            b[i] = t.b;
            const w = b[i] - a[i];
            if (w < leastWidth) {
                leastWidthAssignment = i;
                leastWidth = w;
            }
        }
        for (let i = 0; i < 4; i++) {
            let delta;
            if (XCoordsWithAlignment.IsLeftMostAssignment(i)) {
                delta = a[leastWidthAssignment] - a[i];
            }
            else {
                delta = b[leastWidthAssignment] - b[i];
            }
            this.x = this.xCoords[i];
            if (delta !== 0) {
                for (let j = 0; j < this.nOfVertices; j++) {
                    this.x[j] = this.x[j] + delta;
                }
            }
        }
        const arr = new Array(4);
        for (let v = 0; v < this.nOfVertices; v++) {
            arr[0] = this.xCoords[0][v];
            arr[1] = this.xCoords[1][v];
            arr[2] = this.xCoords[2][v];
            arr[3] = this.xCoords[3][v];
            arr.sort((a, b) => a - b);
            this.anchors[v].x = (arr[1] + arr[2]) / 2;
        }
        //    Layout.ShowDataBase(dataBase);
    }
    static IsLeftMostAssignment(i) {
        return i === 0 || i === 2;
    }
    AssignmentBounds(i, t) {
        if (this.nOfVertices === 0) {
            t.a = 0;
            t.b = 0;
        }
        else {
            this.x = this.xCoords[i];
            t.a = t.b = this.x[0];
            for (let j = 1; j < this.nOfVertices; j++) {
                const r = this.x[j];
                if (r < t.a) {
                    t.a = r;
                }
                else if (r > t.b) {
                    t.b = r;
                }
            }
        }
    }
    CalcBiasedAlignment() {
        this.ConflictElimination();
        this.Align();
    }
    LeftUpSetup() {
        this.LR = false;
        this.BT = true;
    }
    LeftDownSetup() {
        this.LR = false;
        this.BT = false;
    }
    RightDownSetup() {
        this.LR = true;
        this.BT = false;
    }
    RightUpSetup() {
        this.LR = true;
        this.BT = true;
    }
    // The code is written as if we go left up, but in fact the settings define the directions.
    //
    // We need to create a subgraph for alignment:
    // where no edge segments intersect, and every vertex has
    // at most one incoming and at most one outcoming edge.
    // This function marks edges to resolve conflicts with only one inner segment.
    // An inner segment is a segment between two dummy nodes.
    // We mark edges that later will not participate in the alignment.
    // Inner segments are preferred to other ones. So, in a conflict with one inner and one
    // non-inner edges we leave the inner edge to participate in the alignment.
    // At the moment we mark as not participating both of the two intersecting inner segments
    ConflictElimination() {
        this.RemoveMarksFromEdges();
        this.MarkConflictingEdges();
    }
    // iterator
    *UpperEdgeMedians(target) {
        const medians = this.BT ? this.upperMedians[target] : this.lowMedians[target];
        const isIp = !(typeof medians === 'number');
        if (isIp) {
            const ip = medians;
            if (this.LR) {
                yield ip.x;
                yield ip.y;
            }
            else {
                yield ip.y;
                yield ip.x;
            }
        }
        else {
            const i = medians;
            if (i >= 0) {
                yield i;
            }
        }
    }
    // here we eliminate all constraints
    MarkConflictingEdges() {
        let i = this.LowerOf(0, this.h - 1);
        const lowest = i;
        const upperBound = this.UpperOf(0, this.h - 1);
        const nextBelowUpperBound = this.NextLower(upperBound);
        // our top layer has index h-1, our bottom layer has index 0
        // inner segments can appear only between layers with indices i+1 and i where i>0 and i<h-1
        for (; this.IsBelow(i, upperBound); i = this.NextUpper(i)) {
            if (this.IsBelow(lowest, i) && this.IsBelow(i, nextBelowUpperBound)) {
                this.ConflictsWithAtLeastOneInnerEdgeForALayer(i);
            }
        }
    }
    // parameterized next upper
    NextUpper(i) {
        return this.BT ? i + 1 : i - 1;
    }
    // parameterized next lower
    NextLower(i) {
        return this.BT ? i - 1 : i + 1;
    }
    // parameterize highest of two numbers
    UpperOf(i, j) {
        return this.BT ? Math.max(i, j) : Math.min(i, j);
    }
    // parameterized lowest of a pair
    LowerOf(i, j) {
        return this.BT ? Math.min(i, j) : Math.max(i, j);
    }
    // returns parameterized below
    IsBelow(i, j) {
        return this.BT ? i < j : j < i;
    }
    // returns the "parameterized" left of the two positions
    LeftMost(pos0, pos1) {
        return this.LR ? Math.min(pos0, pos1) : Math.max(pos0, pos1);
    }
    // returns the "parameterized" right of the two positions
    RightMost(pos0, pos1) {
        return this.LR ? Math.max(pos0, pos1) : Math.min(pos0, pos1);
    }
    // Return true if i is to the left or equal to pos in a "parameterized" fasion
    IsNotRightFrom(i, pos) {
        return this.LR ? i <= pos : pos <= i;
    }
    // Parameterized left relation
    IsLeftFrom(i, j) {
        return this.LR ? i < j : j < i;
    }
    // parameterized next right
    NextRight(i) {
        return this.LR ? i + 1 : i - 1;
    }
    // parameterized next left
    NextLeft(i) {
        return this.LR ? i - 1 : i + 1;
    }
    // // Eliminates conflicts with at least one inner edge inside of one layer
    // // <
    ConflictsWithAtLeastOneInnerEdgeForALayer(layerIndex) {
        if (layerIndex >= 0 && layerIndex < this.la.Layers.length) {
            const lowerLayer = this.la.Layers[layerIndex];
            let innerEdge = null;
            // start looking for the first inner edge from the left of lowerLayer
            let targetPos = this.LeftMost(0, lowerLayer.length - 1);
            const lastTargetPos = this.RightMost(0, lowerLayer.length - 1);
            for (; this.IsNotRightFrom(targetPos, lastTargetPos) && innerEdge == null; targetPos = this.NextRight(targetPos)) {
                innerEdge = this.InnerEdgeByTarget(lowerLayer[targetPos]);
            }
            // now targetPos points to the right of the innerEdge target at lowerLayer
            if (innerEdge != null) {
                const positionOfInnerEdgeSource = this.Pos(this.Source(innerEdge));
                // We are still not in the main loop.
                // We mark conflicting edges with targets to the left of targetPos,
                // That of course means
                // that the sources of conflicting edges lie to the right of Source(innerEdge)
                for (let j = this.LeftMost(0, lowerLayer.length - 1); this.IsLeftFrom(j, targetPos); j = this.NextRight(j)) {
                    for (const ie of this.InEdges(lowerLayer[j])) {
                        if (this.IsLeftFrom(positionOfInnerEdgeSource, this.Pos(this.Source(ie)))) {
                            this.MarkEdge(ie);
                        }
                    }
                }
                let innerSourcePos = this.Pos(this.Source(innerEdge));
                // starting the main loop
                while (this.IsNotRightFrom(targetPos, lastTargetPos)) {
                    // Now we look for the next inner edge in the alignment to the right of the current innerEdge,
                    // and we mark the conflicts later. Marking the conflicts later makes sense.
                    // We would have to go through positions between innerEdge and newInnerEdge targets
                    // again anyway to resolve conflicts with not inner edges and newInnerEdge
                    const newInnerEdge = this.AlignmentToTheRightOfInner(lowerLayer, targetPos, positionOfInnerEdgeSource);
                    targetPos = this.NextRight(targetPos);
                    if (newInnerEdge != null) {
                        const newInnerSourcePos = this.Pos(this.Source(newInnerEdge));
                        this.MarkEdgesBetweenInnerAndNewInnerEdges(lowerLayer, innerEdge, newInnerEdge, innerSourcePos, newInnerSourcePos);
                        innerEdge = newInnerEdge;
                        innerSourcePos = newInnerSourcePos;
                    }
                }
                // look for conflicting edges with targets to the right from the target of innerEdge
                for (let k = this.NextRight(this.Pos(this.Target(innerEdge))); this.IsNotRightFrom(k, lastTargetPos); k = this.NextRight(k)) {
                    for (const ie of this.InEdges(lowerLayer[k])) {
                        if (this.IsLeftFrom(this.Pos(this.Source(ie)), this.Pos(this.Source(innerEdge)))) {
                            this.MarkEdge(ie);
                        }
                    }
                }
            }
        }
    }
    InEdgeOfVirtualNode(v) {
        return this.BT ? this.graph.InEdgeOfVirtualNode(v) : this.graph.OutEdgeOfVirtualNode(v);
    }
    InEdges(v) {
        return this.BT ? this.graph.InEdges(v) : this.graph.OutEdges(v);
    }
    // // This function marks conflicting edges with targets positioned between innerEdge and newInnerEdge targets.
    // // <
    MarkEdgesBetweenInnerAndNewInnerEdges(lowerLayer, innerEdge, newInnerEdge, innerEdgeSourcePos, newInnerEdgeSourcePos) {
        let u = this.NextRight(this.Pos(this.Target(innerEdge)));
        for (; this.IsLeftFrom(u, this.Pos(this.Target(newInnerEdge))); u = this.NextRight(u)) {
            for (const ie of this.InEdges(lowerLayer[u])) {
                const ieSourcePos = this.Pos(this.Source(ie));
                if (this.IsLeftFrom(ieSourcePos, innerEdgeSourcePos)) {
                    this.MarkEdge(ie);
                }
                else if (this.IsLeftFrom(newInnerEdgeSourcePos, ieSourcePos)) {
                    this.MarkEdge(ie);
                }
            }
        }
    }
    // // Returns the inner non-conflicting edge incoming into i-th position
    // // of the layer or null if there is no such edge
    // // <
    AlignmentToTheRightOfInner(lowLayer, i, posInnerSource) {
        const numOfInEdges = this.NumberOfInEdges(lowLayer[i]);
        if (numOfInEdges === 1) {
            let ie = null;
            for (const e of this.InEdges(lowLayer[i])) {
                ie = e;
            }
            if (this.IsInnerEdge(ie) && this.IsLeftFrom(posInnerSource, this.Pos(ie.Source))) {
                return ie;
            }
            return null;
        }
        return null;
    }
    NumberOfInEdges(v) {
        return this.BT ? this.graph.InEdgesCount(v) : this.graph.OutEdgesCount(v);
    }
    Pos(v) {
        return this.la.x[v];
    }
    InnerEdgeByTarget(v) {
        if (this.IsVirtual(v)) {
            const ie = this.InEdgeOfVirtualNode(v);
            // there is exactly one edge entering in to the dummy node
            if (this.IsVirtual(this.Source(ie))) {
                return ie;
            }
        }
        return null;
    }
    IsInnerEdge(e) {
        return this.IsVirtual(e.Source) && this.IsVirtual(e.Target);
    }
    RemoveMarksFromEdges() {
        this.markedEdges.clear();
    }
    // // private constructor
    // // <
    constructor(layerArrays, layeredGraph, nOfOriginalVs, anchorsP, ns) {
        // four arrays for four different direction combinations
        this.xCoords = new Array(4);
        this.la = layerArrays;
        this.graph = layeredGraph;
        this.nOfOriginalVertices = nOfOriginalVs;
        this.nOfVertices = this.graph.NodeCount;
        this.markedEdges = new _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_3__.IntPairSet();
        this.h = this.la.Layers.length;
        this.root = new Array(this.nOfVertices);
        this.align = new Array(this.nOfVertices);
        // this.sink = new int[nOfVertices];
        // this.shift = new double[nOfVertices];
        this.anchors = anchorsP;
        this.nodeSep = ns;
    }
    // Calculate the alignment based on the marked edges and greedily resolve the remaining conflicts on the fly, without marking
    Align() {
        this.CreateBlocks();
        this.AssignCoordinatesByLongestPath();
    }
    AssignCoordinatesByLongestPath() {
        this.x = this.xCoords[this.CurrentEnumRightUp] = new Array(this.nOfVertices);
        // create the graph first
        const edges = new Array();
        for (let v = 0; v < this.nOfVertices; v++) {
            if (v === this.root[v]) {
                //v is a root
                let w = v; //w will be running over the block
                do {
                    const rn = { neighbor: 0 };
                    if (this.TryToGetRightNeighbor(w, rn))
                        edges.push(new _polyIntEdge__WEBPACK_IMPORTED_MODULE_4__.PolyIntEdge(v, this.root[rn.neighbor], null));
                    w = this.align[w];
                } while (w !== v);
            }
        }
        const blockGraph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__.mkGraphOnEdgesN)(edges, this.nOfVertices);
        // sort the graph in the topological order
        const topoSort = _math_graphAlgorithms_topologicalSort__WEBPACK_IMPORTED_MODULE_0__.TopologicalSort.getOrderOnGraph(blockGraph);
        // start placing the blocks according to the order
        for (const v of topoSort) {
            if (v === this.root[v]) {
                let vx = 0;
                let vIsLeftMost = true;
                let w = v;
                // w is running over the block
                do {
                    const wLn = { neighbor: 0 };
                    if (this.TryToGetLeftNeighbor(w, wLn)) {
                        if (vIsLeftMost) {
                            vx = this.x[this.root[wLn.neighbor]] + this.DeltaBetweenVertices(wLn.neighbor, w);
                            vIsLeftMost = false;
                        }
                        else {
                            vx = this.RightMost(vx, this.x[this.root[wLn.neighbor]] + this.DeltaBetweenVertices(wLn.neighbor, w));
                        }
                    }
                    w = this.align[w];
                } while (w !== v);
                this.x[v] = vx;
            }
        }
        // push the roots of the graph maximally to the right
        for (const v of topoSort) {
            if (v === this.root[v]) {
                if (blockGraph.inEdges[v].length === 0) {
                    let w = v;
                    // w runs over the block
                    let xLeftMost = this.RightMost(-XCoordsWithAlignment.infinity, XCoordsWithAlignment.infinity);
                    const xl = xLeftMost;
                    do {
                        const wRn = { neighbor: 0 };
                        if (this.TryToGetRightNeighbor(w, wRn)) {
                            xLeftMost = this.LeftMost(xLeftMost, this.x[this.root[wRn.neighbor]] - this.DeltaBetweenVertices(w, wRn.neighbor));
                        }
                        w = this.align[w];
                    } while (w !== v);
                    if (xl !== xLeftMost) {
                        this.x[v] = xLeftMost;
                    }
                }
            }
        }
        for (let v = 0; v < this.nOfVertices; v++) {
            if (v !== this.root[v]) {
                this.x[v] = this.x[this.root[v]];
            }
        }
    }
    // returns true is u has a right neighbor on its layer
    TryToGetRightNeighbor(u, t) {
        const neighborPos = this.NextRight(this.Pos(u));
        const layer = this.la.Layers[this.la.y[u]];
        if (neighborPos >= 0 && neighborPos < layer.length) {
            t.neighbor = layer[neighborPos];
            return true;
        }
        else {
            return false;
        }
    }
    // returns true is u has a right neighbor on its layer
    TryToGetLeftNeighbor(u, t) {
        const neighborPos = this.NextLeft(this.Pos(u));
        const layer = this.la.Layers[this.la.y[u]];
        if (neighborPos >= 0 && neighborPos < layer.length) {
            t.neighbor = layer[neighborPos];
            return true;
        }
        else {
            return false;
        }
    }
    // Organizes the vertices into blocks. A block is a maximal path in the alignment subgraph.
    // The alignment is defined by array align. Every vertex is connected to the top vertex of
    // the block by using root array. The alignment is cyclic. If we start from a root vertex v and
    // apply align then we return to v at some point.
    CreateBlocks() {
        for (let v = 0; v < this.nOfVertices; v++) {
            this.root[v] = this.align[v] = v;
        }
        const lowBound = this.LowerOf(0, this.h - 1);
        // i points to the last layer before the highest one
        for (let i = this.NextLower(this.UpperOf(0, this.h - 1)); !this.IsBelow(i, lowBound); i = this.NextLower(i)) {
            const layer = this.la.Layers[i];
            let r = this.LeftMost(-1, this.la.Layers[this.NextUpper(i)].length);
            // We align vertices of the layer above the i-th one only if their positions are
            // to the right of r. This moves us forward on the layer above the current and resolves the conflicts.
            const rightBound = this.RightMost(0, layer.length - 1);
            for (let k = this.LeftMost(0, layer.length - 1); this.IsNotRightFrom(k, rightBound); k = this.NextRight(k)) {
                const vk = layer[k];
                for (const upperNeighborOfVk of this.UpperEdgeMedians(vk)) {
                    if (!this.IsMarked(vk, upperNeighborOfVk)) {
                        if (this.IsLeftFrom(r, this.Pos(upperNeighborOfVk))) {
                            this.align[upperNeighborOfVk] = vk;
                            this.root[vk] = this.root[upperNeighborOfVk];
                            this.align[vk] = this.root[upperNeighborOfVk];
                            r = this.Pos(upperNeighborOfVk);
                            break;
                            // done with the alignement for vk
                        }
                    }
                }
            }
        }
    }
    IsMarked(source, target) {
        if (this.BT) {
            return this.markedEdges.hasxy(target, source);
        }
        else {
            return this.markedEdges.hasxy(source, target);
        }
    }
    MarkEdge(ie) {
        this.markedEdges.addNN(ie.Source, ie.Target);
    }
    // Calculates the minimum separation between two neighboring vertices: if u is to the left of v on the same layer return positive
    // number, otherwise negative.
    DeltaBetweenVertices(u, v) {
        let sign;
        if (this.Pos(u) > this.Pos(v)) {
            // swap u and v
            const t = u;
            u = v;
            v = t;
            sign = -1;
        }
        else {
            sign = 1;
        }
        return (this.anchors[u].rightAnchor + this.anchors[v].leftAnchor + this.nodeSep) * sign;
    }
}
// Assigning xcoords starting from roots
XCoordsWithAlignment.infinity = 10000000;
//# sourceMappingURL=xCoordsWithAlignment.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/layered/xLayoutGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XLayoutGraph: () => (/* binding */ XLayoutGraph)
/* harmony export */ });
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
// Follows the idea from Gansner etc 93, creating a special graph
// for x-coordinates calculation

class XLayoutGraph extends _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__.BasicGraphOnEdges {
    // weight multiplier for edges with two virtual nodes
    /* internal */ constructor(graph, layeredGraph, layerArrays, edges, nov) {
        super();
        // we have 0,,,virtualVerticesStart-1 - usual vertices
        // virtualVerticesStart,...,virtualVerticesEnd -virtual vertices
        // and virtualVirticesEnd+1, ...NumberOfVertices - nvertices
        this.weightMultiplierOfOriginalOriginal = 1;
        // weight multiplier for edges with Defaults or n end and start
        this.weightMultOfOneVirtual = 3;
        // weight multiplier for edges with only one virtual node
        this.weightMultiplierOfTwoVirtual = 8;
        this.SetEdges(edges, nov);
        this.virtualVerticesStart = graph.nodeCount;
        this.virtualVerticesEnd = layeredGraph.NodeCount - 1;
        this.layeredGraph = layeredGraph;
        this.layerArrays = layerArrays;
    }
    // following Gansner etc 93 returning weight multplier bigger if there are virtual nodes
    EdgeWeightMultiplier(edge) {
        const s = edge.source;
        const t = edge.target;
        if (s < this.layeredGraph.NodeCount &&
            this.layerArrays.y[s] === this.layerArrays.y[t] &&
            this.layerArrays.x[s] === this.layerArrays.x[t] + 1) {
            return 0;
        }
        // this edge needed only for separation vertices in the same layer
        let k = 0;
        /*Assert.assert(s >= this.layeredGraph.NodeCount)*/
        // check the graph on correctness`
        //    throw new Error();//"XLayout graph is incorrect");
        // here (s0,t0) is the edge of underlying graph
        let t0 = -1;
        let s0 = -1;
        // t0 is set to -1 to only avoid the warning
        // there are only two edges in graph.OutEdges(s)
        for (const intEdge of this.outEdges[s]) {
            if (s0 === -1) {
                s0 = intEdge.target;
            }
            else {
                t0 = intEdge.target;
            }
        }
        if (s0 >= this.virtualVerticesStart && s0 <= this.virtualVerticesEnd) {
            k++;
        }
        if (t0 >= this.virtualVerticesStart && t0 <= this.virtualVerticesEnd) {
            k++;
        }
        const ret = k === 0 ? this.weightMultiplierOfOriginalOriginal : k === 1 ? this.weightMultOfOneVirtual : this.weightMultiplierOfTwoVirtual;
        return ret;
    }
    // caching edges weights
    SetEdgeWeights() {
        for (const intEdge of this.edges) {
            intEdge.weight = intEdge.weight * this.EdgeWeightMultiplier(intEdge);
        }
    }
}
//# sourceMappingURL=xLayoutGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/mds/AllPairsDistances.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AllPairsDistances: () => (/* binding */ AllPairsDistances)
/* harmony export */ });
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _SingleSourceDistances__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/SingleSourceDistances.js");


// Algorithm for computing the distance between every pair of nodes in a graph.
class AllPairsDistances extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__.Algorithm {
    // The resulting distances between every pair of nodes in the graph.
    get Result() {
        return this.result;
    }
    set Result(value) {
        this.result = value;
    }
    // Computes distances between every pair of nodes in a graph.
    // Distances are symmetric if the graph is undirected.
    constructor(graph, length) {
        super(null);
        this.graph = graph;
        this.length = length;
    }
    // Executes the algorithm.
    run() {
        this.result = new Array(this.graph.shallowNodeCount);
        let i = 0;
        for (const source of this.graph.shallowNodes) {
            const distances = new _SingleSourceDistances__WEBPACK_IMPORTED_MODULE_1__.SingleSourceDistances(this.graph, source, this.length);
            distances.run();
            this.Result[i++] = distances.Result;
        }
    }
    // Computes the "stress" of the current layout of the given graph:
    //
    //   stress = sum_{(u,v) in V}  (d(u,v) - D(u,v))^2/(D(u,v)^2)
    //
    // where:
    //   V is the set of nodes
    //   d(u,v) is the euclidean distance between the centers of nodes u and v
    //   D(u,v) is the graph-theoretic path length between u and v - scaled by average edge length.
    //
    // Small stress in graph layout correlated with immediate neighbors to be closer
    // together than nodes that are a few hops apart (i.e. that have path length>1).  More generally
    // the distance between nodes in the drawing should be proportional to the path length between them.
    // The lower the stress of a particular graph layout the better it conforms to this ideal.
    //
    static Stress(graph, length) {
        let stress = 0;
        if (graph.edgeCount === 0) {
            return stress;
        }
        const apd = new AllPairsDistances(graph, length);
        apd.run();
        const D = apd.Result;
        let l = 0;
        for (const e of graph.shallowEdges) {
            l += length(e);
        }
        l /= graph.edgeCount; // average of lengths
        let i = 0;
        for (const u of graph.shallowNodes) {
            let j = 0;
            for (const v of graph.shallowNodes) {
                if (i !== j) {
                    const duv = u.center.sub(v.center).length;
                    const Duv = l * D[i][j];
                    const d = Duv - duv;
                    stress += (d * d) / (Duv * Duv);
                }
                j++;
            }
            i++;
        }
        return stress;
    }
}
//# sourceMappingURL=AllPairsDistances.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/mds/SingleSourceDistances.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SingleSourceDistances: () => (/* binding */ SingleSourceDistances)
/* harmony export */ });
/* harmony import */ var _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");


// Provides functionality for computing distances in a graph.
class SingleSourceDistances extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_1__.Algorithm {
    // Dijkstra algorithm. Computes graph-theoretic distances from a node to
    // all other nodes in a graph with nonnegative edge lengths.
    // The distance between a node and itself is 0; the distance between a pair of
    // nodes for which no connecting path exists is Number.POSITIVE_INFINITY.
    constructor(graph, source, length) {
        super(null); // todo: pass the canceltoken
        this.graph = graph;
        this.source = source;
        this.length = length;
    }
    // An array of distances from the source node to all shallow nodes.
    // Nodes are indexed when iterating over them.
    get Result() {
        return this.result;
    }
    // Executes the algorithm.
    run() {
        const q = new _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__.GenericBinaryHeapPriorityQueue((a, b) => a - b);
        const d = new Map();
        for (const node of this.graph.shallowNodes) {
            const dist = node === this.source ? 0 : Number.POSITIVE_INFINITY;
            q.Enqueue(node, dist);
            d.set(node, dist);
        }
        while (q.count > 0) {
            const t = { priority: 0 };
            const u = q.DequeueAndGetPriority(t);
            d.set(u, t.priority);
            const distU = d.get(u);
            for (const vu of u.inEdges()) {
                const v = vu.source;
                // relaxation step
                const nl = distU + this.length(vu);
                if (d.get(v) > nl) {
                    d.set(v, nl);
                    q.DecreasePriority(v, nl);
                }
            }
            for (const uv of u.outEdges()) {
                const v = uv.target;
                // relaxation step
                const nl = distU + this.length(uv);
                if (d.get(v) > nl) {
                    d.set(v, nl);
                    q.DecreasePriority(v, nl);
                }
            }
        }
        this.result = new Array(this.graph.shallowNodeCount);
        let i = 0;
        for (const v of this.graph.shallowNodes) {
            const dist = d.get(v);
            if (dist !== undefined) {
                this.result[i++] = dist;
            }
            else {
                this.result[i++] = Number.POSITIVE_INFINITY;
            }
        }
    }
}
//# sourceMappingURL=SingleSourceDistances.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/mds/Transform.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform)
/* harmony export */ });
class Transform {
    // Rotates a 2D configuration clockwise by a given angle
    // The angle is given in degrees
    static Rotate(x, y, angle) {
        const sin = Math.sin(angle * (Math.PI / 180));
        const cos = Math.cos(angle * (Math.PI / 180));
        for (let i = 0; i < x.length; i++) {
            const t = cos * x[i] + sin * y[i];
            y[i] = cos * y[i] - sin * x[i];
            x[i] = t;
        }
    }
}
//# sourceMappingURL=Transform.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/mds/mDSGraphLayout.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MdsGraphLayout: () => (/* binding */ MdsGraphLayout)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _AllPairsDistances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/AllPairsDistances.js");
/* harmony import */ var _pivotDistances__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/pivotDistances.js");
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/Transform.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _multiDimensionalScaling__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/multiDimensionalScaling.js");
/* harmony import */ var _math_geometry_rectanglePacking_OptimalRectanglePacking__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/OptimalRectanglePacking.js");
/* harmony import */ var _gTreeOverlapRemoval_gTreeOverlapRemoval__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/gTreeOverlapRemoval/gTreeOverlapRemoval.js");









// Class for graph layout with multidimensional scaling.
class MdsGraphLayout extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_5__.Algorithm {
    // Constructs the multidimensional scaling algorithm.
    constructor(settings, geometryGraph, cancelToken, length) {
        super(cancelToken);
        this.settings = settings;
        this.graph = geometryGraph;
        this.length = length;
    }
    // Executes the algorithm
    run() {
        this.LayoutConnectedGraphWithMds();
        this.graph.pumpTheBoxToTheGraphWithMargins();
    }
    // Scales a configuration such that the average edge length in the drawing
    // equals the average of the given edge lengths.
    static ScaleToAverageEdgeLength(g, x, y, length) {
        const index = new Map();
        let c = 0;
        for (const node of g.shallowNodes) {
            index.set(node, c);
            c++;
        }
        let avgLength = 0;
        let avgSum = 0;
        for (const edge of g.shallowEdges) {
            const i = index.get(edge.source);
            const j = index.get(edge.target);
            avgSum += Math.sqrt(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2));
            avgLength += length(edge);
        }
        if (avgLength > 0) {
            avgSum /= avgLength;
        }
        if (avgSum > 0) {
            for (let i = 0; i < x.length; i++) {
                x[i] /= avgSum;
                y[i] /= avgSum;
            }
        }
    }
    // Layouts a connected graph with Multidimensional Scaling, using
    // shortest-path distances as Euclidean target distances.
    static LayoutGraphWithMds(geometryGraph, settings, arrays, length) {
        arrays.x = new Array(geometryGraph.shallowNodeCount);
        arrays.y = new Array(geometryGraph.shallowNodeCount);
        if (arrays.x.length === 0) {
            return;
        }
        if (arrays.x.length === 1) {
            arrays.x[0] = arrays.y[0] = 0;
            return;
        }
        const k = Math.min(settings.PivotNumber, geometryGraph.shallowNodeCount);
        const iter = settings.GetNumberOfIterationsWithMajorization(geometryGraph.shallowNodeCount);
        const exponent = settings.Exponent;
        const pivotArray = new Array(k);
        const pivotDistances = new _pivotDistances__WEBPACK_IMPORTED_MODULE_3__.PivotDistances(geometryGraph, pivotArray, length);
        pivotDistances.run();
        const c = pivotDistances.Result;
        _multiDimensionalScaling__WEBPACK_IMPORTED_MODULE_6__.MultidimensionalScaling.LandmarkClassicalScaling(c, arrays, pivotArray);
        MdsGraphLayout.ScaleToAverageEdgeLength(geometryGraph, arrays.x, arrays.y, length);
        if (iter > 0) {
            const apd = new _AllPairsDistances__WEBPACK_IMPORTED_MODULE_2__.AllPairsDistances(geometryGraph, length);
            apd.run();
            const d = apd.Result;
            const w = _multiDimensionalScaling__WEBPACK_IMPORTED_MODULE_6__.MultidimensionalScaling.ExponentialWeightMatrix(d, exponent);
            // MultidimensionalScaling.DistanceScaling(d, x, y, w, iter);
            _multiDimensionalScaling__WEBPACK_IMPORTED_MODULE_6__.MultidimensionalScaling.DistanceScalingSubset(d, arrays.x, arrays.y, w, iter);
        }
    }
    LayoutConnectedGraphWithMds() {
        const arrays = { x: [], y: [] };
        MdsGraphLayout.LayoutGraphWithMds(this.graph, this.settings, arrays, this.length);
        if (this.settings.RotationAngle !== 0) {
            _Transform__WEBPACK_IMPORTED_MODULE_4__.Transform.Rotate(arrays.x, arrays.y, this.settings.RotationAngle);
        }
        let index = 0;
        for (const node of this.graph.shallowNodes) {
            if (node.boundingBox) {
                node.center = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(arrays.x[index] * this.settings.ScaleX, arrays.y[index] * this.settings.ScaleY);
            }
            index++;
        }
        if (this.settings.removeOverlaps) {
            _gTreeOverlapRemoval_gTreeOverlapRemoval__WEBPACK_IMPORTED_MODULE_8__.GTreeOverlapRemoval.RemoveOverlaps(Array.from(this.graph.shallowNodes), this.settings.NodeSeparation);
        }
        this.graph.pumpTheBoxToTheGraphWithMargins();
    }
    ScaleNodes(nodes, scale) {
        for (const node of nodes) {
            node.center = node.center.mul(scale);
        }
    }
    //  static UpdateTree(tree: RectangleNode<Node, Point>) {
    //    if (tree.IsLeaf) {
    //      tree.irect = tree.UserData.BoundingBox
    //    } else {
    //      MdsGraphLayout.UpdateTree(tree.Left)
    //      MdsGraphLayout.UpdateTree(tree.Right)
    //      tree.rectangle = tree.Left.rectangle
    //      tree.rectangle.Add(tree.Right.rectangle)
    //    }
    //  }
    //  static NumberOfHits(
    //    numberOfChecks: number,
    //    random: Random,
    //    tree: RectangleNode<Node, Point>,
    //    maxNumberOfHits: number,
    //  ): number {
    //    //  var l = new Array<Point>();
    //    let numberOfHits = 0
    //    for (let i = 0; i < numberOfChecks; i++) {
    //      const point: Point = MdsGraphLayout.RandomPointFromBox(
    //        random,
    //        <Rectangle>tree.rectangle,
    //      )
    //      //    l.Add(point);
    //      HitTestBehavior.Stop
    //      null
    //      numberOfHits++
    //      if (numberOfHits === maxNumberOfHits) {
    //        return maxNumberOfHits
    //      }
    //    }
    //    // LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(Getdc(tree, l));
    //    return numberOfHits
    //  }
    //  static BuildNodeTree(nodes: IList<Node>): RectangleNode<Node, Point> {
    //    return RectangleNode.CreateRectangleNodeOnListOfNodes(
    //      nodes.Select(() => {}, new RectangleNode<Node, Point>(n, n.BoundingBox)),
    //    )
    //  }
    //  static RandomPointFromBox(random: Random, boundingBox: Rectangle): Point {
    //    const x = random.NextDouble()
    //    const y = random.NextDouble()
    //    const p = new Point(
    //      boundingBox.left + boundingBox.width * x,
    //      boundingBox.bottom + boundingBox.height * y,
    //    )
    //    return p
    //  }
    // Pack the given graph components to the specified aspect ratio
    static PackGraphs(graphs, settings) {
        if (graphs.length === 0) {
            return _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkEmpty();
        }
        if (graphs.length === 1)
            return graphs[0].boundingBox;
        const rectangles = graphs.map((g) => g.boundingBox);
        const originalLeftBottoms = new Array();
        for (const g of graphs) {
            originalLeftBottoms.push({ g: g, lb: g.boundingBox.leftBottom.clone() });
        }
        const packing = new _math_geometry_rectanglePacking_OptimalRectanglePacking__WEBPACK_IMPORTED_MODULE_7__.OptimalRectanglePacking(rectangles, settings.PackingAspectRatio);
        packing.run();
        for (const { g, lb } of originalLeftBottoms) {
            const delta = g.boundingBox.leftBottom.sub(lb);
            g.translate(delta);
        }
        return new _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle({
            left: 0,
            bottom: 0,
            right: packing.PackedWidth,
            top: packing.PackedHeight,
        });
    }
}
//# sourceMappingURL=mDSGraphLayout.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/mds/mDSLayoutSettings.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MdsLayoutSettings: () => (/* binding */ MdsLayoutSettings)
/* harmony export */ });
/* harmony import */ var _commonLayoutSettings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/commonLayoutSettings.js");

/** Settings for multi-dimensional scaling */
class MdsLayoutSettings {
    constructor() {
        this.commonSettings = new _commonLayoutSettings__WEBPACK_IMPORTED_MODULE_0__.CommonLayoutSettings();
        // the setting of Multi-Dimensional Scaling layout
        // private double epsilon = Math.Pow(10,-8);
        this.pivotNumber = 50;
        this.iterationsWithMajorization = 30;
        this.scaleX = 100;
        this.scaleY = 100;
        this.exponent = -2;
        this.rotationAngle = 0;
        this._removeOverlaps = true;
        /** do not call iterations with majorization, the local layout improvement heuristic, for graph with at least 2000 nodes */
        this._callIterationsWithMajorizationThreshold = 2000;
        this.adjustScale = false;
    }
    static fromJSON(s) {
        const ret = new MdsLayoutSettings();
        if (s.pivotNumber)
            ret.pivotNumber = s.pivotNumber;
        if (s.iterationsWithMajorization)
            ret.iterationsWithMajorization = s.iterationsWithMajorization;
        if (s.scaleX)
            ret.scaleX = s.scaleX;
        if (s.scaleY)
            ret.scaleY = s.scaleY;
        if (s.exponent)
            ret.exponent = s.exponent;
        if (s.rotationAngle)
            ret.rotationAngle = s.rotationAngle;
        if (s.removeOverlaps != undefined)
            ret._removeOverlaps = s.removeOverlaps;
        if (s._callIterationsWithMajorizationThreshold)
            ret._callIterationsWithMajorizationThreshold = s._callIterationsWithMajorizationThreshold;
        return ret;
    }
    toJSON() {
        const ret = {};
        if (this.pivotNumber != 50)
            ret.pivotNumber = this.pivotNumber;
        if (this.iterationsWithMajorization != 30)
            ret.iterationsWithMajorization = this.iterationsWithMajorization;
        if (this.scaleX != 200)
            ret.scaleX = this.scaleX;
        if (this.scaleY != 200)
            ret.scaleY = this.scaleY;
        if (this.exponent != -2)
            ret.exponent = this.exponent;
        if (this.rotationAngle != 0)
            ret.rotationAngle = this.rotationAngle;
        if (!this._removeOverlaps)
            ret.removeOverlaps = this._removeOverlaps;
        if (this._callIterationsWithMajorizationThreshold != 3000)
            ret._callIterationsWithMajorizationThreshold = this._callIterationsWithMajorizationThreshold;
        return ret;
    }
    get NodeSeparation() {
        return this.commonSettings.NodeSeparation;
    }
    set NodeSeparation(value) {
        this.commonSettings.NodeSeparation = value;
    }
    get edgeRoutingSettings() {
        return this.commonSettings.edgeRoutingSettings;
    }
    set edgeRoutingSettings(value) {
        this.commonSettings.edgeRoutingSettings = value;
    }
    // remove overlaps between node boundaries
    get removeOverlaps() {
        return this._removeOverlaps;
    }
    set removeOverlaps(value) {
        this._removeOverlaps = value;
    }
    // Number of pivots in Landmark Scaling (between 3 and number of objects).
    get PivotNumber() {
        return this.pivotNumber;
    }
    set PivotNumber(value) {
        this.pivotNumber = value;
    }
    /** Number of iterations in distance scaling: these iterations beautify the layout locally. This heuristic is optional , and the property has to be set to zero for a large graph, because each iteration has O(n*n) time, where n is the number of nodes in the graph */
    get IterationsWithMajorization() {
        return this.iterationsWithMajorization;
    }
    set IterationsWithMajorization(value) {
        this.iterationsWithMajorization = value;
    }
    // X Scaling Factor.
    get ScaleX() {
        return this.scaleX;
    }
    set ScaleX(value) {
        this.scaleX = value;
    }
    // Y Scaling Factor.
    get ScaleY() {
        return this.scaleY;
    }
    set ScaleY(value) {
        /*Assert.assert(!isNaN(value))*/
        this.scaleY = value;
    }
    // Weight matrix exponent.
    get Exponent() {
        return this.exponent;
    }
    set Exponent(value) {
        this.exponent = value;
    }
    // rotation angle
    get RotationAngle() {
        return this.rotationAngle;
    }
    set RotationAngle(value) {
        this.rotationAngle = value % 360;
    }
    // Adjust the scale of the graph if there is not enough whitespace between nodes
    get AdjustScale() {
        return this.adjustScale;
    }
    set AdjustScale(value) {
        this.adjustScale = value;
    }
    GetNumberOfIterationsWithMajorization(nodeCount) {
        if (nodeCount > this.CallIterationsWithMajorizationThreshold) {
            return 0;
        }
        return this.IterationsWithMajorization;
    }
    get CallIterationsWithMajorizationThreshold() {
        return this._callIterationsWithMajorizationThreshold;
    }
    set CallIterationsWithMajorizationThreshold(value) {
        this._callIterationsWithMajorizationThreshold = value;
    }
}
//# sourceMappingURL=mDSLayoutSettings.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/mds/multiDimensionalScaling.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultidimensionalScaling: () => (/* binding */ MultidimensionalScaling)
/* harmony export */ });
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");

class MultidimensionalScaling {
    // Double-centers a matrix of such a way that the center of gravity is zero.
    // After number-centering, each row and each column sums up to zero.
    static DoubleCenter(matrix) {
        const rowMean = new Array(matrix.length).fill(0);
        const colMean = new Array(matrix[0].length).fill(0);
        let mean = 0;
        for (let i = 0; i < matrix.length; i++) {
            for (let j = 0; j < matrix[0].length; j++) {
                rowMean[i] += matrix[i][j];
                colMean[j] += matrix[i][j];
                mean += matrix[i][j];
            }
        }
        for (let i = 0; i < matrix.length; i++)
            rowMean[i] /= matrix.length;
        for (let j = 0; j < matrix[0].length; j++)
            colMean[j] /= matrix[0].length;
        mean /= matrix.length;
        mean /= matrix[0].length;
        for (let i = 0; i < matrix.length; i++) {
            for (let j = 0; j < matrix[0].length; j++) {
                matrix[i][j] -= rowMean[i] + colMean[j] - mean;
            }
        }
    }
    // Squares all entries of a matrix.
    static SquareEntries(matrix) {
        for (let i = 0; i < matrix.length; i++) {
            for (let j = 0; j < matrix[0].length; j++) {
                matrix[i][j] = Math.pow(matrix[i][j], 2);
            }
        }
    }
    // Multiplies a matrix with a scalar factor.
    static Multiply(matrix, factor) {
        for (let i = 0; i < matrix.length; i++) {
            for (let j = 0; j < matrix[0].length; j++) {
                matrix[i][j] *= factor;
            }
        }
    }
    // Multiply a square matrix and a vector.
    // Note that matrix width and vector length
    // have to be equal, otherwise null is returned.
    static MultiplyX(A, x) {
        if (A[0].length !== x.length)
            return null;
        const y = new Array(x.length).fill(0);
        for (let i = 0; i < A.length; i++) {
            for (let j = 0; j < A[0].length; j++) {
                y[i] += A[i][j] * x[j];
            }
        }
        return y;
    }
    // Gives the norm of a vector, that is, its length in
    // vector.length dimensional Euclidean space.
    static Norm(x) {
        let norm = 0;
        for (let i = 0; i < x.length; i++) {
            norm += Math.pow(x[i], 2);
        }
        return Math.sqrt(norm);
    }
    // Normalizes a vector to unit length (1.0) in
    // vector.length dimensional Euclidean space.
    // If the vector is the 0-vector, nothing is done.
    static Normalize(x) {
        const lambda = MultidimensionalScaling.Norm(x);
        if (lambda <= 0)
            return 0;
        for (let i = 0; i < x.length; i++) {
            x[i] /= lambda;
        }
        return lambda;
    }
    // Gives a random unit Euclidean length vector of a given size.
    static RandomUnitLengthVector(n) {
        const result = new Array(n);
        for (let i = 0; i < n; i++) {
            result[i] = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.random)();
        }
        MultidimensionalScaling.Normalize(result);
        return result;
    }
    // Computes the two dominant eigenvectors and eigenvalues of a symmetric
    // square matrix.
    static SpectralDecomposition(A, t) {
        MultidimensionalScaling.SpectralDecompositionIE(A, t, 30, 1e-6);
    }
    // Computes the two dominant eigenvectors and eigenvalues of a symmetric
    // square matrix.
    static SpectralDecompositionIE(A, t, maxIterations, epsilon) {
        const n = A[0].length;
        t.u1 = MultidimensionalScaling.RandomUnitLengthVector(n);
        t.lambda1 = 0;
        t.u2 = MultidimensionalScaling.RandomUnitLengthVector(n);
        t.lambda2 = 0;
        let r = 0;
        const limit = 1.0 - epsilon;
        // iterate until convergence but at most 30 steps
        for (let i = 0; i < maxIterations && r < limit; i++) {
            const x1 = MultidimensionalScaling.MultiplyX(A, t.u1);
            const x2 = MultidimensionalScaling.MultiplyX(A, t.u2);
            t.lambda1 = MultidimensionalScaling.Normalize(x1);
            t.lambda2 = MultidimensionalScaling.Normalize(x2);
            MultidimensionalScaling.MakeOrthogonal(x2, x1);
            MultidimensionalScaling.Normalize(x2);
            // convergence is assumed if the inner product of
            // two consecutive (unit length) iterates is close to 1
            r = Math.min(MultidimensionalScaling.DotProduct(t.u1, x1), MultidimensionalScaling.DotProduct(t.u2, x2));
            t.u1 = x1;
            t.u2 = x2;
        }
    }
    // Gives the inner product of two vectors of the same size.
    static DotProduct(x, y) {
        if (x.length !== y.length)
            return 0;
        let result = 0;
        for (let i = 0; i < x.length; i++) {
            result += x[i] * y[i];
        }
        return result;
    }
    // Orthogonalizes a vector against another vector, so that
    // their scalar product is 0.
    static MakeOrthogonal(x, y) {
        if (x.length !== y.length)
            return;
        const prod = MultidimensionalScaling.DotProduct(x, y) / MultidimensionalScaling.DotProduct(y, y);
        for (let i = 0; i < x.length; i++) {
            x[i] -= prod * y[i];
        }
    }
    // Classical multidimensional scaling.  Computes two-dimensional coordinates
    // for a given distance matrix by computing the two largest eigenvectors
    // and eigenvalues of a matrix assiciated with the distance matrix (called
    // "fitting inner products").
    static ClassicalScaling(d, t) {
        const b = new Array(d.length);
        for (let i = 0; i < d.length; i++) {
            b[i] = d[i].slice();
        }
        MultidimensionalScaling.SquareEntries(b);
        MultidimensionalScaling.DoubleCenter(b);
        MultidimensionalScaling.Multiply(b, -0.5);
        MultidimensionalScaling.SpectralDecomposition(b, t);
        t.lambda1 = Math.sqrt(Math.abs(t.lambda1));
        t.lambda2 = Math.sqrt(Math.abs(t.lambda2));
        for (let i = 0; i < t.u1.length; i++) {
            t.u1[i] *= t.lambda1;
            t.u2[i] *= t.lambda2;
        }
    }
    // Multidimensional scaling.  Computes two-dimensional coordinates
    // for a given distance matrix by fitting the coordinates to these distances
    // iteratively by majorization (called "distance fitting").
    // Only objects that have rows of the distance/weight matrix
    // is subject to iterative relocation.
    static DistanceScalingSubset(d, x, y, w, numberOfIterations) {
        const n = x.length;
        const k = d.length;
        const index = new Array(k);
        for (let i = 0; i < k; i++) {
            for (let j = 0; j < n; j++) {
                if (d[i][j] === 0) {
                    index[i] = j;
                }
            }
        }
        const wSum = new Array(k).fill(0);
        for (let i = 0; i < k; i++) {
            for (let j = 0; j < n; j++) {
                if (index[i] !== j) {
                    wSum[i] += w[i][j];
                }
            }
        }
        for (let c = 0; c < numberOfIterations; c++) {
            for (let i = 0; i < k; i++) {
                let xNew = 0;
                let yNew = 0;
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        let inv = Math.sqrt(Math.pow(x[index[i]] - x[j], 2) + Math.pow(y[index[i]] - y[j], 2));
                        if (inv > 0)
                            inv = 1 / inv;
                        xNew += w[i][j] * (x[j] + d[i][j] * (x[index[i]] - x[j]) * inv);
                        yNew += w[i][j] * (y[j] + d[i][j] * (y[index[i]] - y[j]) * inv);
                    }
                }
                x[index[i]] = xNew / wSum[i];
                y[index[i]] = yNew / wSum[i];
            }
        }
    }
    // Multidimensional scaling.  Computes two-dimensional coordinates
    // for a given distance matrix by fitting the coordinates to these distances
    // iteratively by majorization (called "distance fitting").
    // (McGee, Kamada-Kawai)
    static DistanceScaling(d, x, y, w, iter) {
        const n = x.length;
        const wSum = new Array(n).fill(0);
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j)
                    wSum[i] += w[i][j];
            }
        }
        for (let c = 0; c < iter; c++) {
            for (let i = 0; i < n; i++) {
                let xNew = 0;
                let yNew = 0;
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        let inv = Math.sqrt(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2));
                        if (inv > 0)
                            inv = 1 / inv;
                        xNew += w[i][j] * (x[j] + d[i][j] * (x[i] - x[j]) * inv);
                        yNew += w[i][j] * (y[j] + d[i][j] * (y[i] - y[j]) * inv);
                    }
                }
                x[i] = xNew / wSum[i];
                y[i] = yNew / wSum[i];
            }
        }
    }
    // Convenience method for generating a weight matrix from a distance matrix.
    // Each output entry is the corresponding input entry powered by a constant
    // exponent.
    static ExponentialWeightMatrix(d, exponent) {
        const w = new Array(d.length);
        for (let i = 0; i < d.length; i++) {
            w[i] = new Array(d[i].length).fill(0);
            for (let j = 0; j < d[i].length; j++) {
                if (d[i][j] > 0)
                    w[i][j] = Math.pow(d[i][j], exponent);
            }
        }
        return w;
    }
    // Convenience method for all Euclidean distances within two-dimensional
    // positions.
    static EuclideanDistanceMatrix(x, y) {
        const d = new Array(x.length);
        for (let i = 0; i < x.length; i++) {
            d[i] = new Array(x.length);
            for (let j = 0; j < x.length; j++) {
                d[i][j] = Math.sqrt(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2));
            }
        }
        return d;
    }
    // Approximation to classical multidimensional scaling.
    // Computes two-dimensional coordinates
    // for a given rectangular distance matrix.
    static LandmarkClassicalScaling(d, t, pivotArray) {
        const c = new Array(d.length);
        for (let i = 0; i < d.length; i++) {
            c[i] = new Array(d.length);
            for (let j = 0; j < d.length; j++) {
                c[i][j] = d[i][pivotArray[j]];
            }
        }
        MultidimensionalScaling.SquareEntries(c);
        const mean = new Array(d.length).fill(0);
        for (let i = 0; i < d.length; i++) {
            for (let j = 0; j < d.length; j++) {
                mean[i] += c[i][j];
            }
            mean[i] /= d.length;
        }
        MultidimensionalScaling.DoubleCenter(c);
        MultidimensionalScaling.Multiply(c, -0.5);
        const tt = {
            u1: new Array(),
            u2: new Array(),
            lambda1: 0,
            lambda2: 0,
        };
        MultidimensionalScaling.SpectralDecomposition(c, tt);
        tt.lambda1 = Math.sqrt(Math.abs(tt.lambda1));
        tt.lambda2 = Math.sqrt(Math.abs(tt.lambda2));
        // place non-pivots by weighted barycenter
        t.x = new Array(d[0].length).fill(0);
        t.y = new Array(d[0].length).fill(0);
        for (let i = 0; i < t.x.length; i++) {
            for (let j = 0; j < c.length; j++) {
                const c = (Math.pow(d[j][i], 2) - mean[j]) / 2;
                t.x[i] -= tt.u1[j] * c;
                t.y[i] -= tt.u2[j] * c;
            }
        }
    }
}
//# sourceMappingURL=multiDimensionalScaling.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/mds/pivotDistances.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PivotDistances: () => (/* binding */ PivotDistances)
/* harmony export */ });
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _SingleSourceDistances__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/SingleSourceDistances.js");


// An algorithm for computing the distances between a selected set of nodes and all nodes.
class PivotDistances extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__.Algorithm {
    // A square matrix with shortest path distances.
    get Result() {
        return this.result;
    }
    // Computes distances between a selected set of nodes and all nodes.
    // Pivot nodes are selected with maxmin strategy (first at random, later
    // ones to maximize distances to all previously selected ones).
    constructor(graph, pivotArray, length) {
        super(null); // todo: pass the canceltoken
        this.graph = graph;
        this.pivotArray = pivotArray;
        this.length = length;
    }
    // Executes the algorithm.
    run() {
        this.result = new Array(this.pivotArray.length);
        const nodes = Array.from(this.graph.shallowNodes);
        const min = new Array(this.graph.shallowNodeCount).fill(Number.POSITIVE_INFINITY);
        let pivot = nodes[0];
        this.pivotArray[0] = 0;
        for (let i = 0;; i++) {
            const ssd = new _SingleSourceDistances__WEBPACK_IMPORTED_MODULE_1__.SingleSourceDistances(this.graph, pivot, this.length);
            ssd.run();
            this.Result[i] = ssd.Result;
            if (i + 1 < this.pivotArray.length) {
                // looking for the next pivot
                let argmax = 0;
                for (let j = 0; j < this.Result[i].length; j++) {
                    min[j] = Math.min(min[j], this.Result[i][j]);
                    if (min[j] > min[argmax]) {
                        argmax = j;
                    }
                }
                pivot = nodes[argmax];
                this.pivotArray[i + 1] = argmax;
            }
            else {
                break;
            }
        }
    }
}
//# sourceMappingURL=pivotDistances.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/layout/mds/pivotMDS.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PivotMDS: () => (/* binding */ PivotMDS),
/* harmony export */   layoutGraphWithMds: () => (/* binding */ layoutGraphWithMds)
/* harmony export */ });
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _core_geomGraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");
/* harmony import */ var _driver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/driver.js");
/* harmony import */ var _mDSGraphLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/mDSGraphLayout.js");
/* harmony import */ var _mDSLayoutSettings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/mds/mDSLayoutSettings.js");





function layoutGraphWithMds(geomGraph, cancelToken = null) {
    const mdsSettings = geomGraph.layoutSettings instanceof _mDSLayoutSettings__WEBPACK_IMPORTED_MODULE_4__.MdsLayoutSettings ? geomGraph.layoutSettings : new _mDSLayoutSettings__WEBPACK_IMPORTED_MODULE_4__.MdsLayoutSettings();
    (0,_driver__WEBPACK_IMPORTED_MODULE_2__.enforceLayoutSettings)(geomGraph, mdsSettings);
    (0,_driver__WEBPACK_IMPORTED_MODULE_2__.layoutGeomGraphDetailed)(geomGraph, cancelToken, mdsLayoutRunner, _driver__WEBPACK_IMPORTED_MODULE_2__.routeEdges, _core_geomGraph__WEBPACK_IMPORTED_MODULE_1__.optimalPackingRunner);
}
// Initial layout using PivotMDS method for a graph with subgraphs
class PivotMDS extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__.Algorithm {
    get scaleX() {
        return this.settings.ScaleX;
    }
    set scaleX(value) {
        /*Assert.assert(!isNaN(value))*/
        this.settings.ScaleX = value;
    }
    // scales the final layout by the specified factor on Y
    get scaleY() {
        return this.settings.ScaleY;
    }
    set scaleY(value) {
        /*Assert.assert(!isNaN(value))*/
        this.settings.ScaleY = value;
    }
    // Layout graph by the PivotMds method.  Uses spectral techniques to obtain a layout in
    // O(n^2) time when iterations with majorization are used, otherwise it is more like O(PivotNumber*n).
    constructor(graph, cancelToken, length, settings) {
        super(cancelToken);
        this.graph = graph;
        this.length = length;
        this.settings = settings;
        this.settings.ScaleX = this.settings.ScaleY = 200;
    }
    // Executes the actual algorithm.
    run() {
        // with 0 majorization iterations we just do PivotMDS
        const mdsLayout = new _mDSGraphLayout__WEBPACK_IMPORTED_MODULE_3__.MdsGraphLayout(this.settings, this.graph, this.cancelToken, this.length);
        mdsLayout.run();
    }
}
// returns the map of pairs (new lifted GeomEdge, existing GeomEdge)
function mdsLayoutRunner(geomG, cancelToken) {
    const pmd = new PivotMDS(geomG, cancelToken, () => 1, geomG.layoutSettings);
    pmd.run();
}
//# sourceMappingURL=pivotMDS.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/RBTree/rbColor.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RBColor: () => (/* binding */ RBColor)
/* harmony export */ });
var RBColor;
(function (RBColor) {
    RBColor[RBColor["Red"] = 0] = "Red";
    RBColor[RBColor["Black"] = 1] = "Black";
})(RBColor || (RBColor = {}));
//# sourceMappingURL=rbColor.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/RBTree/rbNode.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RBNode: () => (/* binding */ RBNode)
/* harmony export */ });
class RBNode {
    constructor(color, item, parent, left, right) {
        this.color = color;
        if (item !== undefined)
            this.item = item;
        if (parent !== undefined)
            this.parent = parent;
        if (left !== undefined)
            this.left = left;
        if (right !== undefined)
            this.right = right;
    }
    toString() {
        return this.item.toString();
    }
}
//# sourceMappingURL=rbNode.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/RBTree/rbTree.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RBTree: () => (/* binding */ RBTree)
/* harmony export */ });
/* harmony import */ var _rbNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbNode.js");
/* harmony import */ var _rbColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbColor.js");


class RBTree {
    [Symbol.iterator]() {
        return this.allNodes();
    }
    constructor(comparer) {
        this.comparer = comparer;
        this.count = 0;
        this.root = this.nil = new _rbNode__WEBPACK_IMPORTED_MODULE_0__.RBNode(_rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black);
    }
    clear() {
        this.root = this.nil = new _rbNode__WEBPACK_IMPORTED_MODULE_0__.RBNode(_rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black);
    }
    toNull(y) {
        return y !== this.nil ? y : null;
    }
    isEmpty() {
        return this.root === this.nil;
    }
    getComparer() {
        return this.comparer;
    }
    getRoot() {
        return this.root;
    }
    find(i, x = this.root) {
        let compareResult;
        while (x !== this.nil && (compareResult = this.comparer(i, x.item)) !== 0)
            x = compareResult < 0 ? x.left : x.right;
        return this.toNull(x);
    }
    findFirst(predicate, n = this.root) {
        if (n === this.nil)
            return null;
        let good = null;
        while (n !== this.nil) {
            n = predicate(n.item) ? (good = n).left : n.right;
        }
        return good;
    }
    findLast(predicate, n = this.root) {
        if (n === this.nil)
            return null;
        let good = null;
        while (n !== this.nil)
            n = predicate(n.item) ? (good = n).right : n.left;
        return good;
    }
    treeMinimum(x = this.root) {
        while (x.left !== this.nil)
            x = x.left;
        return this.toNull(x);
    }
    treeMaximum(x = this.root) {
        while (x.right !== this.nil)
            x = x.right;
        return this.toNull(x);
    }
    next(x) {
        if (x.right !== this.nil)
            return this.treeMinimum(x.right);
        let y = x.parent;
        while (y !== this.nil && x === y.right) {
            x = y;
            y = y.parent;
        }
        return this.toNull(y);
    }
    previous(x) {
        if (x.left !== this.nil)
            return this.treeMaximum(x.left);
        let y = x.parent;
        while (y !== this.nil && x === y.left) {
            x = y;
            y = y.parent;
        }
        return this.toNull(y);
    }
    leftRotate(x) {
        const y = x.right;
        x.right = y.left;
        if (y.left !== this.nil)
            y.left.parent = x;
        y.parent = x.parent;
        if (x.parent === this.nil)
            this.root = y;
        else if (x === x.parent.left)
            x.parent.left = y;
        else
            x.parent.right = y;
        y.left = x;
        x.parent = y;
    }
    rightRotate(x) {
        const y = x.left;
        x.left = y.right;
        if (y.right !== this.nil)
            y.right.parent = x;
        y.parent = x.parent;
        if (x.parent === this.nil)
            this.root = y;
        else if (x === x.parent.right)
            x.parent.right = y;
        else
            x.parent.left = y;
        y.right = x;
        x.parent = y;
    }
    deleteFixup(x) {
        while (x !== this.root && x.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black) {
            if (x === x.parent.left) {
                let w = x.parent.right;
                if (w.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red) {
                    w.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    x.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                    this.leftRotate(x.parent);
                    w = x.parent.right;
                }
                if (w.left.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black && w.right.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black) {
                    w.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                    x = x.parent;
                }
                else {
                    if (w.right.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black) {
                        w.left.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                        w.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                        this.rightRotate(w);
                        w = x.parent.right;
                    }
                    w.color = x.parent.color;
                    x.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    w.right.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    this.leftRotate(x.parent);
                    x = this.root;
                }
            }
            else {
                let w = x.parent.left;
                if (w.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red) {
                    w.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    x.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                    this.rightRotate(x.parent);
                    w = x.parent.left;
                }
                if (w.right.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black && w.left.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black) {
                    w.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                    x = x.parent;
                }
                else {
                    if (w.left.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black) {
                        w.right.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                        w.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                        this.leftRotate(w);
                        w = x.parent.left;
                    }
                    w.color = x.parent.color;
                    x.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    w.left.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    this.rightRotate(x.parent);
                    x = this.root;
                }
            }
        }
        x.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
    }
    deleteSubTree(z) {
        //Assert.assert(z !== nil);
        /*Assert.assert(z !== this.nil, 'root of subtree to delete must not be null.')*/
        let y;
        if (z.left === this.nil || z.right === this.nil) {
            /* y has a nil node as a child */
            y = z;
        }
        else {
            /* find tree successor with a nilnode as a child */
            y = z.right;
            while (y.left !== this.nil)
                y = y.left;
        }
        /* x is y's only child */
        const x = y.left !== this.nil ? y.left : y.right;
        x.parent = y.parent;
        if (y.parent === this.nil)
            this.root = x;
        else {
            if (y === y.parent.left)
                y.parent.left = x;
            else
                y.parent.right = x;
        }
        if (y !== z)
            z.item = y.item;
        if (y.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black)
            this.deleteFixup(x);
        return this.toNull(z);
    }
    deleteNodeInternal(x) {
        this.count--;
        this.deleteSubTree(x);
    }
    remove(i) {
        const n = this.find(i);
        if (n != null) {
            this.count--;
            return this.deleteSubTree(n);
        }
        return null;
    }
    insert(v) {
        const x = this.treeInsert(v);
        this.insertPrivate(x);
        return this.toNull(x);
    }
    treeInsert(z) {
        let y = this.nil;
        let x = this.root;
        let compareRes = 0;
        while (x !== this.nil) {
            y = x;
            //#if SHARPKIT //https://code.google.com/p/sharpkit/issues/detail?id=368
            // compareRes = Comparer.Compare(z, x.Item);
            // x = compareRes < 0 ? x.left : x.right;
            compareRes = this.comparer(z, x.item);
            x = compareRes < 0 ? x.left : x.right;
            // #else
            //    x = (compareRes = Comparer.Compare(z, x.Item)) < 0 ? x.left : x.right;
            // #endif
        }
        const nz = new _rbNode__WEBPACK_IMPORTED_MODULE_0__.RBNode(_rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black, z, y, this.nil, this.nil);
        if (y === this.nil)
            this.root = nz;
        else if (compareRes < 0)
            y.left = nz;
        else
            y.right = nz;
        return this.toNull(nz);
    }
    insertPrivate(x) {
        this.count++;
        x.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
        while (x !== this.root && x.parent.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red) {
            if (x.parent === x.parent.parent.left) {
                const y = x.parent.parent.right;
                if (y.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red) {
                    x.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    y.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    x.parent.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                    x = x.parent.parent;
                }
                else {
                    if (x === x.parent.right) {
                        x = x.parent;
                        this.leftRotate(x);
                    }
                    x.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    x.parent.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                    this.rightRotate(x.parent.parent);
                }
            }
            else {
                const y = x.parent.parent.left;
                if (y.color === _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red) {
                    x.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    y.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    x.parent.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                    x = x.parent.parent;
                }
                else {
                    if (x === x.parent.left) {
                        x = x.parent;
                        this.rightRotate(x);
                    }
                    x.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
                    x.parent.parent.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Red;
                    this.leftRotate(x.parent.parent);
                }
            }
        }
        this.root.color = _rbColor__WEBPACK_IMPORTED_MODULE_1__.RBColor.Black;
    }
    *allNodes() {
        if (this.isEmpty())
            return;
        let c = this.treeMinimum();
        while (c != null) {
            yield c.item;
            c = this.next(c);
        }
        return;
    }
    toString() {
        let ret = '{';
        let i = 0;
        for (const node of this.allNodes()) {
            ret += node.toString();
            if (i !== this.count - 1) {
                ret += '\n';
            }
            i++;
        }
        return ret + '}';
    }
}
//# sourceMappingURL=rbTree.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/Interval.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Interval: () => (/* binding */ Interval)
/* harmony export */ });
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");

class Interval {
    // constructor
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    add(n) {
        this.add_d(n);
    }
    add_rect(rectangle) {
        const r = rectangle;
        const ret = this.clone();
        ret.add_d(r.start);
        ret.add_d(r.end);
        return ret;
    }
    clone() {
        return new Interval(this.start, this.end);
    }
    contains_point(n) {
        return this.contains_d(n);
    }
    contains_rect(rect) {
        const r = rect;
        return this.contains_d(r.start) && this.contains_d(r.end);
    }
    intersection_rect(rectangle) {
        const r = rectangle;
        return new Interval(Math.max(this.start, r.start), Math.min(this.end, r.end));
    }
    intersects_rect(rectangle) {
        const r = rectangle;
        return this.intersects(r);
    }
    contains_point_radius(p, radius) {
        return this.contains_d(p - radius) && this.contains_d(p + radius);
    }
    //
    static mkInterval(a, b) {
        const i = new Interval(a.start, a.end);
        i.add_d(b.start);
        i.add_d(b.end);
        return i;
    }
    // expanding the range to hold v
    add_d(v) {
        if (this.start > v) {
            this.start = v;
        }
        if (this.end < v) {
            this.end = v;
        }
    }
    get Start() {
        return this.start;
    }
    set Start(value) {
        this.start = value;
    }
    // the length
    get Length() {
        return this.end - this.start;
    }
    // return true if the value is inside the range
    contains_d(v) {
        return this.start <= v && v <= this.end;
    }
    // bringe v into the range
    GetInRange(v) {
        return v < this.start ? this.start : v > this.end ? this.end : v;
    }
    // returns true if and only if two intervals are intersecting
    intersects(other) {
        if (other.start > this.end + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon) {
            return false;
        }
        return !(other.end < this.start - _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon);
    }
}
//# sourceMappingURL=Interval.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/RTree/hitTestBehavior.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HitTestBehavior: () => (/* binding */ HitTestBehavior)
/* harmony export */ });
//continue or stop the hit tree traversal
var HitTestBehavior;
(function (HitTestBehavior) {
    HitTestBehavior[HitTestBehavior["Continue"] = 0] = "Continue";
    HitTestBehavior[HitTestBehavior["Stop"] = 1] = "Stop";
})(HitTestBehavior || (HitTestBehavior = {}));
//# sourceMappingURL=hitTestBehavior.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryRTree: () => (/* binding */ BinaryRTree),
/* harmony export */   mkRTree: () => (/* binding */ mkRTree)
/* harmony export */ });
/* harmony import */ var _rectangleNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");

// A search tree for rapid lookup of T objects keyed by rectangles inside a given rectangular region
// It is very similar to "R-TREES. A DYNAMIC INDEX STRUCTURE FOR SPATIAL SEARCHING" by Antonin Guttman
// Create the query tree for a given enumerable of T keyed by Rectangles
function mkRTree(rectsAndData) {
    return new BinaryRTree((0,_rectangleNode__WEBPACK_IMPORTED_MODULE_0__.CreateRectNodeOnArrayOfRectNodes)(rectsAndData.map(([k, v]) => (0,_rectangleNode__WEBPACK_IMPORTED_MODULE_0__.mkRectangleNode)(v, k))));
}
function TransferFromSibling(parent, sibling) {
    parent.UserData = sibling.UserData;
    parent.Left = sibling.Left;
    parent.Right = sibling.Right;
    parent.Count--;
    parent.irect = sibling.irect;
}
function UpdateParent(parent) {
    for (let node = parent.Parent; node != null; node = node.Parent) {
        node.Count--;
        node.irect = node.Left.irect.add_rect(node.Right.irect);
    }
}
function RebuildUnderNodeWithoutLeaf(nodeForRebuild, leaf) {
    /*Assert.assert(leaf.IsLeaf)*/
    /*Assert.assert(!nodeForRebuild.IsLeaf)*/
    const t = new Array();
    for (const n of nodeForRebuild.GetAllLeafNodes()) {
        if (n !== leaf) {
            t.push(n);
        }
    }
    const newNode = (0,_rectangleNode__WEBPACK_IMPORTED_MODULE_0__.CreateRectNodeOnArrayOfRectNodes)(t);
    nodeForRebuild.Count = newNode.Count;
    nodeForRebuild.Left = newNode.Left;
    nodeForRebuild.Right = newNode.Right;
    nodeForRebuild.irect = newNode.Left.irect.add_rect(newNode.Right.irect);
}
function FindTopUnbalancedNode(node) {
    for (let parent = node.Parent; parent != null; parent = parent.Parent)
        if (!Balanced(parent))
            return parent;
    return null;
}
function Balanced(rectangleNode) {
    return 2 * rectangleNode.Left.Count >= rectangleNode.Right.Count && 2 * rectangleNode.Right.Count >= rectangleNode.Left.Count;
}
function NumberOfIntersectedIsLessThanBoundOnNode(node, rect, t, conditionFunc) {
    /*Assert.assert(t.bound > 0)*/
    if (!node.irect.intersects_rect(rect))
        return true;
    if (node.IsLeaf) {
        if (conditionFunc(node.UserData))
            return --t.bound !== 0;
        return true;
    }
    return (NumberOfIntersectedIsLessThanBoundOnNode(node.Left, rect, t, conditionFunc) &&
        NumberOfIntersectedIsLessThanBoundOnNode(node.Right, rect, t, conditionFunc));
}
class BinaryRTree {
    // Removes everything from the tree
    // <
    clear() {
        this.RootNode = null;
    }
    NumberOfIntersectedIsLessThanBound(rect, bound, conditionFunc) {
        return NumberOfIntersectedIsLessThanBoundOnNode(this._rootNode, rect, { bound: bound }, conditionFunc);
    }
    get RootNode() {
        return this._rootNode;
    }
    set RootNode(value) {
        this._rootNode = value;
    }
    // Create a query tree for a given root node
    constructor(rootNode) {
        this._rootNode = rootNode;
    }
    *GetAllLeaves() {
        if (this._rootNode != null && this.Count > 0) {
            for (const l of this._rootNode.GetAllLeaves())
                yield l;
        }
    }
    // The number of data elements of the tree (number of leaf nodes)
    get Count() {
        return this._rootNode == null ? 0 : this._rootNode.Count;
    }
    Add(key, value) {
        this.AddNode((0,_rectangleNode__WEBPACK_IMPORTED_MODULE_0__.mkRectangleNode)(value, key));
    }
    AddNode(node) {
        if (this._rootNode == null)
            this._rootNode = node;
        else if (this.Count <= 2)
            this._rootNode = (0,_rectangleNode__WEBPACK_IMPORTED_MODULE_0__.CreateRectNodeOnArrayOfRectNodes)(Array.from(this._rootNode.GetAllLeafNodes()).concat([node]));
        else
            this.AddNodeToTreeRecursive(node, this._rootNode);
    }
    Rebuild() {
        this._rootNode = (0,_rectangleNode__WEBPACK_IMPORTED_MODULE_0__.CreateRectNodeOnArrayOfRectNodes)(Array.from(this._rootNode.GetAllLeafNodes()));
    }
    AddNodeToTreeRecursive(newNode, existingNode) {
        if (existingNode.IsLeaf) {
            existingNode.Left = (0,_rectangleNode__WEBPACK_IMPORTED_MODULE_0__.mkRectangleNode)(existingNode.UserData, existingNode.irect);
            existingNode.Right = newNode;
            existingNode.Count = 2;
        }
        else {
            existingNode.Count++;
            let leftBox;
            let rightBox;
            if (2 * existingNode.Left.Count < existingNode.Right.Count) {
                // keep the balance
                this.AddNodeToTreeRecursive(newNode, existingNode.Left);
                existingNode.Left.irect = existingNode.Left.irect.add_rect(newNode.irect);
            }
            else if (2 * existingNode.Right.Count < existingNode.Left.Count) {
                // keep the balance
                this.AddNodeToTreeRecursive(newNode, existingNode.Right);
                existingNode.Right.irect = existingNode.Right.irect.add_rect(newNode.irect);
            }
            else {
                // decide basing on the boxes
                leftBox = existingNode.Left.irect.add_rect(newNode.irect);
                const delLeft = leftBox.area - existingNode.Left.irect.area;
                rightBox = existingNode.Right.irect.add_rect(newNode.irect);
                const delRight = rightBox.area - existingNode.Right.irect.area;
                if (delLeft < delRight) {
                    this.AddNodeToTreeRecursive(newNode, existingNode.Left);
                    existingNode.Left.irect = leftBox;
                }
                else if (delLeft > delRight) {
                    this.AddNodeToTreeRecursive(newNode, existingNode.Right);
                    existingNode.Right.irect = rightBox;
                }
                else {
                    // the deltas are the same; add to the smallest
                    if (leftBox.area < rightBox.area) {
                        this.AddNodeToTreeRecursive(newNode, existingNode.Left);
                        existingNode.Left.irect = leftBox;
                    }
                    else {
                        this.AddNodeToTreeRecursive(newNode, existingNode.Right);
                        existingNode.Right.irect = rightBox;
                    }
                }
            }
        }
        existingNode.irect = existingNode.Left.irect.add_rect(existingNode.Right.irect);
    }
    GetAllIntersecting(queryRegion) {
        return this._rootNode == null || this.Count === 0 ? [] : Array.from(this._rootNode.GetNodeItemsIntersectingRectangle(queryRegion));
    }
    OneIntersecting(queryRegion) {
        if (this._rootNode == null || this.Count === 0) {
            return;
        }
        const ret = this._rootNode.FirstIntersectedNode(queryRegion);
        if (ret == null) {
            return;
        }
        return { intersectedLeaf: ret.UserData };
    }
    // Get all leaf nodes with rectangles intersecting the specified rectangular region
    GetAllLeavesIntersectingRectangle(queryRegion) {
        return this._rootNode == null || this.Count === 0 ? [] : this._rootNode.GetLeafRectangleNodesIntersectingRectangle(queryRegion);
    }
    // Does minimal work to determine if any objects of the tree intersect with the query region
    IsIntersecting(queryRegion) {
        if (this._rootNode == null || this.Count === 0)
            return false;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const _ of this._rootNode.GetNodeItemsIntersectingRectangle(queryRegion)) {
            return true;
        }
        return false;
    }
    // return true iff there is a node with the rectangle and UserData that equals to the parameter "userData"
    Contains(rectangle, userData) {
        if (this._rootNode == null) {
            return false;
        }
        for (const node of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(rectangle)) {
            if (node.UserData === userData)
                return true;
        }
        return false;
    }
    Remove(rectangle, userData) {
        if (this._rootNode == null) {
            return;
        }
        let ret = undefined;
        for (const node of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(rectangle)) {
            if (node.UserData === userData) {
                ret = node;
            }
        }
        if (ret == null) {
            return;
        }
        if (this.RootNode.Count === 1) {
            this.RootNode = null;
        }
        else {
            this.RemoveLeaf(ret);
        }
        return ret.UserData;
    }
    RemoveLeaf(leaf) {
        /*Assert.assert(leaf.IsLeaf)*/
        const unbalancedNode = FindTopUnbalancedNode(leaf);
        if (unbalancedNode != null) {
            RebuildUnderNodeWithoutLeaf(unbalancedNode, leaf);
            UpdateParent(unbalancedNode);
        }
        else {
            //replace the parent with the sibling and update bounding boxes and counts
            const parent = leaf.Parent;
            if (parent == null) {
                /*Assert.assert(this._rootNode === leaf)*/
                this._rootNode = new _rectangleNode__WEBPACK_IMPORTED_MODULE_0__.RectangleNode();
            }
            else {
                TransferFromSibling(parent, leaf.IsLeftChild ? parent.Right : parent.Left);
                UpdateParent(parent);
            }
        }
        //  Assert.assert(TreeIsCorrect(RootNode));
    }
    UnbalancedNode(node) {
        for (let parent = node.Parent; parent != null; parent = parent.Parent) {
            if (!Balanced(parent)) {
                return parent;
            }
        }
        return null;
    }
}
//# sourceMappingURL=rTree.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateRectNodeOnArrayOfRectNodes: () => (/* binding */ CreateRectNodeOnArrayOfRectNodes),
/* harmony export */   RectangleNode: () => (/* binding */ RectangleNode),
/* harmony export */   createRectangleNodeOnData: () => (/* binding */ createRectangleNodeOnData),
/* harmony export */   mkRectangleNode: () => (/* binding */ mkRectangleNode),
/* harmony export */   mkRectangleNodeWithCount: () => (/* binding */ mkRectangleNodeWithCount)
/* harmony export */ });
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/hitTestBehavior.js");


function DivideNodes(nodes, seed0, seed1, gr0, gr1, t) {
    const groupSplitThreshold = 2;
    for (let i = 0; i < nodes.length; i++) {
        if (i === seed0 || i === seed1)
            continue;
        // ReSharper disable InconsistentNaming
        const box0_ = t.box0.add_rect(nodes[i].irect);
        const delta0 = box0_.area - t.box0.area;
        const box1_ = t.box1.add_rect(nodes[i].irect);
        const delta1 = box1_.area - t.box1.area;
        // ReSharper restore InconsistentNaming
        //keep the tree roughly balanced
        if (gr0.length * groupSplitThreshold < gr1.length) {
            gr0.push(nodes[i]);
            t.box0 = box0_;
        }
        else if (gr1.length * groupSplitThreshold < gr0.length) {
            gr1.push(nodes[i]);
            t.box1 = box1_;
        }
        else if (delta0 < delta1) {
            gr0.push(nodes[i]);
            t.box0 = box0_;
        }
        else if (delta1 < delta0) {
            gr1.push(nodes[i]);
            t.box1 = box1_;
        }
        else if (t.box0.area < t.box1.area) {
            gr0.push(nodes[i]);
            t.box0 = box0_;
        }
        else {
            gr1.push(nodes[i]);
            t.box1 = box1_;
        }
    }
}
/**  calculates an RTree with the leaves in the given nodes */
function CreateRectNodeOnArrayOfRectNodes(nodes) {
    if (nodes.length === 0)
        return null;
    if (nodes.length === 1)
        return nodes[0];
    //Finding the seeds
    const t = { b0: nodes[0].irect, seed0: 1 };
    const seed1 = ChooseSeeds(nodes, t);
    //We have two seeds at hand. Build two groups.
    const gr0 = [];
    const gr1 = [];
    gr0.push(nodes[t.seed0]);
    gr1.push(nodes[seed1]);
    //divide nodes on two groups
    const p = { box0: nodes[t.seed0].irect, box1: nodes[seed1].irect };
    DivideNodes(nodes, t.seed0, seed1, gr0, gr1, p);
    const ret = mkRectangleNodeWithCount(nodes.length);
    ret.irect = p.box0.add_rect(p.box1);
    ret.Left = CreateRectNodeOnArrayOfRectNodes(gr0);
    ret.Right = CreateRectNodeOnArrayOfRectNodes(gr1);
    return ret;
}
function areaoftwo(a, b) {
    return a.add_rect(b).area;
}
function ChooseSeeds(nodes, t) {
    let area = areaoftwo(t.b0, nodes[t.seed0].irect);
    for (let i = 2; i < nodes.length; i++) {
        const area0 = areaoftwo(t.b0, nodes[i].irect);
        if (area0 > area) {
            t.seed0 = i;
            area = area0;
        }
    }
    //Got the first seed seed0
    //Now looking for a seed for the second group
    let seed1;
    //init seed1
    for (let i = 0; i < nodes.length; i++) {
        if (i !== t.seed0) {
            seed1 = i;
            break;
        }
    }
    area = nodes[t.seed0].irect.add_rect(nodes[seed1].irect).area;
    //Now try to improve the second seed
    for (let i = 0; i < nodes.length; i++) {
        if (i === t.seed0)
            continue;
        const area1 = nodes[t.seed0].irect.add_rect(nodes[i].irect).area;
        if (area1 > area) {
            seed1 = i;
            area = area1;
        }
    }
    return seed1;
}
//calculates a tree based on the given nodes
function createRectangleNodeOnData(dataEnumeration, rectangleDelegate) {
    if (dataEnumeration == null || rectangleDelegate == null)
        return null;
    const nodeList = Array.from(dataEnumeration).map((d) => mkRectangleNode(d, rectangleDelegate(d)));
    return CreateRectNodeOnArrayOfRectNodes(nodeList);
}
function mkRectangleNodeWithCount(count) {
    const r = new RectangleNode();
    r.Count = count;
    return r;
}
function mkRectangleNode(data, rect) {
    const r = new RectangleNode();
    r.UserData = data;
    r.irect = rect;
    r.Count = 1;
    return r;
}
// it should be a static function of a class but declaring it such creates an error
function VisitTreeStatic(rectangleNode, hitTest, hitRectangle) {
    if (rectangleNode.irect.intersects_rect(hitRectangle)) {
        if (hitTest(rectangleNode.UserData) === _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Continue) {
            if (rectangleNode.Left != null) {
                // If rectangleNode.Left is not null, rectangleNode.Right won't be either.
                if (VisitTreeStatic(rectangleNode.Left, hitTest, hitRectangle) === _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Continue &&
                    VisitTreeStatic(rectangleNode.Right, hitTest, hitRectangle) === _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Continue) {
                    return _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Continue;
                }
                return _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Stop;
            }
            return _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Continue;
        }
        return _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Stop;
    }
    return _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Continue;
}
// Represents a node containing a box and some user data.
// Is used of curve intersections routines.
class RectangleNode {
    toString() {
        return this.IsLeaf ? this.Count.toString() + ' ' + this.UserData : this.Count.toString();
    }
    // false if it is an internal node and true if it is a leaf
    get IsLeaf() {
        return this.left == null; /*&& right==null*/
    } //if left is a null then right is also a null
    //
    get Left() {
        return this.left;
    }
    set Left(value) {
        if (this.left != null && this.left.Parent === this)
            this.left.Parent = null;
        this.left = value;
        if (this.left != null)
            this.left.Parent = this;
    }
    get Right() {
        return this.right;
    }
    set Right(value) {
        if (this.right != null && this.right.Parent === this)
            this.right.Parent = null;
        this.right = value;
        if (this.right != null)
            this.right.Parent = this;
    }
    get IsLeftChild() {
        /*Assert.assert(this.Parent != null)*/
        return this === this.Parent.Left;
    }
    // brings the first leaf which rectangle was intersected
    FirstIntersectedNode(r) {
        var _a;
        if (r.intersects_rect(this.irect)) {
            if (this.IsLeaf)
                return this;
            return (_a = this.Left.FirstIntersectedNode(r)) !== null && _a !== void 0 ? _a : this.Right.FirstIntersectedNode(r);
        }
        return null;
    }
    FirstHitNodeWithPredicate(point, hitTest) {
        var _a;
        if (!this.irect.contains_point(point))
            return null;
        if (this.IsLeaf) {
            return hitTest(point, this.UserData) === _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Stop ? this : null;
        }
        return (_a = this.Left.FirstHitNodeWithPredicate(point, hitTest)) !== null && _a !== void 0 ? _a : this.Right.FirstHitNodeWithPredicate(point, hitTest);
    }
    FirstHitByRectWithPredicate(rect, hitTest) {
        var _a;
        if (!this.irect.intersects_rect(rect))
            return null;
        if (this.IsLeaf) {
            return hitTest(this.UserData) === _hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Stop ? this : null;
        }
        return (_a = this.Left.FirstHitByRectWithPredicate(rect, hitTest)) !== null && _a !== void 0 ? _a : this.Right.FirstHitByRectWithPredicate(rect, hitTest);
    }
    // brings the first leaf which rectangle was hit and the delegate is happy with the object
    FirstHitNode(point) {
        var _a;
        if (this.irect.contains_point(point)) {
            if (this.IsLeaf)
                return this;
            return (_a = this.Left.FirstHitNode(point)) !== null && _a !== void 0 ? _a : this.Right.FirstHitNode(point);
        }
        return null;
    }
    // returns all leaf nodes for which the rectangle was hit and the delegate is happy with the object
    *AllHitItems(rectanglePar, hitTestAccept = null) {
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        stack.push(this);
        while (stack.size > 0) {
            const node = stack.pop();
            if (node.irect.intersects_rect(rectanglePar)) {
                if (node.IsLeaf) {
                    if (hitTestAccept == null || hitTestAccept(node.UserData)) {
                        yield node.UserData;
                    }
                }
                else {
                    stack.push(node.left);
                    stack.push(node.right);
                }
            }
        }
    }
    // returns all items for which the rectangle contains the point
    *AllHitItems_(point) {
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        stack.push(this);
        while (stack.size > 0) {
            const node = stack.pop();
            if (node.irect.contains_point(point)) {
                if (node.IsLeaf)
                    yield node.UserData;
                else {
                    stack.push(node.left);
                    stack.push(node.right);
                }
            }
        }
    }
    // Returns all leaves whose rectangles intersect hitRectangle (or all leaves before hitTest returns false).
    VisitTree(hitTest, hitRectangle) {
        VisitTreeStatic(this, hitTest, hitRectangle);
    }
    //
    Clone() {
        const ret = mkRectangleNodeWithCount(this.Count);
        ret.UserData = this.UserData;
        ret.irect = this.irect;
        if (this.Left != null)
            ret.Left = this.Left.Clone();
        if (this.Right != null)
            ret.Right = this.Right.Clone();
        return ret;
    }
    // yields all leaves which rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.
    *GetNodeItemsIntersectingRectangle(rectanglePar) {
        for (const n of this.GetLeafRectangleNodesIntersectingRectangle(rectanglePar))
            yield n.UserData;
    }
    // yields all leaves whose rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.
    *GetLeafRectangleNodesIntersectingRectangle(rectanglePar) {
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        stack.push(this);
        while (stack.size > 0) {
            const node = stack.pop();
            if (node.irect.intersects_rect(rectanglePar)) {
                if (node.IsLeaf) {
                    yield node;
                }
                else {
                    stack.push(node.left);
                    stack.push(node.right);
                }
            }
        }
    }
    // Walk the tree and return the data from all leaves
    *GetAllLeaves() {
        for (const n of this.GetAllLeafNodes())
            yield n.UserData;
    }
    *GetAllLeafNodes() {
        //return this.EnumRectangleNodes(true /*leafOnly*/)
        for (const p of this.EnumRectangleNodes(true))
            yield p;
    }
    *EnumRectangleNodes(leafOnly) {
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        stack.push(this);
        while (stack.size > 0) {
            const node = stack.pop();
            if (node.IsLeaf || !leafOnly) {
                yield node;
            }
            if (!node.IsLeaf) {
                stack.push(node.left);
                stack.push(node.right);
            }
        }
    }
    //
    // Walk the tree from node down and apply visitor to all nodes
    TraverseHierarchy(node, visitor) {
        visitor(node);
        if (node.Left != null)
            this.TraverseHierarchy(node.Left, visitor);
        if (node.Right != null)
            this.TraverseHierarchy(node.Right, visitor);
    }
}
//# sourceMappingURL=rectangleNode.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CrossRectangleNodes: () => (/* binding */ CrossRectangleNodes),
/* harmony export */   CrossRectangleNodesSameType: () => (/* binding */ CrossRectangleNodesSameType),
/* harmony export */   FindIntersectionWithProperty: () => (/* binding */ FindIntersectionWithProperty)
/* harmony export */ });
function CrossRectangleNodes(a, b, action) {
    if (!a.irect.intersects_rect(b.irect))
        return;
    if (a.Left == null) {
        //a is a leat
        if (b.Left == null)
            //b is a leaf
            action(a.UserData, b.UserData);
        else {
            CrossRectangleNodes(a, b.Left, action);
            CrossRectangleNodes(a, b.Right, action);
        }
    }
    else {
        //a is not a leaf
        if (b.Left != null) {
            CrossRectangleNodes(a.Left, b.Left, action);
            CrossRectangleNodes(a.Left, b.Right, action);
            CrossRectangleNodes(a.Right, b.Left, action);
            CrossRectangleNodes(a.Right, b.Right, action);
        }
        else {
            // b is a leaf
            CrossRectangleNodes(a.Left, b, action);
            CrossRectangleNodes(a.Right, b, action);
        }
    }
}
function CrossRectangleNodesSameType(a, b, action) {
    if (!a.irect.intersects_rect(b.irect))
        return;
    if (a === b)
        HandleEquality(a, action);
    else if (a.Left == null) {
        if (b.Left == null) {
            action(a.UserData, b.UserData);
        }
        else {
            CrossRectangleNodesSameType(a, b.Left, action);
            CrossRectangleNodesSameType(a, b.Right, action);
        }
    }
    else {
        if (b.Left != null) {
            CrossRectangleNodesSameType(a.Left, b.Left, action);
            CrossRectangleNodesSameType(a.Left, b.Right, action);
            CrossRectangleNodesSameType(a.Right, b.Left, action);
            CrossRectangleNodesSameType(a.Right, b.Right, action);
        }
        else {
            CrossRectangleNodesSameType(a.Left, b, action);
            CrossRectangleNodesSameType(a.Right, b, action);
        }
    }
}
// returns true if "property" holds for some pair
function FindIntersectionWithProperty(a, b, property) {
    if (!a.irect.intersects_rect(b.irect))
        return false;
    if (a === b)
        return HandleEqualityCheck(a, property);
    if (a.Left == null) {
        if (b.Left == null)
            return property(a.UserData, b.UserData);
        if (FindIntersectionWithProperty(a, b.Left, property))
            return true;
        if (FindIntersectionWithProperty(a, b.Right, property))
            return true;
    }
    else {
        if (b.Left != null) {
            if (FindIntersectionWithProperty(a.Left, b.Left, property))
                return true;
            if (FindIntersectionWithProperty(a.Left, b.Right, property))
                return true;
            if (FindIntersectionWithProperty(a.Right, b.Left, property))
                return true;
            if (FindIntersectionWithProperty(a.Right, b.Right, property))
                return true;
        }
        else {
            if (FindIntersectionWithProperty(a.Left, b, property))
                return true;
            if (FindIntersectionWithProperty(a.Right, b, property))
                return true;
        }
    }
    return false;
}
function HandleEqualityCheck(a, func) {
    if (a.Left == null)
        return false; //we don't do anything for two equal leafs
    return (FindIntersectionWithProperty(a.Left, a.Left, func) ||
        FindIntersectionWithProperty(a.Left, a.Right, func) ||
        FindIntersectionWithProperty(a.Right, a.Right, func));
}
// we need to avoid calling action twice for the same pair
function HandleEquality(a, action) {
    if (a.Left == null)
        return; //we don't do anything for two equal leafs
    CrossRectangleNodesSameType(a.Left, a.Left, action);
    CrossRectangleNodesSameType(a.Left, a.Right, action);
    CrossRectangleNodesSameType(a.Right, a.Right, action);
}
//# sourceMappingURL=rectangleNodeUtils.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/bezierSeg.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BezierSeg: () => (/* binding */ BezierSeg)
/* harmony export */ });
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _parallelogramNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogramNode.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _closestPointOnCurve__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/closestPointOnCurve.js");





/** the standard implementation of a cubic bezier curve */
class BezierSeg {
    toJSON() {
        return { b: this.b.map((p) => p.toJSON()) };
    }
    static fromJSON(bData) {
        return BezierSeg.mkBezier(bData.b.map(_point__WEBPACK_IMPORTED_MODULE_2__.Point.fromJSON));
    }
    leftDerivative(t) {
        return this.derivative(t);
    }
    rightDerivative(t) {
        return this.derivative(t);
    }
    /** get a control point */
    B(controlPointIndex) {
        return this.b[controlPointIndex];
    }
    /** A tree of ParallelogramNodes covering the curve.
     This tree is used in curve intersections routines. */
    pNodeOverICurve() {
        if (this.pBoxNode != null)
            return this.pBoxNode;
        return (this.pBoxNode = _parallelogramNode__WEBPACK_IMPORTED_MODULE_1__.ParallelogramNode.createParallelogramNodeForCurveSegDefaultOffset(this));
    }
    /** Returns the point on the curve corresponding to parameter t */
    value(t) {
        const t2 = t * t;
        const t3 = t2 * t;
        //   return l * t3 + e * t2 + c * t + b[0];
        return this.l.mul(t3).add(this.e.mul(t2).add(this.c.mul(t)).add(this.b[0]));
    }
    static adjustParamTo01(u) {
        if (u > 1)
            return 1;
        else if (u < 0)
            return 0;
        return u;
    }
    /**throw away the segments [0,u] and [v,1] of the segment,
    Returns the trimmed curve */
    trim(u, v) {
        u = BezierSeg.adjustParamTo01(u);
        v = BezierSeg.adjustParamTo01(v);
        if (u > v)
            return this.trim(v, u);
        if (u > 1.0 - _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance)
            return new BezierSeg(this.b[3], this.b[3], this.b[3], this.b[3]);
        const b1 = new Array(3);
        const b2 = new Array(2);
        const pv = this.casteljau(u, b1, b2);
        //this will be the trim to [v,1]
        const trimByU = new BezierSeg(pv, b2[1], b1[2], this.b[3]);
        //1-v is not zero here because we have handled already the case v=1
        const pu = trimByU.casteljau((v - u) / (1.0 - u), b1, b2);
        return new BezierSeg(trimByU.b[0], b1[0], b2[0], pu);
    }
    // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
    trimWithWrap(start, end) {
        throw 'NotImplementedException()';
        return null;
    }
    //array for casteljau method
    casteljau(t, b1, b2) {
        const f = 1.0 - t;
        for (let i = 0; i < 3; i++)
            b1[i] = _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, this.b[i], t, this.b[i + 1]);
        for (let i = 0; i < 2; i++)
            b2[i] = _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, b1[i], t, b1[i + 1]);
        return _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, b2[0], t, b2[1]);
    }
    // first derivative
    derivative(t) {
        return this.l
            .mul(3 * t * t)
            .add(this.e.mul(2 * t))
            .add(this.c);
    }
    // second derivative
    secondDerivative(t) {
        return _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(6 * t, this.l, 2, this.e);
    }
    // third derivative
    thirdDerivative(t) {
        return this.l.mul(6);
    }
    // the constructor
    constructor(b0, b1, b2, b3) {
        /** control points */
        this.b = new Array(4);
        this.parStart = 0;
        this.parEnd = 1;
        this.b[0] = b0;
        this.b[1] = b1;
        this.b[2] = b2;
        this.b[3] = b3;
        this.c = this.b[1].sub(this.b[0]).mul(3);
        this.e = this.b[2].sub(this.b[1]).mul(3).sub(this.c);
        this.l = this.b[3].sub(this.b[0]).sub(this.c).sub(this.e);
    }
    get start() {
        return this.b[0];
    }
    get end() {
        return this.b[3];
    }
    // this[Reverse[t]]=this[ParEnd+ParStart-t]
    reverse() {
        return new BezierSeg(this.b[3], this.b[2], this.b[1], this.b[0]);
    }
    // mutable! changes "this"
    // Returns the curved moved by delta
    translate(delta) {
        this.b[0] = this.b[0].add(delta);
        this.b[1] = this.b[1].add(delta);
        this.b[2] = this.b[2].add(delta);
        this.b[3] = this.b[3].add(delta);
        this.c = this.b[1].sub(this.b[0]).mul(3);
        this.e = this.b[2].sub(this.b[1]).mul(3).sub(this.c);
        this.l = this.b[3].sub(this.b[0]).sub(this.c).sub(this.e);
        if (this.bbox)
            this.bbox = _rectangle__WEBPACK_IMPORTED_MODULE_0__.Rectangle.translate(this.bbox, delta);
        this.pBoxNode = null;
    }
    // Returns the curved scaled by x and y
    scaleFromOrigin(xScale, yScale) {
        return new BezierSeg(this.b[0].scale(xScale, yScale), this.b[1].scale(xScale, yScale), this.b[2].scale(xScale, yScale), this.b[3].scale(xScale, yScale));
    }
    // Offsets the curve in the direction of dir
    offsetCurve(offset, dir) {
        return null;
    }
    // return length of the curve segment [start,end]
    lengthPartial(start, end) {
        return this.trim(start, end).length;
    }
    // Get the length of the curve
    get length() {
        return BezierSeg.lengthOnControlPolygon(this.b[0], this.b[1], this.b[2], this.b[3]);
    }
    //
    static lengthOnControlPolygon(b0, b1, b2, b3) {
        const innerCordLength = b3.sub(b0).length;
        const controlPointPolygonLength = b1.sub(b0).length + b2.sub(b1).length + b3.sub(b2).length;
        if (controlPointPolygonLength - innerCordLength > _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.lineSegmentThreshold) {
            const mb0 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.middle(b0, b1);
            const mb1 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.middle(b1, b2);
            const mb2 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.middle(b2, b3);
            const mmb0 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.middle(mb0, mb1);
            const mmb1 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.middle(mb2, mb1);
            const mmmb0 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.middle(mmb0, mmb1);
            //               LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve(100, 2, "blue", new BezierSeg(b0, b1, b2, b3)), new DebugCurve(100, 1, "red", new BezierSeg(b0, mb0, mmb0, mmmb0)), new DebugCurve(100, 1, "green", new BezierSeg(mmmb0, mmb1, mb2, b3)));
            return BezierSeg.lengthOnControlPolygon(b0, mb0, mmb0, mmmb0) + BezierSeg.lengthOnControlPolygon(mmmb0, mmb1, mb2, b3);
        }
        return (controlPointPolygonLength + innerCordLength) / 2;
    }
    // the segment bounding box
    get boundingBox() {
        if (this.bbox) {
            return this.bbox;
        }
        return (this.bbox = _rectangle__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkOnPoints(this.b));
    }
    // Return the transformed curve
    transform(transformation) {
        return new BezierSeg(transformation.multiplyPoint(this.b[0]), transformation.multiplyPoint(this.b[1]), transformation.multiplyPoint(this.b[2]), transformation.multiplyPoint(this.b[3]));
    }
    // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
    // and t belongs to the closed segment [low,high]
    closestParameterWithinBounds(targetPoint, low, high) {
        /*Assert.assert(high <= 1 && low >= 0)*/
        /*Assert.assert(low <= high)*/
        const t = (high - low) / 8;
        let closest = 0;
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < 9; i++) {
            const p = targetPoint.sub(this.value(i * t + low));
            const d = p.dot(p);
            if (d < minDist) {
                minDist = d;
                closest = i * t + low;
            }
        }
        return _closestPointOnCurve__WEBPACK_IMPORTED_MODULE_4__.ClosestPointOnCurve.closestPoint(this, targetPoint, closest, low, high);
    }
    // clones the curve.
    clone() {
        return new BezierSeg(this.b[0], this.b[1], this.b[2], this.b[3]);
    }
    static mkBezier(b) {
        return new BezierSeg(b[0], b[1], b[2], b[3]);
    }
    // the signed curvature of the segment at t
    curvature(t) {
        /*Assert.assert(t >= this.parStart && t <= this.parEnd)*/
        const den = this.G(t);
        /*Assert.assert(Math.abs(den) > 0.00001)*/
        return this.F(t) / den;
    }
    F(t) {
        return this.Xp(t) * this.Ypp(t) - this.Yp(t) * this.Xpp(t);
    }
    // G(t) is the denomenator of the curvature
    G(t) {
        const xp = this.Xp(t);
        const yp = this.Yp(t);
        const den = xp * xp + yp * yp;
        return Math.sqrt(den * den * den);
    }
    // the first derivative of x-coord
    Xp(t) {
        return 3 * this.l.x * t * t + 2 * this.e.x * t + this.c.x;
    }
    // the second derivativ of y-coordinate
    Ypp(t) {
        return 6 * this.l.y * t + 2 * this.e.y;
    }
    // the first derivative of y-coord
    Yp(t) {
        return 3 * this.l.y * t * t + 2 * this.e.y * t + this.c.y;
    }
    // the seconde derivative of x coord
    Xpp(t) {
        return 6 * this.l.x * t + 2 * this.e.x;
    }
    // the third derivative of x coordinate
    Xppp(t) {
        return 6 * this.l.x;
    }
    // the third derivative of y coordinate
    Yppp(t) {
        return 6 * this.l.y;
    }
    // the derivative of the curvature at t
    curvatureDerivative(t) {
        // we need to calculate the derivative of f/g where f=xp* ypp-yp*xpp and g=(xp*xp+yp*yp)^(3/2)
        const h = this.G(t);
        return (this.Fp(t) * h - this.Gp(t) * this.F(t)) / (h * h);
    }
    Fp(t) {
        return this.Xp(t) * this.Yppp(t) - this.Yp(t) * this.Xppp(t);
    }
    Fpp(t) {
        return (this.Xpp(t) * this.Yppp(t) - // + Xp(t) * Ypppp(t)=0
            this.Ypp(t) * this.Xppp(t)); //- Yp(t) * Xpppp(t)=0
    }
    // returns a parameter t such that the distance between curve[t] and a is minimal
    closestParameter(targetPoint) {
        const t = 1.0 / 8;
        let closest = 0;
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < 9; i++) {
            const p = targetPoint.sub(this.value(i * t));
            const d = p.dot(p);
            if (d < minDist) {
                minDist = d;
                closest = i * t;
            }
        }
        return _closestPointOnCurve__WEBPACK_IMPORTED_MODULE_4__.ClosestPointOnCurve.closestPoint(this, targetPoint, closest, 0, 1);
    }
    //
    curvatureSecondDerivative(t) {
        const g = this.G(t);
        return (this.Qp(t) * g - 2 * this.Q(t) * this.Gp(t)) / (g * g * g);
    }
    Q(t) {
        return this.Fp(t) * this.G(t) - this.Gp(t) * this.F(t);
    }
    Qp(t) {
        return this.Fpp(t) * this.G(t) - this.Gpp(t) * this.F(t);
    }
    Gpp(t) {
        const xp = this.Xp(t);
        const yp = this.Yp(t);
        const xpp = this.Xpp(t);
        const ypp = this.Ypp(t);
        const xppp = this.Xppp(t);
        const yppp = this.Yppp(t);
        const u = Math.sqrt(xp * xp + yp * yp);
        const v = xp * xpp + yp * ypp;
        return 3 * ((v * v) / u + u * (xpp * xpp + xp * xppp + ypp * ypp + yp * yppp));
    }
    Gp(t) {
        const xp = this.Xp(t);
        const yp = this.Yp(t);
        const xpp = this.Xpp(t);
        const ypp = this.Ypp(t);
        return 3 * Math.sqrt(xp * xp + yp * yp) * (xp * xpp + yp * ypp);
    }
    getParameterAtLength(length) {
        let low = 0;
        let upper = 1;
        while (upper - low > _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance) {
            const middle = (upper + low) / 2;
            const err = this.evaluateError(length, middle);
            if (err > 0)
                upper = middle;
            else if (err < 0)
                low = middle;
            else
                return middle;
        }
        return (low + upper) / 2;
    }
    evaluateError(length, t) {
        //todo: this is a slow version!
        const f = 1 - t;
        const mb0 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, this.b[0], t, this.b[1]);
        const mb1 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, this.b[1], t, this.b[2]);
        const mb2 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, this.b[2], t, this.b[3]);
        const mmb0 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, mb0, t, mb1);
        const mmb1 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, mb1, t, mb2);
        const mmmb0 = _point__WEBPACK_IMPORTED_MODULE_2__.Point.mkPoint(f, mmb0, t, mmb1);
        const lengthAtT = BezierSeg.lengthOnControlPolygon(this.b[0], mb0, mmb0, mmmb0);
        if (lengthAtT > length + _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon)
            return 1;
        if (lengthAtT < length - _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon)
            return -1;
        return 0;
    }
}
//# sourceMappingURL=bezierSeg.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/closestPointOnCurve.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClosestPointOnCurve: () => (/* binding */ ClosestPointOnCurve)
/* harmony export */ });
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");

class ClosestPointOnCurve {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static closestPoint(curve, a, hint, low, high) {
        const numberOfIterationsMax = 5;
        const numberOfOverShootsMax = 5;
        let t = hint;
        let numberOfIteration = 0;
        let numberOfOvershoots = 0;
        let dt;
        let abort = false;
        do {
            const c = curve.value(t);
            const ct = curve.derivative(t);
            const ctt = curve.secondDerivative(t);
            const secondDerivative = ct.dot(ct) + c.sub(a).dot(ctt);
            if (Math.abs(secondDerivative) < _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance)
                return t;
            dt = c.sub(a).dot(ct.div(secondDerivative));
            t -= dt;
            if (t > high + _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance) {
                t = high;
                numberOfOvershoots++;
            }
            else if (t < low - _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance) {
                t = low;
                numberOfOvershoots++;
            }
            numberOfIteration++;
        } while (Math.abs(dt) > _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance &&
            !(abort = numberOfIteration >= numberOfIterationsMax || numberOfOvershoots >= numberOfOverShootsMax));
        //may be the initial value was just fine
        if (abort && curve.value(hint).sub(a).length < _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon)
            t = hint;
        return t;
    }
}
//# sourceMappingURL=closestPointOnCurve.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/compassVector.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompassVector: () => (/* binding */ CompassVector)
/* harmony export */ });
/* harmony import */ var _routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");



class CompassVector {
    constructor(direction) {
        this.Dir = direction;
    }
    get Right() {
        return new CompassVector(CompassVector.RotateRight(this.Dir));
    }
    static RotateRight(direction) {
        switch (direction) {
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
                break;
            default:
                throw new Error();
                break;
        }
    }
    static RotateLeft(direction) {
        switch (direction) {
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
                break;
            default:
                throw new Error();
                break;
        }
    }
    static ToIndex(direction) {
        switch (direction) {
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North:
                return 0;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East:
                return 1;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South:
                return 2;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West:
                return 3;
                break;
            default:
                throw new Error();
                break;
        }
    }
    static VectorDirection(d) {
        let r = _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
        if (d.x > _routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__.PointComparer.DifferenceEpsilon) {
            r = _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East;
        }
        else if (d.x < -_routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__.PointComparer.DifferenceEpsilon) {
            r = _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West;
        }
        if (d.y > _routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__.PointComparer.DifferenceEpsilon) {
            r = r | _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
        }
        else if (d.y < -_routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__.PointComparer.DifferenceEpsilon) {
            r = r | _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South;
        }
        return r;
    }
    static VectorDirectionPP(a, b) {
        let r = _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
        // This method is called a lot as part of rectilinear layout.
        // Try to keep it quick.
        const horizontalDiff = b.x - a.x;
        const verticalDiff = b.y - a.y;
        if (horizontalDiff > _routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__.PointComparer.DifferenceEpsilon) {
            r = _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East;
        }
        else if (-horizontalDiff > _routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__.PointComparer.DifferenceEpsilon) {
            r = _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West;
        }
        if (verticalDiff > _routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__.PointComparer.DifferenceEpsilon) {
            r |= _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
        }
        else if (-verticalDiff > _routing_rectilinear_PointComparer__WEBPACK_IMPORTED_MODULE_0__.PointComparer.DifferenceEpsilon) {
            r |= _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South;
        }
        return r;
    }
    static DirectionFromPointToPoint(a, b) {
        return CompassVector.VectorDirectionPP(a, b);
    }
    static OppositeDir(dir) {
        switch (dir) {
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West;
                break;
            default:
                return _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
                break;
        }
    }
    static IsPureDirection(dir) {
        switch (dir) {
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North:
                return true;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East:
                return true;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South:
                return true;
                break;
            case _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West:
                return true;
                break;
            default:
                return false;
                break;
        }
    }
    static IsPureDirectionPP(a, b) {
        return CompassVector.IsPureDirection(CompassVector.DirectionFromPointToPoint(a, b));
    }
    static DirectionsAreParallel(a, b) {
        return a === b || a === CompassVector.OppositeDir(b);
    }
    // Translates the CompassVector's direction into a new Point.
    ToPoint() {
        let x = 0, y = 0;
        if ((this.Dir & _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East) === _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East) {
            x++;
        }
        if ((this.Dir & _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North) === _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North) {
            y++;
        }
        if ((this.Dir & _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West) === _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West) {
            x--;
        }
        if ((this.Dir & _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South) === _direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South) {
            y--;
        }
        return new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x, y);
    }
    // Translates a direction into a Point.
    static toPoint(dir) {
        return new CompassVector(dir).ToPoint();
    }
    //  the negation operator
    static negate(directionVector) {
        return new CompassVector(CompassVector.OppositeDir(directionVector.Dir));
    }
}
//# sourceMappingURL=compassVector.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/convexHull.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConvexHull: () => (/* binding */ ConvexHull)
/* harmony export */ });
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
// Creates the convex hull of a set of points following "Computational Geometry, second edition" of O'Rourke



class ConvexHull {
    constructor(bodyPoints) {
        this.stamp = 0;
        this.SetPivotAndAllocateHullPointsArray(bodyPoints);
    }
    SetPivotAndAllocateHullPointsArray(bodyPoints) {
        this.pivot = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(0, Number.MAX_SAFE_INTEGER);
        // set Y to a very big value
        let pivotIndex = -1;
        let n = 0;
        for (const point of bodyPoints) {
            if (point.y < this.pivot.y) {
                this.pivot = point;
                pivotIndex = n;
            }
            else if (point.y === this.pivot.y) {
                if (point.x > this.pivot.x) {
                    this.pivot = point;
                    pivotIndex = n;
                }
            }
            n++;
        }
        if (n >= 1) {
            this.hullPoints = new Array(n - 1);
            // we will not copy the pivot into the hull points
            n = 0;
            for (const point of bodyPoints) {
                if (n !== pivotIndex) {
                    this.hullPoints[n++] = {
                        point: point,
                        deleted: false,
                        stamp: this.stamp++,
                    };
                }
                else {
                    pivotIndex = -1;
                }
            }
            // forget where the pivot was
        }
    }
    get StackTopPoint() {
        return this.stack.point;
    }
    get StackSecondPoint() {
        return this.stack.next.point;
    }
    // calculates the convex hull of the given set of points
    static *CalculateConvexHull(pointsOfTheBody) {
        const convexHull = new ConvexHull(pointsOfTheBody);
        for (const p of convexHull.Calculate())
            yield p;
    }
    *Calculate() {
        if (this.pivot.y === Number.MAX_SAFE_INTEGER) {
            return;
        }
        if (this.hullPoints.length === 0) {
            yield this.pivot;
            return;
        }
        this.SortAllPointsWithoutPivot();
        this.Scan();
        for (const p of this.EnumerateStack()) {
            yield p;
        }
    }
    *EnumerateStack() {
        let stackCell = this.stack;
        while (stackCell != null) {
            yield stackCell.point;
            stackCell = stackCell.next;
        }
    }
    Scan() {
        let i = 0;
        while (this.hullPoints[i].deleted) {
            i++;
        }
        this.stack = { point: this.pivot, next: null };
        this.Push(i++);
        if (i < this.hullPoints.length) {
            if (!this.hullPoints[i].deleted) {
                this.Push(i++);
            }
            else {
                i++;
            }
        }
        while (i < this.hullPoints.length) {
            if (!this.hullPoints[i].deleted) {
                if (this.LeftTurn(i)) {
                    this.Push(i++);
                }
                else {
                    this.Pop();
                }
            }
            else {
                i++;
            }
        }
        // cleanup the end
        while (this.StackHasMoreThanTwoPoints() && !this.LeftTurnToPivot()) {
            this.Pop();
        }
    }
    LeftTurnToPivot() {
        return _point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientation(this.StackSecondPoint, this.StackTopPoint, this.pivot) === _point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise;
    }
    StackHasMoreThanTwoPoints() {
        return this.stack.next != null && this.stack.next.next != null;
    }
    Pop() {
        this.stack = this.stack.next;
    }
    LeftTurn(i) {
        if (this.stack.next == null) {
            return true;
        }
        // there is only one point in the stack
        const orientation = _point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientationWithIntersectionEpsilon(this.StackSecondPoint, this.StackTopPoint, this.hullPoints[i].point);
        if (orientation === _point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise) {
            return true;
        }
        if (orientation === _point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Clockwise) {
            return false;
        }
        return this.BackSwitchOverPivot(this.hullPoints[i].point);
    }
    BackSwitchOverPivot(point) {
        // we know here that there at least two points in the stack but it has to be exaclty two
        if (this.stack.next.next != null) {
            return false;
        }
        /*Assert.assert(this.StackSecondPoint === this.pivot)*/
        return this.StackTopPoint.x > this.pivot.x + _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon && point.x < this.pivot.x - _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon;
    }
    Push(p) {
        this.stack = { point: this.hullPoints[p].point, next: this.stack };
    }
    SortAllPointsWithoutPivot() {
        this.hullPoints.sort(hullPointComparer(this.pivot));
    }
    static createConvexHullAsClosedPolyline(points) {
        const convexHull = _polyline__WEBPACK_IMPORTED_MODULE_2__.Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(points)));
        // #if (TEST_MSAGL)
        // for (let point of points) {
        //    if ((Curve.PointRelativeToCurveLocation(point, convexHull) === PointLocation.Outside)) {
        //        let hullPoint = convexHull[convexHull.closestParameter(point)];
        //        //  This can be too restrictive if very close points are put into the hull.  It is probably
        //        //  better to clean up in the caller before doing this, but this assert can also be relaxed.
        //        Assert.assert(ApproximateComparer.Close(point, hullPoint, (ApproximateComparer.IntersectionEpsilon * 20)), String.Format("not CloseIntersections: initial point {0}, hull point {1}", point, hullPoint));
        //    }
        // }
        // #endif
        // // TEST_MSAGL
        return convexHull;
    }
}
// note that this function can change "deleted" member for collinear points
function hullPointComparer(pivot) {
    return (i, j) => {
        if (i === j) {
            return 0;
        }
        if (i == null) {
            return -1;
        }
        if (j == null) {
            return 1;
        }
        switch (_point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientationWithIntersectionEpsilon(pivot, i.point, j.point)) {
            case _point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise:
                return -1;
                break;
            case _point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Clockwise:
                return 1;
                break;
            case _point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Collinear:
                // because of the double point error pi and pj can be on different sizes of the pivot on the horizontal line passing through the pivot, or rather just above it
                const piDelX = i.point.x - pivot.x;
                const pjDelX = j.point.x - pivot.x;
                if (piDelX > _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon && pjDelX < -_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon) {
                    return -1;
                }
                if (piDelX < -_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon && pjDelX > _geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon) {
                    return 1;
                }
                // here i and j cannot be on the different sides of the pivot because of the choice of the pivot
                // delete the one that is closer to the pivot.
                const pi = i.point.sub(pivot);
                const pj = j.point.sub(pivot);
                const iMinJ = pi.l1 - pj.l1;
                if (iMinJ < 0) {
                    i.deleted = true;
                    return -1;
                }
                if (iMinJ > 0) {
                    j.deleted = true;
                    return 1;
                }
                // points are the same, leave the one with the smallest stamp
                if (i.stamp > j.stamp) {
                    i.deleted = true;
                }
                else {
                    j.deleted = true;
                }
                return 0;
        }
        throw new Error();
    };
}
//# sourceMappingURL=convexHull.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/cornerSite.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CornerSite: () => (/* binding */ CornerSite)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");

class CornerSite {
    constructor() {
        // the coeffiecient used to calculate the first and the second control points of the
        // Bezier segment for the fillet at the site
        this.previouisBezierCoefficient = 0.5;
        // the coeffiecient used to calculate the third and the fourth control points of the
        // Bezier segment for the fillet at the site
        this.nextBezierCoefficient = 0.5;
        // the coefficient tells how tight the segment fits to the segment after the site; the formula is kNext * c + (1 - kNext) * b
        this.previousTangentCoefficient = 1.0 / 3;
        this.nextTangentCoefficient = 1.0 / 3;
    }
    static mkSiteP(sitePoint) {
        const s = new CornerSite();
        s.point = sitePoint;
        return s;
    }
    static mkSiteSP(previousSite, sitePoint) {
        const s = new CornerSite();
        s.point = sitePoint;
        s.prev = previousSite;
        previousSite.next = s;
        return s;
    }
    static mkSiteSPS(previousSite, sitePoint, nextSite) {
        const s = new CornerSite();
        s.prev = previousSite;
        s.point = sitePoint;
        s.next = nextSite;
        previousSite.next = s;
        nextSite.prev = s;
        return s;
    }
    get turn() {
        if (this.next == null || this.prev == null)
            return 0;
        return _point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.prev.point, this.point, this.next.point);
    }
    clone() {
        const s = new CornerSite();
        s.previouisBezierCoefficient = this.previouisBezierCoefficient;
        s.point = this.point;
        return s;
    }
}
//# sourceMappingURL=cornerSite.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/curve.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Curve: () => (/* binding */ Curve),
/* harmony export */   PointLocation: () => (/* binding */ PointLocation),
/* harmony export */   clipWithRectangle: () => (/* binding */ clipWithRectangle),
/* harmony export */   clipWithRectangleInsideInterval: () => (/* binding */ clipWithRectangleInsideInterval),
/* harmony export */   interpolateICurve: () => (/* binding */ interpolateICurve)
/* harmony export */ });
/* harmony import */ var _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogramNode.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _lineSegment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/intersectionInfo.js");
/* harmony import */ var _parallelogram__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogram.js");
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _linearSystem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/linearSystem.js");
/* harmony import */ var _minDistCurveCurve__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/minDistCurveCurve.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _bezierSeg__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/bezierSeg.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");













function segParamValue(sp) {
    return sp.seg.value(sp.par);
}
function segParamDerivative(sp) {
    return sp.seg.derivative(sp.par);
}
function segParamSecondDerivative(sp) {
    return sp.seg.secondDerivative(sp.par);
}
function segParamThirdDerivative(sp) {
    return sp.seg.thirdDerivative(sp.par);
}
var PointLocation;
(function (PointLocation) {
    PointLocation[PointLocation["Outside"] = 0] = "Outside";
    PointLocation[PointLocation["Boundary"] = 1] = "Boundary";
    PointLocation[PointLocation["Inside"] = 2] = "Inside";
})(PointLocation || (PointLocation = {}));
function getJSONforSeg(seg) {
    if (seg instanceof _ellipse__WEBPACK_IMPORTED_MODULE_5__.Ellipse) {
        return { tag: 'ellipse', segData: seg.toJSON() };
    }
    if (seg instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment) {
        return { tag: 'lineSegment', segData: seg.toJSON() };
    }
    if (seg instanceof _bezierSeg__WEBPACK_IMPORTED_MODULE_11__.BezierSeg) {
        return { tag: 'bezier', segData: seg.toJSON() };
    }
    throw new Error('not implemented');
}
class Curve {
    static fromJSON(eData) {
        const curve = new Curve();
        for (const p of eData.segs) {
            switch (p.tag) {
                case 'bezier':
                    curve.addSegment(_bezierSeg__WEBPACK_IMPORTED_MODULE_11__.BezierSeg.fromJSON(p.segData));
                    break;
                case 'ellipse':
                    curve.addSegment(_ellipse__WEBPACK_IMPORTED_MODULE_5__.Ellipse.fromJSON(p.segData));
                    break;
                case 'lineSegment':
                    curve.addSegment(_lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.fromJSON(p.segData));
                    break;
                default:
                    throw new Error('not implemented');
            }
        }
        return curve;
    }
    toJSON() {
        return { segs: this.segs.map((seg) => getJSONforSeg(seg)) };
    }
    static CurvesIntersect(curve1, curve2) {
        return curve1 === curve2 || Curve.intersectionOne(curve1, curve2, false) != null;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static lengthWithInterpolationAndThreshold(_seg, _eps) {
        throw new Error('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static lengthWithInterpolation(_seg) {
        throw 'not implemented';
    }
    get parStart() {
        return 0;
    }
    get parEnd() {
        return this.parEnd_;
    }
    lengthPartial(start, end) {
        const params = {
            start: start,
            end: end,
        };
        this.adjustStartEndEndParametersToDomain(params);
        const si = this.getSegIndexParam(start);
        const ej = this.getSegIndexParam(end);
        if (si.segIndex < ej.segIndex) {
            let seg = this.segs[si.segIndex];
            let ret = seg.lengthPartial(si.par, seg.parEnd);
            for (let k = si.segIndex + 1; k < ej.segIndex; k++)
                ret += this.segs[k].length;
            seg = this.segs[ej.segIndex];
            return ret + seg.lengthPartial(seg.parStart, ej.par);
        }
        else {
            throw new Error('not implemented.');
        }
    }
    // this[Reverse[t]]=this[ParEnd+ParStart-t]
    reverse() {
        const ret = new Curve();
        for (let i = this.segs.length - 1; i >= 0; i--)
            ret.addSegment(this.segs[i].reverse());
        return ret;
    }
    // Constructs the curve for a given number of segments
    constructor() {
        this.segs = [];
        this.parEnd_ = 0;
    }
    mkCurveWithSegs(segs) {
        this.segs = segs;
        for (const s of segs)
            this.parEnd_ += Curve.paramSpan(s);
    }
    get start() {
        return this.segs[0].start;
    }
    get end() {
        return this.segs[this.segs.length - 1].end;
    }
    scaleFromOrigin(xScale, yScale) {
        const c = new Curve();
        for (const s of this.segs)
            c.addSegment(s.scaleFromOrigin(xScale, yScale));
        return c;
    }
    // Returns the trimmed curve
    trim(start, end) {
        const params = {
            start: start,
            end: end,
        };
        this.adjustStartEndEndParametersToDomain(params);
        const s = this.getSegIndexParam(params.start);
        const e = this.getSegIndexParam(params.end);
        if (s.segIndex === e.segIndex)
            return this.segs[s.segIndex].trim(s.par, e.par);
        let c = new Curve();
        if (s.par < this.segs[s.segIndex].parEnd)
            c = c.addSegment(this.segs[s.segIndex].trim(s.par, this.segs[s.segIndex].parEnd));
        for (let i = s.segIndex + 1; i < e.segIndex; i++)
            c = c.addSegment(this.segs[i]);
        if (this.segs[e.segIndex].parStart < e.par)
            c = c.addSegment(this.segs[e.segIndex].trim(this.segs[e.segIndex].parStart, e.par));
        return c;
    }
    translate(delta) {
        for (const s of this.segs)
            s.translate(delta);
        if (this.boundingBox_) {
            this.boundingBox_ = _rectangle__WEBPACK_IMPORTED_MODULE_10__.Rectangle.translate(this.boundingBox_, delta);
        }
        this.pBNode = null;
    }
    adjustStartEndEndParametersToDomain(params) {
        if (params.start > params.end) {
            const t = params.start;
            params.start = params.end;
            params.end = t;
        }
        if (params.start < this.parStart)
            params.start = this.parStart;
        if (params.end > this.parEnd)
            params.end = this.parEnd;
    }
    // Returns the trimmed curve, wrapping around the end if start is greater than end.
    trimWithWrap(start, end) {
        /*Assert.assert(start >= this.parStart && start <= this.parEnd)*/
        /*Assert.assert(end >= this.parStart && end <= this.parEnd)*/
        if (start < end)
            return this.trim(start, end); // Curve must be closed to wrap
        /*Assert.assert(Point.closeDistEps(this.start, this.end))*/ const c = new Curve();
        c.addSegment(this.trim(start, this.parEnd));
        c.addSegment(this.trim(this.parStart, end));
        return c;
    }
    addSegs(segs) {
        for (const s of segs)
            this.addSegment(s);
        return this;
    }
    // Adds a segment to the curve
    addSegment(curve) {
        if (curve == null)
            return this; //nothing happens
        this.boundingBox_ = null;
        /*Assert.assert(
          this.segs.length === 0 || Point.close(this.end, curve.start, 0.001),
        )*/
        if (!(curve instanceof Curve)) {
            this.segs.push(curve);
            this.parEnd_ += Curve.paramSpan(curve);
        }
        else {
            for (const cc of curve.segs) {
                this.segs.push(cc);
                this.parEnd_ += Curve.paramSpan(cc);
            }
        }
        return this;
    }
    // A tree of ParallelogramNodes covering the curve.
    // This tree is used in curve intersections routines.
    pNodeOverICurve() {
        if (this.pBNode != null)
            return this.pBNode;
        const parallelograms = [];
        const childrenNodes = [];
        for (const curveSeg of this.segs) {
            const pBoxNode = curveSeg.pNodeOverICurve();
            parallelograms.push(pBoxNode.parallelogram);
            childrenNodes.push(pBoxNode);
        }
        this.pBNode = {
            parallelogram: _parallelogram__WEBPACK_IMPORTED_MODULE_4__.Parallelogram.getParallelogramOfAGroup(parallelograms),
            seg: this,
            leafBoxesOffset: _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.defaultLeafBoxesOffset,
            node: { children: childrenNodes },
        };
        return this.pBNode;
    }
    // finds an intersection between to curves,
    static intersectionOne(curve0, curve1, liftIntersection) {
        /*Assert.assert(curve0 !== curve1)*/
        //           number c0S = curve0.parStart, c1S = curve1.parStart;
        //           if (CurvesAreCloseAtParams(curve0, curve1, c0S, c1S)) {
        //               number mc0 = 0.5 * (curve0.parStart + curve0.parEnd);
        //               number mc1 = 0.5 * (curve1.parStart + curve1.parEnd);
        //               number c0E = curve0.parEnd;
        //               if (CurvesAreCloseAtParams(curve0, curve1, mc0, mc1)) {
        //                   number c1E = curve1.parEnd;
        //                   CurvesAreCloseAtParams(curve0, curve1, c0E, c1E);
        //                   throw new Error();
        //               }
        //           }
        //recurse down to find all PBLeaf pairs which intesect and try to cross their segments
        let ret = Curve.curveCurveXWithParallelogramNodesOne(curve0.pNodeOverICurve(), curve1.pNodeOverICurve());
        if (liftIntersection && ret != null)
            ret = Curve.liftIntersectionToCurves(curve0, curve1, ret);
        return ret;
    }
    /**
     *   Calculates all intersections between curve0 and curve1.
     *  If liftIntersections is true then the intersections parameters
     *  recalculated, lifted, to the curve parameter domain. Otherwise they * stay in the segment domains
     */
    static getAllIntersections(curve0, curve1, liftIntersections) {
        //           var c0S = curve0.parStart;
        //           var c1S = curve1.parStart;
        //           var c0E = curve0.parEnd;
        //           var c1E = curve1.parEnd;
        //           if (CurvesAreCloseAtParams(curve0, curve1, c0S, c1S)) {
        //               if (CurvesAreCloseAtParams(curve0, curve1, c0E, c1E)) {
        //                   var mc0 = 0.5*(curve0.parStart + curve0.parEnd);
        //                   var mc1 = 0.5*(curve1.parStart + curve1.parEnd);
        //                   if (CurvesAreCloseAtParams(curve0, curve1, mc0, mc1))
        //                       throw new Error();
        //               }
        //           }
        if (curve0 instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment) {
            return Curve.getAllIntersectionsOfLineAndICurve(curve0, curve1, liftIntersections);
        }
        return Curve.getAllIntersectionsInternal(curve0, curve1, liftIntersections);
    }
    static getAllIntersectionsInternal(curve0, curve1, liftIntersections) {
        //recurse down to find all PBLeaf pairs which intesect and try to cross their segments
        const intersections = [];
        Curve.curveCurveXWithParallelogramNodes(curve0.pNodeOverICurve(), curve1.pNodeOverICurve(), intersections);
        if (liftIntersections)
            for (let i = 0; i < intersections.length; i++) {
                intersections[i] = Curve.liftIntersectionToCurves(curve0, curve1, intersections[i]);
            }
        return intersections;
    }
    static getAllIntersectionsOfLineAndICurve(lineSeg, iCurve, liftIntersections) {
        if (iCurve instanceof _polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline)
            return Curve.getAllIntersectionsOfLineAndPolyline(lineSeg, iCurve);
        if (iCurve instanceof Curve)
            return Curve.getAllIntersectionsOfLineAndCurve(lineSeg, iCurve, liftIntersections);
        if (iCurve instanceof _ellipse__WEBPACK_IMPORTED_MODULE_5__.Ellipse && iCurve.isArc())
            return Curve.getAllIntersectionsOfLineAndArc(lineSeg, iCurve);
        return Curve.getAllIntersectionsInternal(lineSeg, iCurve, liftIntersections);
    }
    static getAllIntersectionsOfLineAndCurve(lineSeg, curve, liftIntersections) {
        const ret = [];
        const lineParallelogram = lineSeg.pNodeOverICurve();
        const curveParallelogramRoot = curve.pNodeOverICurve();
        if (_parallelogram__WEBPACK_IMPORTED_MODULE_4__.Parallelogram.intersect(lineParallelogram.parallelogram, curveParallelogramRoot.parallelogram) === false)
            return ret;
        let parOffset = 0.0;
        for (const seg of curve.segs) {
            const iiList = Curve.getAllIntersections(lineSeg, seg, false);
            if (liftIntersections) {
                for (const intersectionInfo of iiList) {
                    intersectionInfo.par1 += parOffset - seg.parStart;
                    intersectionInfo.seg1 = curve;
                }
                parOffset += seg.parEnd - seg.parStart;
            }
            for (const intersectionInfo of iiList) {
                if (!Curve.alreadyInside(ret, intersectionInfo))
                    ret.push(intersectionInfo);
            }
        }
        return ret;
    }
    static closeIntersections(x, y) {
        return _point__WEBPACK_IMPORTED_MODULE_1__.Point.close(x.x, y.x, _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.intersectionEpsilon);
    }
    static closeIntersectionPoints(x, y) {
        return _point__WEBPACK_IMPORTED_MODULE_1__.Point.close(x, y, _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.intersectionEpsilon);
    }
    static alreadyInside(ret, intersectionInfo) {
        for (let i = 0; i < ret.length; i++) {
            const ii = ret[i];
            if (Curve.closeIntersections(ii, intersectionInfo))
                return true;
        }
        return false;
    }
    static getAllIntersectionsOfLineAndArc(lineSeg, ellipse) {
        /*Assert.assert(ellipse.isArc())*/
        let lineDir = lineSeg.end.sub(lineSeg.start);
        const ret = [];
        const segLength = lineDir.length;
        // the case of a very short LineSegment
        if (segLength < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon) {
            const lsStartMinCen = lineSeg.start.sub(ellipse.center);
            if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_12__.closeDistEps)(lsStartMinCen.length, ellipse.aAxis.length)) {
                let angle = _point__WEBPACK_IMPORTED_MODULE_1__.Point.angle(ellipse.aAxis, lsStartMinCen);
                if (ellipse.parStart - _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance <= angle) {
                    angle = Math.max(angle, ellipse.parStart);
                    if (angle <= ellipse.parEnd + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance) {
                        angle = Math.min(ellipse.parEnd, angle);
                        ret.push(new _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__.IntersectionInfo(0, angle, lineSeg.start, lineSeg, ellipse));
                    }
                }
            }
            return ret;
        }
        const perp = lineDir.rotate90Ccw().div(segLength);
        const segProjection = lineSeg.start.sub(ellipse.center).dot(perp);
        const closestPointOnLine = ellipse.center.add(perp.mul(segProjection));
        const rad = ellipse.aAxis.length;
        const absSegProj = Math.abs(segProjection);
        if (rad < absSegProj - _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon)
            return ret; //we don't have an intersection
        lineDir = perp.rotate90Cw();
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_12__.closeDistEps)(rad, absSegProj)) {
            Curve.tryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, closestPointOnLine, segLength, lineDir);
        }
        else {
            /*Assert.assert(rad > absSegProj)*/
            const otherLeg = Math.sqrt(rad * rad - segProjection * segProjection);
            const d = lineDir.mul(otherLeg);
            Curve.tryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, closestPointOnLine.add(d), segLength, lineDir);
            Curve.tryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, closestPointOnLine.sub(d), segLength, lineDir);
        }
        return ret;
    }
    static tryToAddPointToLineCircleCrossing(lineSeg, ellipse, ret, point, segLength, lineDir) {
        const ds = point.sub(lineSeg.start);
        let t = ds.dot(lineDir);
        if (t < -_geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon)
            return;
        t = Math.max(t, 0);
        if (t > segLength + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon)
            return;
        t = Math.min(t, segLength);
        t /= segLength;
        let angle = _point__WEBPACK_IMPORTED_MODULE_1__.Point.angle(ellipse.aAxis, point.sub(ellipse.center));
        if (ellipse.parStart - _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance <= angle) {
            angle = Math.max(angle, ellipse.parStart);
            if (angle <= ellipse.parEnd + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance) {
                angle = Math.min(ellipse.parEnd, angle);
                ret.push(new _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__.IntersectionInfo(t, angle, point, lineSeg, ellipse));
            }
        }
    }
    static getAllIntersectionsOfLineAndPolyline(lineSeg, poly) {
        const ret = [];
        let offset = 0.0;
        let polyPoint = poly.startPoint;
        for (; polyPoint != null && polyPoint.getNext() != null; polyPoint = polyPoint.getNext()) {
            const sol = Curve.crossTwoLineSegs(lineSeg.start, lineSeg.end, polyPoint.point, polyPoint.getNext().point, 0, 1, 0, 1);
            if (sol) {
                Curve.adjustSolution(lineSeg.start, lineSeg.end, polyPoint.point, polyPoint.getNext().point, sol);
                if (!Curve.oldIntersection(ret, sol.x))
                    ret.push(new _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__.IntersectionInfo(sol.aSol, offset + sol.bSol, sol.x, lineSeg, poly));
            }
            offset++;
        }
        if (poly.closed) {
            const sol = Curve.crossTwoLineSegs(lineSeg.start, lineSeg.end, polyPoint.point, poly.start, 0, 1, 0, 1);
            if (sol) {
                Curve.adjustSolution(lineSeg.start, lineSeg.end, polyPoint.point, poly.start, sol);
                if (!Curve.oldIntersection(ret, sol.x))
                    ret.push(new _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__.IntersectionInfo(sol.aSol, offset + sol.bSol, sol.x, lineSeg, poly));
            }
        }
        return ret;
    }
    static adjustSolution(aStart, aEnd, bStart, bEnd, sol) {
        //adjust the intersection if it is close to the ends of the segs
        if (Curve.closeIntersectionPoints(sol.x, aStart)) {
            sol.x = aStart;
            sol.aSol = 0;
        }
        else if (Curve.closeIntersectionPoints(sol.x, aEnd)) {
            sol.x = aEnd;
            sol.aSol = 1;
        }
        if (Curve.closeIntersectionPoints(sol.x, bStart)) {
            sol.x = bStart;
            sol.bSol = Math.floor(sol.bSol);
        }
        else if (Curve.closeIntersectionPoints(sol.x, bEnd)) {
            sol.x = bEnd;
            sol.bSol = Math.ceil(sol.bSol);
        }
    }
    static curveCurveXWithParallelogramNodesOne(n0, n1) {
        if (!_parallelogram__WEBPACK_IMPORTED_MODULE_4__.Parallelogram.intersect(n0.parallelogram, n1.parallelogram))
            return null;
        const n0Pb = n0.node;
        const n1Pb = n1.node;
        const n0Internal = n0Pb.hasOwnProperty('children');
        const n1Internal = n1Pb.hasOwnProperty('children');
        if (n0Internal && n1Internal)
            for (const n00 of n0Pb.children)
                for (const n11 of n1Pb.children) {
                    const x = Curve.curveCurveXWithParallelogramNodesOne(n00, n11);
                    if (x != null)
                        return x;
                }
        else if (n1Internal)
            for (const n of n1Pb.children) {
                const x = Curve.curveCurveXWithParallelogramNodesOne(n0, n);
                if (x != null)
                    return x;
            }
        else if (n0Internal)
            for (const n of n0Pb.children) {
                const x = Curve.curveCurveXWithParallelogramNodesOne(n, n1);
                if (x != null)
                    return x;
            }
        else
            return Curve.crossOverIntervalsOne(n0, n1);
        return null;
    }
    static curveCurveXWithParallelogramNodes(n0, n1, intersections) {
        if (!_parallelogram__WEBPACK_IMPORTED_MODULE_4__.Parallelogram.intersect(n0.parallelogram, n1.parallelogram)) {
            // Boxes n0.Box and n1.Box do not intersect
            return;
        }
        const isInternal0 = n0.node.hasOwnProperty('children');
        const isInternal1 = n1.node.hasOwnProperty('children');
        if (isInternal0 && isInternal1)
            for (const n00 of n0.node.children)
                for (const n11 of n1.node.children)
                    Curve.curveCurveXWithParallelogramNodes(n00, n11, intersections);
        else if (isInternal1)
            for (const n of n1.node.children)
                Curve.curveCurveXWithParallelogramNodes(n0, n, intersections);
        else if (isInternal0)
            for (const n of n0.node.children)
                Curve.curveCurveXWithParallelogramNodes(n, n1, intersections);
        else
            intersections = Curve.crossOverLeaves(n0, n1, intersections);
    }
    static crossOverIntervalsOne(n0, n1) {
        //both are leafs
        const l0 = n0.node;
        const l1 = n1.node;
        const d0 = (l0.high - l0.low) / 2;
        const d1 = (l1.high - l1.low) / 2;
        for (let i = 1; i < 2; i++) {
            const p0 = i * d0 + l0.low;
            for (let j = 1; j < 2; j++) {
                const p1 = j * d1 + l1.low;
                let sol;
                if (l0.chord == null && l1.chord == null)
                    sol = Curve.crossWithinIntervalsWithGuess(n0.seg, n1.seg, l0.low, l0.high, l1.low, l1.high, p0, p1);
                else if (l0.chord != null && l1.chord == null) {
                    sol = Curve.crossWithinIntervalsWithGuess(l0.chord, n1.seg, 0, 1, l1.low, l1.high, 0.5 * i, p1);
                }
                else if (l0.chord == null) {
                    sol = Curve.crossWithinIntervalsWithGuess(n0.seg, l1.chord, l0.low, l0.high, 0, 1, p0, 0.5 * j);
                    if (sol) {
                        sol.bSol = l1.low + sol.bSol * (l1.high - l1.low);
                    }
                } //if (l0.chord != null && l1.chord != null)
                else {
                    sol = Curve.crossWithinIntervalsWithGuess(l0.chord, l1.chord, 0, 1, 0, 1, 0.5 * i, 0.5 * j);
                    if (sol) {
                        sol.aSol = l0.low + sol.aSol * (l0.high - l0.low);
                        sol.bSol = l1.low + sol.bSol * (l1.high - l1.low);
                    }
                }
                if (sol) {
                    return Curve.createIntersectionOne(n0, n1, sol.aSol, sol.bSol, sol.x);
                }
            }
        }
        return Curve.goDeeperOne(n0, n1);
    }
    static crossOverLeaves(n0, n1, intersections) {
        //both are leafs
        const l0 = n0.node;
        const l1 = n1.node;
        let found = false;
        const p0 = (l0.high - l0.low) / 2 + l0.low;
        const p1 = (l1.high - l1.low) / 2 + l1.low;
        let sol;
        if (l0.chord == null && l1.chord == null)
            sol = Curve.crossWithinIntervalsWithGuess(n0.seg, n1.seg, l0.low, l0.high, l1.low, l1.high, p0, p1);
        else if (l0.chord != null && l1.chord == null) {
            sol = Curve.crossWithinIntervalsWithGuess(l0.chord, n1.seg, 0, 1, l1.low, l1.high, 0.5, p1);
            if (sol)
                sol.aSol = l0.low + sol.aSol * (l0.high - l0.low);
        }
        else if (l0.chord == null) {
            //&& l1.chord != null)
            sol = Curve.crossWithinIntervalsWithGuess(n0.seg, l1.chord, l0.low, l0.high, 0, 1, p0, 0.5);
            if (sol)
                sol.bSol = l1.low + sol.bSol * (l1.high - l1.low);
        } //if (l0.chord != null && l1.chord != null)
        else {
            sol = Curve.crossWithinIntervalsWithGuess(l0.chord, l1.chord, 0, 1, 0, 1, 0.5, 0.5);
            if (sol) {
                sol.bSol = l1.low + sol.bSol * (l1.high - l1.low);
                sol.aSol = l0.low + sol.aSol * (l0.high - l0.low);
            }
        }
        if (sol) {
            Curve.addIntersection(n0, n1, intersections, sol);
            found = true;
        }
        if (!found)
            Curve.goDeeper(intersections, n0, n1);
        return intersections;
    }
    static addIntersection(n0, n1, intersections, sol) {
        const l0 = n0.node;
        //adjust the intersection if it is close to the ends of the segs
        if (Curve.closeIntersectionPoints(sol.x, n0.seg.value(l0.low))) {
            sol.x = n0.seg.value(l0.low);
            sol.aSol = l0.low;
        }
        else if (Curve.closeIntersectionPoints(sol.x, n0.seg.value(l0.high))) {
            sol.x = n0.seg.value(l0.high);
            sol.aSol = l0.high;
        }
        const l1 = n1.node;
        if (Curve.closeIntersectionPoints(sol.x, n1.seg.value(l1.low))) {
            sol.x = n1.seg.value(l1.low);
            sol.bSol = l1.low;
        }
        else if (Curve.closeIntersectionPoints(sol.x, n1.seg.value(l1.high))) {
            sol.x = n1.seg.value(l1.high);
            sol.bSol = l1.high;
        }
        const oldIntersection = Curve.oldIntersection(intersections, sol.x);
        if (!oldIntersection) {
            const xx = new _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__.IntersectionInfo(sol.aSol, sol.bSol, sol.x, n0.seg, n1.seg);
            intersections.push(xx);
        }
        return;
    }
    // returns true if the intersection exists already
    static oldIntersection(intersections, x) {
        //we don't expect many intersections so it's ok just go through all of them
        for (const ii of intersections)
            if (x.sub(ii.x).length < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon * 100) {
                //please no close intersections
                return true;
            }
        return false;
    }
    static createIntersectionOne(n0, n1, aSol, bSol, x) {
        //adjust the intersection if it is close to the ends of the segs
        const l0 = n0.node;
        const l1 = n1.node;
        if (Curve.closeIntersectionPoints(x, n0.seg.value(l0.low))) {
            x = n0.seg.value(l0.low);
            aSol = l0.low;
        }
        else if (Curve.closeIntersectionPoints(x, n0.seg.value(l0.high))) {
            x = n0.seg.value(l0.high);
            aSol = l0.high;
        }
        if (Curve.closeIntersectionPoints(x, n1.seg.value(l1.low))) {
            x = n1.seg.value(l1.low);
            bSol = l1.low;
        }
        else if (Curve.closeIntersectionPoints(x, n1.seg.value(l1.high))) {
            x = n1.seg.value(l1.high);
            bSol = l1.high;
        }
        return new _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__.IntersectionInfo(aSol, bSol, x, n0.seg, n1.seg);
    }
    static liftIntersectionToCurves_(c0, c1, aSol, bSol, x, seg0, seg1) {
        const a = c0 instanceof Curve ? Curve.liftParameterToCurve(c0, aSol - seg0.parStart, seg0) : aSol;
        const b = c1 instanceof Curve ? Curve.liftParameterToCurve(c1, bSol - seg1.parStart, seg1) : bSol;
        return new _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__.IntersectionInfo(a, b, x, c0, c1);
    }
    static DropIntersectionToSegs(xx) {
        let seg0;
        let par0;
        if (xx.seg0 instanceof Curve) {
            const sp = xx.seg0.getSegParam(xx.par0);
            seg0 = sp.seg;
            par0 = sp.par;
        }
        else {
            par0 = xx.par0;
            seg0 = xx.seg0;
        }
        let seg1;
        let par1;
        if (xx.seg1 instanceof Curve) {
            const sp = xx.seg1.getSegParam(xx.par1);
            par1 = sp.par;
            seg1 = sp.seg;
        }
        else {
            par1 = xx.par1;
            seg1 = xx.seg1;
        }
        return new _intersectionInfo__WEBPACK_IMPORTED_MODULE_3__.IntersectionInfo(par0, par1, xx.x, seg0, seg1);
    }
    static liftIntersectionToCurves(c0, c1, xx) {
        return Curve.liftIntersectionToCurves_(c0, c1, xx.par0, xx.par1, xx.x, xx.seg0, xx.seg1);
    }
    static liftParameterToCurve(curve, par, seg) {
        if (curve === seg)
            return par;
        if (!curve.hasOwnProperty('segs'))
            return;
        const c = curve;
        let offset = 0;
        for (const s of c.segs) {
            if (s === seg)
                return par + offset;
            offset += Curve.paramSpan(s);
        }
        throw 'bug in liftParameterToCurve';
    }
    static paramSpan(s) {
        return s.parEnd - s.parStart;
    }
    static goDeeperOne(nl0, nl1) {
        // did not find an intersection yet
        const l0 = nl0.node;
        const l1 = nl1.node;
        if (nl0.leafBoxesOffset > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon && nl1.leafBoxesOffset > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon) {
            // going deeper on both with offset l0.LeafBoxesOffset / 2, l1.LeafBoxesOffset / 2
            const nn0 = _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__.ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low, l0.high, nl0.seg, nl0.leafBoxesOffset / 2);
            const nn1 = _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__.ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low, l1.high, nl1.seg, nl1.leafBoxesOffset / 2);
            return Curve.curveCurveXWithParallelogramNodesOne(nn0, nn1);
        }
        if (nl0.leafBoxesOffset > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon) {
            // go deeper on the left
            const nn0 = _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__.ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low, l0.high, nl0.seg, nl0.leafBoxesOffset / 2);
            return Curve.curveCurveXWithParallelogramNodesOne(nn0, nl1);
        }
        if (nl1.leafBoxesOffset > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon) {
            // go deeper on the right
            const nn1 = _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__.ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low, l1.high, nl1.seg, nl1.leafBoxesOffset / 2);
            return Curve.curveCurveXWithParallelogramNodesOne(nl0, nn1);
        }
        //just cross LineSegs and adjust the solutions if the segments are not straight lines
        const l0Low = nl0.seg.value(l0.low);
        const l0High = nl0.seg.value(l0.high);
        if (!_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(l0Low, l0High)) {
            const l1Low = nl1.seg.value(l1.low);
            const l1High = nl1.seg.value(l1.high);
            if (!_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(l1Low, l1High)) {
                const ls0 = nl0.seg instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment ? nl0.seg : _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(l0Low, l0High);
                const ls1 = nl1.seg instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment ? nl1.seg : _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(l1Low, l1High);
                const sol = Curve.crossWithinIntervalsWithGuess(ls0, ls1, 0, 1, 0, 1, 0.5, 0.5);
                if (sol) {
                    Curve.adjustParameters(nl0, ls0, nl1, ls1, sol);
                    return Curve.createIntersectionOne(nl0, nl1, sol.aSol, sol.bSol, sol.x);
                }
            }
        }
        return null;
    }
    static goDeeper(intersections, nl0, nl1) {
        const l0 = nl0.node;
        const l1 = nl1.node;
        // did not find an intersection
        const n0Large = nl0.leafBoxesOffset > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon;
        const n1Large = nl1.leafBoxesOffset > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon;
        if (n0Large && n1Large) {
            // going deeper on both with offset l0.leafBoxesOffset / 2, l1.leafBoxesOffset / 2
            const nn0 = _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__.ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low, l0.high, nl0.seg, nl0.leafBoxesOffset / 2);
            const nn1 = _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__.ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low, l1.high, nl1.seg, nl1.leafBoxesOffset / 2);
            Curve.curveCurveXWithParallelogramNodes(nn0, nn1, intersections);
        }
        else if (n0Large) {
            // go deeper on the left
            const nn0 = _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__.ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low, l0.high, nl0.seg, nl0.leafBoxesOffset / 2);
            Curve.curveCurveXWithParallelogramNodes(nn0, nl1, intersections);
        }
        else if (n1Large) {
            // go deeper on the right
            const nn1 = _parallelogramNode__WEBPACK_IMPORTED_MODULE_0__.ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low, l1.high, nl1.seg, nl1.leafBoxesOffset / 2);
            Curve.curveCurveXWithParallelogramNodes(nl0, nn1, intersections);
        }
        else {
            //just cross LineSegs since the parallelograms are so thin
            const l0Low = nl0.seg.value(l0.low);
            const l0High = nl0.seg.value(l0.high);
            if (!_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(l0Low, l0High)) {
                const l1Low = nl1.seg.value(l1.low);
                const l1High = nl1.seg.value(l1.high);
                if (!_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(l1Low, l1High)) {
                    const ls0 = nl0.seg instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment ? nl0.seg : _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(l0Low, l0High);
                    const ls1 = nl1.seg instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment ? nl1.seg : _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(l1Low, l1High);
                    const sol = Curve.crossWithinIntervalsWithGuess(ls0, ls1, 0, 1, 0, 1, 0.5, 0.5);
                    if (sol) {
                        Curve.adjustParameters(nl0, ls0, nl1, ls1, sol);
                        Curve.addIntersection(nl0, nl1, intersections, sol);
                    }
                }
            }
        }
    }
    static adjustParameters(l0, ls0, l1, ls1, sol) {
        if (ls0 !== l0.seg && l0.seg instanceof _polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline === false)
            //l0.seg is not a LineSegment and not a polyline
            sol.aSol = l0.seg.closestParameter(sol.x);
        //we need to find the correct parameter
        else {
            const leaf0 = l0.node;
            sol.aSol = leaf0.low + sol.aSol * (leaf0.high - leaf0.low);
        }
        if (ls1 !== l1.seg && l1.seg instanceof _polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline === false)
            //l1.seg is not a LineSegment and not a polyline
            sol.bSol = l1.seg.closestParameter(sol.x);
        //we need to find the correct parameter
        else {
            const leaf1 = l1.node;
            sol.bSol = leaf1.low + sol.bSol * (leaf1.high - leaf1.low);
        }
    }
    // returns the segment correspoinding to t and the segment parameter
    getSegParam(t) {
        let u = this.parStart; //u is the sum of param domains
        for (const sg of this.segs) {
            const nextu = u + sg.parEnd - sg.parStart;
            if (t >= u && t <= nextu) {
                return {
                    par: t - u + sg.parStart,
                    seg: sg,
                };
            }
            u = nextu;
        }
        const lastSeg = this.segs[this.segs.length - 1];
        return {
            seg: lastSeg,
            par: lastSeg.parEnd,
        };
    }
    /** return the segment index and the parameter inside of the segment */
    getSegIndexParam(t) {
        // because of this implementation we alwais should have seg.parStart >= 0: otherwise the function can return a wrong segment
        let u = 0; //u is the sum of param domains
        const segLen = this.segs.length;
        for (let i = 0; i < segLen; i++) {
            const sg = this.segs[i];
            const nextu = u + sg.parEnd - sg.parStart;
            if (t >= u && t <= nextu) {
                return {
                    segIndex: i,
                    par: t - u + sg.parStart,
                };
            }
            u = nextu;
        }
        const lastSeg = this.segs[segLen - 1];
        return {
            segIndex: segLen - 1,
            par: lastSeg.parEnd,
        };
    }
    // Returns the point on the curve corresponding to parameter t
    value(t) {
        return segParamValue(this.getSegParam(t));
    }
    // first derivative at t
    derivative(t) {
        return segParamDerivative(this.getSegParam(t));
    }
    // second derivative
    secondDerivative(t) {
        return segParamSecondDerivative(this.getSegParam(t));
    }
    // third derivative
    thirdDerivative(t) {
        return segParamThirdDerivative(this.getSegParam(t));
    }
    // For curves A(s) and B(t), when we have some evidence that
    // there is at most one intersection point, and we have a guess for the parameters (s0, t0)...
    // You are trying to bring to (0,0) the vector F(s,t) = A(s) - B(t).  To minimize the length of F(s,t)
    // we solve the system of equations:
    //F*Fs + (F*Fss + Fs*Fs)ds + (F*Fst + Fs*Ft)dt = 0
    //F*Ft + (F*Fst + Fs*Ft)ds + (F*Ftt + Ft*Ft)dt = 0
    //
    //Where F = F(si,ti), Fs and Ft are the first partials at si, ti, Fxx are the second partials,
    //   and s(i+1) = si+ds, t(i+1) = ti+dt.
    //We adjust ds and dt to stay in the domain.
    static crossWithinIntervalsWithGuess(a, b, amin, amax, bmin, bmax, aGuess, bGuess) {
        if (a instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment && b instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment) {
            const r = Curve.crossTwoLineSegs(a.start, a.end, b.start, b.end, amin, amax, bmin, bmax);
            if (r !== undefined)
                return r;
        }
        const mdout = Curve.minDistWithinIntervals(a, b, amin, amax, bmin, bmax, aGuess, bGuess);
        if (mdout == null)
            return;
        const aMinusB = mdout.aX.sub(mdout.bX);
        return aMinusB.dot(aMinusB) >= _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon
            ? undefined
            : {
                aSol: mdout.aSol,
                bSol: mdout.bSol,
                x: _point__WEBPACK_IMPORTED_MODULE_1__.Point.middle(mdout.aX, mdout.bX),
            };
    }
    static crossTwoLineSegs(aStart, aEnd, bStart, bEnd, amin, amax, bmin, bmax) {
        const u = aEnd.sub(aStart);
        const v = bStart.sub(bEnd);
        const w = bStart.sub(aStart);
        const sol = _linearSystem__WEBPACK_IMPORTED_MODULE_8__.LinearSystem2.solve(u.x, v.x, w.x, u.y, v.y, w.y);
        if (sol == null)
            return;
        let aSol = sol.x;
        let bSol = sol.y;
        const x = aStart.add(u.mul(aSol));
        if (aSol < amin - _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance)
            return;
        aSol = Math.max(aSol, amin);
        if (aSol > amax + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance)
            return;
        aSol = Math.min(aSol, amax);
        if (bSol < bmin - _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance)
            return;
        bSol = Math.max(bSol, bmin);
        if (bSol > bmax + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance)
            return;
        bSol = Math.min(bSol, bmax);
        /*Assert.assert(Point.closeDistEps(x, Point.convSum(bSol, bStart, bEnd)))*/
        return {
            aSol: aSol,
            bSol: bSol,
            x: x,
        };
    }
    // Decides if the point lies inside, outside or on the curve
    static PointRelativeToCurveLocation(point, curve) {
        if (!curve.boundingBox.contains(point)) {
            return PointLocation.Outside;
        }
        const l = 2 * curve.boundingBox.diagonal;
        // l should be big enough for the line to exit outside of the curve
        const degree = Math.PI / 180;
        let inside = 0;
        for (let i = 13; i < 360; i += 13) {
            const lineDir = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(Math.cos(i * degree), Math.sin(i * degree));
            const ls = _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(point, point.add(lineDir.mul(l)));
            const intersections = this.getAllIntersectionsOfLineAndICurve(ls, curve, true);
            // SugiyamaLayoutSettings.Show(ls, curve);
            // CurveSerializer.Serialize("cornerC:\\tmp\\ls",ls);
            // CurveSerializer.Serialize("cornerC:\\tmp\\pol",curve);
            if (Curve.AllIntersectionsAreGood(intersections, curve)) {
                for (const xx of intersections) {
                    if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(xx.x, point)) {
                        return PointLocation.Boundary;
                    }
                }
                const insideThisTime = intersections.length % 2 === 1;
                // to be on the safe side we need to get the same result at least twice
                if (insideThisTime) {
                    inside++;
                }
                else {
                    inside--;
                }
                if (inside >= 2) {
                    return PointLocation.Inside;
                }
                if (inside <= -2) {
                    return PointLocation.Outside;
                }
            }
        }
        // if all intersections are not good then we probably have the point on the boundaryCurve
        return PointLocation.Boundary;
    }
    static AllIntersectionsAreGood(intersections, polygon) {
        // If this isn't a Curve, try a Polyline.
        //TODO: fix this to avoid the cast
        const isCurve = polygon.hasOwnProperty('segs');
        let curve = null;
        if (!isCurve) {
            const isPolyLine = polygon instanceof _polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline;
            if (isPolyLine)
                curve = polygon.toCurve();
        }
        if (curve)
            for (const xx of intersections)
                if (!Curve.RealCut(Curve.DropIntersectionToSegs(xx), curve, false))
                    return false;
        return true;
    }
    static RealCut(xx, polyline, onlyFromInsideCuts) {
        const sseg = xx.seg0;
        const pseg = xx.seg1;
        const spar = xx.par0;
        const ppar = xx.par1;
        const x = xx.x;
        // normalised tangent to spline
        const ts = sseg.derivative(spar).normalize();
        const pn = pseg
            .derivative(ppar)
            .normalize()
            .rotate(Math.PI / 2);
        if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(x, pseg.end)) {
            // so pseg enters the spline
            let exitSeg = null;
            for (let i = 0; i < polyline.segs.length - 1; i++) {
                if (polyline.segs[i] === pseg) {
                    exitSeg = polyline.segs[i + 1];
                    break;
                }
            }
            if (exitSeg == null) {
                return false;
            }
            // hit the end of the polyline
            const tsn = ts.rotate(Math.PI / 2);
            const touch = tsn.dot(pseg.derivative(pseg.parEnd)) * tsn.dot(exitSeg.derivative(exitSeg.parStart)) < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance;
            return !touch;
        }
        if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(x, pseg.start)) {
            // so pseg exits the spline
            let enterSeg = null;
            for (let i = polyline.segs.length - 1; i > 0; i--) {
                if (polyline.segs[i] === pseg) {
                    enterSeg = polyline.segs[i - 1];
                    break;
                }
            }
            if (enterSeg == null) {
                return false;
            }
            const tsn = ts.rotate(Math.PI / 2);
            const touch = tsn.dot(pseg.derivative(pseg.parStart)) * tsn.dot(enterSeg.derivative(enterSeg.parEnd)) < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance;
            return !touch;
        }
        const d = ts.dot(pn);
        if (onlyFromInsideCuts) {
            return d > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon;
        }
        return Math.abs(d) > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon;
    }
    //   static boolean debug;
    // Returns true if curves do not touch in the intersection point
    // only when the second curve cuts the first one from the inside</param>
    static realCutWithClosedCurve(xx, polygon, onlyFromInsideCuts) {
        const sseg = xx.seg0;
        const pseg = xx.seg1;
        const spar = xx.par0;
        const ppar = xx.par1;
        const x = xx.x;
        // normalised tangent to spline
        const ts = sseg.derivative(spar).normalize();
        const pn = pseg
            .derivative(ppar)
            .normalize()
            .rotate(Math.PI / 2);
        if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(x, pseg.end)) {
            // so pseg enters the spline
            let exitSeg = null;
            for (let i = 0; i < polygon.segs.length; i++) {
                if (polygon.segs[i] === pseg) {
                    exitSeg = polygon.segs[(i + 1) % polygon.segs.length];
                    break;
                }
            }
            if (exitSeg == null) {
                throw new Error();
            }
            const tsn = ts.rotate(Math.PI / 2);
            const touch = tsn.dot(pseg.derivative(pseg.parEnd)) * tsn.dot(exitSeg.derivative(exitSeg.parStart)) < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance;
            return !touch;
        }
        if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(x, pseg.start)) {
            // so pseg exits the spline
            let enterSeg = null;
            for (let i = 0; i < polygon.segs.length; i++) {
                if (polygon.segs[i] === pseg) {
                    enterSeg = polygon.segs[i > 0 ? i - 1 : polygon.segs.length - 1];
                    break;
                }
            }
            const tsn = ts.rotate(Math.PI / 2);
            const touch = tsn.dot(pseg.derivative(pseg.parStart)) * tsn.dot(enterSeg.derivative(enterSeg.parEnd)) < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance;
            return !touch;
        }
        const d = ts.dot(pn);
        if (onlyFromInsideCuts) {
            return d > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon;
        }
        return Math.abs(d) > _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon;
    }
    /*
    
    if (Point.closeDistEps(x, pseg.start)) {
    //so pseg exits the spline
    ICurve enterSeg = null;
    for (int i = polyline.segs.length - 1; i > 0; i--)
    if (polyline.segs[i] === pseg) {
    enterSeg = polyline.segs[i - 1];
    break;
    }
    if (enterSeg == null )
    return false;
    Point tsn = ts.rotate((Math.PI/2));
    boolean touch = (tsn*pseg.derivative(pseg.Parstart))*
    (tsn*enterSeg.derivative(enterSeg.parEnd)) < GeomConstants.tolerance;
    
    return !touch;
    }
    
    number d = ts*pn;
    if (onlyFromInsideCuts)
    return d > GeomConstants.distanceEpsilon;
    return Math.Abs(d) > GeomConstants.distanceEpsilon;
    }
    */
    static minDistWithinIntervals(a, b, aMin, aMax, bMin, bMax, aGuess, bGuess) {
        const md = new _minDistCurveCurve__WEBPACK_IMPORTED_MODULE_9__.MinDistCurveCurve(a, b, aMin, aMax, bMin, bMax, aGuess, bGuess);
        md.solve();
        return md.success
            ? {
                aSol: md.aSolution,
                bSol: md.bSolution,
                aX: md.aPoint,
                bX: md.bPoint,
            }
            : undefined;
    }
    /*
        #if DEBUGCURVES
        public override string ToString()
        {
        boolean poly = true;
        for (ICurve s of segs)
        if (s is LineSeg === false)
        {
        poly = false;
        break;
        }
        
        string ret;
        if (!poly)
        {
        ret = "{";
        
        for (ICurve seg of Segs)
        {
        ret += seg + ",";
        }
        
        
        return ret + "}";
        }
        ret = "{";
        if (segs.length > 0)
        ret += segs[0].start.x.ToString() + "," + segs[0].start.y.ToString()+" ";
        for(LineSeg s of segs)
        ret += s.end.x.ToString() + "," + s.end.y.ToString() + " ";
        return ret + "}";
        }
        #endif
     */
    // Offsets the curve in the direction of dir
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    offsetCurve(offset, dir) {
        throw new Error('Method not implemented.');
        return null;
    }
    /**
     * The bounding rectangle of the curve
     */
    get boundingBox() {
        if (this.boundingBox_)
            return this.boundingBox_;
        if (this.segs.length === 0) {
            this.boundingBox_ = _rectangle__WEBPACK_IMPORTED_MODULE_10__.Rectangle.mkEmpty();
        }
        else {
            const b = this.segs[0].boundingBox.clone();
            for (let i = 1; i < this.segs.length; i++)
                b.addRecSelf(this.segs[i].boundingBox);
            return (this.boundingBox_ = b);
        }
    }
    /**  clones the curve */
    clone() {
        const c = new Curve();
        for (const seg of this.segs)
            c.addSegment(seg.clone());
        if (this.boundingBox_ != null) {
            c.boundingBox_ = this.boundingBox_.clone();
        }
        return c;
    }
    getParameterAtLength(length) {
        let parSpan = 0.0;
        for (const seg of this.segs) {
            const segL = seg.length;
            if (segL >= length)
                return parSpan + seg.getParameterAtLength(length);
            length -= segL;
            parSpan += seg.parEnd - seg.parStart;
        }
        return this.parEnd;
    }
    get length() {
        let r = 0;
        for (const s of this.segs)
            r += s.length;
        return r;
    }
    /** returns a new curve */
    transform(transformation) {
        const c = new Curve();
        for (const s of this.segs) {
            c.addSegment(s.transform(transformation));
        }
        if (this.boundingBox_) {
            c.boundingBox_ = this.boundingBox_.transform(transformation);
        }
        return c;
    }
    // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
    // and t belongs to the closed segment [low,high]
    closestParameterWithinBounds(targetPoint, low, high) {
        let par = 0;
        let dist = Number.MAX_VALUE;
        let offset = 0;
        for (const seg of this.segs) {
            if (offset > high)
                break; //we are out of the [low, high] segment
            const segparamSpan = Curve.paramSpan(seg);
            const segEnd = offset + segparamSpan;
            if (segEnd >= low) {
                //we are in business
                const segLow = Math.max(seg.parStart, seg.parStart + (low - offset));
                const segHigh = Math.min(seg.parEnd, seg.parStart + (high - offset));
                /*Assert.assert(segHigh >= segLow)*/
                const t = seg.closestParameterWithinBounds(targetPoint, segLow, segHigh);
                const d = targetPoint.sub(seg.value(t));
                const dd = d.dot(d);
                if (dd < dist) {
                    par = offset + t - seg.parStart;
                    dist = dd;
                }
            }
            offset += segparamSpan;
        }
        return par;
    }
    // returns a parameter t such that the distance between curve[t] and a is minimal
    closestParameter(targetPoint) {
        let par = 0;
        let dist = Number.MAX_VALUE;
        let offset = 0;
        for (const c of this.segs) {
            const t = c.closestParameter(targetPoint);
            const d = targetPoint.sub(c.value(t));
            const dd = d.dot(d);
            if (dd < dist) {
                par = offset + t - c.parStart;
                if (dd === 0) {
                    break; // cannot beat 0!
                }
                dist = dd;
            }
            offset += Curve.paramSpan(c);
        }
        return par;
    }
    static addLineSegment(curve, pointA, pointB) {
        return curve.addSegment(_lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(pointA, pointB));
    }
    static addLineSegmentCNNP(c, x, y, b) {
        return Curve.addLineSegment(c, new _point__WEBPACK_IMPORTED_MODULE_1__.Point(x, y), b);
    }
    // adds a line segment to the curve
    static addLineSegmentCNNNN(curve, x0, y0, x1, y1) {
        Curve.addLineSegment(curve, new _point__WEBPACK_IMPORTED_MODULE_1__.Point(x0, y0), new _point__WEBPACK_IMPORTED_MODULE_1__.Point(x1, y1));
    }
    // adds a line segment to the curve
    static continueWithLineSegmentNN(c, x, y) {
        Curve.addLineSegment(c, c.end, new _point__WEBPACK_IMPORTED_MODULE_1__.Point(x, y));
    }
    // adds a line segment to the curve
    static continueWithLineSegmentP(c, x) {
        Curve.addLineSegment(c, c.end, x);
    }
    static closeCurve(curve) {
        Curve.continueWithLineSegmentP(curve, curve.start);
        return curve;
    }
    // left derivative at t
    leftDerivative(t) {
        const seg = this.tryToGetLeftSegment(t);
        if (seg != null)
            return seg.derivative(seg.parEnd);
        return this.derivative(t);
    }
    // right derivative at t
    rightDerivative(t) {
        const seg = this.tryToGetRightSegment(t);
        if (seg != null)
            return seg.derivative(seg.parStart);
        return this.derivative(t);
    }
    tryToGetLeftSegment(t) {
        if (Math.abs(t - this.parStart) < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance) {
            if (this.start.equal(this.end))
                return this.segs[this.segs.length - 1];
            return null;
        }
        for (const seg of this.segs) {
            t -= Curve.paramSpan(seg);
            if (Math.abs(t) < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance)
                return seg;
        }
        return null;
    }
    tryToGetRightSegment(t) {
        if (Math.abs(t - this.parEnd) < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance) {
            if (this.start === this.end)
                return this.segs[0];
            return null;
        }
        for (const seg of this.segs) {
            if (Math.abs(t) < _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.tolerance)
                return seg;
            t -= Curve.paramSpan(seg);
        }
        return null;
    }
    /*
         // gets the closest point together with its parameter
         public static number closestParameterWithPoint(ICurve curve, Point location, out Point pointOnCurve) {
  
         number t = curve.closestParameter(location);
         pointOnCurve = curve[t];
         return t;
         }
         */
    // gets the point on the curve that is closest to the given point
    static ClosestPoint(curve, location) {
        return curve.value(curve.closestParameter(location));
    }
    // Tests whether the first curve is inside the second.
    // We suppose that the curves are convex and they are
    // not degenerated into a point
    static CurveIsInsideOther(innerCurve, outerCurve) {
        if (!outerCurve.boundingBox.containsRect(innerCurve.boundingBox)) {
            return false;
        }
        const xx = Curve.getAllIntersections(innerCurve, outerCurve, true);
        if (xx.length === 0) {
            return Curve.NonIntersectingCurveIsInsideOther(innerCurve, outerCurve);
        }
        if (xx.length === 1)
            //it has to be a touch
            return !innerCurve.start.equal(xx[0].x)
                ? Curve.PointRelativeToCurveLocation(innerCurve.start, outerCurve) === PointLocation.Inside
                : Curve.PointRelativeToCurveLocation(innerCurve.value((innerCurve.parStart + innerCurve.parEnd) / 2), outerCurve) ==
                    PointLocation.Inside;
        for (const p of Curve.PointsBetweenIntersections(innerCurve, xx)) {
            if (Curve.PointRelativeToCurveLocation(p, outerCurve) === PointLocation.Outside) {
                return false;
            }
        }
        return true;
    }
    // Return points between but not including the intersections.
    static *PointsBetweenIntersections(a, xx) {
        xx.sort((x, y) => x.par0 - y.par0);
        for (let i = 0; i < xx.length - 1; i++) {
            yield a.value((xx[i].par0 + xx[i + 1].par0) / 2);
        }
        // take care of the last interval
        const start = xx[xx.length - 1].par0;
        const end = xx[0].par0;
        const len = a.parEnd - start + (end - a.parStart);
        let middle = start + len / 2;
        if (middle > a.parEnd) {
            middle = a.parStart + (middle - a.parEnd);
        }
        yield a.value(middle);
    }
    static NonIntersectingCurveIsInsideOther(a, b) {
        // Due to rounding, even curves with 0 intersections may return Boundary.
        for (let par = a.parStart; par < a.parEnd; par += 0.5) {
            // continue as long as we have boundary points.
            const parLoc = Curve.PointRelativeToCurveLocation(a.value(par), b);
            if (PointLocation.Boundary !== parLoc) {
                return PointLocation.Inside === parLoc;
            }
        }
        // All points so far were on border so it is not considered inside; test the End.
        return PointLocation.Outside !== Curve.PointRelativeToCurveLocation(a.end, b);
    }
    // Tests whether the interiors of two closed convex curves intersect
    static ClosedCurveInteriorsIntersect(c1, c2) {
        if (!c2.boundingBox.intersects(c1.boundingBox)) {
            return false;
        }
        const xx = Curve.getAllIntersections(c1, c2, true);
        if (xx.length === 0) {
            return Curve.NonIntersectingCurveIsInsideOther(c1, c2) || Curve.NonIntersectingCurveIsInsideOther(c2, c1);
        }
        if (xx.length === 1) {
            //it is a touch
            return !c1.start.equal(xx[0].x)
                ? Curve.PointRelativeToCurveLocation(c1.start, c2) === PointLocation.Inside
                : Curve.PointRelativeToCurveLocation(c1.value((c1.parStart + c1.parEnd) / 2), c2) === PointLocation.Inside ||
                    !c2.start.equal(xx[0].x)
                    ? Curve.PointRelativeToCurveLocation(c2.start, c1) === PointLocation.Inside
                    : Curve.PointRelativeToCurveLocation(c2.value((c2.parStart + c2.parEnd) / 2), c1) === PointLocation.Inside;
        }
        for (const p of Curve.PointsBetweenIntersections(c1, xx)) {
            if (Curve.PointRelativeToCurveLocation(p, c2) === PointLocation.Inside) {
                return true;
            }
        }
        return true;
    }
    // ICurve Members
    curvature(t) {
        const sp = this.getSegParam(t);
        return sp.seg.curvature(sp.par);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    curvatureDerivative(t) {
        throw new Error('Not implemente');
    }
    //
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    curvatureSecondDerivative(t) {
        throw new Error('Not implemented');
    }
    /*  #endregion
         
         public static boolean CurvesIntersect(ICurve curve1, ICurve curve2) {
         return curve1 === curve2 || (CurveCurveIntersectionOne(curve1, curve2, false) != null);
         }
         */
    static createBezierSeg(kPrev, kNext, a, b, c) {
        const s = _point__WEBPACK_IMPORTED_MODULE_1__.Point.mkPoint(kPrev, a.point, 1 - kPrev, b.point);
        const e = _point__WEBPACK_IMPORTED_MODULE_1__.Point.mkPoint(kNext, c.point, 1 - kNext, b.point);
        const t = b.point.mul(2.0 / 3.0);
        return new _bezierSeg__WEBPACK_IMPORTED_MODULE_11__.BezierSeg(s, s.div(3.0).add(t), t.add(e.div(3.0)), e);
    }
    static createBezierSegN(a, b, perp, i) {
        const d = perp.mul(i);
        return new _bezierSeg__WEBPACK_IMPORTED_MODULE_11__.BezierSeg(a, a.add(d), b.add(d), b);
    }
    static findCorner(a) {
        const b = a.next;
        if (b.next == null)
            return; //no corner has been found
        const c = b.next;
        if (c == null)
            return;
        return { b: b, c: c };
    }
    static trimEdgeSplineWithNodeBoundaries(sourceBoundary, targetBoundary, spline, narrowestInterval) {
        let start = spline.parStart;
        let end = spline.parEnd;
        if (sourceBoundary != null)
            start = Curve.findNewStart(spline, start, sourceBoundary, narrowestInterval);
        if (targetBoundary != null)
            end = Curve.findNewEnd(spline, targetBoundary, narrowestInterval, end);
        const st = Math.min(start, end);
        const en = Math.max(start, end);
        return st < en ? spline.trim(st, en) : spline;
    }
    static findNewEnd(spline, targetBoundary, narrowestInterval, end) {
        //SugiyamaLayoutSettings.Show(c, spline);
        const intersections = Curve.getAllIntersections(spline, targetBoundary, true);
        if (intersections.length === 0) {
            end = spline.parEnd;
            return end;
        }
        if (narrowestInterval) {
            end = spline.parEnd;
            for (const xx of intersections)
                if (xx.par0 < end)
                    end = xx.par0;
        }
        else {
            //looking for the last intersection
            end = spline.parStart;
            for (const xx of intersections)
                if (xx.par0 > end)
                    end = xx.par0;
        }
        return end;
    }
    static findNewStart(spline, start, sourceBoundary, narrowestInterval) {
        const intersections = Curve.getAllIntersections(spline, sourceBoundary, true);
        if (intersections.length === 0) {
            start = spline.parStart;
            return;
        }
        if (narrowestInterval) {
            start = spline.parStart;
            for (const xx of intersections)
                if (xx.par0 > start)
                    start = xx.par0;
        }
        else {
            start = spline.parEnd;
            for (const xx of intersections)
                if (xx.par0 < start)
                    start = xx.par0;
        }
        return start;
    }
    static polylineAroundClosedCurve(curve) {
        if (curve instanceof _ellipse__WEBPACK_IMPORTED_MODULE_5__.Ellipse)
            return Curve.refineEllipse(curve);
        if (curve instanceof _polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline)
            return curve;
        if (curve instanceof Curve && Curve.allSegsAreLines(curve)) {
            const ret = new _polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline();
            for (const ls of curve.segs)
                ret.addPoint(ls.start);
            ret.closed = true;
            if (!ret.isClockwise())
                return ret.reverse();
        }
        return curve.boundingBox.perimeter();
    }
    static allSegsAreLines(c) {
        for (const s of c.segs)
            if (!(s instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment))
                return false;
        return true;
    }
    // this code only works for the standard ellipse
    static refineEllipse(ellipse) {
        const rect = ellipse.boundingBox.perimeter();
        const a = Math.PI / 4;
        const w = ellipse.boundingBox.width;
        const h = ellipse.boundingBox.height;
        const l = Math.sqrt(w * w + h * h);
        const xs = [];
        for (let i = 0; i < 4; i++) {
            const t = a + (i * Math.PI) / 2; // parameter
            const p = ellipse.value(t); //point on the ellipse
            const tan = ellipse.derivative(t).normalize().mul(l); //make it long enough
            const ls = _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(p.sub(tan), p.add(tan));
            for (const x of Curve.getAllIntersections(rect, ls, true))
                xs.push(x);
        }
        /*Assert.assert(xs.length > 0)*/
        xs.sort((a, b) => (a.par0 < b.par0 ? -1 : a.par0 > b.par0 ? 1 : 0));
        const ret = new _polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline();
        xs.forEach((x) => ret.addPoint(x.x));
        ret.closed = true;
        return ret;
    }
    // Create a closed Polyline from a rectangle
    static polyFromBox(rectangle) {
        const p = new _polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline();
        p.addPoint(rectangle.leftTop);
        p.addPoint(rectangle.rightTop);
        p.addPoint(rectangle.rightBottom);
        p.addPoint(rectangle.leftBottom);
        p.closed = true;
        return p;
    }
}
// a, b are parameters of the curve
function isCloseToLineSeg(a, ap, b, bp, s, e) {
    /*Assert.assert(Point.closeDistEps(s.value(a), ap))*/
    /*Assert.assert(Point.closeDistEps(s.value(b), bp))*/
    if (s instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment)
        return true;
    for (const x of [1 / 3, 0.5, 2 / 3]) {
        const p = a * x + b * (1 - x); // the parameter on the curve s
        const pointsAreClose = _point__WEBPACK_IMPORTED_MODULE_1__.Point.closeSquare(s.value(p), _point__WEBPACK_IMPORTED_MODULE_1__.Point.mkPoint(x, ap, 1 - x, bp), e * e);
        if (pointsAreClose === false) {
            return false;
        }
    }
    return true;
}
// interpolates the curve between parameters 'a' and 'b' by a sequence of line segments
function interpolate(a, ap, b, bp, s, eps) {
    /*Assert.assert(Point.closeDistEps(s.value(a), ap))*/
    /*Assert.assert(Point.closeDistEps(s.value(b), bp))*/
    let r = [];
    if (isCloseToLineSeg(a, ap, b, bp, s, eps)) {
        r.push(ap);
        r.push(bp);
    }
    else {
        const m = 0.5 * (a + b);
        const mp = s.value(m);
        r = interpolate(a, ap, m, mp, s, eps);
        const tail = interpolate(m, mp, b, bp, s, eps).slice(1);
        r = r.concat(tail);
    }
    return r;
}
function interpolateICurve(s, eps) {
    return interpolate(s.parStart, s.start, s.parEnd, s.end, s, eps);
}
/** Iterate over all icurve subsegments that intersect the given rectangle.
 * The function might return subsegments that are running outside of the rectangle
 *  but still close to its border.
 *
 * Should be removed
 */
function* clipWithRectangle(curve, rect) {
    if (rect.containsRectWithPadding(curve.boundingBox, 1)) {
        yield curve;
        return;
    }
    const perimeter = rect.perimeter();
    const x = Curve.getAllIntersections(curve, perimeter, true);
    if (x.length == 0) {
        if (rect.contains(curve.start))
            yield curve;
        return;
    }
    x.sort((x, y) => x.par0 - y.par0);
    const xs = [curve.parStart];
    let i = 0;
    for (; i < x.length; i++) {
        const ii = x[i];
        if (ii.par0 > xs[xs.length - 1] + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon) {
            xs.push(ii.par0);
        }
    }
    if (curve.parEnd > xs[xs.length - 1] + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon) {
        xs.push(curve.parEnd);
    }
    for (i = 0; i < xs.length - 1; i++) {
        if (segmentShouldBeIncluded(curve, xs[i], xs[i + 1], rect)) {
            const seg = curve.trim(xs[i], xs[i + 1]);
            yield seg;
        }
    }
}
/** Looking for all subsegments of of 'curve' intersecting 'rect'
 *  For each such a segment return {start:a, end:b} such that segment = curve.trim(a,b)
 */
function* clipWithRectangleInsideInterval(curve, rect) {
    if (curve == null)
        return;
    if (rect.containsRect(curve.boundingBox)) {
        yield curve;
        return;
    }
    const xs = Curve.getAllIntersections(curve, rect.perimeter(), true);
    // // debug
    // for (const x of xs) {
    //   Assert.assert(Point.closeDistEps(x.x, curve.value(x.par0)))
    //   // Assert.assert(Point.closeDistEps(x.x, origCurvDebug.value(x.par0)))
    // }
    if (xs.length == 0) {
        if (rect.contains(curve.start))
            yield curve;
        return;
    }
    xs.sort((x, y) => x.par0 - y.par0);
    const filteredXs = [curve.parStart];
    let i = 0;
    for (; i < xs.length; i++) {
        const ii = xs[i];
        if (ii.par0 > filteredXs[filteredXs.length - 1] + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon) {
            filteredXs.push(ii.par0);
        }
    }
    if (curve.parEnd > filteredXs[filteredXs.length - 1] + _geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon) {
        filteredXs.push(curve.parEnd);
    }
    for (i = 0; i < filteredXs.length - 1; i++) {
        if (segmentShouldBeIncluded(curve, filteredXs[i], filteredXs[i + 1], rect)) {
            const tr = curve.trim(filteredXs[i], filteredXs[i + 1]);
            if (tr)
                yield tr;
        }
    }
}
/** Check the points curve[a+(b-a)/5],[a+2*(b-a)/5], [a+3*(b-a)/5], [a+4*(b-a)/5]
 *  If at least one of them is inside of the rect return true, otherwise return false
 */
function segmentShouldBeIncluded(curve, a, b, rect) {
    const del = (b - a) / 5;
    for (let i = 1; i < 5; i++) {
        const t = a + del * i;
        if (rect.contains(curve.value(t)))
            return true;
    }
    return false;
}
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/curveFactory.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CurveFactory: () => (/* binding */ CurveFactory)
/* harmony export */ });
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _lineSegment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _planeTransformation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/planeTransformation.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");






class CurveFactory {
    static mkEllipse(rx, ry, center) {
        return _ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse.mkFullEllipseNNP(rx, ry, center);
    }
    static createParallelogram(width, height, center) {
        const h = height / 2;
        const w = width / 2;
        const x = center.x;
        const y = center.y;
        const angle = (80 * Math.PI) / 180;
        const deltax = h / Math.tan(angle);
        const poly = ___WEBPACK_IMPORTED_MODULE_5__.Polyline.mkClosedFromPoints([
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(-w - deltax + x, -h + y),
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(w + x, -h + y),
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(w + x + deltax, h + y),
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(-w + x, h + y),
        ]);
        return poly;
    }
    static createHexagon(width, height, center) {
        const h = height / 2;
        const w = width / 2;
        const x = center.x;
        const y = center.y;
        const poly = ___WEBPACK_IMPORTED_MODULE_5__.Polyline.mkClosedFromPoints([
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(-w + x, -h + y),
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(w + x, -h + y),
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(w + (h + x), 0 + y),
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(w + x, h + y),
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(-w + x, h + y),
            new _point__WEBPACK_IMPORTED_MODULE_2__.Point(-(w - h) + x, 0 + y),
        ]);
        return poly;
    }
    static createOctagon(width, height, center) {
        const w = width / 2;
        const h = height / 2;
        const ps = new Array(8);
        // Pad out horizontally
        ps[0] = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(w + CurveFactory.octagonPad * w, h - h * CurveFactory.octagonPad);
        ps[3] = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(ps[0].x * -1, ps[0].y);
        ps[4] = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(ps[3].x, ps[3].y * -1);
        ps[7] = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(ps[0].x, ps[0].y * -1);
        // Pad out vertically
        ps[1] = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(w - w * CurveFactory.octagonPad, h + h * CurveFactory.octagonPad);
        ps[2] = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(ps[1].x * -1, ps[1].y);
        ps[6] = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(ps[1].x, ps[1].y * -1);
        ps[5] = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(ps[2].x, ps[2].y * -1);
        for (let i = 0; i < 8; i++) {
            ps[i] = ps[i].add(center);
        }
        return ___WEBPACK_IMPORTED_MODULE_5__.Polyline.mkClosedFromPoints(ps);
    }
    static createInvertedHouse(width, height, center) {
        const shape = CurveFactory.createHouse(width, height, center);
        return CurveFactory.rotateCurveAroundCenterByDegree(shape, center, 180);
    }
    static createHouse(width, height, center) {
        const w = width / 2;
        const h = height / 2;
        const x = center.x;
        const y = center.y;
        const c = new _curve__WEBPACK_IMPORTED_MODULE_1__.Curve();
        _curve__WEBPACK_IMPORTED_MODULE_1__.Curve.addLineSegmentCNNNN(c, x - w, y - h, x + w, y - h);
        _curve__WEBPACK_IMPORTED_MODULE_1__.Curve.continueWithLineSegmentNN(c, x + w, y + h);
        _curve__WEBPACK_IMPORTED_MODULE_1__.Curve.continueWithLineSegmentNN(c, x, y + 2 * h);
        _curve__WEBPACK_IMPORTED_MODULE_1__.Curve.continueWithLineSegmentNN(c, x - w, y + h);
        return _curve__WEBPACK_IMPORTED_MODULE_1__.Curve.closeCurve(c);
    }
    static mkDiamond(width, height, center) {
        const w = width;
        const h = height;
        const x = center.x;
        const y = center.y;
        const c = new _curve__WEBPACK_IMPORTED_MODULE_1__.Curve();
        const p = [new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x, y - h), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x + w, y), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x, y + h), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x - w, y)];
        c.addSegs([_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p[0], p[1]), _lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p[1], p[2]), _lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p[2], p[3]), _lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p[3], p[0])]);
        return c;
    }
    static rotateCurveAroundCenterByDegree(curve, center, angle) {
        return CurveFactory.rotateCurveAroundCenterByRadian(curve, center, (angle * Math.PI) / 180);
    }
    static rotateCurveAroundCenterByRadian(curve, center, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const transform = new _planeTransformation__WEBPACK_IMPORTED_MODULE_4__.PlaneTransformation(1, 0, center.x, 0, 1, center.y)
            .multiply(new _planeTransformation__WEBPACK_IMPORTED_MODULE_4__.PlaneTransformation(c, -s, 0, s, c, 0))
            .multiply(new _planeTransformation__WEBPACK_IMPORTED_MODULE_4__.PlaneTransformation(1, 0, -center.x, 0, 1, -center.y));
        return curve.transform(transform);
    }
    static mkCircle(radius, center) {
        return _ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse.mkCircle(radius, center);
    }
    static createRectangle(width, height, center) {
        const w = width / 2;
        const h = height / 2;
        const x = center.x;
        const y = center.y;
        const c = new _curve__WEBPACK_IMPORTED_MODULE_1__.Curve();
        const p = [new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x - w, y - h), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x + w, y - h), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x + w, y + h), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x - w, y + h)];
        c.addSegs([_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p[0], p[1]), _lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p[1], p[2]), _lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p[2], p[3]), _lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(p[3], p[0])]);
        return c;
    }
    static isRoundedRect(ic) {
        if (!(ic instanceof _curve__WEBPACK_IMPORTED_MODULE_1__.Curve))
            return;
        const segs = ic.segs;
        if (segs.length !== 8 && segs.length !== 4)
            return;
        const full = segs.length === 8 ? true : false;
        let radX;
        let radY;
        for (let k = 0; k < 4; k++) {
            const i = full ? 2 * k + 1 : k;
            if (k === 0) {
                if (!(segs[i] instanceof _ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse)) {
                    return;
                }
                const el = segs[i];
                radX = el.aAxis.length;
                radY = el.bAxis.length;
            }
            else {
                if (!(segs[i] instanceof _ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse)) {
                    return;
                }
                const el = segs[i];
                if (radX !== el.aAxis.length || radY !== el.bAxis.length)
                    return;
            }
            // some more checks are missing!
        }
        return {
            radX: radX,
            radY: radY,
        };
    }
    static mkRectangleWithRoundedCorners(width, height, radX, radY, center = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(0, 0)) {
        if (radX === 0 || radY === 0) {
            return CurveFactory.createRectangle(width, height, center);
        }
        const c = new _curve__WEBPACK_IMPORTED_MODULE_1__.Curve();
        const w = width / 2;
        if (radX > w / 2)
            radX = w / 2;
        const h = height / 2;
        if (radY > h / 2)
            radY = h / 2;
        const x = center.x;
        const y = center.y;
        const ox = w - radX;
        const oy = h - radY;
        const top = y + h;
        const bottom = y - h;
        const left = x - w;
        const right = x + w;
        //ellipse's axises
        const a = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(radX, 0);
        const b = new _point__WEBPACK_IMPORTED_MODULE_2__.Point(0, radY);
        if (ox > 0)
            c.addSegment(_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x - ox, bottom), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x + ox, bottom)));
        c.addSegment(_ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse.mkEllipse(1.5 * Math.PI, 2 * Math.PI, a, b, x + ox, y - oy));
        if (oy > 0)
            c.addSegment(_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(new _point__WEBPACK_IMPORTED_MODULE_2__.Point(right, y - oy), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(right, y + oy)));
        c.addSegment(_ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse.mkEllipse(0, 0.5 * Math.PI, a, b, x + ox, y + oy));
        if (ox > 0)
            c.addSegment(_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x + ox, top), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(x - ox, top)));
        c.addSegment(_ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse.mkEllipse(0.5 * Math.PI, Math.PI, a, b, x - ox, y + oy));
        if (oy > 0)
            c.addSegment(_lineSegment__WEBPACK_IMPORTED_MODULE_3__.LineSegment.mkPP(new _point__WEBPACK_IMPORTED_MODULE_2__.Point(left, y + oy), new _point__WEBPACK_IMPORTED_MODULE_2__.Point(left, y - oy)));
        c.addSegment(_ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse.mkEllipse(Math.PI, 1.5 * Math.PI, a, b, x - ox, y - oy));
        return c;
    }
}
// This adds the padding to the edges around the inscribed rectangle of an octagon.
CurveFactory.octagonPad = 1.0 / 4;
//# sourceMappingURL=curveFactory.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/debugCurve.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DebugCurve: () => (/* binding */ DebugCurve),
/* harmony export */   DebugObject: () => (/* binding */ DebugObject)
/* harmony export */ });
// define a reference to a function that will be set by the caller
// to dump the debug curves to a file
const DebugObject = {
    dumpDebugCurves: null,
};
class DebugCurve {
    clone() {
        const r = new DebugCurve();
        r.transparency = this.transparency;
        r.width = this.width;
        r.color = this.color;
        r.icurve = this.icurve.clone();
        r.label = this.label;
        r.dashArray = this.dashArray;
        r.drawPN = this.drawPN;
        return r;
    }
    static mkDebugCurveTWCILD(transparency, width, color, curve, label, dashArray, drawPN = false) {
        const r = new DebugCurve();
        r.transparency = transparency;
        r.width = width;
        r.color = color;
        r.icurve = curve;
        r.label = label;
        r.dashArray = dashArray;
        r.drawPN = drawPN;
        return r;
    }
    static mkDebugCurveTWCI(transparency, width, color, curve) {
        return DebugCurve.mkDebugCurveTWCILD(transparency, width, color, curve, null, null);
    }
    static mkDebugCurveWCI(width, color, curve) {
        return DebugCurve.mkDebugCurveTWCI(255, width, color, curve);
    }
    static mkDebugCurveCI(color, curve) {
        return DebugCurve.mkDebugCurveWCI(1, color, curve);
    }
    static mkDebugCurveI(curve) {
        return DebugCurve.mkDebugCurveCI('Black', curve);
    }
}
// color strings for debugging
DebugCurve.colors = [
    'DeepSkyBlue',
    'IndianRed',
    'Orange',
    'Gold',
    'DarkRed',
    'Plum',
    'Red',
    'Violet',
    'Indigo',
    'Yellow',
    'OrangeRed',
    'Tomato',
    'Purple',
    'SaddleBrown',
    'Green',
    'Navy',
    'Aqua',
    'Pink',
    'Bisque',
    'Black',
    'BlanchedAlmond',
    'Blue',
    'BlueViolet',
    'Brown',
    'Lime',
    'BurlyWood',
    'Chocolate',
    'Coral',
    'CornflowerBlue',
    'Cornsilk',
    'Crimson',
    'Cyan',
    'CadetBlue',
    'Chartreuse',
    'DarkBlue',
    'DarkCyan',
    'DarkGoldenrod',
    'DarkGray',
    'DarkGreen',
    'DarkKhaki',
    'DarkMagenta',
    'DarkOliveGreen',
    'DarkOrange',
    'DarkOrchid',
    'DarkSalmon',
    'DarkSeaGreen',
    'DarkSlateBlue',
    'DarkSlateGray',
    'DarkTurquoise',
    'DarkViolet',
    'DeepPink',
    'DimGray',
    'DodgerBlue',
    'Firebrick',
    'FloralWhite',
    'ForestGreen',
    'Fuchsia',
    'CodeAnalysis',
    'Gainsboro',
    'GhostWhite',
    'Goldenrod',
    'Gray',
    'GreenYellow',
    'Honeydew',
    'HotPink',
    'Ivory',
    'Lavender',
    'LavenderBlush',
    'LawnGreen',
    'LemonChiffon',
    'LightBlue',
    'LightCoral',
    'LightCyan',
    'LightGoldenrodYellow',
    'LightGray',
    'LightGreen',
    'LightPink',
    'LightSalmon',
    'LightSeaGreen',
    'LightSkyBlue',
    'LightSlateGray',
    'LightSteelBlue',
    'LightYellow',
    'LimeGreen',
    'Linen',
    'Magenta',
    'Maroon',
    'MediumAquamarine',
    'MediumBlue',
    'MediumOrchid',
    'MediumPurple',
    'MediumSeaGreen',
    'MediumSlateBlue',
    'MediumSpringGreen',
    'MediumTurquoise',
    'MediumVioletRed',
    'MidnightBlue',
    'MintCream',
    'MistyRose',
    'Moccasin',
    'NavajoWhite',
    'OldLace',
    'Olive',
    'OliveDrab',
    'Orchid',
    'PaleGoldenrod',
    'PaleGreen',
    'PaleTurquoise',
    'PaleVioletRed',
    'PapayaWhip',
    'PeachPuff',
    'Peru',
    'PowderBlue',
    'RosyBrown',
    'RoyalBlue',
    'Salmon',
    'SandyBrown',
    'SeaGreen',
    'CodeAnalysis',
    'SeaShell',
    'Sienna',
    'Silver',
    'SkyBlue',
    'SlateBlue',
    'SlateGray',
    'Snow',
    'SpringGreen',
    'SteelBlue',
    'Tan',
    'Teal',
    'Thistle',
    'Transparent',
    'Turquoise',
    'Aquamarine',
    'Azure',
    'Beige',
    'Wheat',
    'White',
    'WhiteSmoke',
    'YellowGreen',
    'Khaki',
    'AntiqueWhite',
];
//# sourceMappingURL=debugCurve.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/direction.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Direction: () => (/* binding */ Direction)
/* harmony export */ });
// enumerates the compass directions
var Direction;
(function (Direction) {
    Direction[Direction["None"] = 0] = "None";
    Direction[Direction["North"] = 1] = "North";
    Direction[Direction["East"] = 2] = "East";
    Direction[Direction["South"] = 4] = "South";
    Direction[Direction["West"] = 8] = "West";
})(Direction || (Direction = {}));
//# sourceMappingURL=direction.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/ellipse.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ellipse: () => (/* binding */ Ellipse)
/* harmony export */ });
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _parallelogramNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogramNode.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _closestPointOnCurve__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/closestPointOnCurve.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");







class Ellipse {
    isFullEllipse() {
        return this.parEnd === Math.PI * 2 && this.parStart === 0;
    }
    static fromJSON(eData) {
        return new Ellipse(eData.parStart, eData.parEnd, _point__WEBPACK_IMPORTED_MODULE_3__.Point.fromJSON(eData.axis0), _point__WEBPACK_IMPORTED_MODULE_3__.Point.fromJSON(eData.axis1), _point__WEBPACK_IMPORTED_MODULE_3__.Point.fromJSON(eData.center));
    }
    toJSON() {
        return {
            parStart: this.parStart,
            parEnd: this.parEnd,
            axis0: this.aAxis.toJSON(),
            axis1: this.bAxis.toJSON(),
            center: this.center.toJSON(),
        };
    }
    /** offsets the curve in the given direction */
    offsetCurve(offset, dir) {
        /**is dir inside or outside of the ellipse */
        const d = dir.sub(this.center);
        const angle = _point__WEBPACK_IMPORTED_MODULE_3__.Point.angle(this.aAxis, d);
        const s = this.aAxis.mul(Math.cos(angle)).add(this.bAxis.mul(Math.sin(angle)));
        if (s.length < d.length) {
            const al = this.aAxis.length;
            const bl = this.bAxis.length;
            return Ellipse.mkEllipsePPP(this.aAxis.normalize().mul(al + offset), this.bAxis.normalize().mul(bl + offset), this.center);
        }
        {
            const al = this.aAxis.length;
            const bl = this.bAxis.length;
            return Ellipse.mkEllipsePPP(this.aAxis.normalize().mul(al - offset), this.bAxis.normalize().mul(bl - offset), this.center);
        }
    }
    /** Reverse the ellipe: not implemented. */
    reverse() {
        return null; // throw new Exception("not implemented");
    }
    static mkEllipsePPP(a, b, center) {
        return new Ellipse(0, Math.PI * 2, a, b, center);
    }
    constructor(parStart, parEnd, axis0, axis1, center) {
        //   assert(parStart <= parEnd);
        this.parStart = parStart;
        this.parEnd = parEnd;
        this.aAxis = axis0;
        this.bAxis = axis1;
        this.center = center;
        this.pNode = null;
        this.setBoundingBox();
        // this.parStart has to be nonnegative because of the way curve searches for the segment of a parameter
        while (this.parStart < 0) {
            this.parStart += Math.PI * 2;
            this.parEnd += Math.PI * 2;
        }
    }
    get start() {
        return this.value(this.parStart);
    }
    get end() {
        return this.value(this.parEnd);
    }
    /** Trims the curve */
    trim(start, end) {
        // Assert.assert(start <= end);
        // Assert.assert(start >= ParStart - GeomConstants.tolerance);
        // Assert.assert(end <= ParEnd + GeomConstants.tolerance);
        return new Ellipse(Math.max(start, this.parStart), Math.min(end, this.parEnd), this.aAxis, this.bAxis, this.center);
    }
    // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    trimWithWrap(start, end) {
        return null;
    }
    /** The bounding box of the ellipse */
    get boundingBox() {
        return this.box;
    }
    /** Returns the point on the curve corresponding to parameter t */
    value(t) {
        return this.center.add(_point__WEBPACK_IMPORTED_MODULE_3__.Point.mkPoint(Math.cos(t), this.aAxis, Math.sin(t), this.bAxis));
    }
    /** first derivative */
    derivative(t) {
        return _point__WEBPACK_IMPORTED_MODULE_3__.Point.mkPoint(-Math.sin(t), this.aAxis, Math.cos(t), this.bAxis);
    }
    /** second derivative */
    secondDerivative(t) {
        return _point__WEBPACK_IMPORTED_MODULE_3__.Point.mkPoint(-Math.cos(t), this.aAxis, -Math.sin(t), this.bAxis);
    }
    /** third derivative */
    thirdDerivative(t) {
        return _point__WEBPACK_IMPORTED_MODULE_3__.Point.mkPoint(Math.sin(t), this.aAxis, -Math.cos(t), this.bAxis);
    }
    /** a tree of ParallelogramNodes covering the edge */
    pNodeOverICurve() {
        if (this.pNode != null)
            return this.pNode;
        return (this.pNode = _parallelogramNode__WEBPACK_IMPORTED_MODULE_2__.ParallelogramNode.createParallelogramNodeForCurveSegDefaultOffset(this));
    }
    setBoundingBox() {
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_6__.closeDistEps)(this.parStart, 0) && (0,_utils_compare__WEBPACK_IMPORTED_MODULE_6__.closeDistEps)(this.parEnd, Math.PI * 2))
            this.box = this.fullBox();
        else {
            // the idea is that the box of an arc staying in one quadrant is just the box of the start and the end point of the arc
            this.box = _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(this.start, this.end);
            //now Start and End are in the box, we need just add all k*P/2 that are in between
            let t;
            for (let i = Math.ceil(this.parStart / (Math.PI / 2)); (t = (i * Math.PI) / 2) < this.parEnd; i++)
                if (t > this.parStart)
                    this.box.add(this.value(t));
        }
    }
    static mkEllipse(parStart, parEnd, axis0, axis1, centerX, centerY) {
        return new Ellipse(parStart, parEnd, axis0, axis1, new _point__WEBPACK_IMPORTED_MODULE_3__.Point(centerX, centerY));
    }
    /** Construct a full ellipse by two axes */
    static mkFullEllipsePPP(axis0, axis1, center) {
        return new Ellipse(0, Math.PI * 2, axis0, axis1, center);
    }
    /** Constructs a full ellipse with axes aligned to X and Y directions */
    static mkFullEllipseNNP(axisA, axisB, center) {
        return new Ellipse(0, Math.PI * 2, new _point__WEBPACK_IMPORTED_MODULE_3__.Point(axisA, 0), new _point__WEBPACK_IMPORTED_MODULE_3__.Point(0, axisB), center);
    }
    /** creates a circle by a given radius and the center */
    static mkCircle(radius, center) {
        return Ellipse.mkFullEllipseNNP(radius, radius, center);
    }
    /** Moves the ellipse to the delta vector */
    translate(delta) {
        this.center = this.center.add(delta);
        this.box.center = this.box.center.add(delta);
        this.pNode = null;
    }
    /** Scales the ellipse by x and by y */
    scaleFromOrigin(xScale, yScale) {
        return new Ellipse(this.parStart, this.parEnd, this.aAxis.mul(xScale), this.bAxis.mul(yScale), this.center.scale(xScale, yScale));
    }
    //
    getParameterAtLength(length) {
        //todo: slow version!
        const eps = 0.001;
        let l = this.parStart;
        let u = this.parEnd;
        const lenplus = length + eps;
        const lenminsu = length - eps;
        while (u - l > _geomConstants__WEBPACK_IMPORTED_MODULE_4__.GeomConstants.distanceEpsilon) {
            const m = 0.5 * (u + l);
            const len = this.lengthPartial(this.parStart, m);
            if (len > lenplus)
                u = m;
            else if (len < lenminsu)
                l = m;
            else
                return m;
        }
        return (u + l) / 2;
    }
    /** Transforms the ellipse */
    transform(transformation) {
        if (transformation != null) {
            const ap = transformation.multiplyPoint(this.aAxis).sub(transformation.offset());
            const bp = transformation.multiplyPoint(this.bAxis).sub(transformation.offset());
            return new Ellipse(this.parStart, this.parEnd, ap, bp, transformation.multiplyPoint(this.center));
        }
        return this.clone();
    }
    /** returns a parameter t such that the distance between curve[t] and targetPoint is minimal
     * and t belongs to the closed segment [low,high] */
    closestParameterWithinBounds(targetPoint, low, high) {
        const numberOfTestPoints = 8;
        const t = (high - low) / (numberOfTestPoints + 1);
        let closest = low;
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i <= numberOfTestPoints; i++) {
            const par = low + i * t;
            const p = targetPoint.sub(this.value(par));
            const d = p.dot(p);
            if (d < minDist) {
                minDist = d;
                closest = par;
            }
        }
        if (closest === 0 && high === Math.PI * 2)
            low = -Math.PI;
        let ret = _closestPointOnCurve__WEBPACK_IMPORTED_MODULE_5__.ClosestPointOnCurve.closestPoint(this, targetPoint, closest, low, high);
        if (ret < 0)
            ret += 2 * Math.PI;
        return ret;
    }
    // return length of the curve segment [start,end] : not implemented
    lengthPartial(start, end) {
        return _curve__WEBPACK_IMPORTED_MODULE_0__.Curve.lengthWithInterpolationAndThreshold(this.trim(start, end), _geomConstants__WEBPACK_IMPORTED_MODULE_4__.GeomConstants.lineSegmentThreshold / 100);
    }
    get length() {
        return ((this.aAxis.length + this.bAxis.length) * Math.abs(this.parEnd - this.parStart)) / 2;
    }
    /** clones the ellipse . */
    clone() {
        return new Ellipse(this.parStart, this.parEnd, this.aAxis.clone(), this.bAxis.clone(), this.center.clone());
    }
    /** returns a parameter t such that the distance between curve[t] and a is minimal */
    closestParameter(targetPoint) {
        let savedParStart = 0;
        const numberOfTestPoints = 8;
        const t = (this.parEnd - this.parStart) / (numberOfTestPoints + 1);
        let closest = this.parStart;
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i <= numberOfTestPoints; i++) {
            const par = this.parStart + i * t;
            const p = targetPoint.sub(this.value(par));
            const d = p.dot(p);
            if (d < minDist) {
                minDist = d;
                closest = par;
            }
        }
        let parStartWasChanged = false;
        if (closest === 0 && this.parEnd === Math.PI * 2) {
            parStartWasChanged = true;
            savedParStart = this.parStart;
            this.parStart = -Math.PI;
        }
        let ret = _closestPointOnCurve__WEBPACK_IMPORTED_MODULE_5__.ClosestPointOnCurve.closestPoint(this, targetPoint, closest, this.parStart, this.parEnd);
        if (ret < 0)
            ret += 2 * Math.PI;
        if (parStartWasChanged)
            this.parStart = savedParStart;
        return ret;
    }
    // left derivative at t
    leftDerivative(t) {
        return this.derivative(t);
    }
    // right derivative at t
    rightDerivative(t) {
        return this.derivative(t);
    }
    //
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    curvature(t) {
        throw 'NotImplementedException()';
        return 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    curvatureDerivative(t) {
        throw 'NotImplementedException();';
        return 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    curvatureSecondDerivative(t) {
        throw 'NotImplementedException()';
        return 0;
    }
    // returns true if the ellipse goes counterclockwise
    orientedCounterclockwise() {
        return _point__WEBPACK_IMPORTED_MODULE_3__.Point.crossProduct(this.aAxis, this.bAxis) > 0;
    }
    //returns the box of the ellipse that this ellipse is a part of
    fullBox() {
        const del = this.aAxis.add(this.bAxis);
        return _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(this.center.add(del), this.center.sub(del));
    }
    /**is it a proper arc? meaning that it just a part of a circle */
    isArc() {
        return (Math.abs(this.aAxis.dot(this.bAxis)) < _geomConstants__WEBPACK_IMPORTED_MODULE_4__.GeomConstants.tolerance &&
            Math.abs(this.aAxis.length - this.bAxis.length) < _geomConstants__WEBPACK_IMPORTED_MODULE_4__.GeomConstants.tolerance &&
            _point__WEBPACK_IMPORTED_MODULE_3__.Point.closeDistEps(this.aAxis.rotate90Ccw(), this.bAxis));
    }
}
//# sourceMappingURL=ellipse.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/geomConstants.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomConstants: () => (/* binding */ GeomConstants)
/* harmony export */ });
class GeomConstants {
}
GeomConstants.distanceEpsilonPrecision = 6;
GeomConstants.mult = Math.pow(10, 6);
GeomConstants.defaultLeafBoxesOffset = 0.5;
GeomConstants.lineSegmentThreshold = 0.05;
GeomConstants.intersectionEpsilon = 0.0001;
GeomConstants.distanceEpsilon = Math.pow(10, -GeomConstants.distanceEpsilonPrecision);
GeomConstants.squareOfDistanceEpsilon = Math.pow(10, -GeomConstants.distanceEpsilonPrecision * 2);
GeomConstants.tolerance = 1.0e-8;
//# sourceMappingURL=geomConstants.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/icurve.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JSONToICurve: () => (/* binding */ JSONToICurve),
/* harmony export */   iCurveToJSON: () => (/* binding */ iCurveToJSON),
/* harmony export */   parameterSpan: () => (/* binding */ parameterSpan)
/* harmony export */ });
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _lineSegment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _bezierSeg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/bezierSeg.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");





function parameterSpan(curve) {
    return curve.parEnd - curve.parStart;
}
function JSONToICurve(json) {
    switch (json.type) {
        case 'ellipse':
            return _ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse.fromJSON(json.data);
        case 'curve':
            return _curve__WEBPACK_IMPORTED_MODULE_1__.Curve.fromJSON(json.data);
        case 'lineSegment':
            return _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment.fromJSON(json.data);
        case 'bezier':
            return _bezierSeg__WEBPACK_IMPORTED_MODULE_3__.BezierSeg.fromJSON(json.data);
        case 'polyline':
            return _polyline__WEBPACK_IMPORTED_MODULE_4__.Polyline.fromJSON(json.data);
    }
}
function getICurveType(bc) {
    if (bc instanceof _ellipse__WEBPACK_IMPORTED_MODULE_0__.Ellipse) {
        return 'ellipse';
    }
    else if (bc instanceof _curve__WEBPACK_IMPORTED_MODULE_1__.Curve) {
        return 'curve';
    }
    else if (bc instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_2__.LineSegment) {
        return 'lineSegment';
    }
    else if (bc instanceof _bezierSeg__WEBPACK_IMPORTED_MODULE_3__.BezierSeg) {
        return 'bezier';
    }
    else if (bc instanceof _polyline__WEBPACK_IMPORTED_MODULE_4__.Polyline) {
        return 'polyline';
    }
    else {
        throw new Error('not implemented');
    }
}
function iCurveToJSON(bc) {
    return { type: getICurveType(bc), data: bc.toJSON() };
}
//# sourceMappingURL=icurve.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompassVector: () => (/* reexport safe */ _compassVector__WEBPACK_IMPORTED_MODULE_6__.CompassVector),
/* harmony export */   Curve: () => (/* reexport safe */ _curve__WEBPACK_IMPORTED_MODULE_0__.Curve),
/* harmony export */   CurveFactory: () => (/* reexport safe */ _curveFactory__WEBPACK_IMPORTED_MODULE_1__.CurveFactory),
/* harmony export */   Direction: () => (/* reexport safe */ _direction__WEBPACK_IMPORTED_MODULE_7__.Direction),
/* harmony export */   GeomConstants: () => (/* reexport safe */ _geomConstants__WEBPACK_IMPORTED_MODULE_9__.GeomConstants),
/* harmony export */   LineSegment: () => (/* reexport safe */ _lineSegment__WEBPACK_IMPORTED_MODULE_8__.LineSegment),
/* harmony export */   Point: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_2__.Point),
/* harmony export */   PointLocation: () => (/* reexport safe */ _curve__WEBPACK_IMPORTED_MODULE_0__.PointLocation),
/* harmony export */   Polyline: () => (/* reexport safe */ _polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline),
/* harmony export */   Rectangle: () => (/* reexport safe */ _rectangle__WEBPACK_IMPORTED_MODULE_4__.Rectangle),
/* harmony export */   Size: () => (/* reexport safe */ _rectangle__WEBPACK_IMPORTED_MODULE_4__.Size),
/* harmony export */   interpolateICurve: () => (/* reexport safe */ _curve__WEBPACK_IMPORTED_MODULE_0__.interpolateICurve),
/* harmony export */   parameterSpan: () => (/* reexport safe */ _icurve__WEBPACK_IMPORTED_MODULE_3__.parameterSpan)
/* harmony export */ });
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _curveFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curveFactory.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _icurve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/icurve.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _compassVector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _direction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _lineSegment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");










//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/intersectionInfo.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IntersectionInfo: () => (/* binding */ IntersectionInfo)
/* harmony export */ });
// Contains the result of the intersection of two ICurves.
class IntersectionInfo {
    // the constructor
    constructor(pr0, pr1, x, s0, s1) {
        this.par0 = pr0;
        this.par1 = pr1;
        this.x = x;
        this.seg0 = s0;
        this.seg1 = s1;
        /*Assert.assert(
          Point.close(x, s0.value(pr0), GeomConstants.intersectionEpsilon * 10),
        )*/
        //,
        //  String.Format(
        //    'intersection not at curve[param]; x = {0}, s0[pr0] = {1}, diff = {2}',
        //    x,
        //    s0.value(pr0),
        //    x.sub(s0.value(pr0)),
        //  ),
        // )
        /*Assert.assert(
          Point.close(x, s1.value(pr1), GeomConstants.intersectionEpsilon * 10),
        )*/
        //,
        //  String.Format(
        //    'intersection not at curve[param]; x = {1}, s1[pr1] = {1}, diff = {2}',
        //    x,
        //    s1.value(pr1),
        //    x.sub(s1.value(pr1)),
        //  ),
        // )
    }
}
//# sourceMappingURL=intersectionInfo.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/lineSegment.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineSegment: () => (/* binding */ LineSegment),
/* harmony export */   pointIsOnSegment: () => (/* binding */ pointIsOnSegment),
/* harmony export */   segmentsIntersect: () => (/* binding */ segmentsIntersect)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _parallelogram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogram.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");




class LineSegment {
    static fromJSON(lineData) {
        return LineSegment.mkPP(_point__WEBPACK_IMPORTED_MODULE_0__.Point.fromJSON(lineData.start), _point__WEBPACK_IMPORTED_MODULE_0__.Point.fromJSON(lineData.end));
    }
    toJSON() {
        return { start: this.start.toJSON(), end: this.end.toJSON() };
    }
    // Offsets the curve in the direction of dir
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    offsetCurve(offset, dir) {
        return null;
    }
    constructor(x, y, x1, y1) {
        this.parStart = 0;
        this.parEnd = 1;
        this.start = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);
        this.end = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x1, y1);
    }
    // Returns the trim curve
    trim(start, end) {
        start = Math.max(this.parStart, start);
        end = Math.min(this.parEnd, end);
        if (start > end)
            throw 'wrong params in trimming';
        const p1 = this.value(start);
        const p2 = this.value(end);
        if (_point__WEBPACK_IMPORTED_MODULE_0__.Point.close(p1, p2, _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon)) {
            return null;
        }
        return LineSegment.mkPP(p1, p2);
    }
    value(t) {
        return this.start.add(this.end.sub(this.start).mul(t));
    }
    // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    trimWithWrap(start, end) {
        return null;
    } // not implemented
    // A tree of ParallelogramNodes covering the curve.
    // This tree is used in curve intersections routines.
    // <value></value>
    pNodeOverICurve() {
        const side = this.end.sub(this.start).mul(0.5);
        return {
            parallelogram: _parallelogram__WEBPACK_IMPORTED_MODULE_1__.Parallelogram.parallelogramByCornerSideSide(this.start, side, side),
            seg: this,
            leafBoxesOffset: 0,
            node: {
                low: 0,
                high: 1,
                chord: this,
            },
        };
    }
    normal() {
        let t = this.start.sub(this.end);
        t = t.div(t.length);
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(-t.y, t.x);
    }
    // construct a line segment
    static mkPP(start, end) {
        return new LineSegment(start.x, start.y, end.x, end.y);
    }
    // constructs a line segment
    static mkLinePXY(p, x, y) {
        return new LineSegment(p.x, p.y, x, y);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    derivative(t) {
        return this.end.sub(this.start);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    secondDerivative(t) {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    thirdDerivative(t) {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
    }
    reverse() {
        return LineSegment.mkPP(this.end, this.start);
    }
    /*
  static internal IntersectionInfo Cross(LineSeg coeff, LineSeg side1){
  IntersectionInfo xx=CrossTwoLines(coeff.start, coeff.End-coeff.start,side1.start, side1.End-side1.start);
  if (xx == null )
  {
  //parallel segs
  Point adir=coeff.d1(0);
  Point bdir=side1.d1(0);
  
  if (adir.length > bdir.length)
  {
  if (adir.length > Curve.DistEps)
  {
  adir = adir.normalize();
  if(Math.Abs((coeff-side1)*adir<Curve.DistEps)){
  
  }
  }
  }
  return null;
  }
  
  if(xx.Par0>1){
  if (Point.closeDistEps(coeff.End, xx.x))
  {
  xx.x = coeff.End;
  xx.Par0 = 1;
  }
  else
  return null;
  }
  else if(xx.Par0<0){
  if(Point.closeDistEps(coeff.start,xx.x)){
  xx.x=coeff.start;
  xx.Par0=1;
  }
  else
  return null;
  }
  
  if (xx.Par1 > 1)
  {
  if (Point.closeDistEps(side1.End, xx.x))
  {
  xx.x = coeff.End;
  xx.Par1 = 1;
  }
  else
  return null;
  }
  else if (xx.Par1 < 0)
  {
  if (Point.closeDistEps(side1.start, xx.x))
  {
  xx.x = coeff.start;
  xx.Par1 = 1;
  }
  else
  return null;
  }
  
  return xx;
  }
  * */
    // mutable! changes this
    // Returns the curved moved by delta
    translate(delta) {
        this.start = this.start.add(delta);
        this.end = this.end.add(delta);
    }
    // Scale (multiply) from origin by x and y
    scaleFromOrigin(xScale, yScale) {
        return LineSegment.mkPP(this.start.scale(xScale, yScale), this.end.scale(xScale, yScale));
    }
    // gets the parameter at a specific length from the start along the curve
    getParameterAtLength(length) {
        const len = this.end.sub(this.start).length;
        if (len < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance)
            return 0;
        const t = length / len;
        return t > 1 ? 1 : t < 0 ? 0 : t;
    }
    // Return the transformed curve
    transform(transformation) {
        return LineSegment.mkPP(transformation.multiplyPoint(this.start), transformation.multiplyPoint(this.end));
    }
    // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
    // and t belongs to the closed segment [low,high]
    closestParameterWithinBounds(targetPoint, low, high) {
        let t = this.closestParameter(targetPoint);
        if (t < low)
            t = low;
        if (t > high)
            t = high;
        return t;
    }
    // return length of the curve segment [start,end]
    lengthPartial(start, end) {
        return this.value(end).sub(this.value(start)).length;
    }
    // Get the length of the curve
    get length() {
        return this.start.sub(this.end).length;
    }
    // The bounding box of the line
    get boundingBox() {
        return _rectangle__WEBPACK_IMPORTED_MODULE_2__.Rectangle.mkPP(this.start, this.end);
    }
    // clones the curve.
    clone() {
        return LineSegment.mkPP(this.start.clone(), this.end.clone());
    }
    static closestParameterOnLineSegment(point, segmentStart, segmentEnd) {
        const bc = segmentEnd.sub(segmentStart);
        const ba = point.sub(segmentStart);
        const c1 = bc.dot(ba);
        if (c1 <= 0.0 + _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance)
            return 0;
        const c2 = bc.dot(bc);
        if (c2 <= c1 + _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance)
            return 1;
        return c1 / c2;
    }
    // returns a parameter t such that the distance between curve[t] and a is minimal
    closestParameter(targetPoint) {
        return LineSegment.closestParameterOnLineSegment(targetPoint, this.start, this.end);
    }
    // left derivative at t
    leftDerivative(t) {
        return this.derivative(t);
    }
    // right derivative at t
    rightDerivative(t) {
        return this.derivative(t);
    }
    // returns true if segments are not parallel and are intesecting
    static IntersectPPPP(a, b, c, d) {
        const r = _point__WEBPACK_IMPORTED_MODULE_0__.Point.lineLineIntersection(a, b, c, d);
        if (r == null)
            return;
        if (pointIsOnSegment(r, a, b) && pointIsOnSegment(r, c, d)) {
            return r;
        }
        else {
            return undefined;
        }
    }
    //
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    curvature(t) {
        return 0;
    }
    //
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    curvatureDerivative(t) {
        return 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    curvatureSecondDerivative(_) {
        return 0;
    }
    // [a,b] and [c,d] are the segments. u and v are the corresponding closest point params
    // see http://www.geometrictools.com/Documentation/DistanceLine3Line3.pdf
    static minDistBetweenLineSegments(a, b, c, d) {
        const u = b.sub(a);
        const v = d.sub(c);
        const w = a.sub(c);
        const D = _point__WEBPACK_IMPORTED_MODULE_0__.Point.crossProduct(u, v);
        const uu = u.dot(u); // always >= 0
        const uv = u.dot(v);
        const vv = v.dot(v); // always >= 0
        const uw = u.dot(w);
        const vw = v.dot(w);
        let sN, tN;
        const absD = Math.abs(D);
        let sD = absD, tD = absD;
        // compute the line parameters of the two closest points
        if (absD < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance) {
            // the lines are almost parallel
            sN = 0.0; // force using point a on segment [a..b]
            sD = 1.0; // to prevent possible division by 0.0 later
            tN = vw;
            tD = vv;
        }
        else {
            // get the closest points on the infinite lines
            sN = _point__WEBPACK_IMPORTED_MODULE_0__.Point.crossProduct(v, w);
            tN = _point__WEBPACK_IMPORTED_MODULE_0__.Point.crossProduct(u, w);
            if (D < 0) {
                sN = -sN;
                tN = -tN;
            }
            if (sN < 0.0) {
                // parab < 0 => the s=0 edge is visible
                sN = 0.0;
                tN = vw;
                tD = vv;
            }
            else if (sN > sD) {
                // parab > 1 => the s=1 edge is visible
                sN = sD = 1;
                tN = vw + uv;
                tD = vv;
            }
        }
        if (tN < 0.0) {
            // tc < 0 => the t=0 edge is visible
            tN = 0.0;
            // recompute parab for this edge
            if (-uw < 0.0)
                sN = 0.0;
            else if (-uw > uu)
                sN = sD;
            else {
                sN = -uw;
                sD = uu;
            }
        }
        else if (tN > tD) {
            // tc > 1 => the t=1 edge is visible
            tN = tD = 1;
            // recompute parab for this edge
            if (-uw + uv < 0.0)
                sN = 0;
            else if (-uw + uv > uu)
                sN = sD;
            else {
                sN = -uw + uv;
                sD = uu;
            }
        }
        const parab_ = Math.abs(sN) < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance ? 0.0 : sN / sD;
        const parcd_ = Math.abs(tN) < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance ? 0.0 : tN / tD;
        // finally do the division to get parameters
        return {
            parab: parab_,
            parcd: parcd_,
            // get the difference of the two closest points
            //           const dP = w + (parab * u) - (parcd * v),
            dist: w.add(u.mul(parab_).sub(v.mul(parcd_))).length, // return the closest distance
        };
    }
}
/** a - is the point to test
 * [c,b] - is the segment
 * The function actually checks that a is inside of the bounding box of [c,b].
 * ! Use it only when a,b,c are collinear !
 */
function pointIsOnSegment(a, b, c) {
    return (a.x >= Math.min(b.x, c.x) - _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon &&
        a.y >= Math.min(b.y, c.y) - _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon &&
        a.x <= Math.max(b.x, c.x) + _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon &&
        a.y <= Math.max(b.y, c.y) + _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon);
}
/** returns true if segments intersect */
function segmentsIntersect(a, b, c, d) {
    const abc = _point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(a, b, c);
    const abd = _point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(a, b, d);
    const cda = _point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(c, d, a);
    const cdb = _point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(c, d, b);
    // if abc != abd then ab separates c and d
    // if cda != cdb then cd separates b and a
    if (abc != abd && cda != cdb)
        return true;
    // If the orientations are collinear and the points lie on the segments,
    // the segments intersect
    if (abc == _point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear && pointIsOnSegment(c, a, b))
        return true;
    if (abd == _point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear && pointIsOnSegment(d, a, b))
        return true;
    if (cda == _point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear && pointIsOnSegment(a, c, d))
        return true;
    if (cdb == _point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear && pointIsOnSegment(b, c, d))
        return true;
    // Otherwise, the segments do not intersect
    return false;
}
//# sourceMappingURL=lineSegment.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/linearSystem.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinearSystem2: () => (/* binding */ LinearSystem2)
/* harmony export */ });
// solves a linear system of two equations with two unknown variables
class LinearSystem2 {
    static solve(a00, a01, b0, a10, a11, b1) {
        const d = a00 * a11 - a10 * a01;
        if (Math.abs(d) < LinearSystem2.eps) {
            return;
        }
        return {
            x: (b0 * a11 - b1 * a01) / d,
            y: (a00 * b1 - a10 * b0) / d,
        };
    }
}
LinearSystem2.eps = 1.0e-8;
//# sourceMappingURL=linearSystem.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/minDistCurveCurve.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MinDistCurveCurve: () => (/* binding */ MinDistCurveCurve)
/* harmony export */ });
/* harmony import */ var _lineSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");


// For curves A(s) and B(t), when we have some evidence that
// there is at most one intersection point, and we have a guess for the parameters (s0, t0),
// we try to bring to (0,0) vector F(s,t) = A(s) - B(t).  To minimize the length of F(s,t)
// we solve the system of equations:
// F*Fs + (F*Fss + Fs*Fs)ds + (F*Fst + Fs*Ft)dt = 0
// F*Ft + (F*Fst + Fs*Ft)ds + (F*Ftt + Ft*Ft)dt = 0
//
// Where F = F(si,ti), Fs and Ft are the first partials at si, ti, Fxx are the second partials,
// and s(i+1) = si+ds, t(i+1) = ti+dt.
// We adjust ds and dt to stay in the domain.
class MinDistCurveCurve {
    initValues() {
        this.a = this.curveA.value(this.si);
        this.b = this.curveB.value(this.ti);
        this.a_b = this.a.sub(this.b);
        this.ad = this.curveA.derivative(this.si);
        this.add = this.curveA.secondDerivative(this.si);
        this.bd = this.curveB.derivative(this.ti);
        this.bdd = this.curveB.secondDerivative(this.ti);
    }
    // curveAPar">first curve</param>
    // curveBPar">second curve</param>
    // lowBound0">the first curve minimal parameter</param>
    // upperBound0">the first curve maximal parameter</param>
    // lowBound1">the second curve minimal parameter</param>
    // upperBound1">the first curve maximal parameter</param>
    // guess0"></param>
    // guess1"></param>
    constructor(curveA, curveB, aMin, aMax, bMin, mBax, aGuess, bGuess) {
        this.curveA = curveA;
        this.curveB = curveB;
        this.aMin = aMin;
        this.bMin = bMin;
        this.aMax = aMax;
        this.bMax = mBax;
        this.aGuess = aGuess;
        this.bGuess = bGuess;
        this.si = aGuess;
        this.ti = bGuess;
    }
    //we ignore the mulitplier 2 here fore efficiency reasons
    Fs() {
        return /*2**/ this.a_b.dot(this.ad);
    }
    Fss() {
        return /*2**/ this.a_b.dot(this.add) + this.ad.dot(this.ad);
    }
    Fst() {
        //equals to Fts
        return -( /*2**/this.bd.dot(this.ad));
    }
    Ftt() {
        return /*2**/ -this.a_b.dot(this.bdd) + this.bd.dot(this.bd);
    }
    Ft() {
        return -( /*2**/this.a_b.dot(this.bd));
    }
    // xy - the first row
    // uw - the second row
    delta(x, y, u, w) {
        return x * w - u * y;
    }
    //Fs + Fss*ds + Fst*dt = 0
    //Ft + Fst*ds + Ftt*dt = 0
    solve() {
        let numberOfBoundaryCrossings = 0;
        const maxNumberOfBoundaryCrossings = 10;
        let numberOfTotalReps = 0;
        const maxNumberOfTotalReps = 100;
        let abort = false;
        this.initValues();
        if (this.curveA instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_0__.LineSegment && this.curveB instanceof _lineSegment__WEBPACK_IMPORTED_MODULE_0__.LineSegment) {
            let bd1 = this.curveB.derivative(0);
            bd1 = bd1.div(bd1.length);
            const an = this.curveA.normal();
            const del = Math.abs(an.dot(bd1));
            if (Math.abs(del) < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon ||
                this.delta(this.Fss(), this.Fst(), this.Fst(), this.Ftt()) < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
                this.success = true;
                this.parallelLineSegLineSegMinDist();
                return;
            }
        }
        let d;
        do {
            const delta = this.delta(this.Fss(), this.Fst(), this.Fst(), this.Ftt());
            if (Math.abs(delta) < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
                this.success = false;
                abort = true;
                break;
            }
            d = {
                s: this.delta(-this.Fs(), this.Fst(), -this.Ft(), this.Ftt()) / delta,
                t: this.delta(this.Fss(), -this.Fs(), this.Fst(), -this.Ft()) / delta,
            };
            const nsi = this.si + d.s;
            const nti = this.ti + d.t;
            let bc;
            if (nsi > this.aMax + _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon ||
                nsi < this.aMin - _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon ||
                nti > this.bMax + _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon ||
                nti < this.bMin - _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                numberOfBoundaryCrossings++;
                this.chopDsDt(d);
                this.si += d.s;
                this.ti += d.t;
                bc = true;
            }
            else {
                bc = false;
                this.si = nsi;
                this.ti = nti;
                if (this.si > this.aMax)
                    this.si = this.aMax;
                else if (this.si < this.aMin)
                    this.si = this.aMin;
                if (this.ti > this.bMax)
                    this.ti = this.bMax;
                else if (this.ti < this.bMin)
                    this.ti = this.bMin;
            }
            this.initValues();
            numberOfTotalReps++;
            abort =
                numberOfBoundaryCrossings >= maxNumberOfBoundaryCrossings ||
                    numberOfTotalReps >= maxNumberOfTotalReps ||
                    (d.s === 0 && d.t === 0 && bc);
        } while ((Math.abs(d.s) >= _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance || Math.abs(d.t) >= _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) && !abort);
        if (abort) {
            //may be the initial values were just OK
            const t = this.curveA.value(this.aGuess).sub(this.curveB.value(this.bGuess));
            if (t.dot(t) < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon * _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                this.aSolution = this.aGuess;
                this.bSolution = this.bGuess;
                this.aPoint = this.curveA.value(this.aGuess);
                this.bPoint = this.curveB.value(this.bGuess);
                this.success = true;
                return;
            }
        }
        this.aSolution = this.si;
        this.bSolution = this.ti;
        this.aPoint = this.a;
        this.bPoint = this.b;
        this.success = !abort;
    }
    // d is is {s:number; d:number}
    chopDsDt(d) {
        if (d.s !== 0 && d.t !== 0) {
            let k1 = 1; //we are looking for a chopped vector of the form k(ds, dt)
            if (this.si + d.s > this.aMax)
                //we have si+k*ds=aMax
                k1 = (this.aMax - this.si) / d.s;
            else if (this.si + d.s < this.aMin)
                k1 = (this.aMin - this.si) / d.s;
            let k2 = 1;
            if (this.ti + d.t > this.bMax)
                //we need to have ti+k*d.t=bMax  or ti+k*d.t=bMin
                k2 = (this.bMax - this.ti) / d.t;
            else if (this.ti + d.t < this.bMin)
                k2 = (this.bMin - this.ti) / d.t;
            const k = Math.min(k1, k2);
            d.s *= k;
            d.t *= k;
        }
        else if (d.s === 0) {
            if (this.ti + d.t > this.bMax)
                d.t = this.bMax - this.ti;
            else if (this.ti + d.t < this.bMin)
                d.t = this.bMin - this.ti;
        }
        else {
            //d.t==0)
            if (this.si + d.s > this.aMax)
                d.s = this.aMax - this.si;
            else if (this.si + d.s < this.aMin)
                d.s = this.aMin - this.si;
        }
    }
    parallelLineSegLineSegMinDist() {
        const l0 = this.curveA;
        const l1 = this.curveB;
        const v0 = l0.start;
        const v1 = l0.end;
        const v2 = l1.start;
        const v3 = l1.end;
        let d0 = v1.sub(v0);
        const nd0 = d0.length;
        let r0 = 0;
        let r1, r2, r3;
        if (nd0 > _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            //v0 becomes the zero point
            d0 = d0.div(nd0);
            r1 = d0.dot(v1.sub(v0));
            r2 = d0.dot(v2.sub(v0));
            r3 = d0.dot(v3.sub(v0));
            let swapped = false;
            if (r2 > r3) {
                swapped = true;
                const t = r2;
                r2 = r3;
                r3 = t;
            }
            if (r3 < r0) {
                this.aSolution = 0;
                this.bSolution = swapped ? 0 : 1;
            }
            else if (r2 > r1) {
                this.aSolution = 1;
                this.bSolution = swapped ? 1 : 0;
            }
            else {
                const r = Math.min(r1, r3);
                this.aSolution = r / (r1 - r0);
                this.bSolution = (r - r2) / (r3 - r2);
                if (swapped)
                    this.bSolution = 1 - this.bSolution;
            }
        }
        else {
            let d1 = v3.sub(v2);
            const nd1 = d1.length;
            if (nd1 > _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                //v2 becomes the zero point
                d1 = d1.div(nd1);
                r0 = 0; //v2 position
                r1 = d1.dot(v3.sub(v2)); //v3 position
                r2 = d1.dot(v0.sub(v2)); //v0 position - here v0 and v1 are indistinguishable
                if (r2 < r0) {
                    this.bSolution = 0;
                    this.aSolution = 1;
                }
                else if (r2 > r1) {
                    this.bSolution = 1;
                    this.aSolution = 0;
                }
                else {
                    const r = Math.min(r1, r2);
                    this.bSolution = r / (r1 - r0);
                    this.aSolution = 0;
                }
            }
            else {
                this.aSolution = 0;
                this.bSolution = 0;
            }
        }
        this.aPoint = this.curveA.value(this.aSolution);
        this.bPoint = this.curveB.value(this.bSolution);
    }
}
//# sourceMappingURL=minDistCurveCurve.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/parallelogram.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Parallelogram: () => (/* binding */ Parallelogram),
/* harmony export */   VertexId: () => (/* binding */ VertexId),
/* harmony export */   allVerticesOfParall: () => (/* binding */ allVerticesOfParall)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");


var VertexId;
(function (VertexId) {
    VertexId[VertexId["Corner"] = 0] = "Corner";
    VertexId[VertexId["VertexA"] = 1] = "VertexA";
    VertexId[VertexId["otherCorner"] = 2] = "otherCorner";
    VertexId[VertexId["VertexB"] = 3] = "VertexB";
})(VertexId || (VertexId = {}));
class Parallelogram {
    // Return true if the parallelogram contains the point
    contains(point) {
        const g = point.sub(this.corner);
        const e = _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon;
        const gbRot = g.dot(this.bRot);
        if (gbRot > this.abRot + e || gbRot < -e)
            return false;
        const gaRot = g.dot(this.aRot);
        return gaRot <= this.baRot + e && gaRot >= -e;
    }
    get area() {
        return Math.abs(this.a.x * this.b.y - this.a.y * this.b.x);
    }
    vertex(vertexPar) {
        switch (vertexPar) {
            case VertexId.Corner:
                return this.corner;
            case VertexId.VertexA:
                return this.aPlusCorner;
            case VertexId.otherCorner:
                return this.otherCorner;
            case VertexId.VertexB:
                return this.bPlusCorner;
            default:
                return undefined;
        }
    }
    static parallelogramOfTwo(box0, box1) {
        const result = new Parallelogram();
        const v = box0.corner;
        const mm = {
            minx: v.x,
            maxx: v.x,
            miny: v.y,
            maxy: v.y,
        };
        Parallelogram.pumpMinMax(mm, box0.aPlusCorner);
        Parallelogram.pumpMinMax(mm, box0.otherCorner);
        Parallelogram.pumpMinMax(mm, box0.bPlusCorner);
        Parallelogram.pumpMinMax(mm, box1.corner);
        Parallelogram.pumpMinMax(mm, box1.aPlusCorner);
        Parallelogram.pumpMinMax(mm, box1.otherCorner);
        Parallelogram.pumpMinMax(mm, box1.bPlusCorner);
        result.corner = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(mm.minx, mm.miny);
        result.a = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(0, mm.maxy - mm.miny);
        result.b = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(mm.maxx - mm.minx, 0);
        result.aPlusCorner = result.a.add(result.corner);
        result.otherCorner = result.b.add(result.aPlusCorner);
        result.bPlusCorner = result.b.add(result.corner);
        result.aRot = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(-result.a.y, result.a.x);
        if (result.aRot.length > 0.5)
            result.aRot = result.aRot.normalize();
        result.bRot = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(-result.b.y, result.b.x);
        if (result.bRot.length > 0.5)
            result.bRot = result.bRot.normalize();
        result.abRot = result.a.dot(result.bRot);
        result.baRot = result.b.dot(result.aRot);
        if (result.abRot < 0) {
            result.abRot = -result.abRot;
            result.bRot = result.bRot.neg();
        }
        if (result.baRot < 0) {
            result.baRot = -result.baRot;
            result.aRot = result.aRot.neg();
        }
        result.isSeg = result.a.sub(result.b).length < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon;
        return result;
    }
    static pumpMinMax(mm, p) {
        if (p.x < mm.minx) {
            mm.minx = p.x;
        }
        else if (p.x > mm.maxx) {
            mm.maxx = p.x;
        }
        if (p.y < mm.miny) {
            mm.miny = p.y;
        }
        else if (p.y > mm.maxy) {
            mm.maxy = p.y;
        }
    }
    // returns true if parallelograms intersect
    static intersect(parallelogram0, parallelogram1) {
        // It can be shown that two parallelograms do not intersect if and only if
        // they are separated with one of the parallelogram sides
        const ret = !(Parallelogram.separByA(parallelogram0, parallelogram1) ||
            Parallelogram.separByA(parallelogram1, parallelogram0) ||
            Parallelogram.separByB(parallelogram0, parallelogram1) ||
            Parallelogram.separByB(parallelogram1, parallelogram0));
        if (ret === false)
            return false;
        if (!(parallelogram0.isSeg && parallelogram1.isSeg))
            return true;
        if (!_point__WEBPACK_IMPORTED_MODULE_0__.Point.parallelWithinEpsilon(parallelogram0.otherCorner.sub(parallelogram0.corner), parallelogram1.otherCorner.sub(parallelogram1.corner), 1.0e-5))
            return true;
        //here we know that the segs are parallel
        return Parallelogram.ParallelSegsIntersect(parallelogram1, parallelogram0);
    }
    static ParallelSegsIntersect(p0, p1) {
        const v0 = p0.corner;
        const v1 = p0.otherCorner;
        const v2 = p1.corner;
        const v3 = p1.otherCorner;
        const d = v1.sub(v0);
        //const us imagine that v0 is at zero
        const r0 = 0; // position of v0
        const r1 = d.dot(d); //offset of v1
        //offset of v2
        let r2 = v2.sub(v0).dot(d);
        //offset of v3
        let r3 = v3.sub(v0).dot(d);
        // we need to check if [r0,r1] intersects [r2,r3]
        if (r2 > r3) {
            const t = r2;
            r2 = r3;
            r3 = t;
        }
        return !(r3 < r0 - _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon || r2 > r1 + _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon);
    }
    static separByB(p0, p1) {
        const eps = _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon;
        const p1a = p1.vertex(0).sub(p0.corner).dot(p0.bRot);
        const list = [VertexId.VertexA, VertexId.otherCorner, VertexId.VertexB];
        if (p1a > p0.abRot + eps) {
            for (const i of list) {
                if (p1.vertex(i).sub(p0.corner).dot(p0.bRot) <= p0.abRot + eps)
                    return false;
            }
            return true;
        }
        else if (p1a < -eps) {
            for (const i of list) {
                if (p1.vertex(i).sub(p0.corner).dot(p0.bRot) >= -eps)
                    return false;
            }
            return true;
        }
        return false;
    }
    static separByA(p0, p1) {
        const eps = _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon;
        let t = p1.corner.sub(p0.corner);
        const p1a = _point__WEBPACK_IMPORTED_MODULE_0__.Point.dot(t, p0.aRot);
        if (p1a > p0.baRot + eps) {
            t = p1.aPlusCorner.sub(p0.corner);
            if (_point__WEBPACK_IMPORTED_MODULE_0__.Point.dot(t, p0.aRot) <= p0.baRot + eps)
                return false;
            t = p1.bPlusCorner.sub(p0.corner);
            if (_point__WEBPACK_IMPORTED_MODULE_0__.Point.dot(t, p0.aRot) <= p0.baRot + eps)
                return false;
            t = p1.otherCorner.sub(p0.corner);
            if (_point__WEBPACK_IMPORTED_MODULE_0__.Point.dot(t, p0.aRot) <= p0.baRot + eps)
                return false;
            return true;
        }
        else if (p1a < -eps) {
            t = p1.aPlusCorner.sub(p0.corner);
            if (_point__WEBPACK_IMPORTED_MODULE_0__.Point.dot(t, p0.aRot) >= -eps)
                return false;
            t = p1.bPlusCorner.sub(p0.corner);
            if (_point__WEBPACK_IMPORTED_MODULE_0__.Point.dot(t, p0.aRot) >= -eps)
                return false;
            t = p1.otherCorner.sub(p0.corner);
            if (_point__WEBPACK_IMPORTED_MODULE_0__.Point.dot(t, p0.aRot) >= -eps)
                return false;
            return true;
        }
        return false;
    }
    static parallelogramByCornerSideSide(corner, sideA, sideB) {
        const result = new Parallelogram();
        result.corner = corner;
        result.a = sideA;
        result.b = sideB;
        result.aRot = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(-sideA.y, sideA.x);
        if (result.aRot.length > 0.5)
            result.aRot = result.aRot.normalize();
        result.bRot = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(-sideB.y, sideB.x);
        if (result.bRot.length > 0.5)
            result.bRot = result.bRot.normalize();
        result.abRot = result.bRot.dot(sideA);
        result.baRot = sideB.dot(result.aRot);
        if (result.abRot < 0) {
            result.abRot = -result.abRot;
            result.bRot = result.bRot.neg();
        }
        if (result.baRot < 0) {
            result.baRot = -result.baRot;
            result.aRot = result.aRot.neg();
        }
        result.isSeg = sideA.sub(sideB).length < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon;
        result.aPlusCorner = sideA.add(corner);
        result.otherCorner = sideB.add(result.aPlusCorner);
        result.bPlusCorner = sideB.add(corner);
        return result;
    }
    static getParallelogramOfAGroup(boxes) {
        let minx = 0, maxx = 0, miny = 0, maxy = 0;
        let firstTime = true;
        for (const b of boxes) {
            const verts = allVerticesOfParall(b);
            for (const v of verts) {
                const x = v.x;
                const y = v.y;
                if (firstTime) {
                    firstTime = false;
                    minx = maxx = x;
                    miny = maxy = y;
                }
                else {
                    if (x < minx) {
                        minx = x;
                    }
                    else if (x > maxx) {
                        maxx = x;
                    }
                    if (y < miny) {
                        miny = y;
                    }
                    else if (y > maxy) {
                        maxy = y;
                    }
                }
            }
        }
        return Parallelogram.parallelogramByCornerSideSide(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(minx, miny), new _point__WEBPACK_IMPORTED_MODULE_0__.Point(0, maxy - miny), new _point__WEBPACK_IMPORTED_MODULE_0__.Point(maxx - minx, 0));
    }
}
function* allVerticesOfParall(p) {
    yield p.corner;
    yield p.aPlusCorner;
    yield p.otherCorner;
    yield p.bPlusCorner;
}
//# sourceMappingURL=parallelogram.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/parallelogramNode.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParallelogramNode: () => (/* binding */ ParallelogramNode),
/* harmony export */   createPNLeaf: () => (/* binding */ createPNLeaf)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _lineSegment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _parallelogram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogram.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");




function createPNLeaf(start, end, box, seg, eps) {
    return {
        parallelogram: box,
        seg: seg,
        leafBoxesOffset: eps,
        node: {
            low: start,
            high: end,
            chord: null, // create a cord only the segment and the chord are within intersectionEpsilon
        },
    };
}
class ParallelogramNode {
    static distToSegm(p, s, e) {
        const l = e.sub(s);
        if (l.length < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.intersectionEpsilon)
            return p.sub(s.add(e).div(2)).length;
        let perp = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(-l.y, l.x);
        perp = perp.mul(1 / perp.length);
        return Math.abs(p.sub(s).dot(perp));
    }
    static createParallelogramOnSubSeg(start, end, seg) {
        let tan1 = seg.derivative(start);
        const tan2 = seg.derivative(end);
        const tan2Perp = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(-tan2.y, tan2.x);
        const corner = seg.value(start);
        const e = seg.value(end);
        const p = e.sub(corner);
        const numerator = p.dot(tan2Perp);
        const denumerator = tan1.dot(tan2Perp);
        //x  = (p * tan2Perp) / (tan1 * tan2Perp);
        // x*tan1 will be a side of the parallelogram
        const numeratorTiny = Math.abs(numerator) < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon;
        if (!numeratorTiny && Math.abs(denumerator) < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
            //it is degenerated; the adjacent sides would be parallel, but
            //since p * tan2Perp is big the parallelogram would not contain e
            return;
        }
        const x = numeratorTiny ? 0 : numerator / denumerator;
        tan1 = tan1.mul(x);
        return _parallelogram__WEBPACK_IMPORTED_MODULE_2__.Parallelogram.parallelogramByCornerSideSide(corner, tan1, e.sub(corner).sub(tan1));
    }
    static createParallelogramNodeForCurveSeg(start, end, seg, eps) {
        const closedSeg = start === seg.parStart && end === seg.parEnd && _point__WEBPACK_IMPORTED_MODULE_0__.Point.close(seg.start, seg.end, _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon);
        if (closedSeg)
            return ParallelogramNode.createNodeWithSegmentSplit(start, end, seg, eps);
        const s = seg.value(start);
        const e = seg.value(end);
        const w = e.sub(s);
        const middle = seg.value((start + end) / 2);
        if (ParallelogramNode.distToSegm(middle, s, e) <= _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.intersectionEpsilon &&
            w.dot(w) < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.lineSegmentThreshold * _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.lineSegmentThreshold &&
            end - start < _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.lineSegmentThreshold) {
            const ls = _lineSegment__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(s, e);
            const pn = ls.pNodeOverICurve();
            pn.seg = seg;
            const leaf = pn.node;
            leaf.low = start;
            leaf.high = end;
            leaf.chord = ls;
            return pn;
        }
        if (ParallelogramNode.WithinEpsilon(seg, start, end, eps)) {
            const box = ParallelogramNode.createParallelogramOnSubSeg(start, end, seg);
            if (box !== undefined)
                return createPNLeaf(start, end, box, seg, eps);
        }
        return ParallelogramNode.createNodeWithSegmentSplit(start, end, seg, eps);
    }
    static WithinEpsilon(seg, start, end, eps) {
        const n = 3; //hack !!!! but maybe can be proven for Bezier curves and other regular curves
        const d = (end - start) / n;
        const s = seg.value(start);
        const e = seg.value(end);
        const d0 = ParallelogramNode.distToSegm(seg.value(start + d), s, e);
        if (d0 > eps)
            return false;
        const d1 = ParallelogramNode.distToSegm(seg.value(start + d * (n - 1)), s, e);
        return d1 <= eps;
    }
    static createParallelogramNodeForCurveSegDefaultOffset(seg) {
        return ParallelogramNode.createParallelogramNodeForCurveSeg(seg.parStart, seg.parEnd, seg, _geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.defaultLeafBoxesOffset);
    }
    static createNodeWithSegmentSplit(start, end, ell, eps) {
        const pBNode = {
            parallelogram: null,
            seg: ell,
            leafBoxesOffset: 1,
            node: { children: [] },
        };
        const intNode = pBNode.node;
        intNode.children.push(ParallelogramNode.createParallelogramNodeForCurveSeg(start, 0.5 * (start + end), ell, eps));
        intNode.children.push(ParallelogramNode.createParallelogramNodeForCurveSeg(0.5 * (start + end), end, ell, eps));
        pBNode.parallelogram = _parallelogram__WEBPACK_IMPORTED_MODULE_2__.Parallelogram.parallelogramOfTwo(intNode.children[0].parallelogram, intNode.children[1].parallelogram);
        return pBNode;
    }
}
//# sourceMappingURL=parallelogramNode.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/planeTransformation.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlaneTransformation: () => (/* binding */ PlaneTransformation)
/* harmony export */ });
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");


// 2 by 3 matrix of plane affine transformations
class PlaneTransformation {
    // the matrix elements
    get Elements() {
        return this.elements;
    }
    // i,j th element
    getElem(i, j) {
        return this.elements[i][j];
    }
    setElem(i, j, v) {
        this.elements[i][j] = v;
    }
    // Divid matrix by a matrix
    static Divide(m0, m1) {
        return m0.multiply(m1.inverse());
    }
    isIdentity() {
        return ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.closeDistEps)(this.elements[0][0], 1) &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.closeDistEps)(this.elements[0][1], 0) &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.closeDistEps)(this.elements[0][2], 0) &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.closeDistEps)(this.elements[1][0], 0) &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.closeDistEps)(this.elements[1][1], 1) &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.closeDistEps)(this.elements[1][2], 0));
    }
    // returns the point of the matrix offset
    offset() {
        return new _point__WEBPACK_IMPORTED_MODULE_1__.Point(this.getElem(0, 2), this.getElem(1, 2));
    }
    static getIdentity() {
        return new PlaneTransformation(1, 0, 0, 0, 1, 0);
    }
    constructor(m00, m01, m02, m10, m11, m12) {
        this.elements = [
            [m00, m01, m02],
            [m10, m11, m12],
        ];
    }
    // Rotation matrix - rotates counterclockwise by 'angle'
    static rotation(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new PlaneTransformation(cos, -sin, 0, sin, cos, 0);
    }
    static scaleAroundCenterTransformation(xScale, yScale, center) {
        /*var toOrigin = new PlaneTransformation(1, 0, -center.x, 0, 1, -center.y);
      var scaconstr = new PlaneTransformation(scale, 0, 0,
      0, scale, 0);
      var toCenter = new PlaneTransformation(1, 0, center.x, 0, 1, center.y);
      var t = toCenter*scaconstr*toOrigin;
      return t;*/
        const dX = 1 - xScale;
        const dY = 1 - yScale;
        return new PlaneTransformation(xScale, 0, dX * center.x, 0, yScale, dY * center.y);
    }
    // Point by matrix multiplication
    multiplyPoint(p) {
        return new _point__WEBPACK_IMPORTED_MODULE_1__.Point(this.getElem(0, 0) * p.x + this.getElem(0, 1) * p.y + this.getElem(0, 2), this.getElem(1, 0) * p.x + this.getElem(1, 1) * p.y + this.getElem(1, 2));
    }
    // matrix matrix multiplication
    multiply(b) {
        if (b != null)
            return new PlaneTransformation(this.getElem(0, 0) * b.getElem(0, 0) + this.getElem(0, 1) * b.getElem(1, 0), this.getElem(0, 0) * b.getElem(0, 1) + this.getElem(0, 1) * b.getElem(1, 1), this.getElem(0, 0) * b.getElem(0, 2) + this.getElem(0, 1) * b.getElem(1, 2) + this.getElem(0, 2), this.getElem(1, 0) * b.getElem(0, 0) + this.getElem(1, 1) * b.getElem(1, 0), this.getElem(1, 0) * b.getElem(0, 1) + this.getElem(1, 1) * b.getElem(1, 1), this.getElem(1, 0) * b.getElem(0, 2) + this.getElem(1, 1) * b.getElem(1, 2) + this.getElem(1, 2));
        return null;
    }
    // returns the inversed matrix
    inverse() {
        const det = this.getElem(0, 0) * this.getElem(1, 1) - this.getElem(1, 0) * this.getElem(0, 1);
        const a00 = this.getElem(1, 1) / det;
        const a01 = -this.getElem(0, 1) / det;
        const a10 = -this.getElem(1, 0) / det;
        const a11 = this.getElem(0, 0) / det;
        const a02 = -a00 * this.getElem(0, 2) - a01 * this.getElem(1, 2);
        const a12 = -a10 * this.getElem(0, 2) - a11 * this.getElem(1, 2);
        return new PlaneTransformation(a00, a01, a02, a10, a11, a12);
    }
}
//# sourceMappingURL=planeTransformation.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/point.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Point: () => (/* binding */ Point),
/* harmony export */   TriangleOrientation: () => (/* binding */ TriangleOrientation),
/* harmony export */   distPP: () => (/* binding */ distPP)
/* harmony export */ });
/* harmony import */ var _linearSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/linearSystem.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");



//import {Assert} from '../../utils/assert'
var TriangleOrientation;
(function (TriangleOrientation) {
    TriangleOrientation[TriangleOrientation["Clockwise"] = 0] = "Clockwise";
    TriangleOrientation[TriangleOrientation["Counterclockwise"] = 1] = "Counterclockwise";
    TriangleOrientation[TriangleOrientation["Collinear"] = 2] = "Collinear";
})(TriangleOrientation || (TriangleOrientation = {}));
function distPP(a, b) {
    return a.sub(b).length;
}
/** represents a point with two coordinates on the plane */
class Point {
    static RoundPoint(point) {
        return new Point(Point.RoundDouble(point.x), Point.RoundDouble(point.y));
    }
    static RoundDouble(num) {
        return Math.round(num * _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.mult) / _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.mult;
    }
    toJSON() {
        return { x: this.x, y: this.y };
    }
    static fromJSON(pData) {
        return new Point(pData.x, pData.y);
    }
    /** c is projected to line through a, b */
    static ProjectionToLine(a, b, c) {
        let d = b.sub(a);
        const dLen = d.length;
        if (dLen < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            return a;
        }
        d = d.div(dLen);
        const pr = c.sub(a).dot(d);
        // projection
        const ret = a.add(d.mul(pr));
        //Assert.assert(Math.abs(c.sub(ret).dot(d)) < GeomConstants.distanceEpsilon)
        return ret;
    }
    static RayIntersectsRayInteriors(aOrig, aDir, bOrig, bDir) {
        const x = Point.lineLineIntersection(aOrig, aOrig.add(aDir), bOrig, bOrig.add(bDir));
        if (!x)
            return undefined;
        if (x.sub(aOrig).dot(aDir.div(aDir.l1)) > _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon &&
            x.sub(bOrig).dot(bDir.div(bDir.l1)) > _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon)
            return x;
        return undefined;
    }
    static IntervalIntersectsRay(segStart, segEnd, rayOrigin, rayDirection) {
        const x = Point.lineLineIntersection(segStart, segEnd, rayOrigin, rayOrigin.add(rayDirection));
        if (!x) {
            return;
        }
        const ds = segStart.sub(x);
        const de = x.sub(segEnd);
        if (ds.dot(de) <= 0) {
            return;
        }
        if (x.sub(rayOrigin).dot(rayDirection) < 0) {
            return;
        }
        if (ds.dot(ds) > _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.squareOfDistanceEpsilon && de.dot(de) >= _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.squareOfDistanceEpsilon)
            return x;
    }
    static PointToTheLeftOfLineOrOnLine(point, linePoint0, linePoint1) {
        return Point.signedDoubledTriangleArea(point, linePoint0, linePoint1) >= 0;
    }
    // returns true if "point" lies to the left of the line linePoint0, linePoint1
    static PointToTheLeftOfLine(point, linePoint0, linePoint1) {
        return Point.signedDoubledTriangleArea(point, linePoint0, linePoint1) > 0;
    }
    static PointIsInsideCone(p, apex, leftSideConePoint, rightSideConePoint) {
        return (Point.PointToTheRightOfLineOrOnLine(p, apex, leftSideConePoint) && Point.PointToTheLeftOfLineOrOnLine(p, apex, rightSideConePoint));
    }
    static PointToTheRightOfLineOrOnLine(point, linePoint0, linePoint1) {
        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, point) <= 0;
    }
    static PointToTheRightOfLine(point, linePoint0, linePoint1) {
        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, point) < 0;
    }
    static closeIntersections(a, b) {
        return Point.close(a, b, _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon);
    }
    get l1() {
        return Math.abs(this.x_) + Math.abs(this.y_);
    }
    dot(a) {
        return this.x * a.x + this.y * a.y;
    }
    get x() {
        return this.x_;
    }
    get y() {
        return this.y_;
    }
    compareTo(other) {
        const r = (0,_utils_compare__WEBPACK_IMPORTED_MODULE_2__.compareNumbers)(this.x, other.x);
        if (r !== 0)
            return r;
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_2__.compareNumbers)(this.y, other.y);
    }
    toString() {
        return '(' + this.x + ',' + this.y + ')';
    }
    static close(a, b, tol) {
        return a.sub(b).length <= tol;
    }
    static closeSquare(a, b, tol) {
        const d = b.sub(a);
        return d.dot(d) <= tol;
    }
    static closeDistEps(a, b, eps = _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
        return a.sub(b).length <= eps;
    }
    normalize() {
        const l = this.length;
        return new Point(this.x / l, this.y / l);
    }
    get length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    get lengthSquared() {
        return this.x * this.x + this.y * this.y;
    }
    constructor(x, y) {
        // Assert.assert(!(isNaN(x) || isNaN(y)))
        this.x_ = x;
        this.y_ = y;
    }
    static middle(a, b) {
        return a.add(b).div(2);
    }
    scale(sx, sy) {
        return new Point(this.x * sx, this.y * sy);
    }
    add(a) {
        return new Point(this.x + a.x, this.y + a.y);
    }
    sub(a) {
        return new Point(this.x - a.x, this.y - a.y);
    }
    mul(c) {
        return new Point(this.x * c, this.y * c);
    }
    div(c) {
        return new Point(this.x / c, this.y / c);
    }
    equal(a) {
        return a.x === this.x && a.y === this.y;
    }
    neg() {
        return new Point(-this.x, -this.y);
    }
    static lineLineIntersection(a, b, c, d) {
        //look for the solution of the form a+u*(b-a)=c+v*(d-c)
        const ba = b.sub(a);
        const cd = c.sub(d);
        const ca = c.sub(a);
        const ret = _linearSystem__WEBPACK_IMPORTED_MODULE_0__.LinearSystem2.solve(ba.x, cd.x, ca.x, ba.y, cd.y, ca.y);
        if (ret !== undefined) {
            return a.add(ba.mul(ret.x));
        }
        else {
            return;
        }
    }
    static segSegIntersection(a, b, c, d) {
        //look for the solution of the form a+u*(b-a)=c+v*(d-c)
        const ba = b.sub(a);
        const cd = c.sub(d);
        const ca = c.sub(a);
        const eps = _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance;
        const ret = _linearSystem__WEBPACK_IMPORTED_MODULE_0__.LinearSystem2.solve(ba.x, cd.x, ca.x, ba.y, cd.y, ca.y);
        if (ret !== undefined && ret.x > -eps && ret.x < 1.0 + eps && ret.y > -eps && ret.y < 1.0 + eps) {
            return a.add(ba.mul(ret.x));
        }
        else {
            return;
        }
    }
    static parallelWithinEpsilon(a, b, eps) {
        const alength = a.length;
        const blength = b.length;
        if (alength < eps || blength < eps)
            return true;
        a = a.div(alength);
        b = b.div(blength);
        return Math.abs(-a.x * b.y + a.y * b.x) < eps;
    }
    static crossProduct(point0, point1) {
        return point0.x * point1.y - point0.y * point1.x;
    }
    static dot(a, b) {
        return a.x * b.x + a.y * b.y;
    }
    static add(a, b) {
        return a.add(b);
    }
    rotate90Ccw() {
        return new Point(-this.y, this.x);
    }
    rotate90Cw() {
        return new Point(this.y, -this.x);
    }
    clone() {
        return new Point(this.x, this.y);
    }
    // returns this rotated by the angle counterclockwise; does not change "this" value
    rotate(angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return new Point(c * this.x - s * this.y, s * this.x + c * this.y);
    }
    static mkPoint(x, a, y, b) {
        return a.mul(x).add(b.mul(y));
    }
    static convSum(x, a, b) {
        return a.add(b.sub(a).mul(x));
    }
    static anglePCP(point1, center, point3) {
        return Point.angle(point1.sub(center), point3.sub(center));
    }
    // The angle you need to turn "side0" counterclockwise to make it collinear with "side1"
    static angle(side0, side1) {
        const ax = side0.x;
        const ay = side0.y;
        const bx = side1.x;
        const by = side1.y;
        const cross = ax * by - ay * bx;
        const dot = ax * bx + ay * by;
        if (Math.abs(dot) < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
            if (Math.abs(cross) < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance)
                return 0;
            if (cross < -_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance)
                return (3 * Math.PI) / 2;
            return Math.PI / 2;
        }
        if (Math.abs(cross) < _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
            if (dot < -_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance)
                return Math.PI;
            return 0.0;
        }
        const atan2 = Math.atan2(cross, dot);
        if (cross >= -_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance)
            return atan2;
        return Math.PI * 2.0 + atan2;
    }
    static signedDoubledTriangleArea(a, b, c) {
        return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
    }
    static getTriangleOrientation(cornerA, cornerB, cornerC) {
        const area = Point.signedDoubledTriangleArea(cornerA, cornerB, cornerC);
        if (area > _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon)
            return TriangleOrientation.Counterclockwise;
        if (area < -_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon)
            return TriangleOrientation.Clockwise;
        return TriangleOrientation.Collinear;
    }
    static getTriangleOrientationWithIntersectionEpsilon(cornerA, cornerB, cornerC) {
        const area = Point.signedDoubledTriangleArea(cornerA, cornerB, cornerC);
        if (area > _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon)
            return TriangleOrientation.Counterclockwise;
        if (area < -_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon)
            return TriangleOrientation.Clockwise;
        return TriangleOrientation.Collinear;
    }
    static ClosestPointAtLineSegment(point, segmentStart, segmentEnd) {
        const bc = segmentEnd.sub(segmentStart);
        const ba = point.sub(segmentStart);
        const c1 = bc.dot(ba);
        const c2 = bc.dot(bc);
        if (c1 <= 0.0 + _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance)
            return segmentStart;
        if (c2 <= c1 + _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance)
            return segmentEnd;
        return segmentStart.add(bc.mul(c1 / c2));
    }
    static pointToTheLeftOfLineOrOnLine(point, linePoint0, linePoint1) {
        return Point.signedDoubledTriangleArea(point, linePoint0, linePoint1) >= 0;
    }
    // returns true if "point" lies to the left of the line linePoint0, linePoint1
    static pointToTheLeftOfLine(point, linePoint0, linePoint1) {
        return Point.signedDoubledTriangleArea(point, linePoint0, linePoint1) > 0;
    }
    // returns true if "point" lies to the right of the line linePoint0, linePoint1
    static pointToTheRightOfLineOrOnLine(point, linePoint0, linePoint1) {
        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, point) <= 0;
    }
    static pointToTheRightOfLine(point, linePoint0, linePoint1) {
        return Point.signedDoubledTriangleArea(linePoint0, linePoint1, point) < 0;
    }
    static canProject(point, segmentStart, segmentEnd) {
        const bc = segmentEnd.sub(segmentStart);
        const ba = point.sub(segmentStart);
        if (ba.dot(bc) < 0)
            // point belongs to the halfplane before the segment
            return false;
        const ca = point.sub(segmentEnd);
        if (ca.dot(bc) > 0)
            //point belongs to the halfplane after the segment
            return false;
        return true;
    }
    static distToLineSegment(a, b, c) {
        const bc = c.sub(b);
        const ba = a.sub(b);
        let c1, c2;
        if ((c1 = bc.dot(ba)) <= _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
            return { par: 0, dist: ba.length };
        }
        if ((c2 = bc.dot(bc)) <= c1 + _geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
            return { par: 1, dist: a.sub(c).length };
        }
        const p = c1 / c2;
        return { par: p, dist: b.add(bc.mul(p)).length };
    }
}
//# sourceMappingURL=point.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/pointPair.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointPair: () => (/* binding */ PointPair)
/* harmony export */ });
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");


/** An unordered pair of points */
class PointPair {
    constructor(first, second) {
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.comparePointsYFirst)(first, second) < 0) {
            this._first = first;
            this._second = second;
        }
        else {
            this._first = second;
            this._second = first;
        }
    }
    get first() {
        return this._first;
    }
    get second() {
        return this._second;
    }
    get Length() {
        return (0,_point__WEBPACK_IMPORTED_MODULE_1__.distPP)(this._first, this._second);
    }
    CompareTo(other) {
        const cr = (0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.comparePointsYFirst)(this._first, other._first);
        if (cr !== 0) {
            return cr;
        }
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.comparePointsYFirst)(this._second, other._second);
    }
    static equal(pair0, pair1) {
        return pair0._first.equal(pair1._first) && pair0._second.equal(pair1._second);
    }
    toString() {
        return this._first + (' ' + this._second);
    }
}
//# sourceMappingURL=pointPair.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/polyline.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polyline: () => (/* binding */ Polyline)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _polylinePoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js");
/* harmony import */ var _parallelogram__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/parallelogram.js");
/* harmony import */ var _lineSegment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");






/** the curve corresponding to the sequence of lines, could be closed when the start coincides with the end */
class Polyline {
    constructor() {
        this.initIsRequired = true;
        this.isClosed_ = false;
    }
    toJSON() {
        return { points: Array.from(this).map((p) => p.toJSON()) };
    }
    static fromJSON(data) {
        return Polyline.mkFromPoints(data.points.map((p) => _point__WEBPACK_IMPORTED_MODULE_0__.Point.fromJSON(p)));
    }
    RemoveStartPoint() {
        const p = this.startPoint.next;
        p.prev = null;
        this.startPoint = p;
        this.setInitIsRequired();
    }
    RemoveEndPoint() {
        const p = this.endPoint.prev;
        p.next = null;
        this.endPoint = p;
        this.setInitIsRequired();
    }
    setInitIsRequired() {
        this.initIsRequired = true;
    }
    addPointXY(x, y) {
        this.addPoint(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x, y));
    }
    /** should true, by internal assumptions,  in general for convex polylines */
    isClockwise() {
        return (_point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.startPoint.point, this.startPoint.next.point, this.startPoint.next.next.point) ==
            _point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Clockwise);
    }
    /**  adds a point to the polyline */
    addPoint(p) {
        // Assert.assert(
        //  this.endPoint == null  || !Point.closeDistEps(p, this.endPoint.point),
        // )
        const pp = new _polylinePoint__WEBPACK_IMPORTED_MODULE_2__.PolylinePoint();
        pp.polyline = this;
        pp.point = p.clone();
        if (this.endPoint != null) {
            // if (!ApproximateComparer.Close(point, this.endPoint.Point)) {
            this.endPoint.next = pp;
            pp.prev = this.endPoint;
            this.endPoint = pp;
            // }
        }
        else {
            this.startPoint = this.endPoint = pp;
        }
        this.setInitIsRequired();
    }
    PrependPoint(p) {
        // Assert.assert(this.endPoint == null  || !Point.closeDistEps(p, this.endPoint.point))
        const pp = _polylinePoint__WEBPACK_IMPORTED_MODULE_2__.PolylinePoint.mkFromPoint(p);
        pp.polyline = this;
        if (this.startPoint != null) {
            if (!_point__WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(p, this.startPoint.point)) {
                this.startPoint.prev = pp;
                pp.next = this.startPoint;
                this.startPoint = pp;
            }
        }
        else {
            this.endPoint = pp;
            this.startPoint = pp;
        }
        this.setInitIsRequired();
    }
    *[Symbol.iterator]() {
        for (let s = this.startPoint; s != null; s = s.next)
            yield s.point;
    }
    *polylinePoints() {
        for (let s = this.startPoint; s != null; s = s.next)
            yield s;
    }
    *skip(skipCount) {
        for (let s = this.startPoint; s != null; s = s.next) {
            if (skipCount > 0)
                skipCount--;
            else
                yield s;
        }
    }
    static parallelogramOfLineSeg(a, b) {
        const side = b.sub(a).div(2);
        return _parallelogram__WEBPACK_IMPORTED_MODULE_3__.Parallelogram.parallelogramByCornerSideSide(a, side, side);
    }
    static mkFromPoints(ps) {
        const r = new Polyline();
        for (const p of ps) {
            r.addPoint(p);
        }
        return r;
    }
    static mkClosedFromPoints(ps) {
        const r = Polyline.mkFromPoints(ps);
        r.closed = true;
        return r;
    }
    calculatePbNode() {
        const parallelograms = [];
        const children = [];
        let pp = this.startPoint;
        let offset = 0;
        while (pp.next != null) {
            const parallelogram = Polyline.parallelogramOfLineSeg(pp.point, pp.next.point);
            parallelograms.push(parallelogram);
            children.push({
                parallelogram: parallelogram,
                seg: this,
                leafBoxesOffset: 0,
                node: {
                    low: offset,
                    high: offset + 1,
                    chord: _lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(pp.point, pp.next.point),
                },
            });
            pp = pp.next;
            offset++;
        }
        if (this.isClosed_) {
            const parallelogram = Polyline.parallelogramOfLineSeg(this.endPoint.point, this.startPoint.point);
            parallelograms.push(parallelogram);
            children.push({
                parallelogram: parallelogram,
                seg: this,
                leafBoxesOffset: 0,
                node: {
                    low: offset,
                    high: offset + 1,
                    chord: _lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.endPoint.point, this.startPoint.point),
                },
            });
        }
        this.pBNode = {
            parallelogram: _parallelogram__WEBPACK_IMPORTED_MODULE_3__.Parallelogram.getParallelogramOfAGroup(parallelograms),
            seg: this,
            leafBoxesOffset: 0,
            node: {
                children: children,
            },
        };
    }
    init() {
        this.bBox = _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.rectangleOnPoint(this.startPoint.point);
        for (const p of this.skip(1)) {
            this.bBox.add(p.point);
        }
        this.updateCount();
        this.calculatePbNode();
        this.initIsRequired = false;
    }
    updateCount() {
        this.count_ = 0;
        for (let pp = this.startPoint; pp != null; pp = pp.next) {
            this.count_++;
        }
    }
    get count() {
        if (this.initIsRequired)
            this.init();
        return this.count_;
    }
    get closed() {
        return this.isClosed_;
    }
    set closed(value) {
        this.isClosed_ = value;
    }
    value(t) {
        if (this.initIsRequired)
            this.init();
        const p = this.getAdjustedParamAndStartEndPoints(t);
        return _point__WEBPACK_IMPORTED_MODULE_0__.Point.convSum(p.t, p.a, p.b);
    }
    getAdjustedParamAndStartEndPoints(t) {
        /*Assert.assert(t >= -GeomConstants.tolerance)*/
        /*Assert.assert(this.startPoint != null)*/
        let s = this.startPoint;
        while (s.next != null) {
            if (t <= 1) {
                return {
                    a: s.point,
                    b: s.next.point,
                    t: t,
                };
            }
            s = s.next;
            t -= 1;
        }
        if (this.closed) {
            if (t <= 1) {
                return {
                    a: this.endPoint.point,
                    b: this.startPoint.point,
                    t: t,
                };
            }
        }
        throw new Error('out of the parameter domain');
    }
    derivative(t) {
        const ap = this.getAdjustedParamAndStartEndPoints(t);
        return ap.b.sub(ap.a);
    }
    secondDerivative(t) {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
    }
    thirdDerivative(t) {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
    }
    pNodeOverICurve() {
        if (this.initIsRequired)
            this.init();
        return this.pBNode;
    }
    get boundingBox() {
        if (this.initIsRequired)
            this.init();
        return this.bBox;
    }
    get parStart() {
        return 0;
    }
    get parEnd() {
        if (this.initIsRequired)
            this.init();
        return this.closed ? this.count_ : this.count_ - 1;
    }
    static polylineFromCurve(curve) {
        const ret = new Polyline();
        ret.addPoint(curve.start);
        for (const ls of curve.segs)
            ret.addPoint(ls.end);
        ret.closed = curve.start === curve.end;
        return ret;
    }
    trim(start, end) {
        //this is a very lazy version!
        let curve = this.toCurve();
        curve = curve.trim(start, end);
        /* always convert to Polyline */
        if (curve instanceof _curve__WEBPACK_IMPORTED_MODULE_5__.Curve)
            return Polyline.polylineFromCurve(curve);
        else
            return Polyline.mkFromPoints([curve.start, curve.end]);
    }
    trimWithWrap(start, end) {
        throw new Error('Method not implemented.');
    }
    translate(delta) {
        let p = this.startPoint;
        do {
            p.point = p.point.add(delta);
            if (p === this.endPoint)
                break;
            p = p.getNext();
        } while (true);
        this.setInitIsRequired();
    }
    scaleFromOrigin(xScale, yScale) {
        throw new Error('Method not implemented.');
    }
    get start() {
        return this.startPoint.point;
    }
    get end() {
        return this.endPoint.point;
    }
    reverse() {
        const r = new Polyline();
        r.closed = this.closed;
        let p = this.endPoint;
        do {
            r.addPoint(p.point);
            if (p === this.startPoint)
                break;
            p = p.getPrev();
        } while (true);
        return r;
    }
    offsetCurve(offset, dir) {
        throw new Error('Method not implemented.');
    }
    lengthPartial(start, end) {
        throw new Error('Method not implemented.');
    }
    get length() {
        throw new Error('Method not implemented.');
    }
    getParameterAtLength(length) {
        throw new Error('Method not implemented.');
    }
    transform(transformation) {
        const ret = new Polyline();
        for (const p of this.polylinePoints()) {
            ret.addPoint(transformation.multiplyPoint(p.point));
        }
        ret.closed = this.closed;
        return ret;
    }
    closestParameterWithinBounds(targetPoint, low, high) {
        throw new Error('Method not implemented.');
    }
    closestParameter(targetPoint) {
        let ret = 0;
        let dist = Number.MAX_VALUE;
        let offset = 0;
        let pp = this.startPoint;
        while (pp.next != null) {
            const ls = _lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(pp.point, pp.next.point);
            const t = ls.closestParameter(targetPoint);
            const delta = ls.value(t).sub(targetPoint);
            const newDist = delta.dot(delta);
            if (newDist < dist) {
                dist = newDist;
                ret = t + offset;
            }
            pp = pp.next;
            offset++;
        }
        if (this.closed) {
            const ls = _lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.endPoint.point, this.startPoint.point);
            const t = ls.closestParameter(targetPoint);
            const delta = ls.value(t).sub(targetPoint);
            const newDist = delta.dot(delta);
            if (newDist < dist) {
                ret = t + offset;
            }
        }
        return ret;
    }
    clone() {
        const r = new Polyline();
        r.closed = this.closed;
        let p = this.startPoint;
        do {
            r.addPoint(p.point);
            if (p === this.endPoint)
                break;
            p = p.getNext();
        } while (true);
        return r;
    }
    leftDerivative(t) {
        throw new Error('Method not implemented.');
    }
    rightDerivative(t) {
        throw new Error('Method not implemented.');
    }
    curvature(t) {
        throw new Error('Method not implemented.');
    }
    curvatureDerivative(t) {
        throw new Error('Method not implemented.');
    }
    curvatureSecondDerivative(t) {
        throw new Error('Method not implemented.');
    }
    next(a) {
        var _a;
        return (_a = a.next) !== null && _a !== void 0 ? _a : (this.closed ? this.startPoint : null);
    }
    prev(a) {
        var _a;
        return (_a = a.prev) !== null && _a !== void 0 ? _a : (this.closed ? this.endPoint : null);
    }
    toCurve() {
        const c = new _curve__WEBPACK_IMPORTED_MODULE_5__.Curve();
        _curve__WEBPACK_IMPORTED_MODULE_5__.Curve.addLineSegment(c, this.startPoint.point, this.startPoint.next.point);
        let p = this.startPoint.next;
        while ((p = p.next) != null)
            _curve__WEBPACK_IMPORTED_MODULE_5__.Curve.continueWithLineSegmentP(c, p.point);
        if (this.closed)
            _curve__WEBPACK_IMPORTED_MODULE_5__.Curve.continueWithLineSegmentP(c, this.startPoint.point);
        return c;
    }
    RemoveCollinearVertices() {
        for (let pp = this.startPoint.next; pp.next != null; pp = pp.next) {
            if (_point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(pp.prev.point, pp.point, pp.next.point) === _point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear) {
                pp.prev.next = pp.next;
                pp.next.prev = pp.prev;
            }
        }
        this.setInitIsRequired();
        return this;
    }
}
//# sourceMappingURL=polyline.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolylinePoint: () => (/* binding */ PolylinePoint)
/* harmony export */ });
class PolylinePoint {
    constructor() {
        this._next = null;
        this.prev = null;
    }
    get point() {
        return this._point;
    }
    set point(value) {
        this._point = value;
    }
    get next() {
        return this._next;
    }
    set next(value) {
        this._next = value;
    }
    get nextOnPolyline() {
        return this.polyline.next(this);
    }
    get prevOnPolyline() {
        return this.polyline.prev(this);
    }
    //
    getNext() {
        return this.next;
    }
    setNext(nVal) {
        this.next = nVal;
        if (this.polyline != null)
            this.polyline.setInitIsRequired();
    }
    //
    getPrev() {
        return this.prev;
    }
    setPrev(prevVal) {
        this.prev = prevVal;
        if (this.polyline != null)
            this.polyline.setInitIsRequired();
    }
    static mkFromPoint(p) {
        const pp = new PolylinePoint();
        pp.point = p;
        return pp;
    }
}
//# sourceMappingURL=polylinePoint.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/rectangle.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rectangle: () => (/* binding */ Rectangle),
/* harmony export */   Size: () => (/* binding */ Size)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _geomConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");




class Size {
    pad(padW) {
        this.width += padW * 2;
    }
    /** creates a square if called with width only */
    constructor(width, height = width) {
        this.width = width;
        this.height = height;
    }
}
class Rectangle {
    /** this function will not work correctly for transformations that are not translations, or rotations by n*90, or a combination of those */
    transform(m) {
        return Rectangle.mkPP(m.multiplyPoint(this.leftTop), m.multiplyPoint(this.rightBottom));
    }
    translate(m) {
        return Rectangle.mkSizeCenter(this.size, this.center.add(m));
    }
    /** Returns true iff the rectangles are geometrically identical */
    equal(bbox) {
        return this.left_ === bbox.left && this.right_ === bbox.right && this.top_ === bbox.top && this.bottom_ === bbox.bottom;
    }
    /** Returns true iff the rectangles are distEpsilon close */
    equalEps(bbox) {
        return ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(this.left_, bbox.left) &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(this.right_, bbox.right) &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(this.top_, bbox.top) &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(this.bottom_, bbox.bottom));
    }
    /** make a rectangle with the given size and center */
    static mkSizeCenter(size, center) {
        const w = size.width / 2;
        const h = size.height / 2;
        return new Rectangle({
            left: center.x - w,
            right: center.x + w,
            bottom: center.y - h,
            top: center.y + h,
        });
    }
    constructor(t) {
        this.left_ = t.left;
        this.right_ = t.right;
        this.top_ = t.top;
        this.bottom = t.bottom;
    }
    add_rect(rectangle) {
        return this.addRec(rectangle);
    }
    contains_point(point) {
        return this.contains(point);
    }
    contains_rect(rect) {
        return this.containsRect(rect);
    }
    intersection_rect(rectangle) {
        return this.intersection(rectangle);
    }
    intersects_rect(rectangle) {
        return this.intersects(rectangle);
    }
    unite(b) {
        return Rectangle.rectangleOfTwo(this, b);
    }
    contains_point_radius(p, radius) {
        return this.containsWithPadding(p, radius);
    }
    // returns true if r intersect this rectangle
    intersects(rectangle) {
        return this.intersectsOnX(rectangle) && this.intersectsOnY(rectangle);
    }
    // intersection (possibly empty) of rectangles
    intersection(rectangle) {
        if (!this.intersects(rectangle)) {
            const intersection = Rectangle.mkEmpty();
            intersection.setToEmpty();
            return intersection;
        }
        const l = Math.max(this.left, rectangle.left);
        const r = Math.min(this.right, rectangle.right);
        const b = Math.max(this.bottom, rectangle.bottom);
        const t = Math.min(this.top, rectangle.top);
        return new Rectangle({ left: l, bottom: b, right: r, top: t });
    }
    // the center of the bounding box
    get center() {
        return this.leftTop.add(this.rightBottom).mul(0.5);
    }
    set center(value) {
        const cen = this.leftTop.add(this.rightBottom).mul(0.5);
        const shift = value.sub(cen);
        this.leftTop = this.leftTop.add(shift);
        this.rightBottom = this.rightBottom.add(shift);
    }
    intersectsOnY(r) {
        if (r.bottom_ > this.top_ + _geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon)
            return false;
        if (r.top_ < this.bottom_ - _geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon)
            return false;
        return true;
    }
    intersectsOnX(r) {
        if (r.left > this.right_ + _geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon)
            return false;
        if (r.right < this.left_ - _geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon)
            return false;
        return true;
    }
    // creates an empty rectangle
    static mkEmpty() {
        return new Rectangle({ left: 0, right: -1, bottom: 0, top: -1 });
    }
    get left() {
        return this.left_;
    }
    set left(value) {
        this.left_ = value;
        this.onUpdated();
    }
    get right() {
        return this.right_;
    }
    set right(value) {
        this.right_ = value;
        this.onUpdated();
    }
    get top() {
        return this.top_;
    }
    set top(value) {
        this.top_ = value;
        this.onUpdated();
    }
    get bottom() {
        return this.bottom_;
    }
    set bottom(value) {
        this.bottom_ = value;
        this.onUpdated();
    }
    get leftBottom() {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.left_, this.bottom_);
    }
    set leftBottom(value) {
        this.left_ = value.x;
        this.bottom = value.y;
    }
    get rightTop() {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.right_, this.top_);
    }
    set rightTop(value) {
        this.right_ = value.x;
        this.top_ = value.y;
    }
    get leftTop() {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.left_, this.top_);
    }
    set leftTop(value) {
        this.left_ = value.x;
        this.top_ = value.y;
    }
    get rightBottom() {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.right_, this.bottom_);
    }
    set rightBottom(value) {
        this.right_ = value.x;
        this.bottom = value.y;
    }
    /* eslint-disable  @typescript-eslint/no-empty-function */
    onUpdated() { }
    // create a box of two points
    static mkPP(point0, point1) {
        const r = new Rectangle({
            left: point0.x,
            right: point0.x,
            top: point0.y,
            bottom: point0.y,
        });
        r.add(point1);
        return r;
    }
    // create rectangle from a point
    static rectangleOnPoint(p) {
        return new Rectangle({ left: p.x, right: p.x, top: p.y, bottom: p.y });
    }
    static mkLeftBottomSize(left, bottom, sizeF) {
        const right = left + sizeF.width;
        const top = bottom + sizeF.height;
        return new Rectangle({ left: left, right: right, top: top, bottom: bottom });
    }
    // create a box on points (x0,y0), (x1,y1)
    static getRectangleOnCoords(x0, y0, x1, y1) {
        const r = new Rectangle({ left: x0, bottom: y0, right: x0, top: y0 });
        r.add(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x1, y1));
        return r;
    }
    // Create rectangle that is the bounding box of the given points
    static mkOnPoints(points) {
        const r = Rectangle.mkEmpty();
        for (const p of points) {
            r.add(p);
        }
        return r;
    }
    // Create rectangle that is the bounding box of the given Rectangles
    static mkOnRectangles(rectangles) {
        const r = Rectangle.mkEmpty();
        for (const p of rectangles) {
            r.addRecSelf(p);
        }
        return r;
    }
    // the width of the rectangle
    get width() {
        return this.right_ - this.left_;
    }
    set width(value) {
        const hw = value / 2.0;
        const cx = (this.left_ + this.right_) / 2.0;
        this.left_ = cx - hw;
        this.right_ = cx + hw;
    }
    // returns true if the rectangle has negative width
    isEmpty() {
        return this.right < this.left;
    }
    // makes the rectangle empty
    setToEmpty() {
        this.left = 0;
        this.right = -1;
    }
    // height of the rectangle
    get height() {
        return this.top_ - this.bottom_;
    }
    set height(value) {
        const hw = value / 2.0;
        const cx = (this.top_ + this.bottom_) / 2.0;
        this.top_ = cx + hw;
        this.bottom = cx - hw;
    }
    // rectangle containing both a and b
    static rectangleOfTwo(a, b) {
        const r = new Rectangle({
            left: a.left_,
            right: a.right_,
            top: a.top_,
            bottom: a.bottom_,
        });
        r.addRecSelf(b);
        return r;
    }
    // contains with padding
    containsWithPadding(point, padding) {
        return (this.left_ - padding - _geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon <= point.x &&
            point.x <= this.right_ + padding + _geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon &&
            this.bottom_ - padding - _geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon <= point.y &&
            point.y <= this.top_ + padding + _geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon);
    }
    // Rectangle area
    get area() {
        return (this.right_ - this.left_) * (this.top_ - this.bottom_);
    }
    // adding a point to the rectangle
    add(point) {
        if (!this.isEmpty()) {
            if (this.left_ > point.x)
                this.left_ = point.x;
            if (this.top_ < point.y)
                this.top_ = point.y;
            if (this.right_ < point.x)
                this.right_ = point.x;
            if (this.bottom_ > point.y)
                this.bottom = point.y;
        }
        else {
            this.left_ = this.right_ = point.x;
            this.top_ = this.bottom = point.y;
        }
    }
    // adding rectangle
    addRecSelf(rectangle) {
        this.add(rectangle.leftTop);
        this.add(rectangle.rightBottom);
    }
    // adding rectangle
    addRec(rectangle) {
        const ret = this.clone();
        ret.add(rectangle.leftTop);
        ret.add(rectangle.rightBottom);
        return ret;
    }
    /**  Returns the translated clone of the specified rectangle */
    static translate(rectangle, delta) {
        const r = rectangle.clone();
        r.center = rectangle.center.add(delta);
        return r;
    }
    /**  Returns a new Rectangle which is the transform the input rectangle */
    static transform(rectangle, m) {
        return Rectangle.mkPP(m.multiplyPoint(rectangle.leftTop), m.multiplyPoint(rectangle.rightBottom));
    }
    // returns true if the rectangle contains the point
    contains(point) {
        return this.containsWithPadding(point, 0);
    }
    // returns true if this rectangle compconstely contains the specified rectangle
    containsRect(rect) {
        return this.contains(rect.leftTop) && this.contains(rect.rightBottom);
    }
    // returns true if this rectangle compconstely contains the specified rectangle
    containsRectWithPadding(rect, padding) {
        return this.containsWithPadding(rect.leftTop, padding) && this.containsWithPadding(rect.rightBottom, padding);
    }
    // return the length of the diagonal
    get diagonal() {
        return Math.sqrt(this.width * this.width + this.height * this.height);
    }
    // pad the rectangle horizontally by the given padding
    padWidth(padding) {
        this.left -= padding;
        this.right += padding;
    }
    // pad the rectangle vertically by the given padding
    padHeight(padding) {
        this.top += padding;
        this.bottom -= padding;
    }
    // pad the rectangle by the given padding
    pad(padding) {
        if (padding < -this.width / 2)
            padding = -this.width / 2;
        if (padding < -this.height / 2)
            padding = -this.height / 2;
        this.padWidth(padding);
        this.padHeight(padding);
    }
    // Pad the rectangle by the given amount on each side
    padEverywhere(margins) {
        this.left -= margins.left;
        this.right += margins.right;
        this.bottom -= margins.bottom;
        this.top += margins.top;
    }
    // Returns the intersection of two rectangles.
    static intersect(rect1, rect2) {
        if (rect1.intersects(rect2))
            return Rectangle.mkPP(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(Math.max(rect1.left, rect2.left), Math.max(rect1.bottom, rect2.bottom)), new _point__WEBPACK_IMPORTED_MODULE_0__.Point(Math.min(rect1.right, rect2.right), Math.min(rect1.top, rect2.top)));
        return Rectangle.mkEmpty();
    }
    perimeter() {
        const poly = new _polyline__WEBPACK_IMPORTED_MODULE_1__.Polyline();
        poly.addPoint(this.leftTop);
        poly.addPoint(this.rightTop);
        poly.addPoint(this.rightBottom);
        poly.addPoint(this.leftBottom);
        poly.closed = true;
        return poly;
    }
    scaleAroundCenter(scale) {
        this.width = this.width * scale;
        this.height = this.height * scale;
    }
    clone() {
        return new Rectangle({ left: this.left, right: this.right, top: this.top, bottom: this.bottom });
    }
    // gets or sets the Size
    get size() {
        return new Size(this.width, this.height);
    }
    set size(value) {
        this.width = value.width;
        this.height = value.height;
    }
    // constructor with Size and center
    static creatRectangleWithSize(size, center) {
        const w = size.width / 2;
        const left = center.x - w;
        const right = center.x + w;
        const h = size.height / 2;
        const bottom = center.y - h;
        const top = center.y + h;
        return new Rectangle({ left: left, right: right, top: top, bottom: bottom });
    }
    // adding a point with a Size
    addPointWithSize(size, point) {
        const w = size.width / 2;
        const h = size.height / 2;
        this.add(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(point.x - w, point.y - h));
        this.add(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(point.x + w, point.y - h));
        this.add(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(point.x - w, point.y + h));
        this.add(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(point.x + w, point.y + h));
    }
}
//# sourceMappingURL=rectangle.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/OptimalPacking.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OptimalPacking: () => (/* binding */ OptimalPacking)
/* harmony export */ });
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _PackingConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/PackingConstants.js");


// Pack rectangles (without rotation) into a given aspect ratio
class OptimalPacking extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__.Algorithm {
    constructor(rectangles, aspectRatio) {
        super(null);
        this.desiredAspectRatio = 1.2;
        this.bestPacking = null;
        this.cachedCosts = new Map();
        this.rectangles = rectangles;
        this.desiredAspectRatio = aspectRatio;
    }
    // The width of the widest row in the packed solution
    get PackedWidth() {
        if (this.bestPacking != null) {
            return this.bestPacking.PackedWidth;
        }
        return 0;
    }
    // The height of the bounding box of the packed solution
    get PackedHeight() {
        if (this.bestPacking != null) {
            return this.bestPacking.PackedHeight;
        }
        return 0;
    }
    Pack(lowerBound, upperBound, minGranularity) {
        const c0 = OptimalPacking.GetGoldenSectionStep(lowerBound, upperBound);
        // the worst case time complexity is O(n log(n)) where we have to do a full traversal of the
        // golden section search tree because it each stage the two candidate split points we chose had
        // the same cost.
        // the following calculation for precision limits the worst case time by making max(n) = MaxSteps.
        const precision = Math.max(minGranularity / 10, (upperBound - lowerBound) / OptimalPacking.MaxSteps);
        // need to overshoot upperbound when it is optimal
        upperBound += precision;
        this.bestPackingCost = Number.MAX_VALUE;
        if (this.rectangles.length === 1) {
            // the trivial solution for just one rectangle is widthLowerBound
            this.PackLimit(lowerBound);
        }
        else if (this.rectangles.length === 2) {
            // if we have 2 rectangles just try the two possibilities
            this.PackLimit(lowerBound);
            this.PackLimit(upperBound);
        }
        else if (this.rectangles.length > 2) {
            OptimalPacking.GoldenSectionSearch((l) => this.PackLimit(l), lowerBound, c0, upperBound, precision);
        }
        const newRects = this.bestPacking.getRects();
        for (let i = 0; i < this.rectangles.length; i++)
            this.rectangles[i] = newRects[i];
    }
    PackLimit(limit) {
        let cost = this.cachedCosts.get(limit);
        if (cost == null) {
            const packing = this.createPacking(this.rectangles, limit);
            packing.run();
            this.cachedCosts.set(limit, (cost = Math.abs(packing.PackedAspectRatio - this.desiredAspectRatio)));
            if (cost < this.bestPackingCost) {
                this.bestPackingCost = cost;
                this.bestPacking = packing;
            }
        }
        return cost;
    }
    // recursively searches a weakly unimodal function f(x) between x1 and x3 for the minimum.  It is assumed x2 \le x1 and x2 \le x3
    // and x2-x1=a \lt b=x3-x2.  The recursion generates a fourth point x4-x1=b \gt a=x3-x4 where x4-x2=c and b=a+c and:
    // if f(x4) \lt f(x2) we search in the range [x2, x3]
    // else if f(x2) \lt f(x4) we search in the range [x1, x4]
    // else
    // f(x2)==f(x4) and we know that f is only weakly unimodal (not strongly unimodal) and we must search both branches.
    static GoldenSectionSearch(f, x1, x2, x3, precision) {
        // check termination
        if (Math.abs(x1 - x3) < precision) {
            return f(x1) < f(x3) ? x1 : x3;
        }
        // x2 must be between x1 and x3
        /*Assert.assert(
          (x1 < x2 && x2 < x3) || (x3 < x2 && x2 < x1),
          'x2 not bounded by x1 and x3',
        )*/
        // x4 will be our new midpoint candidate
        const x4 = OptimalPacking.GetGoldenSectionStep(x2, x3);
        // now we have two candidates (x2,x4) both between x1 and x3: choose the bracket that most reduces f
        const fx2 = f(x2);
        const fx4 = f(x4);
        const leftSearch = () => OptimalPacking.GoldenSectionSearch(f, x4, x2, x1, precision);
        const rightSearch = () => OptimalPacking.GoldenSectionSearch(f, x2, x4, x3, precision);
        if (fx4 < fx2) {
            /*Assert.assert(
              Math.abs(x2 - x3) < Math.abs(x1 - x3),
              'Search region not narrowing!',
            )*/
            return rightSearch();
        }
        if (fx4 > fx2) {
            /*Assert.assert(
              Math.abs(x4 - x1) < Math.abs(x1 - x3),
              'Search region not narrowing!',
            )*/
            return leftSearch();
        }
        // Doh! f(x2) === f(x4)!  Have to search both branches.
        const right = rightSearch();
        const left = leftSearch();
        return f(left) < f(right) ? left : right;
    }
    static GetGoldenSectionStep(x1, x2) {
        if (x1 < x2) {
            return x1 + _PackingConstants__WEBPACK_IMPORTED_MODULE_1__.PackingConstants.GoldenRatioRemainder * (x2 - x1);
        }
        return x1 - _PackingConstants__WEBPACK_IMPORTED_MODULE_1__.PackingConstants.GoldenRatioRemainder * (x1 - x2);
    }
}
// controls the maximum number of steps we are allowed to take in our golden section search
// (actually worst case is O (n log n) for n=MaxSteps)
OptimalPacking.MaxSteps = 1000;
//# sourceMappingURL=OptimalPacking.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/OptimalRectanglePacking.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OptimalRectanglePacking: () => (/* binding */ OptimalRectanglePacking)
/* harmony export */ });
/* harmony import */ var _OptimalPacking__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/OptimalPacking.js");
/* harmony import */ var _RectanglePacking__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/RectanglePacking.js");


// Pack rectangles (without rotation) into a given aspect ratio
class OptimalRectanglePacking extends _OptimalPacking__WEBPACK_IMPORTED_MODULE_0__.OptimalPacking {
    // Constructor for packing, call Run to do the actual pack.
    // Each RectangleToPack.Rectangle is updated in place.
    // Performs a Golden Section Search on packing width for the
    // closest aspect ratio to the specified desired aspect ratio
    constructor(rectangles, aspectRatio) {
        super(_RectanglePacking__WEBPACK_IMPORTED_MODULE_1__.GreedyRectanglePacking.SortRectangles(rectangles), aspectRatio);
        /*Assert.assert(
          rectangles.length > 0,
          'Expected at least one rectangle in rectangles packing',
        )*/
        /*Assert.assert(aspectRatio > 0, 'aspect ratio should be greater than 0')*/
        this.createPacking = (rs, width) => new _RectanglePacking__WEBPACK_IMPORTED_MODULE_1__.GreedyRectanglePacking(rs, width, true);
    }
    // Performs a Golden Section Search on packing width for the
    // closest aspect ratio to the specified desired aspect ratio
    run() {
        let minRectWidth = Number.MAX_VALUE;
        let maxRectWidth = 0;
        let totalWidth = 0;
        // initial widthLowerBound is the width of a perfect packing for the desired aspect ratio
        for (const r of this.rectangles) {
            /*Assert.assert(r.width > 0, 'Width must be greater than 0')*/
            /*Assert.assert(r.height > 0, 'Height must be greater than 0')*/
            const width = r.width;
            totalWidth += width;
            minRectWidth = Math.min(minRectWidth, width);
            maxRectWidth = Math.max(maxRectWidth, width);
        }
        this.Pack(maxRectWidth, totalWidth, minRectWidth);
    }
}
//# sourceMappingURL=OptimalRectanglePacking.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/Packing.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Packing: () => (/* binding */ Packing)
/* harmony export */ });
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");

// Algorithm to pack rectangles
class Packing extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_0__.Algorithm {
    get PackedWidth() {
        return this.packedWidth;
    }
    set PackedWidth(value) {
        this.packedWidth = value;
    }
    get PackedHeight() {
        return this.packedHeight;
    }
    set PackedHeight(value) {
        this.packedHeight = value;
    }
    // Aspect ratio of the bounding box of the packed solution
    get PackedAspectRatio() {
        return this.PackedWidth / this.PackedHeight;
    }
    getRects() {
        const ret = [];
        for (const [r, center] of this.rectsToCenters) {
            r.center = center;
            ret.push(r);
        }
        return ret;
    }
}
//# sourceMappingURL=Packing.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/PackingConstants.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PackingConstants: () => (/* binding */ PackingConstants)
/* harmony export */ });
// Constants used by OptimalRectanglePacking
class PackingConstants {
}
// The greeks thought the GoldenRatio was a good aspect ratio: Phi = (1 + Math.Sqrt(5)) / 2
// <remarks>we also use this internally in our golden section search</remarks>
PackingConstants.GoldenRatio = (1 + Math.sqrt(5)) / 2;
// equiv to 1 - (1/Phi) where Phi is the Golden Ratio: i.e. the smaller of the two sections
// if you divide a unit length by the golden ratio
PackingConstants.GoldenRatioRemainder = 2 - PackingConstants.GoldenRatio;
//# sourceMappingURL=PackingConstants.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/RectanglePacking.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GreedyRectanglePacking: () => (/* binding */ GreedyRectanglePacking)
/* harmony export */ });
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _Packing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectanglePacking/Packing.js");



// Greedily pack rectangles (without rotation) into a given aspect ratio
class GreedyRectanglePacking extends _Packing__WEBPACK_IMPORTED_MODULE_2__.Packing {
    // Constructor for packing, call Run to do the actual pack.
    // Each RectangleToPack.Rectangle is updated in place.
    // Pack rectangles tallest to shortest, left to right until wrapWidth is reached,
    // then wrap to right-most rectangle still with vertical space to fit the next rectangle
    constructor(rectangles, wrapWidth, rectanglesPresorted = false) {
        super(null);
        this.rectsToCenters = new Map();
        this.rectanglesByDescendingHeight = rectanglesPresorted ? rectangles : GreedyRectanglePacking.SortRectangles(rectangles);
        this.wrapWidth = wrapWidth;
    }
    // Sort rectangles by height
    static SortRectangles(rectangles) {
        rectangles.sort((a, b) => b.height - a.height);
        return rectangles;
    }
    // Pack rectangles tallest to shortest, left to right until wrapWidth is reached,
    // then wrap to right-most rectangle still with vertical space to fit the next rectangle
    run() {
        this.Pack();
    }
    // Traverses the rectangleEnumerator and places rectangles at the next available slot beneath the current parent,
    // until the parent is filled or until maxRowWidth is reached.  Each successfully placed rectangle is pushed onto
    // a stack, when there is no room for the rectangle we pop the stack for a new parent and try again.
    Pack() {
        this.PackedWidth = 0;
        this.PackedHeight = 0;
        // get next rectangle
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        let wrap = false;
        let verticalPosition = 0;
        let packedWidth = 0;
        let packedHeight = 0;
        const rects = this.rectanglesByDescendingHeight;
        for (let i = 0; wrap || i < rects.length;) {
            const r = rects[i];
            const parent = stack.length > 0 ? stack.top : null;
            if (parent == null || (parent.right + r.width <= this.wrapWidth && verticalPosition + r.height <= parent.top)) {
                const leftBottom = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(parent ? parent.right : 0, verticalPosition);
                const center = leftBottom.add(new _point__WEBPACK_IMPORTED_MODULE_1__.Point(r.width / 2, r.height / 2));
                r.center = center;
                this.rectsToCenters.set(r, center);
                packedWidth = Math.max(packedWidth, r.right);
                packedHeight = Math.max(packedHeight, r.top);
                stack.push(r);
                wrap = false;
            }
            else {
                verticalPosition = parent.top;
                stack.pop();
                wrap = true;
            }
            if (!wrap)
                i++;
        }
        this.PackedWidth = packedWidth;
        this.PackedHeight = packedHeight;
    }
}
//# sourceMappingURL=RectanglePacking.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SmoothedPolyline: () => (/* binding */ SmoothedPolyline)
/* harmony export */ });
/* harmony import */ var _cornerSite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/cornerSite.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/bezierSeg.js");




class SmoothedPolyline {
    // creates the polyline from corner points
    static mkFromPoints(points) {
        let ret = null;
        let site = null;
        for (const p of points) {
            if (site == null) {
                site = _cornerSite__WEBPACK_IMPORTED_MODULE_0__.CornerSite.mkSiteP(p);
                ret = new SmoothedPolyline(site);
            }
            else {
                const s = _cornerSite__WEBPACK_IMPORTED_MODULE_0__.CornerSite.mkSiteP(p);
                s.prev = site;
                site.next = s;
                site = s;
            }
        }
        return ret;
    }
    clone() {
        let s = this.headSite; //the old site
        let prev = null;
        let h;
        let headOfTheClone = null;
        while (s != null) {
            h = s.clone();
            h.prev = prev;
            if (prev != null)
                prev.next = h;
            else
                headOfTheClone = h;
            s = s.next;
            prev = h;
        }
        return new SmoothedPolyline(headOfTheClone);
    }
    constructor(head) {
        this.headSite = head;
    }
    // the last site of the polyline
    // <
    get lastSite() {
        let ret = this.headSite;
        while (ret.next != null)
            ret = ret.next;
        return ret;
    }
    *[Symbol.iterator]() {
        let s0 = this.headSite;
        while (s0 != null) {
            yield s0.point;
            s0 = s0.next;
        }
    }
    /** Creates a curve by using the underlying polyline*/
    createCurve() {
        const curve = new _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve();
        let a = this.headSite; //the corner start
        let b; //the corner origin
        do {
            const corner = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.findCorner(a);
            if (corner == null)
                break;
            const bezierSeg = SmoothedPolyline.createBezierSegOnSite(corner.b);
            if (curve.segs.length === 0) {
                if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(a.point, bezierSeg.start))
                    _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.addLineSegment(curve, a.point, bezierSeg.start);
            }
            else if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(curve.end, bezierSeg.start))
                _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.continueWithLineSegmentP(curve, bezierSeg.start);
            curve.addSegment(bezierSeg);
            a = corner.b;
        } while (true);
        /*Assert.assert(a.next.next == null )*/
        if (curve.segs.length === 0) {
            if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(a.point, a.next.point)) {
                _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.addLineSegment(curve, a.point, a.next.point);
            }
            else {
                const w = 5;
                curve.segs.push(new _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_3__.BezierSeg(a.point, a.point.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(w, w)), a.point.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(-w, w)), b.point));
            }
        }
        else if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(curve.end, a.next.point))
            _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.continueWithLineSegmentP(curve, a.next.point);
        return curve;
    }
    static createBezierSegOnSite(b) {
        const kPrev = b.previouisBezierCoefficient;
        const kNext = b.nextBezierCoefficient;
        const a = b.prev;
        const c = b.next;
        //   s = kPrev*a.point + (1 - kPrev)*b.point;
        const s = a.point.mul(kPrev).add(b.point.mul(1 - kPrev));
        //   const e = kNext * c.point + (1 - kNext) * b.point;
        const e = c.point.mul(kNext).add(b.point.mul(1 - kNext));
        //  u = s*b.PreviousTangentCoefficient + (1 - b.PreviousTangentCoefficient)*b.point;
        const u = s.mul(b.previousTangentCoefficient).add(b.point.mul(1 - b.previousTangentCoefficient));
        //const v = e * b.nextTangentCoefficient + (1 - b.nextTangentCoefficient) * b.point;
        const v = e.mul(b.nextTangentCoefficient).add(b.point.mul(1 - b.nextTangentCoefficient));
        return _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_3__.BezierSeg.mkBezier([s, u, v, e]);
    }
}
//# sourceMappingURL=smoothedPolyline.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/graphAlgorithms/ConnectedComponentCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetConnectedComponents: () => (/* binding */ GetConnectedComponents)
/* harmony export */ });
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");

function* GetConnectedComponents(graph) {
    const enqueueed = new Array(graph.nodeCount).fill(false);
    const queue = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
    for (let i = 0; i < graph.nodeCount; i++) {
        if (!enqueueed[i]) {
            const nodes = new Array();
            Enqueue(i, queue, enqueueed);
            while (queue.length > 0) {
                const s = queue.dequeue();
                nodes.push(s);
                for (const neighbor of Neighbors(graph, s)) {
                    Enqueue(neighbor, queue, enqueueed);
                }
            }
            yield nodes;
        }
    }
}
function* Neighbors(graph, s) {
    for (const e of graph.outEdges[s]) {
        yield e.target;
    }
    for (const e of graph.inEdges[s]) {
        yield e.source;
    }
}
function Enqueue(i, q, enqueueed) {
    if (enqueueed[i] === false) {
        q.enqueue(i);
        enqueueed[i] = true;
    }
}
//# sourceMappingURL=ConnectedComponentCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/graphAlgorithms/MinimumSpanningTreeByPrim.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MinimumSpanningTreeByPrim: () => (/* binding */ MinimumSpanningTreeByPrim)
/* harmony export */ });
/* harmony import */ var _structs_BinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/BinaryHeapPriorityQueue.js");

class MinimumSpanningTreeByPrim {
    constructor(graph, weight, root) {
        this.treeNodes = new Set();
        // map of neighbors of the tree to the edges connected them to the tree
        this.hedgehog = new Map();
        this.graph = graph;
        this.weight = weight;
        this.root = root;
        this.q = new _structs_BinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__.BinaryHeapPriorityQueue(this.graph.nodeCount);
    }
    NodeIsInTree(i) {
        return this.treeNodes.has(i);
    }
    GetTreeEdges() {
        const ret = new Array();
        this.Init();
        while (ret.length < this.graph.nodeCount - 1 && this.q.Count > 0)
            //some nodes might have no edges
            this.AddEdgeToTree(ret);
        return ret;
    }
    AddEdgeToTree(ret) {
        const v = this.q.Dequeue();
        const e = this.hedgehog.get(v);
        this.treeNodes.add(v);
        ret.push(e);
        this.UpdateOutEdgesOfV(v);
        this.UpdateInEdgesOfV(v);
    }
    UpdateOutEdgesOfV(v) {
        for (const outEdge of this.graph.outEdges[v]) {
            const u = outEdge.target;
            if (this.NodeIsInTree(u)) {
                continue;
            }
            const oldEdge = this.hedgehog.get(u);
            if (oldEdge) {
                const oldWeight = this.weight(oldEdge);
                const newWeight = this.weight(outEdge);
                if (newWeight < oldWeight) {
                    this.q.DecreasePriority(u, newWeight);
                    this.hedgehog.set(u, outEdge);
                }
            }
            else {
                this.q.Enqueue(u, this.weight(outEdge));
                this.hedgehog.set(u, outEdge);
            }
        }
    }
    UpdateInEdgesOfV(v) {
        for (const inEdge of this.graph.inEdges[v]) {
            const u = inEdge.source;
            if (this.NodeIsInTree(u)) {
                continue;
            }
            const oldEdge = this.hedgehog.get(u);
            if (oldEdge) {
                const oldWeight = this.weight(oldEdge);
                const newWeight = this.weight(inEdge);
                if (newWeight < oldWeight) {
                    this.q.DecreasePriority(u, newWeight);
                    this.hedgehog.set(u, inEdge);
                }
            }
            else {
                this.q.Enqueue(u, this.weight(inEdge));
                this.hedgehog.set(u, inEdge);
            }
        }
    }
    Init() {
        this.treeNodes.add(this.root);
        for (const outEdge of this.graph.outEdges[this.root]) {
            const w = this.weight(outEdge);
            this.q.Enqueue(outEdge.target, w);
            this.hedgehog.set(outEdge.target, outEdge);
        }
        for (const inEdge of this.graph.inEdges[this.root]) {
            const w = this.weight(inEdge);
            this.q.Enqueue(inEdge.source, w);
            this.hedgehog.set(inEdge.source, inEdge);
        }
    }
}
//# sourceMappingURL=MinimumSpanningTreeByPrim.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/graphAlgorithms/topologicalSort.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TopologicalSort: () => (/* binding */ TopologicalSort),
/* harmony export */   hasCycle: () => (/* binding */ hasCycle)
/* harmony export */ });
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");



function hasCycle(g) {
    const visited = new Array(g.nodeCount).fill(false);
    const reachableFromU = new Array(g.nodeCount).fill(false);
    for (let u = 0; u < g.nodeCount; u++) {
        if (hasCycleUnder(g, u, visited, reachableFromU))
            return true;
    }
    return false;
}
class TopologicalSort {
    // Topological sort of a list of int edge tuples
    static getOrder(numberOfVertices, edges) {
        const dag = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__.mkGraphOnEdgesN)(edges.map(([u, v]) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_0__.IntPair(u, v)), numberOfVertices);
        //Assert.assert(!hasCycle(dag), 'no cycles')
        return TopologicalSort.getOrderOnGraph(dag);
    }
    // The function returns an array arr such that
    // every edge points forward in the array. The input has to be a DAG
    static getOrderOnGraph(graph) {
        // Assert.assert(!hasCycle(graph))
        const visited = new Array(graph.nodeCount).fill(false);
        //no recursion! So we have to organize a stack
        const se = new stack_typescript__WEBPACK_IMPORTED_MODULE_2__.Stack();
        const order = [];
        let en;
        for (let u = 0; u < graph.nodeCount; u++) {
            if (visited[u])
                continue;
            let cu = u;
            visited[cu] = true;
            let i = 0;
            en = graph.outEdges[u];
            do {
                for (; i < en.length; i++) {
                    const v = en[i].target;
                    if (!visited[v]) {
                        visited[v] = true;
                        se.push({ edges: en, index: i + 1, current_u: cu });
                        cu = v;
                        en = graph.outEdges[cu];
                        i = -1;
                    }
                }
                order.push(cu);
                if (se.length > 0) {
                    const t = se.pop();
                    en = t.edges;
                    i = t.index;
                    cu = t.current_u;
                }
                else
                    break;
            } while (true);
        }
        return order.reverse();
    }
}
function hasCycleUnder(g, u, visited, reachableFromU) {
    if (reachableFromU[u]) {
        return true;
    }
    if (visited[u])
        return false;
    reachableFromU[u] = true;
    visited[u] = true;
    for (const e of g.outEdges[u]) {
        if (hasCycleUnder(g, e.target, visited, reachableFromU)) {
            return true;
        }
    }
    reachableFromU[u] = false;
    return false;
}
//# sourceMappingURL=topologicalSort.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/Block.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Block: () => (/* binding */ Block)
/* harmony export */ });
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _Constraint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/Constraint.js");
/* harmony import */ var _DfDvNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/DfDvNode.js");




// For Path traversal of Expand.
class ConstraintDirectionPair {
    constructor(constraint, isLeftToRight) {
        this.Constraint = constraint;
        this.IsForward = isLeftToRight;
    }
}
// A Block is essentially a collection of Variables, which of turn contain
// a collection of Constraints.
class Block {
    constructor(initialVariable, allConstraints) {
        this.Variables = new Array();
        // On initialization, each variable is put into its own block.  If this was called from Block.Split
        // initialVariable will be null.
        if (null != initialVariable) {
            this.AddVariable(initialVariable);
        }
        this.allConstraints = allConstraints;
    }
    // Generate a string representation of the Block.
    // <returns>A string representation of the Block.</returns>
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_1__.String.Format('[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]', this.Variables.length, this.ReferencePos, this.Scale);
    }
    ComputeDfDv(initialVarToEval) {
        // Compute the derivative of the spanning tree (comprised of our active constraints) at the
        // point of variableToEval (with "change" being the difference between "Desired" position and the calculated
        // position for the current pass), for all paths that do not include the edge variableToEval->variableDoneEval.
        // Recursiteratively process all outgoing paths from variableToEval to its right (i.e. where it is constraint.Left),
        // but don't include variableDoneEval because it's already been evaluated.
        // At each variable on the rightward traversal, we'll also process leftward paths (incoming to) that
        // variable (via the following constraint loop) before returning here.
        // variableToEval and variableDoneEval (if not null) are guaranteed to be of this Block, since they're co-located
        // of an active Constraint of this Block.
        //
        // For Expand, we want to find the constraint path from violatedConstraint.Left to violatedConstraint.Right;
        // the latter is of pathTargetVariable.  This is ComputePath from the doc.  The logic there is:
        //    Do the iterations of ComputeDvDv
        //    If we find the target, then traverse the parent chain to populate the list bottom-up
        /*Assert.assert(
          0 === this.allConstraints.DfDvStack.length,
          'Leftovers of ComputeDfDvStack',
        )*/
        this.allConstraints.DfDvStack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        // Variables for initializing the first node.
        const dummyConstraint = new _Constraint__WEBPACK_IMPORTED_MODULE_2__.Constraint(initialVarToEval);
        this.dfDvDummyParentNode = new _DfDvNode__WEBPACK_IMPORTED_MODULE_3__.DfDvNode(dummyConstraint);
        const firstNode = this.GetDfDvNode(this.dfDvDummyParentNode, dummyConstraint, initialVarToEval, null);
        this.allConstraints.DfDvStack.push(firstNode);
        // Iteratively recurse, processing all children of a constraint before the constraint itself.
        // Loop termination is by testing for completion based on node==firstNode which is faster than
        // (non-inlined) Stack.length.
        for (;;) {
            // Leave the node on the stack until we've processed all of its children.
            const node = this.allConstraints.DfDvStack.top;
            const prevStackCount = this.allConstraints.DfDvStack.length;
            if (!node.ChildrenHaveBeenPushed) {
                node.ChildrenHaveBeenPushed = true;
                for (const constraint of node.VariableToEval.LeftConstraints) {
                    // Direct violations (a -> b -> a) are not caught by the constraint-based cycle detection
                    // because VariableDoneEval prevents them from being entered (b -> a is not entered because a is
                    // VariableDoneEval).  These cycles should be caught by the null-minLagrangian IsUnsatisfiable
                    // setting of Block.Expand (but assert with IsActive not IsUnsatisfiable, as the constraint
                    // may not have been encountered yet).  Test_Unsatisfiable_Cycle_InDirect_With_SingleConstraint_Var.
                    /*Assert.assert(
                      !constraint.IsActive ||
                        !(
                          node.IsLeftToRight && constraint.Right === node.VariableDoneEval
                        ),
                      'this cycle should not happen',
                    )*/
                    if (constraint.IsActive && constraint.Right !== node.VariableDoneEval) {
                        // variableToEval is now considered "done"
                        const childNode = this.GetDfDvNode(node, constraint, constraint.Right, node.VariableToEval);
                        // If the node has no constraints other than the one we're now processing, it's a leaf
                        // and we don't need the overhead of pushing to and popping from the stack.
                        if (1 === constraint.Right.ActiveConstraintCount) {
                            this.ProcessDfDvLeafNodeDirectly(childNode);
                        }
                        else {
                            this.PushDfDvNode(childNode);
                        }
                    }
                }
                for (const constraint of node.VariableToEval.RightConstraints) {
                    // See comments of .LeftConstraints.
                    /*Assert.assert(
                      !constraint.IsActive ||
                        !(
                          !node.IsLeftToRight && constraint.Left === node.VariableDoneEval
                        ),
                      'this cycle should not happen',
                    )*/
                    if (constraint.IsActive && constraint.Left !== node.VariableDoneEval) {
                        const childNode = this.GetDfDvNode(node, constraint, constraint.Left, node.VariableToEval);
                        if (1 === constraint.Left.ActiveConstraintCount) {
                            this.ProcessDfDvLeafNodeDirectly(childNode);
                        }
                        else {
                            this.PushDfDvNode(childNode);
                        }
                    }
                }
                // If we just pushed one or more nodes, loop back up and "recurse" into them.
                if (this.allConstraints.DfDvStack.length > prevStackCount) {
                    continue;
                }
            }
            // endif !node.ChildrenHaveBeenPushed
            // We are at a non-leaf node and have "recursed" through all its descendents; therefore pop it off
            // the stack and process it.  If it's the initial node, we've already updated DummyConstraint.Lagrangian
            // from all child nodes, and it's of the DummyParentNode as well so this will add the final dfdv.
            /*Assert.assert(
              this.allConstraints.DfDvStack.top === node,
              "DfDvStack.top should be 'node'",
            )*/
            this.allConstraints.DfDvStack.pop();
            this.ProcessDfDvLeafNode(node);
            if (node === firstNode) {
                /*Assert.assert(
                  0 === this.allConstraints.DfDvStack.length,
                  'Leftovers of DfDvStack on completion of loop',
                )*/
                break;
            }
        }
        // endwhile stack is not empty
    }
    // end ComputeDfDv()
    ProcessDfDvLeafNode(node) {
        const dfdv = node.VariableToEval.DfDv;
        // Add dfdv to constraint.Lagrangian if we are going left-to-right, else subtract it ("negative slope");
        // similarly, add it to or subtract it from the parent's Lagrangian.
        if (node.IsLeftToRight) {
            node.ConstraintToEval.Lagrangian = node.ConstraintToEval.Lagrangian + dfdv;
            node.Parent.ConstraintToEval.Lagrangian = node.Parent.ConstraintToEval.Lagrangian + node.ConstraintToEval.Lagrangian;
        }
        else {
            // Any child constraints have already put their values into the current constraint
            // according to whether they were left-to-right or right-to-left.  This is the equivalent
            // to the sum of return values of the recursive approach of the paper.  However, the paper
            // negates this return value when setting it into a right-to-left parent's Lagrangian;
            // we're that right-to-left parent now so do that first (negate the sum of children).
            node.ConstraintToEval.Lagrangian = (node.ConstraintToEval.Lagrangian + dfdv) * -1;
            node.Parent.ConstraintToEval.Lagrangian = node.Parent.ConstraintToEval.Lagrangian - node.ConstraintToEval.Lagrangian;
        }
        // See if this node found the target variable.
        this.CheckForConstraintPathTarget(node);
        // If this active constraint is violated, record it.
        this.Debug_CheckForViolatedActiveConstraint(node.ConstraintToEval);
        // We're done with this node.
        this.allConstraints.RecycleDfDvNode(node);
    }
    Debug_CheckForViolatedActiveConstraint(constraint) {
        // Test is: Test_Unsatisfiable_Direct_Inequality(); it should not encounter this.
        if (constraint.Violation > this.allConstraints.SolverParameters.GapTolerance) {
            /*Assert.assert(
              false,
              'Violated active constraint should never be encountered',
            )*/
        }
    }
    // Directly evaluate a leaf node rather than defer it to stack push/pop.
    ProcessDfDvLeafNodeDirectly(node) {
        // this.Debug_MarkForCycleCheck(node.ConstraintToEval)
        this.ProcessDfDvLeafNode(node);
    }
    GetDfDvNode(parent, constraintToEval, variableToEval, variableDoneEval) {
        const node = this.allConstraints.DfDvRecycleStack.size > 0
            ? this.allConstraints.DfDvRecycleStack.pop().Set(parent, constraintToEval, variableToEval, variableDoneEval)
            : _DfDvNode__WEBPACK_IMPORTED_MODULE_3__.DfDvNode.constructorDCVV(parent, constraintToEval, variableToEval, variableDoneEval);
        node.Depth = node.Parent.Depth + 1;
        if (this.allConstraints.MaxConstraintTreeDepth < node.Depth) {
            this.allConstraints.MaxConstraintTreeDepth = node.Depth;
        }
        return node;
    }
    // Called by ComputeDfDv.
    PushDfDvNode(node) {
        this.PushOnDfDvStack(node);
    }
    // Called by RecurseGetConnectedVariables.
    AddVariableAndPushDfDvNode(lstVars, node) {
        // this.Debug_CycleCheck(node.ConstraintToEval)
        lstVars.push(node.VariableToEval);
        this.PushOnDfDvStack(node);
    }
    PushOnDfDvStack(node) {
        // this.Debug_MarkForCycleCheck(node.ConstraintToEval)
        this.allConstraints.DfDvStack.push(node);
    }
    CheckForConstraintPathTarget(node) {
        if (this.pathTargetVariable === node.VariableToEval) {
            // Add every variable from pathTargetVariable up the callchain up to but not including initialVarToEval.
            while (node.Parent !== this.dfDvDummyParentNode) {
                this.constraintPath.push(new ConstraintDirectionPair(node.ConstraintToEval, node.IsLeftToRight));
                node = node.Parent;
            }
            this.pathTargetVariable = null;
            // Path is complete
        }
    }
    Expand(violatedConstraint) {
        // Debug_ClearDfDv(false)
        // Calculate the derivative at the point of each constraint.
        // violatedConstraint's edge may be the minimum so pass null for variableDoneEval.
        //
        // We also want to find the path along the active constraint tree from violatedConstraint.Left
        // to violatedConstraint.Right, and find the constraint on that path with the lowest Langragian
        // multiplier. The ActiveConstraints form a spanning tree so there will be no more than
        // one path. violatedConstraint is not yet active so it will not appear of this list.
        if (this.constraintPath == null) {
            this.constraintPath = new Array();
        }
        this.constraintPath = [];
        this.pathTargetVariable = violatedConstraint.Right;
        this.ComputeDfDv(violatedConstraint.Left);
        // Now find the forward non-equality constraint on the path that has the minimal Lagrangina.
        // Both variables of the constraint are of the same block so a path should always be found.
        let minLagrangianConstraint = null;
        if (this.constraintPath.length > 0) {
            // We found an existing path so must remove an edge from our active list so that all
            // connected variables from its varRight onward can move to the right; this will
            // make the "active" status false for that edge.  The active non-Equality constraint
            // with the minimal Lagrangian *that points rightward* is our split point (do *not*
            // split Equality constraints).
            for (const pathItem of this.constraintPath) {
                if (pathItem.IsForward &&
                    (minLagrangianConstraint == null || pathItem.Constraint.Lagrangian < minLagrangianConstraint.Lagrangian)) {
                    if (!pathItem.Constraint.IsEquality) {
                        minLagrangianConstraint = pathItem.Constraint;
                    }
                }
            }
            if (null != minLagrangianConstraint) {
                // Deactivate this constraint as we are splitting on it.
                this.allConstraints.DeactivateConstraint(minLagrangianConstraint);
            }
        }
        this.constraintPath = [];
        this.pathTargetVariable = null;
        if (minLagrangianConstraint == null) {
            // If no forward non-equality edge was found, violatedConstraint would have created a cycle.
            /*Assert.assert(
              !violatedConstraint.IsUnsatisfiable,
              'An already-unsatisfiable constraint should not have been attempted',
            )*/
            violatedConstraint.IsUnsatisfiable = true;
            this.allConstraints.NumberOfUnsatisfiableConstraints++;
            return;
        }
        // Note: for perf, expand in-place (as of Ipsep) rather than Split/Merge (as of the Scaling paper).
        // Adjust the offset of each variable at and past the right-hand side of violatedConstraint of the
        // active spanning tree.  Because we've removed minLagrangianConstraint, this will widen the
        // gap between minLagrangianConstraint.Left and .Right.  Note that this must include not only
        // violatedConstraint.Right and those to its right, but also those to its left that are connected
        // to it by active constraints - because the definition of an active constraint is that the
        // gap matches exactly with the actual position, so all will move as a unit.
        const lstConnectedVars = new Array();
        // We consider .Left "already evaluated" because we don't want the path evaluation to back
        // up to it (because we're splitting .Right off from it by deactivating the constraint).
        this.GetConnectedVariables(lstConnectedVars, violatedConstraint.Right, violatedConstraint.Left);
        const violation = violatedConstraint.Violation;
        const cConnectedVars = lstConnectedVars.length;
        for (let ii = 0; ii < cConnectedVars; ii++) {
            lstConnectedVars[ii].OffsetInBlock = lstConnectedVars[ii].OffsetInBlock + violation;
        }
        // Now make the (no-longer-) violated constraint active.
        this.allConstraints.ActivateConstraint(violatedConstraint);
        // Clear the DfDv values.  For TEST_MSAGL, the new constraint came of from outside this block
        // so this will make sure it doesn't have a stale cycle-detection flag.
        violatedConstraint.ClearDfDv();
        // Update this block's reference position.
        this.UpdateReferencePos();
    }
    // end Expand()
    Split(isQpsc) {
        if (isQpsc) {
            // of the Qpsc case, we've modified current positions of PreProject() so need to update them here.
            this.UpdateReferencePos();
        }
        // If there is only one variable there's nothing to split.
        if (this.Variables.length < 2) {
            return null;
        }
        let minLagrangianConstraint = null;
        // Debug_ClearDfDv(false)
        // Pick a variable from the active constraint list - it doesn't matter which; any variable in
        // the block is active (except for the initial one-var-per-block case), so ComputeDfDv will evaluate
        // it along the active path.  Eventually all variables needing to be repositioned will be part of
        // active constraints; even if SplitBlocks eventually happens, if the variable must be repositioned
        // again (via the global-constraint-maxviolation check) its constraint will be reactivated.
        // By the same token, ExpandBlock and SplitBlocks implicitly address/optimize all situations
        // (or close enough) where an Active (i.e. === Gap) constraint would be better made inactive
        // and the gap grown.
        this.ComputeDfDv(this.Variables[0]);
        // We only split the block if it has a non-equality constraint with a Lagrangian that is more than a
        // rounding error below 0.0.
        let minLagrangian = this.allConstraints.SolverParameters.Advanced.MinSplitLagrangianThreshold;
        const numVars = this.Variables.length;
        // cache for perf
        for (let ii = 0; ii < numVars; ii++) {
            for (const constraint of this.Variables[ii].LeftConstraints) {
                if (constraint.IsActive && !constraint.IsEquality && constraint.Lagrangian < minLagrangian) {
                    minLagrangianConstraint = constraint;
                    minLagrangian = constraint.Lagrangian;
                }
            }
        }
        // If we have no satisfying constraint, we're done.
        if (minLagrangianConstraint == null) {
            return null;
        }
        return this.SplitOnConstraint(minLagrangianConstraint);
    }
    SplitOnConstraint(constraintToSplit) {
        // We have a split point.  Remove that constraint from our active list and transfer it and all
        // variables to its right to a new block.  As mentioned above, all variables and associated
        // constraints of the block are active, and the block split and recalc of reference positions
        // doesn't change the actual positions of any variables.
        this.allConstraints.DeactivateConstraint(constraintToSplit);
        let newSplitBlock = new Block(null, this.allConstraints);
        // Transfer the connected variables.  This has the side-effect of moving the associated active
        // constraints as well (because they are carried of the variables' LeftConstraints).
        // This must include not only minLagrangianConstraint.Right and those to its right, but also
        // those to its left that are connected to it by active constraints - because connected variables
        // must be within a single a block.  Since we are splitting the constraint, there will be at least
        // one variable (minLagrangianConstraint.Left) of the current block when we're done.  Because the active
        // constraints form a tree, we won't have a situation where minLagrangianConstraint.Left is
        // also the .Right of a constraint of a variable to the left of varRight.
        // minLagrangianConstraint.Left is "already evaluated" because we don't want the path evaluation to
        // back up to it (because we're splitting minLagrangianConstraint by deactivating it).
        // this.DebugVerifyBlockConnectivity()
        this.TransferConnectedVariables(newSplitBlock, constraintToSplit.Right, constraintToSplit.Left);
        if (newSplitBlock.Variables.length > 0) {
            // We may have removed the first variable so fully recalculate the reference position.
            this.UpdateReferencePos();
            // The new block's sums were not updated as its variables were added directly to its
            // variables list, so fully recalculate.
            newSplitBlock.UpdateReferencePos();
            // this.DebugVerifyBlockConnectivity()
            // newSplitBlock.DebugVerifyBlockConnectivity()
        }
        else {
            // If there were unsatisfiable constraints, we may have tried to transfer all variables;
            // of that case we simply ignored the transfer operation and left all variables of 'this' block.
            // Return NULL so Solver.SplitBlocks knows we didn't split.
            newSplitBlock = null;
        }
        return newSplitBlock;
    }
    // end Split()
    AddVariable(variable) {
        // Don't recalculate position yet; that will be done after all Block.AddVariable calls and then
        // block-merge processing are done.
        this.Variables.push(variable);
        variable.Block = this;
        if (1 === this.Variables.length) {
            // The block's information is set to that of the initial variable's "actual" state; we won't
            // call UpdateReferencePosFromSums.
            this.Scale = variable.Scale;
            this.ReferencePos = variable.ActualPos;
            this.sumAd = variable.ActualPos * variable.Weight;
            this.sumAb = 0;
            this.sumA2 = variable.Weight;
            variable.OffsetInBlock = 0;
        }
        else {
            // Don't update ReferencePos yet because this is called from MergeBlocks or SplitBlock
            // for a number of variables and we'll call UpdateReferencePosFromSums when they're all added.
            this.AddVariableToBlockSums(variable);
        }
    }
    UpdateReferencePos() {
        // Make sure we're using the first variable's scale, of case the previous first-variable
        // has been removed.
        this.Scale = this.Variables[0].Scale;
        // Note:  This does not keep the variables at their current positions; rather, it pulls them
        // closer to their desired positions (this is easily seen by running through the math for a
        // single variable).  However the relative positions are preserved.  This helps the solution
        // remain minimal.
        this.sumAd = 0;
        this.sumAb = 0;
        this.sumA2 = 0;
        const numVars = this.Variables.length;
        // cache for perf
        for (let ii = 0; ii < numVars; ii++) {
            this.AddVariableToBlockSums(this.Variables[ii]);
        }
        this.UpdateReferencePosFromSums();
    }
    AddVariableToBlockSums(variable) {
        // a and b are from the scaling paper - with calculations modified for weights.
        const a = this.Scale / variable.Scale;
        const b = variable.OffsetInBlock / variable.Scale;
        const aw = a * variable.Weight;
        this.sumAd += aw * variable.DesiredPos;
        this.sumAb += aw * b;
        this.sumA2 += aw * a;
    }
    UpdateReferencePosFromSums() {
        // This is called from Solver.MergeBlocks as well as internally.
        if (!(Number.isFinite(this.sumAd) && Number.isFinite(this.sumAb) && Number.isFinite(this.sumA2))) {
            throw new Error('infinite numbers');
        }
        this.ReferencePos = (this.sumAd - this.sumAb) / this.sumA2;
        this.UpdateVariablePositions();
    }
    UpdateVariablePositions() {
        const scaledReferencePos = this.Scale * this.ReferencePos;
        const numVars = this.Variables.length;
        // iteration is faster than foreach for Array
        for (let ii = 0; ii < numVars; ii++) {
            const v = this.Variables[ii];
            // The derivation on this is from the paper:  a_i * YB + b_i
            //      a_i === this.Scale / v.Scale
            //      YB  === this.ReferencePos
            //      b_i === v.OffsetInBlock / v.Scale
            // Thus
            //      ((this.Scale / v.Scale) * this.ReferencePos) + (v.OffsetInBlock / v.Scale)
            // reorganizes to...
            //      ((this.Scale * this.ReferencePos) / v.Scale) + (v.OffsetInBlock / v.Scale)
            // which simplifies to...
            v.ActualPos = (scaledReferencePos + v.OffsetInBlock) / v.Scale;
        }
    }
    GetConnectedVariables(lstVars, varToEval, varDoneEval) {
        // First set up cycle-detection of TEST_MSAGL mode.
        // Debug_ClearDfDv(false)
        this.RecurseGetConnectedVariables(lstVars, varToEval, varDoneEval);
    }
    RecurseGetConnectedVariables(lstVars, initialVarToEval, initialVarDoneEval) {
        // Get all the vars at and to the right of 'var', including backtracking to get all
        // variables that are connected from the left.  This is just like ComputeDfDv except
        // that of this case we start with the variableDoneEval being the Left variable.
        /*Assert.assert(
          0 === this.allConstraints.DfDvStack.length,
          'Leftovers of ComputeDfDvStack',
        )*/
        this.allConstraints.DfDvStack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        /*Assert.assert(0 === lstVars.length, 'Leftovers of lstVars')*/
        // Variables for initializing the first node.
        const dummyConstraint = new _Constraint__WEBPACK_IMPORTED_MODULE_2__.Constraint(initialVarToEval);
        this.dfDvDummyParentNode = new _DfDvNode__WEBPACK_IMPORTED_MODULE_3__.DfDvNode(dummyConstraint);
        this.allConstraints.DfDvStack.push(this.GetDfDvNode(this.dfDvDummyParentNode, dummyConstraint, initialVarToEval, initialVarDoneEval));
        lstVars.push(initialVarToEval);
        // Do a pre-order tree traversal (process the constraint before its children), for consistency
        // with prior behaviour.
        while (this.allConstraints.DfDvStack.length > 0) {
            // Leave the node on the stack until we've processed all of its children.
            const node = this.allConstraints.DfDvStack.top;
            const prevStackCount = this.allConstraints.DfDvStack.length;
            if (!node.ChildrenHaveBeenPushed) {
                node.ChildrenHaveBeenPushed = true;
                for (const constraint of node.VariableToEval.LeftConstraints) {
                    if (constraint.IsActive && constraint.Right !== node.VariableDoneEval) {
                        // If the node has no constraints other than the one we're now processing, it's a leaf
                        // and we don't need the overhead of pushing to and popping from the stack.
                        if (1 === constraint.Right.ActiveConstraintCount) {
                            //  this.Debug_CycleCheck(constraint)
                            //  this.Debug_MarkForCycleCheck(constraint)
                            lstVars.push(constraint.Right);
                        }
                        else {
                            // variableToEval is now considered "done"
                            this.AddVariableAndPushDfDvNode(lstVars, this.GetDfDvNode(node, constraint, constraint.Right, node.VariableToEval));
                        }
                    }
                }
                for (const constraint of node.VariableToEval.RightConstraints) {
                    if (constraint.IsActive && constraint.Left !== node.VariableDoneEval) {
                        // See comments of .LeftConstraints
                        if (1 === constraint.Left.ActiveConstraintCount) {
                            //  this.Debug_CycleCheck(constraint)
                            //  this.Debug_MarkForCycleCheck(constraint)
                            lstVars.push(constraint.Left);
                        }
                        else {
                            this.AddVariableAndPushDfDvNode(lstVars, this.GetDfDvNode(node, constraint, constraint.Left, node.VariableToEval));
                        }
                    }
                }
            }
            // endif !node.ChildrenHaveBeenPushed
            // If we just pushed one or more nodes, loop back up and "recurse" into them.
            if (this.allConstraints.DfDvStack.length > prevStackCount) {
                continue;
            }
            // We are at a non-leaf node and have "recursed" through all its descendents, so we're done with it.
            /*Assert.assert(
              this.allConstraints.DfDvStack.top === node,
              "DfDvStack.top should be 'node'",
            )*/
            this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.pop());
        }
        // endwhile stack is not empty
    }
    TransferConnectedVariables(newSplitBlock, varToEval, varDoneEval) {
        this.GetConnectedVariables(newSplitBlock.Variables, varToEval, varDoneEval);
        const numVarsToMove = newSplitBlock.Variables.length;
        // cache for perf
        // The constraints transferred to the new block need to have any stale cycle-detection values cleared out.
        // newSplitBlock.Debug_ClearDfDv(true)
        // Avoid the creation of an inner loop on Array<T>.Remove (which does linear scan and shift
        // to preserve the order of members).  We don't care about variable ordering within the block
        // so we can just repeatedly swap of the end one over whichever we're removing.
        for (let moveIndex = 0; moveIndex < numVarsToMove; moveIndex++) {
            newSplitBlock.Variables[moveIndex].Block = newSplitBlock;
        }
        // Now iterate from the end and swap of the last one we'll keep over the ones we'll remove.
        let lastKeepIndex = this.Variables.length - 1;
        for (let currentIndex = this.Variables.length - 1; currentIndex >= 0; currentIndex--) {
            const currentVariable = this.Variables[currentIndex];
            if (currentVariable.Block === newSplitBlock) {
                if (currentIndex < lastKeepIndex) {
                    // Swap of the one from the end.
                    this.Variables[currentIndex] = this.Variables[lastKeepIndex];
                }
                lastKeepIndex--;
            }
        }
        // end for each var to keep
        // Now remove the end slots we're not keeping.  lastKeepIndex is -1 if we are removing all variables.
        /*Assert.assert(
          numVarsToMove === this.Variables.length - lastKeepIndex - 1,
          'variable should not be found twice (probable cycle-detection problem',
        )*/
        this.Variables = this.Variables.slice(0, lastKeepIndex + 1);
        if (0 === this.Variables.length) {
            // This is probably due to unsatisfiable constraints; we've transferred all the variables,
            // so just don't split at all; move the variables back into the current block rather than
            // leaving an empty block of the list.  Caller will detect the empty newSplitBlock and ignore it.
            for (let moveIndex = 0; moveIndex < numVarsToMove; moveIndex++) {
                const variableToMove = newSplitBlock.Variables[moveIndex];
                this.Variables.push(variableToMove);
                variableToMove.Block = this;
            }
            newSplitBlock.Variables = [];
        }
    }
}
//# sourceMappingURL=Block.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/BlockVector.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BlockVector: () => (/* binding */ BlockVector)
/* harmony export */ });
class BlockVector {
    get Count() {
        return this.Vector.length;
    }
    item(index) {
        return this.Vector[index];
    }
    constructor() {
        this.Vector = new Array();
    }
    Add(block) {
        block.VectorIndex = this.Vector.length;
        this.Vector.push(block);
        /*Assert.assert(
          this.Vector[block.VectorIndex] === block,
          'Inconsistent block.VectorIndex',
        )*/
    }
    Remove(block) {
        /*Assert.assert(
          this.Vector[block.VectorIndex] === block,
          'Inconsistent block.VectorIndex',
        )*/
        const swapBlock = this.Vector[this.Vector.length - 1];
        this.Vector[block.VectorIndex] = swapBlock;
        swapBlock.VectorIndex = block.VectorIndex;
        this.Vector.pop();
    }
    toString() {
        return this.Vector.toString();
    }
}
//# sourceMappingURL=BlockVector.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/Constraint.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Constraint: () => (/* binding */ Constraint)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");


class Constraint {
    SetActiveState(activeState, newVectorIndex) {
        // Note: newVectorIndex may be the same as the old one if we are changing the state
        // of the last inactive or first active constraint.
        /*Assert.assert(
          this.IsActive !== activeState,
          'Constraint is already set to activationState',
        )*/
        this.IsActive = activeState;
        this.VectorIndex = newVectorIndex;
        if (this.IsActive) {
            this.Left.ActiveConstraintCount++;
            this.Right.ActiveConstraintCount++;
        }
        else {
            this.Left.ActiveConstraintCount--;
            this.Right.ActiveConstraintCount--;
        }
    }
    SetVectorIndex(vectorIndex) {
        // This is separate from set_VectorIndex because we can't restrict the caller to a specific
        // class and we only want ConstraintVector to be able to call this.
        this.VectorIndex = vectorIndex;
    }
    Reinitialize() {
        // Called by Qpsc or equivalence-constraint-regapping initial block restructuring.
        // All variables have been moved to their own blocks again, so reset solution states.
        this.IsActive = false;
        this.IsUnsatisfiable = false;
        this.ClearDfDv();
    }
    // This is an  function, not a propset, because we only want it called by the Solver.
    UpdateGap(newGap) {
        this.Gap = newGap;
    }
    // The Constraint constructor takes the two variables and their required distance.
    // The constraints will be generated either manually or by ConstraintGenerator,
    // both of which know about the sizes when the constraints are generated (as
    // well as any necessary padding), so the sizes are accounted for at that time
    // and ProjectionSolver classes are not aware of Variable sizes.
    static constructorVVNB(left, right, gap, isEquality) {
        const v = new Constraint(left);
        v.Left = left;
        v.Right = right;
        v.Gap = gap;
        v.IsEquality = isEquality;
        v.Lagrangian = 0;
        v.IsActive = false;
        return v;
    }
    // For Solver.ComputeDfDv's DummyParentNode's constraint only.
    constructor(variable) {
        this.Right = variable;
        this.Left = variable;
    }
    // Generates a string representation of the Constraint.
    // <returns>A string representation of the Constraint.</returns>
    ToString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv', this.Left, this.Right, this.IsEquality ? '==' : '>=', this.Gap, this.Violation, this.Lagrangian, this.Lagrangian * 2, this.IsActive ? '+' : this.IsUnsatisfiable ? '!' : '-');
    }
    get Violation() {
        return this.Left.ActualPos * this.Left.Scale + (this.Gap - this.Right.ActualPos * this.Right.Scale);
    }
    ClearDfDv() {
        this.Lagrangian = 0;
    }
    // Compare this Constraint to rhs by their Variables in ascending order (this === lhs, other === rhs).
    // The object being compared to.
    // <returns>-1 if this.Left/Right are "less"; +1 if this.Left/Right are "greater"; 0 if this.Left/Right
    //         and rhs.Left/Right are equal.</returns>
    CompareTo(other) {
        let cmp = this.Left.CompareTo(other.Left);
        if (0 === cmp) {
            cmp = this.Right.CompareTo(other.Right);
        }
        if (0 === cmp) {
            cmp = (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(this.Gap, other.Gap);
        }
        return cmp;
    }
}
//# sourceMappingURL=Constraint.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/ConstraintVector.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConstraintVector: () => (/* binding */ ConstraintVector)
/* harmony export */ });
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");

class ConstraintVector {
    constructor() {
        this.nextConstraintIndex = 0;
        // The node stack for "recursive iteration" of constraint trees, and the recycled node stack
        // to reduce inner-loop alloc/GC overhead.
        this.DfDvStack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        this.DfDvRecycleStack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
    }
    get IsEmpty() {
        return this.Vector == null;
    }
    Create(numConstraints) {
        this.Vector = new Array(numConstraints);
        // Initialize this to out of range.
        this.firstActiveConstraintIndex = numConstraints;
    }
    Add(constraint) {
        /*Assert.assert(!constraint.IsActive, 'Constraint should not be active')*/
        constraint.SetVectorIndex(this.nextConstraintIndex);
        this.Vector[this.nextConstraintIndex++] = constraint;
    }
    ActivateConstraint(constraint) {
        /*Assert.assert(!constraint.IsActive, 'Constraint is already active')*/
        // Swap it from the inactive region to the start of the active region of the Vector.
        /*Assert.assert(
          this.firstActiveConstraintIndex > 0,
          'All constraints are already active',
        )*/
        this.firstActiveConstraintIndex--;
        /*Assert.assert(
          !this.Vector[this.firstActiveConstraintIndex].IsActive,
          'Constraint in inactive region is active',
        )*/
        this.SwapConstraint(constraint);
        // Debug_AssertConsistency();
    }
    DeactivateConstraint(constraint) {
        /*Assert.assert(constraint.IsActive, 'Constraint is not active')*/
        // Swap it from the active region to the end of the inactive region of the Vector.
        /*Assert.assert(
          this.firstActiveConstraintIndex < this.Vector.length,
          'All constraints are already inactive',
        )*/
        /*Assert.assert(
          this.Vector[this.firstActiveConstraintIndex].IsActive,
          'Constraint in active region is not active',
        )*/
        this.SwapConstraint(constraint);
        this.firstActiveConstraintIndex++;
        // Debug_AssertConsistency();
    }
    SwapConstraint(constraint) {
        // Swap out the constraint at the current active/inactive border index (which has been updated
        // according to the direction we're moving it).
        const swapConstraint = this.Vector[this.firstActiveConstraintIndex];
        swapConstraint.SetVectorIndex(constraint.VectorIndex);
        this.Vector[constraint.VectorIndex] = swapConstraint;
        // Toggle the state of the constraint being updated.
        this.Vector[this.firstActiveConstraintIndex] = constraint;
        constraint.SetActiveState(!constraint.IsActive, this.firstActiveConstraintIndex);
    }
    Reinitialize() {
        // Qpsc requires reinitializing the block structure
        if (this.Vector == null) {
            return;
        }
        for (const constraint of this.Vector) {
            constraint.Reinitialize();
        }
        this.firstActiveConstraintIndex = this.Vector.length;
    }
    RecycleDfDvNode(node) {
        // In the case of long constraint chains make sure this does not end up as big as the number of constraints in the block.
        if (this.DfDvRecycleStack.length < 1024) {
            this.DfDvRecycleStack.push(node);
        }
    }
    toString() {
        return this.Vector.toString();
    }
}
//# sourceMappingURL=ConstraintVector.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/DfDvNode.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DfDvNode: () => (/* binding */ DfDvNode)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");

// variableDoneEval is NULL if we are starting an evaluation; if recursive, it's the variable
// on that side from the parent call, which was already processed.
class DfDvNode {
    static constructorDCVV(parent, constraintToEval, variableToEval, variableDoneEval) {
        const ret = new DfDvNode(constraintToEval);
        ret.Set(parent, constraintToEval, variableToEval, variableDoneEval);
        return ret;
    }
    // For DummyParentNode only.
    constructor(dummyConstraint) {
        this.ConstraintToEval = dummyConstraint;
        this.Depth = -1;
        // The first real node adds 1, so it starts at 0.
    }
    Set(parent, constraintToEval, variableToEval, variableDoneEval) {
        this.Parent = parent;
        this.ConstraintToEval = constraintToEval;
        this.VariableToEval = variableToEval;
        this.VariableDoneEval = variableDoneEval;
        this.Depth = 0;
        this.ChildrenHaveBeenPushed = false;
        constraintToEval.Lagrangian = 0;
        return this;
    }
    get IsLeftToRight() {
        return this.VariableToEval === this.ConstraintToEval.Right;
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0} {1}{2} - {3}{4} ({5})', '', this.IsLeftToRight ? '' : '*', this.ConstraintToEval.Left.Name, this.IsLeftToRight ? '*' : '', this.ConstraintToEval.Right.Name, this.Depth);
    }
}
//# sourceMappingURL=DfDvNode.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/Parameters.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AdvancedParameters: () => (/* binding */ AdvancedParameters),
/* harmony export */   Parameters: () => (/* binding */ Parameters)
/* harmony export */ });
// Per-instance parameters for ProjectionSolver.Solver.Solve().
class Parameters {
    // Constructor.
    constructor() {
        this.GapTolerance = 0.0001;
        this.QpscConvergenceEpsilon = 1e-5;
        this.QpscConvergenceQuotient = 1e-6;
        this.OuterProjectIterationsLimit = -1;
        this.InnerProjectIterationsLimit = -1;
        this.TimeLimit = -1;
        this.Advanced = new AdvancedParameters();
    }
    // Deep-copy the AdvancedParameters.
    Clone() {
        const newParams = this.MemberwiseClone();
        newParams.Advanced = this.Advanced.Clone();
        return newParams;
    }
    MemberwiseClone() {
        const par = new Parameters();
        par.GapTolerance = this.GapTolerance;
        par.QpscConvergenceEpsilon = this.QpscConvergenceEpsilon;
        par.QpscConvergenceQuotient = this.QpscConvergenceQuotient;
        par.OuterProjectIterationsLimit = this.OuterProjectIterationsLimit;
        par.InnerProjectIterationsLimit = this.InnerProjectIterationsLimit;
        par.TimeLimit = this.TimeLimit;
        return par;
    }
}
// end struct Parameters
// Parameter specification for advanced options.
class AdvancedParameters {
    // Constructor.
    constructor() {
        this.ForceQpsc = false;
        this.ScaleInQpsc = true;
        this.MinSplitLagrangianThreshold = -1e-7;
        this.UseViolationCache = true;
        this.ViolationCacheMinBlocksDivisor = 10;
        this.ViolationCacheMinBlocksCount = 100;
    }
    // Shallow-copy the object (there is nothing requiring deep-copy).
    Clone() {
        const ret = new AdvancedParameters();
        ret.ForceQpsc = this.ForceQpsc;
        ret.ScaleInQpsc = this.ScaleInQpsc;
        ret.MinSplitLagrangianThreshold = this.MinSplitLagrangianThreshold;
        ret.UseViolationCache = this.UseViolationCache;
        ret.ViolationCacheMinBlocksDivisor = this.ViolationCacheMinBlocksDivisor;
        ret.ViolationCacheMinBlocksCount = this.ViolationCacheMinBlocksCount;
        return ret;
    }
}
//# sourceMappingURL=Parameters.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/QPSC.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qpsc: () => (/* binding */ Qpsc),
/* harmony export */   QpscVar: () => (/* binding */ QpscVar)
/* harmony export */ });
// Store original weight to be restored when done.  With the ability to re-Solve() after
// updating constraint gaps, we must restore DesiredPos as well.
class QpscVar {
    constructor(v) {
        this.Variable = v;
        this.OrigWeight = v.Weight;
        this.OrigScale = v.Scale;
        this.OrigDesiredPos = this.Variable.DesiredPos;
    }
}
class MatrixCell {
    constructor(w, index) {
        this.Value = w;
        this.Column = index;
    }
}
class Qpsc {
    constructor(solverParameters, cVariables) {
        // Array of variables, for perf (avoid nested block/variable Array<> iteration)
        this.newMatrixRow = new Array();
        // If true we're on our first call to Project
        // Holds the value of f(x) = yQ'y + b'y as computed on the last iteration; used to test for
        // convergence and updated before HasConverged() returns.
        this.previousFunctionValue = Number.MAX_VALUE;
        this.solverParameters = solverParameters;
        this.matrixQ = new Array(cVariables).fill(0);
        this.vectorWiDi = new Array(cVariables).fill(0);
        this.vectorQpscVars = new Array(cVariables).fill(0);
        this.gradientVector = new Array(cVariables).fill(0);
        this.vectorQg = new Array(cVariables).fill(0);
        this.vectorPrevY = new Array(cVariables).fill(0);
        this.vectorCurY = new Array(cVariables).fill(0);
    }
    //
    // solver.SolveQpsc drives the Qpsc instance as follows:
    // Initialization:
    //    Qpsc qpsc = new Qpsc(numVariables);
    //    foreach (variable in (foreach block))
    //       qpsc.AddVariable(variable)
    //    qpsc.VariablesComplete()
    // Per iteration:
    //    if (!qpsc.PreProject()) break;
    //    solver.SplitBlocks()
    //    solver.Project()
    //    if (!qpsc.PostProject()) break;
    // Done:
    //    qpsc.ProjectComplete()
    AddVariable(variable) {
        /*Assert.assert(
          this.matrixQ[variable.Ordinal] == null  &&
            this.vectorQpscVars[variable.Ordinal].Variable == null ,
          'variable.Ordinal already exists',
        )*/
        this.isFirstProjectCall = true;
        // This is the weight times desired position, multiplied by 2.0 per the partial derivative.
        // We'll use this to keep as close as possible to the desired position on each iteration.
        this.vectorWiDi[variable.Ordinal] = 2 * (variable.Weight * variable.DesiredPos) * -1;
        // Temporarily hijack vectorPrevY for use as scratch storage, to handle duplicate
        // neighbor pairs (take the highest weight).
        // Sum the weight for cell i,i (the diagonal).
        this.vectorPrevY[variable.Ordinal] = variable.Weight;
        if (null != variable.Neighbors) {
            for (const neighborWeightPair of variable.Neighbors) {
                // We should already have verified this in AddNeighbourPair.
                /*Assert.assert(
                  neighborWeightPair.Neighbor.Ordinal !== variable.Ordinal,
                  'self-neighbors are not allowed',
                )*/
                // For the neighbor KeyValuePairs, Key === neighboring variable and Value === relationship
                // weight.  If we've already encountered this pair then we'll sum the relationship weights, under
                // the assumption the caller will be doing something like creating edges for different reasons,
                // and multiple edges should be like rubber bands, the sum of the strengths.  Mathematica also
                // sums duplicate weights.
                // Per above comments:
                //     First the diagonal entries: A[i][i] = wi + Sum(wij for every neighbor j of i).
                this.vectorPrevY[variable.Ordinal] = this.vectorPrevY[variable.Ordinal] + neighborWeightPair.Weight;
                //     Then the off diagonal entries: A[i][j] = -Sum(wij for time j is a neighbor of i).
                this.vectorPrevY[neighborWeightPair.Neighbor.Ordinal] =
                    this.vectorPrevY[neighborWeightPair.Neighbor.Ordinal] - neighborWeightPair.Weight;
            }
        }
        // endif null !=  variable.Neighbors
        // Add the sparse row to the matrix (all non-zero slots of vectorPrevY are weights to that neighbor).
        for (let ii = 0; ii < this.vectorPrevY.length; ii++) {
            if (0 !== this.vectorPrevY[ii]) {
                // The diagonal must be > 0 and off-diagonal < 0.
                /*Assert.assert(
                  (ii === variable.Ordinal) === this.vectorPrevY[ii] > 0,
                  'Diagonal must be > 0.0',
                )*/
                // All 'A' cells must be 2*(summed weights).
                this.newMatrixRow.push(new MatrixCell(this.vectorPrevY[ii] * 2, ii));
                this.vectorPrevY[ii] = 0;
            }
        }
        this.matrixQ[variable.Ordinal] = Array.from(this.newMatrixRow);
        this.newMatrixRow = [];
        this.vectorQpscVars[variable.Ordinal] = new QpscVar(variable);
        // For the non-Qpsc loop, we consider weights in block reference-position calculation.
        // Here, we have that in vectorWiDi which we use in calculating gradient and alpha, which
        // in turn we use to set the gradient-stepped desiredPos.  So turn it off for the duration
        // of Qpsc - we restore it in QpscComplete().
        variable.Weight = 1;
    }
    // end AddVariable()
    VariablesComplete() {
        for (const qvar of this.vectorQpscVars) {
            const variable = qvar.Variable;
            for (const cell of this.matrixQ[variable.Ordinal]) {
                if (cell.Column === variable.Ordinal) {
                    if (this.solverParameters.Advanced.ScaleInQpsc) {
                        variable.Scale = 1 / Math.sqrt(Math.abs(cell.Value));
                        if (!Number.isFinite(variable.Scale)) {
                            variable.Scale = 1;
                        }
                        // This is the y = Sx step from the Scaling paper.
                        variable.Scale;
                        // This is the b' <- Sb step from the Scaling paper
                        this.vectorWiDi[variable.Ordinal] = this.vectorWiDi[variable.Ordinal] * variable.Scale;
                    }
                    // This is needed for block re-initialization.
                    this.vectorCurY[variable.Ordinal] = variable.ActualPos;
                    variable.DesiredPos = variable.ActualPos;
                }
            }
        }
        if (!this.solverParameters.Advanced.ScaleInQpsc) {
            return;
        }
        // Now convert mxQ to its scaled form S#QS (noting that the transform of a diagonal matrix S is S
        // so this is optimized), and we've made the S matrix such that Q[i][i] is 1.  The result is in-place
        // conversion of Q to scaledQ s.t.
        //   for all ii
        //      for all jj
        //         if ii === jj, scaledQ[ii][jj] = 1
        //         else         scaledQ[ii][jj] = Q[ii][jj] * var[ii].scale * var[jj].scale
        // /
        for (let rowNum = 0; rowNum < this.matrixQ.length; rowNum++) {
            const row = this.matrixQ[rowNum];
            for (let sparseCol = 0; sparseCol < row.length; sparseCol++) {
                if (row[sparseCol].Column === rowNum) {
                    row[sparseCol].Value = 1;
                }
                else {
                    // Diagonal on left scales rows [SQ], on right scales columns [QS].
                    row[sparseCol].Value =
                        row[sparseCol].Value * (this.vectorQpscVars[rowNum].Variable.Scale * this.vectorQpscVars[row[sparseCol].Column].Variable.Scale);
                }
            }
        }
    }
    // end VariablesComplete()
    // Called by SolveQpsc before the split/project phase.  Returns false if the difference in the
    // function value on the current vs. previous iteration is sufficiently small that we're done.
    // @@PERF: Right now this is distinct matrix/vector operations.  Profiling shows most time
    // in Qpsc is taken by MatrixVectorMultiply.  We could gain a bit of performance by combining
    // some things but keep it simple unless that's needed.
    PreProject() {
        if (this.isFirstProjectCall) {
            // Due to MergeEqualityConstraints we may have moved some of the variables.  This won't
            // affect feasibility since QpscMakeFeasible would already have ensured that any unsatisfiable
            // constraints are so marked.
            for (const qvar of this.vectorQpscVars) {
                this.vectorCurY[qvar.Variable.Ordinal] = qvar.Variable.ActualPos;
            }
        }
        //
        // Compute: g = Q'y + b' (in the Scaling paper terminology)
        //
        // g(radient) = Q'y...
        this.MatrixVectorMultiply(this.vectorCurY, this.gradientVector);
        // If we've minimized the goal function (far enough), we're done.
        // This uses the Q'y value we've just put into gradientVector and tests the goal-function value
        // to see if it is sufficiently close to the previous value to be considered converged.
        if (this.HasConverged()) {
            return false;
        }
        // ...g = Q'y + b'
        Qpsc.VectorVectorAdd(this.gradientVector, this.vectorWiDi, this.gradientVector);
        //
        // Compute: alpha = g#g / g#Q'g  (# === transpose)
        //
        const alphaNumerator = Qpsc.VectorVectorMultiply(this.gradientVector, this.gradientVector);
        // Compute numerator of stepsize
        let alphaDenominator = 0;
        if (0 !== alphaNumerator) {
            this.MatrixVectorMultiply(this.gradientVector, this.vectorQg);
            alphaDenominator = Qpsc.VectorVectorMultiply(this.vectorQg, this.gradientVector);
        }
        if (0 === alphaDenominator) {
            return false;
        }
        const alpha = alphaNumerator / alphaDenominator;
        //
        // Store off the current position as the previous position (the paper's y^ (y-hat)),
        // then calculate the new current position by subtracting the (gradient * alpha)
        // from it and update the Variables' desired position.
        //
        Qpsc.VectorCopy(this.vectorPrevY, this.vectorCurY);
        // Update d(esiredpos) = y - alpha*g
        // Use vectorCurY as temp as it is not used again here and is updated at start of PostProject.
        Qpsc.VectorScaledVectorSubtract(this.vectorPrevY, alpha, this.gradientVector, this.vectorCurY);
        for (let ii = 0; ii < this.vectorCurY.length; ii++) {
            this.vectorQpscVars[ii].Variable.DesiredPos = this.vectorCurY[ii];
        }
        return true;
    }
    // end PreProject()
    // Called by SolveQpsc after the split/project phase.
    PostProject() {
        //
        // Update our copy of current positions (y-bar from the paper) and deltaY (p in the Scaling paper; y-bar minus y-hat).
        //
        for (const qvar of this.vectorQpscVars) {
            this.vectorCurY[qvar.Variable.Ordinal] = qvar.Variable.ActualPos;
        }
        // vectorCurY temporarily becomes the p-vector from the Scaling paper since we don't use the "current"
        // position otherwise, until we reset it at the end.
        Qpsc.VectorVectorSubtract(this.vectorPrevY, this.vectorCurY, this.vectorCurY);
        //
        // Compute: Beta = min(g#p / p#Qp, 1)
        //
        const betaNumerator = Qpsc.VectorVectorMultiply(this.gradientVector, this.vectorCurY);
        // Compute numerator of stepsize
        let beta = 0;
        if (0 !== betaNumerator) {
            // Calculate Qp first (matrix ops are associative so (AB)C === A(BC), so calculate the rhs first
            // with MatrixVectorMultiply).  Temporarily hijack vectorQg for this operation.
            this.MatrixVectorMultiply(this.vectorCurY, this.vectorQg);
            // Now p#(Qp).
            const betaDenominator = Qpsc.VectorVectorMultiply(this.vectorQg, this.vectorCurY);
            // Dividing by almost-0 would yield a huge value which we'd cap at 1.0 below.
            beta = 0 === betaDenominator ? 1 : betaNumerator / betaDenominator;
            if (beta > 1) {
                // Note:  With huge ranges, beta is >>1 here - like 50 or millions.  This is expected as
                // we're dividing by p#Qp where p is potentially quite small.
                beta = 1;
            }
            else if (beta < 0) {
                // Setting it above 0.0 can move us away from convergence, so set it to 0.0 which leaves
                // vectorCurY unchanged from vectorPrevY and we'll terminate if there are no splits/violations.
                // If we were close to convergence in preProject, we could have a significantly negative
                // beta here, which means we're basically done unless split/project still have stuff to do.
                beta = 0;
            }
        }
        // Beta numerator is nonzero
        // Update the "Qpsc-local" copy of the current positions for use in the next loop's PreProject().
        Qpsc.VectorScaledVectorSubtract(this.vectorPrevY, beta, this.vectorCurY, this.vectorCurY);
        this.isFirstProjectCall = false;
        return beta > 0;
    }
    // end PostProject()
    QpscComplete() {
        // Restore original desired position and unscale the actual position.
        for (const qvar of this.vectorQpscVars) {
            qvar.Variable.Weight = qvar.OrigWeight;
            qvar.Variable.DesiredPos = qvar.OrigDesiredPos;
            if (this.solverParameters.Advanced.ScaleInQpsc) {
                // This multiplication essentially does what Constraint.Violation does, so the "satisfied" state
                // of constraints won't be changed.
                qvar.Variable.ActualPos = qvar.Variable.ActualPos * qvar.Variable.Scale;
                qvar.Variable.Scale = qvar.OrigScale;
            }
        }
        // This was updated to the final function value before HasConverged returned.
        return this.previousFunctionValue;
    }
    HasConverged() {
        //
        // Compute the function value relative to the previous iteration to test convergence:
        //     (x#Ax)/2 + bx + (w d).d       Note: final term is from Tim's Mathematica
        // where the last term (w d).d is constant and, because we only test decreasing value,
        // can therefore be omitted.
        //
        // We don't need to do the Ax operation as this is done as part of PreProject which has
        // already put this into gradientVector.
        //
        const currentFunctionValue = this.GetFunctionValue(this.vectorCurY);
        // If this is not our first PreProject call, test for convergence.
        let fConverged = false;
        if (!this.isFirstProjectCall) {
            // Check for convergence.  We are monotonically decreasing so prev should be > cur
            // with some allowance for rounding error.
            const diff = this.previousFunctionValue - currentFunctionValue;
            let quotient = 0;
            if (diff !== 0) {
                const divisor = 0 !== this.previousFunctionValue ? this.previousFunctionValue : currentFunctionValue;
                quotient = Math.abs(diff / divisor);
            }
            if (Math.abs(diff) < this.solverParameters.QpscConvergenceEpsilon ||
                Math.abs(quotient) < this.solverParameters.QpscConvergenceQuotient) {
                fConverged = true;
            }
        }
        // endif !isFirstProjectCall
        this.previousFunctionValue = currentFunctionValue;
        return fConverged;
    }
    GetFunctionValue(positions) {
        // (x#Ax)/2...
        const value = Qpsc.VectorVectorMultiply(this.gradientVector, positions) / 2;
        // (x'Ax)/2 + bx...
        return value + Qpsc.VectorVectorMultiply(this.vectorWiDi, positions);
    }
    // Returns the dot product of two column vectors (with an "implicit transpose").
    static VectorVectorMultiply(lhs, rhs) {
        // Do not use LINQ's Sum, it slows end-to-end by over 10%.
        let sum = 0;
        for (let ii = 0; ii < lhs.length; ii++) {
            sum = sum + lhs[ii] * rhs[ii];
        }
        return sum;
    }
    // Multiplies matrixQ with the column vector rhs leaving the result in column vector in result[].
    MatrixVectorMultiply(rhs, result) {
        // The only matrix we have here is (sparse) matrixQ so it's not a parameter.
        let rowIndex = 0;
        for (const row of this.matrixQ) {
            // Do not use LINQ's Sum, it slows end-to-end by over 10%.
            let sum = 0;
            for (const cell of row) {
                sum = sum + cell.Value * rhs[cell.Column];
            }
            result[rowIndex++] = sum;
        }
    }
    // Returns the addition result in result[] (which may be lhs or rhs or a different vector).
    static VectorVectorAdd(lhs, rhs, result) {
        for (let ii = 0; ii < lhs.length; ii++) {
            result[ii] = lhs[ii] + rhs[ii];
        }
    }
    // Returns the subtraction result in result[] (which may be lhs or rhs or a different vector).
    static VectorVectorSubtract(lhs, rhs, result) {
        for (let ii = 0; ii < lhs.length; ii++) {
            result[ii] = lhs[ii] - rhs[ii];
        }
    }
    // Same as VectorVectorSubtract except that rhs is multiplied by the scale value.
    static VectorScaledVectorSubtract(lhs, scale, rhs, result) {
        for (let ii = 0; ii < lhs.length; ii++) {
            result[ii] = lhs[ii] - scale * rhs[ii];
        }
    }
    // Copies src to dest
    static VectorCopy(dest, src) {
        for (let ii = 0; ii < src.length; ii++) {
            dest[ii] = src[ii];
        }
    }
}
//# sourceMappingURL=QPSC.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/Solution.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Solution: () => (/* binding */ Solution)
/* harmony export */ });
// Per-instance results from ProjectionSolver.Solver.Solve().
class Solution {
    constructor() {
        // The only failure condition is if there are one or more unsatisfiable constraints, such as cycles
        // or mutually exclusive equality constraints.
        this.NumberOfUnsatisfiableConstraints = 0;
        // The number of times the outer Project/Split loop was run.
        this.OuterProjectIterations = 0;
        // The number of times Project iterated internally; divide by OuterProjectIterations to get the average
        // inner iterations per outer iteration; see also MinInnerProjectIterations and MaxInnerProjectIterations.
        this.InnerProjectIterationsTotal = 0;
        // The minimum number of times Project iterated internally for any outer Project iterations.
        this.MinInnerProjectIterations = 0;
        // The maximum number of times Project iterated internally for any outer Project iterations.
        this.MaxInnerProjectIterations = 0;
        // The maximum depth of a constraint tree.
        this.MaxConstraintTreeDepth = 0;
        // The final value of the goal function.
        this.GoalFunctionValue = 0;
        // If true, the function ended due to TimeLimit being exceeded.
        this.TimeLimitExceeded = false;
        // If true, the function ended due to OuterProjectIterationsLimit being exceeded.
        this.OuterProjectIterationsLimitExceeded = false;
        // If true, a call to Project ended early due to InnerProjectIterationsLimit being exceeded.
        // The result may be nonfeasible.
        this.InnerProjectIterationsLimitExceeded = false;
    }
    // Indicates whether one or more execution limits were exceeded.
    get ExecutionLimitExceeded() {
        return this.TimeLimitExceeded || this.OuterProjectIterationsLimitExceeded || this.InnerProjectIterationsLimitExceeded;
    }
    // Shallow-copy everything, including the contained list.
    Clone() {
        const r = new Solution();
        r.GoalFunctionValue = this.GoalFunctionValue;
        r.InnerProjectIterationsLimitExceeded = this.InnerProjectIterationsLimitExceeded;
        r.InnerProjectIterationsTotal = this.InnerProjectIterationsTotal;
        r.MaxConstraintTreeDepth = this.MaxConstraintTreeDepth;
        r.OuterProjectIterations = this.OuterProjectIterations;
        r.OuterProjectIterationsLimitExceeded = this.OuterProjectIterationsLimitExceeded;
        r.AlgorithmUsed = this.AlgorithmUsed;
        r.NumberOfUnsatisfiableConstraints = this.NumberOfUnsatisfiableConstraints;
        r.MaxInnerProjectIterations = this.MaxInnerProjectIterations;
        return r;
    }
}
//# sourceMappingURL=Solution.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/Solver.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Solver: () => (/* binding */ Solver)
/* harmony export */ });
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _Block__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/Block.js");
/* harmony import */ var _BlockVector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/BlockVector.js");
/* harmony import */ var _Constraint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/Constraint.js");
/* harmony import */ var _ConstraintVector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/ConstraintVector.js");
/* harmony import */ var _Parameters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/Parameters.js");
/* harmony import */ var _QPSC__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/QPSC.js");
/* harmony import */ var _Solution__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/Solution.js");
/* harmony import */ var _SolverAlgorithm__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/SolverAlgorithm.js");
/* harmony import */ var _Variable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/Variable.js");
/* harmony import */ var _ViolationCache__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/ViolationCache.js");
// A Solver is the driving class that collects Variables and Constraints and then generates a
// solution that minimally satisfies the constraints.












class ConstraintListForVariable {
    constructor(constraints, numberOfLeftConstraints) {
        // The number of Constraints that are LeftConstraints for the variable keying this object.
        this.NumberOfLeftConstraints = 0;
        this.Constraints = constraints;
        this.NumberOfLeftConstraints = numberOfLeftConstraints;
    }
}
class Solver {
    constructor() {
        // Notes about hierarchy:
        //  1.  Each Variable is initially assigned to its own block, and subsequently MergeBlocks()
        //      and SplitBlocks() may change its block membership, but the variable is always in one
        //      and only one block, so we enumerate variables by enumerating blocks and variables.
        //  2.  The list of (active and inactive) constraints is within each block's variable list;
        //      we simply enumerate each block's LeftConstraints.
        this.allBlocks = new _BlockVector__WEBPACK_IMPORTED_MODULE_3__.BlockVector();
        // To speed up SearchAllConstraints, have a single Array in addition to the per-block
        // variable Lists (Array indexing is faster than Array).
        this.allConstraints = new _ConstraintVector__WEBPACK_IMPORTED_MODULE_5__.ConstraintVector();
        this.numberOfConstraints = 0;
        // Updated on AddConstraint; used to create AllConstraints
        this.numberOfVariables = 0;
        // Also for speed, a separate list of Equality constraints (which we expect to be fairly rare).
        this.equalityConstraints = new Array();
        // Also for speed, store variables -> constraint list while we load, then convert this into
        // arrays when we call Solve().  The members are Array of constraints, and number of Left constraints.
        this.loadedVariablesAndConstraintLists = new Map();
        // We bundle up the constraints first, so we can use Array rather than Array iteration for speed.
        // To make the code cleaner (not having to check for NULL all over the place) use an empty Array/Array
        // for Variables' constraint Lists/Arrays, and to help memory efficiency, use a single object.
        this.emptyConstraintList = new Array(0);
        // For long-lived Variable objects
        // For UpdateConstraint(), we want to buffer up the changes so variable values are not changed
        // by doing an immediate Block.Split which updates the Block's ReferencePos.
        this.updatedConstraints = new Array();
        // For caching violations to improve GetMaxViolatedConstraint performance.
        this.violationCache = new _ViolationCache__WEBPACK_IMPORTED_MODULE_11__.ViolationCache();
        this.violationCacheMinBlockCutoff = 0;
        this.nextVariableOrdinal = 0;
        // May be overridden by the caller's Parameters object passed to Solve.
        this.solverParams = new _Parameters__WEBPACK_IMPORTED_MODULE_6__.Parameters();
        // Solution results - will be cloned to return to caller.
        this.solverSolution = new _Solution__WEBPACK_IMPORTED_MODULE_8__.Solution();
    }
    get IsQpsc() {
        return this.hasNeighbourPairs || this.solverParams.Advanced.ForceQpsc;
    }
    // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
    // a tag or other user data - can be null
    // The position of the variable, such as the coordinate of a node along one axis.
    // <returns>The created variable</returns>
    AddVariableAN(userData, desiredPos) {
        return this.AddVariableANNN(userData, desiredPos, 1, 1);
    }
    // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
    // a tag or other user data - can be null
    // The position of the variable, such as the coordinate of a node along one axis.
    // The weight of the variable (makes it less likely to move if the weight is high).
    AddVariableANN(userData, desiredPos, weight) {
        return this.AddVariableANNN(userData, desiredPos, weight, 1);
    }
    // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
    // a tag or other user data - can be null
    // The position of the variable, such as the coordinate of a node along one axis.
    // The weight of the variable (makes it less likely to move if the weight is high).
    // The scale of the variable, for improving convergence.
    // <returns>The created variable</returns>
    AddVariableANNN(userData, desiredPos, weight, scale) {
        // @@DCR "Incremental Solving": For now we disallow this; if we support it, we'll need to
        // retain loadedVariablesAndConstraintLists, store up the added Variables (TryGetValue and if that fails add
        // the existing variable, then iterate through variables with new Constraints and replace the arrays.
        // Also remember to check for emptyConstraintList - don't add to it.
        if (!this.allConstraints.IsEmpty) {
            throw new Error('Cannot add Variables or Constraints once Solve() has been called');
        }
        const varNew = new _Variable__WEBPACK_IMPORTED_MODULE_10__.Variable(this.nextVariableOrdinal++, userData, desiredPos, weight, scale);
        const block = new _Block__WEBPACK_IMPORTED_MODULE_2__.Block(varNew, this.allConstraints);
        varNew.Block = block;
        this.allBlocks.Add(block);
        this.numberOfVariables++;
        // Initialize the variable in the dictionary with a null list and zero left constraints.
        this.loadedVariablesAndConstraintLists.set(varNew, new ConstraintListForVariable(new Array(), 0));
        return varNew;
    }
    // end AddVariable()
    // Must be called before Solve() if the caller has updated variable Initial positions; this
    // reconciles internals such as Block.ReferencePos.
    UpdateVariables() {
        // Although the name is "UpdateVariables", that's just for the caller to not need to know
        // about the internals; this really is updating the blocks after the variables have already
        // been updated one at a time. (This doesn't need to be called if constraints are re-gapped
        // while variable positions are unchanged; Solve() checks for that).
        for (const block of this.allBlocks.Vector) {
            block.UpdateReferencePos();
        }
    }
    // end UpdateVariables()
    // This enumerates all Variables created by AddVariable.
    get Variables() {
        return (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_1__.flattenArray)(this.allBlocks.Vector, (block) => block.Variables);
    }
    // The number of variables added to the Solver.
    get VariableCount() {
        return this.numberOfVariables;
    }
    // This enumerates all Constraints created by AddConstraint (which in turn may have
    // been called from OverlapRemoval.ConstraintGenerator.Generate()).
    *Constraints() {
        if (!this.allConstraints.IsEmpty) {
            // Solve() has been called.
            for (const constraint of this.allConstraints.Vector) {
                yield constraint;
            }
        }
        else {
            // Solve() has not yet been called.
            for (const variable of this.loadedVariablesAndConstraintLists.keys()) {
                const constraintsForVar = this.loadedVariablesAndConstraintLists.get(variable);
                if (null != constraintsForVar.Constraints) {
                    // Return all variables in the LeftConstraints list for each variable.
                    const numConstraints = constraintsForVar.Constraints.length;
                    // Cache for perf
                    for (let ii = 0; ii < numConstraints; ii++) {
                        const constraint = constraintsForVar.Constraints[ii];
                        if (variable === constraint.Left) {
                            yield;
                            return constraint;
                        }
                    }
                }
            }
        }
        // endifelse (!AllConstraints.Empty)
    }
    // end Constraints property
    // The number of constraints added to the Solver.
    get ConstraintCount() {
        return this.numberOfConstraints;
    }
    // Add a constraint 'left + gap' is equal to right
    AddEqualityConstraint(left, right, gap) {
        return this.AddConstraintVVNB(left, right, gap, true);
    }
    // Add a constraint 'left + gap' is less than or equal to 'right'
    // The gap required between the variables.
    // <returns>The new constraint.</returns>
    AddConstraintVVNB(left, right, gap, isEquality) {
        // @@DCR "Incremental Solving": See notes in AddVariable; for now, this is disallowed.
        if (!this.allConstraints.IsEmpty) {
            throw new Error('Cannot add Variables or Constraints once Solve() has been called');
        }
        if (left === right) {
            throw new Error('Cannot add a constraint between a variable and itself');
        }
        // Get the dictionary entries so we can store these until Solve() is called.  kvp.Key === lstConstraints,
        // kvp.Value === number of constraints in lstConstraints that are LeftConstraints for the variable.
        // kvpConstraintsForVar(Left|Right) are bidirectional for that variable, but we're operating only on
        // varLeft's LeftConstraints and varRight's RightConstraints; this is slightly more complicated logic
        // than just having two Lists, but for large numbers of variables, having all constraints in a single
        // list is more memory-efficient.
        const constraintsForLeftVar = this.loadedVariablesAndConstraintLists.get(left);
        const constraintsForRightVar = this.loadedVariablesAndConstraintLists.get(right);
        // Now create the new constraint and update the structures.  For varLeft, we must also update the
        // left-variable count and that requires another lookup to update the structure in the Map
        // since it's a value type so a copy was returned by-value from Map lookup.
        const constraint = _Constraint__WEBPACK_IMPORTED_MODULE_4__.Constraint.constructorVVNB(left, right, gap, isEquality);
        // Structure update requires replacing the full structure.
        this.loadedVariablesAndConstraintLists.set(left, new ConstraintListForVariable(constraintsForLeftVar.Constraints, constraintsForLeftVar.NumberOfLeftConstraints + 1));
        constraintsForLeftVar.Constraints.push(constraint);
        constraintsForRightVar.Constraints.push(constraint);
        this.numberOfConstraints++;
        if (isEquality) {
            this.equalityConstraints.push(constraint);
        }
        return constraint;
    }
    // Add a constraint 'left + gap' is less than or equal to 'right'
    // The gap required between the variables.
    // <returns>The new constraint.</returns>
    AddConstraint(left, right, gap) {
        return this.AddConstraintVVNB(left, right, gap, false);
    }
    // Register an update to a constraint's gap; this defers the actual update until Solve() is called.
    // The constraint to update
    // The new gap
    SetConstraintUpdate(constraint, gap) {
        // Defer this to the Solve() call, so the variables' positions are not altered by doing a
        // Block.Split here (which updates Block.ReferencePos, upon which Variable.(Scaled)ActualPos relies).
        if (gap !== constraint.Gap) {
            this.updatedConstraints.push([constraint, gap]);
        }
    }
    // Add a pair of connected variables for goal functions of the form (x1-x2)^2.  These are
    // minimally satisfied, along with the default (x-i)^2 goal function, while also satisfying
    // all constraints.
    // The first variable
    // The second variable
    // The weight of the relationship
    AddNeighborPair(variable1, variable2, relationshipWeight) {
        if (relationshipWeight <= 0 || Number.isNaN(relationshipWeight) || !Number.isFinite(relationshipWeight)) {
            throw new Error('relationshipWeight');
        }
        if (variable1 === variable2) {
            throw new Error();
        }
        variable1.AddNeighbor(variable2, relationshipWeight);
        variable2.AddNeighbor(variable1, relationshipWeight);
        this.hasNeighbourPairs = true;
    }
    // end AddNeighborPair()
    // Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints
    // along this axis.  This overload uses default solution parameter values.
    // <returns>A Solution object.</returns>
    Solve() {
        return this.SolvePar(null);
    }
    // Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints
    // along this axis.  This overload takes a parameter specification.
    // Solution-generation options.
    // <returns>The only failure condition is if there are one or more unsatisfiable constraints, such as cycles
    //         or mutually exclusive equality constraints; if these are encountered, a list of lists of these
    //         constraints is returned, where each list contains a single cycle, which may be of length one for
    //         unsatisfiable equality constraints.  Otherwise, the return value is null.</returns>
    SolvePar(solverParameters) {
        if (solverParameters) {
            this.solverParams = solverParameters.Clone();
        }
        // Reset some parameter defaults to per-solver-instance values.
        if (this.solverParams.OuterProjectIterationsLimit < 0) {
            // If this came in 0, it stays that way, and there is no limit.  Otherwise, set it to a value
            // reflecting the expectation of convergence roughly log-linearly in the number of variables.
            this.solverParams.OuterProjectIterationsLimit = 100 * (Math.floor(Math.log2(this.numberOfVariables)) + 1);
        }
        if (this.solverParams.InnerProjectIterationsLimit < 0) {
            // If this came in 0, it stays that way, and there is no limit.  Otherwise, assume that for
            // any pass, each constraint may be violated (most likely this happens only on the first pass),
            // and add some extra based upon constraint count.  Now that we split and retry on unsatisfied
            // constraints, assume that any constraint may be seen twice on a pass.
            this.solverParams.InnerProjectIterationsLimit =
                this.numberOfConstraints * 2 + 100 * (Math.max(0, Math.floor(Math.log2(this.numberOfConstraints))) + 1);
        }
        // ReSolving can be done for updated constraints.
        const isReSolve = !this.allConstraints.IsEmpty;
        this.CheckForUpdatedConstraints();
        this.solverSolution = new _Solution__WEBPACK_IMPORTED_MODULE_8__.Solution();
        this.solverSolution.MinInnerProjectIterations = Number.MAX_VALUE;
        this.allConstraints.MaxConstraintTreeDepth = 0;
        this.allConstraints.SolverParameters = this.solverParams;
        //
        // First set up all the  stuff we'll use for solutions.
        //
        // If no constraints have been loaded, there's nothing to do.  Two distinct variables
        // are required to create a constraint, so this also ensures a minimum number of variables.
        if (this.numberOfConstraints === 0) {
            // For Qpsc, we may have neighbours but no constraints.
            if (!this.IsQpsc) {
                return this.solverSolution.Clone();
            }
        }
        else if (!isReSolve) {
            this.SetupConstraints();
        }
        // This is the number of unsatisfiable constraints encountered.
        this.allConstraints.NumberOfUnsatisfiableConstraints = 0;
        // Merge Equality constraints first.  These do not do any constraint-splitting, and thus
        // remain in the same blocks, always satisfied, regardless of whether we're solving the full
        // Qpsc or the simpler loop.
        this.MergeEqualityConstraints();
        // Prepare for timeout checking.
        //
        // Done with initial setup.  Now if we have neighbour pairs, we do the full SolveQpsc logic
        // complete with Gradient projection.  Otherwise, we have a much simpler Project/Split loop.
        //
        if (this.IsQpsc) {
            this.SolveQpsc();
        }
        else {
            this.SolveByStandaloneProject();
            this.CalculateStandaloneProjectGoalFunctionValue();
        }
        // We initialized this to int.MaxValue so make sure it's sane if we didn't complete a Project iteration.
        if (this.solverSolution.MinInnerProjectIterations > this.solverSolution.MaxInnerProjectIterations) {
            // Probably this is 0.
            this.solverSolution.MinInnerProjectIterations = this.solverSolution.MaxInnerProjectIterations;
        }
        // Done.  Caller will copy each var.ActualPos back to the Nodes.  If we had any unsatisfiable
        // constraints, copy them back out to the caller.
        this.solverSolution.NumberOfUnsatisfiableConstraints = this.allConstraints.NumberOfUnsatisfiableConstraints;
        this.solverSolution.MaxConstraintTreeDepth = this.allConstraints.MaxConstraintTreeDepth;
        return this.solverSolution.Clone();
    }
    // end Solve()
    CheckForUpdatedConstraints() {
        if (0 === this.updatedConstraints.length) {
            return;
        }
        /*Assert.assert(
          !this.allConstraints.IsEmpty,
          'Cannot have updated constraints if AllConstraints is empty.',
        )*/
        // For Qpsc, all Block.ReferencePos values are based upon Variable.DesiredPos values, and the latter
        // have been restored from what they were on the last Qpsc iteration to their initial values).
        let mustReinitializeBlocks = this.IsQpsc;
        for (const [key, value] of this.updatedConstraints) {
            // Update the constraint, then split its block if it's active, so the next call to Solve()
            // will start the merge/split cycle again.
            const constraint = key;
            constraint.UpdateGap(value);
            if (!mustReinitializeBlocks && !constraint.IsEquality) {
                this.SplitOnConstraintIfActive(constraint);
                continue;
            }
            // Equality constraints must always be evaluated first and never split.
            // If we have updated one we must reinitialize the block structure.
            mustReinitializeBlocks = true;
        }
        this.updatedConstraints = [];
        if (mustReinitializeBlocks) {
            this.ReinitializeBlocks();
        }
    }
    SplitOnConstraintIfActive(constraint) {
        if (constraint.IsActive) {
            // Similar handling as in SplitBlocks, except that we know which constraint we're splitting on.
            const newSplitBlock = constraint.Left.Block.SplitOnConstraint(constraint);
            if (null != newSplitBlock) {
                this.allBlocks.Add(newSplitBlock);
            }
        }
        // endif constraint.IsActive
    }
    SetupConstraints() {
        // Optimize the lookup in SearchAllConstraints; create an array (which has faster
        // iteration than Array).
        this.allConstraints.Create(this.numberOfConstraints);
        for (const variable of this.loadedVariablesAndConstraintLists.keys()) {
            const constraintsForVar = this.loadedVariablesAndConstraintLists.get(variable);
            const constraints = constraintsForVar.Constraints;
            let numAllConstraints = 0;
            let numLeftConstraints = 0;
            let numRightConstraints = 0;
            if (null != constraints) {
                numAllConstraints = constraints.length;
                numLeftConstraints = constraintsForVar.NumberOfLeftConstraints;
                numRightConstraints = numAllConstraints - numLeftConstraints;
            }
            // Create the Variable's Constraint arrays, using the single emptyConstraintList for efficiency.
            let leftConstraints = this.emptyConstraintList;
            if (0 !== numLeftConstraints) {
                leftConstraints = new Array(numLeftConstraints);
            }
            let rightConstraints = this.emptyConstraintList;
            if (0 !== numRightConstraints) {
                rightConstraints = new Array(numRightConstraints);
            }
            variable.SetConstraints(leftConstraints, rightConstraints);
            // Now load the Variables' Arrays.  We're done with the loadedVariablesAndConstraintLists lists after this.
            let leftConstraintIndex = 0;
            let rightConstraintIndex = 0;
            for (let loadedConstraintIndex = 0; loadedConstraintIndex < numAllConstraints; loadedConstraintIndex++) {
                // numAllConstraints is 0 if null == constraints.
                // ReSharper disable PossibleNullReferenceException
                const loadedConstraint = constraints[loadedConstraintIndex];
                // ReSharper restore PossibleNullReferenceException
                if (variable === loadedConstraint.Left) {
                    leftConstraints[leftConstraintIndex++] = loadedConstraint;
                }
                else {
                    rightConstraints[rightConstraintIndex++] = loadedConstraint;
                }
            }
            /*Assert.assert(
              leftConstraintIndex === numLeftConstraints,
              'leftConstraintIndex must === numLeftConstraints',
            )*/
            /*Assert.assert(
              rightConstraintIndex === numRightConstraints,
              'rightConstraintIndex must === numRightConstraints',
            )*/
            // Done with per-variable constraint loading.  Now load the big list of all constraints.
            // All constraints are stored in a LeftConstraints array (and duplicated in a RightConstraints
            // array), so just load the LeftConstraints into AllConstraints. Array.Foreach is optimized.
            for (const constraint of variable.LeftConstraints) {
                this.allConstraints.Add(constraint);
            }
        }
        // this.allConstraints.Debug_AssertIsFull()
        // Done with the dictionary now.
        this.loadedVariablesAndConstraintLists.clear();
        // If we don't have many blocks then the caching optimization's overhead may outweigh
        // its benefit. Similarly, after blocks have merged past a certain point it's faster to
        // just enumerate them all.  Initialize this to off.
        this.violationCacheMinBlockCutoff = Number.MAX_VALUE;
        if (this.solverParams.Advanced.UseViolationCache && this.solverParams.Advanced.ViolationCacheMinBlocksDivisor > 0) {
            this.violationCacheMinBlockCutoff = Math.min(this.allBlocks.Count / this.solverParams.Advanced.ViolationCacheMinBlocksDivisor, this.solverParams.Advanced.ViolationCacheMinBlocksCount);
        }
    }
    SolveByStandaloneProject() {
        // Loop until we have no constraints with violations and no blocks are split.
        // Note:  this functions differently from the loop-termination test in SolveQpsc, which tests the
        // total movement resulting from Project() against some epsilon.  We do this differently here because
        // we're not doing the Gradient portion of SolveQpsc, so we'll just keep going as long as we have any
        // violations greater than the minimum violation we look for in GetMaxViolatedConstraint (and as long
        // as we don't split any blocks whether or not we find such a violation).
        for (;;) {
            // Don't check the return of Project; defer the termination check to SplitBlocks.
            // This also examines limits post-Project; because it happens pre-SplitBlocks it ensures
            // a feasible stopping state.
            if (!this.RunProject()) {
                return;
            }
            // If SplitBlocks doesn't find anything to split then Project would do nothing.
            if (!this.SplitBlocks()) {
                break;
            }
        }
    }
    RunProject() {
        this.solverSolution.OuterProjectIterations++;
        this.Project();
        // Examine limits post-Project but pre-SplitBlocks to ensure a feasible stopping state.
        return !this.CheckForLimitsExceeded();
    }
    CheckForLimitsExceeded() {
        // if (null !=  this.timeoutStopwatch) {
        //  if (
        //    this.timeoutStopwatch.ElapsedMilliseconds >= this.solverParams.TimeLimit
        //  ) {
        //    this.solverSolution.TimeLimitExceeded = true
        //    return true
        //  }
        // }
        if (this.solverParams.OuterProjectIterationsLimit > 0) {
            if (this.solverSolution.OuterProjectIterations >= this.solverParams.OuterProjectIterationsLimit) {
                this.solverSolution.OuterProjectIterationsLimitExceeded = true;
                return true;
            }
        }
        if (this.solverSolution.InnerProjectIterationsLimitExceeded) {
            return true;
        }
        return false;
    }
    CalculateStandaloneProjectGoalFunctionValue() {
        // Fill in the non-Qpsc Goal function value.  See Qpsc.HasConverged for details; this is a
        // streamlined form of (x'Ax)/2 + bx here, where A has only the diagonals (as there are no
        // neighbours) with 2*wi and b is a vector of -2*wi*di, and x is current position.
        this.solverSolution.GoalFunctionValue = 0;
        const numBlocks = this.allBlocks.Count;
        // cache for perf
        for (let i = 0; i < numBlocks; i++) {
            const block = this.allBlocks.item(i);
            const numVars = block.Variables.length;
            for (let j = 0; j < numVars; j++) {
                const variable = block.Variables[j];
                // (x'Ax)/2
                this.solverSolution.GoalFunctionValue += variable.Weight * (variable.ActualPos * variable.ActualPos);
                // +bx
                this.solverSolution.GoalFunctionValue -= 2 * (variable.Weight * (variable.DesiredPos * variable.ActualPos));
            }
        }
    }
    // Implements the full solve_QPSC from the Ipsep_Cola and Scaling papers.
    SolveQpsc() {
        this.solverSolution.AlgorithmUsed = this.solverParams.Advanced.ScaleInQpsc
            ? _SolverAlgorithm__WEBPACK_IMPORTED_MODULE_9__.SolverAlgorithm.QpscWithScaling
            : _SolverAlgorithm__WEBPACK_IMPORTED_MODULE_9__.SolverAlgorithm.QpscWithoutScaling;
        if (!this.QpscMakeFeasible()) {
            return;
        }
        // Initialize the Qpsc state, which also sets the scale for all variables (if we are scaling).
        const qpsc = new _QPSC__WEBPACK_IMPORTED_MODULE_7__.Qpsc(this.solverParams, this.numberOfVariables);
        for (const block of this.allBlocks.Vector) {
            for (const variable of block.Variables) {
                qpsc.AddVariable(variable);
            }
        }
        qpsc.VariablesComplete();
        this.ReinitializeBlocks();
        this.MergeEqualityConstraints();
        // this.VerifyConstraintsAreFeasible()
        // Iterations
        let foundSplit = false;
        for (;;) {
            //
            // Calculate initial step movement.  We assume there will be some movement needed
            // even on the first pass in the vast majority of cases.  This also tests convergence
            // of the goal-function value; if it is sufficiently close to the previous iteration's
            // result and the previous iteration did not split or encounter a violation, we're done.
            //
            if (!qpsc.PreProject() && !foundSplit) {
                break;
            }
            //
            // Split the blocks (if this the first time through the loop then all variables are in their
            // own block except for any equality constraints, which we don't split; but we still need to
            // have UpdateReferencePos called).
            //
            foundSplit = this.SplitBlocks();
            // Examine limits post-Project to ensure a feasible stopping state.  We don't test for
            // termination due to "no violations found" here, deferring that to the next iteration's PreProject().
            if (!this.RunProject()) {
                break;
            }
            //
            // Calculate the new adjustment to the current positions based upon the amount of movement
            // done by split/project.  If this returns false then it means that movement was zero and
            // we're done if there was no split or constraint violation.
            //
            if (!qpsc.PostProject() && !foundSplit) {
                break;
            }
        }
        // end forever
        this.solverSolution.GoalFunctionValue = qpsc.QpscComplete();
    }
    QpscMakeFeasible() {
        // Start off with one Project pass so the initial Qpsc state is feasible (not in violation
        // of constraints).  If this takes more than the max allowable time, we're done.
        return this.RunProject();
    }
    ReinitializeBlocks() {
        // For Qpsc we want to discard the previous block structure, because it did not consider
        // neighbors, and the gradient may want to pull things in an entirely different way.
        // We must also do this for a re-Solve that updated the gap of an equality constraint.
        const oldBlocks = Array.from(this.allBlocks.Vector);
        this.allBlocks.Vector = [];
        for (const oldBlock of oldBlocks) {
            for (const variable of oldBlock.Variables) {
                variable.Reinitialize();
                const newBlock = new _Block__WEBPACK_IMPORTED_MODULE_2__.Block(variable, this.allConstraints);
                this.allBlocks.Add(newBlock);
            }
        }
        this.allConstraints.Reinitialize();
        this.violationCache.Clear();
    }
    MergeEqualityConstraints() {
        // PerfNote: We only call this routine once so don't worry about Array-Enumerator overhead.
        for (const constraint of this.equalityConstraints) {
            if (constraint.Left.Block === constraint.Right.Block) {
                // They are already in the same block and we are here on the first pass that merges blocks
                // containing only equality constraints.  Thus we know that there is already a chain of equality
                // constraints joining constraint.Left and constraint.Right, and that chain will always be
                // moved as a unit because we never split or expand equality constraints, so this constraint
                // will remain retain its current satisfied state and does not need to be activated (which
                // would potentially lead to cycles; this is consistent with the non-equality constraint
                // approach of not activating constraints that are not violated).
                if (Math.abs(constraint.Violation) > this.solverParams.GapTolerance) {
                    // This is an equivalence conflict, such as a + 3 === b; b + 3 === c; a + 9 === c.
                    constraint.IsUnsatisfiable = true;
                    this.allConstraints.NumberOfUnsatisfiableConstraints++;
                }
                continue;
            }
            this.MergeBlocks(constraint);
        }
    }
    Project() {
        if (this.numberOfConstraints === 0) {
            // We are here for the neighbours-only case.
            return false;
        }
        // Get the maximum violation (the Constraint with the biggest difference between the
        // required gap between its two variables vs. their actual relative positions).
        // If there is no violation, we're done (although SplitBlocks may change things so
        // we have to go again).
        this.violationCache.Clear();
        this.lastModifiedBlock = null;
        let useViolationCache = this.allBlocks.Count > this.violationCacheMinBlockCutoff;
        // The first iteration gets the first violated constraint.
        let cIterations = 1;
        const t = { maxViolation: 0 };
        let maxViolatedConstraint = this.GetMaxViolatedConstraint(t, useViolationCache);
        if (!maxViolatedConstraint) {
            return false;
        }
        // We have at least one violation, so process them until there are no more.
        while (maxViolatedConstraint) {
            /*Assert.assert(
              !maxViolatedConstraint.IsUnsatisfiable,
              'maxViolatedConstraint should not be unsatisfiable',
            )*/
            /*Assert.assert(
              !maxViolatedConstraint.IsEquality,
              'maxViolatedConstraint should not be equality',
            )*/
            // Perf note: Variables (and Blocks) use the default Object.Equals implementation, which is
            // simply ReferenceEquals for reference types.
            if (maxViolatedConstraint.Left.Block === maxViolatedConstraint.Right.Block) {
                maxViolatedConstraint.Left.Block.Expand(maxViolatedConstraint);
                if (maxViolatedConstraint.IsUnsatisfiable) {
                    this.violationCache.Clear();
                    // We're confusing the lineage of lastModifiedBlock
                }
                this.lastModifiedBlock = maxViolatedConstraint.Left.Block;
            }
            else {
                // The variables are in different blocks so merge the blocks.
                this.lastModifiedBlock = this.MergeBlocks(maxViolatedConstraint);
            }
            // Note that aborting here does not guarantee a feasible state.
            if (this.solverParams.InnerProjectIterationsLimit > 0) {
                if (cIterations >= this.solverParams.InnerProjectIterationsLimit) {
                    this.solverSolution.InnerProjectIterationsLimitExceeded = true;
                    break;
                }
            }
            // Now we've potentially changed one or many variables' positions so recalculate the max violation.
            useViolationCache = this.allBlocks.Count > this.violationCacheMinBlockCutoff;
            if (!useViolationCache) {
                this.violationCache.Clear();
            }
            cIterations++;
            const t = { maxViolation: 0 };
            maxViolatedConstraint = this.GetMaxViolatedConstraint(t, useViolationCache);
        }
        // endwhile violations exist
        this.solverSolution.InnerProjectIterationsTotal = this.solverSolution.InnerProjectIterationsTotal + cIterations;
        if (this.solverSolution.MaxInnerProjectIterations < cIterations) {
            this.solverSolution.MaxInnerProjectIterations = cIterations;
        }
        if (this.solverSolution.MinInnerProjectIterations > cIterations) {
            this.solverSolution.MinInnerProjectIterations = cIterations;
        }
        // If we got here, we had at least one violation.
        // this.allConstraints.Debug_AssertConsistency()
        return true;
    }
    // end Project()
    MergeBlocks(violatedConstraint) {
        // Start off evaluating left-to-right.
        let blockTo = violatedConstraint.Left.Block;
        let blockFrom = violatedConstraint.Right.Block;
        /*Assert.assert(
          blockTo !== blockFrom,
          'Merging of constraints in the same block is not allowed',
        )*/
        // The violation amount is the needed distance to move to tightly satisfy the constraint.
        // Calculate this based on offsets even though the vars are in different blocks; we'll normalize
        // that when we recalculate the block reference position and the offsets in the Right block.
        let distance = violatedConstraint.Left.OffsetInBlock + (violatedConstraint.Gap - violatedConstraint.Right.OffsetInBlock);
        if (blockFrom.Variables.length > blockTo.Variables.length) {
            // Reverse this so we minimize variable movement by moving stuff from the block with the least
            // number of vars into the block with the greater number.
            blockTo = violatedConstraint.Right.Block;
            blockFrom = violatedConstraint.Left.Block;
            distance = -distance;
        }
        // Move all vars from blockFrom to blockTo, and adjust their offsets by dist as
        // mentioned above.  This has the side-effect of moving the associated active constraints
        // as well (because they are carried in the variables' LeftConstraints); violatedConstraint
        // is therefore also moved if it was in blockFrom.
        const numVars = blockFrom.Variables.length;
        // iteration is faster than foreach for Array<>s
        for (let i = 0; i < numVars; i++) {
            const variable = blockFrom.Variables[i];
            variable.OffsetInBlock += distance;
            blockTo.AddVariable(variable);
        }
        blockTo.UpdateReferencePosFromSums();
        //blockTo.DebugVerifyReferencePos()
        // Do any final bookkeeping necessary.
        // blockTo.Debug_PostMerge(blockFrom)
        // Make the (no-longer-) violated constraint active.
        this.allConstraints.ActivateConstraint(violatedConstraint);
        // We have no further use for blockFrom as nobody references it.
        this.allBlocks.Remove(blockFrom);
        return blockTo;
    }
    // end MergeBlocks()
    SplitBlocks() {
        // First enumerate all blocks and accumulate any new ones that we form by splitting off
        // from an existing block.  Then add those to our block list in a second pass (to avoid
        // a "collection modified during enumeration" exception).
        const newBlocks = new Array();
        const numBlocks = this.allBlocks.Count;
        // Cache for perf
        for (let i = 0; i < numBlocks; i++) {
            const block = this.allBlocks.item(i);
            /*Assert.assert(
              0 !== block.Variables.length,
              'block must have nonzero variable count',
            )*/
            const newSplitBlock = block.Split(this.IsQpsc);
            if (null != newSplitBlock) {
                newBlocks.push(newSplitBlock);
            }
        }
        const numNewBlocks = newBlocks.length;
        // cache for perf
        for (let ii = 0; ii < numNewBlocks; ii++) {
            const block = newBlocks[ii];
            this.allBlocks.Add(block);
        }
        // The paper uses "did not split" for the return but "did split" seems more intuitive
        return 0 !== newBlocks.length;
    }
    // end SplitBlocks
    GetMaxViolatedConstraint(t, useViolationCache) {
        // Get the most-violated constraint in the Solver.  Active constraints are calculated
        // to keep their constraint minimally satisfied, so any nonzero active-constraint
        // violation is due to rounding error; therefore just look for inactive constraints.
        // Pass maxViolation to subroutines because it is initialized to a limiting value.
        t.maxViolation = this.solverParams.GapTolerance;
        const maxViolatedConstraint = this.SearchViolationCache(t.maxViolation);
        if (null != maxViolatedConstraint) {
            return maxViolatedConstraint;
        }
        // Nothing in ViolationCache or we've got too many Constraints in the block, so search
        // the list of all constraints.
        return this.SearchAllConstraints(t.maxViolation, useViolationCache);
    }
    // end GetMaxViolatedConstraint()
    SearchViolationCache(maxViolation) {
        // If we have any previously cached max violated constraints, then we'll first remove any
        // that are incoming to or outgoing from the lastModifiedBlock on the current Project()
        // iteration; these constraints are the only ones that may have changed violation values
        // (due to block expansion or merging).  If any of the cached maxvio constraints remain after
        // that, then we can use the largest of these if it's larger than any constraints in lastModifiedBlock.
        // Even if no cached violations remain after filtering, we still know that the largest violations were
        // most likely associated with lastModifiedBlock.  So we take a pass through lastModifiedBlock and put
        // its top constraints into the cache and then take the largest constraint from the violation cache,
        // which may or may not be associated with lastModifiedBlock.  (This would happen after filling the
        // cache from multiple blocks in the first pass, or after Block.Split moved some variables (with
        // cached inactive constraints) to the new block).
        //
        // This iteration is slower (relative to the number of constraints in the block) than
        // SearchAllConstraints, due to two loops, so only do it if the block has a sufficiently small
        // number of constraints.  Use the Variables as a proxy for the constraint count of the block.
        // @@PERF: the block could keep a constraint count to make ViolationCache cutoff more accurate.
        let maxViolatedConstraint = null;
        if (this.lastModifiedBlock == null)
            return;
        if (this.lastModifiedBlock.Variables.length < this.numberOfVariables + 1 && this.violationCache.FilterBlock(this.lastModifiedBlock)) {
            // Also removes unsatisfiables
        }
        // First evaluate all (inactive) outgoing constraints for all variables in the block; this gets
        // both all intra-block constraints and all inter-block constraints where the lastModifiedBlock
        // is the source.  Then evaluate incoming constraints where the source is outside the block.
        const numVarsInBlock = this.lastModifiedBlock.Variables.length;
        // cache for perf
        for (let variableIndex = 0; variableIndex < numVarsInBlock; variableIndex++) {
            const variable = this.lastModifiedBlock.Variables[variableIndex];
            for (const constraint of variable.LeftConstraints) {
                if (!constraint.IsActive && !constraint.IsUnsatisfiable) {
                    const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);
                    /*Assert.assert(
                      closeDistEps(constraint.Violation, violation),
                      'LeftConstraints: constraint.Violation must === violation',
                    )*/
                    if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.greaterDistEps)(violation, maxViolation)) {
                        // Cache the previous high violation.  Pass the violation as a tiny perf optimization
                        // to save re-doing the double operations in this inner loop.
                        if (null != maxViolatedConstraint && maxViolation > this.violationCache.LowViolation) {
                            this.violationCache.Insert(maxViolatedConstraint, maxViolation);
                        }
                        maxViolation = constraint.Violation;
                        maxViolatedConstraint = constraint;
                    }
                }
            }
            // endfor each LeftConstraint
            for (const constraint of variable.RightConstraints) {
                if (!constraint.IsActive && !constraint.IsUnsatisfiable && constraint.Left.Block !== this.lastModifiedBlock) {
                    const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);
                    // Assert.assert(constraint.Violation === violation, "LeftConstraints: constraint.Violation must === violation");
                    /*Assert.assert(
                      closeDistEps(constraint.Violation, violation),
                      'LeftConstraints: constraint.Violation must === violation',
                    )*/
                    // if (violation > maxViolation)
                    if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.greaterDistEps)(violation, maxViolation)) {
                        if (null != maxViolatedConstraint && maxViolation > this.violationCache.LowViolation) {
                            this.violationCache.Insert(maxViolatedConstraint, maxViolation);
                        }
                        maxViolation = violation;
                        maxViolatedConstraint = constraint;
                    }
                }
            }
            // endfor each RightConstraint
        }
        // endfor each var in lastModifiedBlock.Variables
        // Now see if any of the cached maxvios are greater than we have now.  Don't remove
        // it here; we'll wait until Expand/Merge set lastModifiedBlock and then the removal
        // occurs above in ViolationCache.FilterBlock in this block when we come back in.
        const cachedConstraint = this.violationCache.FindIfGreater(maxViolation);
        if (null != cachedConstraint) {
            // The cache had something more violated than maxViolatedConstraint, but maxViolatedConstraint
            // may be larger than at least one cache element.
            if (null != maxViolatedConstraint && maxViolation > this.violationCache.LowViolation) {
                this.violationCache.Insert(maxViolatedConstraint, maxViolation);
            }
            maxViolatedConstraint = cachedConstraint;
        }
        // endif FilterBlock
        return maxViolatedConstraint;
        // Remains null if we don't find one
    }
    SearchAllConstraints(maxViolation, useViolationCache) {
        // Iterate all constraints, finding the most-violated and populating the violation cache
        // with the next-highest violations.
        let maxViolatedConstraint = null;
        this.violationCache.Clear();
        for (const constraint of this.allConstraints.Vector) {
            // The constraint vector is now organized with all inactive constraints first.
            if (constraint.IsActive) {
                break;
            }
            if (constraint.IsUnsatisfiable) {
                continue;
            }
            // Note:  The docs have >= 0 for violation condition but it should be just > 0.
            const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);
            /*Assert.assert(
              closeDistEps(constraint.Violation, violation),
              'constraint.Violation must === violation',
            )*/
            let cacheInsertConstraint = null;
            let cacheInsertViolation = 0;
            if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_0__.greaterDistEps)(violation, maxViolation)) {
                if (maxViolation > this.violationCache.LowViolation) {
                    cacheInsertConstraint = maxViolatedConstraint;
                    cacheInsertViolation = maxViolation;
                }
                maxViolation = violation;
                maxViolatedConstraint = constraint;
            }
            if (useViolationCache) {
                // If constraint was a violation but not > maxViolation, then we'll look to insert it into the cache.
                // (We already know that if the previous maxViolatedConstraint is to be inserted, then its violation is
                // greater than any in the cache).  On the first iteration of "for each constraint", maxViolatedConstraint
                // is null, hence the constraint !== maxViolatedConstraint test.
                if (cacheInsertConstraint == null &&
                    constraint !== maxViolatedConstraint &&
                    (!this.violationCache.IsFull || violation > this.violationCache.LowViolation)) {
                    // Either the cache isn't full or the new constraint is more violated than the lowest cached constraint.
                    cacheInsertConstraint = constraint;
                    cacheInsertViolation = violation;
                }
                if (null != cacheInsertConstraint && cacheInsertViolation > this.violationCache.LowViolation) {
                    this.violationCache.Insert(cacheInsertConstraint, cacheInsertViolation);
                }
            }
            // endif useViolationCache
        }
        // endfor each constraint
        return maxViolatedConstraint;
        // Remains null if we don't find one
    }
}
//# sourceMappingURL=Solver.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/SolverAlgorithm.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SolverAlgorithm: () => (/* binding */ SolverAlgorithm)
/* harmony export */ });
// --------------------------------------------------------------------------------------------------------------------
// <copyright file="SolverAlgorithm.cs" company="Microsoft">
//  (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// MSAGL class for algorithm enumeration for Projection Solver.
// --------------------------------------------------------------------------------------------------------------------
var SolverAlgorithm;
(function (SolverAlgorithm) {
    // Iterative Project/Split only.
    SolverAlgorithm[SolverAlgorithm["ProjectOnly"] = 0] = "ProjectOnly";
    // Diagonally-scaled gradient projection/Qpsc (Quadratic Programming for Separation Constraints).
    SolverAlgorithm[SolverAlgorithm["QpscWithScaling"] = 1] = "QpscWithScaling";
    // Gradient projection/Qpsc (Quadratic Programming for Separation Constraints) without diagonal scaling.
    SolverAlgorithm[SolverAlgorithm["QpscWithoutScaling"] = 2] = "QpscWithoutScaling";
})(SolverAlgorithm || (SolverAlgorithm = {}));
//# sourceMappingURL=SolverAlgorithm.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/SolverShell.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SolverShell: () => (/* binding */ SolverShell)
/* harmony export */ });
/* harmony import */ var _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/RealNumberSpan.js");
/* harmony import */ var _Solver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/Solver.js");
// just a convenient interface to the real solver


class SolverShell {
    // Constructor.
    constructor() {
        this.variables = new Map();
        this.fixedVars = new Map();
        // if all active constraint gaps are less than this epsilon we should stop trying adjusting
        this.FailToAdjustEpsilon = 0.001;
        this.InitSolver();
    }
    // Add a node that we would like as close to position i as possible, with the requested weight.
    // Caller's unique identifier for this node
    // Desired position
    // The weight of the corresponding term in the goal function
    AddVariableWithIdealPositionNNN(id, position, weight) {
        // This throws an ArgumentException if a variable with id is already there.
        this.variables.set(id, this.solver.AddVariableANN(id, position, weight));
    }
    // Add a node that we would like as close to position i as possible, with the requested weight.
    AddVariableWithIdealPositionNN(id, position) {
        this.AddVariableWithIdealPositionNNN(id, position, 1);
    }
    // Add a constraint that leftNode+gap eq|leq RightNode.
    // Caller's unique identifier for the left node
    // Caller's unique identifier for the right node
    // Required gap
    // Gap is exact rather than minimum
    AddLeftRightSeparationConstraintNNNB(idLeft, idRight, gap, isEquality) {
        // The variables must already have been added by AddNodeWithDesiredPosition.
        const varLeft = this.GetVariable(idLeft);
        if (varLeft == null) {
            return;
        }
        const varRight = this.GetVariable(idRight);
        if (varRight == null) {
            return;
        }
        this.solver.AddConstraintVVNB(varLeft, varRight, gap, isEquality);
    }
    // Add a constraint that leftNode+gap leq RightNode.
    // Caller's unique identifier for the left node
    // Caller's unique identifier for the right node
    // Required minimal gap
    AddLeftRightSeparationConstraintNNN(idLeft, idRight, gap) {
        this.AddLeftRightSeparationConstraintNNNB(idLeft, idRight, gap, false);
    }
    // Add a goal that minimizes the distance between two nodes, i.e. weight*((id1-id2)^2).
    // Caller's unique identifier for the first node.
    // Caller's unique identifier for the second node.
    // The weight of the corresponding term in the goal function
    AddGoalTwoVariablesAreCloseNNN(id1, id2, weight) {
        const var1 = this.GetVariable(id1);
        if (var1 == null) {
            return;
        }
        const var2 = this.GetVariable(id2);
        if (var2 == null) {
            return;
        }
        this.solver.AddNeighborPair(var1, var2, weight);
    }
    //
    AddGoalTwoVariablesAreClose(id1, id2) {
        this.AddGoalTwoVariablesAreCloseNNN(id1, id2, 1);
    }
    GetVariable(i) {
        return this.variables.get(i);
    }
    // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
    Solve() {
        this.SolveP(null);
    }
    // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
    // Parameter object class specific to the underlying solver
    // <returns>Pass or fail</returns>
    SolveP(parameters) {
        const t = { executionLimitExceeded: false };
        this.SolvePNS(parameters, t);
    }
    // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
    // Parameter object class specific to the underlying solver
    //         or timeout were exceeded</param>
    // <returns>Pass or fail</returns>
    SolvePNS(parameters, t) {
        let fixedVarsMoved;
        do {
            this.solution = null;
            // Remove any stale solution in case parameters validation or Solve() throws.
            let solverParameters = null;
            if (null != parameters) {
                solverParameters = parameters;
                if (solverParameters == null) {
                    throw new Error('parameters');
                }
            }
            this.solution = this.solver.SolvePar(solverParameters);
            t.executionLimitExceeded = this.solution.ExecutionLimitExceeded;
            fixedVarsMoved = this.AdjustConstraintsForMovedFixedVars();
        } while (fixedVarsMoved && this.solution.ExecutionLimitExceeded === false);
        return this.solution.ExecutionLimitExceeded === false;
    }
    //        void DumpToFile(string fileName) {
    //            var file = new StreamWriter(fileName);
    //            file.WriteLine("digraph {");
    //            foreach (var v in solver.Variables) {
    //                var s = v.Weight > 100 ? "color=\"red\"" : "";
    //                file.WriteLine(v.UserData + " [ label=" + "\"" + v.UserData +"\\n" +
    //                               v.DesiredPos + "\" " +s+ "]");
    //
    //            }
    //
    //            foreach (var cs in solver.Constraints) {
    //                file.WriteLine(cs.Left.UserData + " -> " + cs.Right.UserData + " [ label=\"" + cs.Gap + "\"]");
    //            }
    //            file.WriteLine("}");
    //            file.Close();
    //        }
    AdjustConstraintsForMovedFixedVars() {
        const movedFixedVars = new Set();
        for (const [k, v] of this.fixedVars.entries()) {
            if (SolverShell.Close(v, this.GetVariableResolvedPosition(k)))
                continue;
            movedFixedVars.add(k);
        }
        if (movedFixedVars.size === 0) {
            return false;
        }
        return this.AdjustConstraintsForMovedFixedVarSet(movedFixedVars);
    }
    static Close(a, b) {
        return Math.abs(a - b) < 0.0005;
        // so if a fixed variable moved less than 0.0001 we do not care!
    }
    AdjustConstraintsForMovedFixedVarSet(movedFixedVars) {
        while (movedFixedVars.size > 0) {
            let fixedVar;
            for (const t of movedFixedVars) {
                fixedVar = t;
                break;
            }
            if (!this.AdjustSubtreeOfFixedVar(fixedVar, movedFixedVars)) {
                return false;
            }
        }
        return true;
    }
    AdjustSubtreeOfFixedVar(fixedVar, movedFixedVars) {
        const t = { successInAdjusting: false };
        const neighbors = this.AdjustConstraintsOfNeighborsOfFixedVariable(fixedVar, t);
        if (!t.successInAdjusting) {
            return false;
        }
        if (neighbors.length === 0) {
            return false;
        }
        for (const i of neighbors) {
            movedFixedVars.delete(i);
        }
        return true;
    }
    // returns the block of the fixed variable
    AdjustConstraintsOfNeighborsOfFixedVariable(fixedVar, t) {
        const nbs = this.variables.get(fixedVar).Block.Variables;
        const currentSpan = new _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_0__.RealNumberSpan();
        const idealSpan = new _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_0__.RealNumberSpan();
        let scale = 1;
        for (const u of nbs) {
            if (!this.fixedVars.has(u.UserData)) {
                continue;
            }
            currentSpan.AddValue(u.ActualPos);
            idealSpan.AddValue(u.DesiredPos);
            if (idealSpan.length > 0) {
                scale = Math.max(scale, currentSpan.length / idealSpan.length);
            }
        }
        if (scale === 1) {
            scale = 2;
        }
        // just relax the constraints
        t.successInAdjusting = this.FixActiveConstraints(nbs, scale);
        return nbs.map((u) => u.UserData);
    }
    FixActiveConstraints(neighbs, scale) {
        let ret = false;
        for (const v of neighbs) {
            for (const c of v.LeftConstraints) {
                if (c.IsActive) {
                    if (c.Gap > this.FailToAdjustEpsilon)
                        ret = true;
                    this.solver.SetConstraintUpdate(c, c.Gap / scale);
                }
            }
        }
        return ret;
    }
    // Obtain the solved position for a node.
    // Caller's unique identifier for the node.
    // <returns>The node's solved position.</returns>
    GetVariableResolvedPosition(id) {
        const v = this.GetVariable(id);
        return v == null ? 0 : v.ActualPos;
    }
    //
    InitSolver() {
        this.solver = new _Solver__WEBPACK_IMPORTED_MODULE_1__.Solver();
        this.variables.clear();
    }
    // Add a variable with a known and unchanging position.
    // Caller's unique identifier for the node
    // Desired position.
    AddFixedVariable(id, position) {
        this.AddVariableWithIdealPositionNNN(id, position, SolverShell.FixedVarWeight);
        this.fixedVars.set(id, position);
    }
    //
    ContainsVariable(v) {
        return this.variables.has(v);
    }
    // returns the ideal position of the node that had been set at the variable construction
    GetVariableIdealPosition(v) {
        return this.variables.get(v).DesiredPos;
    }
    // Returns the solution object class specific to the underlying solver, or null if there has
    // been no call to Solve() or it threw an exception.
    get Solution() {
        return this.solution;
    }
}
/* const */ SolverShell.FixedVarWeight = 1000000000;
//# sourceMappingURL=SolverShell.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/UniformOneDimensionalSolver.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UniformOneDimensionalSolver: () => (/* binding */ UniformOneDimensionalSolver)
/* harmony export */ });
/* harmony import */ var _layout_layered_CycleRemoval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/layered/CycleRemoval.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _SolverShell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/SolverShell.js");
/* harmony import */ var _UniformSolverVar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/UniformSolverVar.js");





class UniformOneDimensionalSolver {
    // desired variable separation
    constructor(variableSeparation) {
        this.idealPositions = new Map();
        this.varList = new Array();
        this.constraints = new Set();
        this.solverShell = new _SolverShell__WEBPACK_IMPORTED_MODULE_3__.SolverShell();
        this.boundsToInt = new Map();
        this.varSepartion = variableSeparation;
    }
    //        delegate Array<NudgerConstraint> Edges(int i);
    //
    //        delegate int End(NudgerConstraint constraint);
    //        Edges outEdgesDel;
    //        Edges inEdgesDel;
    //        End sourceDelegate;
    //        End targetDelegate;
    //        Supremum minDel;
    //        Supremum maxDel;
    SetLowBound(bound, id) {
        const v = this.Var(id);
        v.LowBound = Math.max(bound, v.LowBound);
    }
    Var(id) {
        return this.varList[id];
    }
    SetUpperBound(id, bound) {
        const v = this.Var(id);
        v.UpperBound = Math.min(bound, v.UpperBound);
    }
    Solve() {
        this.SolveByRegularSolver();
    }
    SolveByRegularSolver() {
        this.CreateVariablesForBounds();
        for (let i = 0; i < this.varList.length; i++) {
            const v = this.varList[i];
            if (v.IsFixed) {
                this.solverShell.AddFixedVariable(i, v.Position);
            }
            else {
                this.solverShell.AddVariableWithIdealPositionNN(i, this.idealPositions.get(i));
                if (v.LowBound !== Number.NEGATIVE_INFINITY) {
                    this.constraints.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__.IntPair(this.GetBoundId(v.LowBound), i));
                }
                if (v.UpperBound !== Number.POSITIVE_INFINITY) {
                    this.constraints.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__.IntPair(i, this.GetBoundId(v.UpperBound)));
                }
            }
        }
        this.CreateGraphAndRemoveCycles();
        for (const edge of this.graph.edges) {
            let w = 0;
            if (edge.x < this.varList.length) {
                w += this.varList[edge.x].Width;
            }
            if (edge.y < this.varList.length) {
                w += this.varList[edge.y].Width;
            }
            w /= 2;
            this.solverShell.AddLeftRightSeparationConstraintNNN(edge.x, edge.y, this.varSepartion + w);
        }
        this.solverShell.Solve();
        for (let i = 0; i < this.varList.length; i++) {
            this.varList[i].Position = this.solverShell.GetVariableResolvedPosition(i);
        }
    }
    GetBoundId(bound) {
        return this.boundsToInt.get(bound);
    }
    CreateVariablesForBounds() {
        for (const v of this.varList) {
            if (v.IsFixed) {
                continue;
            }
            if (v.LowBound !== Number.NEGATIVE_INFINITY) {
                this.RegisterBoundVar(v.LowBound);
            }
            if (v.UpperBound !== Number.POSITIVE_INFINITY) {
                this.RegisterBoundVar(v.UpperBound);
            }
        }
    }
    RegisterBoundVar(bound) {
        if (!this.boundsToInt.has(bound)) {
            const varIndex = this.varList.length + this.boundsToInt.size;
            this.boundsToInt.set(bound, varIndex);
            this.solverShell.AddFixedVariable(varIndex, bound);
        }
    }
    CreateGraphAndRemoveCycles() {
        // edges in the graph go from a smaller value to a bigger value
        this.graph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_1__.mkGraphOnEdgesN)(Array.from(this.constraints), this.varList.length + this.boundsToInt.size);
        // removing cycles
        const feedbackSet = _layout_layered_CycleRemoval__WEBPACK_IMPORTED_MODULE_0__.CycleRemoval.getFeedbackSet(this.graph);
        if (feedbackSet != null) {
            for (const edge of feedbackSet) {
                this.graph.removeEdge(edge);
            }
        }
    }
    GetVariablePosition(id) {
        return this.varList[id].Position;
    }
    AddConstraint(i, j) {
        this.constraints.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_2__.IntPair(i, j));
    }
    AddVariableNNNN(id, currentPosition, idealPosition, width) {
        this.idealPositions.set(id, idealPosition);
        this.AddVariableNNBN(id, currentPosition, false, width);
    }
    AddFixedVariable(id, position) {
        this.AddVariableNNBN(id, position, true, 0);
        // 0 for width
    }
    AddVariableNNBN(id, position, isFixed, width) {
        /*Assert.assert(id === this.varList.length)*/
        //new UniformSolverVar { IsFixed = isFixed, Position = position, Width=width
        const v = new _UniformSolverVar__WEBPACK_IMPORTED_MODULE_4__.UniformSolverVar();
        v.Position = position;
        v.IsFixed = isFixed;
        v.Width = width;
        this.varList.push(v);
    }
}
//# sourceMappingURL=UniformOneDimensionalSolver.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/UniformSolverVar.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UniformSolverVar: () => (/* binding */ UniformSolverVar)
/* harmony export */ });
class UniformSolverVar {
    constructor() {
        this.lowBound = Number.NEGATIVE_INFINITY;
        this.upperBound = Number.POSITIVE_INFINITY;
    }
    get Position() {
        return this.position;
    }
    set Position(value) {
        if (value < this.lowBound) {
            this.position = this.lowBound;
        }
        else if (value > this.upperBound) {
            this.position = this.upperBound;
        }
        else {
            this.position = value;
        }
    }
    get LowBound() {
        return this.lowBound;
    }
    set LowBound(value) {
        /*Assert.assert(value <= this.upperBound)*/
        this.lowBound = value;
    }
    get UpperBound() {
        return this.upperBound;
    }
    set UpperBound(value) {
        /*Assert.assert(value >= this.LowBound)*/
        this.upperBound = value;
    }
    toString() {
        return this.lowBound + (' ' + (this.Position + (' ' + this.upperBound)));
    }
}
//# sourceMappingURL=UniformSolverVar.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/Variable.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NeighborAndWeight: () => (/* binding */ NeighborAndWeight),
/* harmony export */   Variable: () => (/* binding */ Variable)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");


// MSAGL class for Variables for Projection Solver.
class NeighborAndWeight {
    constructor(neighbor, weight) {
        this.Neighbor = neighbor;
        this.Weight = weight;
    }
}
// A Variable is essentially a wrapper around a node, containing the node's initial and
// current (Actual) positions along the current axis and a collection of Constraints.
class Variable {
    // The derivative value - essentially the weighted difference in position.
    get DfDv() {
        return (2 * (this.Weight * (this.ActualPos - this.DesiredPos))) / this.Scale;
    }
    constructor(ordinal, userData, desiredPos, weight, scale) {
        this.ActiveConstraintCount = 0;
        if (weight <= 0) {
            throw new Error('weight');
        }
        if (scale <= 0) {
            throw new Error('scale');
        }
        let check = desiredPos * weight;
        if (!Number.isFinite(check) || Number.isNaN(check)) {
            throw new Error('desiredPos');
        }
        check = desiredPos * scale;
        if (!Number.isFinite(check) || Number.isNaN(check)) {
            throw new Error('desiredPos');
        }
        this.Ordinal = ordinal;
        this.UserData = userData;
        this.DesiredPos = desiredPos;
        this.Weight = weight;
        this.Scale = scale;
        this.OffsetInBlock = 0;
        this.ActualPos = this.DesiredPos;
    }
    Reinitialize() {
        // // Called by Qpsc or equivalence-constraint-regapping initial block restructuring.
        this.ActiveConstraintCount = 0;
        this.OffsetInBlock = 0.0;
        // If we are in Qpsc, this simply repeats (in the opposite direction) what
        // Qpsc.VariablesComplete did after (possibly) scaling.  If we're not in Qpsc,
        // then we've reset all the blocks because we could not incrementally re-Solve
        // due to changes to equality constraints, so this restores the initial state.
        this.ActualPos = this.DesiredPos;
    }
    AddNeighbor(neighbor, weight) {
        if (this.Neighbors == null) {
            this.Neighbors = new Array();
        }
        this.Neighbors.push(new NeighborAndWeight(neighbor, weight));
    }
    // Gets a string representation of the Variable; calls UserData.ToString as part of this.
    // <returns>A string representation of the variable.</returns>
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0} {1:F5} ({2:F5}) {3:F5} {4:F5}', this.Name, this.ActualPos, this.DesiredPos, this.Weight, this.Scale);
    }
    // Gets the string representation of UserData.
    // <returns>A string representation of Node.Object.</returns>
    get Name() {
        return this.UserData == null ? '-0-' : this.UserData.toString();
    }
    SetConstraints(leftConstraints, rightConstraints) {
        this.LeftConstraints = leftConstraints;
        this.RightConstraints = rightConstraints;
    }
    // Compare the Variables by their ordinals, in ascending order (this === lhs, other === rhs).
    // The object being compared to.
    // <returns>-1 if this.Ordinal is "less"; +1 if this.Ordinal is "greater"; 0 if this.Ordinal
    //         and rhs are equal.</returns>
    CompareTo(other) {
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(this.Ordinal, other.Ordinal);
    }
}
//# sourceMappingURL=Variable.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/math/projectionSolver/ViolationCache.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ViolationCache: () => (/* binding */ ViolationCache)
/* harmony export */ });
// The ViolationCache stores the top N maximum violations initially, allowing
// a reduction in the number of times we do a full search of all constraints.
// (It is not guaranteed to retain the max-N violations strictly after the first
// block is processed following a cache fill, but the approximation is sufficient
// to provide significant benefit).
class ViolationCache {
    get IsFull() {
        return this.numConstraints === ViolationCache.MaxConstraints;
    }
    Clear() {
        this.LowViolation = 0;
        this.numConstraints = 0;
        if (!this.constraints) {
            this.constraints = new Array(ViolationCache.MaxConstraints);
        }
    }
    FilterBlock(blockToFilter) {
        // Note: The cache does not try to retain strict accordance with highest violation.
        // Doing so lowers the hit rate, probably because if LastModifiedBlock has enough variables,
        // then it has enough high violations to flush all other blocks out of the cache, and
        // thus the next call to FilterBlock removes all for the current block (which per the following
        // paragraph results in calling SearchAllConstraints).  As it turns out, it doesn't
        // really matter what order we process the constraints in, other than the perf benefit of
        // doing the largest violations first, so using the max violation in LastModifiedBlock in this
        // situation seems to be good enough to win the tradeoff.
        //
        // If it becomes necessary to maintain strict "cache always contains the highest violations"
        // compliance, then we would have to return false if the filtering removed all elements of
        // the cache, because then we wouldn't know if there were any non-blockToFilter-related constraints
        // with a higher violation (currently we return true in that case because it is good enough to know
        // there is a good chance that this is true).  Also, SearchViolationCache would need a verification in
        // at least VERIFY mode to verify there are no higher violations in allConstraints.
        // Iterate in reverse to remove constraints belonging to LastModifiedBlock.
        // Note:  Enumerators and .Where are not used because they are much slower.
        this.LowViolation = Number.MAX_VALUE;
        const fRet = this.numConstraints > 0;
        for (let ii = this.numConstraints - 1; ii >= 0; ii--) {
            const constraint = this.constraints[ii];
            // Also remove any constraint that may have been activated by MergeBlocks or marked unsatisfiable
            // by Block.Expand.
            if (constraint.Left.Block === blockToFilter ||
                constraint.Right.Block === blockToFilter ||
                constraint.IsActive ||
                constraint.IsUnsatisfiable) {
                // If there are any items after this one, then they are ones we want to keep,
                // so swap in the last one in the array before decrementing the count.
                if (ii < this.numConstraints - 1) {
                    this.constraints[ii] = this.constraints[this.numConstraints - 1];
                }
                this.numConstraints--;
            }
            else {
                const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);
                /*Assert.assert(
                  constraint.Violation === violation,
                  'LeftConstraints: constraint.Violation must === violation',
                )*/
                if (violation < this.LowViolation) {
                    this.LowViolation = violation;
                }
            }
        }
        if (0 === this.numConstraints) {
            this.LowViolation = 0;
        }
        return fRet;
    }
    // Find the highest constraint with a greater violation than targetViolation.
    FindIfGreater(targetViolation) {
        let maxViolatedConstraint = null;
        for (let ii = 0; ii < this.numConstraints; ii++) {
            const constraint = this.constraints[ii];
            const violation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);
            /*Assert.assert(
              constraint.Violation === violation,
              'constraint.Violation must === violation',
            )*/
            if (violation > targetViolation) {
                targetViolation = violation;
                maxViolatedConstraint = constraint;
            }
        }
        // Remains null if none was found.
        return maxViolatedConstraint;
    }
    Insert(constraintToInsert, insertViolation) {
        // This should be checked by the caller (instead of here, for perf reasons).
        /*Assert.assert(
          constraintToInsert.Violation > this.LowViolation,
          'constraintToInsert.Violation must be > LowViolation',
        )*/
        /*Assert.assert(
          constraintToInsert.Violation === insertViolation,
          'constraintToInsert.Violation must === insertViolation',
        )*/
        let indexOfLowestViolation = 0;
        let lowViolation = insertViolation;
        let nextLowViolation = insertViolation;
        for (let ii = 0; ii < this.numConstraints; ii++) {
            const constraint = this.constraints[ii];
            const cacheViolation = constraint.Left.ActualPos * constraint.Left.Scale + (constraint.Gap - constraint.Right.ActualPos * constraint.Right.Scale);
            /*Assert.assert(
              constraint.Violation === cacheViolation,
              'constraint.Violation must === cacheViolation',
            )*/
            if (cacheViolation < lowViolation) {
                // If we don't replace an existing block pair, then we'll replace the lowest
                // violation in the cache, so will need to know the next-lowest violation.
                nextLowViolation = lowViolation;
                indexOfLowestViolation = ii;
                lowViolation = cacheViolation;
            }
            else if (cacheViolation < nextLowViolation) {
                nextLowViolation = cacheViolation;
            }
        }
        // endfor each constraint
        // If the cache isn't full yet, add the new one, else replace the lowest violation in the list.
        if (!this.IsFull) {
            // Add to the cache.
            this.constraints[this.numConstraints++] = constraintToInsert;
            if (this.IsFull) {
                this.LowViolation = lowViolation;
            }
        }
        else {
            // Replace in the cache.
            this.constraints[indexOfLowestViolation] = constraintToInsert;
            this.LowViolation = nextLowViolation;
        }
    }
}
// Must be >= 2 for Insert() dblNextLowVio logic; > 20 seems to yield little increase in hits.
ViolationCache.MaxConstraints = 20;
//# sourceMappingURL=ViolationCache.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/BundlingSettings.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BundlingSettings: () => (/* binding */ BundlingSettings)
/* harmony export */ });
class BundlingSettings {
    constructor() {
        this.capacityOverflowCoefficient = BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier;
        this.RotateBundles = false;
        // the upper bound of the virtual node radius
        this.MaxHubRadius = 50;
        // the lower bound of the virtual node radius
        this.MinHubRadius = 0.1;
        this.CreateUnderlyingPolyline = false;
        this.pathLengthImportance = BundlingSettings.DefaultPathLengthImportance;
        this.inkImportance = BundlingSettings.DefaultInkImportance;
        this.edgeSeparation = BundlingSettings.DefaultEdgeSeparation;
        /** this could be different from bundlingSetting.EdgeSeparation
         *    and could be a negative number
         */
        this._edgeWidthShrinkCoeff = 1;
        this.useCubicBezierSegmentsInsideOfHubs = false;
        this.angleThreshold = (Math.PI / 180) * 45;
        this.hubRepulsionImportance = 100;
        this.bundleRepulsionImportance = 100;
        this.minimalRatioOfGoodCdtEdges = 0.9;
        this.highestQuality = true;
        // if set to true then the edges will be routed one on top of each other with no gap inside of a bundle
        this.KeepOverlaps = false;
        // calculates the routes that just follow the visibility graph
        this.StopAfterShortestPaths = false;
    }
    toJSON() {
        const ret = {};
        if (this.capacityOverflowCoefficient != BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier)
            ret.capacityOverflowCoefficient = this.capacityOverflowCoefficient;
        if (this.RotateBundles)
            ret.RotateBundles = this.RotateBundles;
        if (this.MaxHubRadius != 50)
            ret.MaxHubRadius = this.MaxHubRadius;
        if (this.MinHubRadius != 0.1)
            ret.MinHubRadius = this.MinHubRadius;
        if (this.CreateUnderlyingPolyline)
            ret.CreateUnderlyingPolyline = this.CreateUnderlyingPolyline;
        if (this.pathLengthImportance != BundlingSettings.DefaultPathLengthImportance)
            ret.pathLengthImportance = this.pathLengthImportance;
        if (this.inkImportance != BundlingSettings.DefaultInkImportance)
            ret.inkImportance = this.inkImportance;
        if (this.edgeSeparation != BundlingSettings.DefaultEdgeSeparation)
            ret.edgeSeparation = this.edgeSeparation;
        if (this._edgeWidthShrinkCoeff != 1)
            ret._edgeWidthShrinkCoeff = this._edgeWidthShrinkCoeff;
        if (this.useCubicBezierSegmentsInsideOfHubs)
            ret.useCubicBezierSegmentsInsideOfHubs = this.useCubicBezierSegmentsInsideOfHubs;
        if (this.angleThreshold != (Math.PI / 180) * 45)
            ret.angleThreshold = this.angleThreshold;
        if (this.hubRepulsionImportance != 100)
            ret.hubRepulsionImportance = this.hubRepulsionImportance;
        if (this.bundleRepulsionImportance != 100)
            ret.bundleRepulsionImportance = this.bundleRepulsionImportance;
        if (this.minimalRatioOfGoodCdtEdges != 0.9)
            ret.minimalRatioOfGoodCdtEdges = this.minimalRatioOfGoodCdtEdges;
        if (!this.highestQuality)
            ret.highestQuality = this.highestQuality;
        if (this.KeepOverlaps)
            ret.KeepOverlaps = this.KeepOverlaps;
        if (this.StopAfterShortestPaths)
            ret.StopAfterShortestPaths = this.StopAfterShortestPaths;
        return ret;
    }
    static createFromJSON(s) {
        const r = new BundlingSettings();
        if (s.capacityOverflowCoefficient)
            r.capacityOverflowCoefficient = s.capacityOverflowCoefficient;
        if (s.RotateBundles)
            r.RotateBundles = s.RotateBundles;
        if (s.MaxHubRadius)
            r.MaxHubRadius = s.MaxHubRadius;
        if (s.MinHubRadius)
            r.MinHubRadius = s.MinHubRadius;
        if (s.CreateUnderlyingPolyline)
            r.CreateUnderlyingPolyline = s.CreateUnderlyingPolyline;
        if (s.pathLengthImportance)
            r.pathLengthImportance = s.pathLengthImportance;
        if (s.inkImportance)
            r.inkImportance = s.inkImportance;
        if (s.edgeSeparation)
            r.edgeSeparation = s.edgeSeparation;
        if (s._edgeWidthShrinkCoeff)
            r._edgeWidthShrinkCoeff = s._edgeWidthShrinkCoeff;
        if (s.useCubicBezierSegmentsInsideOfHubs)
            r.useCubicBezierSegmentsInsideOfHubs = s.useCubicBezierSegmentsInsideOfHubs;
        if (s.angleThreshold)
            r.angleThreshold = s.angleThreshold;
        if (s.hubRepulsionImportance)
            r.hubRepulsionImportance = s.hubRepulsionImportance;
        if (s.bundleRepulsionImportance)
            r.bundleRepulsionImportance = s.bundleRepulsionImportance;
        if (s.minimalRatioOfGoodCdtEdges)
            r.minimalRatioOfGoodCdtEdges = s.minimalRatioOfGoodCdtEdges;
        if (s.highestQuality)
            r.HighestQuality = s.highestQuality;
        if (s.KeepOverlaps)
            r.KeepOverlaps = s.KeepOverlaps;
        if (s.StopAfterShortestPaths)
            r.StopAfterShortestPaths = s.StopAfterShortestPaths;
        return r;
    }
    // this number is muliplied by the overflow penalty cost and by the sum of the LengthImportanceCoefficient
    // and InkImportanceCoefficient, and added to the routing price
    get CapacityOverflowCoefficient() {
        return this.capacityOverflowCoefficient;
    }
    set CapacityOverflowCoefficient(value) {
        this.capacityOverflowCoefficient = value;
    }
    // the importance of path lengths coefficient
    get PathLengthImportance() {
        return this.pathLengthImportance;
    }
    set PathLengthImportance(value) {
        this.pathLengthImportance = value;
    }
    get InkImportance() {
        return this.inkImportance;
    }
    set InkImportance(value) {
        this.inkImportance = value;
    }
    /** Separation between the neighbor edges within a bundle */
    get EdgeSeparation() {
        return this.edgeSeparation;
    }
    set EdgeSeparation(value) {
        this.edgeSeparation = value;
    }
    get edgeWidthShrinkCoeff() {
        return this._edgeWidthShrinkCoeff;
    }
    set edgeWidthShrinkCoeff(value) {
        this._edgeWidthShrinkCoeff = value;
    }
    ActualEdgeWidth(e, coeff = this.edgeWidthShrinkCoeff) {
        return coeff * (this.edgeSeparation + e.lineWidth);
    }
    // if is set to true will be using Cubic Bezie Segments inside of hubs, otherwise will be using Biarcs
    get UseCubicBezierSegmentsInsideOfHubs() {
        return this.useCubicBezierSegmentsInsideOfHubs;
    }
    set UseCubicBezierSegmentsInsideOfHubs(value) {
        this.useCubicBezierSegmentsInsideOfHubs = value;
    }
    // 45 degrees;
    // min angle for gluing edges
    get AngleThreshold() {
        return this.angleThreshold;
    }
    set AngleThreshold(value) {
        this.angleThreshold = value;
    }
    // the importance of hub repulsion coefficient
    get HubRepulsionImportance() {
        return this.hubRepulsionImportance;
    }
    set HubRepulsionImportance(value) {
        this.hubRepulsionImportance = value;
    }
    // the importance of bundle repulsion coefficient
    get BundleRepulsionImportance() {
        return this.bundleRepulsionImportance;
    }
    set BundleRepulsionImportance(value) {
        this.bundleRepulsionImportance = value;
    }
    // minimal ration of cdt edges with satisfied capacity needed to perform bundling
    // (otherwise bundling will not be executed)
    get MinimalRatioOfGoodCdtEdges() {
        return this.minimalRatioOfGoodCdtEdges;
    }
    set MinimalRatioOfGoodCdtEdges(value) {
        this.minimalRatioOfGoodCdtEdges = value;
    }
    // speed vs quality of the drawing
    get HighestQuality() {
        return this.highestQuality;
    }
    set HighestQuality(value) {
        this.highestQuality = value;
    }
}
// the default value of CapacityOverflowCoefficient
BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier = 1000;
// the default path lenght importance coefficient
BundlingSettings.DefaultPathLengthImportance = 500;
// the default ink importance
BundlingSettings.DefaultInkImportance = 0.01;
/** default edge separation */
BundlingSettings.DefaultEdgeSeparation = 0.5;
//# sourceMappingURL=BundlingSettings.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ClusterBoundaryPort.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClusterBoundaryPort: () => (/* binding */ ClusterBoundaryPort)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/relativeFloatingPort.js");


class ClusterBoundaryPort extends _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_1__.RelativeFloatingPort {
    get LoosePolyline() {
        return this.loosePolyline;
    }
    set LoosePolyline(value) {
        this.loosePolyline = value;
    }
    // constructor
    constructor(curveDelegate, centerDelegate, locationOffset = new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0)) {
        super(curveDelegate, centerDelegate, locationOffset);
    }
    // constructor
    static mk(curveDelegate, centerDelegate) {
        return new ClusterBoundaryPort(curveDelegate, centerDelegate);
    }
}
//# sourceMappingURL=ClusterBoundaryPort.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cdt: () => (/* binding */ Cdt),
/* harmony export */   createCDTOnPolylineRectNode: () => (/* binding */ createCDTOnPolylineRectNode)
/* harmony export */ });
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _CdtEdge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtEdge.js");
/* harmony import */ var _CdtSite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtSite.js");
/* harmony import */ var _CdtSweeper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtSweeper.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/*
Following "Sweep-line algorithm for constrained Delaunay triangulation", by Domiter and Zalik
*/
//triangulates the space between point, line segment and polygons of the Delaunay fashion









class Cdt extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_4__.Algorithm {
    // constructor
    constructor(isolatedSites, obstacles, isolatedSegments) {
        super(null);
        this.isolatedSites = [];
        this.obstacles = [];
        this.PointsToSites = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_3__.PointMap();
        this.simplifyObstacles = true;
        this.rectangleNodeOnTriangles = null;
        this.isolatedSites = isolatedSites;
        this.obstacles = obstacles;
        this.isolatedSegments = isolatedSegments;
    }
    // constructor
    static constructor_(isolatedSitesWithObj) {
        const r = new Cdt(null, null, null);
        r.isolatedSitesWithObject = isolatedSitesWithObj;
        return r;
    }
    FillAllInputSites() {
        // for now suppose that the data is correct: no isolatedSites coincide with obstacles or isolatedSegments, obstacles are mutually disjoint, etc
        if (this.isolatedSitesWithObject != null) {
            for (const tuple of this.isolatedSitesWithObject) {
                this.AddSite(tuple[0], tuple[1]);
            }
        }
        if (this.isolatedSites != null) {
            for (const isolatedSite of this.isolatedSites) {
                this.AddSite(isolatedSite, null);
            }
        }
        if (this.obstacles != null) {
            for (const poly of this.obstacles) {
                this.AddPolylineToAllInputSites(poly);
            }
        }
        if (this.isolatedSegments != null) {
            for (const isolatedSegment of this.isolatedSegments) {
                this.AddConstrainedEdge(isolatedSegment.A, isolatedSegment.B, null);
            }
        }
        this.AddP1AndP2();
        this.allInputSites = Array.from(this.PointsToSites.values());
    }
    AddSite(point, relatedObject) {
        let site;
        if ((site = this.PointsToSites.get(point))) {
            site.Owner = relatedObject;
            // set the owner anyway
        }
        else {
            site = _CdtSite__WEBPACK_IMPORTED_MODULE_6__.CdtSite.mkSO(point, relatedObject);
            this.PointsToSites.set(point, site);
        }
        return site;
    }
    AddP1AndP2() {
        const box = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_2__.Rectangle.mkEmpty();
        for (const site of this.PointsToSites.keys()) {
            box.add(site);
        }
        const delx = 10;
        const dely = 10;
        this.P1 = new _CdtSite__WEBPACK_IMPORTED_MODULE_6__.CdtSite(box.leftBottom.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(-delx, -dely)));
        this.P2 = new _CdtSite__WEBPACK_IMPORTED_MODULE_6__.CdtSite(box.rightBottom.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(delx, -dely)));
    }
    AddPolylineToAllInputSites(poly) {
        if (this.simplifyObstacles) {
            for (let p = poly.startPoint; p != null;) {
                const edgeStart = p.point;
                p = p.next;
                if (!p)
                    break;
                while (p.next && _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientation(edgeStart, p.point, p.next.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Collinear) {
                    p = p.next;
                }
                this.AddConstrainedEdge(edgeStart, p.point, poly);
            }
        }
        else {
            for (let pp = poly.startPoint; pp.next != null; pp = pp.next) {
                this.AddConstrainedEdge(pp.point, pp.next.point, poly);
            }
        }
        if (poly.closed) {
            this.AddConstrainedEdge(poly.endPoint.point, poly.startPoint.point, poly);
        }
    }
    AddConstrainedEdge(a, b, poly) {
        const ab = Cdt.AbovePP(a, b);
        /*Assert.assert(ab !== 0)*/
        let upperPoint;
        let lowerPoint;
        if (ab > 0) {
            // a is above b
            upperPoint = this.AddSite(a, poly);
            lowerPoint = this.AddSite(b, poly);
        }
        else {
            /*Assert.assert(ab < 0)*/
            upperPoint = this.AddSite(b, poly);
            lowerPoint = this.AddSite(a, poly);
        }
        const edge = Cdt.CreateEdgeOnOrderedCouple(upperPoint, lowerPoint);
        edge.constrained = true;
        /*Assert.assert(this.EdgeIsCorrect(edge))*/
    }
    static GetOrCreateEdge(a, b) {
        if (Cdt.AboveCC(a, b) === 1) {
            const e = a.EdgeBetweenUpperSiteAndLowerSite(b);
            if (e != null) {
                return e;
            }
            return Cdt.CreateEdgeOnOrderedCouple(a, b);
        }
        else {
            const e = b.EdgeBetweenUpperSiteAndLowerSite(a);
            if (e != null) {
                return e;
            }
            return Cdt.CreateEdgeOnOrderedCouple(b, a);
        }
    }
    static CreateEdgeOnOrderedCouple(upperPoint, lowerPoint) {
        /*Assert.assert(Cdt.AboveCC(upperPoint, lowerPoint) === 1)*/
        return new _CdtEdge__WEBPACK_IMPORTED_MODULE_5__.CdtEdge(upperPoint, lowerPoint);
    }
    GetTriangles() {
        return this.sweeper.triangles;
    }
    // Executes the actual algorithm.
    run() {
        this.Initialization();
        this.SweepAndFinalize();
    }
    SweepAndFinalize() {
        this.sweeper = new _CdtSweeper__WEBPACK_IMPORTED_MODULE_7__.CdtSweeper(this.allInputSites, this.P1, this.P2, Cdt.GetOrCreateEdge);
        this.sweeper.run();
        this.cleanRemovedEdges();
    }
    cleanRemovedEdges() {
        for (const site of this.PointsToSites.values()) {
            site.cleanRemovedEdges();
        }
    }
    Initialization() {
        this.FillAllInputSites();
        this.allInputSites.sort(Cdt.OnComparison);
    }
    static OnComparison(a, b) {
        return Cdt.AboveCC(a, b);
    }
    // compare first y then -x coordinates
    static AbovePP(a, b) {
        let del = a.y - b.y;
        if (del > 0) {
            return 1;
        }
        if (del < 0) {
            return -1;
        }
        del = a.x - b.x;
        // for a horizontal edge return the point with the smaller X
        return del > 0 ? -1 : del < 0 ? 1 : 0;
    }
    // compare first y then -x coordinates
    static AboveCC(a, b) {
        return Cdt.AbovePP(a.point, b.point);
    }
    RestoreEdgeCapacities() {
        for (const site of this.allInputSites) {
            for (const e of site.Edges) {
                if (!e.constrained) {
                    e.ResidualCapacity = e.Capacity;
                }
            }
        }
    }
    SetInEdges() {
        for (const site of this.PointsToSites.values()) {
            for (const e of site.Edges) {
                const oSite = e.lowerSite;
                /*Assert.assert(oSite !== site)*/
                oSite.AddInEdge(e);
            }
        }
    }
    FindSite(point) {
        return this.PointsToSites.get(point);
    }
    static PointIsInsideOfTriangle(point, t) {
        for (let i = 0; i < 3; i++) {
            const a = t.Sites.getItem(i).point;
            const b = t.Sites.getItem(i + 1).point;
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.signedDoubledTriangleArea(point, a, b) < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon * -1) {
                return false;
            }
        }
        return true;
    }
    getRectangleNodeOnTriangles() {
        if (this.rectangleNodeOnTriangles == null) {
            this.rectangleNodeOnTriangles = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_8__.CreateRectNodeOnArrayOfRectNodes)(Array.from(this.GetTriangles().values()).map((t) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_8__.mkRectangleNode)(t, t.BoundingBox())));
        }
        return this.rectangleNodeOnTriangles;
    }
}
function createCDTOnPolylineRectNode(polylineHierarchy) {
    const obstacles = Array.from(polylineHierarchy.GetAllLeaves());
    const rectangle = polylineHierarchy.irect;
    const del = rectangle.diagonal / 4;
    const nRect = rectangle.clone();
    nRect.pad(del);
    return getConstrainedDelaunayTriangulation(obstacles.concat([nRect.perimeter()]));
}
function getConstrainedDelaunayTriangulation(obstacles) {
    const constrainedDelaunayTriangulation = new Cdt(null, obstacles, null);
    constrainedDelaunayTriangulation.run();
    return constrainedDelaunayTriangulation;
}
//# sourceMappingURL=Cdt.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CdtEdge: () => (/* binding */ CdtEdge)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _Cdt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");


class CdtEdge {
    constructor(a, b) {
        // is an obstacle side, or a given segment
        this.constrained = false;
        // the amount of free space around the edge
        this.Capacity = 1000000;
        const above = _Cdt__WEBPACK_IMPORTED_MODULE_1__.Cdt.AbovePP(a.point, b.point);
        if (above === 1) {
            this.upperSite = a;
            this.lowerSite = b;
        }
        else {
            /*Assert.assert(above !== 0)*/
            this.lowerSite = a;
            this.upperSite = b;
        }
        this.upperSite.AddEdgeToSite(this);
    }
    get CcwTriangle() {
        return this.ccwTriangle;
    }
    set CcwTriangle(value) {
        /*Assert.assert(
          value == null  ||
            this.cwTriangle == null  ||
            value.OppositeSite(this) !== this.cwTriangle.OppositeSite(this),
        )*/
        this.ccwTriangle = value;
    }
    get CwTriangle() {
        return this.cwTriangle;
    }
    set CwTriangle(value) {
        /*Assert.assert(
          value == null  ||
            this.ccwTriangle == null  ||
            value.OppositeSite(this) !== this.ccwTriangle.OppositeSite(this),
        )*/
        this.cwTriangle = value;
    }
    // returns the trianlge on the edge opposite to the site
    GetOtherTriangle_c(p) {
        return this.cwTriangle.Contains(p) ? this.ccwTriangle : this.cwTriangle;
    }
    IsAdjacent(pi) {
        return pi === this.upperSite || pi === this.lowerSite;
    }
    GetOtherTriangle_T(triangle) {
        return this.ccwTriangle === triangle ? this.cwTriangle : this.ccwTriangle;
    }
    // A string that represents the current object.
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('({0},{1})', this.upperSite, this.lowerSite);
    }
    OtherSite(site) {
        /*Assert.assert(this.IsAdjacent(site))*/
        return this.upperSite === site ? this.lowerSite : this.upperSite;
    }
}
//# sourceMappingURL=CdtEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtFrontElement.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CdtFrontElement: () => (/* binding */ CdtFrontElement)
/* harmony export */ });
class CdtFrontElement {
    get x() {
        return this.LeftSite.point.x;
    }
    constructor(leftSite, edge) {
        /*Assert.assert(
          (edge.upperSite.point.x !== edge.lowerSite.point.x &&
            edge.upperSite.point.x < edge.lowerSite.point.x &&
            leftSite === edge.upperSite) ||
            (edge.upperSite.point.x > edge.lowerSite.point.x &&
              leftSite === edge.lowerSite),
        )*/
        this.RightSite = edge.upperSite === leftSite ? edge.lowerSite : edge.upperSite;
        this.LeftSite = leftSite;
        this.Edge = edge;
    }
    toString() {
        return '(' + this.LeftSite.toString() + ', ' + this.Edge.toString() + ',' + this.RightSite.toString() + ')';
    }
}
//# sourceMappingURL=CdtFrontElement.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtSite.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CdtSite: () => (/* binding */ CdtSite)
/* harmony export */ });
class CdtSite {
    cleanRemovedEdges() {
        for (const e of this.Edges) {
            if (e.CcwTriangle === null && e.CwTriangle === null) {
                this.Edges.splice(this.Edges.indexOf(e), 1);
            }
        }
    }
    constructor(isolatedSite) {
        // Object to which this site refers to.
        this.Owner = null;
        this.InEdges = new Array();
        this.point = isolatedSite;
    }
    static mkSO(isolatedSite, owner) {
        const s = new CdtSite(isolatedSite);
        s.Owner = owner;
        return s;
    }
    AddEdgeToSite(edge) {
        if (this.Edges == null) {
            this.Edges = new Array();
        }
        this.Edges.push(edge);
    }
    // #if TEST_MSAGL && TEST_MSAGL
    //         // Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    //         // A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    //         // <filterpriority>2</filterpriority>
    //         public override string ToString()
    //         {
    //             return Point.ToString();
    //         }
    // #endif
    EdgeBetweenUpperSiteAndLowerSite(b) {
        /*Assert.assert(Cdt.AboveCC(this, b) > 0)*/
        if (this.Edges != null) {
            for (const edge of this.Edges) {
                if (edge.lowerSite === b) {
                    return edge;
                }
            }
        }
        return null;
    }
    AddInEdge(e) {
        this.InEdges.push(e);
    }
    *Triangles() {
        // this function might not work correctly if InEdges are not set
        let edge;
        if (this.Edges != null && this.Edges.length > 0)
            edge = this.Edges[0];
        else if (this.InEdges != null && this.InEdges.length > 0)
            edge = this.InEdges[0];
        else
            return;
        //going counterclockwise around the site
        let e = edge;
        do {
            const t = e.upperSite === this ? e.CcwTriangle : e.CwTriangle;
            if (t == null) {
                e = null;
                break;
            }
            yield t;
            e = t.Edges.getItem(t.Edges.index(e) + 2);
        } while (e !== edge); //full circle
        if (e !== edge) {
            //we have not done the full circle, starting again with edge but now going clockwise around the site
            e = edge;
            do {
                const t = e.upperSite === this ? e.CwTriangle : e.CcwTriangle;
                if (t == null) {
                    break;
                }
                yield t;
                e = t.Edges.getItem(t.Edges.index(e) + 1);
            } while (true); // we will hit a null triangle for the convex hull border edge
        }
    }
    toString() {
        return this.point.toString();
    }
}
//# sourceMappingURL=CdtSite.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtSweeper.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CdtSweeper: () => (/* binding */ CdtSweeper),
/* harmony export */   InCircle: () => (/* binding */ InCircle)
/* harmony export */ });
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/debugCurve.js");
/* harmony import */ var _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/RealNumberSpan.js");
/* harmony import */ var _Cdt__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");
/* harmony import */ var _CdtFrontElement__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtFrontElement.js");
/* harmony import */ var _CdtTriangle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtTriangle.js");
/* harmony import */ var _PerimeterEdge__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/PerimeterEdge.js");













// this class builds the triangulation by a sweep with a horizontal line
class CdtSweeper extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_7__.Algorithm {
    constructor(listOfSites, p_1, p_2, createEdgeDelegate) {
        super(null);
        this.front = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_6__.RBTree((a, b) => a.x - b.x);
        this.triangles = new Set();
        this.listOfSites = listOfSites;
        if (this.listOfSites.length === 0) {
            return;
        }
        this.p_1 = p_1;
        this.p_2 = p_2;
        this.createEdgeDelegate = createEdgeDelegate;
        const firstTriangle = _CdtTriangle__WEBPACK_IMPORTED_MODULE_11__.CdtTriangle.mkSSSD(p_1, p_2, this.listOfSites[0], createEdgeDelegate);
        this.triangles.add(firstTriangle);
        this.front.insert(new _CdtFrontElement__WEBPACK_IMPORTED_MODULE_10__.CdtFrontElement(p_1, firstTriangle.Edges.getItem(2)));
        this.front.insert(new _CdtFrontElement__WEBPACK_IMPORTED_MODULE_10__.CdtFrontElement(this.listOfSites[0], firstTriangle.Edges.getItem(1)));
        //this.Show('./tmp/front.svg')
    }
    run() {
        if (this.listOfSites.length === 0) {
            return;
        }
        for (let i = 1; i < this.listOfSites.length; i++) {
            this.ProcessSite(this.listOfSites[i]);
        }
        this.FinalizeTriangulation();
        // #if TEST_MSAGL && TEST_MSAGL
        //             //TestTriangles();
        //             //ShowFront(triangles,null,null,null);
        // #endif
    }
    FinalizeTriangulation() {
        this.RemoveP1AndP2Triangles();
        if (this.triangles.size > 0)
            this.MakePerimeterConvex();
    }
    MakePerimeterConvex() {
        let firstPerimeterEdge = this.CreateDoubleLinkedListOfPerimeter();
        do {
            const concaveEdge = this.FindConcaveEdge(firstPerimeterEdge);
            if (concaveEdge == null)
                return;
            firstPerimeterEdge = this.ShortcutTwoListElements(concaveEdge);
        } while (true);
    }
    FindConcaveEdge(firstPerimeterEdge) {
        let a = firstPerimeterEdge;
        let b;
        do {
            b = a.Next;
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.getTriangleOrientation(a.Start.point, a.End.point, b.End.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Counterclockwise) {
                return a;
            }
            else
                a = b;
        } while (b !== firstPerimeterEdge);
        return null;
    }
    static FindPivot(firstPerimeterEdge) {
        // eslint-disable-next-line no-var
        let pivot = firstPerimeterEdge;
        let e = firstPerimeterEdge;
        do {
            e = e.Next;
            if (e.Start.point.x < pivot.Start.point.x || (e.Start.point.x === pivot.Start.point.x && e.Start.point.y < pivot.Start.point.y))
                pivot = e;
        } while (e !== firstPerimeterEdge);
        return pivot;
    }
    FindFirsePerimeterEdge() {
        for (const t of this.triangles) {
            for (const e of t.Edges) {
                if (e.GetOtherTriangle_T(t) == null)
                    return e;
            }
        }
        return null;
    }
    CreateDoubleLinkedListOfPerimeter() {
        const firstEdge = this.FindFirsePerimeterEdge();
        let edge = firstEdge;
        let listStart = null;
        let pe;
        let prevPe = null;
        const debugDC = new Array();
        do {
            pe = CdtSweeper.CreatePerimeterElementFromEdge(edge);
            debugDC.push(_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(pe.Start.point, pe.End.point));
            edge = CdtSweeper.FindNextEdgeOnPerimeter(edge);
            if (prevPe != null) {
                pe.Prev = prevPe;
                prevPe.Next = pe;
            }
            else {
                listStart = pe;
            }
            prevPe = pe;
        } while (edge !== firstEdge);
        listStart.Prev = pe;
        pe.Next = listStart;
        return listStart;
    }
    static FindNextEdgeOnPerimeter(e) {
        var _a;
        let t = (_a = e.CwTriangle) !== null && _a !== void 0 ? _a : e.CcwTriangle;
        e = t.Edges.getItem(t.Edges.index(e) + 2);
        while (e.CwTriangle != null && e.CcwTriangle != null) {
            t = e.GetOtherTriangle_T(t);
            e = t.Edges.getItem(t.Edges.index(e) + 2);
        }
        return e;
    }
    static CreatePerimeterElementFromEdge(edge) {
        const pe = new _PerimeterEdge__WEBPACK_IMPORTED_MODULE_12__.PerimeterEdge(edge);
        if (edge.CwTriangle != null) {
            pe.Start = edge.upperSite;
            pe.End = edge.lowerSite;
        }
        else {
            pe.End = edge.upperSite;
            pe.Start = edge.lowerSite;
        }
        return pe;
    }
    RemoveP1AndP2Triangles() {
        const trianglesToRemove = new Set();
        for (const t of this.triangles) {
            if (t.Sites.has(this.p_1) || t.Sites.has(this.p_2)) {
                trianglesToRemove.add(t);
            }
        }
        for (const t of trianglesToRemove) {
            CdtSweeper.RemoveTriangleWithEdges(this.triangles, t);
        }
    }
    static RemoveTriangleWithEdges(cdtTriangles, t) {
        cdtTriangles.delete(t);
        for (const e of t.Edges) {
            if (e.CwTriangle === t) {
                e.CwTriangle = null;
            }
            else {
                e.CcwTriangle = null;
            }
            if (e.CwTriangle == null && e.CcwTriangle == null) {
                removeFromArray(e.upperSite.Edges, e);
            }
        }
    }
    static RemoveTriangleButLeaveEdges(cdtTriangles, t) {
        cdtTriangles.delete(t);
        for (const e of t.Edges) {
            if (e.CwTriangle === t) {
                e.CwTriangle = null;
            }
            else {
                e.CcwTriangle = null;
            }
        }
    }
    ProcessSite(site) {
        this.PointEvent(site);
        for (let i = 0; i < site.Edges.length; i++) {
            //console.log('i', i)
            const edge = site.Edges[i];
            if (edge.constrained) {
                this.EdgeEvent(edge);
            }
        }
        //throw new Error()
        // TestThatFrontIsConnected();
    }
    // #if TEST_MSAGL && TEST_MSAGL
    // void TestThatFrontIsConnected() {
    //     CdtFrontElement p = null;
    //     foreach(var cdtFrontElement of front) {
    //         if (p != null)
    //             Assert.assert(p.RightSite === cdtFrontElement.LeftSite);
    //         p = cdtFrontElement;
    //     }
    // }
    // #endif
    EdgeEvent(edge) {
        /*Assert.assert(edge.Constrained)*/
        if (CdtSweeper.EdgeIsProcessed(edge)) {
            return;
        }
        this.traversingEdge = edge;
        this.runEdgeInserter();
    }
    static EdgeIsProcessed(edge) {
        return edge.CwTriangle != null || edge.CcwTriangle != null;
    }
    ShowFrontWithSite(site, redCurves = null) {
        const ls = new Array();
        if (site.Edges != null) {
            for (const e of site.Edges) {
                ls.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(200, 0.8, e.constrained ? 'Pink' : 'Brown', _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(e.upperSite.point, e.lowerSite.point)));
            }
        }
        ls.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(200, 1, 'Brown', _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_2__.Ellipse.mkFullEllipseNNP(0.5, 0.5, site.point)));
        for (const t of this.triangles) {
            for (let i = 0; i < 3; i++) {
                const e = t.Edges.getItem(i);
                ls.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(e.constrained ? 155 : 100, e.constrained ? 0.8 : 0.4, e.constrained ? 'Pink' : 'Navy', _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(e.upperSite.point, e.lowerSite.point)));
            }
        }
        if (redCurves != null)
            for (const c of redCurves) {
                ls.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(100, 0.5, 'Red', c));
            }
        for (const frontElement of this.front) {
            ls.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(100, 5.5, 'Green', _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(frontElement.Edge.upperSite.point, frontElement.Edge.lowerSite.point)));
        }
    }
    Show(fn) {
        CdtSweeper.ShowCdt(Array.from(this.triangles.values()), this.front, null, null, [], fn);
    }
    static ShowCdt(cdtTriangles, cdtFrontElements, redCurves, blueCurves, dc, fn) {
        let ls = new Array();
        if (redCurves != null) {
            for (const c of redCurves) {
                ls.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(200, 0.1, 'Red', c));
            }
        }
        if (blueCurves != null) {
            for (const c of blueCurves) {
                ls.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(200, 0.1, 'Blue', c));
            }
        }
        if (cdtFrontElements != null) {
            for (const frontElement of cdtFrontElements) {
                ls.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(200, 0.1, 'Green', _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(frontElement.Edge.upperSite.point, frontElement.Edge.lowerSite.point)));
            }
        }
        for (const t of cdtTriangles) {
            for (let i = 0; i < 3; i++) {
                const e = t.Edges.getItem(i);
                ls.push(CdtSweeper.GetDebugCurveOfCdtEdge(e));
            }
        }
        ls = ls.concat(dc);
        //   SvgDebugWriter.dumpDebugCurves(fn, ls)
    }
    static GetDebugCurveOfCdtEdge(e) {
        if (e.CcwTriangle == null || e.CwTriangle == null)
            return _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(255, 0.5, e.constrained ? 'Brown' : 'Black', _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(e.upperSite.point, e.lowerSite.point));
        return _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_1__.DebugCurve.mkDebugCurveTWCI(200, e.constrained ? 0.8 : 0.2, e.constrained ? 'Pink' : 'Navy', _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(e.upperSite.point, e.lowerSite.point));
    }
    PointEvent(pi) {
        const hittedFrontElementNode = this.ProjectToFront(pi);
        const t = { rightSite: null };
        const leftSite = hittedFrontElementNode.item.x + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon < pi.point.x
            ? this.MiddleCase(pi, hittedFrontElementNode, t)
            : this.LeftCase(pi, hittedFrontElementNode, t);
        let piNode = this.InsertSiteIntoFront(leftSite, pi, t.rightSite);
        this.TriangulateEmptySpaceToTheRight(piNode);
        piNode = CdtSweeper.FindNodeInFrontBySite(this.front, leftSite);
        this.TriangulateEmptySpaceToTheLeft(piNode);
    }
    // #if TEST_MSAGL && TEST_MSAGL
    // void TestTriangles() {
    //     var usedSites = new Set<CdtSite>();
    //     foreach(var t of triangles)
    //     usedSites.InsertRange(t.Sites);
    //     foreach(var triangle of triangles) {
    //         TestTriangle(triangle, usedSites);
    //     }
    // }
    // void TestTriangle(CdtTriangle triangle, Set < CdtSite > usedSites) {
    //     var tsites = triangle.Sites;
    //     foreach(var site of usedSites) {
    //         if (!tsites.Contains(site)) {
    //             if (!SeparatedByConstrainedEdge(triangle, site) && InCircle(site, tsites[0], tsites[1], tsites[2])) {
    //                 Array < ICurve > redCurves=new Array<ICurve>();
    //                 redCurves.push(new Ellipse(2, 2, site.point));
    //                 Array < ICurve > blueCurves = new Array<ICurve>();
    //                 blueCurves.push(Circumcircle(tsites[0].point, tsites[1].point, tsites[2].point));
    //                 ShowFront(triangles, front, redCurves, blueCurves);
    //             }
    //         }
    //     }
    // }
    //         static bool SeparatedByConstrainedEdge(CdtTriangle triangle, CdtSite site) {
    //     for (int i = 0; i < 3; i++)
    //     if (SeparatedByEdge(triangle, i, site))
    //         return true;
    //     return false;
    // }
    //         static bool SeparatedByEdge(CdtTriangle triangle, int i, CdtSite site) {
    //     var e = triangle.Edges[i];
    //     var s = triangle.Sites.getItem(i + 2);
    //     var a0 = ApproximateComparer.Sign(Point.SignedDoubledTriangleArea(s.point, e.upperSite.point, e.lowerSite.point));
    //     var a1 = ApproximateComparer.Sign(Point.SignedDoubledTriangleArea(site.point, e.upperSite.point, e.lowerSite.point));
    //     return a0 * a1 <= 0;
    // }
    // #endif
    LeftCase(pi, hittedFrontElementNode, t) {
        // left case
        //                if(db)ShowFrontWithSite(pi, LineSegment.mkPP(pi.point, hittedFrontElementNode.Item.Edge.upperSite.point), LineSegment.mkPP(pi.point, hittedFrontElementNode.Item.Edge.lowerSite.point));
        /*Assert.assert(closeDistEps(pi.point.x, hittedFrontElementNode.item.x))*/
        const hittedFrontElement = hittedFrontElementNode.item;
        this.InsertAndLegalizeTriangle(pi, hittedFrontElement);
        const prevToHitted = this.front.previous(hittedFrontElementNode);
        const leftSite = prevToHitted.item.LeftSite;
        t.rightSite = hittedFrontElementNode.item.RightSite;
        //                if(db)ShowFrontWithSite(pi, LineSegment.mkPP(pi.point, leftSite.point), LineSegment.mkPP(pi.point, prevToHitted.Item.RightSite.point));
        this.InsertAndLegalizeTriangle(pi, prevToHitted.item);
        this.front.deleteNodeInternal(prevToHitted);
        const d = this.front.remove(hittedFrontElement);
        /*Assert.assert(d != null)*/
        return leftSite;
    }
    MiddleCase(pi, hittedFrontElementNode, t) {
        //            if(db)
        //                ShowFrontWithSite(pi, LineSegment.mkPP(pi.point, hittedFrontElementNode.Item.Edge.upperSite.point), LineSegment.mkPP(pi.point, hittedFrontElementNode.Item.Edge.lowerSite.point));
        const leftSite = hittedFrontElementNode.item.LeftSite;
        t.rightSite = hittedFrontElementNode.item.RightSite;
        this.InsertAndLegalizeTriangle(pi, hittedFrontElementNode.item);
        this.front.deleteNodeInternal(hittedFrontElementNode);
        return leftSite;
    }
    TriangulateEmptySpaceToTheLeft(leftLegNode) {
        const peakSite = leftLegNode.item.RightSite;
        let previousNode = this.front.previous(leftLegNode);
        while (previousNode != null) {
            const prevElement = previousNode.item;
            const rp = prevElement.LeftSite;
            const r = prevElement.RightSite;
            if (r.point.sub(peakSite.point).dot(rp.point.sub(r.point)) < 0) {
                // see figures 9(a) and 9(b) of the paper
                leftLegNode = this.ShortcutTwoFrontElements(previousNode, leftLegNode);
                previousNode = this.front.previous(leftLegNode);
            }
            else {
                this.TryTriangulateBasinToTheLeft(leftLegNode);
                break;
            }
        }
    }
    ShortcutTwoListElements(a) {
        var _a;
        const b = a.Next;
        /*Assert.assert(a.End === b.Start)*/
        let t = _CdtTriangle__WEBPACK_IMPORTED_MODULE_11__.CdtTriangle.mkSSSEE(a.Start, a.End, b.End, a.Edge, b.Edge, this.createEdgeDelegate);
        this.triangles.add(t);
        const newEdge = t.Edges.getItem(2);
        /*Assert.assert(newEdge.IsAdjacent(a.Start) && newEdge.IsAdjacent(b.End))*/
        this.LegalizeEdge(a.Start, t.OppositeEdge(a.Start));
        t = (_a = newEdge.CcwTriangle) !== null && _a !== void 0 ? _a : newEdge.CwTriangle;
        this.LegalizeEdge(b.End, t.OppositeEdge(b.End));
        const c = new _PerimeterEdge__WEBPACK_IMPORTED_MODULE_12__.PerimeterEdge(newEdge);
        c.Start = a.Start;
        c.End = b.End;
        a.Prev.Next = c;
        c.Prev = a.Prev;
        c.Next = b.Next;
        b.Next.Prev = c;
        return c;
    }
    // aNode is to the left of bNode, and they are consecutive
    ShortcutTwoFrontElements(aNode, bNode) {
        var _a;
        const aElem = aNode.item;
        const bElem = bNode.item;
        /*Assert.assert(aElem.RightSite === bElem.LeftSite)*/
        let t = _CdtTriangle__WEBPACK_IMPORTED_MODULE_11__.CdtTriangle.mkSSSEED(aElem.LeftSite, aElem.RightSite, bElem.RightSite, aElem.Edge, bElem.Edge, this.createEdgeDelegate);
        this.triangles.add(t);
        this.front.deleteNodeInternal(aNode);
        // now bNode might b not valid anymore
        this.front.remove(bElem);
        const newEdge = t.Edges.getItem(2);
        /*Assert.assert(
          newEdge.IsAdjacent(aElem.LeftSite) && newEdge.IsAdjacent(bElem.RightSite),
        )*/
        this.LegalizeEdge(aElem.LeftSite, t.OppositeEdge(aElem.LeftSite));
        t = (_a = newEdge.CcwTriangle) !== null && _a !== void 0 ? _a : newEdge.CwTriangle;
        this.LegalizeEdge(bElem.RightSite, t.OppositeEdge(bElem.RightSite));
        return this.front.insert(new _CdtFrontElement__WEBPACK_IMPORTED_MODULE_10__.CdtFrontElement(aElem.LeftSite, newEdge));
    }
    TryTriangulateBasinToTheLeft(leftLegNode) {
        if (!CdtSweeper.DropsSharpEnoughToTheLeft(leftLegNode.item)) {
            return;
        }
        // ShowFrontWithSite(leftLegNode.Item.LeftSite);
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        stack.push(leftLegNode.item.LeftSite);
        while (true) {
            const site = stack.pop();
            leftLegNode = CdtSweeper.FindNodeInFrontBySite(this.front, site);
            const prev = this.front.previous(leftLegNode);
            if (prev == null) {
                return;
            }
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.getTriangleOrientation(prev.item.LeftSite.point, leftLegNode.item.LeftSite.point, leftLegNode.item.RightSite.point) ==
                _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Counterclockwise) {
                stack.push(prev.item.LeftSite);
                this.ShortcutTwoFrontElements(prev, leftLegNode);
                //      ShowFrontWithSite(site);
            }
            else if (leftLegNode.item.LeftSite.point.y > leftLegNode.item.RightSite.point.y) {
                stack.push(prev.item.LeftSite);
            }
            else {
                if (prev.item.LeftSite.point.y <= prev.item.RightSite.point.y) {
                    return;
                }
                stack.push(prev.item.LeftSite);
            }
        }
    }
    static DropsSharpEnoughToTheLeft(frontElement) {
        const edge = frontElement.Edge;
        if (frontElement.RightSite !== edge.upperSite) {
            return false;
        }
        const d = edge.lowerSite.point.sub(edge.upperSite.point);
        /*Assert.assert(d.x < 0 && d.y <= 0)*/
        return d.x >= 0.5 * d.y;
    }
    InsertSiteIntoFront(leftSite, pi, rightSite) {
        let rightEdge = null;
        let leftEdge = null;
        for (const edge of pi.Edges) {
            if (leftEdge == null && edge.lowerSite === leftSite) {
                leftEdge = edge;
            }
            if (rightEdge == null && edge.lowerSite === rightSite) {
                rightEdge = edge;
            }
            if (leftEdge != null && rightEdge != null) {
                break;
            }
        }
        /*Assert.assert(leftEdge != null && rightEdge != null)*/
        this.front.insert(new _CdtFrontElement__WEBPACK_IMPORTED_MODULE_10__.CdtFrontElement(leftSite, leftEdge));
        return this.front.insert(new _CdtFrontElement__WEBPACK_IMPORTED_MODULE_10__.CdtFrontElement(pi, rightEdge));
    }
    TriangulateEmptySpaceToTheRight(piNode) {
        const piSite = piNode.item.LeftSite;
        const piPoint = piSite.point;
        let piNext = this.front.next(piNode);
        while (piNext != null) {
            const frontElem = piNext.item;
            const r = frontElem.LeftSite;
            const rp = frontElem.RightSite;
            if (r.point.sub(piPoint).dot(rp.point.sub(r.point)) < 0) {
                // see figures 9(a) and 9(b) of the paper
                piNode = this.ShortcutTwoFrontElements(piNode, piNext);
                piNext = this.front.next(piNode);
            }
            else {
                this.TryTriangulateBasinToTheRight(piNode);
                break;
            }
        }
    }
    TryTriangulateBasinToTheRight(piNode) {
        if (!CdtSweeper.DropsSharpEnoughToTheRight(piNode.item)) {
            return;
        }
        // ShowFrontWithSite(piNode.Item.LeftSite);
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        stack.push(piNode.item.LeftSite);
        while (true) {
            const site = stack.pop();
            piNode = CdtSweeper.FindNodeInFrontBySite(this.front, site);
            const next = this.front.next(piNode);
            if (next == null) {
                return;
            }
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.getTriangleOrientation(piNode.item.LeftSite.point, piNode.item.RightSite.point, next.item.RightSite.point) ==
                _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Counterclockwise) {
                this.ShortcutTwoFrontElements(piNode, next);
                stack.push(site);
            }
            else if (piNode.item.LeftSite.point.y > piNode.item.RightSite.point.y) {
                stack.push(piNode.item.RightSite);
            }
            else {
                if (next.item.LeftSite.point.y >= next.item.RightSite.point.y) {
                    return;
                }
                stack.push(piNode.item.RightSite);
            }
        }
    }
    static DropsSharpEnoughToTheRight(frontElement) {
        const edge = frontElement.Edge;
        if (frontElement.LeftSite !== edge.upperSite) {
            return false;
        }
        const d = edge.lowerSite.point.sub(edge.upperSite.point);
        /*Assert.assert(d.x > 0 && d.y <= 0)*/
        return d.x <= -0.5 * d.y;
    }
    static FindNodeInFrontBySite(cdtFrontElements, piSite) {
        return cdtFrontElements.findLast((x) => x.LeftSite.point.x <= piSite.point.x);
    }
    InsertAndLegalizeTriangle(pi, frontElement) {
        var _a;
        if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.getTriangleOrientation(pi.point, frontElement.LeftSite.point, frontElement.RightSite.point) !== _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Collinear) {
            const tr = _CdtTriangle__WEBPACK_IMPORTED_MODULE_11__.CdtTriangle.mkSED(pi, frontElement.Edge, this.createEdgeDelegate);
            this.triangles.add(tr);
            this.LegalizeEdge(pi, tr.Edges.getItem(0));
        }
        else {
            // we need to split the triangle below the element of to two triangles and legalize the old edges
            // we also delete, that is forget, the frontElement.Edge
            const e = frontElement.Edge;
            removeFromArray(e.upperSite.Edges, e);
            let t = (_a = e.CcwTriangle) !== null && _a !== void 0 ? _a : e.CwTriangle;
            const oppositeSite = t.OppositeSite(e);
            CdtSweeper.RemoveTriangleButLeaveEdges(this.triangles, t);
            t = _CdtTriangle__WEBPACK_IMPORTED_MODULE_11__.CdtTriangle.mkSSSD(frontElement.LeftSite, oppositeSite, pi, this.createEdgeDelegate);
            const t1 = _CdtTriangle__WEBPACK_IMPORTED_MODULE_11__.CdtTriangle.mkSSSD(frontElement.RightSite, oppositeSite, pi, this.createEdgeDelegate);
            this.triangles.add(t);
            this.triangles.add(t1);
            this.LegalizeEdge(pi, t.OppositeEdge(pi));
            this.LegalizeEdge(pi, t1.OppositeEdge(pi));
        }
    }
    LegalizeEdge(pi, edge) {
        /*Assert.assert(pi !== edge.upperSite && pi !== edge.lowerSite)*/
        if (edge.constrained || edge.CcwTriangle == null || edge.CwTriangle == null) {
            return;
        }
        if (edge.CcwTriangle.Contains(pi)) {
            this.LegalizeEdgeForOtherCwTriangle(pi, edge);
        }
        else {
            this.LegalizeEdgeForOtherCcwTriangle(pi, edge);
        }
    }
    LegalizeEdgeForOtherCwTriangle(pi, edge) {
        const i = edge.CwTriangle.Edges.index(edge);
        //           if (i === -1)
        //           {
        //               Array<DebugCurve> ls = new Array<DebugCurve>();
        //               ls.Add(new DebugCurve(new Ellipse(2, 2, pi.point)));
        //               for (int j = 0; j < 3; j++)
        //               {
        //                   var ee = edge.CwTriangle.Edges[j];
        //                   ls.Add(new DebugCurve(100,1, j === i ? "red" : "blue", new LineSegment(ee.upperSite.point, ee.lowerSite.point)));
        //               }
        //               ls.Add(new DebugCurve("purple", new LineSegment(edge.upperSite.point, edge.lowerSite.point)));
        //
        //               LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);
        //           }
        /*Assert.assert(i >= 0)*/
        if (IsIllegal(pi, edge.upperSite, edge.CwTriangle.Sites.getItem(i + 2), edge.lowerSite)) {
            //ShowIllegalEdge(edge, i, pi);
            const e = Flip(pi, edge);
            this.LegalizeEdge(pi, e.CwTriangle.OppositeEdge(pi));
            this.LegalizeEdge(pi, e.CcwTriangle.OppositeEdge(pi));
        }
    }
    LegalizeEdgeForOtherCcwTriangle(pi, edge) {
        const i = edge.CcwTriangle.Edges.index(edge);
        if (IsIllegal(pi, edge.lowerSite, edge.CcwTriangle.Sites.getItem(i + 2), edge.upperSite)) {
            const e = Flip(pi, edge);
            this.LegalizeEdge(pi, e.CwTriangle.OppositeEdge(pi));
            this.LegalizeEdge(pi, e.CcwTriangle.OppositeEdge(pi));
        }
    }
    // #if TEST_MSAGL && TEST_MSAGL
    // Array < DebugCurve > ShowIllegalEdge(CdtEdge edge, CdtSite pi, int i) {
    //     Array < DebugCurve > ls = new Array<DebugCurve>();
    //     ls.push(DebugCurve.mkDebugCurveTWCI(new Ellipse(2, 2, pi.point)));
    //     for (int j = 0; j < 3; j++) {
    //         var ee = edge.CcwTriangle.Edges[j];
    //         ls.push(DebugCurve.mkDebugCurveTWCI(j === i ? "red" : "blue", LineSegment.mkPP(ee.upperSite.point, ee.lowerSite.point)));
    //     }
    //     ls.push(DebugCurve.mkDebugCurveTWCI(100, 1, "black", Circumcircle(edge.CcwTriangle.Sites.getItem(0].point, edge.CcwTriangle.Sites[1].point, edge.CcwTriangle.Sites[2).point)));
    //     LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);
    //     return ls;
    // }
    //         static Ellipse Circumcircle(Point a, Point b, Point c) {
    //     var mab = 0.5 * (a + b);
    //     var mbc = 0.5 * (c + b);
    //     Point center;
    //     Point.LineLineIntersection(mab, mab + (b - a).Rotate(Math.PI / 2), mbc, mbc + (b - c).Rotate(Math.PI / 2), out center);
    //     var r = (center - a).Length;
    //     return new Ellipse(r, r, center);
    // }
    // #endif
    ProjectToFront(site) {
        return this.front.findLast((s) => s.x <= site.point.x);
    }
    runEdgeInserter() {
        this.initEdgeInserter();
        this.TraceEdgeThroughTriangles();
        this.TriangulatePolygon0(this.rightPolygon, this.traversingEdge.upperSite, this.traversingEdge.lowerSite, true);
        this.TriangulatePolygon0(this.leftPolygon, this.traversingEdge.upperSite, this.traversingEdge.lowerSite, false);
        this.UpdateFront();
    }
    initEdgeInserter() {
        this.rightPolygon = new Array();
        this.leftPolygon = new Array();
        this.addedTriangles = new Array();
        this.piercedEdge = null;
        this.piercedTriangle = null;
        this.piercedToTheLeftFrontElemNode = null;
        this.piercedToTheRightFrontElemNode = null;
    }
    UpdateFront() {
        const newFrontEdges = new Set();
        for (const t of this.addedTriangles) {
            for (const e of t.Edges)
                if (e.CwTriangle == null || e.CcwTriangle == null) {
                    if (e.lowerSite == this.p_2 && e.upperSite == this.p_1) {
                        continue;
                    }
                    newFrontEdges.add(e);
                }
        }
        for (const e of newFrontEdges)
            this.AddEdgeToFront(e);
    }
    AddEdgeToFront(e) {
        const leftSite = e.upperSite.point.x < e.lowerSite.point.x ? e.upperSite : e.lowerSite;
        this.front.insert(new _CdtFrontElement__WEBPACK_IMPORTED_MODULE_10__.CdtFrontElement(leftSite, e));
    }
    TriangulatePolygon0(polygon, a, b, reverseTrangleWhenCompare) {
        if (polygon.length > 0) {
            this.TriangulatePolygon1(0, polygon.length - 1, polygon, a, b, reverseTrangleWhenCompare);
        }
    }
    TriangulatePolygon1(start, end, polygon, a, b, reverseTrangleWhenCompare) {
        //            if(CdtSweeper.db)
        //               CdtSweeper.ShowFront(triangles,front, Enumerable.Range(start, end-start+1).Select(i=> new Ellipse(10,10,polygon[i].point)).ToArray(), new[]{new LineSegment(a.point,b.point)});
        let c = polygon[start];
        let cIndex = start;
        for (let i = start + 1; i <= end; i++) {
            const v = polygon[i];
            if (localInCircle(v)) {
                cIndex = i;
                c = v;
            }
        }
        const t = _CdtTriangle__WEBPACK_IMPORTED_MODULE_11__.CdtTriangle.mkSSSD(a, b, c, this.createEdgeDelegate);
        this.triangles.add(t);
        this.addedTriangles.push(t);
        if (start < cIndex) {
            this.TriangulatePolygon1(start, cIndex - 1, polygon, a, c, reverseTrangleWhenCompare);
        }
        if (cIndex < end) {
            this.TriangulatePolygon1(cIndex + 1, end, polygon, c, b, reverseTrangleWhenCompare);
        }
        function localInCircle(v) {
            return reverseTrangleWhenCompare ? InCircle(v, a, c, b) : InCircle(v, a, b, c);
        }
    }
    TraceEdgeThroughTriangles() {
        this.initEdgeTracer();
        this.Traverse();
    }
    Traverse() {
        while (!this.BIsReached()) {
            if (this.piercedToTheLeftFrontElemNode != null) {
                this.ProcessLeftFrontPiercedElement();
            }
            else if (this.piercedToTheRightFrontElemNode != null) {
                this.ProcessRightFrontPiercedElement();
            }
            else {
                this.ProcessPiercedEdge();
            }
        }
        if (this.piercedTriangle != null) {
            this.removePiercedTriangle(this.piercedTriangle);
        }
        this.FindMoreRemovedFromFrontElements();
        for (const elem of this.elementsToBeRemovedFromFront) {
            this.front.remove(elem);
        }
    }
    ProcessLeftFrontPiercedElement() {
        // CdtSweeper.ShowFront(triangles, front,new []{new LineSegment(a.point, b.point),new LineSegment(piercedToTheLeftFrontElemNode.item.Edge.lowerSite.point,piercedToTheLeftFrontElemNode.item.Edge.upperSite.point)},null);
        let v = this.piercedToTheLeftFrontElemNode;
        do {
            this.elementsToBeRemovedFromFront.push(v.item);
            this.AddSiteToLeftPolygon(v.item.LeftSite);
            v = this.front.previous(v);
        } while (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.pointToTheLeftOfLine(v.item.LeftSite.point, this.a.point, this.b.point)); //that is why we are adding to the left polygon
        this.elementsToBeRemovedFromFront.push(v.item);
        this.AddSiteToRightPolygon(v.item.LeftSite);
        if (v.item.LeftSite === this.b) {
            this.piercedToTheLeftFrontElemNode = v;
            // this will stop the traversal
            return;
        }
        this.FindPiercedTriangle(v);
        this.piercedToTheLeftFrontElemNode = null;
    }
    FindPiercedTriangle(v) {
        var _a;
        const e = v.item.Edge;
        const t = (_a = e.CcwTriangle) !== null && _a !== void 0 ? _a : e.CwTriangle;
        const eIndex = t.Edges.index(e);
        for (let i = 1; i <= 2; i++) {
            const ei = t.Edges.getItem(i + eIndex);
            const signedArea0 = _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_8__.RealNumberSpan.sign(_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.signedDoubledTriangleArea(ei.lowerSite.point, this.a.point, this.b.point));
            const signedArea1 = _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_8__.RealNumberSpan.sign(_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.signedDoubledTriangleArea(ei.upperSite.point, this.a.point, this.b.point));
            if (signedArea1 * signedArea0 <= 0) {
                this.piercedTriangle = t;
                this.piercedEdge = ei;
                break;
            }
        }
    }
    FindMoreRemovedFromFrontElements() {
        for (const triangle of this.removedTriangles) {
            for (const e of triangle.Edges) {
                if (e.CcwTriangle == null && e.CwTriangle == null) {
                    const site = e.upperSite.point.x < e.lowerSite.point.x ? e.upperSite : e.lowerSite;
                    const frontNode = CdtSweeper.FindNodeInFrontBySite(this.front, site);
                    if (frontNode.item.Edge === e) {
                        this.elementsToBeRemovedFromFront.push(frontNode.item);
                    }
                }
            }
        }
    }
    ProcessPiercedEdge() {
        // if(CdtSweeper.db)
        //          CdtSweeper.ShowFront(triangles, front, new[] { new LineSegment(a.point, b.point) },
        //                      new[] { new LineSegment(piercedEdge.upperSite.point, piercedEdge.lowerSite.point) });
        if (this.piercedEdge.CcwTriangle === this.piercedTriangle) {
            this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite);
            this.AddSiteToRightPolygon(this.piercedEdge.upperSite);
        }
        else {
            this.AddSiteToLeftPolygon(this.piercedEdge.upperSite);
            this.AddSiteToRightPolygon(this.piercedEdge.lowerSite);
        }
        this.removePiercedTriangle(this.piercedTriangle);
        this.PrepareNextStateAfterPiercedEdge();
    }
    PrepareNextStateAfterPiercedEdge() {
        var _a, _b;
        const t = (_a = this.piercedEdge.CwTriangle) !== null && _a !== void 0 ? _a : this.piercedEdge.CcwTriangle;
        const eIndex = t.Edges.index(this.piercedEdge);
        for (let i = 1; i <= 2; i++) {
            const e = t.Edges.getItem(i + eIndex);
            const signedArea0 = _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_8__.RealNumberSpan.sign(_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.signedDoubledTriangleArea(e.lowerSite.point, this.a.point, this.b.point));
            const signedArea1 = _utils_RealNumberSpan__WEBPACK_IMPORTED_MODULE_8__.RealNumberSpan.sign(_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.signedDoubledTriangleArea(e.upperSite.point, this.a.point, this.b.point));
            if (signedArea1 * signedArea0 <= 0) {
                if (e.CwTriangle != null && e.CcwTriangle != null) {
                    this.piercedTriangle = t;
                    this.piercedEdge = e;
                    break;
                }
                // e has to belong to the front, and its triangle has to be removed
                this.piercedTriangle = null;
                this.piercedEdge = null;
                const leftSite = e.upperSite.point.x < e.lowerSite.point.x ? e.upperSite : e.lowerSite;
                const frontElem = CdtSweeper.FindNodeInFrontBySite(this.front, leftSite);
                /*Assert.assert(frontElem != null)*/
                if (leftSite.point.x < this.a.point.x) {
                    this.piercedToTheLeftFrontElemNode = frontElem;
                }
                else {
                    this.piercedToTheRightFrontElemNode = frontElem;
                }
                this.removePiercedTriangle((_b = e.CwTriangle) !== null && _b !== void 0 ? _b : e.CcwTriangle);
                break;
            }
        }
    }
    removePiercedTriangle(t) {
        this.triangles.delete(t);
        for (const e of t.Edges) {
            if (e.CwTriangle === t) {
                e.CwTriangle = null;
            }
            else {
                e.CcwTriangle = null;
            }
            this.removedTriangles.push(t);
        }
    }
    ProcessRightFrontPiercedElement() {
        let v = this.piercedToTheRightFrontElemNode;
        do {
            this.elementsToBeRemovedFromFront.push(v.item);
            this.AddSiteToRightPolygon(v.item.RightSite);
            v = this.front.next(v);
        } while (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.pointToTheRightOfLine(v.item.RightSite.point, this.a.point, this.b.point)); //that is why we are adding to the right polygon
        this.elementsToBeRemovedFromFront.push(v.item);
        this.AddSiteToLeftPolygon(v.item.RightSite);
        if (v.item.RightSite === this.b) {
            this.piercedToTheRightFrontElemNode = v; //this will stop the traversal
            return;
        }
        this.FindPiercedTriangle(v);
        this.piercedToTheRightFrontElemNode = null;
    }
    AddSiteToLeftPolygon(site) {
        this.AddSiteToPolygonWithCheck(site, this.leftPolygon);
    }
    AddSiteToPolygonWithCheck(site, list) {
        if (site === this.b) {
            return;
        }
        if (list.length === 0 || list[list.length - 1] !== site) {
            list.push(site);
        }
    }
    AddSiteToRightPolygon(site) {
        this.AddSiteToPolygonWithCheck(site, this.rightPolygon);
    }
    BIsReached() {
        var _a;
        const node = (_a = this.piercedToTheLeftFrontElemNode) !== null && _a !== void 0 ? _a : this.piercedToTheRightFrontElemNode;
        if (node != null) {
            return node.item.Edge.IsAdjacent(this.b);
        }
        return this.piercedEdge.IsAdjacent(this.b);
    }
    initEdgeTracer() {
        this.elementsToBeRemovedFromFront = [];
        this.a = this.traversingEdge.upperSite;
        this.b = this.traversingEdge.lowerSite;
        this.removedTriangles = [];
        //            if (CdtSweeper.D)
        //                CdtSweeper.ShowFront(triangles, front, new[] {new LineSegment(a.point, b.point)},null);
        // new[] {new LineSegment(piercedEdge.upperSite.point, piercedEdge.lowerSite.point)});
        const frontElemNodeRightOfA = CdtSweeper.FindNodeInFrontBySite(this.front, this.a);
        const frontElemNodeLeftOfA = this.front.previous(frontElemNodeRightOfA);
        if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.pointToTheLeftOfLine(this.b.point, frontElemNodeLeftOfA.item.LeftSite.point, frontElemNodeLeftOfA.item.RightSite.point)) {
            this.piercedToTheLeftFrontElemNode = frontElemNodeLeftOfA;
        }
        else if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.pointToTheRightOfLine(this.b.point, frontElemNodeRightOfA.item.RightSite.point, frontElemNodeRightOfA.item.LeftSite.point)) {
            this.piercedToTheRightFrontElemNode = frontElemNodeRightOfA;
        }
        else {
            for (const e of this.a.Edges) {
                const t = e.CcwTriangle;
                if (t == null) {
                    continue;
                }
                if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.pointToTheLeftOfLine(this.b.point, e.lowerSite.point, e.upperSite.point)) {
                    continue;
                }
                const eIndex = t.Edges.index(e);
                const site = t.Sites.getItem(eIndex + 2);
                if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.pointToTheLeftOfLineOrOnLine(this.b.point, site.point, e.upperSite.point)) {
                    this.piercedEdge = t.Edges.getItem(eIndex + 1);
                    this.piercedTriangle = t;
                    // CdtSweeper.ShowFront(triangles, front, new[] { new LineSegment(e.upperSite.point, e.lowerSite.point) },
                    // new[] { new LineSegment(piercedEdge.upperSite.point, piercedEdge.lowerSite.point) });
                    break;
                }
            }
        }
    }
}
function removeFromArray(arr, item) {
    if (arr.length === 0)
        return;
    const i = arr.findIndex((e) => item === e);
    if (i >= 0) {
        if (i !== arr.length - 1) {
            arr[i] = arr[arr.length - 1]; // save the last element
        }
        arr.pop();
    }
}
function IsIllegal(pi, a, b, c) {
    return InCone(pi, a, b, c) && InCircle(pi, a, b, c);
}
function InCone(pi, a, b, c) {
    /*Assert.assert(
      Point.getTriangleOrientation(a.point, b.point, c.point) ==
        TriangleOrientation.Counterclockwise,
    )*/
    return (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.getTriangleOrientation(a.point, pi.point, b.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Clockwise &&
        _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.getTriangleOrientation(b.point, pi.point, c.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Clockwise);
}
// Testing that d of inside of the circumcircle of (a,b,c).
// The good explanation of this test is of
// "Guibas, Stolfi,"Primitives for the Manipulation of General Subdivisions and the Computation of Voronoi Diagrams
//
function InCircle(d, a, b, c) {
    /*Assert.assert(
      Point.getTriangleOrientation(a.point, b.point, c.point) ==
        TriangleOrientation.Counterclockwise,
    )*/
    const axdx = a.point.x - d.point.x;
    const aydy = a.point.y - d.point.y;
    const bxdx = b.point.x - d.point.x;
    const bydy = b.point.y - d.point.y;
    const cxdx = c.point.x - d.point.x;
    const cydy = c.point.y - d.point.y;
    const t0 = axdx * axdx + aydy * aydy;
    const t1 = bxdx * bxdx + bydy * bydy;
    const t2 = cxdx * cxdx + cydy * cydy;
    return axdx * (bydy * t2 - cydy * t1) - bxdx * (aydy * t2 - cydy * t0) + cxdx * (aydy * t1 - bydy * t0) > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance;
}
function TriangleIsCorrect(t) {
    if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point.getTriangleOrientation(t.Sites.getItem(0).point, t.Sites.getItem(1).point, t.Sites.getItem(2).point) !=
        _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.TriangleOrientation.Counterclockwise) {
        return false;
    }
    for (let i = 0; i < 3; i++) {
        const e = t.Edges.getItem(i);
        const a = t.Sites.getItem(i);
        const b = t.Sites.getItem(i + 1);
        if (!e.IsAdjacent(a) || !e.IsAdjacent(b))
            return false;
        if (e.upperSite === a) {
            if (e.CcwTriangle !== t)
                return false;
        }
        else if (e.CwTriangle !== t)
            return false;
    }
    return true;
}
function Flip(pi, edge) {
    /*Assert.assert(!edge.IsAdjacent(pi))*/
    /*Assert.assert(edge.CcwTriangle.Contains(pi) || edge.CwTriangle.Contains(pi))*/
    //get surrounding data
    let t;
    let ot;
    if (edge.CcwTriangle.Contains(pi)) {
        t = edge.CcwTriangle;
        ot = edge.CwTriangle;
    }
    else {
        t = edge.CwTriangle;
        ot = edge.CcwTriangle;
    }
    /*Assert.assert(t.Contains(pi))*/
    const eIndex = t.Edges.index(edge);
    const eOtherIndex = ot.Edges.index(edge);
    /*Assert.assert(eIndex > -1 && eOtherIndex > -1)*/
    const pl = ot.Sites.getItem(eOtherIndex + 2);
    const edgeBeforPi = t.Edges.getItem(eIndex + 1);
    const edgeBeforPl = ot.Edges.getItem(eOtherIndex + 1);
    //changing t
    const newEdge = _Cdt__WEBPACK_IMPORTED_MODULE_9__.Cdt.GetOrCreateEdge(pi, pl);
    t.Sites.setItem(eIndex + 1, pl);
    t.Edges.setItem(eIndex, edgeBeforPl);
    t.Edges.setItem(eIndex + 1, newEdge);
    //changing ot
    ot.Sites.setItem(eOtherIndex + 1, pi);
    ot.Edges.setItem(eOtherIndex, edgeBeforPi);
    ot.Edges.setItem(eOtherIndex + 1, newEdge);
    //orient the new edge and the two edges that move from one triangle to another
    if (edgeBeforPl.lowerSite === pl)
        edgeBeforPl.CcwTriangle = t;
    else
        edgeBeforPl.CwTriangle = t;
    if (edgeBeforPi.lowerSite === pi)
        edgeBeforPi.CcwTriangle = ot;
    else
        edgeBeforPi.CwTriangle = ot;
    if (newEdge.upperSite === pi) {
        newEdge.CcwTriangle = ot;
        newEdge.CwTriangle = t;
    }
    else {
        newEdge.CcwTriangle = t;
        newEdge.CwTriangle = ot;
    }
    /*Assert.assert(TriangleIsCorrect(t))*/
    /*Assert.assert(TriangleIsCorrect(t))*/
    //ShowFlip(pi, t, ot);
    removeFromArray(edge.upperSite.Edges, edge); //forget the edge
    return newEdge;
}
// #if TEST_MSAGL && TEST_MSAGL
//    static void ShowFlip(CdtSite pi, CdtTriangle t, CdtTriangle ot) {
//        Array<DebugCurve> ls=new Array<DebugCurve>();
//        ls.Add(new DebugCurve(new Ellipse(2,2, pi.point)));
//        for(int i=0;i<3;i++) {
//            var e=t.Edges[i];
//            ls.Add(new DebugCurve(100, 1, "red", new LineSegment(e.upperSite.point,e.lowerSite.point)));
//        }
//        for (int i = 0; i < 3; i++)
//        {
//            var e = ot.Edges[i];
//            ls.Add(new DebugCurve(100, 1, "blue", new LineSegment(e.upperSite.point, e.lowerSite.point)));
//        }
//        ls.Add(new DebugCurve(Circumcircle(t.Sites.getItem(0].point, t.Sites[1].point, t.Sites[2).point)));
//        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);
//    }
// #endif
//# sourceMappingURL=CdtSweeper.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/CdtTriangle.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CdtTriangle: () => (/* binding */ CdtTriangle)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _ThreeArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/ThreeArray.js");





// a trianlge oriented counterclockwise
class CdtTriangle {
    constructor() {
        // the edges
        this.Edges = new _ThreeArray__WEBPACK_IMPORTED_MODULE_4__.ThreeArray();
        // the sites
        this.Sites = new _ThreeArray__WEBPACK_IMPORTED_MODULE_4__.ThreeArray();
    }
    containsPoint(p) {
        return CdtTriangle.PointLocationForTriangle(p, this) !== _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Outside;
    }
    static PointLocationForTriangle(p, triangle) {
        let seenBoundary = false;
        for (let i = 0; i < 3; i++) {
            const area = _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.signedDoubledTriangleArea(p, triangle.Sites.getItem(i).point, triangle.Sites.getItem(i + 1).point);
            if (area < -_math_geometry__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon) {
                return _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Outside;
            }
            if (area < _math_geometry__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon) {
                seenBoundary = true;
            }
        }
        return seenBoundary ? _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Boundary : _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Inside;
    }
    /** extend by eps the triangles edges before the test */
    intersectsLine(a, b, eps) {
        if (CdtTriangle.PointLocationForTriangle(a, this) != _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Outside)
            return true;
        if (CdtTriangle.PointLocationForTriangle(b, this) != _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Outside)
            return true;
        for (const e of this.Edges) {
            if (this.abIntersectsTrianglSide(a, b, e))
                return true;
        }
        return false;
    }
    abIntersectsTrianglSide(a, b, e) {
        return (0,_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_1__.segmentsIntersect)(a, b, e.lowerSite.point, e.upperSite.point);
    }
    static mkSSSD(a, b, c, createEdgeDelegate) {
        const orientation = _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.getTriangleOrientation(a.point, b.point, c.point);
        const r = new CdtTriangle();
        switch (orientation) {
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise:
                r.FillCcwTriangle(a, b, c, createEdgeDelegate);
                break;
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Clockwise:
                r.FillCcwTriangle(a, c, b, createEdgeDelegate);
                break;
            default:
                throw new Error();
                break;
        }
        return r;
    }
    static mkSED(pi, edge, createEdgeDelegate) {
        const tri = new CdtTriangle();
        switch (_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.getTriangleOrientation(edge.upperSite.point, edge.lowerSite.point, pi.point)) {
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise:
                edge.CcwTriangle = tri;
                tri.Sites.setItem(0, edge.upperSite);
                tri.Sites.setItem(1, edge.lowerSite);
                break;
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Clockwise:
                edge.CwTriangle = tri;
                tri.Sites.setItem(0, edge.lowerSite);
                tri.Sites.setItem(1, edge.upperSite);
                break;
            default:
                throw new Error();
        }
        tri.Edges.setItem(0, edge);
        tri.Sites.setItem(2, pi);
        tri.CreateEdge(1, createEdgeDelegate);
        tri.CreateEdge(2, createEdgeDelegate);
        return tri;
    }
    //
    static mkSSSEE(aLeft, aRight, bRight, a, b, createEdgeDelegate) {
        /*Assert.assert(
          Point.getTriangleOrientation(aLeft.point, aRight.point, bRight.point) ==
            TriangleOrientation.Counterclockwise,
        )*/
        const tri = CdtTriangle.mkSSSD(aLeft, aRight, bRight, createEdgeDelegate);
        tri.Edges.setItem(0, a);
        tri.Edges.setItem(1, b);
        tri.BindEdgeToTriangle(aLeft, a);
        tri.BindEdgeToTriangle(aRight, b);
        tri.CreateEdge(2, createEdgeDelegate);
        return tri;
    }
    // in the trianlge, which is always oriented counterclockwise, the edge starts at site
    BindEdgeToTriangle(site, edge) {
        if (site === edge.upperSite) {
            edge.CcwTriangle = this;
        }
        else {
            edge.CwTriangle = this;
        }
    }
    // here a,b,c comprise a ccw triangle
    FillCcwTriangle(a, b, c, createEdgeDelegate) {
        this.Sites.setItem(0, a);
        this.Sites.setItem(1, b);
        this.Sites.setItem(2, c);
        for (let i = 0; i < 3; i++) {
            this.CreateEdge(i, createEdgeDelegate);
        }
    }
    CreateEdge(i, createEdgeDelegate) {
        const a = this.Sites.getItem(i);
        const b = this.Sites.getItem(i + 1);
        const edge = createEdgeDelegate(a, b);
        this.Edges.setItem(i, edge);
        this.BindEdgeToTriangle(a, edge);
    }
    Contains(cdtSite) {
        return this.Sites.has(cdtSite);
    }
    OppositeEdge(pi) {
        const index = this.Sites.index(pi);
        /*Assert.assert(index !== -1)*/
        return this.Edges.getItem(index + 1);
    }
    // #if TEST_MSAGL&&TEST_MSAGL
    //         // Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    //         // A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    //         // <filterpriority>2</filterpriority>
    //         public override string ToString() {
    //             return String.Format("({0},{1},{2}", Sites[0], Sites[1], Sites[2]);
    //         }
    // #endif
    OppositeSite(cdtEdge) {
        const i = this.Edges.index(cdtEdge);
        return this.Sites.getItem(i + 2);
    }
    BoundingBox() {
        const rect = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_3__.Rectangle.mkPP(this.Sites.getItem(0).point, this.Sites.getItem(1).point);
        rect.add(this.Sites.getItem(2).point);
        return rect;
    }
    static mkSSSEED(aLeft, aRight, bRight, a, b, createEdgeDelegate) {
        const t = new CdtTriangle();
        t.Sites.setItem(0, aLeft);
        t.Sites.setItem(1, aRight);
        t.Sites.setItem(2, bRight);
        t.Edges.setItem(0, a);
        t.Edges.setItem(1, b);
        t.BindEdgeToTriangle(aLeft, a);
        t.BindEdgeToTriangle(aRight, b);
        t.CreateEdge(2, createEdgeDelegate);
        return t;
    }
    toString() {
        return this.Sites.getItem(0).toString() + ',' + this.Sites.getItem(1).toString() + ',' + this.Sites.getItem(2).toString();
    }
}
//# sourceMappingURL=CdtTriangle.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/PerimeterEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerimeterEdge: () => (/* binding */ PerimeterEdge)
/* harmony export */ });
class PerimeterEdge {
    constructor(edge) {
        /*Assert.assert(
          edge.CcwTriangle == null  || edge.CwTriangle == null ,
          'one of the edge triangles has to be null',
        )*/
        this.Edge = edge;
    }
}
//# sourceMappingURL=PerimeterEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/ThreeArray.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThreeArray: () => (/* binding */ ThreeArray),
/* harmony export */   constructor: () => (/* binding */ constructor)
/* harmony export */ });
class ThreeArray {
    has(t) {
        return t === this.item0 || t === this.item1 || t === this.item2;
    }
    index(t) {
        if (t === this.item0) {
            return 0;
        }
        if (t === this.item1) {
            return 1;
        }
        if (t === this.item2) {
            return 2;
        }
        return -1;
    }
    getItem(i) {
        switch (i) {
            case 0:
            case 3:
            case -3:
                return this.item0;
                break;
            case 1:
            case 4:
            case -2:
                return this.item1;
                break;
            case 2:
            case 5:
            case -1:
                return this.item2;
                break;
            default:
                throw new Error();
                break;
        }
    }
    setItem(i, value) {
        switch (i) {
            case 0:
            case 3:
            case -3:
                this.item0 = value;
                break;
            case 1:
            case 4:
            case -2:
                this.item1 = value;
                break;
            case 2:
            case 5:
            case -1:
                this.item2 = value;
                break;
            default:
                throw new Error();
                break;
        }
    }
    [Symbol.iterator]() {
        return this.GetEnumerator();
    }
    // Returns an enumerator that iterates through the collection.
    *GetEnumerator() {
        yield this.item0;
        yield this.item1;
        yield this.item2;
    }
}
function constructor(item0, item1, item2) {
    const r = new ThreeArray();
    r.item0 = item0;
    r.item1 = item1;
    r.item2 = item2;
    return r;
}
//# sourceMappingURL=ThreeArray.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/EdgeRoutingMode.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeRoutingMode: () => (/* binding */ EdgeRoutingMode)
/* harmony export */ });
// defines the way edges are routed
var EdgeRoutingMode;
(function (EdgeRoutingMode) {
    EdgeRoutingMode[EdgeRoutingMode["Spline"] = 0] = "Spline";
    EdgeRoutingMode[EdgeRoutingMode["SplineBundling"] = 1] = "SplineBundling";
    EdgeRoutingMode[EdgeRoutingMode["StraightLine"] = 2] = "StraightLine";
    EdgeRoutingMode[EdgeRoutingMode["SugiyamaSplines"] = 3] = "SugiyamaSplines";
    EdgeRoutingMode[EdgeRoutingMode["Rectilinear"] = 4] = "Rectilinear";
    EdgeRoutingMode[EdgeRoutingMode["RectilinearToCenter"] = 5] = "RectilinearToCenter";
    EdgeRoutingMode[EdgeRoutingMode["None"] = 6] = "None";
})(EdgeRoutingMode || (EdgeRoutingMode = {}));
//# sourceMappingURL=EdgeRoutingMode.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/EdgeRoutingSettings.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeRoutingSettings: () => (/* binding */ EdgeRoutingSettings)
/* harmony export */ });
/* harmony import */ var _BundlingSettings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/BundlingSettings.js");
/* harmony import */ var _EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/EdgeRoutingMode.js");


class EdgeRoutingSettings {
    toJSON() {
        const ret = {};
        if (this.EdgeRoutingMode != _EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_1__.EdgeRoutingMode.Spline)
            ret.edgeRoutingMode = _EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_1__.EdgeRoutingMode.Spline;
        if (this.ConeAngle != 30 * (Math.PI / 180))
            ret.coneAngle = this.ConeAngle;
        if (this.padding != 3)
            ret.padding = this.padding;
        if (this.polylinePadding != 1.5)
            ret.polylinePadding = this.polylinePadding;
        if (this.bundlingSettings)
            ret.bundlingSettingsJSON = this.bundlingSettings.toJSON();
        return ret;
    }
    static fromJSON(source) {
        const ret = new EdgeRoutingSettings();
        if (source.edgeRoutingMode)
            source.edgeRoutingMode = ret.edgeRoutingMode;
        if (source.coneAngle)
            ret.coneAngle = source.coneAngle;
        // Amount of space to leave around nodes
        if (source.padding)
            ret.padding = source.padding;
        if (source.polylinePadding)
            ret.polylinePadding = source.polylinePadding;
        // the settings for general edge bundling
        if (source.bundlingSettingsJSON)
            ret.bundlingSettings = _BundlingSettings__WEBPACK_IMPORTED_MODULE_0__.BundlingSettings.createFromJSON(source.bundlingSettingsJSON);
        if (source.routingToParentConeAngle)
            ret.routingToParentConeAngle = source.routingToParentConeAngle;
        if (source.simpleSelfLoopsForParentEdgesThreshold)
            ret.simpleSelfLoopsForParentEdgesThreshold = source.simpleSelfLoopsForParentEdgesThreshold;
        if (source.incrementalRoutingThreshold)
            ret.incrementalRoutingThreshold = source.incrementalRoutingThreshold;
        if (source.routeMultiEdgesAsBundles)
            ret.routeMultiEdgesAsBundles = source.routeMultiEdgesAsBundles;
        // if set to true the original spline is kept under the corresponding GeomEdge
        if (source.KeepOriginalSpline)
            ret.KeepOriginalSpline = source.KeepOriginalSpline;
        return ret;
    }
    constructor() {
        this.coneAngle = 30 * (Math.PI / 180);
        // Amount of space to leave around nodes
        this.padding = 2;
        this.polylinePadding = 1;
        this.routingToParentConeAngle = Math.PI / 6;
        this.simpleSelfLoopsForParentEdgesThreshold = 200;
        this.incrementalRoutingThreshold = 5000000;
        // debugging
        this.routeMultiEdgesAsBundles = true;
        // if set to true the original spline is kept under the corresponding GeomEdge
        this.KeepOriginalSpline = false;
        this.EdgeRoutingMode = _EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_1__.EdgeRoutingMode.Spline;
    }
    // defines the way edges are routed
    get EdgeRoutingMode() {
        return this.edgeRoutingMode;
    }
    set EdgeRoutingMode(value) {
        if (value === _EdgeRoutingMode__WEBPACK_IMPORTED_MODULE_1__.EdgeRoutingMode.SplineBundling && this.bundlingSettings == null) {
            if (this.bundlingSettings == null) {
                this.bundlingSettings = new _BundlingSettings__WEBPACK_IMPORTED_MODULE_0__.BundlingSettings();
            }
        }
        this.edgeRoutingMode = value;
    }
    // the angle in degrees of the cones in the routing with the spanner
    get ConeAngle() {
        return this.coneAngle;
    }
    set ConeAngle(value) {
        this.coneAngle = value;
    }
    // Amount of space to leave around nodes
    get Padding() {
        return this.padding;
    }
    set Padding(value) {
        this.padding = value;
    }
    // Additional amount of padding to leave around nodes when routing with polylines
    get PolylinePadding() {
        return this.polylinePadding;
    }
    set PolylinePadding(value) {
        this.polylinePadding = value;
    }
    // this is a cone angle to find a relatively close point on the parent boundary
    get RoutingToParentConeAngle() {
        return this.routingToParentConeAngle;
    }
    set RoutingToParentConeAngle(value) {
        this.routingToParentConeAngle = value;
    }
    // if the number of the nodes participating in the routing of the parent edges is less than the threshold
    // then the parent edges are routed avoiding the nodes
    get SimpleSelfLoopsForParentEdgesThreshold() {
        return this.simpleSelfLoopsForParentEdgesThreshold;
    }
    set SimpleSelfLoopsForParentEdgesThreshold(value) {
        this.simpleSelfLoopsForParentEdgesThreshold = value;
    }
    // defines the size of the changed graph that could be routed fast with the standard spline routing when dragging
    get IncrementalRoutingThreshold() {
        return this.incrementalRoutingThreshold;
    }
    set IncrementalRoutingThreshold(value) {
        this.incrementalRoutingThreshold = value;
    }
    // if set to true routes multi edges as ordered bundles, when routing in a spline mode
    // <exception cref="NotImplementedException"></exception>
    get RouteMultiEdgesAsBundles() {
        return this.routeMultiEdgesAsBundles;
    }
    set RouteMultiEdgesAsBundles(value) {
        this.routeMultiEdgesAsBundles = value;
    }
}
//# sourceMappingURL=EdgeRoutingSettings.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/MultiEdgeRouter.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiEdgeRouter: () => (/* binding */ MultiEdgeRouter)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/hitTestBehavior.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/graphAlgorithms/ConnectedComponentCalculator.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _PreGraph__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/PreGraph.js");
/* harmony import */ var _spline_bundling_BundleRouter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/BundleRouter.js");
/* harmony import */ var _spline_bundling_SdShortestPath__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/SdShortestPath.js");










class MultiEdgeRouter {
    constructor(multiEdges, interactiveEdgeRouter, nodeBoundaryCurves, bundlingSettings, transparentShapeSetter) {
        this.multiEdges = multiEdges;
        this.interactiveEdgeRouter = interactiveEdgeRouter;
        this.bundlingSettings = bundlingSettings;
        this.bundlingSettings.edgeWidthShrinkCoeff = 1;
        this.transparentShapeSetter = transparentShapeSetter;
        this.nodeTree = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_2__.createRectangleNodeOnData)(nodeBoundaryCurves, (c) => c.boundingBox);
    }
    run() {
        for (const graph of this.GetIndependantPreGraphs()) {
            const br = new _spline_bundling_BundleRouter__WEBPACK_IMPORTED_MODULE_8__.BundleRouter(graph.edges, new _spline_bundling_SdShortestPath__WEBPACK_IMPORTED_MODULE_9__.SdShortestPath(this.transparentShapeSetter, null, null), this.interactiveEdgeRouter.VisibilityGraph, this.bundlingSettings, this.interactiveEdgeRouter.LoosePadding, this.interactiveEdgeRouter.TightHierarchy, this.interactiveEdgeRouter.LooseHierarchy, null, null, null);
            br.run();
        }
    }
    GetPortCurve(port) {
        const curve = this.nodeTree.FirstHitNodeWithPredicate(port.Location, (point, c) => _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.PointRelativeToCurveLocation(point, c) !== _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Outside ? _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Stop : _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_1__.HitTestBehavior.Continue).UserData;
        return curve;
    }
    // creates a set of pregraphs suitable for bundle routing
    GetIndependantPreGraphs() {
        const preGraphs = this.CreateInitialPregraphs();
        do {
            const count = preGraphs.length;
            const t = { preGraphs: preGraphs };
            this.UniteConnectedPreGraphs(t);
            if (count <= preGraphs.length)
                break;
        } while (true);
        return preGraphs;
    }
    UniteConnectedPreGraphs(t) {
        const intersectionGraph = MultiEdgeRouter.GetIntersectionGraphOfPreGraphs(t.preGraphs);
        if (intersectionGraph == null)
            return;
        const connectedComponents = (0,_math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_4__.GetConnectedComponents)(intersectionGraph);
        const newPreGraphList = new Array();
        for (const component of connectedComponents) {
            let preGraph = null;
            for (const i of component) {
                if (preGraph == null) {
                    preGraph = t.preGraphs[i];
                    newPreGraphList.push(preGraph);
                }
                else {
                    preGraph.AddGraph(t.preGraphs[i]);
                }
            }
        }
        t.preGraphs = newPreGraphList;
        for (const pg of t.preGraphs)
            this.AddIntersectingNodes(pg);
    }
    AddIntersectingNodes(pg) {
        const rect = pg.boundingBox;
        for (const curve of this.nodeTree.GetNodeItemsIntersectingRectangle(rect)) {
            pg.AddNodeBoundary(curve);
        }
    }
    static GetIntersectionGraphOfPreGraphs(preGraphs) {
        const intersectingPairs = MultiEdgeRouter.EnumeratePairsOfIntersectedPreGraphs(preGraphs);
        if (intersectingPairs.length) {
            return (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_5__.mkGraphOnEdgesN)(intersectingPairs, preGraphs.length);
        }
        return null;
    }
    static EnumeratePairsOfIntersectedPreGraphs(preGraphs) {
        const arr = Array.from(Array(preGraphs.length).keys());
        const rn = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_2__.createRectangleNodeOnData)(arr, (i) => preGraphs[i].boundingBox);
        const list = new Array();
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_3__.CrossRectangleNodesSameType)(rn, rn, (i, j) => list.push(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_6__.IntPair(i, j)));
        return list;
    }
    CreateInitialPregraphs() {
        return this.multiEdges.map((a) => this.CreatePregraphFromSetOfEdgeGeometries(a));
    }
    CreatePregraphFromSetOfEdgeGeometries(egs) {
        const nodeBoundaries = new Set();
        const eg = egs[0];
        const c = this.GetPortCurve(eg.sourcePort);
        const rect = c.boundingBox;
        nodeBoundaries.add(c);
        nodeBoundaries.add(eg.targetPort.Curve);
        rect.addRec(eg.targetPort.Curve.boundingBox);
        const overlapped = this.nodeTree.GetNodeItemsIntersectingRectangle(rect);
        for (const nodeBoundary of overlapped)
            nodeBoundaries.add(nodeBoundary);
        return _PreGraph__WEBPACK_IMPORTED_MODULE_7__.PreGraph.constructorStatic(egs, nodeBoundaries);
    }
}
//# sourceMappingURL=MultiEdgeRouter.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph: () => (/* binding */ MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph)
/* harmony export */ });
/* harmony import */ var _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js");
/* harmony import */ var _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js");


class MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph {
    constructor(sourceVisVertices, targetVisVertices, visibilityGraph) {
        this.upperBound = Number.POSITIVE_INFINITY;
        this._visGraph = visibilityGraph;
        visibilityGraph.ClearPrevEdgesTable();
        for (const v of visibilityGraph.Vertices())
            v.Distance = Number.POSITIVE_INFINITY;
        this.sources = sourceVisVertices;
        this.targets = new Set(targetVisVertices);
    }
    // Returns  a  path
    GetPath() {
        const pq = new _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__.GenericBinaryHeapPriorityQueue();
        for (const v of this.sources) {
            v.Distance = 0;
            pq.Enqueue(v, 0);
        }
        while (!pq.IsEmpty()) {
            this._current = pq.Dequeue();
            if (this.targets.has(this._current))
                break;
            for (const e of this._current.OutEdges)
                if (this.PassableOutEdge(e))
                    this.ProcessNeighbor(pq, e, e.Target);
            for (const e of this._current.InEdges.filter(this.PassableInEdge.bind))
                this.ProcessNeighbor(pq, e, e.Source);
        }
        return this._visGraph.PreviosVertex(this._current) == null ? null : this.CalculatePath();
    }
    PassableOutEdge(e) {
        return this.targets.has(e.Target) || !MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e);
    }
    PassableInEdge(e) {
        return this.targets.has(e.Source) || !MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e);
    }
    static IsForbidden(e) {
        return ((e.IsPassable != null && !e.IsPassable()) || e) instanceof _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_1__.TollFreeVisibilityEdge;
    }
    ProcessNeighbor(pq, l, v) {
        const len = l.Length;
        const c = this._current.Distance + len;
        if (c >= this.upperBound) {
            return;
        }
        if (this.targets.has(v)) {
            this.upperBound = c;
            this.closestTarget = v;
        }
        if (this._visGraph.PreviosVertex(v) == null) {
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            pq.Enqueue(v, c);
        }
        else if (c < v.Distance) {
            // This condition should never hold for the dequeued nodes.
            // However because of a very rare case of an epsilon error it might!
            // In this case DecreasePriority will fail to find "v" and the algorithm will continue working.
            // Since v is not in the queue changing its .Distance will not mess up the queue.
            // Changing v.Prev is fine since we come up with a path with an insignificantly
            // smaller distance.
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            pq.DecreasePriority(v, c);
        }
    }
    CalculatePath() {
        if (this.closestTarget == null) {
            return null;
        }
        const ret = new Array();
        let v = this.closestTarget;
        do {
            ret.push(v);
            v = this._visGraph.PreviosVertex(v);
        } while (v.Distance > 0);
        ret.push(v);
        return ret.reverse();
    }
}
//# sourceMappingURL=MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/PreGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PreGraph: () => (/* binding */ PreGraph)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");


// this class contains a set of edge geometries, and set of node boundaries, ICurves, that might obstruct the edge routing
class PreGraph {
    static constructorStatic(egs, nodeBoundaries) {
        const pg = new PreGraph();
        pg.edges = egs;
        pg.nodeBoundaries = nodeBoundaries;
        pg.boundingBox = ___WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkEmpty();
        for (const curve of pg.nodeBoundaries) {
            pg.boundingBox = pg.boundingBox.addRec(curve.boundingBox);
        }
        return pg;
    }
    AddGraph(a) {
        this.edges = this.edges.concat(a.edges);
        this.nodeBoundaries = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_1__.uniteSets)(this.nodeBoundaries, a.nodeBoundaries);
        this.boundingBox.addRec(a.boundingBox);
    }
    AddNodeBoundary(curve) {
        this.nodeBoundaries.add(curve);
        this.boundingBox.addRec(curve.boundingBox);
    }
}
//# sourceMappingURL=PreGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/RelativeShape.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RelativeShape: () => (/* binding */ RelativeShape)
/* harmony export */ });
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/shape.js");
// A shape wrapping an ICurve delegate, providing additional information.

class RelativeShape extends _shape__WEBPACK_IMPORTED_MODULE_0__.Shape {
    get BoundaryCurve() {
        return this.node.boundaryCurve;
    }
    set BoundaryCurve(value) {
        if (value)
            throw new Error('Cannot set BoundaryCurve directly for RelativeShape');
    }
    // Constructor taking the ID and the curve delegate for the shape.
    constructor(node) {
        super(null);
        this.node = node;
    }
}
//# sourceMappingURL=RelativeShape.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ShapeCreator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapeCreator: () => (/* binding */ ShapeCreator)
/* harmony export */ });
/* harmony import */ var _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");
/* harmony import */ var _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/hookUpAnywhereFromInsidePort.js");
/* harmony import */ var _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/relativeFloatingPort.js");
/* harmony import */ var _structs_edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/edge.js");
/* harmony import */ var _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ClusterBoundaryPort.js");
/* harmony import */ var _RelativeShape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/RelativeShape.js");
// Class for creating Shape elements from a Graph.




// import {Assert} from '../utils/assert'


class ShapeCreator {
    /**  For a given graph finds the obstacles for nodes and clusters, correctly parenting the obstacles
         according to the cluster hierarchy
         graph with edges to route and nodes/clusters to route around.
         Returns the set of obstacles with correct cluster hierarchy and ports
    */
    static GetShapes(graph, edges = Array.from(graph.shallowEdges)) {
        const nodesToShapes = new Map();
        getShapesUnderGraph(graph, nodesToShapes);
        for (const edge of edges) {
            let shape = nodesToShapes.get(edge.source);
            if (shape) {
                if (edge.sourcePort != null) {
                    shape.Ports.add(edge.sourcePort);
                }
            }
            shape = nodesToShapes.get(edge.target);
            if (shape) {
                if (edge.targetPort != null) {
                    shape.Ports.add(edge.targetPort);
                }
            }
        }
        return Array.from(nodesToShapes.values());
    }
    /**   Creates a shape with a RelativeFloatingPort for the node center, attaches it to the shape and all edges */
    static CreateShapeWithCenterPort(node) {
        // Assert.assert(ApproximateComparer.Close(node.BoundaryCurve.BoundingBox, node.BoundingBox), "node's curve doesn't fit its bounds!");
        const shape = new _RelativeShape__WEBPACK_IMPORTED_MODULE_5__.RelativeShape(node);
        const port = _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_2__.RelativeFloatingPort.mk(() => node.boundaryCurve, () => node.center);
        shape.Ports.add(port);
        for (const e of node.inEdges()) {
            ShapeCreator.FixPortAtTarget(port, e);
        }
        for (const e of node.outEdges()) {
            ShapeCreator.FixPortAtSource(port, e);
        }
        for (const e of node.selfEdges()) {
            ShapeCreator.FixPortAtSource(port, e);
            ShapeCreator.FixPortAtTarget(port, e);
        }
        return shape;
    }
    /**   Creates a ClusterBoundaryPort for the cluster boundary, attaches it to the shape and all edges */
    static CreateShapeWithClusterBoundaryPort(cluster) {
        // Assert.assert(ApproximateComparer.Close(node.BoundaryCurve.BoundingBox, node.BoundingBox), "node's curve doesn't fit its bounds!");
        // Assert.assert(cluster instanceof GeomGraph)
        const shape = new _RelativeShape__WEBPACK_IMPORTED_MODULE_5__.RelativeShape(cluster);
        const port = _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_4__.ClusterBoundaryPort.mk(() => cluster.boundaryCurve, () => cluster.center);
        shape.Ports.add(port);
        let clusterPort = undefined;
        for (const e of cluster.inEdges()) {
            if (e.EdgeToAncestor() === _structs_edge__WEBPACK_IMPORTED_MODULE_3__.ToAncestorEnum.ToAncestor) {
                if (clusterPort == null) {
                    clusterPort = new _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_1__.HookUpAnywhereFromInsidePort(() => cluster.boundaryCurve);
                }
                e.targetPort = clusterPort;
            }
            else {
                ShapeCreator.FixPortAtTarget(port, e);
            }
        }
        for (const e of cluster.outEdges()) {
            if (e.EdgeToAncestor() === _structs_edge__WEBPACK_IMPORTED_MODULE_3__.ToAncestorEnum.FromAncestor) {
                if (clusterPort == null) {
                    clusterPort = new _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_1__.HookUpAnywhereFromInsidePort(() => cluster.boundaryCurve);
                }
                e.sourcePort = clusterPort;
            }
            else {
                ShapeCreator.FixPortAtSource(port, e);
            }
        }
        for (const e of cluster.selfEdges()) {
            ShapeCreator.FixPortAtSource(port, e);
            ShapeCreator.FixPortAtTarget(port, e);
        }
        return shape;
    }
    static FixPortAtSource(port, e) {
        if (e == null)
            return;
        if (e.sourcePort == null) {
            e.sourcePort = port;
        }
    }
    static FixPortAtTarget(port, e) {
        if (e == null)
            return;
        if (e.targetPort == null) {
            e.targetPort = port;
        }
    }
}
function getShapesUnderGraph(graph, nodesToShapes) {
    for (const n of graph.shallowNodes) {
        if (n instanceof _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_0__.GeomGraph) {
            const nShape = ShapeCreator.CreateShapeWithClusterBoundaryPort(n);
            nodesToShapes.set(n, nShape);
            const ng = n;
            if (!ng.isCollapsed) {
                getShapesUnderGraph(ng, nodesToShapes);
                for (const ch of ng.shallowNodes) {
                    nShape.AddChild(nodesToShapes.get(ch));
                }
            }
        }
        else {
            nodesToShapes.set(n, ShapeCreator.CreateShapeWithCenterPort(n));
        }
    }
}
//# sourceMappingURL=ShapeCreator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ShapeCreatorForRoutingToParents.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapeCreatorForRoutingToParents: () => (/* binding */ ShapeCreatorForRoutingToParents)
/* harmony export */ });
/* harmony import */ var _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomGraph.js");
/* harmony import */ var _layout_core_geomObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomObject.js");
/* harmony import */ var _RelativeShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/RelativeShape.js");



class ShapeCreatorForRoutingToParents {
    static GetShapes(inParentEdges, outParentEdges) {
        const nodesToShapes = new Map();
        for (const edge of inParentEdges) {
            ShapeCreatorForRoutingToParents.ProcessAncestorDescendantCouple(edge.target, edge.source, nodesToShapes);
            ShapeCreatorForRoutingToParents.InsertEdgePortsToShapes(nodesToShapes, edge);
        }
        for (const edge of outParentEdges) {
            ShapeCreatorForRoutingToParents.ProcessAncestorDescendantCouple(edge.source, edge.target, nodesToShapes);
            ShapeCreatorForRoutingToParents.InsertEdgePortsToShapes(nodesToShapes, edge);
        }
        ShapeCreatorForRoutingToParents.BindShapes(nodesToShapes);
        return Array.from(nodesToShapes.values());
    }
    static InsertEdgePortsToShapes(nodesToShapes, edge) {
        nodesToShapes.get(edge.target).Ports.add(edge.targetPort);
        nodesToShapes.get(edge.source).Ports.add(edge.sourcePort);
    }
    static BindShapes(nodesToShapes) {
        for (const [key, shape] of nodesToShapes) {
            if (!(key instanceof _layout_core_geomGraph__WEBPACK_IMPORTED_MODULE_0__.GeomGraph)) {
                continue;
            }
            const cluster = key;
            for (const child of Children(cluster)) {
                const childShape = nodesToShapes.get(child);
                if (childShape) {
                    shape.AddChild(childShape);
                }
            }
        }
    }
    static ProcessAncestorDescendantCouple(ancestor, geomNode, nodesToShapes) {
        let parent = Parent(geomNode);
        do {
            for (const n of Children(parent))
                ShapeCreatorForRoutingToParents.CreateShapeIfNeeeded(n, nodesToShapes);
            if (parent === ancestor)
                break;
            parent = Parent(parent);
        } while (true);
        ShapeCreatorForRoutingToParents.CreateShapeIfNeeeded(parent, nodesToShapes);
    }
    static CreateShapeIfNeeeded(n, nodesToShapes) {
        if (nodesToShapes.has(n)) {
            return;
        }
        nodesToShapes.set(n, new _RelativeShape__WEBPACK_IMPORTED_MODULE_2__.RelativeShape(n));
    }
    static NumberOfActiveNodesIsUnderThreshold(inParentEdges, outParentEdges, threshold) {
        const usedNodeSet = new Set();
        for (const edge of inParentEdges) {
            if (ShapeCreatorForRoutingToParents.SetOfActiveNodesIsLargerThanThreshold(edge.target, edge.source, usedNodeSet, threshold)) {
                return false;
            }
        }
        for (const edge of outParentEdges) {
            if (ShapeCreatorForRoutingToParents.SetOfActiveNodesIsLargerThanThreshold(edge.source, edge.target, usedNodeSet, threshold)) {
                return false;
            }
        }
        return true;
    }
    static SetOfActiveNodesIsLargerThanThreshold(ancestor, node, usedNodeSet, threshold) {
        let parent = Parent(node);
        while (true) {
            for (const n of Children(parent)) {
                usedNodeSet.add(n);
                if (usedNodeSet.size > threshold) {
                    return true;
                }
            }
            if (parent === ancestor) {
                break;
            }
            parent = Parent(parent);
        }
        usedNodeSet.add(parent);
        return usedNodeSet.size > threshold;
    }
}
function Parent(geomNode) {
    const p = geomNode.node.parent;
    return _layout_core_geomObject__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(p);
}
function* Children(gg) {
    for (const n of gg.graph.shallowNodes) {
        yield _layout_core_geomObject__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(n);
    }
}
//# sourceMappingURL=ShapeCreatorForRoutingToParents.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/ShapeObstacleCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapeObstacleCalculator: () => (/* binding */ ShapeObstacleCalculator)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/convexHull.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/interactiveObstacleCalculator.js");
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/shape.js");
/* harmony import */ var _TightLooseCouple__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/TightLooseCouple.js");
// The class calculates obstacles under the shape.
// We assume that the boundaries are not set for the shape children yet










class ShapeObstacleCalculator {
    constructor(shape, tightPadding, loosePadding, shapesToTightLooseCouples) {
        this.loosePolylinesToNodes = new Map();
        this.MainShape = shape;
        this.TightPadding = tightPadding;
        this.LoosePadding = loosePadding;
        this.ShapesToTightLooseCouples = shapesToTightLooseCouples;
    }
    Calculate(randomizationShift, maxPadding = Number.MAX_VALUE) {
        (0,_utils_random__WEBPACK_IMPORTED_MODULE_5__.initRandom)(3); // keep it the same all the time, otherwise the path optimizer migth not work
        if (this.MainShape.Children.length === 0) {
            return;
        }
        this.CreateTightObstacles();
        this.CreateTigthLooseCouples(randomizationShift);
        if (this.OverlapsDetected) {
            this.FillTheMapOfShapeToTightLooseCouples();
        }
    }
    FillTheMapOfShapeToTightLooseCouples() {
        const childrenShapeHierarchy = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__.CreateRectNodeOnArrayOfRectNodes)(this.MainShape.Children.map((s) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__.mkRectangleNode)(s, s.BoundingBox)));
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_4__.CrossRectangleNodes)(childrenShapeHierarchy, this.coupleHierarchy, this.TryMapShapeToTightLooseCouple.bind(this));
    }
    TryMapShapeToTightLooseCouple(shape, tightLooseCouple) {
        if (ShapeObstacleCalculator.ShapeIsInsideOfPoly(shape, tightLooseCouple.TightPolyline)) {
            this.ShapesToTightLooseCouples.set(shape, tightLooseCouple);
        }
    }
    // this test is valid in our situation where the tight polylines are disjoint and the shape can cross only one of them
    static ShapeIsInsideOfPoly(shape, tightPolyline) {
        return _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.PointRelativeToCurveLocation(shape.BoundaryCurve.start, tightPolyline) === _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Inside;
    }
    CreateTigthLooseCouples(randomizationShift) {
        const couples = new Array();
        for (const tightPolyline of this.tightHierarchy.GetAllLeaves()) {
            const distance = _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_7__.InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(this.tightHierarchy, tightPolyline, this.LoosePadding);
            const loosePoly = _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_7__.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline, distance, randomizationShift);
            const looseShape = new _shape__WEBPACK_IMPORTED_MODULE_8__.Shape(loosePoly);
            const cpl = _TightLooseCouple__WEBPACK_IMPORTED_MODULE_9__.TightLooseCouple.mk(tightPolyline, looseShape, distance);
            this.ShapesToTightLooseCouples.set(this.tightToShape.get(tightPolyline), cpl);
            couples.push(cpl);
        }
        this.coupleHierarchy = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__.CreateRectNodeOnArrayOfRectNodes)(couples.map((c) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__.mkRectangleNode)(c, c.TightPolyline.boundingBox)));
    }
    CreateTightObstacles() {
        this.tightToShape = new Map();
        const tightObstacles = new Set(this.MainShape.Children.map(this.InitialTightPolyline.bind(this)));
        const initialNumberOfTightObstacles = tightObstacles.size;
        this.tightHierarchy = _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_7__.InteractiveObstacleCalculator.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacles);
        this.OverlapsDetected = initialNumberOfTightObstacles > tightObstacles.size;
    }
    InitialTightPolyline(shape) {
        let poly = _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_7__.InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(shape.BoundaryCurve, this.TightPadding);
        const stickingPointsArray = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_6__.flattenArray)(this.LoosePolylinesUnderShape(shape), (p) => p).filter((p) => _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.PointRelativeToCurveLocation(p, poly) === _math_geometry__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Outside);
        if (stickingPointsArray.length == 0) {
            if (this.tightToShape)
                this.tightToShape.set(poly, shape);
            return poly;
        }
        const pts = Array.from(poly).concat(stickingPointsArray);
        poly = _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_2__.Polyline.mkClosedFromPoints(_math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_1__.ConvexHull.CalculateConvexHull(pts));
        if (this.tightToShape)
            this.tightToShape.set(poly, shape);
        return poly;
    }
    LoosePolylinesUnderShape(shape) {
        return shape.Children.map((child) => this.ShapesToTightLooseCouples.get(child).LooseShape.BoundaryCurve);
    }
}
//# sourceMappingURL=ShapeObstacleCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SingleSourceMultipleTargetsShortestPathOnVisibilityGraph: () => (/* binding */ SingleSourceMultipleTargetsShortestPathOnVisibilityGraph)
/* harmony export */ });
/* harmony import */ var _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js");



class SingleSourceMultipleTargetsShortestPathOnVisibilityGraph {
    constructor(sourceVisVertex, targetVisVertices, visibilityGraph) {
        this.upperBound = Number.POSITIVE_INFINITY;
        this._visGraph = visibilityGraph;
        this._visGraph.ClearPrevEdgesTable();
        for (const v of visibilityGraph.Vertices())
            v.Distance = Number.POSITIVE_INFINITY;
        this.source = sourceVisVertex;
        this.targets = new Set(targetVisVertices);
        this.source.Distance = 0;
    }
    // Returns  a  path
    GetPath() {
        const pq = new _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__.GenericBinaryHeapPriorityQueue(_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers);
        this.source.Distance = 0;
        pq.Enqueue(this.source, 0);
        while (!pq.IsEmpty()) {
            this.current = pq.Dequeue();
            if (this.targets.has(this.current)) {
                break;
            }
            for (const e of this.current.OutEdges)
                if (this.PassableOutEdge(e))
                    this.ProcessNeighbor(pq, e, e.Target);
            for (const e of this.current.InEdges)
                if (this.PassableInEdge(e))
                    this.ProcessNeighbor(pq, e, e.Source);
        }
        return this._visGraph.PreviosVertex(this.current) == null ? null : this.CalculatePath();
    }
    PassableOutEdge(e) {
        return (e.Source === this.source || this.targets.has(e.Target) || !SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e));
    }
    PassableInEdge(e) {
        return (this.targets.has(e.Source) || e.Target === this.source || !SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e));
    }
    static IsForbidden(e) {
        return (e.IsPassable != null && !e.IsPassable()) || e instanceof _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_2__.TollFreeVisibilityEdge;
    }
    ProcessNeighbor(pq, l, v) {
        const len = l.Length;
        const c = this.current.Distance + len;
        if (c >= this.upperBound) {
            return;
        }
        if (this.targets.has(v)) {
            this.upperBound = c;
            this.closestTarget = v;
        }
        if (v !== this.source && this._visGraph.PreviosVertex(v) == null) {
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            pq.Enqueue(v, c);
        }
        else if (c < v.Distance) {
            // This condition should never hold for the dequeued nodes.
            // However because of a very rare case of an epsilon error it might!
            // In this case DecreasePriority will fail to find "v" and the algorithm will continue working.
            // Since v is not in the queue changing its .Distance will not mess up the queue.
            // Changing v.Prev is fine since we come up with a path with an insignificantly
            // smaller distance.
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            pq.DecreasePriority(v, c);
        }
    }
    CalculatePath() {
        if (this.closestTarget == null) {
            return null;
        }
        const ret = new Array();
        let v = this.closestTarget;
        do {
            ret.push(v);
            v = this._visGraph.PreviosVertex(v);
        } while (v !== this.source);
        ret.push(this.source);
        return ret.reverse();
    }
}
//# sourceMappingURL=SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/SingleSourceSingleTargetShortestPathOnVisibilityGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SingleSourceSingleTargetShortestPathOnVisibilityGraph: () => (/* binding */ SingleSourceSingleTargetShortestPathOnVisibilityGraph)
/* harmony export */ });
/* harmony import */ var _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js");



class SingleSourceSingleTargetShortestPathOnVisibilityGraph {
    get LengthMultiplier() {
        return this._lengthMultiplier;
    }
    set LengthMultiplier(value) {
        this._lengthMultiplier = value;
    }
    get LengthMultiplierForAStar() {
        return this._lengthMultiplierForAStar;
    }
    set LengthMultiplierForAStar(value) {
        this._lengthMultiplierForAStar = value;
    }
    constructor(visGraph, sourceVisVertex, targetVisVertex) {
        this._lengthMultiplier = 1;
        this._lengthMultiplierForAStar = 1;
        this._visGraph = visGraph;
        this._source = sourceVisVertex;
        this._target = targetVisVertex;
        this._source.Distance = 0;
    }
    // Returns  a  path
    GetPath(shrinkEdgeLength) {
        const pq = new _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_0__.GenericBinaryHeapPriorityQueue(_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers);
        this._source.Distance = 0;
        this._target.Distance = Number.POSITIVE_INFINITY;
        pq.Enqueue(this._source, this.H(this._source));
        while (!pq.IsEmpty()) {
            const hu = { priority: 0 };
            const u = pq.DequeueAndGetPriority(hu);
            if (hu.priority >= this._target.Distance) {
                break;
            }
            for (const e of u.OutEdges) {
                if (this.PassableOutEdge(e)) {
                    const v = e.Target;
                    this.ProcessNeighbor(pq, u, e, v);
                }
            }
            for (const e of u.InEdges) {
                if (this.PassableInEdge(e)) {
                    const v = e.Source;
                    this.ProcessNeighbor(pq, u, e, v);
                }
            }
        }
        return this._visGraph.PreviosVertex(this._target) == null ? null : this.CalculatePath(shrinkEdgeLength);
    }
    // private AssertEdgesPassable(path: Array<VisibilityEdge>) {
    //  for (const edge of path) Assert.assert(this.PassableOutEdge(edge) || this.PassableInEdge(edge))
    // }
    PassableOutEdge(e) {
        return e.Source === this._source || e.Target === this._target || !SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e);
    }
    PassableInEdge(e) {
        return e.Source === this._target || e.Target === this._source || !SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e);
    }
    static IsForbidden(e) {
        return (e.IsPassable != null && !e.IsPassable()) || e instanceof _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_2__.TollFreeVisibilityEdge;
    }
    ProcessNeighborN(pq, u, l, v, penalty) {
        const len = l.Length + penalty;
        const c = u.Distance + len;
        if (v !== this._source && this._visGraph.PreviosVertex(v) == null) {
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            if (v !== this._target) {
                pq.Enqueue(v, this.H(v));
            }
        }
        else if (v !== this._source && c < v.Distance) {
            // This condition should never hold for the dequeued nodes.
            // However because of a very rare case of an epsilon error it might!
            // In this case DecreasePriority will fail to find "v" and the algorithm will continue working.
            // Since v is not in the queue changing its .Distance will not influence other nodes.
            // Changing v.Prev is fine since we come up with the path with an insignificantly
            // smaller distance.
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            if (v !== this._target) {
                pq.DecreasePriority(v, this.H(v));
            }
        }
    }
    ProcessNeighbor(pq, u, l, v) {
        const len = l.Length;
        const c = u.Distance + len;
        if (v !== this._source && this._visGraph.PreviosVertex(v) == null) {
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            if (v !== this._target) {
                pq.Enqueue(v, this.H(v));
            }
        }
        else if (v !== this._source && c < v.Distance) {
            // This condition should never hold for the dequeued nodes.
            // However because of a very rare case of an epsilon error it might!
            // In this case DecreasePriority will fail to find "v" and the algorithm will continue working.
            // Since v is not in the queue changing its .Distance will not influence other nodes.
            // Changing v.Prev is fine since we come up with the path with an insignificantly
            // smaller distance.
            v.Distance = c;
            this._visGraph.SetPreviousEdge(v, l);
            if (v !== this._target) {
                pq.DecreasePriority(v, this.H(v));
            }
        }
    }
    H(visibilityVertex) {
        return visibilityVertex.Distance + visibilityVertex.point.sub(this._target.point).length * this.LengthMultiplierForAStar;
    }
    CalculatePath(shrinkEdgeLength) {
        const ret = new Array();
        let v = this._target;
        do {
            ret.push(v);
            if (shrinkEdgeLength) {
                this._visGraph.ShrinkLengthOfPrevEdge(v, this.LengthMultiplier);
            }
            v = this._visGraph.PreviosVertex(v);
        } while (v !== this._source);
        ret.push(this._source);
        return ret.reverse();
    }
}
//# sourceMappingURL=SingleSourceSingleTargetShortestPathOnVisibilityGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/StraightLineEdges.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StraightLineEdges: () => (/* binding */ StraightLineEdges),
/* harmony export */   straightLineEdgePatcher: () => (/* binding */ straightLineEdgePatcher)
/* harmony export */ });
/* harmony import */ var _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/arrowhead.js");
/* harmony import */ var _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/cornerSite.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _splineRouter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/splineRouter.js");
/* harmony import */ var _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/relativeFloatingPort.js");
// Basic geomedge router for producing straight edges.










function straightLineEdgePatcher(geomGraph, edgesToRoute, cancelToken) {
    if (edgesToRoute) {
        for (const e of edgesToRoute) {
            if (cancelToken && cancelToken.canceled) {
                return;
            }
            StraightLineEdges.RouteEdge(e, geomGraph.padding);
        }
    }
    else {
        for (const n of geomGraph.nodesBreadthFirst) {
            if (cancelToken && cancelToken.canceled) {
                return;
            }
            for (const e of n.outEdges())
                if (e.curve == null)
                    StraightLineEdges.RouteEdge(e, geomGraph.padding);
            for (const e of n.selfEdges())
                if (e.curve == null)
                    StraightLineEdges.RouteEdge(e, geomGraph.padding);
        }
    }
}
class StraightLineEdges extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_7__.Algorithm {
    // Constructs a basic straight geomedge router.
    constructor(edges, padding) {
        super(null);
        this.edges = edges;
        this.padding = padding;
    }
    // Executes the algorithm.
    run() {
        _splineRouter__WEBPACK_IMPORTED_MODULE_8__.SplineRouter.CreatePortsIfNeeded(this.edges);
        for (const geomedge of this.edges) {
            StraightLineEdges.RouteEdge(geomedge, this.padding);
        }
    }
    // populate the geometry including curve and arrowhead positioning for the given geomedge using simple
    // straight line routing style.  Self edges will be drawn as a loop, padding is used to control the
    // size of the loop.
    static RouteEdge(geomedge, padding) {
        const eg = geomedge;
        if (eg.sourcePort == null) {
            eg.sourcePort = _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_9__.RelativeFloatingPort.mk(() => geomedge.source.boundaryCurve, () => geomedge.source.center);
        }
        if (eg.targetPort == null) {
            eg.targetPort = _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_9__.RelativeFloatingPort.mk(() => geomedge.target.boundaryCurve, () => geomedge.target.center);
        }
        if (!StraightLineEdges.ContainmentLoop(eg, padding)) {
            eg.curve = StraightLineEdges.GetEdgeLine(geomedge);
        }
        _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_0__.Arrowhead.trimSplineAndCalculateArrowheadsII(eg, eg.sourcePort.Curve, eg.targetPort.Curve, geomedge.curve, false);
    }
    static ContainmentLoop(eg, padding) {
        const sourceCurve = eg.sourcePort.Curve;
        const targetCurve = eg.targetPort.Curve;
        if (sourceCurve == null || targetCurve == null) {
            return false;
        }
        const targetBox = sourceCurve.boundingBox;
        const sourceBox = targetCurve.boundingBox;
        const targetInSource = targetBox.containsRect(sourceBox);
        const sourceInTarget = !targetInSource && sourceBox.containsRect(targetBox);
        if (targetInSource || sourceInTarget) {
            eg.curve = StraightLineEdges.CreateLoop(targetBox, sourceBox, sourceInTarget, padding);
            return true;
        }
        return false;
    }
    static CreateLoop(targetBox, sourceBox, sourceContainsTarget, padding) {
        return sourceContainsTarget
            ? StraightLineEdges.CreateLoop_(targetBox, sourceBox, padding, false)
            : StraightLineEdges.CreateLoop_(sourceBox, targetBox, padding, true);
    }
    // creates a loop from sourceBox center to the closest point on the targetBox boundary
    static CreateLoop_(sourceBox, targetBox, howMuchToStickOut, reverse) {
        const center = sourceBox.center;
        const closestPoint = StraightLineEdges.FindClosestPointOnBoxBoundary(sourceBox.center, targetBox);
        let dir = closestPoint.sub(center);
        const vert = Math.abs(dir.x) < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon;
        const maxWidth = (vert
            ? Math.min(center.y - targetBox.bottom, targetBox.top - center.y)
            : Math.min(center.x - targetBox.left, targetBox.right - center.x)) / 2; //divide over 2 to not miss the rect
        const width = Math.min(howMuchToStickOut, maxWidth);
        if (dir.length <= _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
            dir = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(1, 0);
        }
        const hookDir = dir.normalize();
        const hookPerp = hookDir.rotate(Math.PI / 2);
        const p1 = closestPoint.add(hookDir.mul(howMuchToStickOut));
        const p2 = p1.add(hookPerp.mul(width));
        const p3 = closestPoint.add(hookPerp.mul(width));
        const end = center.add(hookPerp.mul(width));
        const smoothedPoly = reverse
            ? _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_6__.SmoothedPolyline.mkFromPoints([end, p3, p2, p1, closestPoint, center])
            : _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_6__.SmoothedPolyline.mkFromPoints([center, closestPoint, p1, p2, p3, end]);
        return smoothedPoly.createCurve();
    }
    static FindClosestPointOnBoxBoundary(c, targetBox) {
        const x = c.x - targetBox.left < targetBox.right - c.x ? targetBox.left : targetBox.right;
        const y = c.y - targetBox.bottom < targetBox.top - c.y ? targetBox.bottom : targetBox.top;
        return Math.abs(x - c.x) < Math.abs(y - c.y) ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(x, c.y) : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(c.x, y);
    }
    // Returns a line segment for the given geomedge.
    static GetEdgeLine(geomedge) {
        let sourcePoint;
        let sourceBox;
        if (geomedge.sourcePort == null) {
            sourcePoint = geomedge.source.center;
            sourceBox = geomedge.source.boundaryCurve;
        }
        else {
            sourcePoint = geomedge.sourcePort.Location;
            sourceBox = geomedge.sourcePort.Curve;
        }
        let targetPoint;
        let targetBox;
        if (geomedge.targetPort == null) {
            targetPoint = geomedge.target.center;
            targetBox = geomedge.target.boundaryCurve;
        }
        else {
            targetPoint = geomedge.targetPort.Location;
            targetBox = geomedge.targetPort.Curve;
        }
        let line = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(sourcePoint, targetPoint);
        let intersects = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.getAllIntersections(sourceBox, line, false);
        if (intersects.length > 0) {
            let c = line.trim(intersects[0].par1, 1);
            if (c instanceof _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment) {
                line = c;
                intersects = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.getAllIntersections(targetBox, line, false);
                if (intersects.length > 0) {
                    c = line.trim(0, intersects[0].par1);
                    if (c instanceof _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_4__.LineSegment) {
                        line = c;
                    }
                }
            }
        }
        return line;
    }
    // creates an geomedge curve based only on the source and target geometry
    static CreateSimpleEdgeCurveWithUnderlyingPolyline(ge) {
        const a = ge.sourcePort ? ge.sourcePort.Location : ge.source.center;
        const b = ge.targetPort ? ge.targetPort.Location : ge.target.center;
        if (ge.source === ge.target) {
            const dx = 2 / (3 * ge.source.boundaryCurve.boundingBox.width);
            const dy = ge.source.boundingBox.height / 4;
            ge.smoothedPolyline = StraightLineEdges.CreateUnderlyingPolylineForSelfEdge(a, dx, dy);
            ge.curve = ge.smoothedPolyline.createCurve();
        }
        else {
            ge.smoothedPolyline = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_6__.SmoothedPolyline.mkFromPoints([a, b]);
            ge.curve = ge.smoothedPolyline.createCurve();
        }
        _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_0__.Arrowhead.trimSplineAndCalculateArrowheadsII(ge, ge.source.boundaryCurve, ge.target.boundaryCurve, ge.curve, false);
    }
    static CreateUnderlyingPolylineForSelfEdge(p0, dx, dy) {
        const p1 = p0.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(0, dy));
        const p2 = p0.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(dx, dy));
        const p3 = p0.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(dx, dy * -1));
        const p4 = p0.add(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.Point(0, dy * -1));
        let site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_1__.CornerSite.mkSiteP(p0);
        const polyline = new _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_6__.SmoothedPolyline(site);
        site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_1__.CornerSite.mkSiteSP(site, p1);
        site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_1__.CornerSite.mkSiteSP(site, p2);
        site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_1__.CornerSite.mkSiteSP(site, p3);
        site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_1__.CornerSite.mkSiteSP(site, p4);
        _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_1__.CornerSite.mkSiteSP(site, p0);
        return polyline;
    }
    static SetStraightLineEdgesWithUnderlyingPolylines(graph) {
        _splineRouter__WEBPACK_IMPORTED_MODULE_8__.SplineRouter.CreatePortsIfNeeded(Array.from(graph.deepEdges));
        for (const geomedge of graph.deepEdges) {
            StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(geomedge);
        }
    }
}
//# sourceMappingURL=StraightLineEdges.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/TightLooseCouple.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TightLooseCouple: () => (/* binding */ TightLooseCouple)
/* harmony export */ });
// an utility class to keep different polylines created around a shape
class TightLooseCouple {
    get TightPolyline() {
        return this.tightPoly;
    }
    set TightPolyline(value) {
        this.tightPoly = value;
    }
    static mk(tightPolyline, looseShape, distance) {
        const ret = new TightLooseCouple();
        ret.TightPolyline = tightPolyline;
        ret.LooseShape = looseShape;
        ret.Distance = distance;
        return ret;
    }
    toString() {
        return ((this.TightPolyline == null ? 'null' : this.TightPolyline.toString().substring(0, 5)) +
            ',' +
            (this.LooseShape == null ? 'null' : this.LooseShape.toString().substring(0, 5)));
    }
}
//# sourceMappingURL=TightLooseCouple.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/interactiveEdgeRouter.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InteractiveEdgeRouter: () => (/* binding */ InteractiveEdgeRouter)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/curvePort.js");
/* harmony import */ var _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/floatingPort.js");
/* harmony import */ var _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/hookUpAnywhereFromInsidePort.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/hitTestBehavior.js");
/* harmony import */ var _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js");
/* harmony import */ var _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/interactiveObstacleCalculator.js");
/* harmony import */ var _SingleSourceMultipleTargetsShortestPathOnVisibilityGraph__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.js");
/* harmony import */ var _SingleSourceSingleTargetShortestPathOnVisibilityGraph__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/SingleSourceSingleTargetShortestPathOnVisibilityGraph.js");
/* harmony import */ var _spline_coneSpanner_ConeSpanner__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSpanner.js");
/* harmony import */ var _visibility_Polygon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/Polygon.js");
/* harmony import */ var _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js");
/* harmony import */ var _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _visibility_VisibilityKind__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityKind.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _visibility_InteractiveTangentVisibilityGraphCalculator__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/InteractiveTangentVisibilityGraphCalculator.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _visibility_PointVisibilityCalculator__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/PointVisibilityCalculator.js");
// the router between nodes





















// import {Assert} from '../utils/assert'
class InteractiveEdgeRouter extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_17__.Algorithm {
    constructor() {
        super(...arguments);
        this.IgnoreTightPadding = true;
        // RectangleNode<Polyline, Point> RootOfTightHierarchy {
        //    get { return this.obstacleCalculator.RootOfTightHierararchy; }
        // }
        this.activeRectangle = ___WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkEmpty();
        // Array<Polyline> activeTightPolylines = new Array<Polyline>();
        this.activePolygons = new Array();
        this.alreadyAddedOrExcludedPolylines = new Set();
        this.UseEdgeLengthMultiplier = false;
        // if set to true the algorithm will try to shortcut a shortest polyline inner points
        this.UseInnerPolylingShortcutting = true;
        // if set to true the algorithm will try to shortcut a shortest polyline start and end
        this.UsePolylineEndShortcutting = true;
        this.AllowedShootingStraightLines = true;
        this.LookForRoundedVertices = false;
    }
    rerouteEdge(edge) {
        const poly = edge.smoothedPolyline
            ? _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline.mkFromPoints(edge.smoothedPolyline)
            : _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline.mkFromPoints(edge.getSmoothPolyPoints());
        this.pathOptimizer.run(poly);
        edge.curve = this.pathOptimizer.poly.toCurve();
        // SvgDebugWriter.dumpDebugCurves('./tmp/edge' + debCount++ + '.svg', [
        //   DebugCurve.mkDebugCurveCI('Red', edge.source.boundaryCurve),
        //   DebugCurve.mkDebugCurveCI('Blue', edge.target.boundaryCurve),
        //   DebugCurve.mkDebugCurveTWCI(100, 1, 'Black', poly),
        //   DebugCurve.mkDebugCurveTWCI(100, 1, 'Red', loosePolyOfSource),
        //   DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', loosePolyOfTarget),
        //   DebugCurve.mkDebugCurveTWCI(200, 1.5, 'Magenta', edge.curve),
        // ])
    }
    static constructorANNN(obstacles, padding, loosePadding, coneSpannerAngle) {
        return InteractiveEdgeRouter.constructorANNNB(obstacles, padding, loosePadding, coneSpannerAngle, false);
    }
    get Obstacles() {
        return this.obstacles_;
    }
    set Obstacles(value) {
        this.obstacles_ = value;
    }
    get EnteringAngleBound() {
        return this.enteringAngleBound_;
    }
    set EnteringAngleBound(value) {
        this.enteringAngleBound_ = value;
    }
    get SourceTightPolyline() {
        return this._sourceTightPolyline;
    }
    set SourceTightPolyline(value) {
        this._sourceTightPolyline = value;
    }
    get TargetTightPolyline() {
        return this.targetTightPolyline;
    }
    set TargetTightPolyline(value) {
        this.targetTightPolyline = value;
    }
    get TargetLoosePolyline() {
        return this.targetLoosePolyline;
    }
    set TargetLoosePolyline(value) {
        this.targetLoosePolyline = value;
    }
    get VisibilityGraph() {
        return this.visibilityGraph;
    }
    set VisibilityGraph(value) {
        this.visibilityGraph = value;
    }
    // the port of the edge start
    get SourcePort() {
        return this.sourcePort;
    }
    set SourcePort(value) {
        this.sourcePort = value;
        if (this.sourcePort != null) {
            this.SourceTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.Location, this.ObstacleCalculator.RootOfTightHierarchy);
            if (this.sourcePort instanceof _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort) {
                this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline);
                // we need to exclude the loose polyline around the source port from the tangent visibily graph
                this.StartPointOfEdgeRouting = this.SourcePort.Location;
            }
            else {
                const bp = this.sourcePort;
                this.StartPointOfEdgeRouting = this.TakeBoundaryPortOutsideOfItsLoosePolyline(bp.Curve, bp.Parameter, this.SourceLoosePolyline);
            }
        }
    }
    // the port of the edge end
    get TargetPort() {
        return this.targetPort;
    }
    set TargetPort(value) {
        this.targetPort = value;
    }
    // we further pad each node but not more than LoosePadding.
    get LoosePadding() {
        return this.loosePadding;
    }
    set LoosePadding(value) {
        this.loosePadding = value;
        if (this.ObstacleCalculator != null) {
            this.ObstacleCalculator.LoosePadding = value;
        }
    }
    get OffsetForPolylineRelaxing() {
        return this.TightPadding * 0.75;
    }
    get StartPointOfEdgeRouting() {
        return this.startPointOfRouting_;
    }
    set StartPointOfEdgeRouting(value) {
        this.startPointOfRouting_ = value;
    }
    ExtendVisibilityGraphToLocation(location) {
        if (this.VisibilityGraph == null) {
            this.VisibilityGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_15__.VisibilityGraph();
        }
        let addedPolygons = null;
        if (!this.activeRectangle.contains(location)) {
            if (this.activeRectangle.isEmpty) {
                this.activeRectangle = ___WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkPP(this.SourcePort.Location, location);
            }
            else {
                this.activeRectangle.add(location);
            }
            addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
            for (const polygon of addedPolygons) {
                this.VisibilityGraph.AddHole(polygon.Polyline);
            }
        }
        if (addedPolygons == null || addedPolygons.length === 0) {
            if (this.targetVV != null) {
                this.VisibilityGraph.RemoveVertex(this.targetVV);
            }
            this.CalculateEdgeTargetVisibilityGraph(location);
        }
        else {
            this.RemovePointVisibilityGraphs();
            const visibilityGraphGenerator = new _visibility_InteractiveTangentVisibilityGraphCalculator__WEBPACK_IMPORTED_MODULE_18__.InteractiveTangentVisibilityGraphCalculator(addedPolygons, this.activePolygons, this.VisibilityGraph);
            visibilityGraphGenerator.run();
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_19__.addRange)(this.activePolygons, addedPolygons);
            this.CalculateEdgeTargetVisibilityGraph(location);
            this.CalculateSourcePortVisibilityGraph();
        }
    }
    RemovePointVisibilityGraphs() {
        if (this.targetVV != null) {
            this.VisibilityGraph.RemoveVertex(this.targetVV);
        }
        if (this.sourceVV != null) {
            this.VisibilityGraph.RemoveVertex(this.sourceVV);
        }
    }
    CalculateEdgeTargetVisibilityGraph(location) {
        this.targetVV = _visibility_PointVisibilityCalculator__WEBPACK_IMPORTED_MODULE_20__.PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()), this.VisibilityGraph, location, _visibility_VisibilityKind__WEBPACK_IMPORTED_MODULE_16__.VisibilityKind.Tangent);
    }
    CalculateSourcePortVisibilityGraph() {
        this.sourceVV = _visibility_PointVisibilityCalculator__WEBPACK_IMPORTED_MODULE_20__.PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()), this.VisibilityGraph, this.StartPointOfEdgeRouting, _visibility_VisibilityKind__WEBPACK_IMPORTED_MODULE_16__.VisibilityKind.Tangent);
    }
    TakeBoundaryPortOutsideOfItsLoosePolyline(nodeBoundary, parameter, loosePolyline) {
        const location = nodeBoundary.value(parameter);
        let tangent = nodeBoundary
            .leftDerivative(parameter)
            .normalize()
            .add(nodeBoundary.rightDerivative(parameter).normalize())
            .normalize();
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(InteractiveEdgeRouter.PointInsideOfConvexCurve(nodeBoundary), location, location.add(tangent)) ==
            _math_geometry_point__WEBPACK_IMPORTED_MODULE_6__.TriangleOrientation.Counterclockwise) {
            tangent = tangent.mul(-1);
        }
        tangent = tangent.rotate(Math.PI / 2);
        const len = loosePolyline.boundingBox.diagonal;
        let ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(location, location.add(tangent.mul(len)));
        const p = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.intersectionOne(ls, loosePolyline, false).x;
        let del = tangent.mul(p.sub(location).length / 2);
        // Point del = tangent * this.OffsetForPolylineRelaxing * 2;
        while (true) {
            ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(location, p.add(del));
            let foundIntersectionsOutsideOfSource = false;
            for (const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfLooseHierarchy)) {
                if (ii.seg1 !== loosePolyline) {
                    del = del.div(1.5);
                    foundIntersectionsOutsideOfSource = true;
                    break;
                }
            }
            if (!foundIntersectionsOutsideOfSource) {
                break;
            }
        }
        return ls.end;
    }
    static PointInsideOfConvexCurve(nodeBoundary) {
        return nodeBoundary.value(0).add(nodeBoundary.value(1.5)).div(2);
        // a hack !!!!!!!!!!!!!!!!!!!!!!
    }
    // Point TakeSourcePortOutsideOfLoosePolyline() {
    //    CurvePort bp = SourcePort as CurvePort;
    //    ICurve nodeBoundary = bp.Node.BoundaryCurve;
    //    Point location = bp.Location;
    //    Point tangent = (nodeBoundary.LeftDerivative(bp.Parameter).Normalize() + nodeBoundary.RightDerivative(bp.Parameter).Normalize()).Normalize();
    //    if (Point.GetTriangleOrientation(bp.Node.Center, location, location + tangent) === TriangleOrientation.Counterclockwise)
    //        tangent = -tangent;
    //    tangent = tangent.Rotate(Math.PI / 2);
    //    Number len = this.sourceLoosePolyline.BoundingBox.Diagonal;
    //    Point portLocation = bp.Location;
    //    LineSegment ls = LineSegment.mkPP(portLocation, portLocation + len * tangent);
    //    Point p = Curve.GetAllIntersections(ls, this.SourceLoosePolyline, false)[0].x;
    //    Point del = tangent * this.OffsetForPolylineRelaxing * 2;
    //    while (true) {
    //        ls = LineSegment.mkPP(portLocation, p + del);
    //        bool foundIntersectionsOutsideOfSource = false;
    //        foreach (IntersectionInfo ii in IntersectionsOfLineAndRectangleNodeOverPolyline(ls, this.obstacleCalculator.RootOfLooseHierarchy))
    //            if (ii.seg1 !== this.SourceLoosePolyline) {
    //                del /= 1.5;
    //                foundIntersectionsOutsideOfSource = true;
    //                break;
    //            }
    //        if (!foundIntersectionsOutsideOfSource)
    //            break;
    //    }
    //    return ls.End;
    // }
    *GetActivePolylines() {
        for (const polygon of this.activePolygons) {
            yield polygon.Polyline;
        }
    }
    GetAddedPolygonesAndMaybeExtendActiveRectangle() {
        const rect = this.activeRectangle;
        const addedPolygones = new Array();
        let added;
        do {
            added = false;
            for (const loosePoly of this.ObstacleCalculator.RootOfLooseHierarchy.GetNodeItemsIntersectingRectangle(this.activeRectangle)) {
                if (!this.alreadyAddedOrExcludedPolylines.has(loosePoly)) {
                    rect.addRec(loosePoly.boundingBox);
                    addedPolygones.push(new _visibility_Polygon__WEBPACK_IMPORTED_MODULE_13__.Polygon(loosePoly));
                    this.alreadyAddedOrExcludedPolylines.add(loosePoly);
                    // we register the loose polyline in the set to not add it twice
                    added = true;
                }
            }
            if (added) {
                this.activeRectangle = rect;
            }
        } while (added);
        return addedPolygones;
    }
    PolylineSegmentIntersectsTightHierarchy(a, b) {
        return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(a, b, this.ObstacleCalculator.RootOfTightHierarchy);
    }
    PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(a, b, rect) {
        return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(_math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(a, b), rect);
    }
    PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls, rect) {
        if (!ls.boundingBox.intersects(rect.irect)) {
            return false;
        }
        if (rect.UserData != null) {
            for (const ii of _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.getAllIntersections(ls, rect.UserData, false)) {
                if (ii.seg1 !== this.SourceTightPolyline && ii.seg1 !== this.TargetTightPolyline) {
                    return true;
                }
                if ((ii.seg1 === this.SourceTightPolyline && this.SourcePort) instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__.CurvePort) {
                    return true;
                }
                if ((ii.seg1 === this.TargetTightPolyline && this.TargetPort) instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__.CurvePort) {
                    return true;
                }
            }
            return false;
        }
        return (this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls, rect.Left) ||
            this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls, rect.Right));
    }
    static IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, rectNode) {
        const ret = new Array();
        InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls, rectNode, ret);
        return ret;
    }
    static IntersectionsOfLineAndRectangleNodeOverPolyline(ls, rectNode, listOfIntersections) {
        if (rectNode == null) {
            return;
        }
        if (!ls.boundingBox.intersects(rectNode.irect)) {
            return;
        }
        if (rectNode.UserData != null) {
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_19__.addRange)(listOfIntersections, _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.getAllIntersections(ls, rectNode.UserData, true));
            return;
        }
        InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls, rectNode.Left, listOfIntersections);
        InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls, rectNode.Right, listOfIntersections);
    }
    LineCanBeAcceptedForRouting(ls) {
        const sourceIsFloating = this.SourcePort instanceof _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort;
        const targetIsFloating = this.TargetPort instanceof _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort;
        if (!sourceIsFloating && !this.targetIsInsideOfSourceTightPolyline) {
            if (!this.InsideOfTheAllowedConeOfBoundaryPort(ls.end, this.SourcePort)) {
                return false;
            }
        }
        if (!targetIsFloating && this.TargetPort != null && !this.sourceIsInsideOfTargetTightPolyline) {
            if (!this.InsideOfTheAllowedConeOfBoundaryPort(ls.start, this.TargetPort)) {
                return false;
            }
        }
        const xx = InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfTightHierarchy);
        for (const ii of xx) {
            if (ii.seg1 === this.SourceTightPolyline) {
                continue;
            }
            if (ii.seg1 === this.targetTightPolyline) {
                continue;
            }
            return false;
        }
        return true;
    }
    InsideOfTheAllowedConeOfBoundaryPort(pointToTest, port) {
        const boundaryCurve = port.Curve;
        const curveIsClockwise = _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_9__.InteractiveObstacleCalculator.CurveIsClockwise(boundaryCurve, InteractiveEdgeRouter.PointInsideOfConvexCurve(boundaryCurve));
        const portLocation = port.Location;
        const pointOnTheRightConeSide = this.GetPointOnTheRightBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, port.Parameter);
        const pointOnTheLeftConeSide = this.GetPointOnTheLeftBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, port.Parameter);
        return (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(portLocation, pointOnTheRightConeSide, pointToTest) !== _math_geometry_point__WEBPACK_IMPORTED_MODULE_6__.TriangleOrientation.Clockwise &&
            ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(portLocation, pointToTest, pointOnTheLeftConeSide) !== _math_geometry_point__WEBPACK_IMPORTED_MODULE_6__.TriangleOrientation.Clockwise);
    }
    GetPointOnTheRightBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, portParam) {
        const tan = curveIsClockwise ? boundaryCurve.rightDerivative(portParam) : boundaryCurve.leftDerivative(portParam).neg();
        return portLocation.add(tan.rotate(this.EnteringAngleBound));
    }
    GetPointOnTheLeftBoundaryPortConeSide(portLocation, boundaryCurve, curveIsClockwise, portParam) {
        const tan = curveIsClockwise ? boundaryCurve.leftDerivative(portParam).neg() : boundaryCurve.rightDerivative(portParam);
        return portLocation.add(tan.rotate(-this.EnteringAngleBound));
    }
    // ShowPolylineAndObstacles(params curves: ICurve[]) {
    //    //  ReSharper restore UnusedMember.Local
    //    let ls: Array<DebugCurve> = this.GetDebugCurves(curves);
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);
    // }
    // GetDebugCurves(params curves: ICurve[]): Array<DebugCurve> {
    //    let ls = this.CreateListWithObstaclesAndPolyline(curves);
    //    // ls.AddRange(this.VisibilityGraph.Edges.Select(e => new DebugCurve(100,0.1, e is TollFreeVisibilityEdge?"red":"green", LineSegment.mkPP(e.SourcePoint, e.TargetPoint))));
    //    if ((this._sourceVisibilityVertex != null)) {
    //        ls.Add(new DebugCurve("red", CurveFactory.CreateDiamond(4, 4, this._sourceVisibilityVertex.point)));
    //    }
    //    if ((this.targetVisibilityVertex != null)) {
    //        ls.Add(new DebugCurve("purple", new Ellipse(4, 4, this.targetVisibilityVertex.Point)));
    //    }
    //    let anywerePort = (<HookUpAnywhereFromInsidePort>(this.targetPort));
    //    if ((anywerePort != null)) {
    //        ls.Add(new DebugCurve("purple", anywerePort.LoosePolyline));
    //    }
    //    return ls;
    // }
    // CreateListWithObstaclesAndPolyline(params curves: ICurve[]): Array<DebugCurve> {
    //    let ls = new Array<DebugCurve>(this.ObstacleCalculator.RootOfLooseHierarchy.GetAllLeaves().select(() => {  }, new DebugCurve(100, 0.01, "green", e)));
    //    ls.AddRange(curves.Select(() => {  }, new DebugCurve(100, 0.01, "red", c)));
    //    ls.AddRange(this.ObstacleCalculator.RootOfTightHierarchy.GetAllLeaves().select(() => {  }, new DebugCurve(100, 0.01, "blue", e)));
    //    //  ls.AddRange(visibilityGraph.Edges.Select(e => (ICurve) LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));
    //    if ((this._polyline != null)) {
    //        ls.Add(new DebugCurve(100, 0.03, "blue", this._polyline));
    //    }
    //    return ls;
    // }
    // smoothing the corners of the polyline
    SmoothenCorners(edgePolyline) {
        let a = edgePolyline.headSite;
        let corner = { b: null, c: null };
        // the corner other end
        while ((corner = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.findCorner(a))) {
            a = this.SmoothOneCorner(a, corner.c, corner.b);
        }
    }
    SmoothOneCorner(a, c, b) {
        const mult = 1.5;
        const kMin = 0.01;
        let k = 0.5;
        let seg;
        let v;
        let u;
        if (a.prev == null) {
            // this will allow to the segment to start from site "a"
            u = 2;
            v = 1;
        }
        else if (c.next == null) {
            u = 1;
            v = 2;
            // this will allow to the segment to end at site "c"
        }
        else {
            u = v = 1;
        }
        do {
            seg = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.createBezierSeg(k * u, k * v, a, b, c);
            b.previouisBezierCoefficient = k * u;
            b.nextBezierCoefficient = k * v;
            k /= mult;
        } while (distFromCornerToSeg() > this.loosePadding && k > kMin);
        k *= mult;
        // that was the last k
        if (k < 0.5 && k > kMin) {
            // one time try a smoother seg
            k = 0.5 * (k + k * mult);
            seg = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.createBezierSeg(k * u, k * v, a, b, c);
            if (distFromCornerToSeg() > this.loosePadding) {
                b.previouisBezierCoefficient = k * u;
                b.nextBezierCoefficient = k * v;
            }
        }
        return b;
        function distFromCornerToSeg() {
            const t = seg.closestParameter(b.point);
            return b.point.sub(seg.value(t)).length;
        }
    }
    TryToRemoveInflectionsAndCollinearSegments(underlyingPolyline) {
        let progress = true;
        const t = { s: null };
        while (progress) {
            progress = false;
            for (t.s = underlyingPolyline.headSite; t.s != null && t.s.next != null; t.s = t.s.next) {
                if (t.s.turn * t.s.next.turn < 0) {
                    progress = this.TryToRemoveInflectionEdge(t) || progress;
                }
            }
        }
    }
    TryToRemoveInflectionEdge(t) {
        if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point, t.s.next.point)) {
            const a = t.s.prev;
            // forget t.s
            const b = t.s.next;
            a.next = b;
            b.prev = a;
            t.s = a;
            return true;
        }
        if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point, t.s.next.next.point)) {
            // forget about t.s and t.s.Next
            const a = t.s.prev;
            const b = t.s.next.next;
            a.next = b;
            b.prev = a;
            t.s = a;
            return true;
        }
        if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.point, t.s.next.next.point)) {
            // forget about t.s.Next
            const b = t.s.next.next;
            t.s.next = b;
            b.prev = t.s;
            return true;
        }
        return false;
    }
    // internal Point TargetPoint {
    //    get {
    //        CurvePort tp = this.TargetPort as CurvePort;
    //        if (tp != null)
    //            return this.Target.BoundaryCurve[tp.Parameter];
    //        else
    //            return (this.TargetPort as FloatingPort).Location;
    //    }
    // }
    // internal Point SourcePoint {
    //    get {
    //        CurvePort sp = this.SourcePort as CurvePort;
    //        if (sp != null)
    //            return this.Source.BoundaryCurve[sp.Parameter];
    //        else
    //            return (this.SourcePort as FloatingPort).Location;
    //    }
    // }
    GetShortestPolyline(sourceVisVertex, _targetVisVertex) {
        this.CleanTheGraphForShortestPath();
        const pathCalc = new _SingleSourceSingleTargetShortestPathOnVisibilityGraph__WEBPACK_IMPORTED_MODULE_11__.SingleSourceSingleTargetShortestPathOnVisibilityGraph(this.visibilityGraph, sourceVisVertex, _targetVisVertex);
        const path = pathCalc.GetPath(this.UseEdgeLengthMultiplier);
        if (path == null) {
            // ShowIsPassable(_sourceVisibilityVertex, _targetVisVertex);
            return null;
        }
        // Assert.assert(path[0] === sourceVisVertex && path[path.length - 1] === _targetVisVertex)
        let ret = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline.mkFromPoints(Array.from(path).map((p) => p.point)).RemoveCollinearVertices();
        if (this.pathOptimizer) {
            this.pathOptimizer.run(ret);
            ret = this.pathOptimizer.poly;
        }
        return ret;
    }
    // private ShowIsPassable(sourceVisVertex: VisibilityVertex, targetVisVertex: VisibilityVertex) {
    //    let dd = new Array<DebugCurve>(this.visibilityGraph.Edges.Select(() => {  }, new DebugCurve(100, 0.5, "green", LineSegment.mkPP(e.SourcePoint, e.TargetPoint))));
    //    // TODO: Warning!!!, inline IF is not supported ?
    //    ((e.IsPassable == null )
    //                || e.IsPassable());
    //    "red";
    //    if ((sourceVisVertex != null)) {
    //        dd.Add(new DebugCurve(CurveFactory.CreateDiamond(3, 3, sourceVisVertex.point)));
    //    }
    //    if ((targetVisVertex != null)) {
    //        dd.Add(new DebugCurve(CurveFactory.CreateEllipse(3, 3, targetVisVertex.point)));
    //    }
    //    if ((this.Obstacles != null)) {
    //        dd.AddRange(this.Obstacles.Select(() => {  }, new DebugCurve(o)));
    //    }
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
    // }
    CleanTheGraphForShortestPath() {
        this.visibilityGraph.ClearPrevEdgesTable();
    }
    // returns true if the nodes overlap or just positioned too close
    get OverlapsDetected() {
        return this.ObstacleCalculator.OverlapsDetected;
    }
    get TightHierarchy() {
        return this.ObstacleCalculator.RootOfTightHierarchy;
    }
    set TightHierarchy(value) {
        this.ObstacleCalculator.RootOfTightHierarchy = value;
    }
    get LooseHierarchy() {
        return this.ObstacleCalculator.RootOfLooseHierarchy;
    }
    set LooseHierarchy(value) {
        this.ObstacleCalculator.RootOfLooseHierarchy = value;
    }
    CalculateObstacles() {
        this.ObstacleCalculator = new _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_9__.InteractiveObstacleCalculator(this.Obstacles, this.TightPadding, this.LoosePadding, this.IgnoreTightPadding);
        this.ObstacleCalculator.Calculate();
    }
    static constructorANNNB(obstacles, padding, loosePadding, coneSpannerAngle, ignoreTightPadding) {
        const ier = new InteractiveEdgeRouter(null);
        ier.IgnoreTightPadding = ignoreTightPadding;
        ier.EnteringAngleBound = 80 * (Math.PI / 180);
        ier.TightPadding = padding;
        ier.LoosePadding = loosePadding;
        if (coneSpannerAngle > 0) {
            ___WEBPACK_IMPORTED_MODULE_0__.Assert.assert(coneSpannerAngle > Math.PI / 180);
            ___WEBPACK_IMPORTED_MODULE_0__.Assert.assert(coneSpannerAngle <= 90 * (Math.PI / 180));
            ier.UseSpanner = true;
            ier.ExpectedProgressSteps = _spline_coneSpanner_ConeSpanner__WEBPACK_IMPORTED_MODULE_12__.ConeSpanner.GetTotalSteps(coneSpannerAngle);
        }
        else {
            ier.ExpectedProgressSteps = obstacles.length;
        }
        ier.ConeSpannerAngle = coneSpannerAngle;
        ier.Obstacles = obstacles;
        ier.CalculateObstacles();
        return ier;
    }
    RouteEdgeToLocation(targetLocation) {
        this.TargetPort = new _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort(null, targetLocation);
        // otherwise route edge to a port would be called
        this.TargetTightPolyline = null;
        this.TargetLoosePolyline = null;
        const edge = new ___WEBPACK_IMPORTED_MODULE_0__.GeomEdge(null);
        let ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.SourcePort.Location, targetLocation);
        if (this.LineCanBeAcceptedForRouting(ls)) {
            this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
            this._polyline.addPoint(ls.start);
            this._polyline.addPoint(ls.end);
            const smoothedPolyline = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__.SmoothedPolyline.mkFromPoints(this._polyline);
            edge.curve = smoothedPolyline.createCurve();
            return edge;
        }
        // can we do with just two line segments?
        if (this.SourcePort instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__.CurvePort) {
            ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.StartPointOfEdgeRouting, targetLocation);
            if (InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfTightHierarchy).length ==
                0) {
                this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
                this._polyline.addPoint(this.SourcePort.Location);
                this._polyline.addPoint(ls.start);
                this._polyline.addPoint(ls.end);
                edge.curve = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__.SmoothedPolyline.mkFromPoints(this._polyline).createCurve();
                return edge;
            }
        }
        this.ExtendVisibilityGraphToLocation(targetLocation);
        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
        if (this.SourcePort instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__.CurvePort) {
            this._polyline.PrependPoint(this.SourcePort.Location);
        }
        edge.curve = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__.SmoothedPolyline.mkFromPoints(this._polyline).createCurve();
        return edge;
    }
    // routes the edge to the port
    //
    RouteEdgeToPort(edgeTargetPort, portLoosePolyline, smooth, t) {
        if (!this.ObstacleCalculator.IsEmpty()) {
            this.TargetPort = edgeTargetPort;
            this.TargetTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(edgeTargetPort.Location, this.ObstacleCalculator.RootOfTightHierarchy);
            // Assert.assert(this.targetTightPolyline != null)
            if (edgeTargetPort instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__.CurvePort) {
                return this.RouteEdgeToBoundaryPort(portLoosePolyline, smooth, t);
            }
            return this.RouteEdgeToFloatingPortOfNode(portLoosePolyline, smooth, t);
        }
        if (this.sourcePort != null && this.targetPort != null) {
            t.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(this.sourcePort.Location, this.targetPort.Location);
            return _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.sourcePort.Location, this.targetPort.Location);
        }
        return null;
    }
    SmoothedPolylineFromTwoPoints(s, e) {
        this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
        this._polyline.addPoint(s);
        this._polyline.addPoint(e);
        return _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__.SmoothedPolyline.mkFromPoints(this._polyline);
    }
    RouteEdgeToFloatingPortOfNode(portLoosePolyline, smooth, t) {
        if (this.sourcePort instanceof _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort) {
            return this.RouteFromFloatingPortToFloatingPort(portLoosePolyline, smooth, t);
        }
        return this.RouteFromBoundaryPortToFloatingPort(portLoosePolyline, smooth, t);
    }
    RouteFromBoundaryPortToFloatingPort(targetPortLoosePolyline, smooth, t) {
        const sourcePortLocation = this.SourcePort.Location;
        const targetPortLocation = this.targetPort.Location;
        let ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(sourcePortLocation, targetPortLocation);
        if (this.LineCanBeAcceptedForRouting(ls)) {
            t.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(ls.start, ls.end);
            return ls;
        }
        if (!this.targetIsInsideOfSourceTightPolyline) {
            // try a variant with two segments
            const takenOutPoint = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve, this.SourcePort.Parameter, this.SourceLoosePolyline);
            ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(takenOutPoint, targetPortLocation);
            if (this.LineAvoidsTightHierarchyLP(ls, targetPortLoosePolyline)) {
                t.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(ls.start, ls.end);
                return ls;
            }
        }
        // we need to route throw the visibility graph
        this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(targetPortLoosePolyline);
        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
        const tmp = this.SourceTightPolyline;
        if (!this.targetIsInsideOfSourceTightPolyline) {
            this.SourceTightPolyline = null;
        }
        this.SourceTightPolyline = tmp;
        this._polyline.PrependPoint(sourcePortLocation);
        //  return this._polyline
        return this.SmoothCornersAndReturnCurve(smooth, t);
    }
    SmoothCornersAndReturnCurve(smooth, t) {
        t.smoothedPolyline = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__.SmoothedPolyline.mkFromPoints(this._polyline);
        if (smooth) {
            this.SmoothenCorners(t.smoothedPolyline);
        }
        return t.smoothedPolyline.createCurve();
    }
    RouteFromFloatingPortToFloatingPort(portLoosePolyline, smooth, t) {
        // route through the visibility graph
        this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(portLoosePolyline);
        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
        if (this._polyline == null) {
            return null;
        }
        t.smoothedPolyline = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__.SmoothedPolyline.mkFromPoints(this._polyline);
        return this.SmoothCornersAndReturnCurve(smooth, t);
    }
    TryShortcutPolyPoint(pp) {
        if (this.LineAvoidsTightHierarchyLPP(_math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(pp.point, pp.next.next.point), this.SourceTightPolyline, this.targetTightPolyline)) {
            // remove pp.Next
            pp.next = pp.next.next;
            pp.next.prev = pp;
            return true;
        }
        return false;
    }
    ExtendVisibilityGraphToLocationOfTargetFloatingPort(portLoosePolyline) {
        if (this.VisibilityGraph == null) {
            this.VisibilityGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_15__.VisibilityGraph();
        }
        let addedPolygons = null;
        const targetLocation = this.targetPort.Location;
        if (!this.activeRectangle.contains(targetLocation)) {
            if (this.activeRectangle.isEmpty) {
                this.activeRectangle = ___WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkPP(this.SourcePort.Location, targetLocation);
            }
            else {
                this.activeRectangle.add(targetLocation);
            }
            addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
            for (const polygon of addedPolygons) {
                this.VisibilityGraph.AddHole(polygon.Polyline);
            }
        }
        if (addedPolygons == null) {
            if (this.targetVV != null) {
                this.VisibilityGraph.RemoveVertex(this.targetVV);
            }
            this.CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation, portLoosePolyline);
            if (this.sourceVV == null) {
                this.CalculateSourcePortVisibilityGraph();
            }
        }
        else {
            this.RemovePointVisibilityGraphs();
            const visibilityGraphGenerator = new _visibility_InteractiveTangentVisibilityGraphCalculator__WEBPACK_IMPORTED_MODULE_18__.InteractiveTangentVisibilityGraphCalculator(addedPolygons, this.activePolygons, this.VisibilityGraph);
            visibilityGraphGenerator.run();
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_19__.addRange)(this.activePolygons, addedPolygons);
            this.CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation, portLoosePolyline);
            this.CalculateSourcePortVisibilityGraph();
        }
    }
    CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation, targetLoosePoly) {
        if (this.UseSpanner) {
            this.targetVV = this.AddTransientVisibilityEdgesForPort(targetLocation, targetLoosePoly);
        }
        else {
            this.targetVV = _visibility_PointVisibilityCalculator__WEBPACK_IMPORTED_MODULE_20__.PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(targetLoosePoly), this.VisibilityGraph, targetLocation, _visibility_VisibilityKind__WEBPACK_IMPORTED_MODULE_16__.VisibilityKind.Tangent);
        }
    }
    AddTransientVisibilityEdgesForPort(point, loosePoly) {
        let v = this.GetVertex(point);
        if (v != null) {
            return v;
        }
        v = this.visibilityGraph.AddVertexP(point);
        if (loosePoly != null)
            //if the edges have not been calculated do it in a quick and dirty mode
            for (const p of loosePoly)
                this.visibilityGraph.AddEdgeF(point, p, (a, b) => new _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_14__.TollFreeVisibilityEdge(a, b));
        else {
            v = _visibility_PointVisibilityCalculator__WEBPACK_IMPORTED_MODULE_20__.PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylines(), this.VisibilityGraph, point, _visibility_VisibilityKind__WEBPACK_IMPORTED_MODULE_16__.VisibilityKind.Tangent);
            // Assert.assert(v != null)
        }
        return v;
    }
    GetVertex(point) {
        let v = this.visibilityGraph.FindVertex(point);
        if (v == null && this.LookForRoundedVertices) {
            v = this.visibilityGraph.FindVertex(___WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(point));
        }
        return v;
    }
    *GetActivePolylinesWithException(targetLoosePoly) {
        /*
    return from polygon in activePolygons where polygon.Polyline !== targetLoosePoly select polygon.Polyline;
          */
        for (const polygon of this.activePolygons) {
            if (polygon.Polyline !== targetLoosePoly)
                yield polygon.Polyline;
        }
    }
    RouteEdgeToBoundaryPort(portLoosePolyline, smooth, t) {
        this.TargetLoosePolyline = portLoosePolyline;
        if (this.sourcePort instanceof _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort) {
            return this.RouteFromFloatingPortToBoundaryPort(smooth, t);
        }
        return this.RouteFromBoundaryPortToBoundaryPort(smooth, t);
    }
    RouteFromBoundaryPortToBoundaryPort(smooth, t) {
        const sourcePortLocation = this.SourcePort.Location;
        let curve;
        const targetPortLocation = this.targetPort.Location;
        let ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(sourcePortLocation, targetPortLocation);
        if (this.LineCanBeAcceptedForRouting(ls)) {
            this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
            this._polyline.addPoint(ls.start);
            this._polyline.addPoint(ls.end);
            t.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(ls.start, ls.end);
            curve = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__.SmoothedPolyline.mkFromPoints(this._polyline).createCurve();
        }
        else {
            // try three variants with two segments
            const takenOutPoint = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.Curve, this.targetPort.Parameter, this.TargetLoosePolyline);
            ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(sourcePortLocation, takenOutPoint);
            if (this.InsideOfTheAllowedConeOfBoundaryPort(takenOutPoint, this.SourcePort) &&
                this.LineAvoidsTightHierarchyLP(ls, this._sourceTightPolyline)) {
                this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
                this._polyline.addPoint(ls.start);
                this._polyline.addPoint(ls.end);
                this._polyline.addPoint(targetPortLocation);
                curve = this.SmoothCornersAndReturnCurve(smooth, t);
            }
            else {
                ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.StartPointOfEdgeRouting, targetPortLocation);
                if (this.InsideOfTheAllowedConeOfBoundaryPort(this.StartPointOfEdgeRouting, this.TargetPort) &&
                    this.LineAvoidsTightHierarchy(ls)) {
                    this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
                    this._polyline.addPoint(sourcePortLocation);
                    this._polyline.addPoint(ls.start);
                    this._polyline.addPoint(ls.end);
                    curve = this.SmoothCornersAndReturnCurve(smooth, t);
                }
                else {
                    // we still can make the polyline with two segs when the port sticking segs are intersecting
                    let x;
                    if ((x = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.IntersectPPPP(sourcePortLocation, this.StartPointOfEdgeRouting, targetPortLocation, takenOutPoint))) {
                        this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
                        this._polyline.addPoint(sourcePortLocation);
                        this._polyline.addPoint(x);
                        this._polyline.addPoint(targetPortLocation);
                        curve = this.SmoothCornersAndReturnCurve(smooth, t);
                    }
                    else if (___WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(this.StartPointOfEdgeRouting, takenOutPoint)) {
                        this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
                        this._polyline.addPoint(sourcePortLocation);
                        this._polyline.addPoint(takenOutPoint);
                        this._polyline.addPoint(targetPortLocation);
                        curve = this.SmoothCornersAndReturnCurve(smooth, t);
                    }
                    else if (this.LineAvoidsTightHierarchy(_math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.StartPointOfEdgeRouting, takenOutPoint))) {
                        // can we do three segments?
                        this._polyline = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
                        this._polyline.addPoint(sourcePortLocation);
                        this._polyline.addPoint(this.StartPointOfEdgeRouting);
                        this._polyline.addPoint(takenOutPoint);
                        this._polyline.addPoint(targetPortLocation);
                        curve = this.SmoothCornersAndReturnCurve(smooth, t);
                    }
                    else {
                        this.ExtendVisibilityGraphToTargetBoundaryPort(takenOutPoint);
                        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
                        const r = { tmpTargetTight: null };
                        const tmpSourceTight = this.HideSourceTargetTightsIfNeeded(r);
                        this.RecoverSourceTargetTights(tmpSourceTight, r.tmpTargetTight);
                        this._polyline.PrependPoint(sourcePortLocation);
                        this._polyline.addPoint(targetPortLocation);
                        curve = this.SmoothCornersAndReturnCurve(smooth, t);
                    }
                }
            }
        }
        return curve;
    }
    RecoverSourceTargetTights(tmpSourceTight, tmpTargetTight) {
        this.SourceTightPolyline = tmpSourceTight;
        this.TargetTightPolyline = tmpTargetTight;
    }
    HideSourceTargetTightsIfNeeded(t) {
        const tmpSourceTight = this.SourceTightPolyline;
        t.tmpTargetTight = this.TargetTightPolyline;
        this.TargetTightPolyline = null;
        this.SourceTightPolyline = null;
        return tmpSourceTight;
    }
    LineAvoidsTightHierarchy(lineSegment) {
        return (InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(lineSegment, this.ObstacleCalculator.RootOfTightHierarchy)
            .length === 0);
    }
    RouteFromFloatingPortToBoundaryPort(smooth, r) {
        const targetPortLocation = this.targetPort.Location;
        let ls;
        if (this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.Location, this.targetPort)) {
            ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.SourcePort.Location, targetPortLocation);
            if (this.LineCanBeAcceptedForRouting(ls)) {
                r.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(ls.start, ls.end);
                return ls;
            }
        }
        const takenOutTargetPortLocation = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.TargetPort.Curve, this.TargetPort.Parameter, this.TargetLoosePolyline);
        // can we do with just two line segments?
        ls = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(this.SourcePort.Location, takenOutTargetPortLocation);
        if (this.LineAvoidsTightHierarchyLP(ls, this._sourceTightPolyline)) {
            this._polyline = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline.mkFromPoints([ls.start, ls.end, targetPortLocation]);
            r.smoothedPolyline = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_8__.SmoothedPolyline.mkFromPoints(this._polyline);
            return r.smoothedPolyline.createCurve();
        }
        this.ExtendVisibilityGraphToTargetBoundaryPort(takenOutTargetPortLocation);
        this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
        this._polyline.addPoint(targetPortLocation);
        const t = { smoothedPolyline: null };
        return this.SmoothCornersAndReturnCurve(smooth, t);
    }
    LineAvoidsTightHierarchyLP(ls, polylineToExclude) {
        let lineIsGood = true;
        for (const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfTightHierarchy)) {
            if (ii.seg1 !== polylineToExclude) {
                lineIsGood = false;
                break;
            }
        }
        return lineIsGood;
    }
    LineAvoidsTightHierarchyLPP(ls, polylineToExclude0, polylineToExclude1) {
        let lineIsGood = true;
        for (const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls, this.ObstacleCalculator.RootOfTightHierarchy)) {
            if (!(ii.seg1 === polylineToExclude0 || ii.seg1 === polylineToExclude1)) {
                lineIsGood = false;
                break;
            }
        }
        return lineIsGood;
    }
    LineAvoidsTightHierarchyPPPP(a, b, polylineToExclude0, polylineToExclude1) {
        return this.LineAvoidsTightHierarchyLPP(_math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(a, b), polylineToExclude0, polylineToExclude1);
    }
    ExtendVisibilityGraphToTargetBoundaryPort(takenOutTargetPortLocation) {
        let addedPolygons = null;
        if (this.VisibilityGraph == null) {
            this.VisibilityGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_15__.VisibilityGraph();
        }
        if (!this.activeRectangle.contains(takenOutTargetPortLocation) ||
            !this.activeRectangle.containsRect(this.TargetLoosePolyline.boundingBox)) {
            if (this.activeRectangle.isEmpty) {
                this.activeRectangle = this.TargetLoosePolyline.boundingBox.clone();
                this.activeRectangle.add(this.SourcePort.Location);
                this.activeRectangle.add(this.StartPointOfEdgeRouting);
                this.activeRectangle.add(takenOutTargetPortLocation);
            }
            else {
                this.activeRectangle.add(takenOutTargetPortLocation);
                this.activeRectangle.addRec(this.TargetLoosePolyline.boundingBox);
            }
            addedPolygons = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
            for (const polygon of addedPolygons) {
                this.VisibilityGraph.AddHole(polygon.Polyline);
            }
        }
        if (addedPolygons == null) {
            if (this.targetVV != null) {
                this.VisibilityGraph.RemoveVertex(this.targetVV);
            }
            this.CalculateEdgeTargetVisibilityGraph(takenOutTargetPortLocation);
        }
        else {
            this.RemovePointVisibilityGraphs();
            const visibilityGraphGenerator = new _visibility_InteractiveTangentVisibilityGraphCalculator__WEBPACK_IMPORTED_MODULE_18__.InteractiveTangentVisibilityGraphCalculator(addedPolygons, this.activePolygons, this.VisibilityGraph);
            visibilityGraphGenerator.run();
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_19__.addRange)(this.activePolygons, addedPolygons);
            this.CalculateEdgeTargetVisibilityGraph(takenOutTargetPortLocation);
            this.CalculateSourcePortVisibilityGraph();
        }
    }
    // returns the hit object
    GetHitLoosePolyline(point) {
        if (this.ObstacleCalculator.IsEmpty() || this.ObstacleCalculator.RootOfLooseHierarchy == null) {
            return null;
        }
        return InteractiveEdgeRouter.GetFirstHitPolyline(point, this.ObstacleCalculator.RootOfLooseHierarchy);
    }
    static GetFirstHitPolyline(point, rectangleNode) {
        const rectNode = InteractiveEdgeRouter.GetFirstHitRectangleNode(point, rectangleNode);
        return rectNode ? rectNode.UserData : null;
    }
    static GetFirstHitRectangleNode(point, rectangleNode) {
        if (rectangleNode == null) {
            return null;
        }
        return rectangleNode.FirstHitNodeWithPredicate(point, (pnt, polyline) => _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.PointRelativeToCurveLocation(pnt, polyline) !== _math_geometry__WEBPACK_IMPORTED_MODULE_4__.PointLocation.Outside ? _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_7__.HitTestBehavior.Stop : _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_7__.HitTestBehavior.Continue);
    }
    //
    Clean() {
        this.TargetPort = null;
        this.SourcePort = null;
        this.SourceTightPolyline = null;
        this.SourceLoosePolyline = null;
        this.TargetLoosePolyline = null;
        this.targetTightPolyline = null;
        this.VisibilityGraph = null;
        this.targetVV = null;
        this.sourceVV = null;
        this.activePolygons = [];
        this.alreadyAddedOrExcludedPolylines.clear();
        this.activeRectangle.setToEmpty();
    }
    // setting source port and the loose polyline of the port
    SetSourcePortAndSourceLoosePolyline(port, sourceLoosePolylinePar) {
        this.SourceLoosePolyline = sourceLoosePolylinePar;
        this.sourcePort = port;
        if (this.sourcePort != null) {
            this.SourceTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.Location, this.ObstacleCalculator.RootOfTightHierarchy);
            if (this.sourcePort instanceof _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort) {
                this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline);
                // we need to exclude the loose polyline around the source port from the tangent visibily graph
                this.StartPointOfEdgeRouting = this.SourcePort.Location;
            }
            else {
                this.StartPointOfEdgeRouting = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve, this.sourcePort.Parameter, this.SourceLoosePolyline);
            }
        }
    }
    run() {
        this.CalculateWholeTangentVisibilityGraph();
    }
    CalculateWholeTangentVisibilityGraph() {
        this.VisibilityGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_15__.VisibilityGraph();
        this.CalculateWholeVisibilityGraphOnExistingGraph();
    }
    CalculateWholeVisibilityGraphOnExistingGraph() {
        this.activePolygons = Array.from(this.AllPolygons());
        for (const polylineLocal of this.ObstacleCalculator.LooseObstacles) {
            this.VisibilityGraph.AddHole(polylineLocal);
        }
        let visibilityGraphGenerator;
        if (this.UseSpanner) {
            visibilityGraphGenerator = new _spline_coneSpanner_ConeSpanner__WEBPACK_IMPORTED_MODULE_12__.ConeSpanner(this.ObstacleCalculator.LooseObstacles, this.VisibilityGraph);
        }
        else {
            visibilityGraphGenerator = new _visibility_InteractiveTangentVisibilityGraphCalculator__WEBPACK_IMPORTED_MODULE_18__.InteractiveTangentVisibilityGraphCalculator(new Array(), this.activePolygons, this.visibilityGraph);
        }
        visibilityGraphGenerator.run();
    }
    RouteSplineFromPortToPortWhenTheWholeGraphIsReady(sourcePortLocal, targetPortLocal, smooth, t) {
        const reversed = (sourcePortLocal instanceof _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort && targetPortLocal instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__.CurvePort) ||
            sourcePortLocal instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_3__.HookUpAnywhereFromInsidePort;
        if (reversed) {
            const tmp = sourcePortLocal;
            sourcePortLocal = targetPortLocal;
            targetPortLocal = tmp;
        }
        this.sourcePort = sourcePortLocal;
        this.targetPort = targetPortLocal;
        this.FigureOutSourceTargetPolylinesAndActiveRectangle();
        let curve = this.GetEdgeGeomByRouting(smooth, t);
        if (curve == null) {
            return null;
        }
        this.targetVV = null;
        this.sourceVV = null;
        if (reversed) {
            curve = curve.reverse();
        }
        return curve;
    }
    GetEdgeGeomByRouting(smooth, t) {
        this.sourceIsInsideOfTargetTightPolyline =
            this.TargetTightPolyline == null ||
                _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.PointRelativeToCurveLocation(this.sourcePort.Location, this.TargetTightPolyline) === _math_geometry__WEBPACK_IMPORTED_MODULE_4__.PointLocation.Inside;
        let curve;
        if (this.sourcePort instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__.CurvePort) {
            const curvePort = this.sourcePort;
            this.StartPointOfEdgeRouting = !this.targetIsInsideOfSourceTightPolyline
                ? this.TakeBoundaryPortOutsideOfItsLoosePolyline(curvePort.Curve, curvePort.Parameter, this.SourceLoosePolyline)
                : curvePort.Location;
            this.CalculateSourcePortVisibilityGraph();
            const t = { smoothedPolyline: null };
            if (this.targetPort instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_1__.CurvePort) {
                curve = this.RouteFromBoundaryPortToBoundaryPort(smooth, t);
            }
            else {
                curve = this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline, smooth, t);
            }
        }
        else if (this.targetPort instanceof _layout_core_floatingPort__WEBPACK_IMPORTED_MODULE_2__.FloatingPort) {
            this.ExtendVisibilityGraphFromFloatingSourcePort();
            // Assert.assert(this.sourceVV != null)
            // the edge has to be reversed to route from CurvePort to FloatingPort
            curve = this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline, smooth, t);
        }
        else {
            // Assert.assert(this.targetPort instanceof HookUpAnywhereFromInsidePort)
            curve = this.RouteFromFloatingPortToAnywherePort(this.targetPort.LoosePolyline, smooth, t, this.targetPort);
        }
        return curve;
    }
    RouteFromFloatingPortToAnywherePort(targetLoosePoly, smooth, t, port) {
        if (!port.Curve.boundingBox.contains(this.sourcePort.Location)) {
            t.smoothedPolyline = null;
            return null;
        }
        this.sourceVV = this.GetVertex(this.sourcePort.Location);
        this._polyline = this.GetShortestPolylineToMulitpleTargets(this.sourceVV, Array.from(this.Targets(targetLoosePoly)));
        if (this._polyline == null) {
            return null;
        }
        this.FixLastPolylinePointForAnywherePort(port);
        if (port.HookSize > 0) {
            this.BuildHook(port);
        }
        return this.SmoothCornersAndReturnCurve(smooth, t);
    }
    BuildHook(port) {
        const curve = port.Curve;
        // creating a hook
        const ellipse = _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_5__.Ellipse.mkFullEllipseNNP(port.HookSize, port.HookSize, this._polyline.end);
        const intersections = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.getAllIntersections(curve, ellipse, true);
        // Assert.assert(intersections.length === 2)
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(intersections[0].x, this._polyline.end, this._polyline.endPoint.prev.point) ==
            _math_geometry_point__WEBPACK_IMPORTED_MODULE_6__.TriangleOrientation.Counterclockwise) {
            intersections.reverse();
        }
        // so the [0] point is to the left of the Polyline
        const polylineTangent = this._polyline.end.sub(this._polyline.endPoint.prev.point).normalize();
        const tan0 = curve.derivative(intersections[0].par0).normalize();
        const prj0 = tan0.dot(polylineTangent);
        if (Math.abs(prj0) < 0.2) {
            this.ExtendPolyline(tan0, intersections[0], polylineTangent, port);
        }
        else {
            const tan1 = curve.derivative(intersections[1].par0).normalize();
            const prj1 = tan1.dot(polylineTangent);
            if (prj1 < prj0) {
                this.ExtendPolyline(tan1, intersections[1], polylineTangent, port);
            }
            else {
                this.ExtendPolyline(tan0, intersections[0], polylineTangent, port);
            }
        }
    }
    ExtendPolyline(tangentAtIntersection, x, polylineTangent, port) {
        let normal = tangentAtIntersection.rotate(Math.PI / 2);
        if (normal.dot(polylineTangent) < 0) {
            normal = normal.neg();
        }
        const pointBeforeLast = x.x.add(normal.mul(port.HookSize));
        let pointAfterX;
        if (!(pointAfterX = ___WEBPACK_IMPORTED_MODULE_0__.Point.lineLineIntersection(pointBeforeLast, pointBeforeLast.add(tangentAtIntersection), this._polyline.end, this._polyline.end.add(polylineTangent)))) {
            return;
        }
        this._polyline.addPoint(pointAfterX);
        this._polyline.addPoint(pointBeforeLast);
        this._polyline.addPoint(x.x);
    }
    FixLastPolylinePointForAnywherePort(port) {
        while (true) {
            const lastPointInside = this.GetLastPointInsideOfCurveOnPolyline(port.Curve);
            lastPointInside.next.next = null;
            this._polyline.endPoint = lastPointInside.next;
            let dir = lastPointInside.next.point.sub(lastPointInside.point);
            dir = dir.normalize().mul(port.Curve.boundingBox.diagonal);
            // make it a long vector
            const dir0 = dir.rotate(port.AdjustmentAngle * -1);
            const dir1 = dir.rotate(port.AdjustmentAngle);
            const rx = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.intersectionOne(port.Curve, _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(lastPointInside.point, lastPointInside.point.add(dir0)), true);
            const lx = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.intersectionOne(port.Curve, _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(lastPointInside.point, lastPointInside.point.add(dir1)), true);
            if (rx == null || lx == null) {
                return;
            }
            // this.ShowPolylineAndObstacles(Polyline, LineSegment.mkPP(lastPointInside.Point, lastPointInside.Point+dir0), LineSegment.mkPP(lastPointInside.Point, rerPoint+dir1), port.Curve);
            const trimmedCurve = InteractiveEdgeRouter.GetTrimmedCurveForHookingUpAnywhere(port.Curve, lastPointInside, rx, lx);
            const newLastPoint = trimmedCurve.value(trimmedCurve.closestParameter(lastPointInside.point));
            if (!this.LineAvoidsTightHierarchyLPP(_math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(lastPointInside.point, newLastPoint), this.SourceTightPolyline, null)) {
                const xx = _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.intersectionOne(port.Curve, _math_geometry__WEBPACK_IMPORTED_MODULE_4__.LineSegment.mkPP(lastPointInside.point, lastPointInside.next.point), false);
                if (xx == null) {
                    return;
                }
                // this.ShowPolylineAndObstacles(Polyline, port.Curve);
                this._polyline.endPoint.point = xx.x;
                break;
            }
            this._polyline.endPoint.point = newLastPoint;
            if (lastPointInside.prev == null || !this.TryShortcutPolyPoint(lastPointInside.prev)) {
                break;
            }
        }
    }
    static GetTrimmedCurveForHookingUpAnywhere(curve, lastPointInside, x0, x1) {
        const clockwise = ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(x1.x, x0.x, lastPointInside.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_6__.TriangleOrientation.Clockwise;
        const rightX = x0.par0;
        const leftX = x1.par0;
        let tr1;
        let tr0;
        let ret;
        if (clockwise) {
            if (rightX < leftX) {
                return curve.trim(rightX, leftX);
            }
            tr0 = curve.trim(rightX, curve.parEnd);
            tr1 = curve.trim(curve.parStart, leftX);
            ret = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve();
            return ret.addSegs([tr0, tr1]);
        }
        if (leftX < rightX) {
            return curve.trim(leftX, rightX);
        }
        tr0 = curve.trim(leftX, curve.parEnd);
        tr1 = curve.trim(curve.parStart, rightX);
        ret = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve();
        return ret.addSegs([tr0, tr1]);
    }
    GetLastPointInsideOfCurveOnPolyline(curve) {
        for (let p = this._polyline.endPoint.prev; p != null; p = p.prev) {
            if (p.prev == null) {
                return p;
            }
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_4__.Curve.PointRelativeToCurveLocation(p.point, curve) === _math_geometry__WEBPACK_IMPORTED_MODULE_4__.PointLocation.Inside) {
                return p;
            }
        }
        throw new Error();
    }
    GetShortestPolylineToMulitpleTargets(sourceVisVertex, targets) {
        this.CleanTheGraphForShortestPath();
        // ShowPolylineAndObstacles(targets.Select(t=>new Ellipse(3,3,t.Point)).ToArray());
        const pathCalc = new _SingleSourceMultipleTargetsShortestPathOnVisibilityGraph__WEBPACK_IMPORTED_MODULE_10__.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph(sourceVisVertex, targets, this.VisibilityGraph);
        // { dd = ShowPolylineAndObstacles };
        const path = pathCalc.GetPath();
        if (path == null) {
            return null;
        }
        // Assert.assert(((from(path).first() === sourceVisVertex)
        //                && targets.contains(path.last())));
        const ret = new _math_geometry__WEBPACK_IMPORTED_MODULE_4__.Polyline();
        for (const v of path) {
            ret.addPoint(v.point);
        }
        return ret.RemoveCollinearVertices();
    }
    Targets(targetLoosePoly) {
        return Array.from(targetLoosePoly).map((p) => this.visibilityGraph.FindVertex(p));
    }
    ExtendVisibilityGraphFromFloatingSourcePort() {
        const fp = this.sourcePort;
        // Assert.assert(this.sourcePort instanceof FloatingPort)
        this.StartPointOfEdgeRouting = fp.Location;
        if (this.UseSpanner) {
            this.sourceVV = this.AddTransientVisibilityEdgesForPort(this.sourcePort.Location, this.SourceLoosePolyline);
        }
        else {
            this.sourceVV = _visibility_PointVisibilityCalculator__WEBPACK_IMPORTED_MODULE_20__.PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()).filter((p) => p !== this.SourceLoosePolyline), this.VisibilityGraph, this.StartPointOfEdgeRouting, _visibility_VisibilityKind__WEBPACK_IMPORTED_MODULE_16__.VisibilityKind.Tangent);
        }
    }
    FigureOutSourceTargetPolylinesAndActiveRectangle() {
        let p = this.sourcePort.Curve.value(this.sourcePort.Curve.parStart);
        this._sourceTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(p, this.ObstacleCalculator.RootOfTightHierarchy);
        this.SourceLoosePolyline = InteractiveEdgeRouter.GetFirstHitPolyline(p, this.ObstacleCalculator.RootOfLooseHierarchy);
        p = this.targetPort.Curve.value(this.targetPort.Curve.parStart);
        this.targetTightPolyline = InteractiveEdgeRouter.GetFirstHitPolyline(p, this.ObstacleCalculator.RootOfTightHierarchy);
        this.targetLoosePolyline = InteractiveEdgeRouter.GetFirstHitPolyline(p, this.ObstacleCalculator.RootOfLooseHierarchy);
        this.activeRectangle = ___WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkPP(new ___WEBPACK_IMPORTED_MODULE_0__.Point(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY), new ___WEBPACK_IMPORTED_MODULE_0__.Point(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY));
    }
    *AllPolygons() {
        for (const p of this.ObstacleCalculator.LooseObstacles) {
            yield new _visibility_Polygon__WEBPACK_IMPORTED_MODULE_13__.Polygon(p);
        }
    }
    //
    GetVisibilityGraph() {
        return this.VisibilityGraph;
    }
    // ShowObstaclesAndVisGraph() {
    //    let obs = this.ObstacleCalculator.LooseObstacles.Select(() => {  }, new DebugCurve(100, 1, "blue", o));
    //    let edges = this.visibilityGraph.Edges.Select(() => {  }, new DebugCurve(70, 1, (e instanceof  "red"), LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));
    //    // TODO: Warning!!!, inline IF is not supported ?
    //    TransientVisibilityEdge;
    //    "green";
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(obs.Concat(edges));
    // }
    AddActivePolygons(polygons) {
        (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_19__.addRange)(this.activePolygons, polygons);
    }
    ClearActivePolygons() {
        this.activePolygons = [];
    }
}
//# sourceMappingURL=interactiveEdgeRouter.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/interactiveObstacleCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InteractiveObstacleCalculator: () => (/* binding */ InteractiveObstacleCalculator)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/convexHull.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/graphAlgorithms/ConnectedComponentCalculator.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _visibility_Polygon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/Polygon.js");














class InteractiveObstacleCalculator {
    ObstaclesIntersectLine(a, b) {
        return this.ObstaclesIntersectICurve(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(a, b));
    }
    static PadCorner(localpoly, p0, p1, p2, padding) {
        const padInfo = InteractiveObstacleCalculator.GetPaddedCorner(p0, p1, p2, padding);
        if (padInfo.numberOfPoints === -1) {
            return false;
        }
        localpoly.addPoint(padInfo.a);
        if (padInfo.numberOfPoints === 2) {
            localpoly.addPoint(padInfo.b);
        }
        return true;
    }
    static CurveIsClockwise(iCurve, pointInside) {
        return (_math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.getTriangleOrientation(pointInside, iCurve.start, iCurve.start.add(iCurve.derivative(iCurve.parStart))) ==
            _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.TriangleOrientation.Clockwise);
    }
    static PaddedPolylineBoundaryOfNode(curve, padding, randomizePoints = false) {
        return InteractiveObstacleCalculator.CreatePaddedPolyline(_math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.polylineAroundClosedCurve(curve), padding, randomizePoints);
    }
    /** surrounds the given polyline with the given offset, optionally randomizes the output */
    static LoosePolylineWithFewCorners(tightPolyline, p, randomizationShift) {
        if (p < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
            return tightPolyline;
        }
        return InteractiveObstacleCalculator.CreateLoosePolylineOnBisectors(tightPolyline, p, randomizationShift);
    }
    static CreateLoosePolylineOnBisectors(tightPolyline, offset, randomizationShift) {
        const ps = Array.from(InteractiveObstacleCalculator.BisectorPoints(tightPolyline, offset));
        if (randomizationShift)
            randomizePoints();
        const convHull = _math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_1__.ConvexHull.CalculateConvexHull(ps);
        return _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline.mkClosedFromPoints(convHull);
        function randomizePoints() {
            for (let i = 0; i < ps.length; i++) {
                const p = ps[i];
                ps[i] = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point(p.x + (2 * (0,_utils_random__WEBPACK_IMPORTED_MODULE_11__.random)() - 1) * randomizationShift, p.y + (2 * (0,_utils_random__WEBPACK_IMPORTED_MODULE_11__.random)() - 1) * randomizationShift);
            }
        }
    }
    static CreateRectNodeOfPolyline(polyline) {
        return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_6__.mkRectangleNode)(polyline, polyline.boundingBox);
    }
    CreateLooseObstacles() {
        this.tightPolylinesToLooseDistances = new Map();
        this.LooseObstacles = new Array();
        for (const tightPolyline of this.TightObstacles) {
            const distance = InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(this.RootOfTightHierarchy, tightPolyline, this.LoosePadding);
            this.tightPolylinesToLooseDistances.set(tightPolyline, distance);
            this.LooseObstacles.push(InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline, distance, this.randomizationShift));
        }
        this.RootOfLooseHierarchy = InteractiveObstacleCalculator.CalculateHierarchy(this.LooseObstacles);
        // Assert.assert(
        //  InteractiveObstacleCalculator.GetOverlappedPairSet(this.RootOfLooseHierarchy).size === 0,
        //  'Overlaps are found in LooseObstacles',
        // )
    }
    CreateTightObstacles() {
        this.RootOfTightHierarchy = this.CreateTightObstacles_();
        this.OverlapsDetected = this.TightObstacles.size < this.Obstacles.length;
    }
    Calculate() {
        if (this.IgnoreTightPadding)
            this.CreateTightObstaclesIgnoringTightPadding();
        else
            this.CreateTightObstacles();
        if (!this.IsEmpty())
            this.CreateLooseObstacles();
    }
    IsEmpty() {
        return this.TightObstacles == null || this.TightObstacles.size === 0;
    }
    constructor(obstacles, tightPadding, loosePadding, ignoreTightPadding) {
        /** if set to true the vertices of the loose polylines would be randomly shifted by a small amont */
        this.randomizationShift = 0.01;
        this.TightObstacles = new Set();
        this.Obstacles = obstacles;
        this.TightPadding = tightPadding;
        this.LoosePadding = loosePadding;
        this.IgnoreTightPadding = ignoreTightPadding;
    }
    ObstaclesIntersectICurve(curve) {
        const rect = curve.boundingBox;
        return InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, rect, this.RootOfTightHierarchy);
    }
    static CurveIntersectsRectangleNode(curve, curveBox, rectNode) {
        if (!rectNode.irect.intersects(curveBox)) {
            return false;
        }
        if (rectNode.UserData != null) {
            const curveUnderTest = rectNode.UserData;
            return (_math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.intersectionOne(curveUnderTest, curve, false) != null ||
                InteractiveObstacleCalculator.PointIsInside(curveUnderTest.start, curve));
        }
        // Assert.assert(rectNode.Left != null && rectNode.Right != null)
        return (InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, curveBox, rectNode.Left) ||
            InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve, curveBox, rectNode.Right));
    }
    static PointIsInside(point, curve) {
        return _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.PointRelativeToCurveLocation(point, curve) === _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.PointLocation.Inside;
    }
    CreateTightObstaclesIgnoringTightPadding() {
        const polysWithoutPadding = this.Obstacles.map((o) => _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.polylineAroundClosedCurve(o));
        const polylineHierarchy = InteractiveObstacleCalculator.CalculateHierarchy(polysWithoutPadding);
        const overlappingPairSet = InteractiveObstacleCalculator.GetOverlappedPairSet(polylineHierarchy);
        this.TightObstacles = new Set();
        if (overlappingPairSet.size === 0) {
            for (const polyline of polysWithoutPadding) {
                const distance = InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(polylineHierarchy, polyline, this.TightPadding);
                this.TightObstacles.add(InteractiveObstacleCalculator.LoosePolylineWithFewCorners(polyline, distance, this.randomizationShift));
            }
            this.RootOfTightHierarchy = InteractiveObstacleCalculator.CalculateHierarchy(Array.from(this.TightObstacles));
        }
        else {
            for (const localpoly of polysWithoutPadding) {
                this.TightObstacles.add(InteractiveObstacleCalculator.CreatePaddedPolyline(localpoly, this.TightPadding));
            }
            if (!this.IsEmpty()) {
                this.RootOfTightHierarchy = InteractiveObstacleCalculator.CalculateHierarchy(Array.from(this.TightObstacles));
                this.OverlapsDetected = false;
                while (InteractiveObstacleCalculator.GetOverlappedPairSet(this.RootOfTightHierarchy).size > 0) {
                    this.RootOfTightHierarchy = InteractiveObstacleCalculator.ReplaceTightObstaclesWithConvexHulls(this.TightObstacles, Array.from(overlappingPairSet));
                    this.OverlapsDetected = true;
                }
            }
        }
    }
    CreateTightObstacles_() {
        if (this.Obstacles.length === 0) {
            return null;
        }
        for (const curve of this.Obstacles) {
            InteractiveObstacleCalculator.CalculateTightPolyline(this.TightObstacles, this.TightPadding, curve);
        }
        return InteractiveObstacleCalculator.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(this.TightObstacles);
    }
    static CalculateTightPolyline(tightObstacles, tightPadding, curve) {
        const tightPoly = InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(curve, tightPadding);
        tightObstacles.add(tightPoly);
    }
    static CalculateHierarchy(polylines) {
        const rectNodes = polylines.map((polyline) => InteractiveObstacleCalculator.CreateRectNodeOfPolyline(polyline));
        return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_6__.CreateRectNodeOnArrayOfRectNodes)(rectNodes);
    }
    static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacleSet) {
        let hierarchy = InteractiveObstacleCalculator.CalculateHierarchy(Array.from(tightObstacleSet));
        let overlappingPairSet;
        while ((overlappingPairSet = InteractiveObstacleCalculator.GetOverlappedPairSet(hierarchy)).size > 0) {
            hierarchy = InteractiveObstacleCalculator.ReplaceTightObstaclesWithConvexHulls(tightObstacleSet, Array.from(overlappingPairSet));
        }
        return hierarchy;
    }
    static MapToInt(objects) {
        const ret = new Map();
        for (let i = 0; i < objects.length; i++) {
            ret.set(objects[i], i);
        }
        return ret;
    }
    static ReplaceTightObstaclesWithConvexHulls(tightObsts, overlappingPairSet) {
        const overlapping = new Set();
        for (const pair of overlappingPairSet) {
            overlapping.add(pair[0]);
            overlapping.add(pair[1]);
        }
        const intToPoly = Array.from(overlapping);
        const polyToInt = InteractiveObstacleCalculator.MapToInt(intToPoly);
        const graph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_9__.mkGraphOnEdgesArray)(Array.from(overlappingPairSet).map((pair) => new _utils_IntPair__WEBPACK_IMPORTED_MODULE_10__.IntPair(polyToInt.get(pair[0]), polyToInt.get(pair[1]))));
        const connectedComponents = (0,_math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_8__.GetConnectedComponents)(graph);
        for (const component of connectedComponents) {
            const polys = component.map((i) => intToPoly[i]);
            const points = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_12__.flattenArray)(polys, (p) => p);
            const convexHull = _math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_1__.ConvexHull.createConvexHullAsClosedPolyline(points);
            for (const localpoly of polys) {
                tightObsts.delete(localpoly);
            }
            tightObsts.add(convexHull);
        }
        return InteractiveObstacleCalculator.CalculateHierarchy(Array.from(tightObsts));
    }
    static OneCurveLiesInsideOfOther(polyA, polyB) {
        // Assert.assert(!Curve.CurvesIntersect(polyA, polyB), 'The curves should not intersect')
        return (_math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.PointRelativeToCurveLocation(polyA.start, polyB) !== _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.PointLocation.Outside ||
            _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.PointRelativeToCurveLocation(polyB.start, polyA) !== _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.PointLocation.Outside);
    }
    static PolylinesIntersect(a, b) {
        const ret = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_2__.Curve.CurvesIntersect(a, b) || InteractiveObstacleCalculator.OneCurveLiesInsideOfOther(a, b);
        return ret;
    }
    static GetOverlappedPairSet(rootOfObstacleHierarchy) {
        const overlappingPairSet = new Set();
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_7__.CrossRectangleNodesSameType)(rootOfObstacleHierarchy, rootOfObstacleHierarchy, (a, b) => {
            if (InteractiveObstacleCalculator.PolylinesIntersect(a, b)) {
                overlappingPairSet.add([a, b]);
            }
        });
        return overlappingPairSet;
    }
    static *BisectorPoints(tightPolyline, offset) {
        for (let pp = tightPolyline.startPoint; pp != null; pp = pp.next) {
            const t = { skip: false };
            const currentSticking = InteractiveObstacleCalculator.GetStickingVertexOnBisector(pp, offset, t);
            if (!t.skip) {
                yield currentSticking;
            }
        }
    }
    static GetStickingVertexOnBisector(pp, p, t) {
        const u = pp.polyline.prev(pp).point;
        const v = pp.point;
        const w = pp.polyline.next(pp).point;
        let z = v.sub(u).normalize().add(v.sub(w).normalize());
        const zLen = z.length;
        if (zLen < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.tolerance) {
            t.skip = true;
        }
        else {
            t.skip = false;
            z = z.div(zLen);
        }
        return z.mul(p).add(v);
    }
    static FindMaxPaddingForTightPolyline(hierarchy, polyline, desiredPadding) {
        let dist = desiredPadding;
        const polygon = new _visibility_Polygon__WEBPACK_IMPORTED_MODULE_13__.Polygon(polyline);
        const boundingBox = polyline.boundingBox.clone();
        boundingBox.pad(2 * desiredPadding);
        for (const localpoly of Array.from(hierarchy.GetNodeItemsIntersectingRectangle(boundingBox)).filter((p) => p !== polyline)) {
            const separation = _visibility_Polygon__WEBPACK_IMPORTED_MODULE_13__.Polygon.Distance(polygon, new _visibility_Polygon__WEBPACK_IMPORTED_MODULE_13__.Polygon(localpoly)).dist;
            dist = Math.min(dist, separation / InteractiveObstacleCalculator.LooseDistCoefficient);
        }
        return dist;
    }
    static GetPaddedCorner(first, second, third, padding) {
        const u = first.point;
        const v = second.point;
        const w = third.point;
        if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.getTriangleOrientation(u, v, w) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.TriangleOrientation.Counterclockwise) {
            return { a: undefined, b: undefined, numberOfPoints: -1 };
        }
        let uvPerp = v
            .sub(u)
            .rotate(Math.PI / 2)
            .normalize();
        if (InteractiveObstacleCalculator.CornerIsNotTooSharp(u, v, w)) {
            // the angle is not too sharp: just continue the offset lines of the sides and return their intersection
            uvPerp = uvPerp.mul(padding);
            const vwPerp = w
                .sub(v)
                .normalize()
                .mul(padding)
                .rotate(Math.PI / 2);
            const a = _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.lineLineIntersection(u.add(uvPerp), v.add(uvPerp), v.add(vwPerp), w.add(vwPerp));
            /*Assert.assert(a !== undefined)*/
            return { a: a, b: a, numberOfPoints: 1 };
        }
        const l = v.sub(u).normalize().add(v.sub(w).normalize());
        if (l.length < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.intersectionEpsilon) {
            const a = v.add(uvPerp.mul(padding));
            return { a: a, b: a, numberOfPoints: 1 };
        }
        const d = l.normalize().mul(padding);
        const dp = d.rotate(Math.PI / 2);
        // look for a in the form d+x*dp
        // we have:  Padding=(d+x*dp)*uvPerp
        const xp = (padding - d.dot(uvPerp)) / dp.dot(uvPerp);
        const dpxp = dp.mul(xp);
        return { a: d.add(dpxp).add(v), b: d.sub(dpxp).add(v), numberOfPoints: 2 };
    }
    static CornerIsNotTooSharp(u, v, w) {
        const a = u
            .sub(v)
            .rotate(Math.PI / 4)
            .add(v);
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.getTriangleOrientation(v, a, w) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.TriangleOrientation.Counterclockwise;
        //   return Point.Angle(u, v, w) > Math.PI / 4;
    }
    static CreatePaddedPolyline(poly, padding, randomizePoints = false) {
        /*Assert.assert(
          Point.getTriangleOrientation(
            localpoly.start,
            localpoly.startPoint.next.point,
            localpoly.startPoint.next.next.point,
          ) === TriangleOrientation.Clockwise,
          'Unpadded polyline is not clockwise',
        )*/
        const ret = new _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline();
        const localPoly = randomizePoints ? getPolyRandom(poly) : poly;
        if (!InteractiveObstacleCalculator.PadCorner(ret, localPoly.endPoint.prev, localPoly.endPoint, localPoly.startPoint, padding)) {
            return InteractiveObstacleCalculator.CreatePaddedPolyline(_math_geometry_polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline.mkClosedFromPoints(Array.from(_math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_1__.ConvexHull.CalculateConvexHull(localPoly))), padding);
        }
        if (!InteractiveObstacleCalculator.PadCorner(ret, localPoly.endPoint, localPoly.startPoint, localPoly.startPoint.next, padding)) {
            return InteractiveObstacleCalculator.CreatePaddedPolyline(_math_geometry_polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline.mkClosedFromPoints(Array.from(_math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_1__.ConvexHull.CalculateConvexHull(localPoly))), padding);
        }
        for (let pp = localPoly.startPoint; pp.next.next != null; pp = pp.next) {
            if (!InteractiveObstacleCalculator.PadCorner(ret, pp, pp.next, pp.next.next, padding)) {
                return InteractiveObstacleCalculator.CreatePaddedPolyline(_math_geometry_polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline.mkClosedFromPoints(Array.from(_math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_1__.ConvexHull.CalculateConvexHull(localPoly))), padding);
            }
        }
        /*Assert.assert(
          Point.getTriangleOrientation(
            ret.start,
            ret.startPoint.next.point,
            ret.startPoint.next.next.point,
          ) !== TriangleOrientation.Counterclockwise,
          'Padded polyline is counterclockwise',
        )*/
        ret.closed = true;
        return ret;
    }
}
InteractiveObstacleCalculator.LooseDistCoefficient = 2.1;
function getPolyRandom(poly) {
    const ret = new _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline();
    const eps = 0.01;
    for (let p = poly.startPoint; p; p = p.next) {
        const x = p.point.x + eps * (0,_utils_random__WEBPACK_IMPORTED_MODULE_11__.random)();
        const y = p.point.y + eps * (0,_utils_random__WEBPACK_IMPORTED_MODULE_11__.random)();
        ret.addPointXY(x, y);
    }
    ret.closed = poly.closed;
    return ret;
}
//# sourceMappingURL=interactiveObstacleCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/AxisCoordinateEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisCoordinateEvent: () => (/* binding */ AxisCoordinateEvent)
/* harmony export */ });
/* harmony import */ var _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");

class AxisCoordinateEvent extends _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    constructor(p) {
        super();
        this.site = p;
    }
    get Site() {
        return this.site;
    }
}
//# sourceMappingURL=AxisCoordinateEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/BasicObstacleSide.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicObstacleSide: () => (/* binding */ BasicObstacleSide),
/* harmony export */   HighObstacleSide: () => (/* binding */ HighObstacleSide),
/* harmony export */   LowObstacleSide: () => (/* binding */ LowObstacleSide)
/* harmony export */ });
/* harmony import */ var _spline_coneSpanner_ObstacleSide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ObstacleSide.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");
// BasicObstacleSide is base class for an obstacle side that is to the low or high end of the
// scanline-parallel coordinate, and knows which direction to traverse to find the endVertex.
// This is different from RightObstacleSide or LeftObstacleSide, where the class itself is the
// determinant of traversal direction being with or opposite to the clockwise polyline direction;


// BasicObstacleSide uses the ctor arg traverseClockwise to manage that.
class BasicObstacleSide extends _spline_coneSpanner_ObstacleSide__WEBPACK_IMPORTED_MODULE_0__.ObstacleSide {
    get Obstacle() {
        return this.obstacle;
    }
    set Obstacle(value) {
        this.obstacle = value;
    }
    constructor(obstacle, startVertex, scanDir, traverseClockwise) {
        super(startVertex);
        this.Slope = 0;
        this.SlopeInverse = 0;
        this.Obstacle = obstacle;
        this.endVertex = traverseClockwise ? startVertex.nextOnPolyline : startVertex.prevOnPolyline;
        if (!scanDir.IsPerpendicularPP(startVertex.point, this.endVertex.point)) {
            this.Slope = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_1__.StaticGraphUtility.Slope(startVertex.point, this.endVertex.point, scanDir);
            this.SlopeInverse = 1 / this.Slope;
        }
    }
    get EndVertex() {
        return this.endVertex;
    }
}
class LowObstacleSide extends BasicObstacleSide {
    constructor(obstacle, startVertex, scanDir) {
        super(obstacle, startVertex, scanDir, scanDir.IsHorizontal);
    }
}
class HighObstacleSide extends BasicObstacleSide {
    constructor(obstacle, startVertex, scanDir) {
        super(obstacle, startVertex, scanDir, scanDir.IsVertical);
    }
}
//# sourceMappingURL=BasicObstacleSide.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/BasicVertexEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicVertexEvent: () => (/* binding */ BasicVertexEvent)
/* harmony export */ });
/* harmony import */ var _spline_coneSpanner_VertexEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/VertexEvent.js");

class BasicVertexEvent extends _spline_coneSpanner_VertexEvent__WEBPACK_IMPORTED_MODULE_0__.VertexEvent {
    constructor(obstacle, p) {
        super(p);
        this.Obstacle = obstacle;
    }
}
//# sourceMappingURL=BasicVertexEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/EventQueue.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventQueue: () => (/* binding */ EventQueue)
/* harmony export */ });
/* harmony import */ var _structs_BinaryHeapWithComparer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/BinaryHeapWithComparer.js");
/* harmony import */ var _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/basicReflectionEvent.js");
// Wrap the tree of events.


class EventQueue {
    constructor() {
        this.eventTree = new _structs_BinaryHeapWithComparer__WEBPACK_IMPORTED_MODULE_0__.BinaryHeapWithComparer((a, b) => this.Compare(a, b));
    }
    Reset(scanDir) {
        /*Assert.assert(0 === this.eventTree.Count, 'Stray events in EventQueue.Reset')*/
        this.scanDirection = scanDir;
    }
    Enqueue(evt) {
        this.eventTree.Enqueue(evt);
    }
    Dequeue() {
        const evt = this.eventTree.Dequeue();
        return evt;
    }
    get Count() {
        return this.eventTree.Count;
    }
    Compare(lhs, rhs) {
        if (lhs === rhs) {
            return 0;
        }
        if (lhs == null) {
            return -1;
        }
        if (rhs == null) {
            return 1;
        }
        // First see if it's at the same scanline level (perpendicular coordinate).
        let cmp = this.scanDirection.ComparePerpCoord(lhs.Site, rhs.Site);
        if (cmp)
            return cmp;
        // Event sites are at the same scanline level. Make sure that any reflection events are lowest (come before
        // any side events, which could remove the side the reflection event was queued for).  We may have two
        // reflection events at same coordinate, because we enqueue in two situations: when a side is opened,
        // and when a side that is within that side's scanline-parallel span is closed.
        const lhsIsNotReflection = !(lhs instanceof _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_1__.BasicReflectionEvent) ? 1 : 0;
        const rhsIsNotReflection = !(rhs instanceof _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_1__.BasicReflectionEvent) ? 1 : 0;
        cmp = lhsIsNotReflection - rhsIsNotReflection;
        // If the scanline-parallel coordinate is the same these events are at the same point.
        if (cmp)
            return cmp;
        return this.scanDirection.CompareScanCoord(lhs.Site, rhs.Site);
    }
}
//# sourceMappingURL=EventQueue.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/FreePoint.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreePoint: () => (/* binding */ FreePoint)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _ScanSegment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");
// This is a point on a path that is not associated with an obstacle, such as
// a port for the end of a dragged path, or a waypoint.




class FreePoint {
    get Point() {
        return this.Vertex.point;
    }
    get InitialWeight() {
        return this.IsOverlapped ? _ScanSegment__WEBPACK_IMPORTED_MODULE_2__.ScanSegment.OverlappedWeight : _ScanSegment__WEBPACK_IMPORTED_MODULE_2__.ScanSegment.NormalWeight;
    }
    get IsOutOfBounds() {
        return _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Direction.None !== this.OutOfBoundsDirectionFromGraph;
    }
    // Called if we must create the vertex.
    constructor(transUtil, point) {
        this.maxVisibilitySegmentsAndCrossings = new Array(4);
        this.OutOfBoundsDirectionFromGraph = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Direction.None;
        this.GetVertex(transUtil, point);
    }
    GetVertex(transUtil, point) {
        this.Vertex = transUtil.FindOrAddVertex(point);
    }
    // Adds an edge from this.Vertex to a (possibly new) vertex at an intersection with an
    // existing Edge that adjoins the point.  We take 'dir' as an input parameter for edge
    // extension because we may be on the edge so can't calculate the direction.
    AddEdgeToAdjacentEdge(transUtil, targetEdge, dirToExtend, limitRect) {
        const targetIntersect = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_3__.StaticGraphUtility.SegmentIntersectionEP(targetEdge, this.Point);
        let targetVertex = transUtil.VisGraph.FindVertex(targetIntersect);
        if (null != targetVertex) {
            this.AddToAdjacentVertex(transUtil, targetVertex, dirToExtend, limitRect);
        }
        else {
            targetVertex = transUtil.AddEdgeToTargetEdge(this.Vertex, targetEdge, targetIntersect);
        }
        this.ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect);
        return targetVertex;
    }
    AddToAdjacentVertex(transUtil, targetVertex, dirToExtend, limitRect) {
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_1__.PointComparer.EqualPP(this.Point, targetVertex.point)) {
            transUtil.FindOrAddEdge(this.Vertex, targetVertex, this.InitialWeight);
        }
        this.ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect);
    }
    ExtendEdgeChain(transUtil, targetVertex, dirToExtend, limitRect) {
        // Extend the edge chain to the opposite side of the limit rectangle.
        // StaticGraphUtility.Assert((PointComparer.Equal(this.Point, targetVertex.point)
        //                || (PointComparer.GetPureDirectionVV(this.Point, targetVertex.point) === dirToExtend)), "input dir does not match with to-targetVertex direction", transUtil.ObstacleTree, transUtil.VisGraph);
        let extendOverlapped = this.IsOverlapped;
        if (extendOverlapped) {
            // The initial vertex we connected to may be on the border of the enclosing obstacle,
            // or of another also-overlapped obstacle.  If the former, we turn off overlap now.
            extendOverlapped = transUtil.ObstacleTree.PointIsInsideAnObstaclePD(targetVertex.point, dirToExtend);
        }
        // If we're inside an obstacle's boundaries we'll never extend past the end of the obstacle
        // due to encountering the boundary from the inside.  So start the extension at targetVertex.
        const segmentAndCrossings = this.GetSegmentAndCrossings(this.IsOverlapped ? targetVertex : this.Vertex, dirToExtend, transUtil);
        transUtil.ExtendEdgeChainVRLPB(targetVertex, limitRect, segmentAndCrossings[0], segmentAndCrossings[1], extendOverlapped);
    }
    GetSegmentAndCrossings(startVertex, dirToExtend, transUtil) {
        const dirIndex = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.CompassVector.ToIndex(dirToExtend);
        let segmentAndCrossings = this.maxVisibilitySegmentsAndCrossings[dirIndex];
        if (segmentAndCrossings == null) {
            const t = { pacList: null };
            const maxVisibilitySegment = transUtil.ObstacleTree.CreateMaxVisibilitySegment(startVertex.point, dirToExtend, t);
            segmentAndCrossings = [maxVisibilitySegment, t.pacList];
            this.maxVisibilitySegmentsAndCrossings[dirIndex] = segmentAndCrossings;
        }
        else {
            // For a waypoint this will be a target and then a source, so there may be a different lateral edge to
            // connect to. In that case make sure we are consistent in directions - back up the start point if needed.
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_1__.PointComparer.GetDirections(startVertex.point, segmentAndCrossings[0].start) === dirToExtend) {
                segmentAndCrossings[0].start = startVertex.point;
            }
        }
        return segmentAndCrossings;
    }
    MaxVisibilityInDirectionForNonOverlappedFreePoint(dirToExtend, transUtil) {
        /*Assert.assert(
          !this.IsOverlapped,
          'Do not precalculate overlapped obstacle visibility as we should extend from the outer target vertex instead',
        )*/
        const segmentAndCrossings = this.GetSegmentAndCrossings(this.Vertex, dirToExtend, transUtil);
        return segmentAndCrossings[0].end;
    }
    AddOobEdgesFromGraphCorner(transUtil, cornerPoint) {
        const dirs = _PointComparer__WEBPACK_IMPORTED_MODULE_1__.PointComparer.GetDirections(cornerPoint, this.Vertex.point);
        const cornerVertex = transUtil.VisGraph.FindVertex(cornerPoint);
        // For waypoints we want to be able to enter in both directions.
        transUtil.ConnectVertexToTargetVertex(cornerVertex, this.Vertex, dirs & (_math_geometry__WEBPACK_IMPORTED_MODULE_0__.Direction.North | _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Direction.South), _ScanSegment__WEBPACK_IMPORTED_MODULE_2__.ScanSegment.NormalWeight);
        transUtil.ConnectVertexToTargetVertex(cornerVertex, this.Vertex, dirs & (_math_geometry__WEBPACK_IMPORTED_MODULE_0__.Direction.East | _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Direction.West), _ScanSegment__WEBPACK_IMPORTED_MODULE_2__.ScanSegment.NormalWeight);
    }
    RemoveFromGraph() {
        // Currently all transient removals and edge restorations are done by TransientGraphUtility itself.
        this.Vertex = null;
    }
    toString() {
        return this.Vertex.toString();
    }
}
//# sourceMappingURL=FreePoint.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/GroupBoundaryCrossing.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GroupBoundaryCrossing: () => (/* binding */ GroupBoundaryCrossing)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
// A Group is a Shape that has children.
// This class defines a single crossing of a group boundary, from a point on the group boundary.
// It is intended as the Value of a GroupBoundaryCrossingMap entry, or as an element in a VisiblityEdge.GroupCrossings




// array, so the actual crossing coordinates are not included.
class GroupBoundaryCrossing {
    constructor(group, dirToInside) {
        this.BoundaryWidth = _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon;
        /*Assert.assert(
          CompassVector.IsPureDirection(dirToInside),
          'Impure direction',
        )*/
        this.Group = group;
        this.DirectionToInside = dirToInside;
    }
    GetInteriorVertexPoint(outerVertex) {
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.Point.RoundPoint(outerVertex.add(_math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector.toPoint(this.DirectionToInside).mul(this.BoundaryWidth)));
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0} {1}', this.DirectionToInside, this.Group);
    }
}
GroupBoundaryCrossing.BoundaryWidth = _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon;
//# sourceMappingURL=GroupBoundaryCrossing.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/GroupBoundaryCrossingMap.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GroupBoundaryCrossingMap: () => (/* binding */ GroupBoundaryCrossingMap)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
/* harmony import */ var _GroupBoundaryCrossing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/GroupBoundaryCrossing.js");
/* harmony import */ var _PointAndCrossingsList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointAndCrossingsList.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");





// A Group is a Shape that has children.
// This class maps between intersection points on Group boundaries and the groups and crossing
// directions at those intersection points.
class GroupBoundaryCrossingMap {
    constructor() {
        // Note:  Like VisibilityGraph, this does not use PointComparer but assumes already-rounded key values.
        this.pointCrossingMap = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_1__.PointMap();
        this.pointList = new Array();
    }
    AddIntersection(intersection, group, dirToInside) {
        let crossings = this.pointCrossingMap.get(intersection);
        if (!crossings) {
            crossings = new Array();
            this.pointCrossingMap.set(intersection, crossings);
        }
        // We may hit the same point on neighbor traversal in multiple directions.  We will have more than one item
        // in this list only if there are multiple group boundaries at this point, which should be unusual.
        const crossingsCount = crossings.length;
        // cache for perf
        for (let ii = 0; ii < crossingsCount; ii++) {
            const crossing = crossings[ii];
            if (crossing.Group === group) {
                // At a given location for a given group, there is only one valid dirToInside.
                /*Assert.assert(
                  dirToInside === crossing.DirectionToInside,
                  'Mismatched dirToInside',
                )*/
                return crossing;
            }
        }
        const newCrossing = new _GroupBoundaryCrossing__WEBPACK_IMPORTED_MODULE_2__.GroupBoundaryCrossing(group, dirToInside);
        crossings.push(newCrossing);
        return newCrossing;
    }
    Clear() {
        this.pointCrossingMap.clear();
    }
    GetOrderedListBetween(start, end) {
        if (this.pointCrossingMap.size === 0) {
            return null;
        }
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_4__.PointComparer.ComparePP(start, end) > 0) {
            const temp = start;
            start = end;
            end = temp;
        }
        // Start and end are inclusive.
        this.pointList = [];
        for (const intersection of this.pointCrossingMap.keys()) {
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_4__.PointComparer.ComparePP(intersection, start) >= 0 && _PointComparer__WEBPACK_IMPORTED_MODULE_4__.PointComparer.ComparePP(intersection, end) <= 0) {
                this.pointList.push(intersection);
            }
        }
        this.pointList.sort((a, b) => a.compareTo(b));
        const pointAndCrossingList = new _PointAndCrossingsList__WEBPACK_IMPORTED_MODULE_3__.PointAndCrossingsList();
        const numCrossings = this.pointList.length;
        for (let ii = 0; ii < numCrossings; ii++) {
            const intersect = this.pointList[ii];
            pointAndCrossingList.Add(intersect, this.pointCrossingMap.get(intersect));
        }
        return pointAndCrossingList;
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0}', this.pointCrossingMap.size);
    }
}
//# sourceMappingURL=GroupBoundaryCrossingMap.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/HighReflectionEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HighReflectionEvent: () => (/* binding */ HighReflectionEvent)
/* harmony export */ });
/* harmony import */ var _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/basicReflectionEvent.js");

class HighReflectionEvent extends _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_0__.BasicReflectionEvent {
    constructor(previousSite, targetSide, site) {
        super(previousSite.ReflectingObstacle, targetSide.Obstacle, site);
        this.Side = targetSide;
    }
}
//# sourceMappingURL=HighReflectionEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/LookaheadScan.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LookaheadScan: () => (/* binding */ LookaheadScan)
/* harmony export */ });
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
// For lookahead points, we record the point of the intersection on the reflecting side, then
// whenever we load a side, we check for active lookahead lines within this range.  Since we
// are just intersecting rays, we only care about the X (H scan) or Y (V scan) coordinate.

class LookaheadScan {
    constructor(scanDir) {
        this.staleSites = new Array();
        this.scanDirection = scanDir;
        this.eventTree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_0__.RBTree((a, b) => this.CompareBB(a, b));
        this.findFirstPred = (n) => this.CompareToFindFirstPoint(n.Site) >= 0;
    }
    Add(initialSite) {
        // Assert we can't find it - subsumption should have taken care of that.
        /*Assert.assert(
          this.Find(initialSite.Site) == null ,
          'Should not add the same Lookahead coordinate twice',
        )*/
        this.eventTree.insert(initialSite);
    }
    // Buffer up the events that are known to be stale - that is, will never queued as events because the
    // event-load intersection is the same as the site.
    MarkStaleSite(siteEvent) {
        this.staleSites.push(siteEvent);
    }
    RemoveStaleSites() {
        const cSites = this.staleSites.length;
        // for (;;) is faster than IEnumerator for Lists
        if (cSites > 0) {
            for (let ii = 0; ii < cSites; ii++) {
                this.RemoveExact(this.staleSites[ii]);
            }
            this.staleSites = [];
        }
    }
    RemoveSitesForFlatBottom(low, high) {
        for (let node = this.FindFirstInRange(low, high); null != node; node = this.FindNextInRange(node, high)) {
            this.MarkStaleSite(node.item);
        }
        this.RemoveStaleSites();
    }
    Find(site) {
        return this.FindFirstInRange(site, site);
    }
    RemoveExact(initialSite) {
        const node = this.eventTree.find(initialSite);
        if (null != node) {
            if (node.item.Site === initialSite.Site) {
                this.eventTree.deleteNodeInternal(node);
                return true;
            }
        }
        return false;
    }
    FindFirstInRange(low, high) {
        // We only use FindFirstPoint in this routine, to find the first satisfying node,
        // so we don't care that we leave leftovers in it.
        this.findFirstPoint = low;
        const nextNode = this.eventTree.findFirst(this.findFirstPred);
        if (null != nextNode) {
            // It's >= low; is it <= high?
            if (this.Compare(nextNode.item.Site, high) <= 0) {
                return nextNode;
            }
        }
        return null;
    }
    CompareToFindFirstPoint(treeItem) {
        return this.Compare(treeItem, this.findFirstPoint);
    }
    FindNextInRange(prev, high) {
        const nextNode = this.eventTree.next(prev);
        if (null != nextNode && this.Compare(nextNode.item.Site, high) <= 0) {
            return nextNode;
        }
        return null;
    }
    // For ordering Points in the lookahead list.  We just care about the coordinate that changes
    // parallel to the scanline, so for vertical sweep (sweeping up from bottom, scanning
    // horizontally) then order points by X only, else by Y only.
    CompareBB(lhs, rhs) {
        return this.scanDirection.CompareScanCoord(lhs.Site, rhs.Site);
    }
    Compare(lhs, rhs) {
        return this.scanDirection.CompareScanCoord(lhs, rhs);
    }
}
//# sourceMappingURL=LookaheadScan.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/LowReflectionEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LowReflectionEvent: () => (/* binding */ LowReflectionEvent)
/* harmony export */ });
/* harmony import */ var _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/basicReflectionEvent.js");

class LowReflectionEvent extends _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_0__.BasicReflectionEvent {
    constructor(previousSite, targetSide, site) {
        super(previousSite.ReflectingObstacle, targetSide.obstacle, site);
        this.Side = targetSide;
    }
}
//# sourceMappingURL=LowReflectionEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/MiscVertexEvents.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CloseVertexEvent: () => (/* binding */ CloseVertexEvent),
/* harmony export */   HighBendVertexEvent: () => (/* binding */ HighBendVertexEvent),
/* harmony export */   LowBendVertexEvent: () => (/* binding */ LowBendVertexEvent)
/* harmony export */ });
/* harmony import */ var _BasicVertexEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/BasicVertexEvent.js");

class LowBendVertexEvent extends _BasicVertexEvent__WEBPACK_IMPORTED_MODULE_0__.BasicVertexEvent {
    constructor(obstacle, p) {
        super(obstacle, p);
    }
}
class HighBendVertexEvent extends _BasicVertexEvent__WEBPACK_IMPORTED_MODULE_0__.BasicVertexEvent {
    constructor(obstacle, p) {
        super(obstacle, p);
    }
}
class CloseVertexEvent extends _BasicVertexEvent__WEBPACK_IMPORTED_MODULE_0__.BasicVertexEvent {
    constructor(obstacle, p) {
        super(obstacle, p);
    }
}
//# sourceMappingURL=MiscVertexEvents.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/MsmtRectilinearPath.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MsmtRectilinearPath: () => (/* binding */ MsmtRectilinearPath)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _ScanSegment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js");
/* harmony import */ var _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/SsstRectilinearPath.js");




class MsmtRectilinearPath {
    constructor(bendPenalty) {
        this.bendPenaltyAsAPercentageOfDistance = _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_3__.SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance;
        // Temporary for accumulating target entries.
        this.currentPassTargetEntries = new Array(4);
        this.bendPenaltyAsAPercentageOfDistance = bendPenalty;
    }
    // Get the lowest-cost path from one of one or more sources to one of one or more targets, without waypoints.
    // One or more source vertices
    // One or more target vertices
    // <returns>A single enumeration of path points.</returns>
    GetPath(sources, targets) {
        const t = { entry: this.GetPathStage(null, sources, null, targets) };
        return _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_3__.SsstRectilinearPath.RestorePathV(t);
    }
    // Route a single stage of a possibly multi-stage (due to waypoints) path.
    // The VertexEntry array that was in the source vertex if it was the target of a prior stage.
    // The enumeration of source vertices; must be only one if sourceVertexEntries is non-null.
    // The enumeration of target vertex entries; must be only one if targetVertexEntries is non-null.
    // The VertexEntry array that is in the target at the end of the stage.
    GetPathStage(sourceVertexEntries, sources, targetVertexEntries, targets) {
        const ssstCalculator = new _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_3__.SsstRectilinearPath();
        const t = {
            bestEntry: null,
            // This contains the best (lowest) path cost after normalizing origins to the center of the sources
            // and targets.  This is used to avoid selecting a vertex pair whose path has more bends than another pair of
            // vertices, but the bend penalty didn't total enough to offset the additional length between the "better" pair.
            // This also plays the role of an upper bound on the path length; if a path cost is greater than adjustedMinCost
            // then we stop exploring it, which saves considerable time after low-cost paths have been found.
            bestCost: Number.MAX_VALUE / _ScanSegment__WEBPACK_IMPORTED_MODULE_2__.ScanSegment.OverlappedWeight,
        };
        let bestPathCostRatio = Number.POSITIVE_INFINITY;
        // Calculate the bend penalty multiplier.  This is a percentage of the distance between the source and target,
        // so that we have the same relative importance if we have objects of about size 20 that are about 100 apart
        // as for objects of about size 200 that are about 1000 apart.
        const sourceCenter = MsmtRectilinearPath.Barycenter(sources);
        const targetCenter = MsmtRectilinearPath.Barycenter(targets);
        const distance = _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_3__.SsstRectilinearPath.ManhattanDistance(sourceCenter, targetCenter);
        ssstCalculator.BendsImportance = Math.max(0.001, distance * (this.bendPenaltyAsAPercentageOfDistance * 0.01));
        // We'll normalize by adding (a proportion of) the distance (only; not bends) from the current endpoints to
        // their centers. This is similar to routeToCenter, but routing multiple paths like this means we'll always
        // get at least a tie for the best vertex pair, whereas routeToCenter can introduce extraneous bends
        // if the sources/targets are not collinear with the center (such as an E-R diagram).
        // interiorLengthAdjustment is a way to decrease the cost adjustment slightly to allow a bend if it saves moving
        // a certain proportion of the distance parallel to the object before turning to it.
        const interiorLengthAdjustment = ssstCalculator.LengthImportance;
        // VertexEntries for the current pass of the current stage, if multistage.
        const tempTargetEntries = targetVertexEntries != null ? this.currentPassTargetEntries : null;
        // Process closest pairs first, so we can skip longer ones (jump out of SsstRectilinear sooner, often immediately).
        // This means that we'll be consistent on tiebreaking for equal scores with differing bend counts (the shorter
        // path will win).  In overlapped graphs the shortest path may have more higher-weight edges.
        const stPairs = [];
        for (const s of sources)
            for (const t of targets)
                stPairs.push([s, t]);
        stPairs.sort(([a, b], [c, d]) => md(a, b) - md(c, d));
        for (const [sv, tv] of stPairs) {
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(sv.point, tv.point)) {
                continue;
            }
            const sourceCostAdjustment = mdP(sv, sourceCenter) * interiorLengthAdjustment;
            const targetCostAdjustment = mdP(tv, targetCenter) * interiorLengthAdjustment;
            let adjustedBestCost = t.bestCost;
            if (targetVertexEntries != null) {
                for (let i = 0; i < tempTargetEntries.length; i++) {
                    tempTargetEntries[i] = null;
                }
                adjustedBestCost = ssstCalculator.MultistageAdjustedCostBound(t.bestCost);
            }
            const lastEntry = ssstCalculator.GetPathWithCost(sourceVertexEntries, sv, sourceCostAdjustment, tempTargetEntries, tv, targetCostAdjustment, adjustedBestCost);
            if (tempTargetEntries != null) {
                MsmtRectilinearPath.UpdateTargetEntriesForEachDirection(targetVertexEntries, tempTargetEntries, t);
                continue;
            }
            // This is the final (or only) stage. Break ties by picking the lowest ratio of cost to ManhattanDistance between the endpoints.
            if (lastEntry == null) {
                continue;
            }
            const costRatio = lastEntry.Cost / md(sv, tv);
            if (lastEntry.Cost < t.bestCost || ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.closeDistEps)(lastEntry.Cost, t.bestCost) && costRatio < bestPathCostRatio)) {
                t.bestCost = lastEntry.Cost;
                t.bestEntry = lastEntry;
                bestPathCostRatio = lastEntry.Cost / md(sv, tv);
            }
        }
        return t.bestEntry;
        function md(s, t) {
            return _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_3__.SsstRectilinearPath.ManhattanDistance(s.point, t.point);
        }
        function mdP(s, t) {
            return _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_3__.SsstRectilinearPath.ManhattanDistance(s.point, t);
        }
    }
    static UpdateTargetEntriesForEachDirection(targetVertexEntries, tempTargetEntries, t) {
        for (let ii = 0; ii < tempTargetEntries.length; ii++) {
            const tempEntry = tempTargetEntries[ii];
            if (tempEntry == null) {
                continue;
            }
            if (targetVertexEntries[ii] == null || tempEntry.Cost < targetVertexEntries[ii].Cost) {
                targetVertexEntries[ii] = tempEntry;
                if (tempEntry.Cost < t.bestCost) {
                    // This does not have the ratio tiebreaker because the individual stage path is only used as a success indicator.
                    t.bestCost = tempEntry.Cost;
                    t.bestEntry = tempEntry;
                }
            }
        }
        return;
    }
    static Barycenter(vertices) {
        let center = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
        for (const vertex of vertices) {
            center = center.add(vertex.point);
        }
        return center.div(vertices.length);
    }
}
//# sourceMappingURL=MsmtRectilinearPath.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/NeighborSides.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NeighborSides: () => (/* binding */ NeighborSides)
/* harmony export */ });
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");

class NeighborSides {
    // Dereferences the node if non-null to return the side Item.
    get LowNeighborSide() {
        return this.LowNeighbor == null ? null : this.LowNeighbor.item;
    }
    // Dereferences the node if non-null to return the side Item.
    get HighNeighborSide() {
        return this.HighNeighbor == null ? null : this.HighNeighbor.item;
    }
    Clear() {
        this.LowNeighbor = null;
        this.LowOverlapEnd = null;
        this.GroupSideInterveningBeforeLowNeighbor = null;
        this.HighNeighbor = null;
        this.HighOverlapEnd = null;
        this.GroupSideInterveningBeforeHighNeighbor = null;
    }
    SetSides(dir, neighborNode, overlapEndNode, interveningGroupSide) {
        if (_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_0__.StaticGraphUtility.IsAscending(dir)) {
            this.HighNeighbor = neighborNode;
            this.HighOverlapEnd = overlapEndNode;
            this.GroupSideInterveningBeforeHighNeighbor = interveningGroupSide;
            return;
        }
        this.LowNeighbor = neighborNode;
        this.LowOverlapEnd = overlapEndNode;
        this.GroupSideInterveningBeforeLowNeighbor = interveningGroupSide;
    }
}
//# sourceMappingURL=NeighborSides.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/ObstaclePort.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObstaclePort: () => (/* binding */ ObstaclePort)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _ObstaclePortEntrance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ObstaclePortEntrance.js");


class ObstaclePort {
    constructor(port, obstacle) {
        this.HasCollinearEntrances = false;
        this.VisibilityRectangle = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkEmpty();
        this.Port = port;
        this.Obstacle = obstacle;
        this.PortEntrances = new Array();
        this.Location = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(this.Port.Location);
    }
    CreatePortEntrance(unpaddedBorderIntersect, outDir, obstacleTree) {
        const entrance = new _ObstaclePortEntrance__WEBPACK_IMPORTED_MODULE_1__.ObstaclePortEntrance(this, unpaddedBorderIntersect, outDir, obstacleTree);
        this.PortEntrances.push(entrance);
        this.VisibilityRectangle.add(entrance.MaxVisibilitySegment.end);
        this.HasCollinearEntrances = this.HasCollinearEntrances || entrance.IsCollinearWithPort;
    }
    ClearVisibility() {
        // Most of the retained PortEntrance stuff is about precalculated visibility.
        this.PortEntrances = [];
    }
    AddToGraph(transUtil, routeToCenter) {
        // We use only border vertices if !routeToCenter.
        if (routeToCenter) {
            this.CenterVertex = transUtil.FindOrAddVertex(this.Location);
        }
    }
    RemoveFromGraph() {
        this.CenterVertex = null;
    }
    // PortManager will recreate the Port if it detects this (this.Location has already been rounded).
    get LocationHasChanged() {
        return !_math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(this.Location, _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(this.Port.Location));
    }
    // The curve associated with the port.
    get PortCurve() {
        return this.Port.Curve;
    }
    // The (unrounded) location of the port.
    get PortLocation() {
        return this.Port.Location;
    }
    toString() {
        return this.Port + this.Obstacle.toString();
    }
}
//# sourceMappingURL=ObstaclePort.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/ObstaclePortEntrance.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObstaclePortEntrance: () => (/* binding */ ObstaclePortEntrance)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _ScanDirection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanDirection.js");
/* harmony import */ var _ScanSegment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");






class ObstaclePortEntrance {
    get Obstacle() {
        return this.ObstaclePort.Obstacle;
    }
    get InitialWeight() {
        return this.IsOverlapped ? _ScanSegment__WEBPACK_IMPORTED_MODULE_4__.ScanSegment.OverlappedWeight : _ScanSegment__WEBPACK_IMPORTED_MODULE_4__.ScanSegment.NormalWeight;
    }
    get IsCollinearWithPort() {
        return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.IsPureDirection(_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(this.VisibilityBorderIntersect, this.ObstaclePort.Location));
    }
    get IsVertical() {
        return _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_5__.StaticGraphUtility.IsVertical(this.MaxVisibilitySegment);
    }
    // If the port has entrances that are collinear, don't do the optimization for non-collinear ones.
    get WantVisibilityIntersection() {
        return !this.IsOverlapped && this.CanExtend && (!this.ObstaclePort.HasCollinearEntrances || this.IsCollinearWithPort);
    }
    get CanExtend() {
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(this.MaxVisibilitySegment.start, this.MaxVisibilitySegment.end) !== _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
    }
    constructor(oport, unpaddedBorderIntersect, outDir, obstacleTree) {
        this.IsOverlapped = false;
        this.unpaddedToPaddedBorderWeight = _ScanSegment__WEBPACK_IMPORTED_MODULE_4__.ScanSegment.NormalWeight;
        this.ObstaclePort = oport;
        this.UnpaddedBorderIntersect = unpaddedBorderIntersect;
        this.OutwardDirection = outDir;
        // Get the padded intersection.
        const lineSeg = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(this.UnpaddedBorderIntersect, _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_5__.StaticGraphUtility.RectangleBorderIntersect(oport.Obstacle.VisibilityBoundingBox, this.UnpaddedBorderIntersect, outDir));
        const xxs = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.getAllIntersections(lineSeg, oport.Obstacle.VisibilityPolyline, true);
        /*Assert.assert(1 === xxs.length, 'Expected one intersection')*/
        this.VisibilityBorderIntersect = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(xxs[0].x);
        const t = { pacList: null };
        this.MaxVisibilitySegment = obstacleTree.CreateMaxVisibilitySegment(this.VisibilityBorderIntersect, this.OutwardDirection, t);
        this.pointAndCrossingsList = t.pacList;
        // Groups are never in a clump (overlapped) but they may still have their port entrance overlapped.
        if (this.Obstacle.isOverlapped || (this.Obstacle.IsGroup && !this.Obstacle.IsInConvexHull)) {
            this.IsOverlapped = obstacleTree.IntersectionIsInsideAnotherObstacle(null, this.Obstacle, this.VisibilityBorderIntersect, _ScanDirection__WEBPACK_IMPORTED_MODULE_3__.ScanDirection.GetInstance(this.OutwardDirection));
            if (!this.Obstacle.IsGroup || this.IsOverlapped || this.InteriorEdgeCrossesObstacle(obstacleTree)) {
                this.unpaddedToPaddedBorderWeight = _ScanSegment__WEBPACK_IMPORTED_MODULE_4__.ScanSegment.OverlappedWeight;
            }
        }
        if (this.Obstacle.IsInConvexHull && this.unpaddedToPaddedBorderWeight === _ScanSegment__WEBPACK_IMPORTED_MODULE_4__.ScanSegment.NormalWeight) {
            this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(obstacleTree);
        }
    }
    SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(obstacleTree) {
        if (this.Obstacle.IsGroup ? this.InteriorEdgeCrossesObstacle(obstacleTree) : this.InteriorEdgeCrossesConvexHullSiblings()) {
            this.unpaddedToPaddedBorderWeight = _ScanSegment__WEBPACK_IMPORTED_MODULE_4__.ScanSegment.OverlappedWeight;
        }
    }
    InteriorEdgeCrossesObstacle(obstacleTree) {
        // File Test: Nudger_Overlap4
        // Use the VisibilityBoundingBox for groups because those are what the tree consists of.
        const rect = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);
        return this.InteriorEdgeCrossesObstacleRFI(rect, (obs) => obs.VisibilityPolyline, Array.from(obstacleTree.Root.GetLeafRectangleNodesIntersectingRectangle(rect))
            .filter((node) => !node.UserData.IsGroup && node.UserData !== this.Obstacle)
            .map((node) => node.UserData));
    }
    InteriorEdgeCrossesConvexHullSiblings() {
        // There is no RectangleNode tree that includes convex hull non-primary siblings, so we just iterate;
        // this will only be significant to perf in extremely overlapped cases that we are not optimizing for.
        const rect = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);
        return this.InteriorEdgeCrossesObstacleRFI(rect, (obs) => obs.PaddedPolyline, this.Obstacle.ConvexHull.Obstacles.filter((obs) => obs !== this.Obstacle));
    }
    InteriorEdgeCrossesObstacleRFI(rect, whichPolylineToUse, candidates) {
        let lineSeg = null;
        for (const blocker of candidates) {
            const blockerPolyline = whichPolylineToUse(blocker);
            if (!_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_5__.StaticGraphUtility.RectangleInteriorsIntersect(rect, blockerPolyline.boundingBox)) {
                continue;
            }
            lineSeg = lineSeg !== null && lineSeg !== void 0 ? lineSeg : _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);
            const xx = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.intersectionOne(lineSeg, blockerPolyline, /* liftIntersection:*/ false);
            if (xx != null) {
                return true;
            }
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Outside !== _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.PointRelativeToCurveLocation(this.UnpaddedBorderIntersect, blockerPolyline)) {
                return true;
            }
        }
        return false;
    }
    get HasGroupCrossings() {
        return this.pointAndCrossingsList != null && this.pointAndCrossingsList.Count() > 0;
    }
    HasGroupCrossingBeforePoint(point) {
        if (!this.HasGroupCrossings) {
            return false;
        }
        const pac = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_5__.StaticGraphUtility.IsAscending(this.OutwardDirection) ? this.pointAndCrossingsList.First : this.pointAndCrossingsList.Last;
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(this.MaxVisibilitySegment.start, pac.Location) === _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(pac.Location, point);
    }
    AddToAdjacentVertex(transUtil, targetVertex, limitRect, routeToCenter) {
        let borderVertex = transUtil.VisGraph.FindVertex(this.VisibilityBorderIntersect);
        if (borderVertex != null) {
            this.ExtendEdgeChain(transUtil, borderVertex, borderVertex, limitRect, routeToCenter);
            return;
        }
        // There is no vertex at VisibilityBorderIntersect, so create it and link it to targetVertex.
        // Note: VisibilityBorderIntersect may === targetIntersect if that is on our border, *and*
        // targetIntersect may be on the border of a touching obstacle, in which case this will splice
        // into or across the adjacent obstacle, which is consistent with "touching is overlapped".
        // So we don't use UnpaddedBorderIntersect as prevPoint when calling ExtendEdgeChain.
        // VisibilityBorderIntersect may be rounded just one Curve.DistanceEpsilon beyond the ScanSegment's
        // perpendicular coordinate; e.g. our X may be targetIntersect.X + Curve.DistanceEpsilon, thereby
        // causing the direction from VisibilityBorderIntersect to targetIntersect to be W instead of E.
        // So use the targetIntersect if they are close enough; they will be equal for flat borders, and
        // otherwise the exact value we use only needs be "close enough" to the border.  (We can't use
        // CenterVertex as the prevPoint because that could be an impure direction).
        // Update: With the change to carry MaxVisibilitySegment within the PortEntrance, PortManager finds
        // targetVertex between VisibilityBorderIntersect and MaxVisibilitySegment.End, so this should no longer
        // be able to happen.
        // See RectilinearTests.PaddedBorderIntersectMeetsIncomingScanSegment for an example of what happens
        // when VisibilityBorderIntersect is on the incoming ScanSegment (it jumps out above with borderVertex found).
        if (this.OutwardDirection === _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(targetVertex.point, this.VisibilityBorderIntersect)) {
            /*Assert.assert(
              false,
              'Unexpected reversed direction between VisibilityBorderIntersect and targetVertex',
            )*/
            // ReSharper disable HeuristicUnreachableCode
            this.VisibilityBorderIntersect = targetVertex.point;
            borderVertex = targetVertex;
            // ReSharper restore HeuristicUnreachableCode
        }
        else {
            borderVertex = transUtil.FindOrAddVertex(this.VisibilityBorderIntersect);
            transUtil.FindOrAddEdge(borderVertex, targetVertex, this.InitialWeight);
        }
        this.ExtendEdgeChain(transUtil, borderVertex, targetVertex, limitRect, routeToCenter);
    }
    ExtendEdgeChain(transUtil, paddedBorderVertex, targetVertex, limitRect, routeToCenter) {
        // Extend the edge chain to the opposite side of the limit rectangle.
        transUtil.ExtendEdgeChainVRLPB(targetVertex, limitRect, this.MaxVisibilitySegment, this.pointAndCrossingsList, this.IsOverlapped);
        // In order for Nudger to be able to map from the (near-) endpoint vertex to a PortEntry, we must
        // always connect a vertex at UnpaddedBorderIntersect to the paddedBorderVertex, even if routeToCenter.
        const unpaddedBorderVertex = transUtil.FindOrAddVertex(this.UnpaddedBorderIntersect);
        transUtil.FindOrAddEdge(unpaddedBorderVertex, paddedBorderVertex, this.unpaddedToPaddedBorderWeight);
        if (routeToCenter) {
            // Link the CenterVertex to the vertex at UnpaddedBorderIntersect.
            transUtil.ConnectVertexToTargetVertex(this.ObstaclePort.CenterVertex, unpaddedBorderVertex, this.OutwardDirection, this.InitialWeight);
        }
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0} {1}~{2} {3}', this.ObstaclePort.Location, this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect, this.OutwardDirection);
    }
}
//# sourceMappingURL=ObstaclePortEntrance.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/ObstacleTree.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObstacleTree: () => (/* binding */ ObstacleTree)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/convexHull.js");
/* harmony import */ var _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/hitTestBehavior.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/graphAlgorithms/ConnectedComponentCalculator.js");
/* harmony import */ var _structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_IntPair__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");
/* harmony import */ var _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPairSet.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _GroupBoundaryCrossingMap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/GroupBoundaryCrossingMap.js");
/* harmony import */ var _obstacle__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/obstacle.js");
/* harmony import */ var _OverlapConvexHull__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/OverlapConvexHull.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _ScanDirection__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanDirection.js");
/* harmony import */ var _SpliceUtility__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/SpliceUtility.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");



















class ObstacleTree {
    constructor() {
        // // The map of all group boundary crossings for the current RestrictSegmentWithObstacles call.
        this.CurrentGroupBoundaryCrossingMap = new _GroupBoundaryCrossingMap__WEBPACK_IMPORTED_MODULE_12__.GroupBoundaryCrossingMap();
        // For accreting obstacles for clumps or convex hulls.
        this.overlapPairs = new _utils_IntPairSet__WEBPACK_IMPORTED_MODULE_10__.IntPairSet();
        // Indicates whether one or more obstacles overlap.
        this.hasOverlaps = false;
        // Member to avoid unnecessary class creation just to do a lookup.
        this.lookupIntPair = new _utils_IntPair__WEBPACK_IMPORTED_MODULE_9__.IntPair(-1, -1);
    }
    get GraphBox() {
        return this.Root.irect;
    }
    //Create the tree hierarchy from the enumeration.
    Init(obstacles, ancestorSets, idToObstacleMap) {
        this.CreateObstacleListAndOrdinals(obstacles);
        this.AncestorSets = ancestorSets;
        this.CreateRoot();
        this.shapeIdToObstacleMap = idToObstacleMap;
    }
    CreateObstacleListAndOrdinals(obstacles) {
        this.allObstacles = Array.from(obstacles);
        let scanlineOrdinal = _obstacle__WEBPACK_IMPORTED_MODULE_13__.Obstacle.FirstNonSentinelOrdinal;
        for (const obstacle of this.allObstacles) {
            obstacle.Ordinal = scanlineOrdinal++;
        }
    }
    OrdinalToObstacle(index) {
        /*Assert.assert(index >= Obstacle.FirstNonSentinelOrdinal, 'index too small')*/
        /*Assert.assert(
          index < this.allObstacles.length + Obstacle.FirstNonSentinelOrdinal,
          'index too large',
        )*/
        return this.allObstacles[index - _obstacle__WEBPACK_IMPORTED_MODULE_13__.Obstacle.FirstNonSentinelOrdinal];
    }
    // Create the root with overlapping non-rectangular obstacles converted to their convex hulls, for more reliable calculations.
    CreateRoot() {
        this.Root = ObstacleTree.CalculateHierarchy(this.GetAllObstacles());
        if (!this.OverlapsExist()) {
            return;
        }
        this.AccreteClumps();
        this.AccreteConvexHulls();
        this.GrowGroupsToAccommodateOverlaps();
        this.Root = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => obs.IsPrimaryObstacle));
    }
    OverlapsExist() {
        if (this.Root == null) {
            return false;
        }
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_5__.CrossRectangleNodesSameType)(this.Root, this.Root, (a, b) => this.CheckForInitialOverlaps(a, b));
        return this.hasOverlaps;
    }
    OverlapPairAlreadyFound(a, b) {
        // If we already found it then we'll have enqueued it in the reverse order.
        this.lookupIntPair.x = b.Ordinal;
        this.lookupIntPair.y = a.Ordinal;
        return this.overlapPairs.has(this.lookupIntPair);
    }
    CheckForInitialOverlaps(a, b) {
        if (this.hasOverlaps) {
            return;
        }
        const t = { bIsInsideA: false, aIsInsideB: false };
        if (ObstacleTree.ObstaclesIntersect(a, b, t)) {
            this.hasOverlaps = true;
            return;
        }
        if (!t.aIsInsideB && !t.bIsInsideA) {
            return;
        }
        // One obstacle is inside the other.  If they're both groups, or a non-group is inside a group, nothing
        // further is needed; we process groups differently because we can go through their sides.
        if (a.IsGroup && b.IsGroup) {
            return;
        }
        if ((a.IsGroup && t.bIsInsideA) || (b.IsGroup && t.aIsInsideB)) {
            return;
        }
        this.hasOverlaps = true;
    }
    AccreteClumps() {
        // Clumps are only created once.  After that, as the result of convex hull creation, we may
        // overlap an obstacle of a clump, in which case we enclose the clump in the convex hull as well.
        // We only allow clumps of rectangular obstacles, to avoid angled sides in the scanline.
        this.AccumulateObstaclesForClumps();
        this.CreateClumps();
    }
    AccreteConvexHulls() {
        // Convex-hull creation is transitive, because the created hull may overlap additional obstacles.
        for (;;) {
            this.AccumulateObstaclesForConvexHulls();
            if (!this.CreateConvexHulls()) {
                return;
            }
        }
    }
    static CalculateHierarchy(obstacles) {
        const rectNodes = Array.from(obstacles).map((obs) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_4__.mkRectangleNode)(obs, obs.VisibilityBoundingBox));
        return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_4__.CreateRectNodeOnArrayOfRectNodes)(rectNodes);
    }
    AccumulateObstaclesForClumps() {
        this.overlapPairs.clear();
        const rectangularObstacles = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => !obs.IsGroup && obs.IsRectangle));
        if (rectangularObstacles == null) {
            return;
        }
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_5__.CrossRectangleNodes)(rectangularObstacles, rectangularObstacles, (a, b) => this.EvaluateOverlappedPairForClump(a, b));
    }
    EvaluateOverlappedPairForClump(a, b) {
        /*Assert.assert(!a.IsGroup && !b.IsGroup, 'Groups should not come here')*/
        /*Assert.assert(
          a.IsRectangle && b.IsRectangle,
          'Only rectangles should come here',
        )*/
        if (a === b || this.OverlapPairAlreadyFound(a, b)) {
            return;
        }
        const t = { bIsInsideA: false, aIsInsideB: false };
        if (!ObstacleTree.ObstaclesIntersect(a, b, t) && !t.aIsInsideB && !t.bIsInsideA) {
            return;
        }
        this.overlapPairs.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_9__.IntPair(a.Ordinal, b.Ordinal));
    }
    AccumulateObstaclesForConvexHulls() {
        this.overlapPairs.clear();
        const allPrimaryNonGroupObstacles = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => obs.IsPrimaryObstacle && !obs.IsGroup));
        if (allPrimaryNonGroupObstacles == null) {
            return;
        }
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_5__.CrossRectangleNodes)(allPrimaryNonGroupObstacles, allPrimaryNonGroupObstacles, (a, b) => this.EvaluateOverlappedPairForConvexHull(a, b));
    }
    EvaluateOverlappedPairForConvexHull(a, b) {
        /*Assert.assert(!a.IsGroup && !b.IsGroup, 'Groups should not come here')*/
        if (a === b || this.OverlapPairAlreadyFound(a, b)) {
            return;
        }
        const t = { bIsInsideA: false, aIsInsideB: false };
        if (!ObstacleTree.ObstaclesIntersect(a, b, t) && !t.aIsInsideB && !t.bIsInsideA) {
            return;
        }
        // If either is in a convex hull, those must be coalesced.
        if (!a.IsInConvexHull && !b.IsInConvexHull) {
            // If the obstacles are rectangles, we don't need to do anything (for this pair).
            if (a.IsRectangle && b.IsRectangle) {
                return;
            }
        }
        this.overlapPairs.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_9__.IntPair(a.Ordinal, b.Ordinal));
        this.AddClumpToConvexHull(a);
        this.AddClumpToConvexHull(b);
        this.AddConvexHullToConvexHull(a);
        this.AddConvexHullToConvexHull(b);
    }
    GrowGroupsToAccommodateOverlaps() {
        // Group growth is transitive, because the created hull may overlap additional obstacles.
        for (;;) {
            this.AccumulateObstaclesForGroupOverlaps();
            if (!this.GrowGroupsToResolveOverlaps()) {
                return;
            }
        }
    }
    AccumulateObstaclesForGroupOverlaps() {
        const groupObstacles = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => obs.IsGroup));
        const allPrimaryObstacles = ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs) => obs.IsPrimaryObstacle));
        if (groupObstacles == null || allPrimaryObstacles == null) {
            return;
        }
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_5__.CrossRectangleNodes)(groupObstacles, allPrimaryObstacles, (a, b) => this.EvaluateOverlappedPairForGroup(a, b));
    }
    EvaluateOverlappedPairForGroup(a, b) {
        /*Assert.assert(a.IsGroup, 'Inconsistency in overlapping group enumeration')*/
        if (a === b || this.OverlapPairAlreadyFound(a, b)) {
            return;
        }
        const t = { bIsInsideA: false, aIsInsideB: false };
        const curvesIntersect = ObstacleTree.ObstaclesIntersect(a, b, t);
        if (!curvesIntersect && !t.aIsInsideB && !t.bIsInsideA) {
            return;
        }
        if (a.IsRectangle && b.IsRectangle) {
            // If these are already rectangles, we don't need to do anything here.  Non-group VisibilityPolylines
            // will not change by the group operations; we'll just grow the group if needed (if it is already
            // nonrectangular, either because it came in that way or because it has intersected a non-rectangle).
            // However, SparseVg needs to know about the overlap so it will create interior scansegments if the
            // obstacle is not otherwise overlapped.
            if (!b.IsGroup) {
                if (t.aIsInsideB || ObstacleTree.FirstRectangleContainsACornerOfTheOther(b.VisibilityBoundingBox, a.VisibilityBoundingBox)) {
                    b.OverlapsGroupCorner = true;
                }
            }
            return;
        }
        if (!curvesIntersect) {
            // If the borders don't intersect, we don't need to do anything if both are groups or the
            // obstacle or convex hull is inside the group.  Otherwise we have to grow group a to encompass b.
            if (b.IsGroup || t.bIsInsideA) {
                return;
            }
        }
        this.overlapPairs.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_9__.IntPair(a.Ordinal, b.Ordinal));
    }
    static FirstRectangleContainsACornerOfTheOther(a, b) {
        return a.contains(b.leftBottom) || a.contains(b.leftTop) || a.contains(b.rightTop) || a.contains(b.rightBottom);
    }
    static FirstPolylineStartIsInsideSecondPolyline(first, second) {
        return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.PointRelativeToCurveLocation(first.start, second) !== _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Outside;
    }
    AddClumpToConvexHull(obstacle) {
        if (obstacle.isOverlapped) {
            for (const sibling of obstacle.clump.filter((sib) => sib.Ordinal !== obstacle.Ordinal)) {
                this.overlapPairs.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_9__.IntPair(obstacle.Ordinal, sibling.Ordinal));
            }
            // Clear this now so any overlaps with other obstacles in the clump won't doubly insert.
            obstacle.clump = [];
        }
    }
    AddConvexHullToConvexHull(obstacle) {
        if (obstacle.IsInConvexHull) {
            for (const sibling of obstacle.ConvexHull.Obstacles.filter((sib) => sib.Ordinal !== obstacle.Ordinal)) {
                this.overlapPairs.add(new _utils_IntPair__WEBPACK_IMPORTED_MODULE_9__.IntPair(obstacle.Ordinal, sibling.Ordinal));
            }
            // Clear this now so any overlaps with other obstacles in the ConvexHull won't doubly insert.
            obstacle.ConvexHull.Obstacles = [];
        }
    }
    CreateClumps() {
        const graph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_7__.mkGraphOnEdges)(Array.from(this.overlapPairs.values()));
        const connectedComponents = (0,_math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_6__.GetConnectedComponents)(graph);
        for (const component of connectedComponents) {
            // GetComponents returns at least one self-entry for each index - including the < FirstNonSentinelOrdinal ones.
            if (component.length === 1) {
                continue;
            }
            const clump = component.map((i) => this.OrdinalToObstacle(i));
            for (const obstacle of clump) {
                obstacle.clump = clump;
            }
        }
    }
    CreateConvexHulls() {
        let found = false;
        const graph = (0,_structs_basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_7__.mkGraphOnEdges)(Array.from(this.overlapPairs.values()));
        const connectedComponents = (0,_math_graphAlgorithms_ConnectedComponentCalculator__WEBPACK_IMPORTED_MODULE_6__.GetConnectedComponents)(graph);
        for (const component of connectedComponents) {
            // GetComponents returns at least one self-entry for each index - including the < FirstNonSentinelOrdinal ones.
            if (component.length === 1) {
                continue;
            }
            found = true;
            const obstacles = component.map(this.OrdinalToObstacle);
            const points = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_11__.flattenArray)(obstacles, (p) => p.VisibilityPolyline);
            const och = new _OverlapConvexHull__WEBPACK_IMPORTED_MODULE_14__.OverlapConvexHull(_math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_2__.ConvexHull.createConvexHullAsClosedPolyline(points), obstacles);
            for (const obstacle of obstacles) {
                obstacle.SetConvexHull(och);
            }
        }
        return found;
    }
    GrowGroupsToResolveOverlaps() {
        // This is one-at-a-time so not terribly efficient but there should be a very small number of such overlaps, if any.
        let found = false;
        for (const pair of this.overlapPairs.values()) {
            found = true;
            const a = this.OrdinalToObstacle(pair.x);
            const b = this.OrdinalToObstacle(pair.y);
            if (!ObstacleTree.ResolveGroupAndGroupOverlap(a, b)) {
                ObstacleTree.ResolveGroupAndObstacleOverlap(a, b);
            }
        }
        this.overlapPairs.clear();
        return found;
    }
    static ResolveGroupAndGroupOverlap(a, b) {
        // For simplicity, pick the larger group and make grow its convex hull to encompass the smaller.
        if (!b.IsGroup) {
            return false;
        }
        if (a.VisibilityPolyline.boundingBox.area > b.VisibilityPolyline.boundingBox.area) {
            ObstacleTree.ResolveGroupAndObstacleOverlap(a, b);
        }
        else {
            ObstacleTree.ResolveGroupAndObstacleOverlap(b, a);
        }
        return true;
    }
    static ResolveGroupAndObstacleOverlap(group, obstacle) {
        // Create a convex hull for the group which goes outside the obstacle (which may also be a group).
        // It must go outside the obstacle so we don't have coinciding angled sides in the scanline.
        let loosePolyline = obstacle.looseVisibilityPolyline;
        ObstacleTree.GrowGroupAroundLoosePolyline(group, loosePolyline);
        // Due to rounding we may still report this to be close or intersecting; grow it again if so.
        const t = { bIsInsideA: false, aIsInsideB: false };
        while (ObstacleTree.ObstaclesIntersect(obstacle, group, t) || !t.aIsInsideB) {
            loosePolyline = _obstacle__WEBPACK_IMPORTED_MODULE_13__.Obstacle.CreateLoosePolyline(loosePolyline);
            ObstacleTree.GrowGroupAroundLoosePolyline(group, loosePolyline);
        }
    }
    static GrowGroupAroundLoosePolyline(group, loosePolyline) {
        const points = Array.from(group.VisibilityPolyline).concat(Array.from(loosePolyline));
        group.SetConvexHull(new _OverlapConvexHull__WEBPACK_IMPORTED_MODULE_14__.OverlapConvexHull(_math_geometry_convexHull__WEBPACK_IMPORTED_MODULE_2__.ConvexHull.createConvexHullAsClosedPolyline(points), [group]));
    }
    static ObstaclesIntersect(a, b, t) {
        if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.CurvesIntersect(a.VisibilityPolyline, b.VisibilityPolyline)) {
            t.aIsInsideB = false;
            t.bIsInsideA = false;
            return true;
        }
        t.aIsInsideB = ObstacleTree.FirstPolylineStartIsInsideSecondPolyline(a.VisibilityPolyline, b.VisibilityPolyline);
        t.bIsInsideA = !t.aIsInsideB && ObstacleTree.FirstPolylineStartIsInsideSecondPolyline(b.VisibilityPolyline, a.VisibilityPolyline);
        if (a.IsRectangle && b.IsRectangle) {
            // Rectangles do not require further evaluation.
            return false;
        }
        if (ObstacleTree.ObstaclesAreCloseEnoughToBeConsideredTouching(a, b, t.aIsInsideB, t.bIsInsideA)) {
            t.aIsInsideB = false;
            t.bIsInsideA = false;
            return true;
        }
        return false;
    }
    static ObstaclesAreCloseEnoughToBeConsideredTouching(a, b, aIsInsideB, bIsInsideA) {
        // This is only called when the obstacle.VisibilityPolylines don't intersect, thus one is inside the other
        // or both are outside. If both are outside then either one's LooseVisibilityPolyline may be used.
        if (!aIsInsideB && !bIsInsideA) {
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.CurvesIntersect(a.looseVisibilityPolyline, b.VisibilityPolyline);
        }
        // Otherwise see if the inner one is close enough to the outer border to consider them touching.
        const innerLoosePolyline = aIsInsideB ? a.looseVisibilityPolyline : b.looseVisibilityPolyline;
        const outerPolyline = aIsInsideB ? b.VisibilityPolyline : a.VisibilityPolyline;
        for (const innerPoint of innerLoosePolyline) {
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.PointRelativeToCurveLocation(innerPoint, outerPolyline) === _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Outside) {
                const outerParamPoint = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.ClosestPoint(outerPolyline, innerPoint);
                if (!___WEBPACK_IMPORTED_MODULE_0__.Point.closeIntersections(innerPoint, outerParamPoint)) {
                    return true;
                }
            }
        }
        return false;
    }
    //Add ancestors that are spatial parents - they may not be in the hierarchy, but we need to be
    //able to cross their boundaries if we're routing between obstacles on different sides of them.
    AdjustSpatialAncestors() {
        if (this.SpatialAncestorsAdjusted) {
            return false;
        }
        // Add each group to the AncestorSet of any spatial children (duplicate Insert() is ignored).
        for (const group of this.GetAllGroups()) {
            const groupBox = group.VisibilityBoundingBox;
            for (const obstacle of this.Root.GetNodeItemsIntersectingRectangle(groupBox)) {
                if (obstacle !== group && _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.ClosedCurveInteriorsIntersect(obstacle.VisibilityPolyline, group.VisibilityPolyline)) {
                    if (obstacle.IsInConvexHull) {
                        /*Assert.assert(
                          obstacle.IsPrimaryObstacle,
                          'Only primary obstacles should be in the hierarchy',
                        )*/
                        for (const sibling of obstacle.ConvexHull.Obstacles) {
                            this.AncestorSets.get(sibling.InputShape).add(group.InputShape);
                        }
                    }
                    this.AncestorSets.get(obstacle.InputShape).add(group.InputShape);
                }
            }
        }
        // Remove any hierarchical ancestors that are not spatial ancestors.  Otherwise, when trying to route to
        // obstacles that *are* spatial children of such a non-spatial-but-hierarchical ancestor, we won't enable
        // crossing the boundary the first time and will always go to the full "activate all groups" path.  By
        // removing them here we not only get a better graph (avoiding some spurious crossings) but we're faster
        // both in path generation and Nudging.
        let nonSpatialGroups = new Array();
        for (const child of this.Root.GetAllLeaves()) {
            const childBox = child.VisibilityBoundingBox;
            // This has to be two steps because we can't modify the Set during enumeration.
            nonSpatialGroups = nonSpatialGroups.concat(Array.from(this.AncestorSets.get(child.InputShape)).filter((anc) => !childBox.intersects(this.shapeIdToObstacleMap.get(anc).VisibilityBoundingBox)));
            for (const group of nonSpatialGroups) {
                this.AncestorSets.get(child.InputShape).delete(group);
            }
            nonSpatialGroups = [];
        }
        this.SpatialAncestorsAdjusted = true;
        return true;
    }
    GetAllGroups() {
        return this.GetAllObstacles().filter((obs) => obs.IsGroup);
    }
    //Clear the internal state.
    Clear() {
        this.Root = null;
        this.AncestorSets = null;
    }
    // Create a LineSegment that contains the max visibility from startPoint in the desired direction.
    CreateMaxVisibilitySegment(startPoint, dir, t) {
        const graphBoxBorderIntersect = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_18__.StaticGraphUtility.RectangleBorderIntersect(this.GraphBox, startPoint, dir);
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.GetDirections(startPoint, graphBoxBorderIntersect) === _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.None) {
            t.pacList = null;
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(startPoint, startPoint);
        }
        const segment = this.RestrictSegmentWithObstacles(startPoint, graphBoxBorderIntersect);
        // Store this off before other operations which overwrite it.
        t.pacList = this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(segment.start, segment.end);
        return segment;
    }
    // Convenience functions that call through to RectangleNode.
    GetAllObstacles() {
        return this.allObstacles;
    }
    // Returns a list of all primary obstacles - secondary obstacles inside a convex hull are not needed in the VisibilityGraphGenerator.
    GetAllPrimaryObstacles() {
        return this.Root.GetAllLeaves();
    }
    // Hit-testing.
    IntersectionIsInsideAnotherObstacle(sideObstacle, eventObstacle, intersect, scanDirection) {
        this.insideHitTestIgnoreObstacle1 = eventObstacle;
        this.insideHitTestIgnoreObstacle2 = sideObstacle;
        this.insideHitTestScanDirection = scanDirection;
        const obstacleNode = this.Root.FirstHitNodeWithPredicate(intersect, this.InsideObstacleHitTest.bind(this));
        return null != obstacleNode;
    }
    PointIsInsideAnObstaclePD(intersect, direction) {
        return this.PointIsInsideAnObstacle(intersect, _ScanDirection__WEBPACK_IMPORTED_MODULE_16__.ScanDirection.GetInstance(direction));
    }
    PointIsInsideAnObstacle(intersect, scanDirection) {
        this.insideHitTestIgnoreObstacle1 = null;
        this.insideHitTestIgnoreObstacle2 = null;
        this.insideHitTestScanDirection = scanDirection;
        const obstacleNode = this.Root.FirstHitNodeWithPredicate(intersect, this.InsideObstacleHitTest.bind(this));
        return null != obstacleNode;
    }
    InsideObstacleHitTest(location, obstacle) {
        if (obstacle === this.insideHitTestIgnoreObstacle1 || obstacle === this.insideHitTestIgnoreObstacle2) {
            // It's one of the two obstacles we already know about.
            return _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_3__.HitTestBehavior.Continue;
        }
        if (obstacle.IsGroup) {
            // Groups are handled differently from overlaps; we create ScanSegments (overlapped
            // if within a non-group obstacle, else non-overlapped), and turn on/off access across
            // the Group boundary vertices.
            return _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_3__.HitTestBehavior.Continue;
        }
        if (!_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_18__.StaticGraphUtility.PointIsInRectangleInterior(location, obstacle.VisibilityBoundingBox)) {
            // // The point is on the obstacle boundary, not inside it.
            return _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_3__.HitTestBehavior.Continue;
        }
        // Note: There are rounding issues using Curve.PointRelativeToCurveLocation at angled
        // obstacle boundaries, hence this function.
        const high = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_18__.StaticGraphUtility.RectangleBorderIntersect(obstacle.VisibilityBoundingBox, location, this.insideHitTestScanDirection.dir).add(this.insideHitTestScanDirection.DirectionAsPoint);
        const low = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_18__.StaticGraphUtility.RectangleBorderIntersect(obstacle.VisibilityBoundingBox, location, this.insideHitTestScanDirection.OppositeDirection).sub(this.insideHitTestScanDirection.DirectionAsPoint);
        const testSeg = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(low, high);
        const xxs = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.getAllIntersections(testSeg, obstacle.VisibilityPolyline, true);
        // If this is an extreme point it can have one intersection, in which case we're either on the border
        // or outside; if it's a collinear flat boundary, there can be 3 intersections to this point which again
        // means we're on the border (and 3 shouldn't happen anymore with the curve intersection fixes and
        // PointIsInsideRectangle check above).  So the interesting case is that we have 2 intersections.
        if (2 === xxs.length) {
            const firstInt = ___WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(xxs[0].x);
            const secondInt = ___WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(xxs[1].x);
            // If we're on either intersection, we're on the border rather than inside.
            if (!_PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.EqualPP(location, firstInt) &&
                !_PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.EqualPP(location, secondInt) &&
                location.compareTo(firstInt) !== location.compareTo(secondInt)) {
                // We're inside.  However, this may be an almost-flat side, in which case rounding
                // could have reported the intersection with the start or end of the same side and
                // a point somewhere on the interior of that side.  Therefore if both intersections
                // are on the same side (integral portion of the parameter), we consider location
                // to be on the border.  testSeg is always xxs[*].Segment0.
                /*Assert.assert(
                  testSeg === xxs[0].seg0,
                  'incorrect parameter ordering to GetAllIntersections',
                )*/
                if (!(0,_utils_compare__WEBPACK_IMPORTED_MODULE_8__.closeDistEps)(Math.floor(xxs[0].par1), Math.floor(xxs[1].par1))) {
                    return _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_3__.HitTestBehavior.Stop;
                }
            }
        }
        return _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_3__.HitTestBehavior.Continue;
    }
    SegmentCrossesAnObstacle(startPoint, endPoint) {
        this.stopAtGroups = true;
        this.wantGroupCrossings = false;
        const obstacleIntersectSeg = this.RestrictSegmentPrivate(startPoint, endPoint);
        return !_PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.EqualPP(obstacleIntersectSeg.end, endPoint);
    }
    SegmentCrossesANonGroupObstacle(startPoint, endPoint) {
        this.stopAtGroups = false;
        this.wantGroupCrossings = false;
        const obstacleIntersectSeg = this.RestrictSegmentPrivate(startPoint, endPoint);
        return !_PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.EqualPP(obstacleIntersectSeg.end, endPoint);
    }
    // TEST_MSAGL
    RestrictSegmentWithObstacles(startPoint, endPoint) {
        this.stopAtGroups = false;
        this.wantGroupCrossings = true;
        return this.RestrictSegmentPrivate(startPoint, endPoint);
    }
    RestrictSegmentPrivate(startPoint, endPoint) {
        this.GetRestrictedIntersectionTestSegment(startPoint, endPoint);
        this.currentRestrictedRay = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(startPoint, endPoint);
        this.restrictedRayLengthSquared = startPoint.sub(endPoint).lengthSquared;
        this.CurrentGroupBoundaryCrossingMap.Clear();
        this.RecurseRestrictRayWithObstacles(this.Root);
        return this.currentRestrictedRay;
    }
    GetRestrictedIntersectionTestSegment(startPoint, endPoint) {
        // Due to rounding issues use a larger line span for intersection calculations.
        const segDir = _PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.GetDirections(startPoint, endPoint);
        const startX = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.West === segDir ? this.GraphBox.right : _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.East === segDir ? this.GraphBox.left : startPoint.x;
        const endX = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.West === segDir ? this.GraphBox.left : _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.East === segDir ? this.GraphBox.right : endPoint.x;
        const startY = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.South === segDir ? this.GraphBox.top * 2 : _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.North === segDir ? this.GraphBox.bottom : startPoint.y;
        const endY = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.South === segDir ? this.GraphBox.bottom : _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.North === segDir ? this.GraphBox.top : startPoint.y;
        this.restrictedIntersectionTestSegment = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(new ___WEBPACK_IMPORTED_MODULE_0__.Point(startX, startY), new ___WEBPACK_IMPORTED_MODULE_0__.Point(endX, endY));
    }
    RecurseRestrictRayWithObstacles(rectNode) {
        // A lineSeg that moves along the boundary of an obstacle is not blocked by it.
        if (!_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_18__.StaticGraphUtility.RectangleInteriorsIntersect(this.currentRestrictedRay.boundingBox, rectNode.irect)) {
            return;
        }
        const obstacle = rectNode.UserData;
        if (null != obstacle) {
            // Leaf node. Get the interior intersections.  Use the full-length original segment for the intersection calculation.
            const intersections = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.getAllIntersections(this.restrictedIntersectionTestSegment, obstacle.VisibilityPolyline, true);
            if (!obstacle.IsGroup || this.stopAtGroups) {
                this.LookForCloserNonGroupIntersectionToRestrictRay(intersections);
                return;
            }
            if (this.wantGroupCrossings) {
                this.AddGroupIntersectionsToRestrictedRay(obstacle, intersections);
            }
            /*Assert.assert(rectNode.IsLeaf, 'RectNode with UserData is not a Leaf')*/
            return;
        }
        // Not a leaf; recurse into children.
        this.RecurseRestrictRayWithObstacles(rectNode.Left);
        this.RecurseRestrictRayWithObstacles(rectNode.Right);
    }
    LookForCloserNonGroupIntersectionToRestrictRay(intersections) {
        let numberOfGoodIntersections = 0;
        let closestIntersectionInfo = null;
        let localLeastDistSquared = this.restrictedRayLengthSquared;
        const testDirection = _PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.GetDirections(this.restrictedIntersectionTestSegment.start, this.restrictedIntersectionTestSegment.end);
        for (const intersectionInfo of intersections) {
            const intersect = ___WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(intersectionInfo.x);
            const dirToIntersect = _PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.GetDirections(this.currentRestrictedRay.start, intersect);
            if (dirToIntersect === _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(testDirection)) {
                continue;
            }
            numberOfGoodIntersections++;
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.None === dirToIntersect) {
                localLeastDistSquared = 0;
                closestIntersectionInfo = intersectionInfo;
                continue;
            }
            const distSquared = intersect.sub(this.currentRestrictedRay.start).lengthSquared;
            if (distSquared < localLeastDistSquared) {
                // Rounding may falsely report two intersections as different when they are actually "Close",
                // e.g. a horizontal vs. vertical intersection on a slanted edge.
                const rawDistSquared = intersectionInfo.x.sub(this.currentRestrictedRay.start).lengthSquared;
                if (rawDistSquared < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.squareOfDistanceEpsilon) {
                    continue;
                }
                localLeastDistSquared = distSquared;
                closestIntersectionInfo = intersectionInfo;
            }
        }
        if (null != closestIntersectionInfo) {
            // If there was only one intersection and it is quite close to an end, ignore it.
            // If there is more than one intersection, we have crossed the obstacle so we want it.
            if (numberOfGoodIntersections === 1) {
                const intersect = ___WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(closestIntersectionInfo.x);
                if (___WEBPACK_IMPORTED_MODULE_0__.Point.closeIntersections(intersect, this.currentRestrictedRay.start) ||
                    ___WEBPACK_IMPORTED_MODULE_0__.Point.closeIntersections(intersect, this.currentRestrictedRay.end)) {
                    return;
                }
            }
            this.restrictedRayLengthSquared = localLeastDistSquared;
            this.currentRestrictedRay.end = _SpliceUtility__WEBPACK_IMPORTED_MODULE_17__.SpliceUtility.MungeClosestIntersectionInfo(this.currentRestrictedRay.start, closestIntersectionInfo, !_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_18__.StaticGraphUtility.IsVerticalPP(this.currentRestrictedRay.start, this.currentRestrictedRay.end));
        }
    }
    AddGroupIntersectionsToRestrictedRay(obstacle, intersections) {
        // We'll let the lines punch through any intersections with groups, but track the location so we can enable/disable crossing.
        for (const intersectionInfo of intersections) {
            const intersect = ___WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(intersectionInfo.x);
            // Skip intersections that are past the end of the restricted segment (though there may still be some
            // there if we shorten it later, but we'll skip them later).
            const distSquared = intersect.sub(this.currentRestrictedRay.start).lengthSquared;
            if (distSquared > this.restrictedRayLengthSquared) {
                continue;
            }
            const dirTowardIntersect = _PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.GetDirections(this.currentRestrictedRay.start, this.currentRestrictedRay.end);
            const polyline = intersectionInfo.seg1;
            // this is the second arg to GetAllIntersections
            const dirsOfSide = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.VectorDirection(polyline.derivative(intersectionInfo.par1));
            // // The derivative is always clockwise, so if the side contains the rightward rotation of the
            // direction from the ray origin, then we're hitting it from the inside; otherwise from the outside.
            let dirToInsideOfGroup = dirTowardIntersect;
            if (0 !== (dirsOfSide & _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.RotateRight(dirTowardIntersect))) {
                dirToInsideOfGroup = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dirToInsideOfGroup);
            }
            this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, obstacle, dirToInsideOfGroup);
        }
    }
}
//# sourceMappingURL=ObstacleTree.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/OpenVertexEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OpenVertexEvent: () => (/* binding */ OpenVertexEvent)
/* harmony export */ });
/* harmony import */ var _BasicVertexEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/BasicVertexEvent.js");

class OpenVertexEvent extends _BasicVertexEvent__WEBPACK_IMPORTED_MODULE_0__.BasicVertexEvent {
    constructor(obstacle, p) {
        super(obstacle, p);
    }
}
//# sourceMappingURL=OpenVertexEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/OverlapConvexHull.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlapConvexHull: () => (/* binding */ OverlapConvexHull)
/* harmony export */ });
/* harmony import */ var _obstacle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/obstacle.js");
// This stores the location and type of a Port.

class OverlapConvexHull {
    constructor(polyline, obstacles) {
        this.Polyline = polyline;
        this.Obstacles = Array.from(obstacles);
        this.PrimaryObstacle = this.Obstacles[0];
        _obstacle__WEBPACK_IMPORTED_MODULE_0__.Obstacle.RoundVerticesAndSimplify(this.Polyline);
    }
}
//# sourceMappingURL=OverlapConvexHull.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/PointAndCrossings.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointAndCrossings: () => (/* binding */ PointAndCrossings)
/* harmony export */ });
// MSAGL class for a Point and any Group boundary crossings at that Point, for Rectilinear Edge Routing.
class PointAndCrossings {
    constructor(loc, crossings) {
        this.Crossings = [];
        this.Location = loc;
        this.Crossings = crossings;
    }
}
//# sourceMappingURL=PointAndCrossings.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/PointAndCrossingsList.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointAndCrossingsList: () => (/* binding */ PointAndCrossingsList)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _PointAndCrossings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointAndCrossings.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
// A Group is a Shape that has children.
// This class maps between intersection points on Group boundaries and the groups and crossing



// directions at those intersection points.
class PointAndCrossingsList {
    Count() {
        return this.ListOfPointsAndCrossings.length;
    }
    constructor() {
        // Internal to allow testing.
        this.ListOfPointsAndCrossings = [];
        this.index = 0;
        this.ListOfPointsAndCrossings = new Array();
    }
    Add(intersect, crossings) {
        this.ListOfPointsAndCrossings.push(new _PointAndCrossings__WEBPACK_IMPORTED_MODULE_1__.PointAndCrossings(intersect, crossings));
    }
    Pop() {
        // Next should only be called after CurrentIsBeforeOrAt returns true.
        /*Assert.assert(
          this.index < this.ListOfPointsAndCrossings.length,
          'Unexpected call to Next()',
        )*/
        return this.ListOfPointsAndCrossings[this.index++];
    }
    CurrentIsBeforeOrAt(comparand) {
        if (this.index >= this.ListOfPointsAndCrossings.length) {
            return false;
        }
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.ComparePP(this.ListOfPointsAndCrossings[this.index].Location, comparand) <= 0;
    }
    get First() {
        return this.ListOfPointsAndCrossings[0];
    }
    get Last() {
        return this.ListOfPointsAndCrossings[this.ListOfPointsAndCrossings.length - 1];
    }
    Reset() {
        this.index = 0;
    }
    MergeFrom(other) {
        this.Reset();
        if (other == null) {
            return;
        }
        // Do the usual sorted-list merge.
        const thisMax = this.ListOfPointsAndCrossings.length;
        let thisIndex = 0;
        const otherMax = other.ListOfPointsAndCrossings.length;
        let otherIndex = 0;
        const newCrossingsList = new Array(this.ListOfPointsAndCrossings.length);
        while (thisIndex < thisMax || otherIndex < otherMax) {
            if (thisIndex >= thisMax) {
                newCrossingsList.push(other.ListOfPointsAndCrossings[otherIndex++]);
                continue;
            }
            if (otherIndex >= otherMax) {
                newCrossingsList.push(this.ListOfPointsAndCrossings[thisIndex++]);
                continue;
            }
            const thisPac = this.ListOfPointsAndCrossings[thisIndex];
            const otherPac = other.ListOfPointsAndCrossings[otherIndex];
            const cmp = _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.ComparePP(thisPac.Location, otherPac.Location);
            if (0 === cmp) {
                // No duplicates
                newCrossingsList.push(thisPac);
                ++thisIndex;
                ++otherIndex;
            }
            else if (-1 === cmp) {
                newCrossingsList.push(thisPac);
                ++thisIndex;
            }
            else {
                newCrossingsList.push(otherPac);
                ++otherIndex;
            }
        }
        this.ListOfPointsAndCrossings = newCrossingsList;
    }
    Trim(start, end) {
        this.Reset();
        if (this.ListOfPointsAndCrossings == null || 0 === this.ListOfPointsAndCrossings.length) {
            return;
        }
        this.ListOfPointsAndCrossings = this.ListOfPointsAndCrossings.filter((pair) => _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.ComparePP(pair.Location, start) >= 0 && _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.ComparePP(pair.Location, end) <= 0);
    }
    // For a single vertex point, split its Array of crossings in both directions into an array in each (opposite)
    // direction.  CLR Array iteration is much faster than Array.
    static ToCrossingArray(crossings, dirToInside) {
        // First find the number in each (opposite) direction, then create the arrays.
        // We expect a very small number of groups to share a boundary point so this is not optimized.
        let numInDir = 0;
        const crossingsCount = crossings.length;
        // cache for perf
        for (let ii = 0; ii < crossingsCount; ii++) {
            if (crossings[ii].DirectionToInside === dirToInside) {
                numInDir++;
            }
        }
        if (0 === numInDir) {
            return null;
        }
        const vector = new Array(numInDir);
        let jj = 0;
        for (let ii = 0; ii < crossingsCount; ii++) {
            if (crossings[ii].DirectionToInside === dirToInside) {
                vector[jj++] = crossings[ii];
            }
        }
        return vector;
    }
    ToString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0} [{1}]', this.ListOfPointsAndCrossings.length, this.index);
    }
}
//# sourceMappingURL=PointAndCrossingsList.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointComparer: () => (/* binding */ PointComparer)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");



class PointComparer {
    // ReSharper restore InconsistentNaming
    static get DifferenceEpsilon() {
        return PointComparer.differenceEpsilon;
    }
    // Determines whether the specified Points, which are assumed to have been Round()ed,
    // are close enough to be considered equal.
    // <returns>True if the inputs are close enough to be considered equal, else false</returns>
    static EqualPP(a, b) {
        return PointComparer.Equal(a.x, b.x) && PointComparer.Equal(a.y, b.y);
    }
    // Determines whether the specified double values, which are assumed to have been Round()ed,
    // are close enough to be considered equal.
    // <returns>True if the inputs are close enough to be considered equal, else false</returns>
    static Equal(x, y) {
        return PointComparer.Compare(x, y) === 0;
    }
    // The usual Compare operation, with inputs that are assumed to have been Round()ed.
    //
    //
    // <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is
    // less than rhs, else 1.</returns>
    static Compare(lhs, rhs) {
        // If the inputs are not rounded, then two numbers that are close together at the
        // middle of the rounding range may Compare as 0 but Round to different values
        // (e.g., with rounding to 6 digits, xxx.yyyyyy49 and xxx.yyyyyy51 will exhibit this).
        // PointComparer.Assert_Rounded(lhs)
        // PointComparer.Assert_Rounded(rhs)
        let cmp = 0;
        if (lhs + PointComparer.DifferenceEpsilon < rhs) {
            cmp = -1;
        }
        else if (rhs + PointComparer.DifferenceEpsilon < lhs) {
            cmp = 1;
        }
        // Just to be sure we're in sync with CompassVector
        /*Assert.assert(
          cmp < 0 ==
            (Direction.East ==
              CompassVector.VectorDirectionPP(
                new Point(lhs, 0),
                new Point(rhs, 0),
              )),
        )*/
        /*Assert.assert(
          (0 === cmp) ==
            (Direction.None ==
              CompassVector.VectorDirectionPP(
                new Point(lhs, 0),
                new Point(rhs, 0),
              )),
        )*/
        return cmp;
    }
    // The usual Compare operation, with inputs that are assumed to have been Round()ed.
    // <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is
    // less than rhs, else 1.</returns>
    static ComparePP(lhs, rhs) {
        let cmp = PointComparer.Compare(lhs.x, rhs.x);
        if (cmp === 0) {
            cmp = PointComparer.Compare(lhs.y, rhs.y);
        }
        return cmp;
    }
    // return true if less or equal holds for two values that are assumed to have been Round()ed
    static LessOrEqual(a, b) {
        const comp = PointComparer.Compare(a, b);
        return comp < 0 || comp === 0;
    }
    static Less(a, b) {
        return PointComparer.Compare(a, b) < 0;
    }
    // static Assert_Rounded(d: number) {
    //  //  Be sure there is enough precision to round that far; anything larger than this is
    //  //  unlikely to be a graph coordinate (it's probably a line intersection way out of range).
    //  if (Math.log10(Math.abs(d)) < 14 - GeomConstants.distanceEpsilonPrecision) {
    //    /*Assert.assert(
    //      Math.abs(Point.RoundDouble(d) - d) <
    //        PointComparer.DifferenceEpsilon,
    //      'unRounded value passed',
    //    )*/
    //  }
    // }
    // static Assert_RoundedP(p: Point) {
    //  // PointComparer.Assert_Rounded(p.x)
    //  // PointComparer.Assert_Rounded(p.y)
    // }
    static GetDirections(a, b) {
        // PointComparer.Assert_RoundedP(a)
        // PointComparer.Assert_RoundedP(b)
        return _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(a, b);
    }
    static IsPureDirection(a, b) {
        // PointComparer.Assert_RoundedP(a)
        // PointComparer.Assert_RoundedP(b)
        return _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.IsPureDirection(PointComparer.GetDirections(a, b));
    }
    static IsPureDirectionD(dir) {
        return _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.IsPureDirection(dir);
    }
    static IsPureLower(a, b) {
        // PointComparer.Assert_RoundedP(a)
        // PointComparer.Assert_RoundedP(b)
        // Is a lower than b along the orthogonal line segment?  That means moving
        // from a to b is in the increasing direction.
        const dir = PointComparer.GetDirections(a, b);
        return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East === dir || _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North === dir;
    }
    static GetPureDirectionVV(first, second) {
        return PointComparer.GetDirections(first.point, second.point);
    }
}
// Due to the vagaries of rounding, we may encounter a result that is not quite 0
// when subtracting two numbers that are close.
// ReSharper disable InconsistentNaming
PointComparer.differenceEpsilon = _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_2__.GeomConstants.distanceEpsilon / 2;
//# sourceMappingURL=PointComparer.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/PortManager.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PortManager: () => (/* binding */ PortManager)
/* harmony export */ });
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/interactiveObstacleCalculator.js");
/* harmony import */ var _ObstaclePort__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ObstaclePort.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _ScanDirection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanDirection.js");
/* harmony import */ var _ScanSegment__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");
/* harmony import */ var _FreePoint__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/FreePoint.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _TransientGraphUtility__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/TransientGraphUtility.js");
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
//
// PortManager.cs
// MSAGL class for Port management for Rectilinear Edge Routing.
//
// This stores information mapping the App-level Ports (e.g. FloatingPort, RelativeFloatingPort,
// and MultiLocationFloatingPort) to the router's BasicScanPort subclasses (ObstaclePort and FreePoint).

















class PortManager {
    // Extension of port visibility splices into the visibility graph.
    get LimitPortVisibilitySpliceToEndpointBoundingBox() {
        return this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox;
    }
    set LimitPortVisibilitySpliceToEndpointBoundingBox(value) {
        this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox = value;
    }
    // Typing shortcuts
    get VisGraph() {
        return this.graphGenerator.VisibilityGraph;
    }
    get HScanSegments() {
        return this.graphGenerator.HorizontalScanSegments;
    }
    get VScanSegments() {
        return this.graphGenerator.VerticalScanSegments;
    }
    get ObstacleTree() {
        return this.graphGenerator.ObstacleTree;
    }
    get AncestorSets() {
        return this.ObstacleTree.AncestorSets;
    }
    constructor(graphGenerator) {
        // The mapping of Msagl.Port (which may be MultiLocation) to the underlying Obstacle.Shape.
        this.obstaclePortMap = new Map();
        // The mapping of Msagl.Port.Location or a Waypoint to a FreePoint with visibility info.
        this.freePointMap = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_15__.PointMap();
        // This tracks which locations were used by the last call to RouteEdges, so we can remove unused locations.
        this.freePointLocationsUsedByRouteEdges = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_16__.PointSet();
        // Storage and implementation of RectilinearEdgeRouter property of the same name.
        this.RouteToCenterOfObstacles = false;
        // A control point is a source, target, or waypoint (terminology only, there's no ControlPoint
        // class).  These lists are the control points we've added for the current path.
        this.obstaclePortsInGraph = new Array();
        this.freePointsInGraph = new Set();
        // The current set of Obstacles that are groups whose boundaries are crossable.
        this.activeAncestors = new Array();
        this.TransUtil = new _TransientGraphUtility__WEBPACK_IMPORTED_MODULE_14__.TransientGraphUtility(graphGenerator);
        this.graphGenerator = graphGenerator;
    }
    Clear() {
        this.TransUtil.RemoveFromGraph();
        // Probably nothing in here when this is called
        this.obstaclePortMap.clear();
    }
    CreateObstaclePorts(obstacle) {
        // Create ObstaclePorts for all Ports of this obstacle.  This just creates the
        // ObstaclePort object; we don't add its edges/vertices to the graph until we
        // do the actual routing.
        for (const port of obstacle.Ports) {
            this.CreateObstaclePort(obstacle, port);
        }
    }
    CreateObstaclePort(obstacle, port) {
        // This will replace any previous specification for the port (last one wins).
        /*Assert.assert(
          !this.obstaclePortMap.has(port),
          'Port is used by more than one obstacle',
        )*/
        if (port.Curve == null) {
            return null;
        }
        const roundedLocation = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(port.Location);
        if (_math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.PointLocation.Outside === _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.PointRelativeToCurveLocation(roundedLocation, obstacle.InputShape.BoundaryCurve)) {
            // Obstacle.Port is outside Obstacle.Shape; handle it as a FreePoint.
            return null;
        }
        if (obstacle.InputShape.BoundaryCurve !== port.Curve &&
            _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.PointLocation.Outside === _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.PointRelativeToCurveLocation(roundedLocation, port.Curve)) {
            // Obstacle.Port is outside port.Curve; handle it as a FreePoint.
            return null;
        }
        const oport = new _ObstaclePort__WEBPACK_IMPORTED_MODULE_7__.ObstaclePort(port, obstacle);
        this.obstaclePortMap.set(port, oport);
        return oport;
    }
    FindVertices(port) {
        const vertices = new Array();
        const oport = this.obstaclePortMap.get(port);
        if (oport) {
            if (this.RouteToCenterOfObstacles) {
                vertices.push(oport.CenterVertex);
            }
            else {
                // Add all vertices on the obstacle borders.  Avoid LINQ for performance.
                for (const entrance of oport.PortEntrances) {
                    const vertex = this.VisGraph.FindVertex(entrance.UnpaddedBorderIntersect);
                    if (vertex != null) {
                        vertices.push(vertex);
                    }
                }
            }
        }
        else {
            vertices.push(this.VisGraph.FindVertex(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(port.Location)));
        }
        return vertices;
    }
    RemoveObstaclePorts(obstacle) {
        for (const port of obstacle.Ports) {
            // Since we remove the port from the visibility graph after each routing, all we
            // have to do here is remove it from the dictionary.
            this.RemoveObstaclePort(port);
        }
    }
    RemoveObstaclePort(port) {
        this.obstaclePortMap.delete(port);
    }
    // Add path control points - source, target, and any waypoints.
    AddControlPointsToGraph(edge, shapeToObstacleMap) {
        this.GetPortSpliceLimitRectangle(edge);
        this.activeAncestors = [];
        const s = { oport: null };
        const t = { oport: null };
        const ssAncs = this.FindAncestorsAndObstaclePort(edge.sourcePort, s);
        const ttAncs = this.FindAncestorsAndObstaclePort(edge.targetPort, t);
        if (this.AncestorSets.size > 0 && s.oport != null && t.oport != null) {
            // Make non-common ancestors' boundaries transparent (we don't want to route outside common ancestors).
            const ttAncsOnly = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_0__.substractSets)(ttAncs, ssAncs);
            const ssAncsOnly = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_0__.substractSets)(ssAncs, ttAncs);
            this.ActivateAncestors(ssAncsOnly, ttAncsOnly, shapeToObstacleMap);
        }
        // Now that we've set any active ancestors, splice in the port visibility.
        this.AddPortToGraph(edge.sourcePort, s.oport);
        this.AddPortToGraph(edge.targetPort, t.oport);
    }
    ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(oobWaypoint, port) {
        if (oobWaypoint == null || !oobWaypoint.IsOutOfBounds) {
            return;
        }
        // Connect to the graphbox side at points collinear with the vertices.  The waypoint may be
        // OOB in two directions so call once for each axis.
        const endpointVertices = this.FindVertices(port);
        let dirFromGraph = oobWaypoint.OutOfBoundsDirectionFromGraph & (_math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.North | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.South);
        this.ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint, dirFromGraph, endpointVertices);
        dirFromGraph = oobWaypoint.OutOfBoundsDirectionFromGraph & (_math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.East | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.West);
        this.ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint, dirFromGraph, endpointVertices);
    }
    ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint, dirFromGraph, endpointVertices) {
        if (_math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.None === dirFromGraph) {
            // Not out of bounds on this axis.
            return;
        }
        const dirToGraph = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.OppositeDir(dirFromGraph);
        for (const vertex of endpointVertices) {
            const graphBorderLocation = this.InBoundsGraphBoxIntersect(vertex.point, dirFromGraph);
            const graphBorderVertex = this.VisGraph.FindVertex(graphBorderLocation);
            if (graphBorderVertex != null) {
                this.TransUtil.ConnectVertexToTargetVertex(oobWaypoint.Vertex, graphBorderVertex, dirToGraph, _ScanSegment__WEBPACK_IMPORTED_MODULE_10__.ScanSegment.NormalWeight);
            }
        }
    }
    SetAllAncestorsActive(edgeGeom, shapeToObstacleMap) {
        if (0 === this.AncestorSets.size) {
            return false;
        }
        this.ObstacleTree.AdjustSpatialAncestors();
        this.ClearActiveAncestors();
        const t = { oport: null };
        const s = { oport: null };
        const ssAncs = this.FindAncestorsAndObstaclePort(edgeGeom.sourcePort, s);
        const ttAncs = this.FindAncestorsAndObstaclePort(edgeGeom.targetPort, t);
        if (this.AncestorSets.size > 0 && ssAncs != null && ttAncs != null) {
            // Make all ancestors boundaries transparent; in this case we've already tried with only
            // non-common and found no path, so perhaps an obstacle is outside its parent group's bounds.
            this.ActivateAncestors(ssAncs, ttAncs, shapeToObstacleMap);
            return true;
        }
        return false;
    }
    SetAllGroupsActive() {
        // We couldn't get a path when we activated all hierarchical and spatial group ancestors of the shapes,
        // so assume we may be landlocked and activate all groups, period.
        this.ClearActiveAncestors();
        for (const group of this.ObstacleTree.GetAllGroups()) {
            group.IsTransparentAncestor = true;
            this.activeAncestors.push(group);
        }
    }
    FindAncestorsAndObstaclePort(port, t) {
        t.oport = this.FindObstaclePort(port);
        if (0 === this.AncestorSets.size) {
            return null;
        }
        if (t.oport != null) {
            return this.AncestorSets.get(t.oport.Obstacle.InputShape);
        }
        // This is a free Port (not associated with an obstacle) or a Waypoint; return all spatial parents.
        return new Set(Array.from(this.ObstacleTree.Root.AllHitItems(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(port.Location, port.Location), (shape) => shape.IsGroup)).map((obs) => obs.InputShape));
    }
    ActivateAncestors(ssAncsToUse, ttAncsToUse, shapeToObstacleMap) {
        for (const shape of (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_0__.uniteSets)(ssAncsToUse, ttAncsToUse)) {
            const group = shapeToObstacleMap.get(shape);
            /*Assert.assert(group.IsGroup, 'Ancestor shape is not a group')*/
            group.IsTransparentAncestor = true;
            this.activeAncestors.push(group);
        }
    }
    ClearActiveAncestors() {
        for (const group of this.activeAncestors) {
            group.IsTransparentAncestor = false;
        }
        this.activeAncestors = [];
    }
    RemoveControlPointsFromGraph() {
        this.ClearActiveAncestors();
        this.RemoveObstaclePortsFromGraph();
        this.RemoveFreePointsFromGraph();
        this.TransUtil.RemoveFromGraph();
        this.portSpliceLimitRectangle = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkEmpty();
    }
    RemoveObstaclePortsFromGraph() {
        for (const oport of this.obstaclePortsInGraph) {
            oport.RemoveFromGraph();
        }
        this.obstaclePortsInGraph = [];
    }
    RemoveFreePointsFromGraph() {
        for (const freePoint of this.freePointsInGraph) {
            freePoint.RemoveFromGraph();
        }
        this.freePointsInGraph.clear();
    }
    RemoveStaleFreePoints() {
        // FreePoints are not necessarily persistent - they may for example be waypoints which are removed.
        // So after every routing pass, remove any that were not added to the graph. Because the FreePoint has
        // be removed from the graph, its Vertex (and thus Point) are no longer set in the FreePoint, so we
        // must use the key from the dictionary.
        if (this.freePointMap.size > this.freePointLocationsUsedByRouteEdges.size) {
            const staleFreePairs = Array.from(this.freePointMap).filter((p) => !this.freePointLocationsUsedByRouteEdges.has(p[0]));
            for (const staleFreePair of staleFreePairs) {
                this.freePointMap.deleteP(staleFreePair[0]);
            }
        }
    }
    ClearVisibility() {
        // Most of the retained freepoint stuff is about precalculated visibility.
        this.freePointMap.clear();
        for (const oport of this.obstaclePortMap.values()) {
            oport.ClearVisibility();
        }
    }
    BeginRouteEdges() {
        this.RemoveControlPointsFromGraph();
        // ensure there are no leftovers
        this.freePointLocationsUsedByRouteEdges.clear();
    }
    EndRouteEdges() {
        this.RemoveStaleFreePoints();
    }
    FindObstaclePort(port) {
        let oport = this.obstaclePortMap.get(port);
        if (oport) {
            // First see if the obstacle's port list has changed without UpdateObstacles() being called.
            // Unfortunately we don't have a way to update the obstacle's ports until we enter
            // this block; there is no direct Port->Shape/Obstacle mapping.  So UpdateObstacle must still
            // be called, but at least this check here will remove obsolete ObstaclePorts.
            const t = {
                removedPorts: null,
                addedPorts: null,
            };
            if (oport.Obstacle.GetPortChanges(t)) {
                for (const newPort of t.addedPorts) {
                    this.CreateObstaclePort(oport.Obstacle, newPort);
                }
                for (const oldPort of t.removedPorts) {
                    this.RemoveObstaclePort(oldPort);
                }
                // If it's not still there, it was moved outside the obstacle so we'll just add it as a FreePoint.
                oport = this.obstaclePortMap.get(port);
            }
        }
        return oport;
    }
    AddPortToGraph(port, oport) {
        if (oport != null) {
            this.AddObstaclePortToGraph(oport);
            return;
        }
        // This is a FreePoint, either a Waypoint or a Port not in an Obstacle.Ports list.
        this.AddFreePointToGraph(port.Location);
    }
    AddObstaclePortToGraph(oport) {
        // If the port's position has changed without UpdateObstacles() being called, recreate it.
        if (oport.LocationHasChanged) {
            this.RemoveObstaclePort(oport.Port);
            oport = this.CreateObstaclePort(oport.Obstacle, oport.Port);
            if (oport == null) {
                // Port has been moved outside obstacle; return and let caller add it as a FreePoint.
                return;
            }
        }
        oport.AddToGraph(this.TransUtil, this.RouteToCenterOfObstacles);
        this.obstaclePortsInGraph.push(oport);
        this.CreateObstaclePortEntrancesIfNeeded(oport);
        // We've determined the entrypoints on the obstacle boundary for each PortEntry,
        // so now add them to the VisGraph.
        for (const entrance of oport.PortEntrances) {
            this.AddObstaclePortEntranceToGraph(entrance);
        }
        return;
    }
    CreateObstaclePortEntrancesIfNeeded(oport) {
        if (oport.PortEntrances.length > 0) {
            return;
        }
        // Create the PortEntrances with initial information:  border intersect and outer edge direction.
        this.CreateObstaclePortEntrancesFromPoints(oport);
    }
    GetPortVisibilityIntersection(edgeGeometry) {
        const sourceOport = this.FindObstaclePort(edgeGeometry.sourcePort);
        const targetOport = this.FindObstaclePort(edgeGeometry.targetPort);
        if (sourceOport == null || targetOport == null) {
            return null;
        }
        if (sourceOport.Obstacle.IsInConvexHull || targetOport.Obstacle.IsInConvexHull) {
            return null;
        }
        this.CreateObstaclePortEntrancesIfNeeded(sourceOport);
        this.CreateObstaclePortEntrancesIfNeeded(targetOport);
        if (!sourceOport.VisibilityRectangle.intersects(targetOport.VisibilityRectangle)) {
            return null;
        }
        for (const sourceEntrance of sourceOport.PortEntrances) {
            if (!sourceEntrance.WantVisibilityIntersection) {
                continue;
            }
            for (const targetEntrance of targetOport.PortEntrances) {
                if (!targetEntrance.WantVisibilityIntersection) {
                    continue;
                }
                const points = sourceEntrance.IsVertical === targetEntrance.IsVertical
                    ? PortManager.GetPathPointsFromOverlappingCollinearVisibility(sourceEntrance, targetEntrance)
                    : PortManager.GetPathPointsFromIntersectingVisibility(sourceEntrance, targetEntrance);
                if (points != null) {
                    return points;
                }
            }
        }
        return null;
    }
    static GetPathPointsFromOverlappingCollinearVisibility(sourceEntrance, targetEntrance) {
        // If the segments are the same they'll be in reverse.  Note: check for IntervalsOverlap also, if we support FreePoints here.
        if (!_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.IntervalsAreSame(sourceEntrance.MaxVisibilitySegment.start, sourceEntrance.MaxVisibilitySegment.end, targetEntrance.MaxVisibilitySegment.end, targetEntrance.MaxVisibilitySegment.start)) {
            return null;
        }
        if (sourceEntrance.HasGroupCrossings || targetEntrance.HasGroupCrossings) {
            return null;
        }
        if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(sourceEntrance.UnpaddedBorderIntersect, targetEntrance.UnpaddedBorderIntersect)) {
            // Probably one obstacle contained within another; we handle that elsewhere.
            return null;
        }
        return [sourceEntrance.UnpaddedBorderIntersect, targetEntrance.UnpaddedBorderIntersect];
    }
    static GetPathPointsFromIntersectingVisibility(sourceEntrance, targetEntrance) {
        const intersect = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.SegmentsIntersectLL(sourceEntrance.MaxVisibilitySegment, targetEntrance.MaxVisibilitySegment);
        if (!intersect) {
            return null;
        }
        if (sourceEntrance.HasGroupCrossingBeforePoint(intersect) || targetEntrance.HasGroupCrossingBeforePoint(intersect)) {
            return null;
        }
        return [sourceEntrance.UnpaddedBorderIntersect, intersect, targetEntrance.UnpaddedBorderIntersect];
    }
    CreateObstaclePortEntrancesFromPoints(oport) {
        const graphBox = this.graphGenerator.ObstacleTree.GraphBox;
        const curveBox = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(oport.PortCurve.boundingBox.leftBottom), _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(oport.PortCurve.boundingBox.rightTop));
        // This Port does not have a PortEntry, so we'll have visibility edges to its location
        // in the Horizontal and Vertical directions (possibly all 4 directions, if not on boundary).
        //
        // First calculate the intersection with the obstacle in all directions.  Do nothing in the
        // horizontal direction for port locations that are on the unpadded vertical extremes, because
        // this will have a path that moves alongside a rectilinear obstacle side in less than the
        // padding radius and will thus create the PaddedBorderIntersection on the side rather than top
        // (and vice-versa for the vertical direction).  We'll have an edge in the vertical direction
        // to the padded extreme boundary ScanSegment, and the Nudger will modify paths as appropriate
        // to remove unnecessary bends.
        // Use the unrounded port location to intersect with its curve.
        const location = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(oport.PortLocation);
        let found = false;
        const t = { xx0: null, xx1: null };
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.Equal(location.y, curveBox.top) && !_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.Equal(location.y, curveBox.bottom)) {
            found = true;
            const hSeg = new _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_5__.LineSegment(graphBox.left, location.y, graphBox.right, location.y);
            this.GetBorderIntersections(location, hSeg, oport.PortCurve, t);
            let wBorderIntersect = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(Math.min(t.xx0.x, t.xx1.x), location.y);
            if (wBorderIntersect.x < curveBox.left) {
                // Handle rounding error
                wBorderIntersect = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(curveBox.left, wBorderIntersect.y);
            }
            let eBorderIntersect = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(Math.max(t.xx0.x, t.xx1.x), location.y);
            if (eBorderIntersect.x > curveBox.right) {
                eBorderIntersect = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(curveBox.right, eBorderIntersect.y);
            }
            this.CreatePortEntrancesAtBorderIntersections(curveBox, oport, location, wBorderIntersect, eBorderIntersect);
        }
        // endif horizontal pass is not at vertical extreme
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.Equal(location.x, curveBox.left) && !_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.Equal(location.x, curveBox.right)) {
            found = true;
            const vSeg = new _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_5__.LineSegment(location.x, graphBox.bottom, location.x, graphBox.top);
            this.GetBorderIntersections(location, vSeg, oport.PortCurve, t);
            let sBorderIntersect = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(location.x, Math.min(t.xx0.y, t.xx1.y));
            if (sBorderIntersect.y < graphBox.bottom) {
                // Handle rounding error
                sBorderIntersect = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(sBorderIntersect.x, graphBox.bottom);
            }
            let nBorderIntersect = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(location.x, Math.max(t.xx0.y, t.xx1.y));
            if (nBorderIntersect.y > graphBox.top) {
                nBorderIntersect = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(nBorderIntersect.x, graphBox.top);
            }
            this.CreatePortEntrancesAtBorderIntersections(curveBox, oport, location, sBorderIntersect, nBorderIntersect);
        }
        // endif vertical pass is not at horizontal extreme
        if (!found) {
            // This must be on a corner, else one of the above would have matched.
            this.CreateEntrancesForCornerPort(curveBox, oport, location);
        }
    }
    GetBorderIntersections(location, lineSeg, curve, t) {
        // Important:  the LineSegment must be the first arg to GetAllIntersections so RawIntersection works.
        const xxs = _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.getAllIntersections(lineSeg, curve, true);
        /*Assert.assert(2 === xxs.length, 'Expected two intersections')*/
        t.xx0 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(xxs[0].x);
        t.xx1 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(xxs[1].x);
    }
    CreatePortEntrancesAtBorderIntersections(curveBox, oport, location, unpaddedBorderIntersect0, unpaddedBorderIntersect1) {
        // Allow entry from both sides, except from the opposite side of a point on the border.
        const dir = _PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.GetDirections(unpaddedBorderIntersect0, unpaddedBorderIntersect1);
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(unpaddedBorderIntersect0, location)) {
            this.CreatePortEntrance(curveBox, oport, unpaddedBorderIntersect1, dir);
        }
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(unpaddedBorderIntersect1, location)) {
            this.CreatePortEntrance(curveBox, oport, unpaddedBorderIntersect0, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.OppositeDir(dir));
        }
    }
    static GetDerivative(oport, borderPoint) {
        // This is only used for ObstaclePorts, which have ensured Port.Curve is not null.
        const param = oport.PortCurve.closestParameter(borderPoint);
        let deriv = oport.PortCurve.derivative(param);
        const parMid = (oport.PortCurve.parStart + oport.PortCurve.parEnd) / 2;
        if (!_interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_6__.InteractiveObstacleCalculator.CurveIsClockwise(oport.PortCurve, oport.PortCurve.value(parMid))) {
            deriv = deriv.mul(-1);
        }
        return deriv;
    }
    CreatePortEntrance(curveBox, oport, unpaddedBorderIntersect, outDir) {
        oport.CreatePortEntrance(unpaddedBorderIntersect, outDir, this.ObstacleTree);
        const scanDir = _ScanDirection__WEBPACK_IMPORTED_MODULE_9__.ScanDirection.GetInstance(outDir);
        let axisDistanceBetweenIntersections = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.GetRectangleBound(curveBox, outDir) - scanDir.Coord(unpaddedBorderIntersect);
        if (axisDistanceBetweenIntersections < 0) {
            axisDistanceBetweenIntersections = -axisDistanceBetweenIntersections;
        }
        if (axisDistanceBetweenIntersections > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_13__.GeomConstants.intersectionEpsilon) {
            // This is not on an extreme boundary of the unpadded curve (it's on a sloping (nonrectangular) boundary),
            // so we need to generate another entrance in one of the perpendicular directions (depending on which
            // way the side slopes).  Derivative is always clockwise.
            const perpDirs = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.VectorDirection(PortManager.GetDerivative(oport, unpaddedBorderIntersect));
            let perpDir;
            outDir | _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.OppositeDir(outDir);
            if (_math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.None !== (outDir & perpDirs)) {
                // If the derivative is in the same direction as outDir then perpDir is toward the obstacle
                // interior and must be reversed.
                perpDir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.OppositeDir(perpDir);
            }
            oport.CreatePortEntrance(unpaddedBorderIntersect, perpDir, this.ObstacleTree);
        }
    }
    CreateEntrancesForCornerPort(curveBox, oport, location) {
        // This must be a corner or it would have been within one of the bounds and handled elsewhere.
        // Therefore create an entrance in both directions, with the first direction selected so that
        // the second can be obtained via RotateRight.
        let outDir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.North;
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(location, curveBox.leftBottom)) {
            outDir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.South;
        }
        else if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(location, curveBox.leftTop)) {
            outDir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.West;
        }
        else if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(location, curveBox.rightTop)) {
            outDir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.North;
        }
        else if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(location, curveBox.rightBottom)) {
            outDir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.East;
        }
        else {
            /*Assert.assert(false, 'Expected Port to be on corner of curveBox')*/
        }
        oport.CreatePortEntrance(location, outDir, this.ObstacleTree);
        oport.CreatePortEntrance(location, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.RotateRight(outDir), this.ObstacleTree);
    }
    AddObstaclePortEntranceToGraph(entrance) {
        // Note: As discussed in ObstaclePortEntrance.AddToGraph, oport.VisibilityBorderIntersect may be
        // on a border shared with another obstacle, in which case we'll extend into that obstacle.  This
        // should be fine if we're consistent about "touching means overlapped", so that a path that comes
        // through the other obstacle on the shared border is OK.
        const borderVertex = this.VisGraph.FindVertex(entrance.VisibilityBorderIntersect);
        if (borderVertex) {
            entrance.ExtendEdgeChain(this.TransUtil, borderVertex, borderVertex, this.portSpliceLimitRectangle, this.RouteToCenterOfObstacles);
            return;
        }
        // There may be no scansegment to splice to before we hit an adjacent obstacle, so if the edge
        // is null there is nothing to do.
        const t = { targetVertex: null };
        const weight = entrance.IsOverlapped ? _ScanSegment__WEBPACK_IMPORTED_MODULE_10__.ScanSegment.OverlappedWeight : _ScanSegment__WEBPACK_IMPORTED_MODULE_10__.ScanSegment.NormalWeight;
        const edge = this.FindorCreateNearestPerpEdgePPDNT(entrance.MaxVisibilitySegment.end, entrance.VisibilityBorderIntersect, entrance.OutwardDirection, weight, t);
        if (edge != null) {
            entrance.AddToAdjacentVertex(this.TransUtil, t.targetVertex, this.portSpliceLimitRectangle, this.RouteToCenterOfObstacles);
        }
    }
    InBoundsGraphBoxIntersect(point, dir) {
        return _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.GraphBox, point, dir);
    }
    FindorCreateNearestPerpEdgePPDN(first, second, dir, weight) {
        const t = { targetVertex: null };
        return this.FindorCreateNearestPerpEdgePPDNT(first, second, dir, weight, t);
    }
    FindorCreateNearestPerpEdgePPDNT(first, second, dir, weight, t) {
        // Find the closest perpendicular ScanSegment that intersects a segment with endpoints
        // first and second, then find the closest parallel ScanSegment that intersects that
        // perpendicular ScanSegment.  This gives us a VisibilityVertex location from which we
        // can walk to the closest perpendicular VisibilityEdge that intersects first->second.
        const couple = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.SortAscending(first, second);
        const low = couple[0];
        const high = couple[1];
        const perpendicularScanSegments = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.IsVerticalD(dir) ? this.HScanSegments : this.VScanSegments;
        // Look up the nearest intersection.  For obstacles, we cannot just look for the bounding box
        // corners because nonrectilinear obstacles may have other obstacles overlapping the bounding
        // box (at either the corners or between the port border intersection and the bounding box
        // side), and of course obstacles may overlap too.
        const nearestPerpSeg = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.IsAscending(dir)
            ? perpendicularScanSegments.FindLowestIntersector(low, high)
            : perpendicularScanSegments.FindHighestIntersector(low, high);
        if (nearestPerpSeg == null) {
            // No ScanSegment between this and visibility limits.
            t.targetVertex = null;
            return null;
        }
        const edgeIntersect = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.SegmentIntersectionSP(nearestPerpSeg, low);
        // We now know the nearest perpendicular segment that intersects start->end.  Next we'll find a close
        // parallel scansegment that intersects the perp segment, then walk to find the nearest perp edge.
        return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.IsAscending(dir) ? low : high, nearestPerpSeg, edgeIntersect, weight, t);
    }
    FindOrCreateNearestPerpEdgeFromNearestPerpSegment(pointLocation, scanSeg, edgeIntersect, weight, t) {
        var _a;
        // Given: a ScanSegment scanSeg perpendicular to pointLocation->edgeIntersect and containing edgeIntersect.
        // To find: a VisibilityEdge perpendicular to pointLocation->edgeIntersect which may be on scanSeg, or may
        //          be closer to pointLocation than the passed edgeIntersect is.
        // Since there may be TransientEdges between pointLocation and edgeIntersect, we start by finding
        // a scanSeg-intersecting (i.e. parallel to pointLocation->edgeIntersect) ScanSegment, then starting from
        // the intersection of those segments, walk the VisibilityGraph until we find the closest VisibilityEdge
        // perpendicular to pointLocation->edgeIntersect.  If there is a vertex on that edge collinear to
        // pointLocation->edgeIntersect, return the edge for which it is Source, else split the edge.
        // If there is already a vertex at edgeIntersect, we do not need to look for the intersecting ScanSegment.
        const tt = {
            segsegVertex: this.VisGraph.FindVertex(edgeIntersect),
            targetVertex: null,
        };
        if (tt.segsegVertex == null) {
            const edge = this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(pointLocation, edgeIntersect, scanSeg, weight, tt);
            if (edge != null) {
                return edge;
            }
        }
        else if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(pointLocation, edgeIntersect)) {
            // The initial pointLocation was on scanSeg at an existing vertex so return an edge
            // from that vertex along scanSeg. Look in both directions in case of dead ends.
            t.targetVertex = tt.segsegVertex;
            return this.TransUtil.FindNextEdge(t.targetVertex, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.OppositeDir(scanSeg.ScanDirection.Dir));
        }
        // pointLocation is not on the initial scanSeg, so see if there is a transient edge between
        // pointLocation and edgeIntersect.  edgeIntersect === segsegVertex.Point if pointLocation is
        // collinear with intSegBefore (pointLocation is before or after intSegBefore's VisibilityVertices).
        const dirTowardLocation = _PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.GetDirections(edgeIntersect, pointLocation);
        let perpDir = _PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.GetDirections(tt.segsegVertex.point, pointLocation);
        if (dirTowardLocation === perpDir) {
            // intSegBefore is collinear with pointLocation so walk to the vertex closest to pointLocation.
            const ot = { bracketTarget: null, bracketSource: null };
            _TransientGraphUtility__WEBPACK_IMPORTED_MODULE_14__.TransientGraphUtility.FindBracketingVertices(tt.segsegVertex, pointLocation, dirTowardLocation, ot);
            // Return an edge. Look in both directions in case of dead ends.
            return ((_a = this.TransUtil.FindNextEdge(ot.bracketSource, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.RotateLeft(dirTowardLocation))) !== null && _a !== void 0 ? _a : this.TransUtil.FindNextEdge(ot.bracketSource, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.RotateRight(dirTowardLocation)));
        }
        // Now make perpDir have only the perpendicular component.
        perpDir &= ~dirTowardLocation; // if this is Directions. None, pointLocation === edgeIntersect
        // StaticGraphUtility.Assert((Direction.None !== perpDir), "pointLocation === initial segsegVertex.Point should already have exited", this.ObstacleTree, this.VisGraph);
        // Other TransientVE edge chains may have been added between the control point and the
        // ScanSegment (which is always non-transient), and they may have split ScanSegment VEs.
        // Fortunately we know we'll always have all transient edge chains extended to or past any
        // control point (due to LimitRectangle), so we can just move up lowestIntSeg toward
        // pointLocation, updating segsegVertex and edgeIntersect.  There are 3 possibilities:
        //  - location is not on an edge - the usual case, we just create an edge perpendicular
        //    to an edge on scanSeg, splitting that scanSeg edge in the process.
        //  - location is on a VE that is parallel to scanSeg.  This is essentially the same thing
        //    but we don't need the first perpendicular edge to scanSeg.
        //  - location is on a VE that is perpendicular to scanSeg.  In that case the vertex on ScanSeg
        //    already exists; TransUtil.FindOrAddEdge just returns the edge starting at that intersection.
        // FreePoint tests of this are in RectilinearTests.FreePortLocationRelativeToTransientVisibilityEdges*.
        const perpendicularEdge = this.TransUtil.FindNearestPerpendicularOrContainingEdge(tt.segsegVertex, perpDir, pointLocation);
        if (perpendicularEdge == null) {
            // Dead end; we're above the highest point at which there is an intersection of scanSeg.
            // Create a new vertex and edge higher than the ScanSegment's HighestVisibilityVertex
            // if that doesn't cross an obstacle (if we are between two ScanSegment dead-ends, we may).
            // We hit this in RectilinearFileTests.Nudger_Many_Paths_In_Channel and .Nudger_Overlap*.
            // StaticGraphUtility.Assert((edgeIntersect > scanSeg.HighestVisibilityVertex.point), "edgeIntersect is not > scanSeg.HighestVisibilityVertex", this.ObstacleTree, this.VisGraph);
            t.targetVertex = this.TransUtil.AddVertex(edgeIntersect);
            return this.TransUtil.FindOrAddEdge(t.targetVertex, scanSeg.HighestVisibilityVertex, scanSeg.Weight);
        }
        // We have an intersecting perp edge, which may be on the original scanSeg or closer to pointLocation.
        // Get one of its vertices and re-find the intersection on it (it doesn't matter which vertex of the
        // edge we use, but for consistency use the "lower in perpDir" one).
        tt.segsegVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.GetEdgeEnd(perpendicularEdge, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.OppositeDir(perpDir));
        edgeIntersect = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.SegmentIntersectionPPP(pointLocation, edgeIntersect, tt.segsegVertex.point);
        // By this point we've verified there's no intervening Transient edge, so if we have an identical
        // point, we're done.
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(tt.segsegVertex.point, edgeIntersect)) {
            t.targetVertex = tt.segsegVertex;
            return this.TransUtil.FindNextEdge(tt.segsegVertex, perpDir);
        }
        // The targetVertex doesn't exist; this will split the edge and add it.
        t.targetVertex = this.TransUtil.FindOrAddVertex(edgeIntersect);
        return this.TransUtil.FindOrAddEdge(tt.segsegVertex, t.targetVertex, weight);
    }
    FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(pointLocation, edgeIntersect, scanSeg, weight, t) {
        const intersectingSegments = scanSeg.IsVertical ? this.HScanSegments : this.VScanSegments;
        const intSegBefore = intersectingSegments.FindHighestIntersector(scanSeg.Start, edgeIntersect);
        if (intSegBefore == null) {
            // Dead end; we're below the lowest point at which there is an intersection of scanSeg.
            // Create a new vertex and edge lower than the ScanSegment's LowestVisibilityVertex.
            // Test: RectilinearFileTests.Overlap_Rotate_SplicePort_FreeObstaclePorts.
            t.segsegVertex = null;
            t.targetVertex = this.TransUtil.AddVertex(edgeIntersect);
            return this.TransUtil.FindOrAddEdge(t.targetVertex, scanSeg.LowestVisibilityVertex, scanSeg.Weight);
        }
        // Get the VisibilityVertex at the intersection of the two segments we just found;
        // edgeIntersect is between that vertex and another on the segment, and we'll split
        // the edge between those two vertices (or find one nearer to walk to).
        const segsegIntersect = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.SegmentsIntersection(scanSeg, intSegBefore);
        t.segsegVertex = this.VisGraph.FindVertex(segsegIntersect);
        if (!t.segsegVertex) {
            // This happens only for UseSparseVisibilityGraph; in that case we must create the
            // intersection vertex in the direction of both segments so we can start walking.
            t.segsegVertex = this.TransUtil.AddVertex(segsegIntersect);
            const newEdge = this.AddEdgeToClosestSegmentEnd(scanSeg, t.segsegVertex, scanSeg.Weight);
            this.AddEdgeToClosestSegmentEnd(intSegBefore, t.segsegVertex, intSegBefore.Weight);
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(t.segsegVertex.point, edgeIntersect)) {
                t.targetVertex = t.segsegVertex;
                return newEdge;
            }
        }
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.EqualPP(pointLocation, edgeIntersect)) {
            // The initial pointLocation was on scanSeg and we had to create a new vertex for it,
            // so we'll find or create (by splitting) the edge on scanSeg that contains pointLocation.
            t.targetVertex = this.TransUtil.FindOrAddVertex(edgeIntersect);
            return this.TransUtil.FindOrAddEdge(t.segsegVertex, t.targetVertex, weight);
        }
        t.targetVertex = null;
        return null;
    }
    AddEdgeToClosestSegmentEnd(scanSeg, segsegVertex, weight) {
        // FindOrAddEdge will walk until it finds the minimal bracketing vertices.
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.IsPureLower(scanSeg.HighestVisibilityVertex.point, segsegVertex.point)) {
            return this.TransUtil.FindOrAddEdge(scanSeg.HighestVisibilityVertex, segsegVertex, weight);
        }
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.IsPureLower(segsegVertex.point, scanSeg.LowestVisibilityVertex.point)) {
            return this.TransUtil.FindOrAddEdge(segsegVertex, scanSeg.LowestVisibilityVertex, weight);
        }
        return this.TransUtil.FindOrAddEdgeVV(scanSeg.LowestVisibilityVertex, segsegVertex);
    }
    GetPortSpliceLimitRectangle(edgeGeom) {
        if (!this.LimitPortVisibilitySpliceToEndpointBoundingBox) {
            this.portSpliceLimitRectangle = this.graphGenerator.ObstacleTree.GraphBox;
            return;
        }
        // Return the endpoint-containing rectangle marking the limits of edge-chain extension for a single path.
        this.portSpliceLimitRectangle = this.GetPortRectangle(edgeGeom.sourcePort);
        this.portSpliceLimitRectangle.addRecSelf(this.GetPortRectangle(edgeGeom.targetPort));
    }
    GetPortRectangle(port) {
        const oport = this.obstaclePortMap.get(port);
        if (oport) {
            return oport.Obstacle.VisibilityBoundingBox.clone();
        }
        // FreePoint.
        return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkOnPoints([_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(port.Location)]);
    }
    AddToLimitRectangle(location) {
        if (this.graphGenerator.IsInBoundsP(location)) {
            this.portSpliceLimitRectangle.add(location);
        }
    }
    FindOrCreateFreePoint(location) {
        let freePoint = this.freePointMap.get(location);
        if (!freePoint) {
            freePoint = new _FreePoint__WEBPACK_IMPORTED_MODULE_12__.FreePoint(this.TransUtil, location);
            this.freePointMap.set(location, freePoint);
        }
        else {
            freePoint.GetVertex(this.TransUtil, location);
        }
        this.freePointsInGraph.add(freePoint);
        this.freePointLocationsUsedByRouteEdges.add(location);
        return freePoint;
    }
    // This is private because it depends on LimitRectangle
    AddFreePointToGraph(location) {
        // This is a FreePoint, either a Waypoint or a Port not in an Obstacle.Ports list.
        // We can't modify the Port.Location as the caller owns that, so Point.RoundPoint it
        // at the point at which we acquire it.
        location = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(location);
        // If the point already exists before FreePoint creation, there's nothing to do.
        const vertex = this.VisGraph.FindVertex(location);
        const freePoint = this.FindOrCreateFreePoint(location);
        if (vertex != null) {
            return freePoint;
        }
        if (!this.graphGenerator.IsInBoundsP(location)) {
            this.CreateOutOfBoundsFreePoint(freePoint);
            return freePoint;
        }
        // Vertex is inbounds and does not yet exist.  Possibilities are:
        //  - point is on one ScanSegment (perhaps a dead-end)
        //  - point is not on any edge (it's in free space so it's in the middle of some rectangle
        //    (possibly not closed) formed by ScanSegment intersections)
        let edge = null;
        freePoint.IsOverlapped = this.ObstacleTree.PointIsInsideAnObstacle(freePoint.Point, this.HScanSegments.ScanDirection);
        let scanSegment;
        this.VScanSegments.FindSegmentContainingPoint(location, true);
        if (scanSegment != null) {
            // The location is on one ScanSegment.  Find the intersector and split an edge along the segment
            // (or extend the VisibilityEdges of the segment in the desired direction).
            const t = { targetVertex: null };
            edge = this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(location, scanSegment, location, freePoint.InitialWeight, t);
        }
        let edgeDir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_4__.Direction.South;
        if (edge != null) {
            // The freePoint is on one (but not two) segments, and has already been spliced into
            // that segment's edge chain.  Add edges laterally to the parallel edges.
            edgeDir = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.EdgeDirectionVE(edge);
            this.ConnectFreePointToLateralEdge(freePoint, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.RotateLeft(edgeDir));
            this.ConnectFreePointToLateralEdge(freePoint, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.RotateRight(edgeDir));
        }
        else {
            // The freePoint is not on ScanSegment so we must splice to 4 surrounding edges (or it may be on a
            // TransientVE). Look in each of the 4 directions, trying first to avoid crossing any obstacle
            // boundaries.  However if we cannot find an edge that does not cross an obstacle boundary, the
            // freepoint is inside a non-overlapped obstacle, so take a second pass to connect to the nearest
            // edge regardless of obstacle boundaries.
            for (let ii = 0; ii < 4; ii++) {
                this.ConnectFreePointToLateralEdge(freePoint, edgeDir);
                edgeDir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.RotateLeft(edgeDir);
            }
        }
        return freePoint;
    }
    CreateOutOfBoundsFreePoint(freePoint) {
        // For an out of bounds (OOB) point, we'll link one edge from it to the inbounds edge if it's
        // out of bounds in only one direction; if in two, we'll add a bend. Currently we don't need
        // to do any more because multiple waypoints are processed as multiple subpaths.
        const oobLocation = freePoint.Point;
        const inboundsLocation = this.graphGenerator.MakeInBoundsLocation(oobLocation);
        const dirFromGraph = _PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.GetDirections(inboundsLocation, oobLocation);
        freePoint.OutOfBoundsDirectionFromGraph = dirFromGraph;
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_8__.PointComparer.IsPureDirectionD(dirFromGraph)) {
            // It's OOB in two directions so will need a bend, but we know inboundsLocation
            // is a graph corner so it has a vertex already and we don't need to look up sides.
            //StaticGraphUtility.Assert((this.VisGraph.FindVertex(inboundsLocation) != null), "graph corner vertex not found", this.ObstacleTree, this.VisGraph);
            freePoint.AddOobEdgesFromGraphCorner(this.TransUtil, inboundsLocation);
            return;
        }
        // We know inboundsLocation is on the nearest graphBox border ScanSegment, so this won't return a
        // null edge, and we'll just do normal join-to-one-edge handling, extending in the direction to the graph.
        let inboundsVertex = this.VisGraph.FindVertex(inboundsLocation);
        const dirToGraph = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.OppositeDir(dirFromGraph);
        if (inboundsVertex != null) {
            freePoint.AddToAdjacentVertex(this.TransUtil, inboundsVertex, dirToGraph, this.portSpliceLimitRectangle);
        }
        else {
            const edge = this.FindorCreateNearestPerpEdgePPDN(oobLocation, inboundsLocation, dirFromGraph, _ScanSegment__WEBPACK_IMPORTED_MODULE_10__.ScanSegment.NormalWeight);
            if (edge != null) {
                inboundsVertex = freePoint.AddEdgeToAdjacentEdge(this.TransUtil, edge, dirToGraph, this.portSpliceLimitRectangle);
            }
        }
        // This may be an oob waypoint, in which case we want to add additional edges so we can
        // go outside graph, cross the waypoint, and come back in.  Shortest-paths will do the
        // work of determining the optimal path, to avoid backtracking.
        const inboundsLeftVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.FindAdjacentVertex(inboundsVertex, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.RotateLeft(dirToGraph));
        if (inboundsLeftVertex != null) {
            this.TransUtil.ConnectVertexToTargetVertex(freePoint.Vertex, inboundsLeftVertex, dirToGraph, _ScanSegment__WEBPACK_IMPORTED_MODULE_10__.ScanSegment.NormalWeight);
        }
        const inboundsRightVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_11__.StaticGraphUtility.FindAdjacentVertex(inboundsVertex, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_2__.CompassVector.RotateRight(dirToGraph));
        if (inboundsRightVertex != null) {
            this.TransUtil.ConnectVertexToTargetVertex(freePoint.Vertex, inboundsRightVertex, dirToGraph, _ScanSegment__WEBPACK_IMPORTED_MODULE_10__.ScanSegment.NormalWeight);
        }
    }
    ConnectFreePointToLateralEdge(freePoint, lateralDir) {
        // Turn on pivot vertex to either side to find the next edge to connect to.  If the freepoint is
        // overlapped (inside an obstacle), just find the closest ScanSegment outside the obstacle and
        // start extending from there; otherwise, we can have the FreePoint calculate its max visibility.
        const end = freePoint.IsOverlapped
            ? this.InBoundsGraphBoxIntersect(freePoint.Point, lateralDir)
            : freePoint.MaxVisibilityInDirectionForNonOverlappedFreePoint(lateralDir, this.TransUtil);
        const lateralEdge = this.FindorCreateNearestPerpEdgePPDN(end, freePoint.Point, lateralDir, freePoint.InitialWeight);
        // There may be no VisibilityEdge between the current point and any adjoining obstacle in that direction.
        if (lateralEdge != null) {
            freePoint.AddEdgeToAdjacentEdge(this.TransUtil, lateralEdge, lateralDir, this.portSpliceLimitRectangle);
        }
    }
}
//# sourceMappingURL=PortManager.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearEdgeRouter.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RectilinearEdgeRouter: () => (/* binding */ RectilinearEdgeRouter)
/* harmony export */ });
/* harmony import */ var _nudging_Nudger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/Nudger.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _layout_core_geomEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomEdge.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _ShapeCreator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ShapeCreator.js");
/* harmony import */ var _splineRouter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/splineRouter.js");
/* harmony import */ var _MsmtRectilinearPath__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/MsmtRectilinearPath.js");
/* harmony import */ var _nudging_Path__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/Path.js");
/* harmony import */ var _obstacle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/obstacle.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _PortManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PortManager.js");
/* harmony import */ var _SparseVisibiltyGraphGenerator__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/SparseVisibiltyGraphGenerator.js");
/* harmony import */ var _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/SsstRectilinearPath.js");
/* harmony import */ var _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/arrowhead.js");
//
// RectilinearEdgeRouter.cs
// MSAGL main class for Rectilinear Edge Routing.Routing.
//
// Copyright Microsoft Corporation.


















// Provides rectilinear edge routing functionality
class RectilinearEdgeRouter extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_7__.Algorithm {
    // If true, route to obstacle centers.  Initially false for greater accuracy with the current
    // MultiSourceMultiTarget approach.
    get RouteToCenterOfObstacles() {
        return this.PortManager.RouteToCenterOfObstacles;
    }
    set RouteToCenterOfObstacles(value) {
        this.PortManager.RouteToCenterOfObstacles = value;
    }
    // If true, limits the extension of port visibility splices into the visibility graph to the rectangle defined by
    // the path endpoints.
    get LimitPortVisibilitySpliceToEndpointBoundingBox() {
        return this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox;
    }
    set LimitPortVisibilitySpliceToEndpointBoundingBox(value) {
        this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox = value;
    }
    // Add an GeomEdge to route
    AddEdgeGeometryToRoute(edgeGeometry) {
        // The Port.Location values are not necessarily rounded by the caller.  The values
        // will be rounded upon acquisition in PortManager.cs.  PointComparer.Equal expects
        // all values to be rounded.
        if (!_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(edgeGeometry.sourcePort.Location), _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(edgeGeometry.targetPort.Location))) {
            this.EdgesToRoute.push(edgeGeometry);
        }
        else {
            this.selfEdges.push(edgeGeometry);
        }
    }
    // Array all edge routing specifications that are currently active.  We want to hide access to the
    // Array itself so people don't add or remove items directly.
    get EdgeGeometriesToRoute() {
        return this.EdgesToRoute;
    }
    // Remove all EdgeGeometries to route
    RemoveAllEdgeGeometriesToRoute() {
        // Don't call RemoveEdgeGeometryToRoute as it will interrupt the EdgeGeometries enumerator.
        this.EdgesToRoute = [];
    }
    // If true, this router uses a sparse visibility graph, which saves memory for large graphs but
    // may choose suboptimal paths.  Set on constructor.
    get UseSparseVisibilityGraph() {
        return this.GraphGenerator instanceof _SparseVisibiltyGraphGenerator__WEBPACK_IMPORTED_MODULE_15__.SparseVisibilityGraphGenerator;
    }
    get Obstacles() {
        return Array.from(this.ShapeToObstacleMap.values()).map((obs) => obs.InputShape);
    }
    // The collection of padded obstacle boundary polylines around the input shapes to route around.
    get PaddedObstacles() {
        return Array.from(this.ShapeToObstacleMap.values()).map((obs) => obs.PaddedPolyline);
    }
    // Add obstacles to the router.
    AddObstacles(obstacles) {
        this.AddShapes(obstacles);
        this.RebuildTreeAndGraph();
    }
    AddShapes(obstacles) {
        for (const shape of obstacles) {
            this.AddObstacleWithoutRebuild(shape);
        }
    }
    // Add a single obstacle to the router.
    AddObstacle(shape) {
        this.AddObstacleWithoutRebuild(shape);
        this.RebuildTreeAndGraph();
    }
    // For each Shapes, update its position and reroute as necessary.
    UpdateObstacles(obstacles) {
        for (const shape of obstacles) {
            this.UpdateObstacleWithoutRebuild(shape);
        }
        this.RebuildTreeAndGraph();
    }
    // For each Shapes, update its position and reroute as necessary.
    UpdateObstacle(obstacle) {
        this.UpdateObstacleWithoutRebuild(obstacle);
        this.RebuildTreeAndGraph();
    }
    // Remove obstacles from the router.
    RemoveObstacles(obstacles) {
        for (const shape of obstacles) {
            this.RemoveObstacleWithoutRebuild(shape);
        }
        this.RebuildTreeAndGraph();
    }
    // Removes an obstacle from the router.
    // <returns>All EdgeGeometries affected by the re-routing and re-nudging in order to avoid the new obstacle.</returns>
    RemoveObstacle(obstacle) {
        this.RemoveObstacleWithoutRebuild(obstacle);
        this.RebuildTreeAndGraph();
    }
    // utilities
    AddObstacleWithoutRebuild(shape) {
        if (shape.BoundaryCurve == null) {
            throw new Error('Shape must have a BoundaryCurve');
        }
        this.CreatePaddedObstacle(shape);
    }
    UpdateObstacleWithoutRebuild(shape) {
        if (shape.BoundaryCurve == null) {
            throw new Error('Shape must have a BoundaryCurve');
        }
        // Always do all of this even if the Shape objects are the same, because the BoundaryCurve probably changed.
        this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get(shape));
        this.CreatePaddedObstacle(shape);
    }
    CreatePaddedObstacle(shape) {
        const obstacle = new _obstacle__WEBPACK_IMPORTED_MODULE_12__.Obstacle(shape, this.Padding);
        this.ShapeToObstacleMap.set(shape, obstacle);
        this.PortManager.CreateObstaclePorts(obstacle);
    }
    RemoveObstacleWithoutRebuild(shape) {
        const obstacle = this.ShapeToObstacleMap.get(shape);
        this.ShapeToObstacleMap.delete(shape);
        this.PortManager.RemoveObstaclePorts(obstacle);
    }
    // Remove all obstacles from the graph.
    RemoveAllObstacles() {
        this.InternalClear(/* retainObstacles:*/ false);
    }
    RebuildTreeAndGraph() {
        const hadTree = this.ObsTree.Root != null;
        const hadVg = this.GraphGenerator.VisibilityGraph != null;
        this.InternalClear(/* retainObstacles:*/ true);
        if (hadTree) {
            this.GenerateObstacleTree();
        }
        if (hadVg) {
            this.GenerateVisibilityGraph();
        }
    }
    // The visibility graph generated by GenerateVisibilityGraph.
    get VisibilityGraph() {
        this.GenerateVisibilityGraph();
        return this.GraphGenerator.VisibilityGraph;
    }
    // Clears all data set into the router.
    Clear() {
        this.InternalClear(/* retainObstacles:*/ false);
    }
    static constructorEmpty() {
        return RectilinearEdgeRouter.constructorC(null);
        // pass-through default arguments to parameterized ctor
    }
    static constructorC(cancelToket) {
        return new RectilinearEdgeRouter([], RectilinearEdgeRouter.DefaultPadding, RectilinearEdgeRouter.DefaultCornerFitRadius);
    }
    // Constructor that takes the obstacles but uses defaults for other arguments.
    // as well as any intervening obstacles.</param>
    static constructorI(Obstacle) {
        return new RectilinearEdgeRouter(Obstacle, RectilinearEdgeRouter.DefaultPadding, RectilinearEdgeRouter.DefaultCornerFitRadius);
    }
    // Constructor for a router that does not use obstacle rectangles in the visibility graph.
    // as well as any intervening obstacles.</param>
    // The minimum padding from an obstacle's curve to its enclosing polyline.
    // The radius of the arc inscribed into path corners
    // but may select suboptimal paths</param>
    static constructorINN(obstacles, padding, cornerFitRadius) {
        return new RectilinearEdgeRouter(obstacles, padding, cornerFitRadius);
    }
    // Constructor specifying graph and shape information.
    // as well as any intervening obstacles.</param>
    // The minimum padding from an obstacle's curve to its enclosing polyline.
    // The radius of the arc inscribed into path corners
    // but may select suboptimal paths</param>
    // Use obstacle bounding boxes in visibility graph
    constructor(obstacles, padding, cornerFitRadius) {
        super(null);
        // If an edge does not connect to an obstacle it should stay away from it at least at the padding distance
        this.Padding = 0;
        /**  The radius of the arc inscribed into the path corners. */
        this.CornerFitRadius = 0;
        /** the minimal distance between to parrallel segments */
        this.edgeSeparatian = 3;
        // The relative penalty of a bend, representated as a percentage of the Manhattan distance between
        // two ports being connected.
        this.BendPenaltyAsAPercentageOfDistance = 0;
        // To support dynamic obstacles, we index obstacles by their Shape, which is
        // the unpadded inner obstacle boundary and contains a unique ID so we can
        // handle overlap due to dragging.
        this.ShapeToObstacleMap = new Map();
        // The list of EdgeGeometries to route
        this.EdgesToRoute = new Array();
        this.removeStaircases = true;
        this.selfEdges = new Array();
        this.Padding = padding;
        this.CornerFitRadius = cornerFitRadius;
        this.BendPenaltyAsAPercentageOfDistance = _SsstRectilinearPath__WEBPACK_IMPORTED_MODULE_16__.SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance;
        this.GraphGenerator = new _SparseVisibiltyGraphGenerator__WEBPACK_IMPORTED_MODULE_15__.SparseVisibilityGraphGenerator();
        this.PortManager = new _PortManager__WEBPACK_IMPORTED_MODULE_14__.PortManager(this.GraphGenerator);
        this.AddShapes(obstacles);
    }
    // The graph whose edges are being routed.
    // The minimum padding from an obstacle's curve to its enclosing polyline.
    // The radius of the arc inscribed into path corners
    // but may select suboptimal paths</param>
    // If true, use obstacle bounding boxes in visibility graph
    static constructorGNAN(graph, geomEdges, padding, cornerFitRadius) {
        const ret = new RectilinearEdgeRouter(_ShapeCreator__WEBPACK_IMPORTED_MODULE_8__.ShapeCreator.GetShapes(graph), padding, cornerFitRadius);
        if (geomEdges == null)
            for (const edge of graph.deepEdges) {
                ret.AddEdgeGeometryToRoute(edge);
            }
        else {
            for (const edge of geomEdges) {
                ret.AddEdgeGeometryToRoute(edge);
            }
        }
        return ret;
    }
    // Executes the algorithm.
    // Calculates the routed edges geometry, optionally forcing re-routing for existing paths.
    run() {
        this.GenerateVisibilityGraph();
        this.GeneratePaths();
    }
    GeneratePaths() {
        const edgePaths = this.EdgesToRoute.map((eg) => new _nudging_Path__WEBPACK_IMPORTED_MODULE_11__.Path(eg));
        this.FillEdgePathsWithShortestPaths(edgePaths);
        this.NudgePaths(edgePaths);
        this.RouteSelfEdges();
        this.FinaliseEdgeGeometries();
    }
    RouteSelfEdges() {
        for (const edge of this.selfEdges) {
            const t = { smoothedPolyline: null };
            edge.curve = _layout_core_geomEdge__WEBPACK_IMPORTED_MODULE_2__.GeomEdge.RouteSelfEdge(edge.sourcePort.Curve, Math.max(this.Padding, 2 * edge.GetMaxArrowheadLength()), t);
        }
    }
    FillEdgePathsWithShortestPaths(edgePaths) {
        this.PortManager.BeginRouteEdges();
        const shortestPathRouter = new _MsmtRectilinearPath__WEBPACK_IMPORTED_MODULE_10__.MsmtRectilinearPath(this.BendPenaltyAsAPercentageOfDistance);
        for (const edgePath of edgePaths) {
            this.AddControlPointsAndGeneratePath(shortestPathRouter, edgePath);
        }
        this.PortManager.EndRouteEdges();
    }
    AddControlPointsAndGeneratePath(shortestPathRouter, edgePath) {
        const intersectPoints = this.PortManager.GetPortVisibilityIntersection(edgePath.GeomEdge);
        if (intersectPoints != null) {
            this.GeneratePathThroughVisibilityIntersection(edgePath, intersectPoints);
            return;
        }
        this.SpliceVisibilityAndGeneratePath(shortestPathRouter, edgePath);
    }
    GeneratePathThroughVisibilityIntersection(edgePath, intersectPoints) {
        edgePath.PathPoints = intersectPoints;
    }
    SpliceVisibilityAndGeneratePath(shortestPathRouter, edgePath) {
        this.PortManager.AddControlPointsToGraph(edgePath.GeomEdge, this.ShapeToObstacleMap);
        // this.PortManager.TransUtil.DevTrace_VerifyAllVertices(this.VisibilityGraph)
        // this.PortManager.TransUtil.DevTrace_VerifyAllEdgeIntersections(
        //  this.VisibilityGraph,
        // )
        if (!this.GeneratePath(shortestPathRouter, edgePath, false)) {
            this.RetryPathsWithAdditionalGroupsEnabled(shortestPathRouter, edgePath);
        }
        this.PortManager.RemoveControlPointsFromGraph();
    }
    // ReSharper disable UnusedMember.Local
    GeneratePath(shortestPathRouter, edgePath, lastChance) {
        const sourceVertices = this.PortManager.FindVertices(edgePath.GeomEdge.sourcePort);
        const targetVertices = this.PortManager.FindVertices(edgePath.GeomEdge.targetPort);
        return RectilinearEdgeRouter.GetSingleStagePath(edgePath, shortestPathRouter, sourceVertices, targetVertices, lastChance);
    }
    static GetSingleStagePath(edgePath, shortestPathRouter, sourceVertices, targetVertices, lastChance) {
        edgePath.PathPoints = shortestPathRouter.GetPath(sourceVertices, targetVertices);
        if (lastChance) {
            RectilinearEdgeRouter.EnsureNonNullPath(edgePath);
        }
        return edgePath.PathPoints != null && edgePath.PathPoints.length > 0;
    }
    static EnsureNonNullPath(edgePath) {
        if (edgePath.PathPoints == null) {
            // Probably a fully-landlocked obstacle such as RectilinearTests.Route_Between_Two_Separately_Landlocked_Obstacles
            // or disconnected subcomponents due to excessive overlaps, such as Rectilinear(File)Tests.*Disconnected*.  In this
            // case, just put the single-bend path in there, even though it most likely cuts across unrelated obstacles.
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_13__.PointComparer.IsPureDirection(edgePath.GeomEdge.sourcePort.Location, edgePath.GeomEdge.targetPort.Location)) {
                edgePath.PathPoints = [edgePath.GeomEdge.sourcePort.Location, edgePath.GeomEdge.targetPort.Location];
            }
            else {
                edgePath.PathPoints = [
                    edgePath.GeomEdge.sourcePort.Location,
                    new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(edgePath.GeomEdge.sourcePort.Location.x, edgePath.GeomEdge.targetPort.Location.y),
                    edgePath.GeomEdge.targetPort.Location,
                ];
            }
        }
    }
    RetryPathsWithAdditionalGroupsEnabled(shortestPathRouter, edgePath) {
        // Insert any spatial parent groups that are not in our hierarchical parent tree and retry,
        // if we haven't already done this.
        if (!this.PortManager.SetAllAncestorsActive(edgePath.GeomEdge, this.ShapeToObstacleMap) ||
            !this.GeneratePath(shortestPathRouter, edgePath, false)) {
            // Last chance: enable all groups (if we have any).  Only do this on a per-path basis so a single degenerate
            // path won't make the entire graph look bad.
            this.PortManager.SetAllGroupsActive();
            this.GeneratePath(shortestPathRouter, edgePath, true);
        }
    }
    // static ShowPointEnum(p: Iterable<Point>) {
    //    //  ReSharper disable InconsistentNaming
    //    const w0: number = 0.1;
    //    const w1: number = 3;
    //    let arr: Point[] = p.toArray();
    //    let d: number = ((w1 - w0)
    //                / (arr.length - 1));
    //    let l = new Array<DebugCurve>();
    //    for (let i: number = 0; (i
    //                < (arr.length - 1)); i++) {
    //        l.Add(new DebugCurve(100, (w0
    //                            + (i * d)), "blue", new LineSegment(arr[i], arr[(i + 1)])));
    //    }
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    //    //  ReSharper restore InconsistentNaming
    // }
    NudgePaths(edgePaths) {
        // If we adjusted for spatial ancestors, this nudging can get very weird, so refetch in that case.
        const ancestorSets = this.ObsTree.SpatialAncestorsAdjusted ? _splineRouter__WEBPACK_IMPORTED_MODULE_9__.SplineRouter.GetAncestorSetsMap(this.Obstacles) : this.AncestorsSets;
        // Using VisibilityPolyline retains any reflection/staircases on the convex hull borders; using
        // PaddedPolyline removes them.
        _nudging_Nudger__WEBPACK_IMPORTED_MODULE_0__.Nudger.NudgePaths(edgePaths, this.edgeSeparatian, this.PaddedObstacles, ancestorSets, this.RemoveStaircases);
        // Nudger.NudgePaths(edgePaths, CornerFitRadius, this.ObstacleTree.GetAllPrimaryObstacles().Select(obs => obs.VisibilityPolyline), ancestorSets, RemoveStaircases);
    }
    get RemoveStaircases() {
        return this.removeStaircases;
    }
    set RemoveStaircases(value) {
        this.removeStaircases = value;
    }
    FinaliseEdgeGeometries() {
        for (const edgeGeom of this.EdgesToRoute.concat(this.selfEdges)) {
            if (edgeGeom.curve == null) {
                continue;
            }
            const poly = edgeGeom.curve instanceof _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline;
            if (poly) {
                edgeGeom.curve = RectilinearEdgeRouter.FitArcsIntoCorners(this.CornerFitRadius, Array.from(edgeGeom.curve));
            }
            RectilinearEdgeRouter.CalculateArrowheads(edgeGeom);
        }
    }
    CreateVisibilityGraph() {
        this.GraphGenerator.Clear();
        this.InitObstacleTree();
        this.GraphGenerator.GenerateVisibilityGraph();
        // if (DebugObject.dumpDebugCurves) DebugObject.dumpDebugCurves('./tmp/rvg.svg', this.mkDC())
    }
    // mkDC(): Array<DebugCurve> {
    //   const dc = new Array<DebugCurve>()
    //   dc.push(
    //     ...Array.from(this.VisibilityGraph.Edges).map((e) =>
    //       DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', LineSegment.mkPP(e.SourcePoint, e.TargetPoint)),
    //     ),
    //   )
    //   dc.push(...this.Obstacles.map((o) => DebugCurve.mkDebugCurveTWCI(100, 2, 'Red', o.BoundaryCurve)))
    //   return dc
    // }
    static CalculateArrowheads(edgeGeom) {
        _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_17__.Arrowhead.trimSplineAndCalculateArrowheadsII(edgeGeom, edgeGeom.sourcePort.Curve, edgeGeom.targetPort.Curve, edgeGeom.curve, true);
    }
    get ObsTree() {
        return this.GraphGenerator.ObstacleTree;
    }
    GenerateObstacleTree() {
        if (this.Obstacles == null || this.Obstacles.length === 0) {
            throw new Error('No obstacles have been added');
        }
        if (this.ObsTree.Root == null) {
            this.InitObstacleTree();
        }
    }
    InitObstacleTree() {
        this.AncestorsSets = _splineRouter__WEBPACK_IMPORTED_MODULE_9__.SplineRouter.GetAncestorSetsMap(this.Obstacles);
        this.ObsTree.Init(this.ShapeToObstacleMap.values(), this.AncestorsSets, this.ShapeToObstacleMap);
    }
    InternalClear(retainObstacles) {
        this.GraphGenerator.Clear();
        this.ClearShortestPaths();
        if (retainObstacles) {
            // Remove precalculated visibility, since we're likely revising obstacle positions.
            this.PortManager.ClearVisibility();
        }
        else {
            this.PortManager.Clear();
            this.ShapeToObstacleMap.clear();
            this.EdgesToRoute = [];
        }
    }
    ClearShortestPaths() {
        for (const edgeGeom of this.EdgesToRoute) {
            edgeGeom.curve = null;
        }
    }
    GenerateVisibilityGraph() {
        if (this.Obstacles == null || this.Obstacles.length === 0) {
            throw new Error('No obstacles have been set');
        }
        // Must test GraphGenerator.VisibilityGraph because this.VisibilityGraph calls back to
        // this function to ensure the graph is present.
        if (this.GraphGenerator.VisibilityGraph == null) {
            this.CreateVisibilityGraph();
        }
    }
    // ShowPathWithTakenEdgesAndGraph(path: Iterable<VisibilityVertex>, takenEdges: Set<VisibilityEdge>) {
    //    let list = new Array<VisibilityVertex>(path);
    //    let lines = new Array<LineSegment>();
    //    for (let i: number = 0; (i
    //                < (list.Count - 1)); i++) {
    //        lines.Add(new LineSegment(list[i].Point, list[(i + 1)].Point));
    //    }
    //    //  ReSharper disable InconsistentNaming
    //    let w0: number = 4;
    //    const let w1: number = 8;
    //    let delta: number = ((w1 - w0)
    //                / (list.Count - 1));
    //    let dc = new Array<DebugCurve>();
    //    for (let line: LineSegment of lines) {
    //        dc.Add(new DebugCurve(50, w0, "red", line));
    //        w0 = (w0 + delta);
    //    }
    //    dc.AddRange(takenEdges.Select(() => {  }, new DebugCurve(50, 2, "black", new LineSegment(edge.SourcePoint, edge.TargetPoint))));
    //    let k: Iterable<DebugCurve> = this.GetGraphDebugCurves();
    //    dc.AddRange(k);
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dc);
    //    //  ReSharper restore InconsistentNaming
    // }
    static FitArcsIntoCorners(radius, polyline) {
        if (radius == 0) {
            return _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_6__.Polyline.mkFromPoints(polyline);
        }
        const ellipses = RectilinearEdgeRouter.GetFittedArcSegs(radius, polyline);
        const curve = new _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve();
        let prevEllipse = null;
        for (const ellipse of ellipses) {
            const ellipseIsAlmostCurve = RectilinearEdgeRouter.EllipseIsAlmostLineSegment(ellipse);
            if (prevEllipse != null) {
                if (ellipseIsAlmostCurve) {
                    _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.continueWithLineSegmentP(curve, RectilinearEdgeRouter.CornerPoint(ellipse));
                }
                else {
                    _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.continueWithLineSegmentP(curve, ellipse.start);
                    curve.addSegment(ellipse);
                }
            }
            else if (ellipseIsAlmostCurve) {
                _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.addLineSegment(curve, polyline[0], RectilinearEdgeRouter.CornerPoint(ellipse));
            }
            else {
                _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.addLineSegment(curve, polyline[0], ellipse.start);
                curve.addSegment(ellipse);
            }
            prevEllipse = ellipse;
        }
        if (curve.segs.length > 0) {
            _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.continueWithLineSegmentP(curve, polyline[polyline.length - 1]);
        }
        else {
            _math_geometry_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.addLineSegment(curve, polyline[0], polyline[polyline.length - 1]);
        }
        return curve;
    }
    static CornerPoint(ellipse) {
        return ellipse.center.add(ellipse.aAxis.add(ellipse.bAxis));
    }
    static EllipseIsAlmostLineSegment(ellipse) {
        return ellipse.aAxis.lengthSquared < 0.0001 || ellipse.aAxis.lengthSquared < 0.0001;
    }
    static *GetFittedArcSegs(radius, polyline) {
        let leg = polyline[1].sub(polyline[0]);
        let dir = leg.normalize();
        let rad0 = Math.min(radius, leg.length / 2);
        for (let i = 1; i < polyline.length - 1; i++) {
            leg = polyline[i + 1].sub(polyline[i]);
            const legLength = leg.length;
            if (legLength < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_5__.GeomConstants.intersectionEpsilon) {
                yield new _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_4__.Ellipse(0, 0, new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0), new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0), polyline[i]);
                continue;
            }
            const ndir = leg.div(legLength);
            if (Math.abs(ndir.dot(dir)) > 0.9) {
                yield new _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_4__.Ellipse(0, 0, new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0), new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0), polyline[i]);
            }
            const nrad0 = Math.min(radius, leg.length / 2);
            const axis0 = ndir.mul(-nrad0);
            const axis1 = dir.mul(rad0);
            yield new _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_4__.Ellipse(0, Math.PI / 2, axis0, axis1, polyline[i].sub(axis1.add(axis0)));
            dir = ndir;
            rad0 = nrad0;
        }
    }
}
// The padding from an obstacle's curve to its enclosing polyline.
RectilinearEdgeRouter.DefaultPadding = 1;
// The default radius of the arc inscribed into path corners.
RectilinearEdgeRouter.DefaultCornerFitRadius = 3;
//# sourceMappingURL=RectilinearEdgeRouter.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearInteractiveEditor.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RectilinearInteractiveEditor: () => (/* binding */ RectilinearInteractiveEditor)
/* harmony export */ });
/* harmony import */ var _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/arrowhead.js");
/* harmony import */ var _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/relativeFloatingPort.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/cornerSite.js");
/* harmony import */ var _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/smoothedPolyline.js");
/* harmony import */ var _RelativeShape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/RelativeShape.js");
/* harmony import */ var _RectilinearEdgeRouter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearEdgeRouter.js");







class RectilinearInteractiveEditor {
    static CreatePortsAndRouteEdges(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, ct = null) {
        const r = RectilinearInteractiveEditor.FillRouter(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode);
        r.run();
        RectilinearInteractiveEditor.CreateSelfEdges(Array.from(geometryEdges).filter((e) => e.sourcePort.Location === e.targetPort.Location), cornerFitRadius);
    }
    //  Create a RectilinearEdgeRouter from the passed obstacleNodes, with one port at the center of each obstacle,
    //  and route between the obstacles, with default bend penalty.
    static CreatePortsAndRouteEdges_(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph, useObstacleRectangles) {
        RectilinearInteractiveEditor.CreatePortsAndRouteEdges(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode);
    }
    //  Create a RectilinearEdgeRouter from the passed obstacleNodes, with one port at the center of each obstacle,
    //  and route between the obstacles, with default bend penalty.
    static CreatePortsAndRouteEdges__(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode, useSparseVisibilityGraph) {
        RectilinearInteractiveEditor.CreatePortsAndRouteEdges(cornerFitRadius, padding, obstacleNodes, geometryEdges, edgeRoutingMode);
    }
    //  Create a RectilinearEdgeRouter populated with the passed obstacles.
    //  <returns>The populated RectilinearEdgeRouter</returns>
    static FillRouter(cornerFitRadius, padding, obstacleNodes, geomEdges, edgeRoutingMode) {
        // Assert.assert(
        //   EdgeRoutingMode.Rectilinear === edgeRoutingMode || EdgeRoutingMode.RectilinearToCenter === edgeRoutingMode,
        //   'Non-rectilinear edgeRoutingMode',
        // )
        const nodeShapesMap = new Map();
        RectilinearInteractiveEditor.FillNodeShapesMap(obstacleNodes, geomEdges, nodeShapesMap);
        const router = new _RectilinearEdgeRouter__WEBPACK_IMPORTED_MODULE_6__.RectilinearEdgeRouter(nodeShapesMap.values(), padding, cornerFitRadius);
        for (const geomEdge of geomEdges) {
            geomEdge.sourcePort = first(nodeShapesMap.get(geomEdge.source).Ports);
            geomEdge.targetPort = first(nodeShapesMap.get(geomEdge.target).Ports);
            router.AddEdgeGeometryToRoute(geomEdge);
        }
        return router;
    }
    static FillNodeShapesMap(obstacleNodes, geomEdges, nodeShapeMap) {
        for (const node of obstacleNodes) {
            const shape = RectilinearInteractiveEditor.CreateShapeWithRelativeNodeAtCenter(node);
            nodeShapeMap.set(node, shape);
        }
        for (const e of geomEdges) {
            let node = e.source;
            if (!nodeShapeMap.has(node)) {
                nodeShapeMap.set(node, RectilinearInteractiveEditor.CreateShapeWithRelativeNodeAtCenter(node));
            }
            node = e.target;
            if (!nodeShapeMap.has(node)) {
                nodeShapeMap.set(node, RectilinearInteractiveEditor.CreateShapeWithRelativeNodeAtCenter(node));
            }
        }
    }
    static CreateSelfEdges(selfEdges, cornerFitRadius) {
        for (const edge of selfEdges) {
            RectilinearInteractiveEditor.CreateSimpleEdgeCurveWithGivenFitRadius(edge, cornerFitRadius);
        }
    }
    //
    static CreateSimpleEdgeCurveWithGivenFitRadius(edge, cornerFitRadius) {
        const a = edge.source.center;
        const b = edge.target.center;
        if (edge.source === edge.target) {
            const dx = edge.source.boundaryCurve.boundingBox.width / 2;
            const dy = edge.source.boundingBox.height / 4;
            edge.smoothedPolyline = RectilinearInteractiveEditor.CreateUnderlyingPolylineForSelfEdge(a, dx, dy);
            for (let site = edge.smoothedPolyline.headSite.next; site.next != null; site = site.next) {
                RectilinearInteractiveEditor.CalculateCoefficiensUnderSite(site, cornerFitRadius);
            }
            edge.curve = edge.smoothedPolyline.createCurve();
        }
        else {
            edge.smoothedPolyline = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_4__.SmoothedPolyline.mkFromPoints([a, b]);
            edge.curve = edge.smoothedPolyline.createCurve();
        }
        if (!_layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_0__.Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, edge.curve, true)) {
            _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_0__.Arrowhead.createBigEnoughSpline(edge);
        }
    }
    //  creates an edge curve based only on the source and target geometry
    static CreateSimpleEdgeCurve(edge) {
        const a = edge.source.center;
        const b = edge.target.center;
        if (edge.source === edge.target) {
            const dx = edge.source.boundaryCurve.boundingBox.width / 2;
            const dy = edge.source.boundingBox.height / 4;
            edge.smoothedPolyline = RectilinearInteractiveEditor.CreateUnderlyingPolylineForSelfEdge(a, dx, dy);
            edge.curve = edge.smoothedPolyline.createCurve();
        }
        else {
            edge.smoothedPolyline = _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_4__.SmoothedPolyline.mkFromPoints([a, b]);
            edge.curve = edge.smoothedPolyline.createCurve();
        }
        if (!_layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_0__.Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, edge.curve, true)) {
            _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_0__.Arrowhead.createBigEnoughSpline(edge);
        }
    }
    static CreateUnderlyingPolylineForSelfEdge(p0, dx, dy) {
        const p1 = p0.add(new _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Point(0, dy));
        const p2 = p0.add(new _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Point(dx, dy));
        const p3 = p0.add(new _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Point(dx, dy * -1));
        const p4 = p0.add(new _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Point(0, dy * -1));
        let site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_3__.CornerSite.mkSiteP(p0);
        const polyline = new _math_geometry_smoothedPolyline__WEBPACK_IMPORTED_MODULE_4__.SmoothedPolyline(site);
        site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_3__.CornerSite.mkSiteSP(site, p1);
        site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_3__.CornerSite.mkSiteSP(site, p2);
        site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_3__.CornerSite.mkSiteSP(site, p3);
        site = _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_3__.CornerSite.mkSiteSP(site, p4);
        _math_geometry_cornerSite__WEBPACK_IMPORTED_MODULE_3__.CornerSite.mkSiteSP(site, p0);
        return polyline;
    }
    //  Create a Shape with a single relative port at its center.
    static CreateShapeWithRelativeNodeAtCenter(node) {
        const shape = new _RelativeShape__WEBPACK_IMPORTED_MODULE_5__.RelativeShape(node);
        shape.Ports.add(new _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_1__.RelativeFloatingPort(() => node.boundaryCurve, () => node.center, new _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Point(0, 0)));
        return shape;
    }
    static CalculateCoefficiensUnderSite(site, radius) {
        let l = radius / site.point.sub(site.prev.point).length;
        l = Math.min(0.5, l);
        site.previouisBezierCoefficient = l;
        l = radius / site.next.point.sub(site.point).length;
        l = Math.min(0.5, l);
        site.nextBezierCoefficient = l;
    }
}
function first(collection) {
    for (const t of collection) {
        return t;
    }
}
//# sourceMappingURL=RectilinearInteractiveEditor.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearScanLine.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RectilinearScanLine: () => (/* binding */ RectilinearScanLine)
/* harmony export */ });
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/BasicObstacleSide.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");
/* harmony import */ var _VisibilityGraphGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/VisibilityGraphGenerator.js");





class RectilinearScanLine {
    constructor(scanDir, start) {
        this.scanDirection = scanDir;
        this.SideTree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_0__.RBTree((a, b) => this.Compare(a, b));
        this.linePositionAtLastInsertOrRemove = start;
    }
    Insert(side, scanPos) {
        //        DevTraceInfo(1, "prev LinePos = {0}, new LinePos = {1}, inserting side = {2}", this.linePositionAtLastInsertOrRemove, scanPos, side.ToString());
        // Assert(!scanDirection.IsFlat(side), "Flat sides are not allowed in the scanline");
        // Assert(null == Find(side), "side already exists in the ScanLine");
        this.linePositionAtLastInsertOrRemove = scanPos;
        // RBTree's internal operations on insert/remove etc. mean the node can't cache the
        // RBNode returned by insert(); instead we must do find() on each call.  But we can
        // use the returned node to get predecessor/successor.
        const node = this.SideTree.insert(side);
        // DevTraceDump(2);
        return node;
    }
    get Count() {
        return this.SideTree.count;
    }
    Remove(side, scanPos) {
        /*Assert.assert(
          null !=  this.Find(side),
          'side does not exist in the ScanLine',
        )*/
        this.linePositionAtLastInsertOrRemove = scanPos;
        this.SideTree.remove(side);
    }
    Find(side) {
        // Sides that start after the current position cannot be in the scanline.
        if (-1 === this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove, side.Start)) {
            return null;
        }
        return this.SideTree.find(side);
    }
    NextLowB(side) {
        return this.NextLowR(this.Find(side));
    }
    NextLowR(sideNode) {
        const pred = this.SideTree.previous(sideNode);
        return pred;
    }
    NextHighB(side) {
        return this.NextHighR(this.Find(side));
    }
    NextHighR(sideNode) {
        const succ = this.SideTree.next(sideNode);
        return succ;
    }
    Next(dir, sideNode) {
        const succ = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_3__.StaticGraphUtility.IsAscending(dir) ? this.SideTree.next(sideNode) : this.SideTree.previous(sideNode);
        return succ;
    }
    Lowest() {
        return this.SideTree.treeMinimum();
    }
    // For ordering lines along the scanline at segment starts/ends.
    Compare(first, second) {
        // If these are two sides of the same obstacle then the ordering is obvious.
        if (first.Obstacle === second.Obstacle) {
            if (first === second) {
                return 0;
            }
            return first instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_2__.LowObstacleSide ? -1 : 1;
        }
        // RectilinearScanLine.Debug_VerifySidesDoNotIntersect(first, second)
        // Other than intersecting sides at vertices of the same obstacle, there should be no interior intersections...
        const firstIntersect = _VisibilityGraphGenerator__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraphGenerator.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove, first, this.scanDirection);
        const secondIntersect = _VisibilityGraphGenerator__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraphGenerator.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove, second, this.scanDirection);
        let cmp = firstIntersect.compareTo(secondIntersect);
        // ... but we may still have rectangular sides that coincide, or angled sides that are close enough here but
        // are not detected by the convex-hull overlap calculations.  In those cases, we refine the comparison by side
        // type, with High coming before Low, and then by obstacle ordinal if needed. Because there are no interior
        // intersections, this ordering will remain valid as long as the side(s) are in the scanline.
        if (0 === cmp) {
            const firstIsLow = first instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_2__.LowObstacleSide;
            const secondIsLow = second instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_2__.LowObstacleSide;
            cmp = (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareBooleans)(firstIsLow, secondIsLow);
            if (0 === cmp) {
                cmp = (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(first.Obstacle.Ordinal, second.Obstacle.Ordinal);
            }
        }
        return cmp;
    }
}
//# sourceMappingURL=RectilinearScanLine.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/ScanDirection.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScanDirection: () => (/* binding */ ScanDirection)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");




class ScanDirection {
    get Dir() {
        return this.dir;
    }
    set Dir(value) {
        this.dir = value;
    }
    // Use the internal static xxxInstance properties to get an instance.
    constructor(directionAlongScanLine) {
        /*Assert.assert(
          StaticGraphUtility.IsAscending(directionAlongScanLine),
          'directionAlongScanLine must be ascending',
        )*/
        this.Dir = directionAlongScanLine;
        this.DirectionAsPoint = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.toPoint(this.Dir);
        this.PerpDirection = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North === directionAlongScanLine ? _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East : _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
        this.PerpDirectionAsPoint = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.toPoint(this.PerpDirection);
        this.OppositeDirection = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.OppositeDir(directionAlongScanLine);
    }
    get IsHorizontal() {
        return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East === this.Dir;
    }
    get IsVertical() {
        return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North === this.Dir;
    }
    // Compare in perpendicular direction first, then parallel direction.
    Compare(lhs, rhs) {
        const cmp = this.ComparePerpCoord(lhs, rhs);
        return 0 !== cmp ? cmp : this.CompareScanCoord(lhs, rhs);
    }
    CompareScanCoord(lhs, rhs) {
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(lhs.sub(rhs).dot(this.DirectionAsPoint), 0);
    }
    ComparePerpCoord(lhs, rhs) {
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(lhs.sub(rhs).dot(this.PerpDirectionAsPoint), 0);
    }
    IsFlatS(seg) {
        return this.IsFlatPP(seg.Start, seg.End);
    }
    IsFlatPP(start, end) {
        // Return true if there is no change in the perpendicular direction.
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Equal(end.sub(start).dot(this.PerpDirectionAsPoint), 0);
    }
    IsPerpendicularS(seg) {
        return this.IsPerpendicularPP(seg.Start, seg.End);
    }
    IsPerpendicularPP(start, end) {
        // Return true if there is no change in the primary direction.
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Equal(end.sub(start).dot(this.DirectionAsPoint), 0);
    }
    Coord(point) {
        return point.dot(this.DirectionAsPoint);
    }
    Min(first, second) {
        return this.Compare(first, second) <= 0 ? first : second;
    }
    Max(first, second) {
        return this.Compare(first, second) >= 0 ? first : second;
    }
    get PerpendicularInstance() {
        return this.IsHorizontal ? ScanDirection.VerticalInstance : ScanDirection.HorizontalInstance;
    }
    static GetInstance(dir) {
        return _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_3__.StaticGraphUtility.IsVerticalD(dir) ? ScanDirection.VerticalInstance : ScanDirection.HorizontalInstance;
    }
    ToString() {
        return this.Dir.toString();
    }
}
ScanDirection.HorizontalInstance = new ScanDirection(_math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East);
ScanDirection.VerticalInstance = new ScanDirection(_math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North);
//# sourceMappingURL=ScanDirection.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScanSegment: () => (/* binding */ ScanSegment)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _visibility_SegmentBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/SegmentBase.js");
/* harmony import */ var _visibility_VisibilityEdge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityEdge.js");
/* harmony import */ var _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _PointAndCrossingsList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointAndCrossingsList.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _ScanDirection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanDirection.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");
// import {Curve} from '../../math/geometry/curve'









class ScanSegment extends _visibility_SegmentBase__WEBPACK_IMPORTED_MODULE_2__.SegmentBase {
    static mk(start, end) {
        return new ScanSegment(start, end, ScanSegment.NormalWeight, /* gbcList:*/ null);
    }
    constructor(start, end, weight, gbcList) {
        super();
        this.Update(start, end);
        this.Weight = weight;
        this.GroupBoundaryPointAndCrossingsList = gbcList;
    }
    get Start() {
        return this.startPoint;
    }
    get End() {
        return this.endPoint;
    }
    get IsVertical() {
        return ScanSegment.IsVerticalSegment(this.Start, this.End);
    }
    get ScanDirection() {
        return this.IsVertical ? _ScanDirection__WEBPACK_IMPORTED_MODULE_7__.ScanDirection.VerticalInstance : _ScanDirection__WEBPACK_IMPORTED_MODULE_7__.ScanDirection.HorizontalInstance;
    }
    // For overlaps, we will need to create a VisibilityVertex at the junction of overlapped/nonoverlapped
    // segments, but we don't want to create this for non-overlapped situations.
    get IsOverlapped() {
        return ScanSegment.OverlappedWeight === this.Weight;
    }
    get IsReflection() {
        return ScanSegment.ReflectionWeight === this.Weight;
    }
    static IsVerticalSegment(start, end) {
        return start.x === end.x;
    }
    MergeGroupBoundaryCrossingList(other) {
        if (other != null) {
            if (this.GroupBoundaryPointAndCrossingsList == null) {
                this.GroupBoundaryPointAndCrossingsList = new _PointAndCrossingsList__WEBPACK_IMPORTED_MODULE_5__.PointAndCrossingsList();
            }
            this.GroupBoundaryPointAndCrossingsList.MergeFrom(other);
        }
    }
    TrimGroupBoundaryCrossingList() {
        if (this.GroupBoundaryPointAndCrossingsList != null) {
            this.GroupBoundaryPointAndCrossingsList.Trim(this.Start, this.End);
        }
    }
    // ctor
    Update(start, end) {
        /*Assert.assert(
          PointComparer.EqualPP(start, end) ||
            StaticGraphUtility.IsAscending(PointComparer.GetDirections(start, end)),
          'non-ascending segment',
        )*/
        this.startPoint = start;
        this.endPoint = end;
    }
    SetInitialVisibilityVertex(newVertex) {
        this.LowestVisibilityVertex = newVertex;
        this.HighestVisibilityVertex = newVertex;
    }
    AppendVisibilityVertex(vg, newVertex) {
        /*Assert.assert(newVertex != null, 'newVertex must not be null')*/
        /*Assert.assert(
          (this.LowestVisibilityVertex == null ) ==
            (this.HighestVisibilityVertex == null ),
          'Mismatched null Lowest/HighestVisibilityVertex',
        )*/
        /*Assert.assert(
          StaticGraphUtility.PointIsOnSegmentSP(this, newVertex.point),
          'newVertex is out of segment range',
        )*/
        if (this.HighestVisibilityVertex == null) {
            if (!this.AddGroupCrossingsBeforeHighestVisibilityVertex(vg, newVertex)) {
                this.SetInitialVisibilityVertex(newVertex);
            }
        }
        else {
            // In the event of overlaps where ScanSegments share a Start/End at a border, SegmentIntersector
            // may be appending the same Vertex twice.  If that point is on the border of a group,
            // then we may have just added the border-crossing edge as well.
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.IsPureLower(newVertex.point, this.HighestVisibilityVertex.point)) {
                /*Assert.assert(
                  null !=
                    vg.FindEdgePP(newVertex.point, this.HighestVisibilityVertex.point),
                  'unexpected low/middle insertion to ScanSegment',
                )*/
                return;
            }
            // Add the new edge.  This will always be in the ascending direction.
            if (!this.AddGroupCrossingsBeforeHighestVisibilityVertex(vg, newVertex)) {
                this.AppendHighestVisibilityVertex(newVertex);
            }
        }
    }
    AddVisibilityEdge(source, target) {
        /*Assert.assert(source.point !== target.point, 'Self-edges are not allowed')*/
        /*Assert.assert(
          PointComparer.IsPureLower(source.point, target.point),
          'Impure or reversed direction encountered',
        )*/
        // Make sure we aren't adding two edges in the same direction to the same vertex.
        /*Assert.assert(
          StaticGraphUtility.FindAdjacentVertex(
            source,
            StaticGraphUtility.EdgeDirectionVV(source, target),
          ) == null ,
          'Duplicate outEdge from Source vertex',
        )*/
        /*Assert.assert(
          StaticGraphUtility.FindAdjacentVertex(
            target,
            StaticGraphUtility.EdgeDirectionVV(target, source),
          ) == null ,
          'Duplicate inEdge to Target vertex',
        )*/
        const edge = new _visibility_VisibilityEdge__WEBPACK_IMPORTED_MODULE_3__.VisibilityEdge(source, target, this.Weight);
        _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraph.AddEdge(edge);
        return edge;
    }
    AppendHighestVisibilityVertex(newVertex) {
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.EqualPP(this.HighestVisibilityVertex.point, newVertex.point)) {
            this.AddVisibilityEdge(this.HighestVisibilityVertex, newVertex);
            this.HighestVisibilityVertex = newVertex;
        }
    }
    LoadStartOverlapVertexIfNeeded(vg) {
        // For adjacent segments with different IsOverlapped, we need a vertex that
        // joins the two so a path may be run.  This is paired with the other segment's
        // LoadEndOverlapVertexIfNeeded.
        if (this.NeedStartOverlapVertex) {
            const vertex = vg.FindVertex(this.Start);
            this.AppendVisibilityVertex(vg, vertex !== null && vertex !== void 0 ? vertex : vg.AddVertexP(this.Start));
        }
    }
    LoadEndOverlapVertexIfNeeded(vg) {
        // See comments in LoadStartOverlapVertexIfNeeded.
        if (this.NeedEndOverlapVertex) {
            const vertex = vg.FindVertex(this.End);
            this.AppendVisibilityVertex(vg, vertex !== null && vertex !== void 0 ? vertex : vg.AddVertexP(this.End));
        }
    }
    OnSegmentIntersectorBegin(vg) {
        // If we process any group crossings, they'll have created the first point.
        if (!this.AppendGroupCrossingsThroughPoint(vg, this.Start)) {
            this.LoadStartOverlapVertexIfNeeded(vg);
        }
    }
    OnSegmentIntersectorEnd(vg) {
        this.AppendGroupCrossingsThroughPoint(vg, this.End);
        this.GroupBoundaryPointAndCrossingsList = null;
        if (this.HighestVisibilityVertex == null || _PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.IsPureLower(this.HighestVisibilityVertex.point, this.End)) {
            this.LoadEndOverlapVertexIfNeeded(vg);
        }
    }
    // If we have collinear segments, then we may be able to just update the previous one
    // instead of growing the ScanSegmentTree.
    // - For multiple collinear OpenVertexEvents, neighbors to the high side have not yet
    //   been seen, so a segment is created that spans the lowest and highest neighbors.
    //   A subsequent collinear OpenVertexEvent will be to the high side and will add a
    //   subsegment of that segment, so we subsume it into LastAddedSegment.
    // - For multiple collinear CloseVertexEvents, closing neighbors to the high side are
    //   still open, so a segment is created from the lowest neighbor to the next-highest
    //   collinear obstacle to be closed.  When that next-highest CloseVertexEvent is
    //   encountered, it will extend LastAddedSegment.
    // - For multiple collinear mixed Open and Close events, we'll do all Opens first,
    //   followed by all closes (per EventQueue opening), so we may add multiple discrete
    //   segments, which ScanSegmentTree will merge.
    static Subsume(t, newStart, newEnd, weight, gbcList, scanDir, tree, ot) {
        // Initialize these to the non-subsumed state; the endpoints were extended (or on a
        // different line).
        ot.extendStart = true;
        ot.extendEnd = true;
        if (t.seg == null) {
            return false;
        }
        // If they don't overlap (including touching at an endpoint), we don't subsume.
        if (!_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_8__.StaticGraphUtility.IntervalsOverlapPPPP(t.seg.Start, t.seg.End, newStart, newEnd)) {
            return false;
        }
        // If the overlapped-ness isn't the same, we don't subsume.  ScanSegmentTree::MergeSegments
        // will mark that the low-to-high direction needs a VisibilityVertex to link the two segments.
        // These may differ by more than Curve.DistanceEpsilon in the case of reflection lookahead
        // segments collinear with vertex-derived segments, so have a looser tolerance here and we'll
        // adjust the segments in ScanSegmentTree.MergeSegments.
        if (t.seg.Weight !== weight) {
            if (t.seg.Start === newStart && t.seg.End === newEnd) {
                // This is probably because of a rounding difference by one DistanceEpsilon reporting being
                // inside an obstacle vs. the scanline intersection calculation side-ordering.
                // Test is RectilinearFileTests.Overlap_Rounding_Vertex_Intersects_Side.
                t.seg.Weight = Math.min(t.seg.Weight, weight);
                return true;
            }
            // In the case of groups, we go through the group boundary; this may coincide with a
            // reflection segment. RectilinearFileTests.ReflectionSubsumedBySegmentExitingGroup.
            /*Assert.assert(
              (t.seg.Weight === ScanSegment.OverlappedWeight) ==
                (weight === ScanSegment.OverlappedWeight) ||
                Curve.closeIntersectionPoints(t.seg.End, newStart) ||
                Curve.closeIntersectionPoints(t.seg.Start, newEnd),
              'non-equal overlap-mismatched ScanSegments overlap by more than just Start/End',
            )*/
            return false;
        }
        // Subsume the input segment.  Return whether the start/end points were extended (newStart
        // is before this.Start, or newEnd is after this.End), so the caller can generate reflections
        // and so we can merge group border crossings.
        ot.extendStart = -1 === scanDir.CompareScanCoord(newStart, t.seg.Start);
        ot.extendEnd = 1 === scanDir.CompareScanCoord(newEnd, t.seg.End);
        if (ot.extendStart || ot.extendEnd) {
            // We order by start and end so need to replace this in the tree regardless of which end changes.
            tree.Remove(t.seg);
            t.seg.startPoint = scanDir.Min(t.seg.Start, newStart);
            t.seg.endPoint = scanDir.Max(t.seg.End, newEnd);
            t.seg = tree.InsertUnique(t.seg).item;
            t.seg.MergeGroupBoundaryCrossingList(gbcList);
        }
        return true;
    }
    IntersectsSegment(seg) {
        return _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_8__.StaticGraphUtility.SegmentsIntersection(this, seg) !== undefined;
    }
    toString() {
        return '[' + this.Start + ' -> ' + this.End + (this.IsOverlapped ? ' olap' : ' free') + ']';
    }
    ContainsPoint(test) {
        // This may be off the line so do not use GetPureDirections.
        return (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.EqualPP(this.Start, test) ||
            _PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.EqualPP(this.End, test) ||
            _PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.GetDirections(this.Start, test) === _PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.GetDirections(test, this.End));
    }
    get HasSparsePerpendicularCoords() {
        return this.sparsePerpendicularCoords == null ? false : this.sparsePerpendicularCoords.size > 0;
    }
    CreatePointFromPerpCoord(perpCoord) {
        return this.IsVertical ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.Start.x, perpCoord) : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(perpCoord, this.Start.y);
    }
    AddSparseVertexCoord(perpCoord) {
        /*Assert.assert(
          this.ContainsPoint(this.CreatePointFromPerpCoord(perpCoord)),
          'vertexLocation is not on Segment',
        )*/
        if (this.sparsePerpendicularCoords == null) {
            this.sparsePerpendicularCoords = new Set();
        }
        this.sparsePerpendicularCoords.add(perpCoord);
    }
    AddSparseEndpoint(coord) {
        // This is called after AddSparseVertexCoord so this.sparsePerpendicularCoords is already instantiated.
        if (!this.sparsePerpendicularCoords.has(coord)) {
            this.sparsePerpendicularCoords.add(coord);
            return true;
        }
        return false;
    }
    CreateSparseVerticesAndEdges(vg) {
        var _a;
        if (this.sparsePerpendicularCoords == null) {
            return;
        }
        this.AppendGroupCrossingsThroughPoint(vg, this.Start);
        for (const perpCoord of Array.from(this.sparsePerpendicularCoords.values()).sort(_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)) {
            const vertexLocation = this.CreatePointFromPerpCoord(perpCoord);
            /*Assert.assert(
              this.ContainsPoint(vertexLocation),
              'vertexLocation is not on Segment',
            )*/
            this.AppendVisibilityVertex(vg, (_a = vg.FindVertex(vertexLocation)) !== null && _a !== void 0 ? _a : vg.AddVertexP(vertexLocation));
        }
        this.AppendGroupCrossingsThroughPoint(vg, this.End);
        this.GroupBoundaryPointAndCrossingsList = null;
        this.sparsePerpendicularCoords.clear();
        this.sparsePerpendicularCoords = null;
    }
    HasVisibility() {
        // Skip this only if it has no visibility vertex.
        return null != this.LowestVisibilityVertex;
    }
    AddGroupCrossingsBeforeHighestVisibilityVertex(vg, newVertex) {
        if (this.AppendGroupCrossingsThroughPoint(vg, newVertex.point)) {
            // We may have added an interior vertex that is just higher than newVertex.
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.IsPureLower(this.HighestVisibilityVertex.point, newVertex.point)) {
                this.AddVisibilityEdge(this.HighestVisibilityVertex, newVertex);
                this.HighestVisibilityVertex = newVertex;
            }
            return true;
        }
        return false;
    }
    AppendGroupCrossingsThroughPoint(vg, lastPoint) {
        var _a;
        if (this.GroupBoundaryPointAndCrossingsList == null) {
            return false;
        }
        let found = false;
        while (this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(lastPoint)) {
            // We will only create crossing Edges that the segment actually crosses, not those it ends before crossing.
            // For those terminal crossings, the adjacent segment creates the interior vertex and crossing edge.
            const pac = this.GroupBoundaryPointAndCrossingsList.Pop();
            let lowDirCrossings = null;
            let highDirCrossings = null;
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.ComparePP(pac.Location, this.Start) > 0) {
                lowDirCrossings = _PointAndCrossingsList__WEBPACK_IMPORTED_MODULE_5__.PointAndCrossingsList.ToCrossingArray(pac.Crossings, this.ScanDirection.OppositeDirection);
            }
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.ComparePP(pac.Location, this.End) < 0) {
                highDirCrossings = _PointAndCrossingsList__WEBPACK_IMPORTED_MODULE_5__.PointAndCrossingsList.ToCrossingArray(pac.Crossings, this.ScanDirection.Dir);
            }
            found = true;
            const crossingVertex = (_a = vg.FindVertex(pac.Location)) !== null && _a !== void 0 ? _a : vg.AddVertexP(pac.Location);
            vg.AddVertexP(pac.Location);
            if (null != lowDirCrossings || null != highDirCrossings) {
                this.AddLowCrossings(vg, crossingVertex, lowDirCrossings);
                this.AddHighCrossings(vg, crossingVertex, highDirCrossings);
            }
            else {
                // This is at this.Start with only lower-direction toward group interior(s), or at this.End with only
                // higher-direction toward group interior(s).  Therefore an adjacent ScanSegment will create the crossing
                // edge, so create the crossing vertex here and we'll link to it.
                if (this.LowestVisibilityVertex == null) {
                    this.SetInitialVisibilityVertex(crossingVertex);
                }
                else {
                    /*Assert.assert(
                      PointComparer.EqualPP(this.End, crossingVertex.point),
                      'Expected this.End crossingVertex',
                    )*/
                    this.AppendHighestVisibilityVertex(crossingVertex);
                }
            }
        }
        return found;
    }
    static GetCrossingInteriorVertex(vg, crossingVertex, crossing) {
        var _a;
        const interiorPoint = crossing.GetInteriorVertexPoint(crossingVertex.point);
        return (_a = vg.FindVertex(interiorPoint)) !== null && _a !== void 0 ? _a : vg.AddVertexP(interiorPoint);
    }
    AddCrossingEdge(vg, lowVertex, highVertex, crossings) {
        let edge = null;
        if (null != this.HighestVisibilityVertex) {
            // We may have a case where point xx.xxxxx8 has added an ascending-direction crossing, and now we're on
            // xx.xxxxx9 adding a descending-direction crossing.  In that case there should already be a VisibilityEdge
            // in the direction we want.
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.EqualPP(this.HighestVisibilityVertex.point, highVertex.point)) {
                edge = vg.FindEdgePP(lowVertex.point, highVertex.point);
                /*Assert.assert(
                  edge != null,
                  'Inconsistent forward-backward sequencing in HighVisibilityVertex',
                )*/
            }
            else {
                this.AppendHighestVisibilityVertex(lowVertex);
            }
        }
        if (edge == null) {
            edge = this.AddVisibilityEdge(lowVertex, highVertex);
        }
        const crossingsArray = crossings.map((c) => c.Group.InputShape);
        const prevIsPassable = edge.IsPassable;
        if (prevIsPassable == null) {
            edge.IsPassable = () => {
                for (const s of crossingsArray)
                    if (s.IsTransparent)
                        return true;
                return false;
            };
        }
        else {
            // Because we don't have access to the previous delegate's internals, we have to chain.  Fortunately this
            // will never be more than two deep.  File Test: Groups_Forward_Backward_Between_Same_Vertices.
            edge.IsPassable = () => {
                for (const s of crossingsArray)
                    if (s.IsTransparent || prevIsPassable())
                        return true;
                return false;
            };
        }
        if (this.LowestVisibilityVertex == null) {
            this.SetInitialVisibilityVertex(lowVertex);
        }
        this.HighestVisibilityVertex = highVertex;
    }
    AddLowCrossings(vg, crossingVertex, crossings) {
        if (crossings != null) {
            const interiorVertex = ScanSegment.GetCrossingInteriorVertex(vg, crossingVertex, crossings[0]);
            this.AddCrossingEdge(vg, interiorVertex, crossingVertex, crossings);
            // low-to-high
        }
    }
    AddHighCrossings(vg, crossingVertex, crossings) {
        if (crossings != null) {
            const interiorVertex = ScanSegment.GetCrossingInteriorVertex(vg, crossingVertex, crossings[0]);
            this.AddCrossingEdge(vg, crossingVertex, interiorVertex, crossings);
            // low-to-high
        }
    }
}
ScanSegment.NormalWeight = _visibility_VisibilityEdge__WEBPACK_IMPORTED_MODULE_3__.VisibilityEdge.DefaultWeight;
ScanSegment.ReflectionWeight = 5;
ScanSegment.OverlappedWeight = 500;
//# sourceMappingURL=ScanSegment.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentTree.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScanSegmentTree: () => (/* binding */ ScanSegmentTree)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _ScanSegment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js");




class ScanSegmentTree {
    constructor(scanDir) {
        // Temporary variables for lookup.
        this.lookupSegment = _ScanSegment__WEBPACK_IMPORTED_MODULE_3__.ScanSegment.mk(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0), new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1));
        this.ScanDirection = scanDir;
        this.segmentTree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_1__.RBTree((a, b) => this.Compare(a, b));
        this.findIntersectorPred = (a) => this.CompareIntersector(a);
        this.findPointPred = (a) => this.CompareToPoint(a);
    }
    get Segments() {
        return this.segmentTree.allNodes();
    }
    // If the seg is already in the tree it returns that instance, else it inserts the new
    // seg and returns that.
    InsertUnique(seg) {
        // RBTree's internal operations on insert/remove etc. mean the node can't cache the
        // RBNode returned by insert(); instead we must do find() on each call.  But we can
        // use the returned node to get predecessor/successor.
        this.AssertValidSegmentForInsertion(seg);
        const node = this.segmentTree.find(seg);
        if (node != null) {
            /*Assert.assert(
              seg.IsOverlapped === node.item.IsOverlapped,
              'Existing node found with different isOverlapped',
            )*/
            return node;
        }
        return this.segmentTree.insert(seg);
    }
    AssertValidSegmentForInsertion(seg) {
        /*Assert.assert(
          seg.End.x >= seg.Start.x && seg.End.y >= seg.Start.y,
          'Reversed direction in ScanSegment',
        )*/
        /*Assert.assert(
          this.ScanDirection.IsFlatPP(seg.Start, seg.End),
          'non-flat segment cannot be inserted',
        )*/
    }
    Remove(seg) {
        /*Assert.assert(
          seg.IsVertical === this.ScanDirection.IsVertical,
          'seg.IsVertical !== this.ScanDirection.IsVertical',
        )*/
        this.segmentTree.remove(seg);
    }
    Find(start, end) {
        /*Assert.assert(
          PointComparer.EqualPP(start, end) ||
            !this.ScanDirection.IsPerpendicularPP(start, end),
          'perpendicular segment passed',
        )*/
        this.lookupSegment.Update(start, end);
        const node = this.segmentTree.find(this.lookupSegment);
        if (null != node && _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.EqualPP(node.item.End, end)) {
            return node.item;
        }
        return null;
    }
    // Find the lowest perpendicular scanseg that intersects the segment endpoints.
    FindLowestIntersector(start, end) {
        const node = this.FindLowestIntersectorNode(start, end);
        return null != node ? node.item : null;
    }
    FindLowestIntersectorNode(start, end) {
        /*Assert.assert(
          this.ScanDirection.IsPerpendicularPP(start, end),
          'non-perpendicular segment passed',
        )*/
        // Find the last segment that starts at or before 'start'.
        this.lookupSegment.Update(start, start);
        let node = this.segmentTree.findLast(this.findIntersectorPred);
        // We have a segment that intersects start/end, or one that ends before 'start' and thus we
        // must iterate to find the lowest bisector.  TODOperf: see how much that iteration costs us
        // (here and Highest); consider a BSP tree or interval tree (maybe 2-d RBTree for updatability).
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.EqualPP(start, end)) {
            if (null != node && this.ScanDirection.Compare(node.item.End, start) < 0) {
                node = null;
            }
        }
        else {
            this.lookupSegment.Update(start, end);
            while (null != node && !node.item.IntersectsSegment(this.lookupSegment)) {
                // If the node segment starts after 'end', no intersection was found.
                if (this.ScanDirection.Compare(node.item.Start, end) > 0) {
                    return null;
                }
                node = this.segmentTree.next(node);
            }
        }
        return node;
    }
    // Find the highest perpendicular scanseg that intersects the segment endpoints.
    FindHighestIntersector(start, end) {
        /*Assert.assert(
          this.ScanDirection.IsPerpendicularPP(start, end),
          'non-perpendicular segment passed',
        )*/
        // Find the last segment that starts at or before 'end'.
        this.lookupSegment.Update(end, end);
        let node = this.segmentTree.findLast(this.findIntersectorPred);
        // Now we either have a segment that intersects start/end, or one that ends before
        // 'end' and need to iterate to find the highest bisector.
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.EqualPP(start, end)) {
            if (null != node && this.ScanDirection.Compare(node.item.End, start) < 0) {
                node = null;
            }
        }
        else {
            this.lookupSegment.Update(start, end);
            while (null != node && !node.item.IntersectsSegment(this.lookupSegment)) {
                // If the node segment ends before 'start', no intersection was found.
                if (this.ScanDirection.Compare(node.item.End, start) < 0) {
                    return null;
                }
                node = this.segmentTree.previous(node);
            }
        }
        return null != node ? node.item : null;
    }
    CompareIntersector(seg) {
        // We're looking for the last segment that starts before LookupSegment.Start.
        return this.ScanDirection.Compare(seg.Start, this.lookupSegment.Start) <= 0;
    }
    FindSegmentContainingPoint(location, allowUnfound) {
        return this.FindSegmentOverlappingPoints(location, location, allowUnfound);
    }
    FindSegmentOverlappingPoints(start, end, allowUnfound) {
        this.lookupSegment.Update(start, end);
        const node = this.segmentTree.findFirst(this.findPointPred);
        // If we had any segments in the tree that end after 'start', node has the first one.
        // Now we need to that it starts before 'end'.  ScanSegment.CompareToPointPositionFullLength
        // asserts the point is on the segment which we don't want to require here, so
        // compare the endpoints directly.
        if (node != null) {
            const seg = node.item;
            if (this.ScanDirection.Compare(seg.Start, end) <= 0) {
                return seg;
            }
        }
        // Not found.
        if (!allowUnfound) {
            /*Assert.assert(false, 'Could not find expected segment')*/
        }
        return null;
    }
    CompareToPoint(treeSeg) {
        // Test if treeSeg overlaps the LookupSegment.Start point.  We're using FindFirst,
        // so we'll just return false for everything that ends before the point and true for anything
        // that ends at or after it, then the caller will verify overlap.
        return this.ScanDirection.Compare(treeSeg.End, this.lookupSegment.Start) >= 0;
    }
    MergeAndRemoveNextNode(currentSegment, nextSegNode) {
        // Merge at the ends only - if we're here, start will be the same or greater.
        if (-1 === this.ScanDirection.Compare(currentSegment.End, nextSegNode.item.End)) {
            currentSegment.Update(currentSegment.Start, nextSegNode.item.End);
        }
        // Removing the node can revise the tree's RBNodes internally so re-get the current segment.
        currentSegment.MergeGroupBoundaryCrossingList(nextSegNode.item.GroupBoundaryPointAndCrossingsList);
        this.segmentTree.deleteNodeInternal(nextSegNode);
        return this.segmentTree.find(currentSegment);
    }
    MergeSegments() {
        if (this.segmentTree.count < 2) {
            return;
        }
        let currentSegNode = this.segmentTree.treeMinimum();
        let nextSegNode = this.segmentTree.next(currentSegNode);
        for (; null != nextSegNode; nextSegNode = this.segmentTree.next(currentSegNode)) {
            const cmp = this.ScanDirection.Compare(nextSegNode.item.Start, currentSegNode.item.End);
            switch (cmp) {
                case 1:
                    // Next segment starts after the current one.
                    currentSegNode = nextSegNode;
                    break;
                case 0:
                    if (nextSegNode.item.IsOverlapped === currentSegNode.item.IsOverlapped) {
                        // Overlapping is the same, so merge.  Because the ordering in the tree is that
                        // same-Start nodes are ordered by longest-End first, this will retain the tree ordering.
                        currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.item, nextSegNode);
                    }
                    else {
                        // Touching start/end with differing IsOverlapped so they need a connecting vertex.
                        currentSegNode.item.NeedEndOverlapVertex = true;
                        nextSegNode.item.NeedStartOverlapVertex = true;
                        currentSegNode = nextSegNode;
                    }
                    break;
                default:
                    /*Assert.assert(
                      nextSegNode.item.Start !== currentSegNode.item.Start ||
                        nextSegNode.item.End < currentSegNode.item.End,
                      'Identical segments are not allowed, and longer ones must come first',
                    )*/
                    // Because longer segments are ordered before shorter ones at the same start position,
                    // nextSegNode.Item must be a duplicate segment or is partially or totally overlapped.
                    // In the case of reflection lookahead segments, the side-intersection calculated from
                    // horizontal vs. vertical directions may be slightly different along the parallel
                    // coordinate from an overlapped segment, so let non-overlapped win that disagreement.
                    if (currentSegNode.item.IsOverlapped !== nextSegNode.item.IsOverlapped) {
                        /*Assert.assert(
                          Point.closeIntersections(
                            currentSegNode.item.End,
                            nextSegNode.item.Start,
                          ),
                          'Segments share a span with different IsOverlapped',
                        )*/
                        if (currentSegNode.item.IsOverlapped) {
                            // If the Starts are different, then currentSegNode is the only item at its
                            // start, so we don't need to re-insert.  Otherwise, we need to remove it and
                            // re-find nextSegNode's side.
                            if (currentSegNode.item.Start === nextSegNode.item.Start) {
                                // currentSegNode is a tiny overlapped segment between two non-overlapped segments (so
                                // we'll have another merge later, when we hit the other non-overlapped segment).
                                // Notice reversed params.  TestNote: No longer have repro with the change to convex hulls;
                                // this may no longer happen since overlapped edges will now always be inside rectangular
                                // obstacles so there are no angled-side calculations.
                                currentSegNode = this.MergeAndRemoveNextNode(nextSegNode.item, currentSegNode);
                            }
                            else {
                                currentSegNode.item.Update(currentSegNode.item.Start, nextSegNode.item.Start);
                                currentSegNode = nextSegNode;
                            }
                        }
                        else if (currentSegNode.item.End === nextSegNode.item.End) {
                            // nextSegNode is a tiny non-overlapped segment between two overlapped segments (so
                            // we'll have another merge later, when we hit the other non-overlapped segment).
                            // TestNote: No longer have repro with the change to convex hulls;
                            // this may no longer happen since overlapped edges will now always be inside rectangular
                            // obstacles so there are no angled-side calculations.
                            currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.item, nextSegNode);
                        }
                        else {
                            // Remove nextSegNode, increment its start to be after currentSegment, re-insert nextSegNode, and
                            // re-find currentSegNode (there may be more segments between nextSegment.Start and currentSegment.End).
                            const nextSegment = nextSegNode.item;
                            const currentSegment = currentSegNode.item;
                            this.segmentTree.deleteNodeInternal(nextSegNode);
                            nextSegment.Update(currentSegment.End, nextSegment.End);
                            this.segmentTree.insert(nextSegment);
                            nextSegment.TrimGroupBoundaryCrossingList();
                            currentSegNode = this.segmentTree.find(currentSegment);
                        }
                        break;
                    }
                    // Overlaps match so do a normal merge operation.
                    currentSegNode = this.MergeAndRemoveNextNode(currentSegNode.item, nextSegNode);
                    break;
            }
            // endswitch
        }
    }
    // For ordering the line segments inserted by the ScanLine. Assuming vertical sweep (sweeping up from
    // bottom, scanning horizontally) then order ScanSegments first by lowest Y coord, then by lowest X coord.
    Compare(first, second) {
        if (first === second) {
            return 0;
        }
        if (first == null) {
            return -1;
        }
        if (second == null) {
            return 1;
        }
        // This orders on both axes.
        let cmp = this.ScanDirection.Compare(first.Start, second.Start);
        if (0 === cmp) {
            // Longer segments come first, to make overlap removal easier.
            cmp = this.ScanDirection.Compare(first.End, second.End) * -1;
        }
        return cmp;
    }
}
//# sourceMappingURL=ScanSegmentTree.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentVector.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScanSegmentVector: () => (/* binding */ ScanSegmentVector)
/* harmony export */ });
/* harmony import */ var _ScanSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js");
/* harmony import */ var _ScanSegmentVectorItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentVectorItem.js");
// This forms the vector of ScanSegments for the sparse VisibilityGraph.


class ScanSegmentVector {
    constructor(coordMap, isHorizontal) {
        // The index of the scan segment vector we're appending to on the ScanSegment-generation sweep.
        this.CurrentSlotIndex = 0;
        this.vector = [];
        this.IsHorizontal = isHorizontal;
        const coords = Array.from(coordMap).sort((a, b) => (a > b ? 1 : a < b ? -1 : 0));
        for (const c of coords) {
            this.vector.push(new _ScanSegmentVectorItem__WEBPACK_IMPORTED_MODULE_1__.ScanSegmentVectorItem(c));
        }
    }
    get Length() {
        return this.vector.length;
    }
    // The item at the index of the scan segment vector we're appending to on the ScanSegment-generation sweep.
    get CurrentSlot() {
        return this.vector[this.CurrentSlotIndex];
    }
    // The indexed item in the vector.
    Item(slot) {
        return this.vector[slot];
    }
    // Appends a ScanSegment to the linked list in the "Current" slot.
    CreateScanSegment(start, end, weight, gbcList) {
        this.CurrentSlot.AppendScanSegment(new _ScanSegment__WEBPACK_IMPORTED_MODULE_0__.ScanSegment(start, end, weight, gbcList));
    }
    ScanSegmentsCompleteForCurrentSlot() {
        this.CurrentSlotIndex++;
    }
    ScanSegmentsComplete() {
        for (const item of this.vector) {
            item.AddPendingPerpendicularCoordsToScanSegments();
        }
    }
    // Returns an enumeration of the vector of ScanSegmentVectorItems.
    Items() {
        return this.vector;
    }
    // Reset vector state between passes.
    ResetForIntersections() {
        for (const t of this.vector) {
            t.ResetForIntersections();
        }
    }
    // Search the vector for the nearest slot in the specified direction.
    FindNearest(coord, directionIfMiss) {
        // Array.BinarySearch doesn't allow mapping from ScanSegmentVectorItem to its Coord.
        let low = 0;
        let high = this.vector.length - 1;
        if (coord <= this.vector[low].Coord) {
            return low;
        }
        if (coord >= this.vector[high].Coord) {
            return high;
        }
        while (high - low > 2) {
            const mid = low + ((high - low) >> 1);
            const item = this.vector[mid];
            if (coord < item.Coord) {
                high = mid;
                continue;
            }
            if (coord > item.Coord) {
                low = mid;
                continue;
            }
            // TODOsparse - profile - see if I really need the perpCoordMap
            /*Assert.assert(false, 'Should not be here if coord is in the vector')*/
            return mid;
        }
        // We know the value is between low and high, non-inclusive.
        for (low++; low <= high; low++) {
            const item = this.vector[low];
            if (coord < item.Coord) {
                return directionIfMiss > 0 ? low : low - 1;
            }
            if (coord === item.Coord) {
                break;
            }
        }
        // TODOsparse - profile - see if I really need the perpCoordMap
        /*Assert.assert(false, 'Should not be here if coord is in the vector')*/
        return low;
    }
    CreateSparseVerticesAndEdges(vg) {
        for (const item of this.vector) {
            item.ResetForIntersections();
            for (let segment = item.FirstSegment; segment != null; segment = segment.NextSegment) {
                segment.CreateSparseVerticesAndEdges(vg);
            }
        }
    }
    // Get the coordinate that remains constant along a segment in this vector.
    GetParallelCoord(site) {
        return this.IsHorizontal ? site.y : site.x;
    }
    // Get the coordinate that changes along a segment in this vector (and is thus the parallel
    // coord of an intersecting segment).
    GetPerpendicularCoord(site) {
        return this.IsHorizontal ? site.x : site.y;
    }
    ConnectAdjoiningSegmentEndpoints() {
        // Make sure that any series of segments (of different overlappedness) that have points in the
        // graph are connected at adjoining starts/ends and ends/starts (these adjoining points may not be
        // Steiner points in the graph if they are on indirect segments.
        for (const item of this.vector) {
            item.ResetForIntersections();
            let prevSegment = item.FirstSegment;
            for (let segment = prevSegment.NextSegment; segment != null; segment = segment.NextSegment) {
                if (segment.HasSparsePerpendicularCoords && prevSegment.HasSparsePerpendicularCoords) {
                    if (segment.Start === prevSegment.End) {
                        const perpCoord = this.GetPerpendicularCoord(segment.Start);
                        prevSegment.AddSparseEndpoint(perpCoord);
                        segment.AddSparseEndpoint(perpCoord);
                    }
                }
                prevSegment = segment;
            }
        }
    }
    toString() {
        return (this.IsHorizontal ? '(H) count' : '(V) count === ') + this.vector.length;
    }
}
//# sourceMappingURL=ScanSegmentVector.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentVectorItem.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScanSegmentVectorItem: () => (/* binding */ ScanSegmentVectorItem)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
// This forms one slot in the scan segment vector.


class ScanSegmentVectorItem {
    AddPendingPerpendicularCoord(coord) {
        if (this.pendingPerpCoords == null) {
            this.pendingPerpCoords = new Array();
        }
        this.pendingPerpCoords.push(coord);
    }
    // Restores state between intersection passes.
    ResetForIntersections() {
        /*Assert.assert(null !=  this.FirstSegment, 'Empty ScanSegmentVectorItem')*/
        this.CurrentSegment = this.FirstSegment;
    }
    // Indicates whether ScanSegments in this item are horizontally or vertically oriented.
    get IsHorizontal() {
        return !this.FirstSegment.IsVertical;
    }
    // Ctor, taking the parallel (constant) coordinate.
    // the parallel (constant) coordinate
    constructor(coord) {
        this.Coord = coord;
    }
    // Move along the linked list until we hit the ScanSegment that contains the point.
    TraverseToSegmentContainingPoint(point) {
        // This is not a simple Next() because scan segments are extended "through" obstacles
        // (intermixing overlapped and non-overlapped) and thus a ScanSegment's Start and End
        // may not be in the vertexPoints collection and the ScanSegment must be skipped.
        if (this.CurrentSegment.ContainsPoint(point)) {
            return true;
        }
        const pointCoord = this.IsHorizontal ? point.y : point.x;
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_1__.PointComparer.Equal(this.Coord, pointCoord)) {
            /*Assert.assert(
              PointComparer.Compare(this.Coord, pointCoord) === -1,
              'point is before current Coord',
            )*/
            while (this.MoveNext()) {
                // Skip to the end of the linked list if this point is not on the same coordinate.
            }
            return false;
        }
        for (;;) {
            // In the event of mismatched rounding on horizontal versus vertical intersections
            // with a sloped obstacle side, we may have a point that is just before or just
            // after the current segment.  If the point is in some space that doesn't have a
            // scansegment, and if we are "close enough" to one end or the other of a scansegment,
            // then grow the scansegment enough to include the new point.
            if (this.CurrentSegment.NextSegment == null ||
                _PointComparer__WEBPACK_IMPORTED_MODULE_1__.PointComparer.GetDirections(this.CurrentSegment.End, point) ==
                    _PointComparer__WEBPACK_IMPORTED_MODULE_1__.PointComparer.GetDirections(point, this.CurrentSegment.NextSegment.Start)) {
                if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.closeIntersections(this.CurrentSegment.End, point)) {
                    this.CurrentSegment.Update(this.CurrentSegment.Start, point);
                    return true;
                }
            }
            if (!this.MoveNext()) {
                return false;
            }
            if (this.CurrentSegment.ContainsPoint(point)) {
                return true;
            }
            // This is likely the reverse of the above; the point rounding mismatched to just before
            // rather than just after the current segment.
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_1__.PointComparer.IsPureLower(point, this.CurrentSegment.Start)) {
                /*Assert.assert(
                  Point.closeIntersections(this.CurrentSegment.Start, point),
                  'Skipped over the point in the ScanSegment linked list',
                )*/
                this.CurrentSegment.Update(point, this.CurrentSegment.End);
                return true;
            }
        }
    }
    MoveNext() {
        this.CurrentSegment = this.CurrentSegment.NextSegment;
        return this.HasCurrent;
    }
    get HasCurrent() {
        return null != this.CurrentSegment;
    }
    // Returns true if the point is the end of the current segment and there is an adjoining NextSegment.
    PointIsCurrentEndAndNextStart(point) {
        return (point.equal(this.CurrentSegment.End) && null != this.CurrentSegment.NextSegment && point.equal(this.CurrentSegment.NextSegment.Start));
    }
    // Set Current to the ScanSegment containing the perpendicular coordinate, then add that coordinate to its
    // sparse-vector coordinate list.
    AddPerpendicularCoord(perpCoord) {
        const point = this.IsHorizontal ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(perpCoord, this.Coord) : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.Coord, perpCoord);
        this.TraverseToSegmentContainingPoint(point);
        this.CurrentSegment.AddSparseVertexCoord(perpCoord);
    }
    toString() {
        if (this.FirstSegment == null) {
            return '-0- ' + this.Coord;
        }
        return this.IsHorizontal ? '(H) Y === ' + this.Coord : '(V) X === ';
    }
    AppendScanSegment(segment) {
        if (this.FirstSegment == null) {
            this.FirstSegment = segment;
        }
        else {
            // Note: segment.Start may !== Current.End due to skipping internal ScanSegment creation for non-overlapped obstacles.
            this.CurrentSegment.NextSegment = segment;
        }
        this.CurrentSegment = segment;
    }
    AddPendingPerpendicularCoordsToScanSegments() {
        if (this.pendingPerpCoords != null) {
            this.ResetForIntersections();
            for (const point of this.pendingPerpCoords) {
                this.AddPerpendicularCoord(point);
            }
        }
    }
}
//# sourceMappingURL=ScanSegmentVectorItem.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/SparseVisibiltyGraphGenerator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SparseVisibilityGraphGenerator: () => (/* binding */ SparseVisibilityGraphGenerator)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
/* harmony import */ var _AxisCoordinateEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/AxisCoordinateEvent.js");
/* harmony import */ var _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/BasicObstacleSide.js");
/* harmony import */ var _OpenVertexEvent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/OpenVertexEvent.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _ScanDirection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanDirection.js");
/* harmony import */ var _ScanSegment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js");
/* harmony import */ var _ScanSegmentVector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentVector.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");
/* harmony import */ var _VisibilityGraphGenerator__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/VisibilityGraphGenerator.js");
// Scan direction is parallel to the sweepline which moves in the perpendicular direction;
// i.e. scan direction is "sideways" along the sweepline.  We do several passes, following Clarkson et al.,
// "Rectilinear shortest paths through polygonal obstacles in O(n (log n)2) time" (checked into the enlistment).
//   1.  Enumerate all obstacles and load their extreme vertex coordinate projections to the perpendicular axis.
//   2.  Run a scanline (in each direction) that:
//      a.  Accumulates the vertices and generates obstacle-related Steiner points.
//      b.  Generates the ScanSegments.
//   3.  Iterate in parallel along the ScanSegments and *VertexPoints to determine the sparse intersections
//       by binary division, as in the paper.
//   4.  Finally we create the VisibilityVertices and VisibilityEdges along each ScanSegment from its
//       list of intersections.
// Differences from the paper largely are due to the paper's creation of non-orthogonal edges along
// obstacle sides; instead, we create orthogonal edges to the lateral sides of the obstacle's bounding
// box. Also, we support overlapped obstacles (interior edges are weighted, as in the non-sparse












// implementation) and groups.
class SparseVisibilityGraphGenerator extends _VisibilityGraphGenerator__WEBPACK_IMPORTED_MODULE_11__.VisibilityGraphGenerator {
    constructor() {
        super(/* wantReflections:*/ false);
        // The points of obstacle vertices encountered on horizontal scan.
        this.horizontalVertexPoints = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_2__.PointSet();
        // The points of obstacle vertices encountered on vertical scan.
        this.verticalVertexPoints = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_2__.PointSet();
        // The Steiner points generated at the bounding box of obstacles.
        // These help ensure that we can "go around" the obstacle, as with the non-orthogonal edges in the paper.
        this.boundingBoxSteinerPoints = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_2__.PointSet();
        // Accumulates distinct vertex projections to the X axis during sweep.
        this.xCoordAccumulator = new Set();
        // Accumulates distinct vertex projections to the Y axis during sweep.
        this.yCoordAccumulator = new Set();
        // The index from a coordinate to a horizontal vector slot.
        this.horizontalCoordMap = new Map();
        // The index from a point to a vertical vector slot.
        this.verticalCoordMap = new Map();
    }
    Clear() {
        super.Clear();
        this.Cleanup();
    }
    Cleanup() {
        this.horizontalVertexPoints.clear();
        this.verticalVertexPoints.clear();
        this.boundingBoxSteinerPoints.clear();
        this.xCoordAccumulator.clear();
        this.yCoordAccumulator.clear();
        this.horizontalCoordMap.clear();
        this.verticalCoordMap.clear();
    }
    // Generate the visibility graph along which edges will be routed.
    GenerateVisibilityGraph() {
        this.AccumulateVertexCoords();
        this.CreateSegmentVectorsAndPopulateCoordinateMaps();
        this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints();
        this.GenerateSparseIntersectionsFromVertexPoints();
        this.CreateScanSegmentTrees();
        this.Cleanup();
    }
    AccumulateVertexCoords() {
        // Unlike the paper we only generate lines for extreme vertices (i.e. on the horizontal pass we
        // don't generate a horizontal vertex projection to the Y axis for a vertex that is not on the top
        // or bottom of the obstacle).  So we can just use the bounding box.
        for (const obstacle of this.ObstacleTree.GetAllObstacles()) {
            this.xCoordAccumulator.add(obstacle.VisibilityBoundingBox.left);
            this.xCoordAccumulator.add(obstacle.VisibilityBoundingBox.right);
            this.yCoordAccumulator.add(obstacle.VisibilityBoundingBox.top);
            this.yCoordAccumulator.add(obstacle.VisibilityBoundingBox.bottom);
        }
    }
    CreateSegmentVectorsAndPopulateCoordinateMaps() {
        this.horizontalScanSegmentVector = new _ScanSegmentVector__WEBPACK_IMPORTED_MODULE_9__.ScanSegmentVector(this.yCoordAccumulator, true);
        this.verticalScanSegmentVector = new _ScanSegmentVector__WEBPACK_IMPORTED_MODULE_9__.ScanSegmentVector(this.xCoordAccumulator, false);
        for (let slot = 0; slot < this.horizontalScanSegmentVector.Length; slot++) {
            this.horizontalCoordMap.set(this.horizontalScanSegmentVector.Item(slot).Coord, slot);
        }
        for (let slot = 0; slot < this.verticalScanSegmentVector.Length; slot++) {
            this.verticalCoordMap.set(this.verticalScanSegmentVector.Item(slot).Coord, slot);
        }
    }
    RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints() {
        // Do a scanline pass to create scan segments that span the entire height/width of the graph
        // (mixing overlapped with free segments as needed) and generate the type-2 Steiner points.
        super.GenerateVisibilityGraph();
        this.horizontalScanSegmentVector.ScanSegmentsComplete();
        this.verticalScanSegmentVector.ScanSegmentsComplete();
        this.xCoordAccumulator.clear();
        this.yCoordAccumulator.clear();
    }
    InitializeEventQueue(scanDir) {
        super.InitializeEventQueue(scanDir);
        this.SetVectorsAndCoordMaps(scanDir);
        this.AddAxisCoordinateEvents(scanDir);
    }
    AddAxisCoordinateEvents(scanDir) {
        // Normal event ordering will apply - and will thus order the ScanSegments created in the vectors.
        if (scanDir.IsHorizontal) {
            for (const coord of this.yCoordAccumulator) {
                this.eventQueue.Enqueue(new _AxisCoordinateEvent__WEBPACK_IMPORTED_MODULE_3__.AxisCoordinateEvent(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.left - SparseVisibilityGraphGenerator.SentinelOffset, coord)));
            }
            return;
        }
        for (const coord of this.xCoordAccumulator) {
            this.eventQueue.Enqueue(new _AxisCoordinateEvent__WEBPACK_IMPORTED_MODULE_3__.AxisCoordinateEvent(new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(coord, this.ObstacleTree.GraphBox.bottom - SparseVisibilityGraphGenerator.SentinelOffset)));
        }
    }
    ProcessCustomEvent(evt) {
        if (!this.ProcessAxisCoordinate(evt)) {
            this.ProcessCustomEvent(evt);
        }
    }
    ProcessAxisCoordinate(evt) {
        if (evt instanceof _AxisCoordinateEvent__WEBPACK_IMPORTED_MODULE_3__.AxisCoordinateEvent) {
            this.CreateScanSegmentsOnAxisCoordinate(evt.Site);
            return true;
        }
        return false;
    }
    InsertPerpendicularReflectionSegment(start, end) {
        /*Assert.assert(
          false,
          'base.wantReflections is false in Sparse mode so this should never be called',
        )*/
        // ReSharper disable HeuristicUnreachableCode
        return false;
        // ReSharper restore HeuristicUnreachableCode
    }
    InsertParallelReflectionSegment(start, end, eventObstacle, lowNborSide, highNborSide, action) {
        /*Assert.assert(
          false,
          'base.wantReflections is false in Sparse mode so this should never be called',
        )*/
        // ReSharper disable HeuristicUnreachableCode
        return false;
        // ReSharper restore HeuristicUnreachableCode
    }
    ProcessVertexEvent(lowSideNode, highSideNode, vertexEvent) {
        const vertexPoints = this.ScanDirection.IsHorizontal ? this.horizontalVertexPoints : this.verticalVertexPoints;
        vertexPoints.add(vertexEvent.Site);
        // For easier reading...
        const lowNborSide = this.LowNeighborSides.LowNeighbor.item;
        const highNborSide = this.HighNeighborSides.HighNeighbor.item;
        const highDir = this.ScanDirection.Dir;
        const lowDir = this.ScanDirection.OppositeDirection;
        // Generate the neighbor side intersections, regardless of overlaps; these are the type-2 Steiner points.
        const lowSteiner = this.ScanLineIntersectSide(vertexEvent.Site, lowNborSide);
        const highSteiner = this.ScanLineIntersectSide(vertexEvent.Site, highNborSide);
        // Add the intersections at the neighbor bounding boxes if the intersection is not at a sentinel.
        // Go in the opposite direction from the neighbor intersection to find the border between the Steiner
        // point and vertexEvent.Site (unless vertexEvent.Site is inside the bounding box).
        if (this.ObstacleTree.GraphBox.contains(lowSteiner)) {
            const bboxIntersectBeforeLowSteiner = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.RectangleBorderIntersect(lowNborSide.Obstacle.VisibilityBoundingBox, lowSteiner, highDir);
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.IsPureLower(bboxIntersectBeforeLowSteiner, vertexEvent.Site)) {
                this.boundingBoxSteinerPoints.add(bboxIntersectBeforeLowSteiner);
            }
        }
        if (this.ObstacleTree.GraphBox.contains(highSteiner)) {
            const bboxIntersectBeforeHighSteiner = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.RectangleBorderIntersect(highNborSide.Obstacle.VisibilityBoundingBox, highSteiner, lowDir);
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.IsPureLower(vertexEvent.Site, bboxIntersectBeforeHighSteiner)) {
                this.boundingBoxSteinerPoints.add(bboxIntersectBeforeHighSteiner);
            }
        }
        // Add the corners of the bounding box of the vertex obstacle, if they are visible to the event site.
        // This ensures that we "go around" the obstacle, as with the non-orthogonal edges in the paper.
        const t = { lowCorner: undefined, highCorner: undefined };
        SparseVisibilityGraphGenerator.GetBoundingCorners(lowSideNode.item.Obstacle.VisibilityBoundingBox, vertexEvent instanceof _OpenVertexEvent__WEBPACK_IMPORTED_MODULE_5__.OpenVertexEvent, this.ScanDirection.IsHorizontal, t);
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.IsPureLower(lowSteiner, t.lowCorner) || lowNborSide.Obstacle.IsInSameClump(vertexEvent.Obstacle)) {
            vertexPoints.add(t.lowCorner);
        }
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_6__.PointComparer.IsPureLower(t.highCorner, highSteiner) || highNborSide.Obstacle.IsInSameClump(vertexEvent.Obstacle)) {
            vertexPoints.add(t.highCorner);
        }
    }
    static GetBoundingCorners(boundingBox, isLowSide, isHorizontal, t) {
        if (isLowSide) {
            t.lowCorner = boundingBox.leftBottom;
            t.highCorner = isHorizontal ? boundingBox.rightBottom : boundingBox.leftTop;
            return;
        }
        t.lowCorner = isHorizontal ? boundingBox.leftTop : boundingBox.rightBottom;
        t.highCorner = boundingBox.rightTop;
    }
    CreateScanSegmentsOnAxisCoordinate(site) {
        this.CurrentGroupBoundaryCrossingMap.Clear();
        // Iterate the ScanLine and create ScanSegments.  There will always be at least the two sentinel sides.
        const sideNode = this.scanLine.Lowest();
        let nextNode = this.scanLine.NextHighR(sideNode);
        let overlapDepth = 0;
        let start = site;
        let isInsideOverlappedObstacle = false;
        for (; null != nextNode; nextNode = this.scanLine.NextHighR(nextNode)) {
            if (this.SkipSide(start, nextNode.item)) {
                continue;
            }
            if (nextNode.item.Obstacle.IsGroup) {
                // Do not create internal group crossings in non-overlapped obstacles.
                if (overlapDepth === 0 || isInsideOverlappedObstacle) {
                    this.HandleGroupCrossing(site, nextNode.item);
                }
                continue;
            }
            const isLowSide = nextNode.item instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_4__.LowObstacleSide;
            if (isLowSide) {
                if (overlapDepth > 0) {
                    overlapDepth++;
                    continue;
                }
                // We are not overlapped, so create a ScanSegment from the previous side intersection to the
                // intersection with the side in nextNode.Item.
                start = this.CreateScanSegment(start, nextNode.item, _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.NormalWeight);
                this.CurrentGroupBoundaryCrossingMap.Clear();
                overlapDepth = 1;
                isInsideOverlappedObstacle = nextNode.item.Obstacle.isOverlapped;
                continue;
            }
            // This is a HighObstacleSide.  If we've got overlap nesting, decrement the depth.
            /*Assert.assert(overlapDepth > 0, 'Overlap depth must be positive')*/
            overlapDepth++;
            if (overlapDepth > 0) {
                continue;
            }
            // If we are not within an overlapped obstacle, don't bother creating the overlapped ScanSegment
            // as there will never be visibility connecting to it.
            start =
                nextNode.item.Obstacle.isOverlapped || nextNode.item.Obstacle.OverlapsGroupCorner
                    ? this.CreateScanSegment(start, nextNode.item, _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.OverlappedWeight)
                    : this.ScanLineIntersectSide(start, nextNode.item);
            this.CurrentGroupBoundaryCrossingMap.Clear();
            isInsideOverlappedObstacle = false;
        }
        // The final piece.
        const end = this.ScanDirection.IsHorizontal
            ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.right + SparseVisibilityGraphGenerator.SentinelOffset, start.y)
            : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(start.x, this.ObstacleTree.GraphBox.top + SparseVisibilityGraphGenerator.SentinelOffset);
        this.parallelSegmentVector.CreateScanSegment(start, end, _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.NormalWeight, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start, end));
        this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot();
    }
    HandleGroupCrossing(site, groupSide) {
        if (!this.ScanLineCrossesObstacle(site, groupSide.Obstacle)) {
            return;
        }
        // Here we are always going left-to-right.  As in base.SkipToNeighbor, we don't stop traversal for groups,
        // neither do we create overlapped edges (unless we're inside a non-group obstacle).  Instead we turn
        // the boundary crossing on or off based on group membership at ShortestPath-time.  Even though this is
        // the sparse VG, we always create these edges at group boundaries so we don't skip over them.
        const dirToInsideOfGroup = groupSide instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_4__.LowObstacleSide ? this.ScanDirection.Dir : this.ScanDirection.OppositeDirection;
        const intersect = this.ScanLineIntersectSide(site, groupSide);
        const crossing = this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, groupSide.Obstacle, dirToInsideOfGroup);
        // The vertex crossing the edge is perpendicular to the group boundary.  A rectilinear group will also have
        // an edge parallel to that group boundary that includes the point of that crossing vertex; therefore we must
        // split that non-crossing edge at that vertex.
        this.AddPerpendicularCoordForGroupCrossing(intersect);
        // Similarly, the crossing edge's opposite vertex may be on a perpendicular segment.
        const interiorPoint = crossing.GetInteriorVertexPoint(intersect);
        this.AddPerpendicularCoordForGroupCrossing(interiorPoint);
    }
    AddPerpendicularCoordForGroupCrossing(intersect) {
        const nonCrossingPerpSlot = this.FindPerpendicularSlot(intersect, 0);
        if (-1 !== nonCrossingPerpSlot) {
            this.perpendicularSegmentVector.Item(nonCrossingPerpSlot).AddPendingPerpendicularCoord(this.parallelSegmentVector.CurrentSlot.Coord);
        }
    }
    SkipSide(start, side) {
        if (side.Obstacle.IsSentinel) {
            return true;
        }
        // Skip sides of obstacles that we do not actually pass through.
        const bbox = side.Obstacle.VisibilityBoundingBox;
        if (this.ScanDirection.IsHorizontal) {
            return start.y === bbox.bottom || start.y === bbox.top;
        }
        return start.x === bbox.left || start.x === bbox.right;
    }
    CreateScanSegment(start, side, weight) {
        const end = this.ScanLineIntersectSide(start, side);
        if (start !== end) {
            this.parallelSegmentVector.CreateScanSegment(start, end, weight, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start, end));
        }
        return end;
    }
    GenerateSparseIntersectionsFromVertexPoints() {
        this.VisibilityGraph = SparseVisibilityGraphGenerator.NewVisibilityGraph();
        // Generate the sparse intersections between ScanSegments based upon the ordered vertexPoints.
        this.GenerateSparseIntersectionsAlongHorizontalAxis();
        this.GenerateSparseIntersectionsAlongVerticalAxis();
        this.ConnectAdjoiningScanSegments();
        // Now each segment has the coordinates all of its intersections, so create the visibility graph.
        this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph);
        this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph);
    }
    GenerateSparseIntersectionsAlongHorizontalAxis() {
        this.currentAxisPointComparer = _utils_compare__WEBPACK_IMPORTED_MODULE_1__.comparePointsYFirst;
        const vertexPoints = Array.from(this.horizontalVertexPoints.values()).sort(this.currentAxisPointComparer);
        const bboxSteinerPoints = Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);
        this.ScanDirection = _ScanDirection__WEBPACK_IMPORTED_MODULE_7__.ScanDirection.HorizontalInstance;
        this.SetVectorsAndCoordMaps(this.ScanDirection);
        this.GenerateSparseIntersections(vertexPoints, bboxSteinerPoints);
    }
    GenerateSparseIntersectionsAlongVerticalAxis() {
        this.currentAxisPointComparer = (a, b) => a.compareTo(b);
        const vertexPoints = Array.from(this.verticalVertexPoints.values()).sort(this.currentAxisPointComparer);
        const bboxSteinerPoints = Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);
        this.ScanDirection = _ScanDirection__WEBPACK_IMPORTED_MODULE_7__.ScanDirection.VerticalInstance;
        this.SetVectorsAndCoordMaps(this.ScanDirection);
        this.GenerateSparseIntersections(vertexPoints, bboxSteinerPoints);
    }
    SetVectorsAndCoordMaps(scanDir) {
        if (scanDir.IsHorizontal) {
            this.parallelSegmentVector = this.horizontalScanSegmentVector;
            this.perpendicularSegmentVector = this.verticalScanSegmentVector;
            this.perpendicularCoordMap = this.verticalCoordMap;
        }
        else {
            this.parallelSegmentVector = this.verticalScanSegmentVector;
            this.perpendicularSegmentVector = this.horizontalScanSegmentVector;
            this.perpendicularCoordMap = this.horizontalCoordMap;
        }
    }
    ConnectAdjoiningScanSegments() {
        // Ensure there is a vertex at the end/start point of two ScanSegments; these will always differ in overlappedness.
        this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints();
        this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints();
    }
    GenerateSparseIntersections(vertexPoints, bboxSteinerPoints) {
        this.perpendicularSegmentVector.ResetForIntersections();
        this.parallelSegmentVector.ResetForIntersections();
        // Position the enumerations to the first point.
        let i = 1;
        const steinerPointsCounter = { j: 0 };
        for (const item of this.parallelSegmentVector.Items()) {
            for (;;) {
                if (!item.CurrentSegment.ContainsPoint(vertexPoints[i])) {
                    // Done accumulating intersections for the current segment; move to the next segment.
                    if (!this.AddSteinerPointsToInterveningSegments(vertexPoints[i], bboxSteinerPoints, steinerPointsCounter, item) ||
                        !item.TraverseToSegmentContainingPoint(vertexPoints[i])) {
                        // Done with this vectorItem, move to the next item.
                        break;
                    }
                }
                this.AddPointsToCurrentSegmentIntersections(bboxSteinerPoints, steinerPointsCounter, item);
                this.GenerateIntersectionsFromVertexPointForCurrentSegment(vertexPoints[i], item);
                if (item.PointIsCurrentEndAndNextStart(vertexPoints[i])) {
                    // MoveNext will always return true because the test to enter this block returned true.
                    item.MoveNext();
                    /*Assert.assert(
                      item.HasCurrent,
                      'MoveNext ended before EndAndNextStart',
                    )*/
                    continue;
                }
                if (++i >= vertexPoints.length) {
                    // No more vertexPoints; we're done.
                    return;
                }
            }
        }
        // We should have exited in the "no more vertexPoints" case above.
        /*Assert.assert(false, 'Mismatch in points and segments')*/
    }
    AddSteinerPointsToInterveningSegments(currentVertexPoint, bboxSteinerPoints, t, item) {
        // With overlaps, we may have bboxSteinerPoints on segments that do not contain vertices.
        while (t.j < bboxSteinerPoints.length && this.currentAxisPointComparer(bboxSteinerPoints[t.j], currentVertexPoint) === -1) {
            if (!item.TraverseToSegmentContainingPoint(bboxSteinerPoints[t.j])) {
                // Done with this vectorItem, move to the next item.
                return false;
            }
            this.AddPointsToCurrentSegmentIntersections(bboxSteinerPoints, t, item);
        }
        return true;
    }
    AddPointsToCurrentSegmentIntersections(pointsToAdd, t, parallelItem) {
        // The first Steiner point should be in the segment, unless we have a non-orthogonal or overlapped or both situation
        // that results in no Steiner points having been generated, or Steiner points being generated on a segment that has
        // the opposite overlap state from the segment containing the corresponding vertex.
        for (; t.j < pointsToAdd.length && parallelItem.CurrentSegment.ContainsPoint(pointsToAdd[t.j]); t.j++) {
            const steinerSlot = this.FindPerpendicularSlot(pointsToAdd[t.j], 0);
            this.AddSlotToSegmentIntersections(parallelItem, steinerSlot);
        }
    }
    GenerateIntersectionsFromVertexPointForCurrentSegment(site, parallelItem) {
        const perpStartSlot = this.FindPerpendicularSlot(parallelItem.CurrentSegment.Start, 1);
        const perpEndSlot = this.FindPerpendicularSlot(parallelItem.CurrentSegment.End, -1);
        const siteSlot = this.FindPerpendicularSlot(site, 0);
        // See comments in FindIntersectingSlot; we don't add non-extreme vertices in the perpendicular direction
        // so in some heavily-overlapped scenarios, we may not have any intersections within this scan segment.
        if (perpStartSlot >= perpEndSlot) {
            return;
        }
        this.AddSlotToSegmentIntersections(parallelItem, perpStartSlot);
        this.AddSlotToSegmentIntersections(parallelItem, perpEndSlot);
        if (siteSlot > perpStartSlot && siteSlot < perpEndSlot) {
            this.AddSlotToSegmentIntersections(parallelItem, siteSlot);
            this.AddBinaryDivisionSlotsToSegmentIntersections(parallelItem, perpStartSlot, siteSlot, perpEndSlot);
        }
    }
    // These are called when the site may not be in the vector.
    FindPerpendicularSlot(site, directionIfMiss) {
        return SparseVisibilityGraphGenerator.FindIntersectingSlot(this.perpendicularSegmentVector, this.perpendicularCoordMap, site, directionIfMiss);
    }
    static FindIntersectingSlot(segmentVector, coordMap, site, directionIfMiss) {
        const coord = segmentVector.GetParallelCoord(site);
        const slot = coordMap.get(coord);
        if (slot !== undefined) {
            return slot;
        }
        // There are a few cases where the perpCoord is not in the map:
        // 1.  The first ScanSegment in a slot will have a Start at the sentinel, which is before the first
        //     perpendicular segment; similarly, the last ScanSegment in a slot will have an out-of-range End.
        // 2.  Sequences of overlapped/nonoverlapped scan segments that pass through obstacles.  Their start
        //     and end points are not in vertexPoints because they were not vertex-derived, so we find the
        //     closest bracketing coordinates that are in the vectors.
        // 3.  Non-extreme vertices in the perpendicular direction (e.g. for a triangle, we add the X's of
        //     the left and right to the coords, but not of the top).
        // 4.  Non-rectilinear group side intersections.
        return directionIfMiss === 0 ? -1 : segmentVector.FindNearest(coord, directionIfMiss);
    }
    AddSlotToSegmentIntersections(parallelItem, perpSlot) {
        const perpItem = this.perpendicularSegmentVector.Item(perpSlot);
        parallelItem.CurrentSegment.AddSparseVertexCoord(perpItem.Coord);
        perpItem.AddPerpendicularCoord(parallelItem.Coord);
    }
    AddBinaryDivisionSlotsToSegmentIntersections(parallelItem, startSlot, siteSlot, endSlot) {
        // The input parameters' slots have already been added to the segment's coords.
        // If there was no object to the low or high side, then the start or end slot was already
        // the graphbox max (0 or perpSegmentVector.Length, respectively).  So start dividing.
        let low = 0;
        let high = this.perpendicularSegmentVector.Length - 1;
        // Terminate when we are one away because we don't have an edge from a point to itself.
        while (high - low > 1) {
            const mid = low + Math.floor((high - low) / 2);
            // We only use the half of the graph that the site is in, so arbitrarily decide that it is
            // in the lower half if it is at the midpoint.
            if (siteSlot <= mid) {
                high = mid;
                if (siteSlot < high && high <= endSlot) {
                    this.AddSlotToSegmentIntersections(parallelItem, high);
                }
                continue;
            }
            low = mid;
            if (siteSlot > low && low >= startSlot) {
                this.AddSlotToSegmentIntersections(parallelItem, low);
            }
        }
    }
    // Create the ScanSegmentTrees that functions as indexes for port-visibility splicing.
    CreateScanSegmentTrees() {
        SparseVisibilityGraphGenerator.CreateScanSegmentTree(this.horizontalScanSegmentVector, this.HorizontalScanSegments);
        SparseVisibilityGraphGenerator.CreateScanSegmentTree(this.verticalScanSegmentVector, this.VerticalScanSegments);
    }
    static CreateScanSegmentTree(segmentVector, segmentTree) {
        for (const item of segmentVector.Items()) {
            for (let segment = item.FirstSegment; segment != null; segment = segment.NextSegment) {
                if (segment.HasVisibility()) {
                    segmentTree.InsertUnique(segment);
                }
            }
        }
    }
}
//# sourceMappingURL=SparseVisibiltyGraphGenerator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/SpliceUtility.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpliceUtility: () => (/* binding */ SpliceUtility)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");

class SpliceUtility {
    // Most of the original contents of this file have been subsumed into ObstacleTree and TransientGraphUtility.
    static MungeClosestIntersectionInfo(rayOrigin, closestIntersection, isHorizontal) {
        const bbox = closestIntersection.seg1.boundingBox;
        const closest = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(closestIntersection.x).clone();
        return isHorizontal
            ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(SpliceUtility.MungeIntersect(rayOrigin.x, closest.x, bbox.left, bbox.right), closest.y)
            : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(closest.x, SpliceUtility.MungeIntersect(rayOrigin.y, closest.y, bbox.bottom, bbox.top));
    }
    // Make sure that we intersect the object space.
    static MungeIntersect(site, intersect, start, end) {
        if (site < intersect) {
            const min = Math.min(start, end);
            if (intersect < min) {
                intersect = min;
            }
        }
        else if (site > intersect) {
            const max = Math.max(start, end);
            if (intersect > max) {
                intersect = max;
            }
        }
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.RoundDouble(intersect);
    }
}
//# sourceMappingURL=SpliceUtility.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/SsstRectilinearPath.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SsstRectilinearPath: () => (/* binding */ SsstRectilinearPath)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _VertexEntry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/VertexEntry.js");
// single source single target rectilinear path





class NextNeighbor {
    constructor() {
        this.Clear();
    }
    Set(v, w) {
        this.Vertex = v;
        this.Weight = w;
    }
    Clear() {
        this.Vertex = null;
        this.Weight = Number.NaN;
    }
}
class SsstRectilinearPath {
    // The cost of the path calculation
    CombinedCost(length, numberOfBends) {
        return this.LengthImportance * length + this.BendsImportance * numberOfBends;
    }
    TotalCostFromSourceToVertex(length, numberOfBends) {
        return this.CombinedCost(length, numberOfBends) + this.sourceCostAdjustment;
    }
    constructor() {
        // For consistency and speed, path extensions impose an ordering as in the paper:  straight, right, left.  We
        // enqueue entries in the reverse order of preference so the latest timestamp will be the preferred direction.
        // Thus straight-ahead neighbors are in slot 2, right in slot 1, left in slot 0.  (If the target happens
        // to be to the Left, then the heuristic lookahead score will override the Right preference).
        // The next neighbors to extend the path to from the current vertex.
        this.nextNeighbors = [new NextNeighbor(), new NextNeighbor(), new NextNeighbor()];
        this.LengthImportance = 1;
        this.BendsImportance = 1;
    }
    InitPath(sourceVertexEntries, source, target) {
        if (source === target || !this.InitEntryDirectionsAtTarget(target)) {
            return false;
        }
        this.Target = target;
        this.Source = source;
        const cost = this.TotalCostFromSourceToVertex(0, 0) + this.HeuristicDistanceFromVertexToTarget(source.point, _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None);
        if (cost >= this.upperBoundOnCost) {
            return false;
        }
        // This path starts lower than upperBoundOnCost, so create our structures and process it.
        this.queue = new _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_2__.GenericBinaryHeapPriorityQueue(_utils_compare__WEBPACK_IMPORTED_MODULE_3__.compareNumbers);
        this.visitedVertices = [source];
        if (sourceVertexEntries == null) {
            this.EnqueueInitialVerticesFromSource(cost);
        }
        else {
            this.EnqueueInitialVerticesFromSourceEntries(sourceVertexEntries);
        }
        return this.queue.count > 0;
    }
    InitEntryDirectionsAtTarget(vert) {
        this.EntryDirectionsToTarget = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
        // This routine is only called once so don't worry about optimizing foreach.
        for (const edge of vert.OutEdges) {
            this.EntryDirectionsToTarget = this.EntryDirectionsToTarget | _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(edge.TargetPoint, vert.point);
        }
        for (const edge of vert.InEdges) {
            this.EntryDirectionsToTarget = this.EntryDirectionsToTarget | _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(edge.SourcePoint, vert.point);
        }
        // If this returns false then the target is isolated.
        return this.EntryDirectionsToTarget !== _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
    }
    static IsInDirs(direction, dirs) {
        return direction === (direction & dirs);
    }
    MultistageAdjustedCostBound(bestCost) {
        // Allow an additional bend's cost for intermediate stages so we don't jump out early.
        return Number.isFinite(bestCost) ? bestCost + this.BendsImportance : bestCost;
    }
    // estimation from below for the distance
    HeuristicDistanceFromVertexToTarget(point, entryDirToVertex) {
        const vectorToTarget = this.Target.point.sub(point);
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(vectorToTarget.x, 0) && (0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(vectorToTarget.y, 0)) {
            // We are at the target.
            return this.targetCostAdjustment;
        }
        const dirToTarget = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.VectorDirection(vectorToTarget);
        let numberOfBends;
        if (entryDirToVertex === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None) {
            entryDirToVertex = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East | (_math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North | (_math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South));
            numberOfBends = this.GetNumberOfBends(entryDirToVertex, dirToTarget);
        }
        else {
            numberOfBends = this.GetNumberOfBends(entryDirToVertex, dirToTarget);
        }
        return this.CombinedCost(SsstRectilinearPath.ManhattanDistance(point, this.Target.point), numberOfBends) + this.targetCostAdjustment;
    }
    GetNumberOfBends(entryDirToVertex, dirToTarget) {
        return _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.IsPureDirection(dirToTarget)
            ? this.GetNumberOfBendsForPureDirection(entryDirToVertex, dirToTarget)
            : SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, this.EntryDirectionsToTarget);
    }
    GetNumberOfBendsForPureDirection(entryDirToVertex, dirToTarget) {
        if ((dirToTarget & entryDirToVertex) === dirToTarget) {
            if (SsstRectilinearPath.IsInDirs(dirToTarget, this.EntryDirectionsToTarget)) {
                return 0;
            }
            if (SsstRectilinearPath.IsInDirs(SsstRectilinearPath.Left(dirToTarget), this.EntryDirectionsToTarget) ||
                SsstRectilinearPath.IsInDirs(SsstRectilinearPath.Right(dirToTarget), this.EntryDirectionsToTarget)) {
                return 2;
            }
            return 4;
        }
        return this.GetNumberOfBendsForPureDirection(SsstRectilinearPath.AddOneTurn[entryDirToVertex], dirToTarget) + 1;
    }
    static GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, entryDirectionsToTarget) {
        const a = dirToTarget & entryDirToVertex;
        if (a === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None) {
            return (SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, SsstRectilinearPath.AddOneTurn[entryDirToVertex], entryDirectionsToTarget) + 1);
        }
        const b = dirToTarget & entryDirectionsToTarget;
        if (b === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None) {
            return (SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, SsstRectilinearPath.AddOneTurn[entryDirectionsToTarget]) + 1);
        }
        return (a | b) === dirToTarget ? 1 : 2;
    }
    static Left(direction) {
        switch (direction) {
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South;
                break;
            default:
                throw new Error('direction');
                break;
        }
    }
    static Right(direction) {
        switch (direction) {
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West:
                return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
                break;
            default:
                throw new Error('direction');
                break;
        }
    }
    static RestorePathV(t) {
        return SsstRectilinearPath.RestorePath(t, null);
    }
    static RestorePath(t, firstVertexInStage) {
        if (t.entry == null) {
            return [];
        }
        const list = new Array();
        let skippedCollinearEntry = false;
        let lastEntryDir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
        while (true) {
            // Reduce unnecessary AxisEdge creations in Nudger by including only bend points, not points in the middle of a segment.
            if (lastEntryDir === t.entry.Direction) {
                skippedCollinearEntry = true;
            }
            else {
                skippedCollinearEntry = false;
                list.push(t.entry.Vertex.point);
                lastEntryDir = t.entry.Direction;
            }
            const previousEntry = t.entry.PreviousEntry;
            if (previousEntry == null || t.entry.Vertex === firstVertexInStage) {
                break;
            }
            t.entry = previousEntry;
        }
        if (skippedCollinearEntry) {
            list.push(t.entry.Vertex.point);
        }
        list.reverse();
        return list;
    }
    QueueReversedEntryToNeighborVertexIfNeeded(bestEntry, entryFromNeighbor, weight) {
        // If we have a lower-cost path from bestEntry to entryFromNeighbor.PreviousVertex than the cost of entryFromNeighbor,
        // or bestEntry has degree 1 (it is a dead-end), enqueue a path in the opposite direction (entryFromNeighbor will probably
        // never be extended from this point).
        const t = { numberOfBends: 0, length: 0 };
        const neigVer = entryFromNeighbor.PreviousVertex;
        const dirToNeighbor = SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigVer, weight, t);
        if (this.CombinedCost(t.length, t.numberOfBends) < this.CombinedCost(entryFromNeighbor.Length, entryFromNeighbor.NumberOfBends) ||
            bestEntry.Vertex.Degree === 1) {
            const cost = this.TotalCostFromSourceToVertex(t.length, t.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(neigVer.point, dirToNeighbor);
            this.EnqueueEntry(bestEntry, neigVer, t.length, t.numberOfBends, cost);
        }
    }
    UpdateEntryToNeighborVertexIfNeeded(bestEntry, neigEntry, weight) {
        const t = {
            numberOfBends: 0,
            length: 0,
        };
        const dirToNeighbor = SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigEntry.Vertex, weight, t);
        if (this.CombinedCost(t.length, t.numberOfBends) < this.CombinedCost(neigEntry.Length, neigEntry.NumberOfBends)) {
            const newCost = this.TotalCostFromSourceToVertex(t.length, t.numberOfBends) +
                this.HeuristicDistanceFromVertexToTarget(neigEntry.Vertex.point, dirToNeighbor);
            neigEntry.ResetEntry(bestEntry, t.length, t.numberOfBends, newCost);
            this.queue.DecreasePriority(neigEntry, newCost);
        }
    }
    CreateAndEnqueueEntryToNeighborVertex(bestEntry, neigVer, weight) {
        const t = { numberOfBends: 0, length: 0 };
        const dirToNeighbor = SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry, neigVer, weight, t);
        const cost = this.TotalCostFromSourceToVertex(t.length, t.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(neigVer.point, dirToNeighbor);
        if (cost < this.upperBoundOnCost) {
            if (neigVer.VertexEntries == null) {
                this.visitedVertices.push(neigVer);
            }
            this.EnqueueEntry(bestEntry, neigVer, t.length, t.numberOfBends, cost);
        }
    }
    EnqueueEntry(bestEntry, neigVer, length, numberOfBends, cost) {
        const entry = new _VertexEntry__WEBPACK_IMPORTED_MODULE_4__.VertexEntry(neigVer, bestEntry, length, numberOfBends, cost);
        neigVer.SetVertexEntry(entry);
        this.queue.Enqueue(entry, entry.Cost);
    }
    static GetLengthAndNumberOfBendsToNeighborVertex(prevEntry, vertex, weight, t) {
        t.length = prevEntry.Length + SsstRectilinearPath.ManhattanDistance(prevEntry.Vertex.point, vertex.point) * weight;
        const directionToVertex = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(prevEntry.Vertex.point, vertex.point);
        t.numberOfBends = prevEntry.NumberOfBends;
        if (prevEntry.Direction !== _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None && directionToVertex !== prevEntry.Direction) {
            t.numberOfBends++;
        }
        return directionToVertex;
    }
    static ManhattanDistance(a, b) {
        return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);
    }
    GetPathWithCost(sourceVertexEntries, source, adjustmentToSourceCost, targetVertexEntries, target, adjustmentToTargetCost, priorBestCost) {
        this.upperBoundOnCost = priorBestCost;
        this.sourceCostAdjustment = adjustmentToSourceCost;
        this.targetCostAdjustment = adjustmentToTargetCost;
        if (!this.InitPath(sourceVertexEntries, source, target)) {
            return null;
        }
        while (this.queue.count > 0) {
            const bestEntry = this.queue.Dequeue();
            const bestVertex = bestEntry.Vertex;
            if (bestVertex === this.Target) {
                if (targetVertexEntries == null) {
                    this.Cleanup();
                    return bestEntry;
                }
                // We'll never get a duplicate entry direction here; we either relaxed the cost via UpdateEntryToNeighborIfNeeded
                // before we dequeued it, or it was closed.  So, we simply remove the direction from the valid target entry directions
                // and if we get to none, we're done.  We return a null path until the final stage.
                bestEntry.Direction;
                if (this.EntryDirectionsToTarget === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None) {
                    let i = 0;
                    for (const t of this.Target.VertexEntries) {
                        targetVertexEntries[i++] = t;
                    }
                    this.Cleanup();
                    return null;
                }
                this.upperBoundOnCost = Math.min(this.MultistageAdjustedCostBound(bestEntry.Cost), this.upperBoundOnCost);
                continue;
            }
            // It's safe to close this after removing it from the queue.  Any updateEntryIfNeeded that changes it must come
            // while it is still on the queue; it is removed from the queue only if it has the lowest cost path, and we have
            // no negative path weights, so any other path that might try to extend to it after this cannot have a lower cost.
            bestEntry.IsClosed = true;
            // PerfNote: Array.ForEach is optimized, but don't use .Where.
            for (const bendNeighbor of this.nextNeighbors) {
                bendNeighbor.Clear();
            }
            const preferredBendDir = SsstRectilinearPath.Right(bestEntry.Direction);
            this.ExtendPathAlongInEdges(bestEntry, bestVertex.InEdges, preferredBendDir);
            this.ExtendPathAlongOutEdges(bestEntry, bestVertex.OutEdges, preferredBendDir);
            for (const bendNeighbor of this.nextNeighbors) {
                if (bendNeighbor.Vertex != null) {
                    this.ExtendPathToNeighborVertex(bestEntry, bendNeighbor.Vertex, bendNeighbor.Weight);
                }
            }
        }
        // Either there is no path to the target, or we have abandoned the path due to exceeding priorBestCost.
        if (targetVertexEntries != null && this.Target.VertexEntries != null) {
            for (let i = 0; i < this.Target.VertexEntries.length; i++) {
                targetVertexEntries[i] = this.Target.VertexEntries[i];
            }
        }
        this.Cleanup();
        return null;
    }
    ExtendPathAlongInEdges(bestEntry, edges, preferredBendDir) {
        // Iteration is faster than foreach and much faster than .Where.
        for (const edge of edges) {
            this.ExtendPathAlongEdge(bestEntry, edge, true, preferredBendDir);
        }
    }
    ExtendPathAlongOutEdges(bestEntry, edges, preferredBendDir) {
        // Avoid GetEnumerator overhead.
        let outEdgeNode = edges.isEmpty() ? null : edges.treeMinimum();
        for (; outEdgeNode != null; outEdgeNode = edges.next(outEdgeNode)) {
            this.ExtendPathAlongEdge(bestEntry, outEdgeNode.item, false, preferredBendDir);
        }
    }
    ExtendPathAlongEdge(bestEntry, edge, isInEdges, preferredBendDir) {
        if (!SsstRectilinearPath.IsPassable(edge)) {
            return;
        }
        // This is after the initial source vertex so PreviousEntry won't be null.
        const neigVer = isInEdges ? edge.Source : edge.Target;
        if (neigVer === bestEntry.PreviousVertex) {
            // For multistage paths, the source may be a waypoint outside the graph boundaries that is collinear
            // with both the previous and next points in the path; in that case it may have only one degree.
            // For other cases, we just ignore it and the path will be abandoned.
            if (bestEntry.Vertex.Degree > 1 || bestEntry.Vertex !== this.Source) {
                return;
            }
            this.ExtendPathToNeighborVertex(bestEntry, neigVer, edge.Weight);
            return;
        }
        // Enqueue in reverse order of preference per comments on NextNeighbor class.
        const neigDir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(bestEntry.Vertex.point, neigVer.point);
        let nextNeighbor = this.nextNeighbors[2];
        if (neigDir !== bestEntry.Direction) {
            nextNeighbor = this.nextNeighbors[neigDir === preferredBendDir ? 1 : 0];
        }
        /*Assert.assert(nextNeighbor.Vertex == null , 'bend neighbor already exists')*/
        nextNeighbor.Set(neigVer, edge.Weight);
    }
    EnqueueInitialVerticesFromSource(cost) {
        const bestEntry = new _VertexEntry__WEBPACK_IMPORTED_MODULE_4__.VertexEntry(this.Source, null, 0, 0, cost);
        bestEntry.IsClosed = true;
        // This routine is only called once so don't worry about optimizing foreach.where
        for (const edge of this.Source.OutEdges) {
            if (!SsstRectilinearPath.IsPassable(edge))
                continue;
            this.ExtendPathToNeighborVertex(bestEntry, edge.Target, edge.Weight);
        }
        for (const edge of this.Source.InEdges) {
            if (!SsstRectilinearPath.IsPassable(edge))
                continue;
            this.ExtendPathToNeighborVertex(bestEntry, edge.Source, edge.Weight);
        }
    }
    EnqueueInitialVerticesFromSourceEntries(sourceEntries) {
        for (const entry of sourceEntries) {
            if (entry != null) {
                this.queue.Enqueue(entry, entry.Cost);
            }
        }
    }
    ExtendPathToNeighborVertex(bestEntry, neigVer, weight) {
        const dirToNeighbor = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(bestEntry.Vertex.point, neigVer.point);
        const neigEntry = neigVer.VertexEntries != null ? neigVer.VertexEntries[_math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.ToIndex(dirToNeighbor)] : null;
        if (neigEntry == null) {
            if (!this.CreateAndEnqueueReversedEntryToNeighborVertex(bestEntry, neigVer, weight)) {
                this.CreateAndEnqueueEntryToNeighborVertex(bestEntry, neigVer, weight);
            }
        }
        else if (!neigEntry.IsClosed) {
            this.UpdateEntryToNeighborVertexIfNeeded(bestEntry, neigEntry, weight);
        }
    }
    CreateAndEnqueueReversedEntryToNeighborVertex(bestEntry, neigVer, weight) {
        // VertexEntries is null for the initial source. Otherwise, if there is already a path into bestEntry's vertex
        // from neigVer, we're turning back on the path; therefore we have already enqueued the neighbors of neigVer.
        // However, the path cost includes both path length to the current point and the lookahead; this means that we
        // may now be coming into the neigVer from the opposite side with an equal score to the previous entry, but
        // the new path may be going toward the target while the old one (from neigVer to bestEntry) went away from
        // the target.  So, if we score better going in the opposite direction, enqueue bestEntry->neigVer; ignore
        // neigVer->bestEntry as it probably won't be extended again.
        if (bestEntry.Vertex.VertexEntries != null) {
            const dirFromNeighbor = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(neigVer.point, bestEntry.Vertex.point);
            const entryFromNeighbor = bestEntry.Vertex.VertexEntries[_math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.ToIndex(dirFromNeighbor)];
            if (entryFromNeighbor != null) {
                /*Assert.assert(
                  entryFromNeighbor.PreviousVertex === neigVer,
                  'mismatch in turnback PreviousEntry',
                )*/
                /*Assert.assert(
                  entryFromNeighbor.PreviousEntry.IsClosed,
                  'turnback PreviousEntry should be closed',
                )*/
                this.QueueReversedEntryToNeighborVertexIfNeeded(bestEntry, entryFromNeighbor, weight);
                return true;
            }
        }
        return false;
    }
    static IsPassable(edge) {
        return edge.IsPassable == null || edge.IsPassable();
    }
    Cleanup() {
        for (const v of this.visitedVertices) {
            v.RemoveVertexEntries();
        }
        this.visitedVertices = [];
        this.queue = null;
        // this.TestClearIterations()
    }
}
// Only bends importance needs to be public.
SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance = 4;
SsstRectilinearPath.AddOneTurn = [
    _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None,
    _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West,
    _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South,
    15,
    _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West,
    15,
    15,
    15,
    13,
    15,
    15,
    15,
    15,
    15,
    15,
    15, //15
];
//# sourceMappingURL=SsstRectilinearPath.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaticGraphUtility: () => (/* binding */ StaticGraphUtility)
/* harmony export */ });
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
// import {CompassVector} from '../../math/geometry/compassVector'



class StaticGraphUtility {
    // Determine the direction of an edge.
    static EdgeDirectionVE(edge) {
        return StaticGraphUtility.EdgeDirectionVV(edge.Source, edge.Target);
    }
    static EdgeDirectionVV(source, target) {
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(source.point, target.point);
    }
    static GetEdgeEnd(edge, dir) {
        const edgeDir = StaticGraphUtility.EdgeDirectionVE(edge);
        /*Assert.assert(
          0 !== (dir & (edgeDir | CompassVector.OppositeDir(edgeDir))),
          'dir is orthogonal to edge',
        )*/
        return dir === edgeDir ? edge.Target : edge.Source;
    }
    static FindAdjacentVertex(vertex, dir) {
        // This function finds the next vertex in the desired direction relative to the
        // current vertex, not necessarily the edge orientation, hence it does not use
        // EdgeDirection().  This is so the caller can operate on a desired movement
        // direction without having to track whether we're going forward or backward
        // through the In/OutEdge chain.
        for (const edge of vertex.InEdges) {
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(vertex.point, edge.SourcePoint) === dir) {
                return edge.Source;
            }
        }
        // Avoid GetEnumerator overhead.
        for (const edge of vertex.OutEdges) {
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(vertex.point, edge.TargetPoint) === dir) {
                return edge.Target;
            }
        }
        return null;
    }
    static FindAdjacentEdge(a, dir) {
        for (const edge of a.InEdges) {
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(edge.SourcePoint, a.point) === dir) {
                return edge;
            }
        }
        for (const edge of a.OutEdges) {
            if (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(a.point, edge.TargetPoint) === dir) {
                return edge;
            }
        }
        return null;
    }
    static FindBendPointBetween(sourcePoint, targetPoint, finalEdgeDir) {
        return !StaticGraphUtility.IsVerticalD(finalEdgeDir) ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(sourcePoint.x, targetPoint.y) : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(targetPoint.x, sourcePoint.y);
    }
    static SegmentIntersectionPPP(first, second, from) {
        const dir = _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(first, second);
        return StaticGraphUtility.IsVerticalD(dir) ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(first.x, from.y) : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(from.x, first.y);
    }
    static SegmentIntersectionSP(seg, from) {
        return StaticGraphUtility.SegmentIntersectionPPP(seg.Start, seg.End, from);
    }
    static SegmentsIntersection(first, second) {
        return StaticGraphUtility.IntervalsIntersect(first.Start, first.End, second.Start, second.End);
    }
    static SegmentsIntersectLL(first, second) {
        return StaticGraphUtility.IntervalsIntersect(first.start, first.end, second.start, second.end);
    }
    static IntervalsOverlapSS(first, second) {
        return StaticGraphUtility.IntervalsOverlapPPPP(first.Start, first.End, second.Start, second.End);
    }
    static IntervalsOverlapPPPP(start1, end1, start2, end2) {
        return (StaticGraphUtility.IntervalsAreCollinear(start1, end1, start2, end2) &&
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.ComparePP(start1, end2) !== _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.ComparePP(end1, start2));
    }
    static IntervalsAreCollinear(start1, end1, start2, end2) {
        /*Assert.assert(
          StaticGraphUtility.IsVerticalPP(start1, end1) ==
            StaticGraphUtility.IsVerticalPP(start2, end2),
          'segments are not in the same orientation',
        )*/
        const vertical = StaticGraphUtility.IsVerticalPP(start1, end1);
        if (StaticGraphUtility.IsVerticalPP(start2, end2) === vertical) {
            // This handles touching endpoints as well.
            return vertical ? _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Equal(start1.x, start2.x) : _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Equal(start1.y, start2.y);
        }
        return false;
    }
    static IntervalsAreSame(start1, end1, start2, end2) {
        return _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.EqualPP(start1, start2) && _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.EqualPP(end1, end2);
    }
    static IntervalsIntersect(firstStart, firstEnd, secondStart, secondEnd) {
        /*Assert.assert(
          StaticGraphUtility.IsVerticalPP(firstStart, firstEnd) !=
            StaticGraphUtility.IsVerticalPP(secondStart, secondEnd),
          'cannot intersect two parallel segments',
        )*/
        const intersect = StaticGraphUtility.SegmentIntersectionPPP(firstStart, firstEnd, secondStart);
        return StaticGraphUtility.PointIsOnSegmentPPP(firstStart, firstEnd, intersect) &&
            StaticGraphUtility.PointIsOnSegmentPPP(secondStart, secondEnd, intersect)
            ? intersect
            : undefined;
    }
    static SegmentIntersectionEP(edge, from) {
        return StaticGraphUtility.SegmentIntersectionPPP(edge.SourcePoint, edge.TargetPoint, from);
    }
    static PointIsOnSegmentPPP(first, second, test) {
        return (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.EqualPP(first, test) ||
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.EqualPP(second, test) ||
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(first, test) === _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(test, second));
    }
    static PointIsOnSegmentSP(seg, test) {
        return StaticGraphUtility.PointIsOnSegmentPPP(seg.Start, seg.End, test);
    }
    static IsVerticalD(dir) {
        return 0 !== (dir & (_math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.North | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.South));
    }
    static IsVerticalE(edge) {
        return StaticGraphUtility.IsVerticalD(_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(edge.SourcePoint, edge.TargetPoint));
    }
    static IsVerticalPP(first, second) {
        return StaticGraphUtility.IsVerticalD(_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(first, second));
    }
    static IsVertical(seg) {
        return StaticGraphUtility.IsVerticalD(_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(seg.start, seg.end));
    }
    static IsAscending(dir) {
        return (dir & (_math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.North | _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.East)) !== 0;
    }
    static Slope(start, end, scanDir) {
        // Find the slope relative to scanline - how much scan coord changes per sweep change.
        const lineDir = end.sub(start);
        return lineDir.dot(scanDir.PerpDirectionAsPoint) / lineDir.dot(scanDir.DirectionAsPoint);
    }
    static SortAscending(a, b) {
        const dir = _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.GetDirections(a, b);
        /*Assert.assert(
          Direction.None === dir || PointComparer.IsPureDirectionD(dir),
          'SortAscending with impure direction',
        )*/
        return _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.None === dir || StaticGraphUtility.IsAscending(dir) ? [a, b] : [b, a];
    }
    static RectangleBorderIntersect(boundingBox, point, dir) {
        switch (dir) {
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.North:
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.South:
                return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(point.x, StaticGraphUtility.GetRectangleBound(boundingBox, dir));
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.East:
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.West:
                return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point(StaticGraphUtility.GetRectangleBound(boundingBox, dir), point.y);
                break;
            default:
                throw new Error();
                break;
        }
    }
    static GetRectangleBound(rect, dir) {
        switch (dir) {
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.North:
                return rect.top;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.South:
                return rect.bottom;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.East:
                return rect.right;
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.West:
                return rect.left;
                break;
            default:
                throw new Error();
                break;
        }
    }
    static RectangleInteriorsIntersect(a, b) {
        return (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(a.bottom, b.top) < 0 &&
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(b.bottom, a.top) < 0 &&
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(a.left, b.right) < 0 &&
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(b.left, a.right) < 0);
    }
    static PointIsInRectangleInterior(point, rect) {
        return (_PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(point.y, rect.top) < 0 &&
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(rect.bottom, point.y) < 0 &&
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(point.x, rect.right) < 0 &&
            _PointComparer__WEBPACK_IMPORTED_MODULE_2__.PointComparer.Compare(rect.left, point.x) < 0);
    }
}
//# sourceMappingURL=StaticGraphUtility.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/TransientGraphUtility.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TransientGraphUtility: () => (/* binding */ TransientGraphUtility)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js");
/* harmony import */ var _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _GroupBoundaryCrossing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/GroupBoundaryCrossing.js");
/* harmony import */ var _PointAndCrossingsList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointAndCrossingsList.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _ScanSegment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegment.js");
/* harmony import */ var _SparseVisibiltyGraphGenerator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/SparseVisibiltyGraphGenerator.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");











class TransientGraphUtility {
    get ObstacleTree() {
        return this.GraphGenerator.ObstacleTree;
    }
    get VisGraph() {
        return this.GraphGenerator.VisibilityGraph;
    }
    get IsSparseVg() {
        return this.GraphGenerator instanceof _SparseVisibiltyGraphGenerator__WEBPACK_IMPORTED_MODULE_9__.SparseVisibilityGraphGenerator;
    }
    constructor(graphGen) {
        // Vertices added to the graph for routing.
        this.AddedVertices = new Array();
        // Edges added to the graph for routing.
        this.AddedEdges = new Array();
        // Edges joining two non-transient vertices; these must be replaced.
        this.edgesToRestore = new Array();
        this.LimitPortVisibilitySpliceToEndpointBoundingBox = false;
        this.GraphGenerator = graphGen;
    }
    AddVertex(location) {
        const vertex = this.VisGraph.AddVertexP(location);
        this.AddedVertices.push(vertex);
        return vertex;
    }
    FindOrAddVertex(location) {
        const vertex = this.VisGraph.FindVertex(location);
        return vertex !== null && vertex !== void 0 ? vertex : this.AddVertex(location);
    }
    FindOrAddEdgeVV(sourceVertex, targetVertex) {
        return this.FindOrAddEdge(sourceVertex, targetVertex, _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.NormalWeight);
    }
    FindOrAddEdge(sourceVertex, targetVertex, weight) {
        // Since we're adding transient edges into the graph, we're not doing full intersection
        // evaluation; thus there may already be an edge from the source vertex in the direction
        // of the target vertex, but ending before or after the target vertex.
        const dirToTarget = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetPureDirectionVV(sourceVertex, targetVertex);
        // Is there an edge in the chain from sourceVertex in the direction of targetVertex
        // that brackets targetvertex?
        //      <sourceVertex> -> ..1.. -> ..2.. <end>   3
        // Yes if targetVertex is at the x above 1 or 2, No if it is at 3.  If false, bracketSource
        // will be set to the vertex at <end> (if there are any edges in that direction at all).
        const t = {
            bracketSource: undefined,
            bracketTarget: undefined,
            splitVertex: undefined,
        };
        TransientGraphUtility.GetBrackets(sourceVertex, targetVertex, dirToTarget, t);
        // If null !=  edge then targetVertex is between bracketSource and bracketTarget and SplitEdge returns the
        // first half-edge (and weight is ignored as the split uses the edge weight).
        let edge = this.VisGraph.FindEdgePP(t.bracketSource.point, t.bracketTarget.point);
        edge = edge != null ? this.SplitEdge(edge, t.splitVertex) : this.CreateEdge(t.bracketSource, t.bracketTarget, weight);
        return edge;
    }
    static GetBrackets(sourceVertex, targetVertex, dirToTarget, t) {
        // Is there an edge in the chain from sourceVertex in the direction of targetVertex
        // that brackets targetvertex?
        //      <sourceVertex> -> ..1.. -> ..2.. <end>   3
        // Yes if targetVertex is at the x above 1 or 2, No if it is at 3.  If false, bracketSource
        // will be set to the vertex at <end> (if there are any edges in that direction at all).
        t.splitVertex = targetVertex;
        if (!TransientGraphUtility.FindBracketingVertices(sourceVertex, targetVertex.point, dirToTarget, t)) {
            // No bracketing of targetVertex from sourceVertex but bracketSource has been updated.
            // Is there a bracket of bracketSource from the targetVertex direction?
            //                      3   <end> ..2.. <- ..1..   <targetVertex>
            // Yes if bracketSource is at the x above 1 or 2, No if it is at 3.  If false, bracketTarget
            // will be set to the vertex at <end> (if there are any edges in that direction at all).
            // If true, then bracketSource and splitVertex must be updated.
            const tt = {
                bracketSource: null,
                bracketTarget: null,
            };
            if (TransientGraphUtility.FindBracketingVertices(targetVertex, sourceVertex.point, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dirToTarget), tt)) {
                /*Assert.assert(
                  t.bracketSource === sourceVertex,
                  'Mismatched bracketing detection',
                )*/
                t.bracketSource = tt.bracketTarget;
                t.splitVertex = sourceVertex;
            }
            t.bracketTarget = tt.bracketSource;
        }
    }
    static FindBracketingVertices(sourceVertex, targetPoint, dirToTarget, t) {
        // Walk from the source to target until we bracket target or there is no nextVertex
        // in the desired direction.
        t.bracketSource = sourceVertex;
        for (;;) {
            t.bracketTarget = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(t.bracketSource, dirToTarget);
            if (t.bracketTarget == null) {
                break;
            }
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(t.bracketTarget.point, targetPoint)) {
                // Desired edge already exists.
                return true;
            }
            if (dirToTarget !== _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(t.bracketTarget.point, targetPoint)) {
                // bracketTarget is past vertex in the traversal direction.
                break;
            }
            t.bracketSource = t.bracketTarget;
        }
        return t.bracketTarget != null;
    }
    // DEVTRACE
    // ReSharper restore InconsistentNaming
    CreateEdge(first, second, weight) {
        // All edges in the graph are ascending.
        let source = first;
        let target = second;
        if (!_PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.IsPureLower(source.point, target.point)) {
            source = second;
            target = first;
        }
        const edge = new _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_3__.TollFreeVisibilityEdge(source, target, weight);
        _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraph.AddEdge(edge);
        this.AddedEdges.push(edge);
        return edge;
    }
    RemoveFromGraph() {
        this.RemoveAddedVertices();
        this.RemoveAddedEdges();
        this.RestoreRemovedEdges();
    }
    RemoveAddedVertices() {
        for (const vertex of this.AddedVertices) {
            // Removing all transient vertices will remove all associated transient edges as well.
            if (this.VisGraph.FindVertex(vertex.point) != null) {
                this.VisGraph.RemoveVertex(vertex);
            }
        }
        this.AddedVertices = [];
    }
    RemoveAddedEdges() {
        for (const edge of this.AddedEdges) {
            // If either vertex was removed, so was the edge, so just check source.
            if (this.VisGraph.FindVertex(edge.SourcePoint) != null) {
                _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraph.RemoveEdge(edge);
            }
        }
        this.AddedEdges = [];
    }
    RestoreRemovedEdges() {
        for (const edge of this.edgesToRestore) {
            // We should only put TransientVisibilityEdges in this list, and should never encounter
            // a non-transient edge in the graph after we've replaced it with a transient one, so
            // the edge should not be in the graph until we re-insert it.
            /*Assert.assert(
              !(edge instanceof TollFreeVisibilityEdge),
              'Unexpected Transient edge',
            )*/
            _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraph.AddEdge(edge);
        }
        this.edgesToRestore = [];
    }
    FindNextEdge(vertex, dir) {
        return _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentEdge(vertex, dir);
    }
    FindPerpendicularOrContainingEdge(startVertex, dir, pointLocation) {
        // Return the edge in 'dir' from startVertex that is perpendicular to pointLocation.
        // startVertex must therefore be located such that pointLocation is in 'dir' direction from it,
        // or is on the same line.
        // StaticGraphUtility.Assert((0
        //                === (CompassVector.OppositeDir(dir) & PointComparer.GetDirections(startVertex.point, pointLocation))), "the ray from 'dir' is away from pointLocation", this.ObstacleTree, this.VisGraph);
        while (true) {
            const nextVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(startVertex, dir);
            if (nextVertex == null) {
                break;
            }
            const dirCheck = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(nextVertex.point, pointLocation);
            // If the next vertex is past the intersection with pointLocation, this edge brackets it.
            if (0 !== (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dir) & dirCheck)) {
                return this.VisGraph.FindEdgePP(startVertex.point, nextVertex.point);
            }
            startVertex = nextVertex;
        }
        return null;
    }
    FindNearestPerpendicularOrContainingEdge(startVertex, dir, pointLocation) {
        // Similar to FindPerpendicularEdge, but first try to move closer to pointLocation,
        // as long as there are edges going in 'dir' that extend to pointLocation.
        let dirTowardLocation;
        dir & _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(startVertex.point, pointLocation);
        // If Directions. None then pointLocation is collinear.
        let currentVertex = startVertex;
        const currentDirTowardLocation = dirTowardLocation;
        // First move toward pointLocation far as we can.
        while (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.None !== currentDirTowardLocation) {
            const nextVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(currentVertex, dirTowardLocation);
            if (nextVertex == null) {
                break;
            }
            if (0 !== (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dirTowardLocation) & _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(nextVertex.point, pointLocation))) {
                break;
            }
            currentVertex = nextVertex;
            dir & _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(currentVertex.point, pointLocation);
        }
        // Now find the first vertex that has a chain that intersects pointLocation, if any, moving away
        // from pointLocation until we find it or arrive back at startVertex.
        let perpEdge;
        while (true) {
            perpEdge = this.FindPerpendicularOrContainingEdge(currentVertex, dir, pointLocation);
            if (perpEdge != null || currentVertex === startVertex) {
                break;
            }
            currentVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(currentVertex, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dirTowardLocation));
        }
        return perpEdge;
    }
    ConnectVertexToTargetVertex(sourceVertex, targetVertex, finalEdgeDir, weight) {
        // finalDir is the required direction of the final edge to the targetIntersect
        // (there will be two edges if we have to add a bend vertex).
        // StaticGraphUtility.Assert(PointComparer.IsPureDirection(finalEdgeDir), "finalEdgeDir is not pure", this.ObstacleTree, this.VisGraph);
        // // targetIntersect may be CenterVertex if that is on an extreme bend or a flat border.
        if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(sourceVertex.point, targetVertex.point)) {
            return;
        }
        // If the target is collinear with sourceVertex we can just create one edge to it.
        const targetDirs = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(sourceVertex.point, targetVertex.point);
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.IsPureDirectionD(targetDirs)) {
            this.FindOrAddEdgeVV(sourceVertex, targetVertex);
            return;
        }
        // Not collinear so we need to create a bend vertex and edge if they don't yet exist.
        const bendPoint = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindBendPointBetween(sourceVertex.point, targetVertex.point, finalEdgeDir);
        const bendVertex = this.FindOrAddVertex(bendPoint);
        this.FindOrAddEdge(sourceVertex, bendVertex, weight);
        // Now create the outer target vertex if it doesn't exist.
        this.FindOrAddEdge(bendVertex, targetVertex, weight);
    }
    AddEdgeToTargetEdge(sourceVertex, targetEdge, targetIntersect) {
        // StaticGraphUtility.Assert((Point.closeDistEps(sourceVertex.point, targetIntersect) || PointComparer.IsPureDirection(sourceVertex.point, targetIntersect)), "non-orthogonal edge request", this.ObstacleTree, this.VisGraph);
        // StaticGraphUtility.Assert(StaticGraphUtility.PointIsOnSegmentSP(targetEdge.SourcePoint, targetEdge.TargetPoint, targetIntersect), "targetIntersect is not on targetEdge", this.ObstacleTree, this.VisGraph);
        // If the target vertex does not exist, we must split targetEdge to add it.
        let targetVertex = this.VisGraph.FindVertex(targetIntersect);
        if (targetVertex == null) {
            targetVertex = this.AddVertex(targetIntersect);
            this.SplitEdge(targetEdge, targetVertex);
        }
        this.FindOrAddEdgeVV(sourceVertex, targetVertex);
        return targetVertex;
    }
    SplitEdge(edge, splitVertex) {
        // If the edge is NULL it means we could not find an appropriate one, so do nothing.
        if (edge == null) {
            return null;
        }
        // StaticGraphUtility.Assert(StaticGraphUtility.PointIsOnSegmentSP(edge.SourcePoint, edge.TargetPoint, splitVertex.point), "splitVertex is not on edge", this.ObstacleTree, this.VisGraph);
        if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(edge.Source.point, splitVertex.point) || _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(edge.Target.point, splitVertex.point)) {
            // No split needed.
            return edge;
        }
        // Store the original edge, if needed.
        if (!(edge instanceof _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_3__.TollFreeVisibilityEdge)) {
            this.edgesToRestore.push(edge);
        }
        _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraph.RemoveEdge(edge);
        // If this is an overlapped edge, or we're in sparseVg, then it may be an unpadded->padded edge that crosses
        // over another obstacle's padded boundary, and then either a collinear splice from a free point or another
        // obstacle in the same cluster starts splicing from that leapfrogged boundary, so we have the edges:
        //      A   ->   D                      | D is unpadded, A is padded border of sourceObstacle
        //        B -> C  ->  E  ->  F          | B and C are vertical ScanSegments between A and D
        //      <-- splice direction is West    | F is unpadded, E is padded border of targetObstacle
        // Now after splicing F to E to C to B we go A, calling FindOrAddEdge B->A; the bracketing process finds
        // A->D which we'll be splitting at B, which would wind up with A->B, B->C, B->D, having to Eastward
        // outEdges from B.  See RectilinearTests.Reflection_Block1_Big_UseRect for overlapped, and
        // RectilinearTests.FreePortLocationRelativeToTransientVisibilityEdgesSparseVg for sparseVg.
        // To avoid this we add the edges in each direction from splitVertex with FindOrAddEdge.  If we've
        // come here from a previous call to FindOrAddEdge, then that call has found the bracketing vertices,
        // which are the endpoints of 'edge', and we've removed 'edge', so we will not call SplitEdge again.
        if ((this.IsSparseVg || edge.Weight === _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.OverlappedWeight) && splitVertex.Degree > 0) {
            this.FindOrAddEdge(splitVertex, edge.Source, edge.Weight);
            return this.FindOrAddEdge(splitVertex, edge.Target, edge.Weight);
        }
        // Splice it into the graph in place of targetEdge.  Return the first half, because
        // this may be called from AddEdge, in which case the split vertex is the target vertex.
        this.CreateEdge(splitVertex, edge.Target, edge.Weight);
        return this.CreateEdge(edge.Source, splitVertex, edge.Weight);
    }
    ExtendEdgeChainVRLPB(startVertex, limitRect, maxVisibilitySegment, pacList, isOverlapped) {
        const dir = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(maxVisibilitySegment.start, maxVisibilitySegment.end);
        if (dir === _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Direction.None) {
            return;
        }
        /*Assert.assert(
          CompassVector.IsPureDirection(dir),
          'impure max visibility segment',
        )*/
        // Shoot the edge chain out to the shorter of max visibility or intersection with the limitrect.
        // StaticGraphUtility.Assert((Point.closeDistEps(maxVisibilitySegment.start, startVertex.point)
        //                || (PointComparer.GetPureDirectionVV(maxVisibilitySegment.start, startVertex.point) === dir)), "Inconsistent direction found", this.ObstacleTree, this.VisGraph);
        const oppositeFarBound = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.GetRectangleBound(limitRect, dir);
        const maxDesiredSplicePoint = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.IsVerticalD(dir)
            ? _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(startVertex.point.x, oppositeFarBound))
            : _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.RoundPoint(new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(oppositeFarBound, startVertex.point.y));
        if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(maxDesiredSplicePoint, startVertex.point)) {
            // Nothing to do.
            return;
        }
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(startVertex.point, maxDesiredSplicePoint) !== dir) {
            // It's in the opposite direction, so no need to do anything.
            return;
        }
        // If maxDesiredSplicePoint is shorter, create a new shorter segment.  We have to pass both segments
        // through to the worker function so it knows whether it can go past maxDesiredSegment (which may be limited
        // by limitRect).
        let maxDesiredSegment = maxVisibilitySegment;
        if (_PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(maxDesiredSplicePoint, maxDesiredSegment.end) === dir) {
            maxDesiredSegment = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(maxDesiredSegment.start, maxDesiredSplicePoint);
        }
        this.ExtendEdgeChain(startVertex, dir, maxDesiredSegment, maxVisibilitySegment, pacList, isOverlapped);
    }
    ExtendEdgeChain(startVertex, extendDir, maxDesiredSegment, maxVisibilitySegment, pacList, isOverlapped) {
        // StaticGraphUtility.Assert((PointComparer.GetDirections(maxDesiredSegment.start, maxDesiredSegment.end) === extendDir), "maxDesiredSegment is reversed", this.ObstacleTree, this.VisGraph);
        // Direction*s*, because it may return None, which is valid and means startVertex is on the
        // border of an obstacle and we don't want to go inside it.
        const segmentDir = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(startVertex.point, maxDesiredSegment.end);
        if (segmentDir !== extendDir) {
            // OppositeDir may happen on overlaps where the boundary has a gap in its ScanSegments due to other obstacles
            // overlapping it and each other.  This works because the port has an edge connected to startVertex,
            // which is on a ScanSegment outside the obstacle.
            // StaticGraphUtility.Assert((isOverlapped
            //                || (segmentDir !== CompassVector.OppositeDir(extendDir))), "obstacle encountered between prevPoint and startVertex", this.ObstacleTree, this.VisGraph);
            return;
        }
        // We'll find the segment to the left (or right if to the left doesn't exist),
        // then splice across in the opposite direction.
        let spliceSourceDir = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.RotateLeft(extendDir);
        let spliceSource = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(startVertex, spliceSourceDir);
        if (spliceSource == null) {
            spliceSourceDir = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(spliceSourceDir);
            spliceSource = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(startVertex, spliceSourceDir);
            if (spliceSource == null) {
                return;
            }
        }
        // Store this off before ExtendSpliceWorker, which overwrites it.
        const spliceTargetDir = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(spliceSourceDir);
        const t = { spliceTarget: null };
        if (this.ExtendSpliceWorker(spliceSource, extendDir, spliceTargetDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, t)) {
            // We ended on the source side and may have dead-ends on the target side so reverse sides.
            this.ExtendSpliceWorker(t.spliceTarget, extendDir, spliceSourceDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, t);
        }
        this.SpliceGroupBoundaryCrossings(pacList, startVertex, maxDesiredSegment);
    }
    SpliceGroupBoundaryCrossings(crossingList, startVertex, maxSegment) {
        if (crossingList == null || 0 === crossingList.Count()) {
            return;
        }
        crossingList.Reset();
        let start = maxSegment.start;
        let end = maxSegment.end;
        let dir = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(start, end);
        // Make sure we are going in the ascending direction.
        if (!_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.IsAscending(dir)) {
            start = maxSegment.end;
            end = maxSegment.start;
            dir = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dir);
        }
        // We need to back up to handle group crossings that are between a VisibilityBorderIntersect on a sloped border and the
        // incoming startVertex (which is on the first ScanSegment in Perpendicular(dir) that is outside that padded border).
        startVertex = TransientGraphUtility.TraverseToFirstVertexAtOrAbove(startVertex, start, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dir));
        // Splice into the Vertices between and including the start/end points.
        for (let currentVertex = startVertex; currentVertex != null; currentVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(currentVertex, dir)) {
            const isFinalVertex = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.ComparePP(currentVertex.point, end) >= 0;
            while (crossingList.CurrentIsBeforeOrAt(currentVertex.point)) {
                const pac = crossingList.Pop();
                // If it's past the start and at or before the end, splice in the crossings in the descending direction.
                if (_PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.ComparePP(pac.Location, startVertex.point) > 0) {
                    if (_PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.ComparePP(pac.Location, end) <= 0) {
                        this.SpliceGroupBoundaryCrossing(currentVertex, pac, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dir));
                    }
                }
                // If it's at or past the start and before the end, splice in the crossings in the descending direction.
                if (_PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.ComparePP(pac.Location, startVertex.point) >= 0) {
                    if (_PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.ComparePP(pac.Location, end) < 0) {
                        this.SpliceGroupBoundaryCrossing(currentVertex, pac, dir);
                    }
                }
            }
            if (isFinalVertex) {
                break;
            }
        }
    }
    static TraverseToFirstVertexAtOrAbove(startVertex, start, dir) {
        let returnVertex = startVertex;
        const oppositeDir = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(dir);
        for (;;) {
            const nextVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(returnVertex, dir);
            // This returns Directions. None on a match.
            if (nextVertex == null || _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(nextVertex.point, start) === oppositeDir) {
                break;
            }
            returnVertex = nextVertex;
        }
        return returnVertex;
    }
    SpliceGroupBoundaryCrossing(currentVertex, pac, dirToInside) {
        var _a, _b;
        const crossings = _PointAndCrossingsList__WEBPACK_IMPORTED_MODULE_6__.PointAndCrossingsList.ToCrossingArray(pac.Crossings, dirToInside);
        if (crossings != null) {
            const outerVertex = (_a = this.VisGraph.FindVertex(pac.Location)) !== null && _a !== void 0 ? _a : this.AddVertex(pac.Location);
            if (!currentVertex.point.equal(outerVertex.point)) {
                this.FindOrAddEdgeVV(currentVertex, outerVertex);
            }
            const interiorPoint = crossings[0].GetInteriorVertexPoint(pac.Location);
            const interiorVertex = (_b = this.VisGraph.FindVertex(interiorPoint)) !== null && _b !== void 0 ? _b : this.AddVertex(interiorPoint);
            // FindOrAddEdge splits an existing edge so may not return the portion bracketed by outerVertex and interiorVertex.
            const edge = this.FindOrAddEdgeVV(outerVertex, interiorVertex);
            //const edge = this.VisGraph.FindEdgePP(outerVertex.point, interiorVertex.point)
            const crossingsArray = crossings.map((c) => c.Group.InputShape);
            edge.IsPassable = () => crossingsArray.some((s) => s.IsTransparent);
        }
    }
    // The return value is whether we should try a second pass if this is called on the first pass,
    // using spliceTarget to wrap up dead-ends on the target side.
    ExtendSpliceWorker(spliceSourcePar, extendDir, spliceTargetDir, maxDesiredSegment, maxVisibilitySegment, isOverlapped, t) {
        // This is called after having created at least one extension vertex (initially, the
        // first one added outside the obstacle), so we know extendVertex
        // will be there. spliceSource  is the vertex to the OppositeDir(spliceTargetDir) of that extendVertex.
        let extendVertex = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(spliceSourcePar, spliceTargetDir);
        t.spliceTarget = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(extendVertex, spliceTargetDir);
        const st = { spliceSource: spliceSourcePar };
        for (;;) {
            if (!TransientGraphUtility.GetNextSpliceSource(st, spliceTargetDir, extendDir)) {
                break;
            }
            // spliceSource is now on the correct edge relative to the desired nextExtendPoint.
            // spliceTarget is in the opposite direction of the extension-line-to-spliceSource.
            const nextExtendPoint = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindBendPointBetween(extendVertex.point, st.spliceSource.point, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(spliceTargetDir));
            // We test below for being on or past maxDesiredSegment; here we may be skipping
            // over maxDesiredSegmentEnd which is valid since we want to be sure to go to or
            // past limitRect, but be sure to stay within maxVisibilitySegment.
            if (TransientGraphUtility.IsPointPastSegmentEnd(maxVisibilitySegment, nextExtendPoint)) {
                break;
            }
            t.spliceTarget = TransientGraphUtility.GetSpliceTarget(st, spliceTargetDir, nextExtendPoint);
            // StaticGraphUtility.Test_DumpVisibilityGraph(ObstacleTree, VisGraph);
            if (t.spliceTarget == null) {
                // This may be because spliceSource was created just for Group boundaries.  If so,
                // skip to the next nextExtendVertex location.
                if (this.IsSkippableSpliceSourceWithNullSpliceTarget(st.spliceSource, extendDir)) {
                    continue;
                }
                // We're at a dead-end extending from the source side, or there is an intervening obstacle, or both.
                // Don't splice across lateral group boundaries.
                if (this.ObstacleTree.SegmentCrossesAnObstacle(st.spliceSource.point, nextExtendPoint)) {
                    return false;
                }
            }
            // We might be walking through a point where a previous chain dead-ended.
            let nextExtendVertex = this.VisGraph.FindVertex(nextExtendPoint);
            if (nextExtendVertex != null) {
                if (t.spliceTarget == null || this.VisGraph.FindEdgePP(extendVertex.point, nextExtendPoint) != null) {
                    // We are probably along a ScanSegment so visibility in this direction has already been determined.
                    // Stop and don't try to continue extension from the opposite side.  If we continue splicing here
                    // it might go across an obstacle.
                    if (t.spliceTarget == null) {
                        this.FindOrAddEdge(extendVertex, nextExtendVertex, isOverlapped ? _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.OverlappedWeight : _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.NormalWeight);
                    }
                    return false;
                }
                // This should always have been found in the find-the-next-target loop above if there is
                // a vertex (which would be nextExtendVertex, which we just found) between spliceSource
                // and spliceTarget.  Even for a sparse graph, an edge should not skip over a vertex.
                // StaticGraphUtility.Assert((spliceTarget === StaticGraphUtility.FindAdjacentVertex(nextExtendVertex, spliceTargetDir)), "no edge exists between an existing nextExtendVertex and spliceTarget", this.ObstacleTree, this.VisGraph);
            }
            else {
                // StaticGraphUtility.Assert(((spliceTarget == null )
                //                || (spliceTargetDir === PointComparer.GetPureDirectionVV(nextExtendPoint, spliceTarget.point))), "spliceTarget is not to spliceTargetDir of nextExtendVertex", this.ObstacleTree, this.VisGraph);
                nextExtendVertex = this.AddVertex(nextExtendPoint);
            }
            this.FindOrAddEdge(extendVertex, nextExtendVertex, isOverlapped ? _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.OverlappedWeight : _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.NormalWeight);
            // This will split the edge if targetVertex is non-null; otherwise we are at a dead-end
            // on the target side so must not create a vertex as it would be inside an obstacle.
            this.FindOrAddEdge(st.spliceSource, nextExtendVertex, isOverlapped ? _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.OverlappedWeight : _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.NormalWeight);
            if (isOverlapped) {
                isOverlapped = this.SeeIfSpliceIsStillOverlapped(extendDir, nextExtendVertex);
            }
            extendVertex = nextExtendVertex;
            // Test GetDirections because it may return Directions. None.
            if (0 === (extendDir & _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(nextExtendPoint, maxDesiredSegment.end))) {
                // At or past the desired max extension point, so we're done.
                t.spliceTarget = null;
                break;
            }
        }
        return t.spliceTarget != null;
    }
    static GetNextSpliceSource(t, spliceTargetDir, extendDir) {
        let nextSpliceSource = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(t.spliceSource, extendDir);
        if (nextSpliceSource == null) {
            // See if there is a source further away from the extension line - we might have
            // been on freePoint line (or another nearby PortEntry line) that dead-ended.
            // Look laterally from the previous spliceSource first.
            nextSpliceSource = t.spliceSource;
            for (;;) {
                nextSpliceSource = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(nextSpliceSource, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(spliceTargetDir));
                if (nextSpliceSource == null) {
                    return false;
                }
                const nextSpliceSourceExtend = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(nextSpliceSource, extendDir);
                if (nextSpliceSourceExtend != null) {
                    nextSpliceSource = nextSpliceSourceExtend;
                    break;
                }
            }
        }
        t.spliceSource = nextSpliceSource;
        return true;
    }
    static GetSpliceTarget(t, spliceTargetDir, nextExtendPoint) {
        // Look for the target.  There may be a dead-ended edge starting at the current spliceSource
        // edge that has a vertex closer to the extension line; in that case keep walking until we
        // have the closest vertex on the Source side of the extension line as spliceSource.
        const prevDir = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(t.spliceSource.point, nextExtendPoint);
        let nextDir = prevDir;
        let spliceTarget = t.spliceSource;
        while (nextDir === prevDir) {
            t.spliceSource = spliceTarget;
            spliceTarget = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(t.spliceSource, spliceTargetDir);
            if (spliceTarget == null) {
                break;
            }
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(spliceTarget.point, nextExtendPoint)) {
                // If we encountered an existing vertex for the extension chain, update spliceTarget
                // to be after it and we're done with this loop.
                spliceTarget = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentVertex(spliceTarget, spliceTargetDir);
                break;
            }
            nextDir = _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(spliceTarget.point, nextExtendPoint);
        }
        return spliceTarget;
    }
    SeeIfSpliceIsStillOverlapped(extendDir, nextExtendVertex) {
        // If we've spliced out of overlapped space into free space, we may be able to turn off the
        // overlapped state if we have a perpendicular non-overlapped edge.
        let edge = this.FindNextEdge(nextExtendVertex, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.RotateLeft(extendDir));
        let maybeFreeSpace = edge == null ? false : _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.NormalWeight === edge.Weight;
        if (!maybeFreeSpace) {
            edge = this.FindNextEdge(nextExtendVertex, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.RotateRight(extendDir));
            maybeFreeSpace = edge == null ? false : _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.NormalWeight === edge.Weight;
        }
        return !maybeFreeSpace || this.ObstacleTree.PointIsInsideAnObstaclePD(nextExtendVertex.point, extendDir);
    }
    IsSkippableSpliceSourceWithNullSpliceTarget(spliceSource, extendDir) {
        if (TransientGraphUtility.IsSkippableSpliceSourceEdgeWithNullTarget(_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentEdge(spliceSource, extendDir))) {
            return true;
        }
        const spliceSourceEdge = _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_10__.StaticGraphUtility.FindAdjacentEdge(spliceSource, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(extendDir));
        // Since target is null, if this is a reflection, it is bouncing off an outer side of a group or
        // obstacle at spliceSource.  In that case, we don't want to splice from it because then we could
        // cut through the group and outside again; instead we should just stay outside it.
        return (TransientGraphUtility.IsSkippableSpliceSourceEdgeWithNullTarget(spliceSourceEdge) ||
            TransientGraphUtility.IsReflectionEdge(spliceSourceEdge));
    }
    static IsSkippableSpliceSourceEdgeWithNullTarget(spliceSourceEdge) {
        return (spliceSourceEdge != null &&
            spliceSourceEdge.IsPassable != null &&
            (0,_utils_compare__WEBPACK_IMPORTED_MODULE_2__.closeDistEps)(spliceSourceEdge.Length, _GroupBoundaryCrossing__WEBPACK_IMPORTED_MODULE_5__.GroupBoundaryCrossing.BoundaryWidth));
    }
    static IsReflectionEdge(edge) {
        return edge != null && edge.Weight === _ScanSegment__WEBPACK_IMPORTED_MODULE_8__.ScanSegment.ReflectionWeight;
    }
    static IsPointPastSegmentEnd(maxSegment, point) {
        return _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(maxSegment.start, maxSegment.end) === _PointComparer__WEBPACK_IMPORTED_MODULE_7__.PointComparer.GetDirections(maxSegment.end, point);
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0} {1}', this.AddedVertices.length, this.edgesToRestore.length);
    }
}
//# sourceMappingURL=TransientGraphUtility.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/VertexEntry.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VertexEntry: () => (/* binding */ VertexEntry)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");


class VertexEntry {
    // A class that records an entry from a specific direction for a vertex.
    // Vertex that this VertexEntry enters
    // The previous VertexEntry along this path; null for a path source
    // Length of the path up to this vertex
    // Number of bends in the path up to this vertex
    // Cost of the path up to this vertex
    constructor(vertex, prevEntry, length, numberOfBends, cost) {
        // Indicates whether we are allowing further entries into this vertex from this direction.
        this.IsClosed = false;
        this.Vertex = vertex;
        this.Direction = prevEntry != null ? _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(prevEntry.Vertex.point, vertex.point) : _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
        this.ResetEntry(prevEntry, length, numberOfBends, cost);
    }
    ResetEntry(prevEntry, length, numberOfBends, cost) {
        // A new prevEntry using the same previous vertex but a different entry to that vertex is valid here;
        // e.g. we could have prevEntry from S, which in turn had a prevEntry from E, replaced by prevEntry from
        // S which has a prevEntry from S.
        // #if (TEST_MSAGL)
        // if ((this.PreviousEntry != null)) {
        //    Assert.assert((this.PreviousEntry.Vertex === prevEntry.Vertex), "Inconsistent prevEntry vertex");
        //    Assert.assert((this.PreviousEntry.Direction !== prevEntry.Direction), "Duplicate prevEntry direction");
        //    Assert.assert((this.Direction === CompassVector.PureDirectionFromPointToPoint(this.PreviousEntry.Vertex.point, this.Vertex.point)), "Inconsistent entryDir");
        // }
        // #endif
        // // TEST_MSAGL
        this.PreviousEntry = prevEntry;
        this.Length = length;
        this.NumberOfBends = numberOfBends;
        this.Cost = cost;
    }
    // The vertex that this VertexEntry is entered from
    get PreviousVertex() {
        return this.PreviousEntry == null ? null : this.PreviousEntry.Vertex;
    }
    toString() {
        return this.Vertex.point + (' ' + (this.Direction + (' ' + (this.IsClosed + (' ' + this.Cost)))));
    }
}
//# sourceMappingURL=VertexEntry.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/VisibilityGraphGenerator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VisibilityGraphGenerator: () => (/* binding */ VisibilityGraphGenerator)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/BasicObstacleSide.js");
/* harmony import */ var _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/basicReflectionEvent.js");
/* harmony import */ var _EventQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/EventQueue.js");
/* harmony import */ var _GroupBoundaryCrossingMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/GroupBoundaryCrossingMap.js");
/* harmony import */ var _HighReflectionEvent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/HighReflectionEvent.js");
/* harmony import */ var _LookaheadScan__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/LookaheadScan.js");
/* harmony import */ var _MiscVertexEvents__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/MiscVertexEvents.js");
/* harmony import */ var _LowReflectionEvent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/LowReflectionEvent.js");
/* harmony import */ var _NeighborSides__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/NeighborSides.js");
/* harmony import */ var _obstacle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/obstacle.js");
/* harmony import */ var _ObstacleTree__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ObstacleTree.js");
/* harmony import */ var _OpenVertexEvent__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/OpenVertexEvent.js");
/* harmony import */ var _PointComparer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/PointComparer.js");
/* harmony import */ var _RectilinearScanLine__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/RectilinearScanLine.js");
/* harmony import */ var _ScanDirection__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanDirection.js");
/* harmony import */ var _ScanSegmentTree__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/ScanSegmentTree.js");
/* harmony import */ var _SpliceUtility__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/SpliceUtility.js");
/* harmony import */ var _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/StaticGraphUtility.js");
/* harmony import */ var _VisibilityVertexRectiline__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/VisibilityVertexRectiline.js");
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
// Scan direction is parallel to the sweepline which moves in the perpendicular direction;
// i.e. scan direction is "sideways" along the sweepline.  We also have lookahead scans
// that enqueue events along the scan-primary coordinate (in the direction of the scan, i.e.
// X for Hscan, Y for Vscan) to handle reflections from non-orthogonal obstacle sides,
// and lookback scans that have not had their reflections calculated because they reflect























// backward from the scanline and thus must be picked up on a subsequent perpendicular sweep.
class VisibilityGraphGenerator {
    constructor(wantReflections) {
        // This is the tree of rectangle nodes of the input obstacles' padded encompassing polylines.
        this.ObstacleTree = new _ObstacleTree__WEBPACK_IMPORTED_MODULE_13__.ObstacleTree();
        // This is a map of all group boundary crossings for the current scanline event being processed,
        // including the direction (along the scanline axis, horizontal or vertical) that a path crossing
        // that boundary takes toward the group's interior.  A point may be in here twice in the event of
        // groups sharing a boundary.
        this.CurrentGroupBoundaryCrossingMap = new _GroupBoundaryCrossingMap__WEBPACK_IMPORTED_MODULE_6__.GroupBoundaryCrossingMap();
        // For scanline traversal.
        this.LowNeighborSides = new _NeighborSides__WEBPACK_IMPORTED_MODULE_11__.NeighborSides();
        this.HighNeighborSides = new _NeighborSides__WEBPACK_IMPORTED_MODULE_11__.NeighborSides();
        this.ScanDirection = _ScanDirection__WEBPACK_IMPORTED_MODULE_17__.ScanDirection.HorizontalInstance;
        this.eventQueue = new _EventQueue__WEBPACK_IMPORTED_MODULE_5__.EventQueue();
        this.HorizontalScanSegments = new _ScanSegmentTree__WEBPACK_IMPORTED_MODULE_18__.ScanSegmentTree(_ScanDirection__WEBPACK_IMPORTED_MODULE_17__.ScanDirection.HorizontalInstance);
        this.VerticalScanSegments = new _ScanSegmentTree__WEBPACK_IMPORTED_MODULE_18__.ScanSegmentTree(_ScanDirection__WEBPACK_IMPORTED_MODULE_17__.ScanDirection.VerticalInstance);
        this.wantReflections = wantReflections;
    }
    get ParallelScanSegments() {
        return this.ScanDirection.IsHorizontal ? this.HorizontalScanSegments : this.VerticalScanSegments;
    }
    get PerpendicularScanSegments() {
        return this.ScanDirection.IsHorizontal ? this.VerticalScanSegments : this.HorizontalScanSegments;
    }
    static NewVisibilityGraph() {
        const ret = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_2__.VisibilityGraph();
        ret.VertexFactory = (point) => new _VisibilityVertexRectiline__WEBPACK_IMPORTED_MODULE_21__.VisibilityVertexRectilinear(point);
        return ret;
    }
    // Generate the visibility graph along which edges will be routed.
    GenerateVisibilityGraph() {
        // Generate the Polyline tree from the padded shapes.  ObstacleTree allows us to do
        // obstacle hit-testing for dynamic obstacles, as well as providing input for the Nudger.
        // Each PolylinePoint contains a reference to the Polyline of which it is a member.
        if (this.ObstacleTree.Root == null) {
            return;
        }
        // Now enqueue initial events for the vertical sweep (horizontal scan); start with the lowest
        // vertices and then we'll load subsequent vertices (and intersections) as we encounter them.
        // We'll defer the generation of vertex events in the perpendicular direction until we're done
        // with this sweep, to save memory; but we may enqueue intersection events in the perpendicular
        // direction during this sweep.
        this.InitializeEventQueue(_ScanDirection__WEBPACK_IMPORTED_MODULE_17__.ScanDirection.HorizontalInstance);
        // Create the sentinels and add them to the scanline.  Do NOT add them to the event queue
        // because we're not going to close them.  We're also effectively adding only the inner side
        // perpendicular to the scan, but we need the polyline for segment-subsumption tracking.
        // Creating with two points has the lines "clockwise" (and counterclockwise) as above.
        //
        // We don't need to store the sentinels as we retrieve them from [SweepEvent].Vertex.Polyline.
        // And we only need the low sentine's HighSide and the high sentinel's LowSide, but we use both
        // to save Obstacle from having to worry about the special case.  Note: reflection will
        // automatically not happen when hitting sentinels because their borders are IsPerpendicular.
        let scanlineSentinelOrdinal = _obstacle__WEBPACK_IMPORTED_MODULE_12__.Obstacle.FirstSentinelOrdinal;
        // Low sentinel...
        let lowerCorner = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.left - VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.bottom - VisibilityGraphGenerator.SentinelOffset);
        let upperCorner = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.left - VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.top + VisibilityGraphGenerator.SentinelOffset);
        let sentinel = _obstacle__WEBPACK_IMPORTED_MODULE_12__.Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);
        this.scanLine.Insert(sentinel.ActiveHighSide, this.ObstacleTree.GraphBox.leftBottom);
        // High sentinel...
        lowerCorner = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.right + VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.bottom - VisibilityGraphGenerator.SentinelOffset);
        upperCorner = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.right + VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.top + VisibilityGraphGenerator.SentinelOffset);
        sentinel = _obstacle__WEBPACK_IMPORTED_MODULE_12__.Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);
        this.scanLine.Insert(sentinel.ActiveLowSide, this.ObstacleTree.GraphBox.leftBottom);
        // Process the Hscan events.`
        //DevTraceInfoVgGen(1, "Processing Horizontal Scan events");
        this.ProcessEvents();
        // Now do the horizontal sweep (vertical scan).  Note: Because we use Cartesian coordinates
        // rather than Page coordinates, the High and Low sides reverse the direction they traverse
        // when doing vertical scan; this information is passed as a ctor param.  This allows for
        // consistent comparisons.
        this.InitializeEventQueue(_ScanDirection__WEBPACK_IMPORTED_MODULE_17__.ScanDirection.VerticalInstance);
        // Lower sentinel...
        lowerCorner = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.left - VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.bottom - VisibilityGraphGenerator.SentinelOffset);
        upperCorner = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.right + VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.bottom - VisibilityGraphGenerator.SentinelOffset);
        sentinel = _obstacle__WEBPACK_IMPORTED_MODULE_12__.Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal++);
        this.scanLine.Insert(sentinel.ActiveHighSide, this.ObstacleTree.GraphBox.leftBottom);
        // Upper sentinel
        lowerCorner = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.left - VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.top + VisibilityGraphGenerator.SentinelOffset);
        upperCorner = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(this.ObstacleTree.GraphBox.right + VisibilityGraphGenerator.SentinelOffset, this.ObstacleTree.GraphBox.top + VisibilityGraphGenerator.SentinelOffset);
        sentinel = _obstacle__WEBPACK_IMPORTED_MODULE_12__.Obstacle.CreateSentinel(lowerCorner, upperCorner, this.ScanDirection, scanlineSentinelOrdinal);
        this.scanLine.Insert(sentinel.ActiveLowSide, this.ObstacleTree.GraphBox.leftBottom);
        // Process the Vscan events.
        // DevTraceInfoVgGen(1, "Processing Vertical Scan events");
        this.ProcessEvents();
    }
    // // ReSharper disable InconsistentNaming
    // protected static Debug_AssertGraphIsRectilinear(graph: VisibilityGraph, this.ObstacleTree: this.ObstacleTree) {
    //    this.#if TEST_MSAGL
    //    if (graph.Edges.Any(edge => !PointComparer.IsPureDirection(PointComparer.GetDirections(edge.SourcePoint, edge.TargetPoint))))
    //    {
    //        StaticGraphUtility.Assert(false, "Generated VisibilityGraph contains non-rectilinear lines", this.ObstacleTree, graph);
    //        return;
    //    }
    //    this.#endif
    // }
    static ScanLineIntersectSidePBS(site, side, scanDir) {
        // Note: we don't assert that site and side are not PointComparer.Equal, because ScanLine calls
        // this on sides that share vertices.
        /*Assert.assert(
          !scanDir.IsFlatS(side),
          'flat sides should not be in the scanline or encountered on lookahead scan',
        )*/
        // We know that we will have an intersection if the side is adjacent in the scanline, so
        // we can optimize the calculation to project along the slope of the BasicObstacleSide.
        // Also, due to rounding, we need to make sure that when intersecting the side, we're not
        // falling short due to rounding error; that can be a problem if we're right at a vertex
        // of that obstacle, because then there is no intersection with the perpendicular line
        // from that vertex.  So make sure we are at least to the nearest coordinate of that side.
        // Note:  Calculate slope here using 'dir' rather than side.SlopeInverse because Reflection
        // lookaheads calculate the perpendicular intersection and side.Slope(Inverse) is always
        // relative to the scanline parallel.
        const dir = side.Direction;
        let ix = side.Start.x;
        let iy = side.Start.y;
        if (scanDir.IsHorizontal) {
            ix += (dir.x / dir.y) * (site.y - side.Start.y);
            ix = _SpliceUtility__WEBPACK_IMPORTED_MODULE_19__.SpliceUtility.MungeIntersect(site.x, ix, side.Start.x, side.End.x);
            iy = site.y;
        }
        else {
            ix = site.x;
            iy += (dir.y / dir.x) * (site.x - side.Start.x);
            iy = _SpliceUtility__WEBPACK_IMPORTED_MODULE_19__.SpliceUtility.MungeIntersect(site.y, iy, side.Start.y, side.End.y);
        }
        return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(ix, iy);
    }
    GetOpenVertex(poly) {
        let lowest = poly.startPoint;
        let next = this.TraversePolylineForEvents(lowest);
        // We want the bottom vertex to be the lowest in scanline-parallel coordinate if there is a
        // flat bottom side, and we've guaranteed that the lines are oriented clockwise.  This means
        // that we want a <= comparison of the current node vs. the candidate, to store the last
        // lowest vertex of the clockwise rotation.  Stop when we've turned upward from descending/flat.
        let iPrevCmp = this.PointCompare(next.point, lowest.point);
        for (;; next = this.TraversePolylineForEvents(next)) {
            const iCurCmp = this.PointCompare(next.point, lowest.point);
            if (iCurCmp <= 0) {
                lowest = next;
            }
            else if (iCurCmp > 0 && iPrevCmp <= 0) {
                break;
            }
            iPrevCmp = iCurCmp;
        }
        return lowest;
    }
    TraversePolylineForEvents(polyPoint) {
        // When loading scanline events, we'll go clockwise for horizontal scan, where the
        // scanline-parallel coordinate increases to the right, or counterclockwise for vertical
        // scan, where the scanline-parallel coordinate increases to the left.
        return this.ScanDirection.IsHorizontal ? polyPoint.nextOnPolyline : polyPoint.prevOnPolyline;
    }
    InitializeEventQueue(scanDir) {
        this.ScanDirection = scanDir;
        this.eventQueue.Reset(this.ScanDirection);
        this.EnqueueBottomVertexEvents();
        this.scanLine = new _RectilinearScanLine__WEBPACK_IMPORTED_MODULE_16__.RectilinearScanLine(this.ScanDirection, this.ObstacleTree.GraphBox.leftBottom);
        this.lookaheadScan = new _LookaheadScan__WEBPACK_IMPORTED_MODULE_8__.LookaheadScan(this.ScanDirection);
    }
    EnqueueBottomVertexEvents() {
        for (const obstacle of this.ObstacleTree.GetAllPrimaryObstacles()) {
            const bottomVertex = this.GetOpenVertex(obstacle.VisibilityPolyline);
            this.eventQueue.Enqueue(new _OpenVertexEvent__WEBPACK_IMPORTED_MODULE_14__.OpenVertexEvent(obstacle, bottomVertex));
        }
    }
    // end EnqueueBottomVertexEvents
    IsFlat(side) {
        return this.ScanDirection.IsFlatS(side);
    }
    IsPerpendicular(side) {
        // If it's perpendicular we won't generate reflections.
        return this.ScanDirection.IsPerpendicularS(side);
    }
    // Params are event site (vertex point) and the obstacle side adjacent to that site.
    ScanLineIntersectSide(site, side) {
        return VisibilityGraphGenerator.ScanLineIntersectSidePBS(site, side, this.ScanDirection);
    }
    SideReflectsUpward(side) {
        // Returns false if vertical.
        if (side instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__.LowObstacleSide) {
            // Low side slopes upward if slope is positive (to the high direction).
            return this.ScanDirection.Coord(side.End) > this.ScanDirection.Coord(side.Start);
        }
        // High side slopes upward if slope is negative (to the low direction).
        return this.ScanDirection.Coord(side.End) < this.ScanDirection.Coord(side.Start);
    }
    SideReflectsDownward(side) {
        // Returns false if vertical.
        if (side instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__.LowObstacleSide) {
            // Low side slopes downward if slope is negative (to the low direction).
            return this.ScanDirection.Coord(side.End) < this.ScanDirection.Coord(side.Start);
        }
        // High side slopes downward if slope is positive (to the high direction).
        return this.ScanDirection.Coord(side.End) > this.ScanDirection.Coord(side.Start);
    }
    // Calculate reflections from the lines, depending on line side (Low vs. High) and slope.
    // Because the low neighbor intersection is on a high side of its obstacle
    // and vice-versa, then the "side" of a lowNbor is a highSide, and vice versa.
    StoreLookaheadSite(initialObstacle, reflectingSide, reflectionSite, wantExtreme) {
        if (!this.wantReflections) {
            return;
        }
        // If the line is perpendicular, we won't generate reflections (they'd be redundant).
        if (!this.IsPerpendicular(reflectingSide)) {
            // If this is hitting an extreme vertex in the forward direction, we will (or already did) create a normal
            // ScanSegment in the perpendicular direction.
            if (!wantExtreme && !_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_20__.StaticGraphUtility.PointIsInRectangleInterior(reflectionSite, reflectingSide.Obstacle.VisibilityBoundingBox)) {
                return;
            }
            // We can only do upward reflections, which fortunately is all we need.
            if (this.SideReflectsUpward(reflectingSide)) {
                // We defer actually creating the perpendicular line until we've processed
                // the reflection event we're about to enqueue, so we may legitimately encounter
                // two (or more) reflections at the same point along the parallel-to-scanline
                // coordinate, if we have a side that is nearly but not quite perpendicular to
                // the scanline.  For example:
                //      \
                //       \----------------------------- line2
                //        \---------------------------- line1
                // Assume the vertical side is very close to perpendicular; then as we process
                // the horizontal lines in the upward direction, we may generate two lookahead
                // reflections at coordinates that are sufficiently far apart in the vertical
                // coordinate (in this example, Y) that the lines are not subsumed, but are
                // sufficiently close in the horizontal coordinate (in this example, X) that
                // the perpendicular lines would be subsumed. In that case, we look here to see
                // if there is an active lookahead scan for the reflecting site's parallel coordinate;
                // if so, then because we know that the side reflects upward, we also know that
                // the perpendicular line from the lowest segment's reflection site will intersect
                // the higher segments here, providing the VisibilityVertices we need, so we can
                // safely ignore the duplicate lookahead.
                // Don't worry about enqueueing a reflection at the extreme scanline-parallel
                // vertex because we'll MergeSegments to handle that.
                if (this.lookaheadScan.Find(reflectionSite) == null) {
                    this.lookaheadScan.Add(new _basicReflectionEvent__WEBPACK_IMPORTED_MODULE_4__.BasicReflectionEvent(initialObstacle, reflectingSide.Obstacle, reflectionSite));
                    //DevTraceInfoVgGen(1, "Storing reflection lookahead site {0}", reflectionSite);
                }
                else {
                    // DevTraceInfoVgGen(1, "Reflection lookahead site {0} already exists", reflectionSite);
                }
            }
        }
    }
    // Load any lookahead scan ray intersections with a side we've just added.
    LoadReflectionEvents(sideToQueue) {
        this.LoadReflectionEventsBB(sideToQueue, sideToQueue);
    }
    // sideWithRange is either the same as sideToQueue, if that side is being loaded by an
    // OpenVertexEvent, or is a different side that is just closing.
    LoadReflectionEventsBB(sideToQueue, sideWithRange) {
        // If this line reflects upward then it cannot receive rays from below (they would pass
        // through its obstacle), and of course a perpendicular lookahead line will never
        // intersect a perpendicular side.
        if (sideToQueue == null || this.SideReflectsUpward(sideToQueue) || this.IsPerpendicular(sideToQueue)) {
            return;
        }
        // If there is no overlap in the rectangles along the current axis, there is nothing
        // to do.  This reduces (but doesn't prevent) duplicate events being loaded.
        const bbox1 = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(sideToQueue.Start, sideToQueue.End);
        const bbox2 = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(sideWithRange.Start, sideWithRange.End);
        if (this.ScanDirection.IsHorizontal ? !bbox1.intersectsOnX(bbox2) : !bbox1.intersectsOnY(bbox2)) {
            return;
        }
        // Make sure we order the endpoints from low to high along the scanline parallel, and get only
        // the intersection.  RectilinearFileTests.Nudger_Overlap* exercise reflection lookahead subranges.
        const bboxIntersect = _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.intersect(bbox1, bbox2);
        const low = bboxIntersect.leftBottom;
        const high = bboxIntersect.rightTop;
        // This is inclusive of the endpoints of sideWithRange, to be sure that we remove the item
        // from LookaheadScan; if it's on an extreme vertex in the perpendicular sweep then it will
        // stop the chain; see TestRectilinear.Reflection_Staircase_Stops_At_BoundingBox_Side*.
        let lookaheadSiteNode = this.lookaheadScan.FindFirstInRange(low, high);
        while (lookaheadSiteNode != null) {
            // Calculate the lookahead intersection with this side in the perpendicular direction to
            // the scanline.  Note: due to rounding error, this may be different from the calculation
            // in the parallel direction when the scanline gets up to the ScanDirection.PerpCoord(intersect);
            // this will be adjusted in ScanSegmentTree.MergeSegments.
            const intersect = VisibilityGraphGenerator.ScanLineIntersectSidePBS(lookaheadSiteNode.item.Site, sideToQueue, this.ScanDirection.PerpendicularInstance);
            //DevTraceInfoVgGen(1, "Loading reflection from lookahead site {0} to intersect at {1}", lookaheadSiteNode.item.Site, intersect);
            // DevTraceInfoVgGen(2, "     side {0})", sideToQueue);
            // same indent as AddSegment
            // In some cases where the ActiveLowSide and ActiveHighSide of an obstacle lean in the same
            // direction such that LowSide is above HighSide, e.g. on the horizontal pass when they both
            // lean to the right, the delayed-lookahead in CloseVertex (obstacle close) event may find the
            // high side spanning the scanline-parallel coordinate range where its low side has enqueued
            // lookahead events.  In that case the intersection will be less than the enqueueing site so
            // ignore it.  See RectilinearTests.ReflectionsSitedByLowSideAreNotLoadedByHighSide.)
            // Similarly, if this is at the same perpendicular coordinate as the current scanline
            // position, ignore it; otherwise we could back up in the scanline's parallel coordinate.
            // Since we retrieved events for the endpoint of any previous side, this won't be
            // encountered on a bend vertex event; therefore we're on a near-flat bottom side
            // so we're parallel to the extreme-vertex line and it's fine to just absorb the photon.
            // This also handles the case of reflections into intersecting sides - at some point
            // they converge such that the intersection is not ahead of the lookahead site.
            if (this.ScanDirection.ComparePerpCoord(intersect, lookaheadSiteNode.item.Site) > 0) {
                // Add an event to continue the chain, "shifting" the site's reflecting
                // obstacle back to the initialObstacle position.  We must load this here
                // and process it in ConfirmLookaheadEvent so it will be removed from
                // the lookahead list; we can't remove it here if it doesn't satisfy the
                // staircase requirements, because this may be called from loading a "higher"
                // side (during the sweep) which could steal events from the lower side.
                this.AddReflectionEvent(lookaheadSiteNode.item, sideToQueue, intersect);
            }
            else if (lookaheadSiteNode.item.ReflectingObstacle !== sideToQueue.Obstacle) {
                //DevTraceInfoVgGen(1, "  (discarding reflection at intersect {0} as it is not ahead of the previous site)", intersect);
                // We need to remove the site.  We're in the middle of Node enumeration so just
                // mark the site and on function exit we'll remove any so marked.
                this.lookaheadScan.MarkStaleSite(lookaheadSiteNode.item);
            }
            else {
                // DevTraceInfoVgGen(1, "  (skipping reflection at intersect {0} as it is the same obstacle)", intersect);
            }
            // Get the next item, leaving the current one in the lookahead scan until
            // we actually process the event; this lets us know whether an intervening
            // obstacle may be opened and intercepted the reflection. ConfirmLookaheadEvents
            // will actually do the removal when the lowest side containing the lookahead
            // site is loaded.  See RectilinearTests.ReflectionsRemoveInterceptedSite.
            lookaheadSiteNode = this.lookaheadScan.FindNextInRange(lookaheadSiteNode, high);
        }
        // endwhile previousSiteNode
        this.lookaheadScan.RemoveStaleSites();
    }
    // Determine whether the event is valid and do some common processing.
    AddPerpendicularReflectionSegment(currentEvent, eventSide, nborSide) {
        // If eventSide is null it means we had the wrong side type as a scanline neighbor.
        // If another obstacle opened up, then that obstacle (or another intervening one) should have
        // drained this reflection event.
        /*Assert.assert(null !=  eventSide, 'eventSide should not be null')*/
        // Between the time currentEvent was queued and the time we're now processing it, another
        // obstacle may have opened between the previousSite and the eventSite, in which case it
        // removed currentEvent from the queue already.  So currentEvent may be stale.  The new
        // obstacle may have stored *another* lookahead site with the same scanline-parallel
        // coordinate (but higher up perpendicularly).  So remove the exact site of currentEvent;
        // otherwise the currentEvent could be a stale event with the lower scanline-parallel
        // coordinate, and would remove the site from the lookahead list before the "live" event
        // looks for it.  See RectilinearTests.ReflectionsRemoveInterceptedSite.
        if (this.lookaheadScan.RemoveExact(currentEvent.PreviousSite)) {
            /*Assert.assert(
              currentEvent.InitialObstacle ==
                currentEvent.PreviousSite.ReflectingObstacle,
              'Inconsistency: currentEvent.InitialObstacle !== currentEvent.PreviousSite.ReflectingObstacle',
            )*/
            // ReSharper disable HeuristicUnreachableCode
            // ReSharper disable ConditionIsAlwaysTrueOrFalse
            if (eventSide == null) {
                // We've removed the event so there's nothing else to do.
                return false;
            }
            // ReSharper restore ConditionIsAlwaysTrueOrFalse
            // ReSharper restore HeuristicUnreachableCode
            // If the two sides intersect ahead of the scanline, we don't want the reflection.
            // If the reflecting side is flat, no reflection is done - that's handled by OpenVertexEvent.
            /*Assert.assert(
              !this.IsFlat(eventSide),
              'Flat sides should not be encountered in reflections',
            )*/
            if (currentEvent.PreviousSite.IsStaircaseStep(currentEvent.ReflectingObstacle)) {
                // We need to draw the perpendicular lines here because we may be on the second
                // sweep so there won't be a subsequent sweep to draw them.  And if we're on the
                // second sweep, we may have already loaded this segment as part of a continuation
                // of an overlapped segment. Either way, we only want this if we are not on an extreme
                // edge of the target obstacle (reflectingObstacle for the perpendicular segment,
                // nborSide.Obstacle for the parallel segment).  Extreme vertices will generate segments.
                // See TestRectilinear.Reflection_Staircase_Stops_At_BoundingBox_Side*.
                if (!_StaticGraphUtility__WEBPACK_IMPORTED_MODULE_20__.StaticGraphUtility.PointIsInRectangleInterior(currentEvent.Site, currentEvent.ReflectingObstacle.VisibilityBoundingBox)) {
                    return false;
                }
                //DevTraceInfoVgGen(1, "Perpendicular Reflection - Adding Segment [{0} -> {1}]", currentEvent.PreviousSite.Site, currentEvent.Site);
                //DevTraceInfoVgGen(2, "  -> side {0}", eventSide);
                // same indent as AddSegment; eventSide is highNbor
                if (!this.InsertPerpendicularReflectionSegment(currentEvent.PreviousSite.Site, currentEvent.Site)) {
                    return false;
                }
                // If the neighbor continues the staircase and the parallel segment would hit a non-extreme point
                // on the neighbor, return true and the Low/HighReflectionEvent handler will add the parallel segment.
                if (nborSide != null && currentEvent.IsStaircaseStep(nborSide.Obstacle)) {
                    return this.ScanLineCrossesObstacle(currentEvent.Site, nborSide.Obstacle);
                }
                //DevTraceInfoVgGen(1, "Reflection Lookahead site {0} is not an outgoing staircase step; discontinuing", currentEvent.PreviousSite);
            }
            else {
                //DevTraceInfoVgGen(1, "Reflection Lookahead site {0} is not an incoming staircase step; discontinuing", currentEvent.PreviousSite);
            }
        }
        else {
            //DevTraceInfoVgGen(1, "Reflection Lookahead site {0} is no longer in the lookahead table; skipping", currentEvent.PreviousSite);
        }
        return false;
    }
    AddParallelReflectionSegment(eventObstacle, lowNborSide, highNborSide, action) {
        {
            // If this is reflecting to a low neighbor, then that intersect is 'start' in the low-to-high
            // sequence, and the event site is the end; otherwise we start at the event site and end at
            // the high neighbor.
            const intersect = this.ScanLineIntersectSide(action.Site, lowNborSide !== null && lowNborSide !== void 0 ? lowNborSide : highNborSide);
            const start = lowNborSide != null ? intersect : action.Site;
            const end = lowNborSide != null ? action.Site : intersect;
            // Now get the opposite neighbors so AddSegment can continue the reflection chain.
            if (lowNborSide == null) {
                lowNborSide = this.scanLine.NextLowB(highNborSide).item;
            }
            else {
                highNborSide = this.scanLine.NextHighB(lowNborSide).item;
            }
            return this.InsertParallelReflectionSegment(start, end, eventObstacle, lowNborSide, highNborSide, action);
        }
    }
    AddReflectionEvent(previousSite, side, site) {
        /*Assert.assert(
          null !=  this.scanLine.Find(side),
          "AddReflectionEvent could not find 'side' in the scanline",
        )*/
        // Add an event that will be drained when a side spanning the scanline-parallel is loaded
        // as the sweep moves "up".
        const lowSide = side;
        if (lowSide != null) {
            this.eventQueue.Enqueue(new _LowReflectionEvent__WEBPACK_IMPORTED_MODULE_10__.LowReflectionEvent(previousSite, lowSide, site));
        }
        else {
            this.eventQueue.Enqueue(new _HighReflectionEvent__WEBPACK_IMPORTED_MODULE_7__.HighReflectionEvent(previousSite, side, site));
        }
    }
    AddSideToScanLine(side, scanPos) {
        const node = this.scanLine.Insert(side, scanPos);
        // Now get any pending LookaheadScan intersections along this side.
        this.LoadReflectionEvents(side);
        return node;
    }
    RemoveSideFromScanLine(sideNode, scanPos) {
        this.scanLine.Remove(sideNode.item, scanPos);
    }
    PointCompare(lhs, rhs) {
        return this.ScanDirection.Compare(lhs, rhs);
    }
    Clear() {
        this.ObstacleTree.Clear();
        this.eventQueue = new _EventQueue__WEBPACK_IMPORTED_MODULE_5__.EventQueue();
        this.HorizontalScanSegments = new _ScanSegmentTree__WEBPACK_IMPORTED_MODULE_18__.ScanSegmentTree(_ScanDirection__WEBPACK_IMPORTED_MODULE_17__.ScanDirection.HorizontalInstance);
        this.VerticalScanSegments = new _ScanSegmentTree__WEBPACK_IMPORTED_MODULE_18__.ScanSegmentTree(_ScanDirection__WEBPACK_IMPORTED_MODULE_17__.ScanDirection.VerticalInstance);
        this.VisibilityGraph = null;
    }
    ProcessEvents() {
        // Note: Sentinel vertices are not in EventQueue so eventcount will go to 0.
        while (this.eventQueue.Count > 0) {
            const evt = this.eventQueue.Dequeue();
            if (evt instanceof _OpenVertexEvent__WEBPACK_IMPORTED_MODULE_14__.OpenVertexEvent) {
                this.ProcessEventO(evt);
            }
            else if (evt instanceof _MiscVertexEvents__WEBPACK_IMPORTED_MODULE_9__.LowBendVertexEvent) {
                this.ProcessEventLB(evt);
            }
            else if (evt instanceof _MiscVertexEvents__WEBPACK_IMPORTED_MODULE_9__.HighBendVertexEvent) {
                this.ProcessEventHB(evt);
            }
            else if (evt instanceof _MiscVertexEvents__WEBPACK_IMPORTED_MODULE_9__.CloseVertexEvent) {
                this.ProcessEventCV(evt);
            }
            else if (evt instanceof _LowReflectionEvent__WEBPACK_IMPORTED_MODULE_10__.LowReflectionEvent) {
                this.ProcessEventLR(evt);
            }
            else if (evt instanceof _HighReflectionEvent__WEBPACK_IMPORTED_MODULE_7__.HighReflectionEvent) {
                this.ProcessEventHR(evt);
            }
            else {
                this.ProcessCustomEvent(evt);
            }
            this.LowNeighborSides.Clear();
            this.HighNeighborSides.Clear();
        }
        // endwhile there are events
        // Ensure we have no leftovers in the scanline - we should have the two sentinels and nothing else.
        /*Assert.assert(
          2 === this.scanLine.Count,
          'There are leftovers in the scanline',
        )*/
    }
    ProcessCustomEvent(evt) {
        // These are events specific to the derived class; by default there are none.
        /*Assert.assert(false, 'Unknown event type ' + evt)*/
    }
    ScanLineCrossesObstacle(eventSite, obstacle) {
        // An inner or outer neighbor's side is only an overlap start/stop candidate if its obstacle
        // brackets the open/close event's Perpendicular Scan coord.
        return (this.ScanDirection.ComparePerpCoord(eventSite, obstacle.VisibilityBoundingBox.leftBottom) > 0 &&
            this.ScanDirection.ComparePerpCoord(eventSite, obstacle.VisibilityBoundingBox.rightTop) < 0);
    }
    FindInitialNeighborSides(sideNode, t) {
        t.lowNborSideNode = this.scanLine.NextLowR(sideNode);
        t.highNborSideNode = this.scanLine.NextHighR(sideNode);
    }
    // As described in the doc, we stop at the first neighbor of the appropriate side type that we touch
    // the border of, even if that's just skimming along the extreme vertex of it, because those will
    // continue the chain of open/close+addSegment, and we don't want to follow the full length of the
    // segment each time if there are a lot of collinear obstacle open/close events.
    FindNeighborsBRR(vertexEvent, lowSideNode, highSideNode) {
        this.LowNeighborSides.Clear();
        this.HighNeighborSides.Clear();
        // Find the first HighObstacleSide in the low (scanline-decreasing) direction (this may be the low
        // sentinel) and the lowest LowObstacleSide toward that that we cross *through*, if any.  Then do
        // the same thing in the high direction.  If we are not overlapped, then we'll jump out immediately
        // from SkipToNeighbor, so there won't be a lot of redundant effort in that case.
        this.FindNeighbors(vertexEvent, lowSideNode, this.LowNeighborSides);
        this.FindNeighbors(vertexEvent, highSideNode, this.HighNeighborSides);
    }
    FindNeighbors(vertexEvent, sideNode, neighborSides) {
        // vertexEvent.Site is on one of vertexEvent.Obstacle.Active(Low|High)Side, so we must get the
        // appropriate vertex on whichever one of those Active*Sides is sideNode.
        const sideReferencePoint = vertexEvent instanceof _OpenVertexEvent__WEBPACK_IMPORTED_MODULE_14__.OpenVertexEvent ? sideNode.item.Start : sideNode.item.End;
        const t = { lowNborSideNode: null, highNborSideNode: null };
        this.FindInitialNeighborSides(sideNode, t);
        this.SkipToNeighbor(this.ScanDirection.OppositeDirection, sideNode.item, sideReferencePoint, t.lowNborSideNode, neighborSides);
        this.SkipToNeighbor(this.ScanDirection.Dir, sideNode.item, sideReferencePoint, t.highNborSideNode, neighborSides);
    }
    SkipToNeighbor(nborSearchDir, side, sideReferencePoint, nborNode, neighborSides) {
        // Find the first neighbor side (LowObstacleSide if going high, HighObstacleSide if going low) and
        // the side of opposite type (which would potentially end overlap), that that we cross *through*, if any.
        let overlapSideNode = null;
        let interveningGroupSide = null;
        for (;; nborNode = this.scanLine.Next(nborSearchDir, nborNode)) {
            // Ignore the opposite side of the current obstacle.
            if (nborNode.item.Obstacle === side.Obstacle) {
                continue;
            }
            if (nborNode.item.Obstacle.IsGroup) {
                if (this.ProcessGroupSideEncounteredOnTraversalToNeighbor(nborNode, sideReferencePoint, nborSearchDir)) {
                    // Keep the first one (outermost) encountered.
                    if (interveningGroupSide == null) {
                        interveningGroupSide = nborNode.item;
                    }
                }
                continue;
            }
            // Check for overlap-ending obstacle.
            if (nborNode.item instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__.HighObstacleSide === _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_20__.StaticGraphUtility.IsAscending(nborSearchDir)) {
                if (this.ScanLineCrossesObstacle(sideReferencePoint, nborNode.item.Obstacle)) {
                    overlapSideNode = nborNode;
                    interveningGroupSide = null;
                }
                continue;
            }
            // If we're here, we found the neighbor we were looking for.
            break;
        }
        neighborSides.SetSides(nborSearchDir, nborNode, overlapSideNode, interveningGroupSide);
    }
    // end this.ProcessEvent(CloseVertexEvent)
    ProcessGroupSideEncounteredOnTraversalToNeighbor(nborNode, sideReferencePoint, nborSearchDir) {
        if (!this.ScanLineCrossesObstacle(sideReferencePoint, nborNode.item.Obstacle)) {
            return false;
        }
        // We don't stop overlap or neighbor-traversal for groups, because we must go through the boundary;
        // neither do we create overlapped edges (unless we're inside a non-group obstacle).  Instead we turn
        // the boundary crossing on or off based on group membership at ShortestPath-time.
        const dirToInsideOfGroup = nborNode.item instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__.LowObstacleSide === _StaticGraphUtility__WEBPACK_IMPORTED_MODULE_20__.StaticGraphUtility.IsAscending(nborSearchDir)
            ? nborSearchDir
            : _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_22__.CompassVector.OppositeDir(nborSearchDir);
        const intersect = this.ScanLineIntersectSide(sideReferencePoint, nborNode.item);
        this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect, nborNode.item.Obstacle, dirToInsideOfGroup);
        return true;
    }
    FindNeighborsAndProcessVertexEvent(lowSideNode, highSideNode, vertexEvent) {
        this.CurrentGroupBoundaryCrossingMap.Clear();
        this.FindNeighborsBRR(vertexEvent, lowSideNode, highSideNode);
        this.ProcessVertexEvent(lowSideNode, highSideNode, vertexEvent);
        // Clear this again because we don't want Reflections to access stale values.
        this.CurrentGroupBoundaryCrossingMap.Clear();
    }
    ProcessEventO(openVertEvent) {
        var _a, _b;
        // First insert the two new lines into the scanline.  Note: Although the lines are clockwise oriented,
        // LowObstacleSide and HighObstacleSide take a parameter to know when to go counterclockwise.
        const obstacle = openVertEvent.Obstacle;
        obstacle.CreateInitialSides(openVertEvent.Vertex, this.ScanDirection);
        /*Assert.assert(
          !this.IsFlat(obstacle.ActiveLowSide),
          'OpenVertexEvent ActiveLowSide should not be flat',
        )*/
        /*Assert.assert(
          !this.IsFlat(obstacle.ActiveHighSide),
          'RemoveCollinearSides should have been called',
        )*/
        //DevTraceIfFlatSide(true, obstacle.ActiveLowSide.Start, obstacle.ActiveHighSide.Start);
        // Adding can rotate the RBTree which modifies RBNodes so get the lowSideNode after adding highSideNode.
        // AddSideToScanLine loads any reflection events for the side.
        this.AddSideToScanLine(obstacle.ActiveLowSide, openVertEvent.Site);
        const highSideNode = this.AddSideToScanLine(obstacle.ActiveHighSide, openVertEvent.Site);
        const lowSideNode = this.scanLine.Find(obstacle.ActiveLowSide);
        // Get the neighbors.  In the simple, non-overlapped case, we'll generate a segment between them which
        // includes the vertex point (and any flat border of the current obstacle).  These neighbors will
        // never be null; one or both may be the fake sentinel borders at the graphBox limits.
        this.FindNeighborsAndProcessVertexEvent(lowSideNode, highSideNode, openVertEvent);
        // Look for Reflections.  If the ScanSegments we just added generated any
        // ReflectionEvents, then the Active*Side to that side may cover them, or if we're overlapped,
        // the Active*Side of the overlapping obstacle may if there is a non-overlapped segment extension.
        // Check the neighbors in both directions.
        const lowReflector = (_a = this.LowNeighborSides.GroupSideInterveningBeforeLowNeighbor) !== null && _a !== void 0 ? _a : this.LowNeighborSides.LowNeighborSide;
        if (this.SideReflectsUpward(lowReflector)) {
            this.LoadReflectionEvents(obstacle.ActiveLowSide);
        }
        const highReflector = (_b = this.HighNeighborSides.GroupSideInterveningBeforeHighNeighbor) !== null && _b !== void 0 ? _b : this.HighNeighborSides.HighNeighborSide;
        if (this.SideReflectsUpward(highReflector)) {
            this.LoadReflectionEvents(obstacle.ActiveHighSide);
        }
        // If this is a flat side it must absorb any outstanding reflection sites.
        if (obstacle.ActiveHighSide.Start !== obstacle.ActiveLowSide.Start) {
            // Create a temp HighObstacleSide so the "next vertex" moves in the correct direction.
            const tempSide = new _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__.HighObstacleSide(obstacle, openVertEvent.Vertex, this.ScanDirection);
            this.lookaheadScan.RemoveSitesForFlatBottom(tempSide.Start, tempSide.End);
        }
        // Add events for the low and high sides.
        this.EnqueueLowBendVertexEvent(obstacle.ActiveLowSide);
        this.EnqueueHighBendOrCloseVertexEvent(obstacle.ActiveHighSide);
    }
    // end this.ProcessEvent(OpenVertexEvent)
    ProcessEventLB(lowVertEvent) {
        // Note:  we only draw lines only from "interesting" vertices, which would be those
        // that open or close an obstacle, as well as staircase Reflections (see doc). This means
        // Low/HighVertexEvents routines will just track the change in ActiveLowSide/ActiveHighSide.
        // This is a vertex on the low side of the obstacle.  Update the ActiveLowSide in the obstacle
        // and scanline (this also checks for Reflection events).
        const obstacle = lowVertEvent.Obstacle;
        const lowSide = new _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__.LowObstacleSide(obstacle, lowVertEvent.Vertex, this.ScanDirection);
        // If the new lowSide is flat we don't remove it due to potential overlaps; that lets any collinear
        // OpenVertexEvents know they are overlapped (touching === overlap).  When we get to CloseVertexEvent,
        // keeping the current ActiveLowSide in the scanline tells us how when the interior sides stop
        // so we know when we've found a neighbor.  Similarly, if we're turning down toward the
        // scanline, we let CloseVertexEvent remove the side (in case there are coincident vertices).
        // That leaves the case of still ascending, where we replace the side in the scanline.
        if (this.ScanDirection.ComparePerpCoord(lowSide.End, lowSide.Start) > 0) {
            this.RemoveSideFromScanLine(this.scanLine.Find(obstacle.ActiveLowSide), lowVertEvent.Site);
            this.AddSideToScanLine(lowSide, lowVertEvent.Site);
            obstacle.ActiveLowSide = lowSide;
            this.EnqueueLowBendVertexEvent(lowSide);
        }
    }
    // end this.ProcessEvent(LowBendVertexEvent)
    EnqueueLowBendVertexEvent(lowSide) {
        // We've already ensured the extension is valid so just queue the next event.
        this.eventQueue.Enqueue(new _MiscVertexEvents__WEBPACK_IMPORTED_MODULE_9__.LowBendVertexEvent(lowSide.Obstacle, lowSide.EndVertex));
    }
    ProcessEventHB(highVertEvent) {
        // See comments in LowBendVertexEvent; this is mostly the same thing to the other side.
        const obstacle = highVertEvent.Obstacle;
        const highSide = new _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__.HighObstacleSide(obstacle, highVertEvent.Vertex, this.ScanDirection);
        this.RemoveSideFromScanLine(this.scanLine.Find(obstacle.ActiveHighSide), highVertEvent.Site);
        const highSideNode = this.AddSideToScanLine(highSide, highVertEvent.Site);
        obstacle.ActiveHighSide = highSide;
        this.EnqueueHighBendOrCloseVertexEvent(obstacle.ActiveHighSide);
        // If this is an extreme high-side lateral vertex on the horizontal pass turning to an upward-reflecting
        // side - i.e. if it is a vertex on the right-most border of the bounding box, and the new HighObstacleSide
        // has negative slope - then we may have a situation where a neighbor LowObstacleSide reflects downward and
        // spans this entire HighObstacleSide and a little more:
        //     #
        //       #
        //      .  #
        //       \   #
        //        .    #
        //               #
        // The ".\." side is completely spanned by the '#' side and because of the tilt directions, lookahead
        // will not happen, therefore reflections will not happen and there will be no scansegments between the
        // two sides.  This could lead to spurious overlaps.  So in this case we drop in an extra lookahead.
        // (This is not an issue for other tilt directions - there is always a reflection chain generated).
        // Test is RectilinearFileTests.Overlap_ExtremeSide_Lookahead.
        if (this.wantReflections &&
            this.ScanDirection.IsHorizontal &&
            highSide.Start.x === obstacle.VisibilityBoundingBox.right &&
            this.SideReflectsUpward(highSide)) {
            const nborSideNode = this.scanLine.NextHighR(highSideNode);
            if (nborSideNode.item instanceof _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_3__.LowObstacleSide && this.SideReflectsDownward(nborSideNode.item)) {
                if (!obstacle.isOverlapped || !this.ObstacleTree.PointIsInsideAnObstacle(highSide.Start, this.ScanDirection)) {
                    this.StoreLookaheadSite(nborSideNode.item.Obstacle, highSide, highSide.Start, true);
                    this.LoadReflectionEvents(nborSideNode.item);
                }
            }
        }
    }
    EnqueueHighBendOrCloseVertexEvent(highSide) {
        // If the next side segment after highSide is ascending from the scanline we want to queue another
        // HighBendVertexEvent; otherwise it is flat or turns down toward the scanline so queue a CloseVertexEvent.
        const obstacle = highSide.Obstacle;
        const nextHighSideEnd = this.ScanDirection.IsHorizontal
            ? highSide.EndVertex.prevOnPolyline
            : highSide.EndVertex.nextOnPolyline;
        if (this.ScanDirection.ComparePerpCoord(nextHighSideEnd.point, highSide.End) > 0) {
            this.eventQueue.Enqueue(new _MiscVertexEvents__WEBPACK_IMPORTED_MODULE_9__.HighBendVertexEvent(obstacle, highSide.EndVertex));
        }
        else {
            this.eventQueue.Enqueue(new _MiscVertexEvents__WEBPACK_IMPORTED_MODULE_9__.CloseVertexEvent(obstacle, highSide.EndVertex));
        }
    }
    // end this.ProcessEvent(HighBendVertexEvent)
    CreateCloseEventSegmentsAndFindNeighbors(closeVertEvent) {
        const obstacle = closeVertEvent.Obstacle;
        // DevTraceIfFlatSide(false, obstacle.ActiveLowSide.End, obstacle.ActiveHighSide.End);
        let lowSideNode = this.scanLine.Find(obstacle.ActiveLowSide);
        let highSideNode = this.scanLine.Find(obstacle.ActiveHighSide);
        // Two sides coming together at a top point will be reverse-ordered in the scanline,
        // because their projections ahead of the intersection are slope-based.  This must
        // be the case in order to maintain scanline consistency.  Therefore we need to
        // check the comparison and reverse the local variables if necessary.  Fortunately
        // we only concern ourselves with the actual Low-vs-High side type for neighbors,
        // not the sides of the obstacle.
        if (1 === this.scanLine.Compare(obstacle.ActiveLowSide, obstacle.ActiveHighSide)) {
            const temp = lowSideNode;
            lowSideNode = highSideNode;
            highSideNode = temp;
        }
        // As with OpenVertexEvent, the idea here is to find the neighbors and draw the line between them
        // that includes the event vertex (and any flat top obstacle side), with consideration for overlaps.
        this.FindNeighborsAndProcessVertexEvent(lowSideNode, highSideNode, closeVertEvent);
        // Inner overlaps: any overlapped sides coming out of the obstacle must have reflection events
        // drained for any that were generated from sides of the closing obstacle if they extend
        // outside the closing obstacle.
        if (this.wantReflections && obstacle.isOverlapped) {
            for (let nextNode = this.scanLine.NextHighR(lowSideNode); nextNode.item !== highSideNode.item; nextNode = this.scanLine.NextHighR(nextNode)) {
                this.LoadReflectionEvents(nextNode.item);
            }
        }
        // Remove the obstacle from the Scanline.  This comes after the foregoing which is why it's a
        // separate function; the RBTree modifies RBNodes, so doing the .Remove at the end of a separate
        // function ensures we won't access RBNodes that may no longer contain what we expect.
        this.scanLine.Remove(obstacle.ActiveLowSide, closeVertEvent.Site);
        this.scanLine.Remove(obstacle.ActiveHighSide, closeVertEvent.Site);
    }
    ProcessEventCV(closeVertEvent) {
        // This event closes the obstacle.  It removes the ActiveLowSide and ActiveHighSide from the scanline and does
        // not add new sides.  As above, see comments in OpenVertexEvent and its callees for more detailed explanations.
        this.CreateCloseEventSegmentsAndFindNeighbors(closeVertEvent);
        // For reflection, in addition to the delayed lookahead we do in the other *VertexEvents, we need to
        // detect pending reflections up to an already loaded obstacle side.  This may be transitive; using
        // H directions as an example:
        //  (A). Obstacles A and B lean rightward such that a vertical line can be drawn from the lower side
        //    of ObstacleA downward to the right of ObstacleB (missing it) and hitting Obstacle C.
        //  (B). ObstacleC's start point is above the start points of Obstacles A and B.
        //  (C). ObjectC reflects a Lookahead scan up along the line cited in (A).
        // To handle this, whenever we close an object, see if either nbor side spans lookahead scan points.
        // If so, then add the events.  Otherwise, we know that a new side for those nbor objects, or for
        // subsequent higher objects, will be created at some point (unless we run out of obstacles).
        // Since we do reflections only in staircase situations, these lookahead events will be discarded
        // (because the existing edge would have to have already been processed as an immediate neighbor,
        // in order to satisfy the definition of a staircase).  See RectilinearTests.ReflectionsDetectedByAlreadyLoadedSide.
        // Check the neighbors in both directions for reflection events.
        // When querying for lookahead sites for a nborSide, always test the full nborSide range if
        // the opposite nborSide reflects upward, because we will have generated a lookahead site for the
        // current eventObstacle on that upward-reflecting nborSide.  For example, restricting the
        // lowNborSide lookahead-site query to the currentEventObstacle.ActiveLowSide would pick up
        // any lookahead sites stored on eventObstacle.ActiveLowSide, but would not pick up a lookahead
        // site that the current CloseVertexEvent just stored on the highNborSide).
        // Fix: Updated this to remove restricted-range as it skips the range that includes the far side of the
        // current obstacle when called for neighbors that extend across the top vertex.
        const lowNborSide = this.LowNeighborSides.LowNeighbor.item;
        const highNborSide = this.HighNeighborSides.HighNeighbor.item;
        const obstacle = closeVertEvent.Obstacle;
        this.LoadReflectionEvents(lowNborSide);
        this.LoadReflectionEvents(highNborSide);
        // This prepares the object for the second (perpendicular) sweep.
        obstacle.Close();
    }
    ProcessEventLR(lowIntEvent) {
        // Unlike LowBendVertexEvent we don't update the ActiveLowSide in the obstacle and scanline.
        const obstacle = lowIntEvent.Side.Obstacle;
        // Add a perpendicular segment from the previous site to the lowNbor intersection, then from
        // the lowNbor intersection to the event site.
        const lowNborSide = this.scanLine.NextLowB(lowIntEvent.Side).item;
        if (this.AddPerpendicularReflectionSegment(lowIntEvent, lowIntEvent.Side, lowNborSide)) {
            if (this.AddParallelReflectionSegment(obstacle, lowNborSide, null, lowIntEvent)) {
                // We may have just added a reflection that reflects back onto obstacle.ActiveLowSide.
                this.LoadReflectionEvents(obstacle.ActiveLowSide);
            }
        }
    }
    // end this.ProcessEvent(LowReflectionEvent)
    ProcessEventHR(highIntEvent) {
        // Unlike HighBendVertexEvent we don't update the ActiveHighSide in the obstacle and scanline.
        const obstacle = highIntEvent.Side.Obstacle;
        // Add a perpendicular segment from the previous site to the highNbor intersection, then from
        // the highNbor intersection to the event site.
        const highNborSide = this.scanLine.NextHighB(highIntEvent.Side).item;
        if (this.AddPerpendicularReflectionSegment(highIntEvent, highIntEvent.Side, highNborSide)) {
            if (this.AddParallelReflectionSegment(obstacle, null, highNborSide, highIntEvent)) {
                // We may have just added a reflection that reflects back onto obstacle.ActiveHighSide.
                this.LoadReflectionEvents(obstacle.ActiveHighSide);
            }
        }
    }
    // end this.ProcessEvent(HighReflectionEvent)
    MakeInBoundsLocation(location) {
        const xPos = Math.max(location.x, this.ObstacleTree.GraphBox.left);
        const yPos = Math.max(location.y, this.ObstacleTree.GraphBox.bottom);
        return new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(Math.min(xPos, this.ObstacleTree.GraphBox.right), Math.min(yPos, this.ObstacleTree.GraphBox.top));
    }
    IsInBoundsV(vertex) {
        return this.IsInBoundsP(vertex.point);
    }
    IsInBoundsP(p) {
        return _PointComparer__WEBPACK_IMPORTED_MODULE_15__.PointComparer.EqualPP(p, this.MakeInBoundsLocation(p));
    }
}
// This ensures that sentinels lie outside the graph boundaries, to ensure the scanline orders
// orders the sentinels properly.  Its borders are not drawn; instead the borders of objects
// already contain padding and this is assumed to be sufficient to provide space for routing.
/* const */ VisibilityGraphGenerator.SentinelOffset = 1;
//# sourceMappingURL=VisibilityGraphGenerator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/VisibilityVertexRectiline.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VisibilityVertexRectilinear: () => (/* binding */ VisibilityVertexRectilinear)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _visibility_VisibilityVertex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityVertex.js");


class VisibilityVertexRectilinear extends _visibility_VisibilityVertex__WEBPACK_IMPORTED_MODULE_1__.VisibilityVertex {
    constructor(point) {
        super(point);
    }
    SetVertexEntry(entry) {
        if (this.VertexEntries == null) {
            this.VertexEntries = new Array(4);
        }
        this.VertexEntries[_math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.ToIndex(entry.Direction)] = entry;
    }
    RemoveVertexEntries() {
        this.VertexEntries = null;
    }
}
//# sourceMappingURL=VisibilityVertexRectiline.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/basicReflectionEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicReflectionEvent: () => (/* binding */ BasicReflectionEvent)
/* harmony export */ });
/* harmony import */ var _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");

class BasicReflectionEvent extends _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    // Called by StoreLookaheadSite only.
    constructor(initialObstacle, reflectingObstacle, site) {
        super();
        this.InitialObstacle = initialObstacle;
        this.ReflectingObstacle = reflectingObstacle;
        this.site = site;
    }
    // Called by LowReflectionEvent or HighReflectionEvent ctors, which are called out of
    // AddReflectionEvent, which in turn is called by LoadLookaheadIntersections.
    // In this case we know the eventObstacle and initialObstacle are the same obstacle (the
    // one that the reflected ray bounced off of, to generate the Left/HighReflectionEvent).
    static mk(previousSite, reflectingObstacle, site) {
        const ret = new BasicReflectionEvent(previousSite.ReflectingObstacle, reflectingObstacle, site);
        ret.PreviousSite = previousSite;
        return ret;
    }
    // If true, we have a staircase situation.
    IsStaircaseStep(reflectionTarget) {
        return this.InitialObstacle === reflectionTarget;
    }
    get Site() {
        return this.site;
    }
}
//# sourceMappingURL=basicReflectionEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisEdge: () => (/* binding */ AxisEdge)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _visibility_VisibilityEdge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityEdge.js");
// a wrapper arownd VisibilityEdge representing the same edge


// but oriented along the X or the Y axis
class AxisEdge extends _visibility_VisibilityEdge__WEBPACK_IMPORTED_MODULE_1__.VisibilityEdge {
    constructor(source, target) {
        super(source, target);
        this.RightNeighbors = new Set();
        this.setOfLongestSegs = new Set();
        this.RightBound = Number.POSITIVE_INFINITY;
        this.LeftBound = Number.NEGATIVE_INFINITY;
        this.Direction = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(source.point, target.point);
        /*Assert.assert(
          this.Direction === Direction.East || this.Direction === Direction.North,
        )*/
    }
    AddRightNeighbor(edge) {
        this.RightNeighbors.add(edge);
    }
    get LongestNudgedSegments() {
        return this.setOfLongestSegs;
    }
    AddLongestNudgedSegment(segment) {
        this.setOfLongestSegs.add(segment);
    }
    BoundFromRight(rightbound) {
        rightbound = Math.max(rightbound, this.LeftBound);
        this.RightBound = Math.min(rightbound, this.RightBound);
    }
    BoundFromLeft(leftbound) {
        leftbound = Math.min(leftbound, this.RightBound);
        this.LeftBound = Math.max(leftbound, this.LeftBound);
    }
}
//# sourceMappingURL=AxisEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgeHighPointEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisEdgeHighPointEvent: () => (/* binding */ AxisEdgeHighPointEvent)
/* harmony export */ });
/* harmony import */ var _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");

class AxisEdgeHighPointEvent extends _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    constructor(edge, point) {
        super();
        this.site = point;
        this.AxisEdge = edge;
    }
    get Site() {
        return this.site;
    }
}
//# sourceMappingURL=AxisEdgeHighPointEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgeLowPointEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisEdgeLowPointEvent: () => (/* binding */ AxisEdgeLowPointEvent)
/* harmony export */ });
/* harmony import */ var _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");

class AxisEdgeLowPointEvent extends _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    constructor(edge, point) {
        super();
        this.site = point;
        this.AxisEdge = edge;
    }
    get Site() {
        return this.site;
    }
}
//# sourceMappingURL=AxisEdgeLowPointEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgesContainer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisEdgesContainer: () => (/* binding */ AxisEdgesContainer)
/* harmony export */ });
class AxisEdgesContainer {
    get Edges() {
        return this.edges;
    }
    AddEdge(edge) {
        this.UpPoint = edge.TargetPoint;
        /*Assert.assert(!this.edges.has(edge))*/
        this.edges.add(edge);
    }
    constructor(source) {
        this.edges = new Set();
        this.Source = source;
    }
    RemoveAxis(edge) {
        /*Assert.assert(this.edges.has(edge))*/
        this.edges.delete(edge);
    }
    IsEmpty() {
        return this.edges.size === 0;
    }
}
//# sourceMappingURL=AxisEdgesContainer.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/CombinatorialNudger.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CombinatorialNudger: () => (/* binding */ CombinatorialNudger)
/* harmony export */ });
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _AxisEdge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdge.js");
/* harmony import */ var _LinkedPoint__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPoint.js");
/* harmony import */ var _PathEdge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathEdge.js");
// sets the order of connector paths on the edges
//








class CombinatorialNudger {
    get PathVisibilityGraph() {
        return this.pathVisibilityGraph;
    }
    constructor(paths) {
        // A new visibility graph is needed; the DAG of AxisEdges.
        this.pathVisibilityGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraph();
        this.axisEdgesToPathOrders = new Map();
        this.OriginalPaths = paths;
    }
    GetOrder() {
        this.FillTheVisibilityGraphByWalkingThePaths();
        this.InitPathOrder();
        this.OrderPaths();
        return this.axisEdgesToPathOrders;
    }
    FillTheVisibilityGraphByWalkingThePaths() {
        for (const path of this.OriginalPaths) {
            this.FillTheVisibilityGraphByWalkingPath(path);
        }
    }
    FillTheVisibilityGraphByWalkingPath(path) {
        const pathEdgesEnum = this.CreatePathEdgesFromPoints(it(), path.Width);
        let t = pathEdgesEnum.next();
        if (!t.done) {
            path.SetFirstEdge(t.value);
        }
        while ((t = pathEdgesEnum.next()).done === false) {
            path.AddEdge(t.value);
        }
        function* it() {
            if (path.PathPoints instanceof _LinkedPoint__WEBPACK_IMPORTED_MODULE_6__.LinkedPoint) {
                for (let p = path.PathPoints; p != null; p = p.Next) {
                    yield p.Point;
                }
            }
            else {
                for (const p of path.PathPoints)
                    yield p;
            }
        }
    }
    *CreatePathEdgesFromPoints(pathPoints, width) {
        let t = pathPoints.next();
        let p0 = t.value;
        while (!(t = pathPoints.next()).done) {
            yield this.CreatePathEdge(p0, t.value, width);
            p0 = t.value;
        }
    }
    CreatePathEdge(p0, p1, width) {
        const dir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector.DirectionFromPointToPoint(p0, p1);
        switch (dir) {
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__.Direction.East:
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__.Direction.North:
                return new _PathEdge__WEBPACK_IMPORTED_MODULE_7__.PathEdge(this.GetAxisEdge(p0, p1), width);
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__.Direction.South:
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__.Direction.West: {
                const e = new _PathEdge__WEBPACK_IMPORTED_MODULE_7__.PathEdge(this.GetAxisEdge(p1, p0), width);
                e.Reversed = true;
                return e;
            }
            default:
                throw new Error('Not a rectilinear path');
        }
    }
    GetAxisEdge(p0, p1) {
        return this.PathVisibilityGraph.AddEdgeF(p0, p1, (m, n) => new _AxisEdge__WEBPACK_IMPORTED_MODULE_5__.AxisEdge(m, n));
    }
    InitPathOrder() {
        for (const axisEdge of this.PathVisibilityGraph.Edges) {
            this.axisEdgesToPathOrders.set(axisEdge, new Array());
        }
        for (const p of this.OriginalPaths) {
            for (const pathEdge of p.PathEdges()) {
                this.axisEdgesToPathOrders.get(pathEdge.AxisEdge).push(pathEdge);
            }
        }
    }
    OrderPaths() {
        for (const axisEdge of CombinatorialNudger.WalkGraphEdgesInTopologicalOrderIfPossible(this.PathVisibilityGraph)) {
            this.OrderPathEdgesSharingEdge(axisEdge);
        }
    }
    OrderPathEdgesSharingEdge(edge) {
        const pathOrder = this.PathOrderOfVisEdge(edge);
        pathOrder.sort(CombinatorialNudger.CompareTwoPathEdges);
        let i = 0;
        // fill the index
        for (const pathEdge of pathOrder) {
            pathEdge.Index = i++;
        }
    }
    static CompareTwoPathEdges(x, y) {
        if (x === y) {
            return 0;
        }
        /*Assert.assert(x.AxisEdge === y.AxisEdge)*/
        // Nudger.ShowOrderedPaths(null, new[] { x.Path, y.Path }, x.AxisEdge.SourcePoint, x.AxisEdge.TargetPoint);
        const r = CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(x, y, x.AxisEdge, x.AxisEdge.Direction);
        return r !== 0
            ? r
            : -CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(x, y, x.AxisEdge, _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(x.AxisEdge.Direction));
    }
    //
    // axisEdge together with the axisEdgeIsReversed parameter define direction of the movement over the paths
    static CompareInDirectionStartingFromAxisEdge(x, y, axisEdge, direction) {
        while (true) {
            x = CombinatorialNudger.GetNextPathEdgeInDirection(x, axisEdge, direction);
            if (x == null) {
                return 0;
            }
            y = CombinatorialNudger.GetNextPathEdgeInDirection(y, axisEdge, direction);
            if (y == null) {
                return 0;
            }
            if (x.AxisEdge === y.AxisEdge) {
                direction = CombinatorialNudger.FindContinuedDirection(axisEdge, direction, x.AxisEdge);
                axisEdge = x.AxisEdge;
                const r = CombinatorialNudger.GetExistingOrder(x, y);
                if (r === CombinatorialNudger.NotOrdered) {
                    continue;
                }
                return direction === axisEdge.Direction ? r : -r;
            }
            // there is a fork
            const forkVertex = direction === axisEdge.Direction ? axisEdge.Target : axisEdge.Source;
            const xFork = CombinatorialNudger.OtherVertex(x.AxisEdge, forkVertex);
            const yFork = CombinatorialNudger.OtherVertex(y.AxisEdge, forkVertex);
            const projection = CombinatorialNudger.ProjectionForCompare(axisEdge, direction !== axisEdge.Direction);
            return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.compareNumbers)(projection(xFork.point), projection(yFork.point));
        }
    }
    static FindContinuedDirection(edge, direction, nextAxisEdge) {
        if (edge.Direction === direction)
            return nextAxisEdge.Source === edge.Target ? nextAxisEdge.Direction : _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(nextAxisEdge.Direction);
        return nextAxisEdge.Source === edge.Source ? nextAxisEdge.Direction : _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(nextAxisEdge.Direction);
    }
    static OtherVertex(axisEdge, v) {
        return axisEdge.Source === v ? axisEdge.Target : axisEdge.Source;
    }
    static ProjectionForCompare(axisEdge, isReversed) {
        return axisEdge.Direction === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__.Direction.North
            ? isReversed
                ? (p) => -p.x
                : (p) => p.x
            : isReversed
                ? (p) => p.y
                : (p) => -p.y;
    }
    static GetNextPathEdgeInDirection(e, axisEdge, direction) {
        /*Assert.assert(e.AxisEdge === axisEdge)*/
        return axisEdge.Direction === direction ? (e.Reversed ? e.Prev : e.Next) : e.Reversed ? e.Next : e.Prev;
    }
    static GetExistingOrder(x, y) {
        const xi = x.Index;
        if (xi === -1) {
            return CombinatorialNudger.NotOrdered;
        }
        const yi = y.Index;
        /*Assert.assert(yi !== -1)*/
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.compareNumbers)(xi, yi);
    }
    PathOrderOfVisEdge(axisEdge) {
        return this.axisEdgesToPathOrders.get(axisEdge);
    }
    static InitQueueOfSources(queue, dictionary, graph) {
        for (const v of graph.Vertices()) {
            const inDegree = v.InEdgesLength();
            dictionary.set(v, inDegree);
            if (inDegree === 0) {
                queue.enqueue(v);
            }
        }
        /*Assert.assert(queue.length > 0)*/
    }
    static *WalkGraphEdgesInTopologicalOrderIfPossible(visibilityGraph) {
        // Here the visibility graph is always a DAG since the edges point only to North and East
        // where possible
        const sourcesQueue = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
        const inDegreeLeftUnprocessed = new Map();
        CombinatorialNudger.InitQueueOfSources(sourcesQueue, inDegreeLeftUnprocessed, visibilityGraph);
        while (sourcesQueue.length > 0) {
            const visVertex = sourcesQueue.dequeue();
            for (const edge of visVertex.OutEdges) {
                const incomingEdges = inDegreeLeftUnprocessed.get(edge.Target);
                inDegreeLeftUnprocessed.set(edge.Target, incomingEdges - 1);
                if (incomingEdges === 1) {
                    sourcesQueue.enqueue(edge.Target);
                }
                yield edge;
            }
        }
    }
}
CombinatorialNudger.NotOrdered = Number.MAX_VALUE;
//# sourceMappingURL=CombinatorialNudger.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/FreeSpaceFinder.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreeSpaceFinder: () => (/* binding */ FreeSpaceFinder)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _spline_coneSpanner_LeftObstacleSide__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftObstacleSide.js");
/* harmony import */ var _spline_coneSpanner_LeftVertexEvent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftVertexEvent.js");
/* harmony import */ var _spline_coneSpanner_RightObstacleSide__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightObstacleSide.js");
/* harmony import */ var _spline_coneSpanner_RightVertexEvent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightVertexEvent.js");
/* harmony import */ var _spline_coneSpanner_VertexEvent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/VertexEvent.js");
/* harmony import */ var _visibility_LineSweeperBase__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/LineSweeperBase.js");
/* harmony import */ var _AxisEdgeHighPointEvent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgeHighPointEvent.js");
/* harmony import */ var _AxisEdgeLowPointEvent__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgeLowPointEvent.js");
/* harmony import */ var _AxisEdgesContainer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/AxisEdgesContainer.js");
/* harmony import */ var _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/debugCurve.js");
// The class is looking for the free space around AxisEdges


//import{ {DebugCurve} from '../../../math/geometry/}DebugCurve'














class FreeSpaceFinder extends _visibility_LineSweeperBase__WEBPACK_IMPORTED_MODULE_11__.LineSweeperBase {
    //
    // edges to find the empty space around
    constructor(direction, obstacles, axisEdgesToObstaclesTheyOriginatedFrom, pathOrders, axisEdges) {
        super(obstacles, new _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector(direction).ToPoint());
        this.DirectionPerp = new _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector(direction).Right.ToPoint();
        this.PathOrders = pathOrders;
        this.xProjection = direction === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__.Direction.North ? (p) => p.x : (p) => -p.y;
        this.edgeContainersTree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_4__.RBTree((a, b) => this.CompareAA(a, b));
        this.SweepPole = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector.VectorDirection(this.SweepDirection);
        /*Assert.assert(CompassVector.IsPureDirection(this.SweepPole))*/
        this.AxisEdges = axisEdges;
        this.AxisEdgesToObstaclesTheyOriginatedFrom = axisEdgesToObstaclesTheyOriginatedFrom;
    }
    //   Array<Path> EdgePaths { get; set; }
    // VisibilityGraph PathVisibilityGraph { get; set; }
    // calculates the right offsets
    FindFreeSpace() {
        this.InitTheQueueOfEvents();
        this.ProcessEvents();
        //    ShowAxisEdges();
    }
    ProcessEvents() {
        while (this.EventQueue.Count > 0) {
            this.ProcessEvent(this.EventQueue.Dequeue());
        }
    }
    ProcessEvent(sweepEvent) {
        if (sweepEvent instanceof _spline_coneSpanner_VertexEvent__WEBPACK_IMPORTED_MODULE_10__.VertexEvent) {
            this.ProcessVertexEvent(sweepEvent);
        }
        else {
            this.Z = this.GetZP(sweepEvent.Site);
            if (sweepEvent instanceof _AxisEdgeLowPointEvent__WEBPACK_IMPORTED_MODULE_13__.AxisEdgeLowPointEvent) {
                this.ProcessLowEdgeEvent(sweepEvent);
            }
            else {
                /*Assert.assert(sweepEvent instanceof AxisEdgeHighPointEvent)*/
                this.ProcessHighEdgeEvent(sweepEvent);
            }
        }
    }
    ProcessHighEdgeEvent(edgeForNudgingHighPointEvent) {
        const edge = edgeForNudgingHighPointEvent.AxisEdge;
        this.RemoveEdge(edge);
        this.ConstraintEdgeWithObstaclesAtZ(edge, edge.Target.point);
    }
    ProcessLowEdgeEvent(lowEdgeEvent) {
        const edge = lowEdgeEvent.AxisEdge;
        const containerNode = this.GetOrCreateAxisEdgesContainer(edge);
        containerNode.item.AddEdge(edge);
        const prev = this.edgeContainersTree.previous(containerNode);
        if (prev != null) {
            for (const prevEdge of prev.item.edges) {
                for (const ed of containerNode.item.edges) {
                    this.TryToAddRightNeighbor(prevEdge, ed);
                }
            }
        }
        const next = this.edgeContainersTree.next(containerNode);
        if (next != null) {
            for (const ed of containerNode.item.Edges) {
                for (const neEdge of next.item.edges) {
                    this.TryToAddRightNeighbor(ed, neEdge);
                }
            }
        }
        this.ConstraintEdgeWithObstaclesAtZ(edge, edge.Source.point);
    }
    TryToAddRightNeighbor(leftEdge, rightEdge) {
        if (this.ProjectionsOfEdgesOverlap(leftEdge, rightEdge)) {
            leftEdge.AddRightNeighbor(rightEdge);
        }
    }
    ProjectionsOfEdgesOverlap(leftEdge, rightEdge) {
        return this.SweepPole === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_2__.Direction.North
            ? !(leftEdge.TargetPoint.y < rightEdge.SourcePoint.y - _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon ||
                rightEdge.TargetPoint.y < leftEdge.SourcePoint.y - _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon)
            : !(leftEdge.TargetPoint.x < rightEdge.SourcePoint.x - _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon ||
                rightEdge.TargetPoint.x < leftEdge.SourcePoint.x - _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon);
    }
    // DebShowEdge(edge: AxisEdge, point: Point) {
    //    //  ReSharper restore UnusedMember.Local
    //    //  if (InterestingEdge(edge))
    //    this.ShowEdge(edge, point);
    // }
    // // ReSharper disable SuggestBaseTypeForParameter
    // ShowEdge(edge: AxisEdge, point: Point) {
    //    //  ReSharper restore SuggestBaseTypeForParameter
    //    let dd = this.GetObstacleBoundaries("black");
    //    let seg = new DebugCurve(1, "red", new LineSegment(edge.Source.point, edge.Target.point));
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd.Concat(new, [));
    //    seg;
    //    new DebugCurve("blue", CurveFactory.CreateEllipse(3, 3, point));
    // }
    GetObstacleBoundaries(color) {
        return this.Obstacles.map((p) => _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_15__.DebugCurve.mkDebugCurveWCI(1, color, p));
    }
    //
    // a point on the edge on Z level
    ConstraintEdgeWithObstaclesAtZ(edge, point) {
        /*Assert.assert(point === edge.Source.point || point === edge.Target.point)*/
        this.ConstraintEdgeWithObstaclesAtZFromLeft(edge, point);
        this.ConstraintEdgeWithObstaclesAtZFromRight(edge, point);
    }
    ConstraintEdgeWithObstaclesAtZFromRight(edge, point) {
        const node = this.GetActiveSideFromRight(point);
        if (node == null) {
            return;
        }
        if (this.NotRestricting(edge, node.item.Polyline)) {
            return;
        }
        const x = this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(node.item);
        edge.BoundFromRight(x.dot(this.DirectionPerp));
    }
    GetActiveSideFromRight(point) {
        return this.LeftObstacleSideTree.findFirst((side) => FreeSpaceFinder.PointToTheLeftOfLineOrOnLineLocal(point, side.Start, side.End));
    }
    ConstraintEdgeWithObstaclesAtZFromLeft(edge, point) {
        //    ShowNudgedSegAndPoint(point, nudgedSegment);
        const node = this.GetActiveSideFromLeft(point);
        if (node == null) {
            return;
        }
        if (this.NotRestricting(edge, node.item.Polyline)) {
            return;
        }
        const x = this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(node.item);
        edge.BoundFromLeft(x.dot(this.DirectionPerp));
    }
    static PointToTheLeftOfLineOrOnLineLocal(a, linePoint0, linePoint1) {
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(a, linePoint0, linePoint1) > -FreeSpaceFinder.AreaComparisonEpsilon;
    }
    static PointToTheRightOfLineOrOnLineLocal(a, linePoint0, linePoint1) {
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(linePoint0, linePoint1, a) < FreeSpaceFinder.AreaComparisonEpsilon;
    }
    GetActiveSideFromLeft(point) {
        return this.RightObstacleSideTree.findLast((side) => FreeSpaceFinder.PointToTheRightOfLineOrOnLineLocal(point, side.Start, side.End));
    }
    // ReSharper disable UnusedMember.Local
    // ShowPointAndEdge(point: Point, edge: AxisEdge) {
    //    //  ReSharper restore UnusedMember.Local
    //    let curves: Array<ICurve> = this.GetCurves(point, edge);
    //    LayoutAlgorithmSettings.Show(curves.ToArray());
    // }
    // // ReSharper disable UnusedMember.Local
    // ShowPointAndEdgeWithSweepline(point: Point, edge: AxisEdge) {
    //    //  ReSharper restore UnusedMember.Local
    //    let curves: Array<ICurve> = this.GetCurves(point, edge);
    //    curves.Add(new LineSegment(((this.SweepDirection * this.Z) + (10 * this.DirectionPerp)), ((this.SweepDirection * this.Z) - (10 * this.DirectionPerp))));
    //    LayoutAlgorithmSettings.Show(curves.ToArray());
    // }
    // GetCurves(point: Point, edge: AxisEdge): Array<ICurve> {
    //    let ellipse = CurveFactory.CreateEllipse(3, 3, point);
    //    let curves = new Array<ICurve>(this.Obstacles.select(() => {  }, (<ICurve>(o))));
    //    if ((edge.RightBound < Number.POSITIVE_INFINITY)) {
    //        let rightOffset: number = edge.RightBound;
    //        let del = (this.DirectionPerp * rightOffset);
    //        curves.Add(new LineSegment((edge.Source.point + del), (edge.Target.point + del)));
    //    }
    //    if ((edge.LeftBound > Number.NEGATIVE_INFINITY)) {
    //        let leftOffset: number = edge.LeftBound;
    //        let del = (this.DirectionPerp * leftOffset);
    //        curves.Add(new LineSegment((edge.Source.point + del), (edge.Target.point + del)));
    //    }
    //    curves.AddRange(from, e, in, this.PathOrders.keys, let, a=e.SourcePoint, let, b=e.TargetPoint, select, new CubicBezierSegment(a, ((a * 0.8)
    //                        + (b * 0.2)), ((a * 0.2)
    //                        + (b * 0.8)), b)).Cast();
    //    return curves;
    // }
    // GetCurvesTest(point: Point): Array<DebugCurve> {
    //    let ellipse = CurveFactory.CreateEllipse(3, 3, point);
    //    let curves = new Array<DebugCurve>(this.Obstacles.select(() => {  }, new DebugCurve(100, 1, "black", o)));
    //    curves.AddRange(from, e, in, this.edgeContainersTree, from, axisEdge, in, e, let, a=axisEdge.Source.Point, let, b=axisEdge.Target.Point, select, new DebugCurve(100, 1, "green", new LineSegment(a, b)));
    //    curves.AddRange(FreeSpaceFinder.RightNeighborsCurvesTest(this.edgeContainersTree));
    //    return curves;
    // }
    // static RightNeighborsCurvesTest(rbTree: Array<AxisEdgesContainer>): Array<DebugCurve> {
    //    for (let container of rbTree) {
    //        for (let edge of container) {
    //            for (let rn of edge.RightNeighbors) {
    //                yield;
    //                return new DebugCurve(100, 1, "brown", new LineSegment(FreeSpaceFinder.EdgeMidPoint(edge), FreeSpaceFinder.EdgeMidPoint(rn)));
    //            }
    //        }
    //    }
    // }
    static EdgeMidPoint(edge) {
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.middle(edge.SourcePoint, edge.TargetPoint);
    }
    // ShowAxisEdges() {
    //    //  ReSharper restore UnusedMember.Local
    //    let dd = new Array<DebugCurve>(this.GetObstacleBoundaries("black"));
    //    let i: number = 0;
    //    for (let axisEdge of this.AxisEdges) {
    //        let color = DebugCurve.colors[i];
    //        dd.Add(new DebugCurve(200, 1, color, new LineSegment(axisEdge.Source.point, axisEdge.Target.point)));
    //        let perp: Point = new Point(0, 1);
    //        // TODO: Warning!!!, inline IF is not supported ?
    //        (axisEdge.Direction === Direction.East);
    //        new Point(-1, 0);
    //        if ((axisEdge.LeftBound !== Number.NEGATIVE_INFINITY)) {
    //            dd.Add(new DebugCurve(200, 0.5, color, new LineSegment((axisEdge.Source.point
    //                                    + (axisEdge.LeftBound * perp)), (axisEdge.Target.point
    //                                    + (axisEdge.LeftBound * perp)))));
    //        }
    //        if ((axisEdge.RightBound !== Number.POSITIVE_INFINITY)) {
    //            dd.Add(new DebugCurve(200, 0.5, color, new LineSegment((axisEdge.Source.point
    //                                    - (axisEdge.RightBound * perp)), (axisEdge.Target.point
    //                                    - (axisEdge.RightBound * perp)))));
    //        }
    //        i = ((i + 1)
    //                    % DebugCurve.colors.length);
    //    }
    //    DebugCurveCollection.WriteToFile(dd, "c:/tmp/ae");
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
    // }
    // // ReSharper disable UnusedMember.Local
    // ShowAtPoint(point: Point) {
    //    //  ReSharper restore UnusedMember.Local
    //    let curves = this.GetCurvesTest(point);
    //    LayoutAlgorithmSettings.ShowDebugCurves(curves.ToArray());
    // }
    GetOrCreateAxisEdgesContainer(edge) {
        const source = edge.Source.point;
        const ret = this.GetAxisEdgesContainerNode(source);
        if (ret != null) {
            return ret;
        }
        return this.edgeContainersTree.insert(new _AxisEdgesContainer__WEBPACK_IMPORTED_MODULE_14__.AxisEdgesContainer(source));
    }
    //
    // the point has to be on the same line as the container
    GetAxisEdgesContainerNode(point) {
        const prj = this.xProjection(point);
        const ret = this.edgeContainersTree.findFirst((cont) => this.xProjection(cont.Source) >= prj - _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon / 2);
        if (ret != null) {
            if (this.xProjection(ret.item.Source) <= prj + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon / 2) {
                return ret;
            }
        }
        return null;
    }
    ProcessVertexEvent(vertexEvent) {
        this.Z = this.GetZS(vertexEvent);
        if (vertexEvent instanceof _spline_coneSpanner_LeftVertexEvent__WEBPACK_IMPORTED_MODULE_7__.LeftVertexEvent) {
            this.ProcessLeftVertex(vertexEvent, vertexEvent.Vertex.nextOnPolyline);
        }
        else {
            if (vertexEvent instanceof _spline_coneSpanner_RightVertexEvent__WEBPACK_IMPORTED_MODULE_9__.RightVertexEvent) {
                this.ProcessRightVertex(vertexEvent, vertexEvent.Vertex.prevOnPolyline);
            }
            else {
                this.ProcessLeftVertex(vertexEvent, vertexEvent.Vertex.nextOnPolyline);
                this.ProcessRightVertex(vertexEvent, vertexEvent.Vertex.prevOnPolyline);
            }
        }
    }
    ProcessRightVertex(rightVertexEvent, nextVertex) {
        /*Assert.assert(this.Z === rightVertexEvent.Site.dot(this.SweepDirection))*/
        const site = rightVertexEvent.Site;
        this.ProcessPrevSegmentForRightVertex(rightVertexEvent, site);
        const delta = nextVertex.point.sub(rightVertexEvent.Site);
        const deltaX = delta.dot(this.DirectionPerp);
        const deltaZ = delta.dot(this.SweepDirection);
        if (deltaZ <= _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
            if (deltaX > 0 && deltaZ >= 0) {
                this.EnqueueEvent(new _spline_coneSpanner_RightVertexEvent__WEBPACK_IMPORTED_MODULE_9__.RightVertexEvent(nextVertex));
            }
            else {
                this.RestrictEdgeContainerToTheRightOfEvent(rightVertexEvent.Vertex);
            }
        }
        else {
            // deltaZ>epsilon
            this.InsertRightSide(new _spline_coneSpanner_RightObstacleSide__WEBPACK_IMPORTED_MODULE_8__.RightObstacleSide(rightVertexEvent.Vertex));
            this.EnqueueEvent(new _spline_coneSpanner_RightVertexEvent__WEBPACK_IMPORTED_MODULE_9__.RightVertexEvent(nextVertex));
            this.RestrictEdgeContainerToTheRightOfEvent(rightVertexEvent.Vertex);
        }
    }
    RestrictEdgeContainerToTheRightOfEvent(polylinePoint) {
        const site = polylinePoint.point;
        const siteX = this.xProjection(site);
        const containerNode = this.edgeContainersTree.findFirst((container) => siteX <= this.xProjection(container.Source));
        if (containerNode != null) {
            for (const edge of containerNode.item.Edges) {
                if (!this.NotRestricting(edge, polylinePoint.polyline)) {
                    edge.BoundFromLeft(this.DirectionPerp.dot(site));
                }
            }
        }
    }
    NotRestricting(edge, polyline) {
        const p = this.AxisEdgesToObstaclesTheyOriginatedFrom.get(edge);
        return p === polyline;
    }
    ProcessPrevSegmentForRightVertex(rightVertexEvent, site) {
        const prevSite = rightVertexEvent.Vertex.nextOnPolyline.point;
        const delta = site.sub(prevSite);
        const deltaZ = delta.dot(this.SweepDirection);
        if (deltaZ > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
            this.RemoveRightSide(new _spline_coneSpanner_RightObstacleSide__WEBPACK_IMPORTED_MODULE_8__.RightObstacleSide(rightVertexEvent.Vertex.nextOnPolyline));
        }
    }
    RemoveEdge(edge) {
        const containerNode = this.GetAxisEdgesContainerNode(edge.Source.point);
        containerNode.item.RemoveAxis(edge);
        if (containerNode.item.IsEmpty()) {
            this.edgeContainersTree.deleteNodeInternal(containerNode);
        }
    }
    ProcessLeftVertex(leftVertexEvent, nextVertex) {
        /*Assert.assert(this.Z === leftVertexEvent.Site.dot(this.SweepDirection))*/
        const site = leftVertexEvent.Site;
        this.ProcessPrevSegmentForLeftVertex(leftVertexEvent, site);
        const delta = nextVertex.point.sub(leftVertexEvent.Site);
        const deltaX = delta.dot(this.DirectionPerp);
        const deltaZ = delta.dot(this.SweepDirection);
        if (deltaZ <= _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
            if (deltaX < 0 && deltaZ >= 0) {
                this.EnqueueEvent(new _spline_coneSpanner_LeftVertexEvent__WEBPACK_IMPORTED_MODULE_7__.LeftVertexEvent(nextVertex));
            }
        }
        else {
            // deltaZ>epsilon
            this.InsertLeftSide(new _spline_coneSpanner_LeftObstacleSide__WEBPACK_IMPORTED_MODULE_6__.LeftObstacleSide(leftVertexEvent.Vertex));
            this.EnqueueEvent(new _spline_coneSpanner_LeftVertexEvent__WEBPACK_IMPORTED_MODULE_7__.LeftVertexEvent(nextVertex));
        }
        // ShowAtPoint(leftVertexEvent.Site);
        this.RestrictEdgeFromTheLeftOfEvent(leftVertexEvent.Vertex);
    }
    RestrictEdgeFromTheLeftOfEvent(polylinePoint) {
        // ShowAtPoint(site);
        const site = polylinePoint.point;
        const containerNode = this.GetContainerNodeToTheLeftOfEvent(site);
        if (containerNode != null) {
            for (const edge of containerNode.item.Edges) {
                if (!this.NotRestricting(edge, polylinePoint.polyline)) {
                    edge.BoundFromRight(site.dot(this.DirectionPerp));
                }
            }
        }
    }
    GetContainerNodeToTheLeftOfEvent(site) {
        const siteX = this.xProjection(site);
        return this.edgeContainersTree.findLast((container) => this.xProjection(container.Source) <= siteX);
        //                Point.PointToTheRightOfLineOrOnLine(site, container.Source,
        //                                                                                                container.UpPoint));
    }
    ProcessPrevSegmentForLeftVertex(leftVertexEvent, site) {
        const prevSite = leftVertexEvent.Vertex.prevOnPolyline.point;
        const delta = site.sub(prevSite);
        const deltaZ = delta.dot(this.SweepDirection);
        if (deltaZ > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.distanceEpsilon) {
            this.RemoveLeftSide(new _spline_coneSpanner_LeftObstacleSide__WEBPACK_IMPORTED_MODULE_6__.LeftObstacleSide(leftVertexEvent.Vertex.prevOnPolyline));
        }
    }
    InitTheQueueOfEvents() {
        this.InitQueueOfEvents();
        for (const axisEdge of this.AxisEdges) {
            this.EnqueueEventsForEdge(axisEdge);
        }
    }
    EnqueueEventsForEdge(edge) {
        if (this.EdgeIsParallelToSweepDir(edge)) {
            this.EnqueueEvent(FreeSpaceFinder.EdgeLowPointEvent(edge, edge.Source.point));
            this.EnqueueEvent(FreeSpaceFinder.EdgeHighPointEvent(edge, edge.Target.point));
        }
    }
    EdgeIsParallelToSweepDir(edge) {
        return edge.Direction === this.SweepPole || edge.Direction === _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_1__.CompassVector.OppositeDir(this.SweepPole);
    }
    static EdgeHighPointEvent(edge, point) {
        return new _AxisEdgeHighPointEvent__WEBPACK_IMPORTED_MODULE_12__.AxisEdgeHighPointEvent(edge, point);
    }
    static EdgeLowPointEvent(edge, point) {
        return new _AxisEdgeLowPointEvent__WEBPACK_IMPORTED_MODULE_13__.AxisEdgeLowPointEvent(edge, point);
    }
    CompareAA(x, y) {
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_5__.compareNumbers)(x.Source.dot(this.DirectionPerp), y.Source.dot(this.DirectionPerp));
    }
}
FreeSpaceFinder.AreaComparisonEpsilon = _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_3__.GeomConstants.intersectionEpsilon;
//# sourceMappingURL=FreeSpaceFinder.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPoint.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinkedPoint: () => (/* binding */ LinkedPoint)
/* harmony export */ });
// import {CompassVector} from '../../../math/geometry/compassVector'
// represents a segment of a path
class LinkedPoint {
    constructor(point) {
        this.Point = point;
    }
    *GetEnumerator() {
        let p;
        for (p = this; p != null; p = p.Next) {
            yield p.Point;
        }
    }
    get X() {
        return this.Point.x;
    }
    get Y() {
        return this.Point.y;
    }
    InsertVerts(i, j, points) {
        for (j--; i < j; j--) {
            this.SetNewNext(points[j]);
        }
    }
    InsertVertsInReverse(i, j, points) {
        for (i++; i < j; i++) {
            this.SetNewNext(points[i]);
        }
    }
    SetNewNext(p) {
        const nv = new LinkedPoint(p);
        const tmp = this.Next;
        this.Next = nv;
        nv.Next = tmp;
        /*Assert.assert(CompassVector.IsPureDirectionPP(this.Point, this.Next.Point))*/
    }
}
//# sourceMappingURL=LinkedPoint.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPointSplitter.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinkedPointSplitter: () => (/* binding */ LinkedPointSplitter)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js");
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
// intersects a set of horizontal LinkedPoints with a set of vertical LinkedPoints





class LinkedPointSplitter {
    //
    // no two horizontal segs overlap, but they can share an end point
    // no two vertical segs overlap, but they can share an end point
    constructor(horizontalPoints, verticalPoints) {
        this.tree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_3__.RBTree((a, b) => (0,_utils_compare__WEBPACK_IMPORTED_MODULE_4__.compareNumbers)(a.Point.x, b.Point.x));
        this.VerticalPoints = verticalPoints;
        this.HorizontalPoints = horizontalPoints;
    }
    SplitPoints() {
        if (this.VerticalPoints.length === 0 || this.HorizontalPoints.length === 0) {
            return;
        }
        // there will be no intersections
        this.InitEventQueue();
        this.ProcessEvents();
    }
    ProcessEvents() {
        while (!this.Queue.IsEmpty()) {
            const t = { priority: 0 };
            const linkedPoint = this.Queue.DequeueAndGetPriority(t);
            this.ProcessEvent(linkedPoint, t.priority);
        }
    }
    ProcessEvent(linkedPoint, z) {
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_4__.closeDistEps)(linkedPoint.Next.Point.x, linkedPoint.Point.x)) {
            if (z === LinkedPointSplitter.Low(linkedPoint)) {
                this.ProcessLowLinkedPointEvent(linkedPoint);
            }
            else {
                this.ProcessHighLinkedPointEvent(linkedPoint);
            }
        }
        else {
            this.IntersectWithTree(linkedPoint);
        }
    }
    IntersectWithTree(horizontalPoint) {
        let right;
        let left;
        let xAligned;
        /*Assert.assert(closeDistEps(horizontalPoint.Y, horizontalPoint.Next.Y))*/
        const y = horizontalPoint.Y;
        if (horizontalPoint.Point.x < horizontalPoint.Next.Point.x) {
            left = horizontalPoint.Point.x;
            right = horizontalPoint.Next.Point.x;
            xAligned = true;
        }
        else {
            right = horizontalPoint.Point.x;
            left = horizontalPoint.Next.Point.x;
            xAligned = false;
        }
        if (xAligned) {
            for (let node = this.tree.findFirst((p) => left <= p.Point.x); node != null && node.item.Point.x <= right; node = this.tree.next(node)) {
                const p = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(node.item.Point.x, y);
                horizontalPoint = LinkedPointSplitter.TrySplitHorizontalPoint(horizontalPoint, p, true);
                LinkedPointSplitter.TrySplitVerticalPoint(node.item, p);
            }
        }
        else {
            for (let node = this.tree.findLast((p) => p.Point.x <= right); node != null && node.item.Point.x >= left; node = this.tree.previous(node)) {
                const p = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(node.item.Point.x, y);
                horizontalPoint = LinkedPointSplitter.TrySplitHorizontalPoint(horizontalPoint, p, false);
                LinkedPointSplitter.TrySplitVerticalPoint(node.item, p);
            }
        }
    }
    static TrySplitVerticalPoint(linkedPoint, point) {
        /*Assert.assert(closeDistEps(linkedPoint.X, linkedPoint.Next.X))*/
        if (LinkedPointSplitter.Low(linkedPoint) + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon < point.y &&
            point.y + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon < LinkedPointSplitter.High(linkedPoint)) {
            linkedPoint.SetNewNext(point);
        }
    }
    static TrySplitHorizontalPoint(horizontalPoint, point, xAligned) {
        /*Assert.assert(closeDistEps(horizontalPoint.Y, horizontalPoint.Next.Y))*/
        if ((xAligned &&
            horizontalPoint.X + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon < point.x &&
            point.x + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon < horizontalPoint.Next.X) ||
            (!xAligned &&
                horizontalPoint.Next.X + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon < point.x &&
                point.x + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon < horizontalPoint.X)) {
            horizontalPoint.SetNewNext(point);
            return horizontalPoint.Next;
        }
        return horizontalPoint;
    }
    ProcessHighLinkedPointEvent(linkedPoint) {
        this.tree.remove(linkedPoint);
    }
    ProcessLowLinkedPointEvent(linkedPoint) {
        this.tree.insert(linkedPoint);
    }
    InitEventQueue() {
        this.Queue = new _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_2__.GenericBinaryHeapPriorityQueue(_utils_compare__WEBPACK_IMPORTED_MODULE_4__.compareNumbers);
        for (const vertPoint of this.VerticalPoints) {
            this.Queue.Enqueue(vertPoint, LinkedPointSplitter.Low(vertPoint));
        }
        // a horizontal point will appear of the queue after a vertical point
        // with the same coordinate low coorinate
        for (const horizPoint of this.HorizontalPoints) {
            this.Queue.Enqueue(horizPoint, horizPoint.Point.y);
        }
    }
    static Low(vertPoint) {
        return Math.min(vertPoint.Point.y, vertPoint.Next.Point.y);
    }
    static High(vertPoint) {
        return Math.max(vertPoint.Point.y, vertPoint.Next.Point.y);
    }
}
//# sourceMappingURL=LinkedPointSplitter.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LongestNudgedSegment.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LongestNudgedSegment: () => (/* binding */ LongestNudgedSegment)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _visibility_SegmentBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/SegmentBase.js");



// Represent a maximal straight segment of a path
class LongestNudgedSegment extends _visibility_SegmentBase__WEBPACK_IMPORTED_MODULE_2__.SegmentBase {
    constructor(variable) {
        super();
        // has to be North or East
        this.CompassDirection = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.None;
        // the segment can go only North or East independently of the edge directions
        this.edges = new Array();
        this._isFixed = false;
        this.Id = -1;
        this.IdealPosition = 0;
        this.Id = variable;
    }
    get Start() {
        return this.start;
    }
    get End() {
        return this.end;
    }
    // the list of edges holding the same offset and direction
    get Edges() {
        return this.edges;
    }
    AddEdge(edge) {
        if (this.Edges.length === 0) {
            let dir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.VectorDirectionPP(edge.Source, edge.Target);
            switch (dir) {
                case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.South:
                    dir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North;
                    break;
                case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.West:
                    dir = _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East;
                    break;
            }
            this.CompassDirection = dir;
            this.start = edge.Source;
            this.end = edge.Source;
            // does not matter; it will be fixed immediately
        }
        switch (this.CompassDirection) {
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North:
                this.TryPointForStartAndEndNorth(edge.Source);
                this.TryPointForStartAndEndNorth(edge.Target);
                break;
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East:
                this.TryPointForStartAndEndEast(edge.Source);
                this.TryPointForStartAndEndEast(edge.Target);
                break;
        }
        this.Edges.push(edge);
    }
    TryPointForStartAndEndNorth(p) {
        if (p.y < this.start.y) {
            this.start = p;
        }
        else if (p.y > this.end.y) {
            this.end = p;
        }
    }
    TryPointForStartAndEndEast(p) {
        if (p.x < this.start.x) {
            this.start = p;
        }
        else if (p.x > this.end.x) {
            this.end = p;
        }
    }
    // the segments constraining "this" from the right
    get IsFixed() {
        return this._isFixed;
    }
    set IsFixed(value) {
        this._isFixed = value;
    }
    // the maximal width of the edges
    get Width() {
        let w = 0;
        for (const e of this.edges) {
            w = Math.max(w, e.Width);
        }
        return w;
    }
    GetLeftBound() {
        if (!this.IsFixed) {
            let lb = Number.NEGATIVE_INFINITY;
            for (const edge of this.edges) {
                lb = Math.max(lb, edge.AxisEdge.LeftBound);
            }
            return lb;
        }
        return this.CompassDirection === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North ? this.Edges[0].Source.x : -this.Edges[0].Source.y;
    }
    GetRightBound() {
        if (!this.IsFixed) {
            let rb = Number.POSITIVE_INFINITY;
            for (const edge of this.edges) {
                rb = Math.min(rb, edge.AxisEdge.RightBound);
            }
            return rb;
        }
        return this.Position();
    }
    Position() {
        return this.CompassDirection === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North ? this.Edges[0].Source.x : -this.Edges[0].Source.y;
    }
}
//# sourceMappingURL=LongestNudgedSegment.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/Nudger.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nudger: () => (/* binding */ Nudger)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _math_projectionSolver_UniformOneDimensionalSolver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/projectionSolver/UniformOneDimensionalSolver.js");
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/curve.js");
/* harmony import */ var _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/debugCurve.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _CombinatorialNudger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/CombinatorialNudger.js");
/* harmony import */ var _FreeSpaceFinder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/FreeSpaceFinder.js");
/* harmony import */ var _LongestNudgedSegment__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LongestNudgedSegment.js");
/* harmony import */ var _PathRefiner__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathRefiner.js");
/* harmony import */ var _StaircaseRemover__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/StaircaseRemover.js");
/* harmony import */ var _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/hitTestBehavior.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");


















// following paper "Orthogonal Connector Routing"
class Nudger {
    get HasGroups() {
        return null != this.HierarchyOfGroups && this.HierarchyOfGroups.Count > 0;
    }
    //  "nudges" paths to decrease the number of intersections and stores the results inside WidePaths of "paths"
    // paths through the graph
    // two parallel paths should be separated by this distance if it is feasible
    // polygonal convex obstacles organized  of a tree; the obstacles here are padded original obstacles
    //
    constructor(paths, cornerFitRad, obstacles, ancestorsSets) {
        this.AncestorsSets = ancestorsSets;
        this.HierarchyOfGroups = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_17__.CreateRectNodeOnArrayOfRectNodes)(Array.from(ancestorsSets.keys())
            .filter((shape) => shape.IsGroup)
            .map((group) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_17__.mkRectangleNode)(group, group.BoundingBox)));
        this.Obstacles = obstacles;
        this.EdgeSeparation = 2 * cornerFitRad;
        this.Paths = paths;
        this.HierarchyOfObstacles = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_17__.CreateRectNodeOnArrayOfRectNodes)(obstacles.map((p) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_17__.mkRectangleNode)(p, p.boundingBox)));
        this.MapPathsToTheirObstacles();
    }
    MapPathsToTheirObstacles() {
        this.PathToObstacles = new Map();
        for (const path of this.Paths) {
            this.MapPathToItsObstacles(path);
        }
    }
    MapPathToItsObstacles(path) {
        if (!path.PathPoints || path.PathPoints.length === 0)
            return;
        const fr = path.PathPoints;
        const startNode = this.HierarchyOfObstacles.FirstHitNodeWithPredicate(fr[0], Nudger.ObstacleTest);
        const endNode = this.HierarchyOfObstacles.FirstHitNodeWithPredicate(fr[fr.length - 1], Nudger.ObstacleTest);
        if (null != startNode && null != endNode) {
            this.PathToObstacles.set(path, [startNode.UserData, endNode.UserData]);
        }
    }
    static ObstacleTest(pnt, polyline) {
        return _math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__.Curve.PointRelativeToCurveLocation(pnt, polyline) !== _math_geometry_curve__WEBPACK_IMPORTED_MODULE_4__.PointLocation.Outside ? _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_16__.HitTestBehavior.Stop : _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_16__.HitTestBehavior.Continue;
    }
    Calculate(direction, mergePaths) {
        this.NudgingDirection = direction;
        _PathRefiner__WEBPACK_IMPORTED_MODULE_14__.PathRefiner.RefinePaths(this.Paths, mergePaths);
        this.GetPathOrdersAndPathGraph();
        this.MapAxisEdgesToTheirObstacles();
        this.DrawPaths();
    }
    MapAxisEdgesToTheirObstacles() {
        this.axisEdgesToObstaclesTheyOriginatedFrom = new Map();
        for (const path of this.Paths) {
            this.MapPathEndAxisEdgesToTheirObstacles(path);
        }
        // The assignment above was too greedy. An edge belonging to interiour edges of some path can be marked by mistake.
        for (const path of this.Paths) {
            this.UmmapPathInteriourFromStrangerObstacles(path);
        }
    }
    UmmapPathInteriourFromStrangerObstacles(path) {
        const firstUnmappedEdge = this.FindFirstUnmappedEdge(path);
        if (firstUnmappedEdge == null) {
            return;
        }
        const lastUnmappedEdge = this.FindLastUnmappedEdge(path);
        for (let edge = firstUnmappedEdge; edge != null && edge !== lastUnmappedEdge; edge = edge.Next) {
            this.axisEdgesToObstaclesTheyOriginatedFrom.delete(edge.AxisEdge);
        }
    }
    FindLastUnmappedEdge(path) {
        for (let edge = path.LastEdge; edge != null; edge = edge.Prev) {
            if (edge.AxisEdge.Direction !== this.NudgingDirection) {
                return edge;
            }
        }
        return null;
    }
    FindFirstUnmappedEdge(path) {
        for (let edge = path.FirstEdge; edge != null; edge = edge.Next) {
            if (edge.AxisEdge.Direction !== this.NudgingDirection) {
                return edge;
            }
        }
        return null;
    }
    MapPathEndAxisEdgesToTheirObstacles(path) {
        const coupleOfObstacles = this.PathToObstacles.get(path);
        if (coupleOfObstacles) {
            this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(path, coupleOfObstacles[0]);
            this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(path, coupleOfObstacles[1]);
        }
    }
    ProcessThePathEndToMapAxisEdgesToTheirObstacles(path, endPolyline) {
        for (let edge = path.LastEdge; edge != null && _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__.CompassVector.DirectionsAreParallel(edge.Direction, this.NudgingDirection); edge = edge.Prev) {
            this.axisEdgesToObstaclesTheyOriginatedFrom.set(edge.AxisEdge, endPolyline);
        }
    }
    ProcessThePathStartToMapAxisEdgesToTheirObstacles(path, startPolyline) {
        for (let edge = path.FirstEdge; edge != null && _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__.CompassVector.DirectionsAreParallel(edge.Direction, this.NudgingDirection); edge = edge.Next) {
            this.axisEdgesToObstaclesTheyOriginatedFrom.set(edge.AxisEdge, startPolyline);
        }
        // possible bug here because an edge might ignore two obstacles if it connects them
    }
    GetPathOrdersAndPathGraph() {
        const combinatorialNudger = new _CombinatorialNudger__WEBPACK_IMPORTED_MODULE_11__.CombinatorialNudger(this.Paths);
        this.PathOrders = combinatorialNudger.GetOrder();
        this.PathVisibilityGraph = combinatorialNudger.PathVisibilityGraph;
    }
    static GetCurvesForShow(paths, obstacles) {
        const ret = new Array();
        for (const path of paths) {
            const poly = new _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_9__.Polyline();
            for (const point of path.PathPoints) {
                poly.addPoint(point);
            }
            ret.push(poly);
        }
        return ret.concat(Array.from(obstacles));
    }
    DrawPaths() {
        this.SetWidthsOfArrowheads();
        this.CreateLongestNudgedSegments();
        this.FindFreeSpaceInDirection(Array.from(this.PathVisibilityGraph.Edges));
        this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals();
        this.PositionShiftedEdqges();
    }
    SetWidthsOfArrowheads() {
        for (const edgePath of this.Paths) {
            Nudger.SetWidthsOfArrowheadsForEdge(edgePath);
        }
    }
    static SetWidthsOfArrowheadsForEdge(path) {
        const edgeGeom = path.GeomEdge;
        if (edgeGeom.targetArrowhead != null) {
            const pathEdge = path.LastEdge;
            pathEdge.Width = Math.max(edgeGeom.targetArrowhead.width, pathEdge.Width);
        }
        if (edgeGeom.sourceArrowhead != null) {
            const pathEdge = path.FirstEdge;
            pathEdge.Width = Math.max(edgeGeom.sourceArrowhead.width, pathEdge.Width);
        }
    }
    PositionShiftedEdqges() {
        this.Solver = new _math_projectionSolver_UniformOneDimensionalSolver__WEBPACK_IMPORTED_MODULE_2__.UniformOneDimensionalSolver(this.EdgeSeparation);
        for (let i = 0; i < this.LongestNudgedSegs.length; i++) {
            this.CreateVariablesOfLongestSegment(this.LongestNudgedSegs[i]);
        }
        this.CreateConstraintsOfTheOrder();
        this.CreateConstraintsBetweenLongestSegments();
        this.Solver.SolveByRegularSolver();
        this.ShiftPathEdges();
    }
    MoveLongestSegsIdealPositionsInsideFeasibleIntervals() {
        for (let i = 0; i < this.LongestNudgedSegs.length; i++) {
            const seg = this.LongestNudgedSegs[i];
            Nudger.MoveLongestSegIdealPositionsInsideFeasibleInterval(seg);
        }
    }
    static MoveLongestSegIdealPositionsInsideFeasibleInterval(seg) {
        if (seg.IsFixed) {
            return;
        }
        const leftBound = seg.GetLeftBound();
        const rightBound = seg.GetRightBound();
        if (seg.IdealPosition < leftBound) {
            seg.IdealPosition = leftBound;
        }
        else if (seg.IdealPosition > rightBound) {
            seg.IdealPosition = rightBound;
        }
    }
    ShiftPathEdges() {
        for (const path of this.Paths) {
            path.PathPoints = this.GetShiftedPoints(path);
        }
    }
    GetShiftedPoints(path) {
        return Nudger.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(path));
    }
    // sometimes we have very small mistakes  of the positions that have to be fixed
    static Rectilinearise(a, b) {
        if (a.x === b.x || a.y === b.y)
            return b;
        const dx = Math.abs(a.x - b.x);
        const dy = Math.abs(a.y - b.y);
        return dx < dy ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(a.x, b.y) : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(b.x, a.y);
    }
    GetShiftedPointsSimple(path) {
        const ret = [];
        const edge = path.FirstEdge;
        ret.push(this.ShiftedPoint(edge.Source, edge.LongestNudgedSegment));
        for (const e of path.PathEdges()) {
            ret.push(this.ShiftedEdgePositionOfTarget(e));
        }
        return ret;
    }
    ShiftedEdgePositionOfTarget(e) {
        return e.LongestNudgedSegment != null || e.Next == null
            ? this.ShiftedPoint(e.Target, e.LongestNudgedSegment)
            : this.ShiftedPoint(e.Next.Source, e.Next.LongestNudgedSegment);
    }
    ShiftedPoint(point, segment) {
        if (segment == null) {
            return point;
        }
        const t = this.Solver.GetVariablePosition(segment.Id);
        return this.NudgingDirection === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.North ? new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(t, point.y) : new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(point.x, -t);
    }
    // static ShowPathsFromPoints(paths: Array<Path>, enumerable: Array<Polyline>) {
    //    let dd = new Array<DebugCurve>();
    //    if ((enumerable != null)) {
    //        dd=dd.concat(Nudger.GetObstacleBoundaries(enumerable, "grey"));
    //    }
    //    let i: number = 0;
    //    for (let p  of paths) {
    //        dd = dd.concat(Nudger.PathDebugCurvesFromPoints(p, DebugCurve.colors[Math.min(DebugCurve.colors.length, i++)]));
    //    }
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
    // }
    // static PathDebugCurvesFromPoints(path: Path, color: string): Array<DebugCurve> {
    //    const let startWidth: number = 0.01;
    //    const let endWidth: number = 3;
    //    let pts = path.PathPoints.toArray();
    //    let delta: number = ((endWidth - startWidth)
    //                / (pts.length - 1));
    //    for (let i: number = 0; (i
    //                < (pts.length - 1)); i++) {
    //        yield;
    //    }
    //    return new DebugCurve((startWidth
    //                    + (delta * i)), color, new LineSegment(pts[i], pts[(i + 1)]));
    // }
    // static ShowParamPaths(s: Point, e: Point, params paths: Path[]) {
    //    Nudger.ShowOrderedPaths(null, paths, s, e);
    // }
    // //         ReSharper disable UnusedMember.Local
    // static ShowOrderedPaths(obstacles: Array<Polyline>, paths: Array<Path>, s: Point, e: Point) {
    //    //            ReSharper restore UnusedMember.Local
    //    let colors: string[] = [
    //            "red",
    //            "green",
    //            "blue",
    //            "violet",
    //            "rose",
    //            "black"];
    //    const let startWidth: number = 0.001;
    //    const let endWidth: number = 0.1;
    //    let dd = new Array<DebugCurve>();
    //    if ((obstacles != null)) {
    //        dd.AddRange(Nudger.GetObstacleBoundaries(obstacles, "grey"));
    //    }
    //    let i: number = 0;
    //    for (let path  of paths) {
    //        dd.AddRange(Nudger.GetTestPathAsDebugCurve(startWidth, endWidth, colors[Math.min((colors.length - 1), i++)], path));
    //    }
    //    let ell = new DebugCurve(1, "black", new Ellipse(0.01, 0.01, s));
    //    dd.Add(ell);
    //    dd.Add(new DebugCurve(1, "black", new Ellipse(0.02, 0.02, e)));
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd.concat(Nudger.GetObstacleBoundaries(obstacles, "lightblue")));
    // }
    // static GetTestPathAsDebugCurve(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
    //    if ((path.PathEdges.Count() > 0)) {
    //        let count: number = path.PathEdges.Count();
    //        let deltaW: number = ((endWidth - startWidth)
    //                    / (count - 1));
    //        // TODO: Warning!!!, inline IF is not supported ?
    //        (count > 1);
    //        1;
    //        // if count ==1 the value of deltaW does not matter
    //        let i: number = 0;
    //        for (let e  of path.PathEdges) {
    //            yield;
    //        }
    //        return new DebugCurve(150, (startWidth
    //                        + (deltaW
    //                        * (i + 1))), color, new LineSegment(e.Source, e.Target));
    //    }
    //    else {
    //        let count: number = path.PathPoints.count();
    //        let pts = path.PathPoints.toArray();
    //        let deltaW = ((endWidth - startWidth)
    //                    / (count - 1));
    //        // TODO: Warning!!!, inline IF is not supported ?
    //        (count > 1);
    //        1;
    //        // if count ==1 the value of deltaW does not matter
    //        for (let i: number = 0; (i
    //                    < (count - 1)); i++) {
    //            yield;
    //        }
    //        return new DebugCurve(150, (startWidth
    //                        + (deltaW * i)), color, new LineSegment(pts[i], pts[(i + 1)]));
    //    }
    // }
    // static GetTestEdgePathAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
    //    let count: number = path.PathPoints.count();
    //    let deltaW: number = ((endWidth - startWidth)
    //                / (count - 1));
    //    // TODO: Warning!!!, inline IF is not supported ?
    //    (count > 1);
    //    1;
    //    // if count ==1 the value of deltaW does not matter
    //    let points = path.PathPoints.toArray();
    //    for (let i: number = 0; (i
    //                < (points.length - 1)); i++) {
    //        yield;
    //    }
    //    return new DebugCurve(125, (startWidth
    //                    + (deltaW * i)), color, new LineSegment(points[i], points[(i + 1)]));
    // }
    // static GetEdgePathFromPathEdgesAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
    //    let points = path.PathPoints.toArray();
    //    let count: number = points.length;
    //    let deltaW: number = ((endWidth - startWidth)
    //                / (count - 1));
    //    // TODO: Warning!!!, inline IF is not supported ?
    //    (count > 1);
    //    1;
    //    // if count ==1 the value of deltaW does not matter
    //    for (let i: number = 0; (i
    //                < (points.length - 1)); i++) {
    //        yield;
    //    }
    //    return new DebugCurve(120, (startWidth
    //                    + (deltaW * i)), color, new LineSegment(points[i], points[(i + 1)]));
    // }
    // // ReSharper disable UnusedMember.Local
    // static ShowEdgePaths(obstacles: Array<Polyline>, edgePaths: Array<Path>) {
    //    //  ReSharper restore UnusedMember.Local
    //    let debCurves: Array<DebugCurve> = Nudger.GetDebCurvesOfPaths(obstacles, edgePaths);
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
    // }
    // static GetDebCurvesOfPaths(enumerable: Array<Polyline>, edgePaths: Array<Path>): Array<DebugCurve> {
    //    let debCurves = Nudger.GetObstacleBoundaries(enumerable, "black");
    //    let i: number = 0;
    //    for (let edgePath  of edgePaths) {
    //        debCurves.AddRange(Nudger.GetTestEdgePathAsDebugCurves(0.2, 4, DebugCurve.colors[((i + 1)
    //                            % DebugCurve.colors.length)], edgePath));
    //    }
    //    return debCurves;
    // }
    // static ShowPathsInLoop(enumerable: Array<Polyline>, edgePaths: Array<Path>, point: Point) {
    //    for (let edgePath  of edgePaths.where(() => {  }, (((path.PathPoints.First() - point).Length < 1)
    //                    || ((path.PathPoints.Last() - point).Length < 1)))) {
    //        let debCurves = Nudger.GetObstacleBoundaries(enumerable, "black");
    //        debCurves.AddRange(Nudger.GetTestEdgePathAsDebugCurves(0.1, 4, "red", edgePath));
    //        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
    //    }
    // }
    // // ReSharper disable UnusedMember.Local
    // ShowLongSegsWithIdealPositions(dir: Direction) {
    //    //  ReSharper restore UnusedMember.Local
    //    let debCurves = Nudger.GetObstacleBoundaries(this.Obstacles, "black");
    //    let i: number = 0;
    //    debCurves.AddRange(this.LongestNudgedSegs.Select(() => {  }, Nudger.DebugCurveOfLongSeg(ls, DebugCurve.colors[i++, Percent, DebugCurve.colors.length], dir)));
    //    DebugCurveCollection.WriteToFile(debCurves, "c:/tmp/longSegs");
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
    // }
    // static DebugCurveOfLongSeg(ls: LongestNudgedSegment, s: string, dir: Direction): DebugCurve {
    //    return new DebugCurve(1, s, Nudger.LineSegOfLongestSeg(ls, dir));
    // }
    static LineSegOfLongestSeg(ls, dir) {
        const projectionToDir = dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.East ? (p) => p.x : (p) => p.y;
        const mm = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
        for (const edge of ls.Edges) {
            Nudger.UpdateMinMaxWithPoint(mm, projectionToDir, edge.Source);
            Nudger.UpdateMinMaxWithPoint(mm, projectionToDir, edge.Target);
        }
        return dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.East
            ? new _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_8__.LineSegment(mm.min, -ls.IdealPosition, mm.max, -ls.IdealPosition)
            : new _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_8__.LineSegment(ls.IdealPosition, mm.min, ls.IdealPosition, mm.max);
    }
    static UpdateMinMaxWithPoint(mm, projectionToDir, point) {
        const p = projectionToDir(point);
        if (mm.min > p) {
            mm.min = p;
        }
        if (mm.max < p) {
            mm.max = p;
        }
    }
    // ShowPathsDebug(edgePaths: Array<Path>) {
    //    let debCurves = Nudger.GetObstacleBoundaries(this.Obstacles, "black");
    //    let i: number = 0;
    //    for (let edgePath  of edgePaths) {
    //        debCurves.AddRange(Nudger.GetEdgePathFromPathEdgesAsDebugCurves(0.01, 0.4, DebugCurve.colors[((i + 1)
    //                            % DebugCurve.colors.length)], edgePath));
    //    }
    //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
    // }
    // static PathDebugCurves(path: Path, color: string): Array<DebugCurve> {
    //    let d = path.PathEdges.Select(() => {  }, new DebugCurve(70, 0.5, color, new LineSegment(e.Source, e.Target)));
    //    return d.Concat(Nudger.MarkPathVerts(path));
    // }
    // private static MarkPathVerts(path: Path): Array<DebugCurve> {
    //    let first: boolean = true;
    //    let p = new Point();
    //    for (let p0  of path.PathPoints) {
    //        if (first) {
    //            yield;
    //            return new DebugCurve(200, 1, "violet", CurveFactory.CreateDiamond(5, 5, p0));
    //            first = false;
    //        }
    //        else {
    //            yield;
    //        }
    //        return new DebugCurve(100, 0.5, "brown", CurveFactory.CreateEllipse(1.5, 1.5, p0));
    //        p = p0;
    //    }
    //    yield;
    //    return new DebugCurve(200, 1, "green", CurveFactory.CreateDiamond(3, 3, p));
    // }
    // static PathDebugCurvesFromPoint(path: Path): Array<DebugCurve> {
    //    let l = new Array<Point>(path.PathPoints);
    //    for (let i: number = 0; (i
    //                < (l.Count - 1)); i++) {
    //        yield;
    //    }
    //    return new DebugCurve(4, "red", new LineSegment(l[i], l[(i + 1)]));
    // }
    //
    // ReSharper disable UnusedMember.Local
    //        void ShowEdgesOfEdgePath(Path path){
    // ReSharper restore UnusedMember.Local
    //            string[] colors = {"red", "brown", "purple"};
    //            const double w0 = 1;
    //            const double w1 = 3;
    //            double dw = (w1 - w0)/path.OrientedSubpaths.Count;
    //            int i = 0;
    //            var dc = new Array<DebugCurve>();
    //            foreach (var s  of path.OrientedSubpaths){
    //                dc.AddRange(SubpathDebugCurves(w0 + dw*i, colors[Math.Min(i++, colors.Length - 1)], s));
    //            }
    //            LayoutAlgorithmSettings.ShowDebugCurves(dc.ToArray());
    //        }
    //
    //        static Array<DebugCurve> SubpathDebugCurves(double w, string color, OrientedSubpath subpath){
    //            return subpath.LinkedPath.Select(e => new DebugCurve(w, color, new LineSegment(e.Source.Point, e.Target.Point)));
    //        }
    // static GetObstacleBoundaries(obstacles: Array<Polyline>, color: string): Array<DebugCurve> {
    //    let debugCurves = new Array<DebugCurve>();
    //    if ((obstacles != null)) {
    //        debugCurves.AddRange(obstacles.select(() => {  }, new DebugCurve(50, 0.3, color, poly)));
    //    }
    //    return debugCurves;
    // }
    CreateConstraintsBetweenLongestSegments() {
        for (const segment of this.LongestNudgedSegs) {
            this.CreateConstraintsBetweenLongestSegmentsForSegment(segment);
        }
    }
    CreateConstraintsBetweenLongestSegmentsForSegment(segment) {
        const rightNeighbors = new Set();
        for (const pathEdge of segment.Edges) {
            const axisEdge = pathEdge.AxisEdge;
            if (axisEdge != null) {
                for (const rightNeiAxisEdge of axisEdge.RightNeighbors) {
                    for (const longSeg of rightNeiAxisEdge.LongestNudgedSegments) {
                        rightNeighbors.add(longSeg);
                    }
                }
            }
        }
        for (const seg of rightNeighbors) {
            this.ConstraintTwoLongestSegs(segment, seg);
        }
    }
    CreateConstraintsOfTheOrder() {
        for (const kv of this.PathOrders) {
            if (Nudger.ParallelToDirection(kv[0], this.NudgingDirection)) {
                this.CreateConstraintsOfThePathOrder(kv[1]);
            }
        }
    }
    static ParallelToDirection(edge, direction) {
        switch (direction) {
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.North:
            case _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.South:
                return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_10__.closeDistEps)(edge.SourcePoint.x, edge.TargetPoint.x);
                break;
            default:
                return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_10__.closeDistEps)(edge.SourcePoint.y, edge.TargetPoint.y);
                break;
        }
    }
    CreateConstraintsOfThePathOrder(pathOrder) {
        let prevEdge = null;
        for (const pathEdge of pathOrder.filter((p) => p.LongestNudgedSegment != null)) {
            if (prevEdge != null) {
                this.ConstraintTwoLongestSegs(prevEdge.LongestNudgedSegment, pathEdge.LongestNudgedSegment);
            }
            prevEdge = pathEdge;
        }
    }
    ConstraintTwoLongestSegs(prevSeg, seg) {
        if (!prevSeg.IsFixed || !seg.IsFixed) {
            this.Solver.AddConstraint(prevSeg.Id, seg.Id);
        }
    }
    CreateVariablesOfLongestSegment(segment) {
        if (!segment.IsFixed) {
            const leftBound = segment.GetLeftBound();
            const rightBound = segment.GetRightBound();
            if (leftBound >= rightBound) {
                // don't move the segment from the way it was generated
                this.Solver.AddFixedVariable(segment.Id, Nudger.SegmentPosition(segment, this.NudgingDirection));
                segment.IsFixed = true;
            }
            else {
                this.Solver.AddVariableNNNN(segment.Id, Nudger.SegmentPosition(segment, this.NudgingDirection), segment.IdealPosition, segment.Width);
                //           Assert.assert(leftBound + Curve.DistanceEpsilon < rightBound); //this assert does not hold for overlaps
                if (leftBound !== Number.NEGATIVE_INFINITY) {
                    this.Solver.SetLowBound(leftBound, segment.Id);
                }
                if (rightBound !== Number.POSITIVE_INFINITY) {
                    this.Solver.SetUpperBound(segment.Id, rightBound);
                }
            }
        }
        else {
            this.Solver.AddFixedVariable(segment.Id, Nudger.SegmentPosition(segment, this.NudgingDirection));
        }
    }
    static SegmentPosition(segment, direction) {
        return direction === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.North ? segment.Start.x : -segment.Start.y;
    }
    FindFreeSpaceInDirection(axisEdges) {
        this.BoundAxisEdgesByRectsKnownInAdvance();
        const freeSpaceFinder = new _FreeSpaceFinder__WEBPACK_IMPORTED_MODULE_12__.FreeSpaceFinder(this.NudgingDirection, this.Obstacles, this.axisEdgesToObstaclesTheyOriginatedFrom, this.PathOrders, axisEdges);
        freeSpaceFinder.FindFreeSpace();
    }
    BoundAxisEdgesByRectsKnownInAdvance() {
        for (const path of this.Paths) {
            if (this.HasGroups) {
                this.BoundPathByMinCommonAncestors(path);
            }
            this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(path);
        }
    }
    BoundPathByMinCommonAncestors(path) {
        for (const sh of this.GetMinCommonAncestors(path.GeomEdge)) {
            const rect = sh.BoundingBox;
            for (const e of path.PathEdges()) {
                const edge = e.AxisEdge;
                if (edge.Direction === this.NudgingDirection) {
                    this.BoundAxisEdgeByRect(rect, edge);
                }
            }
        }
    }
    GetMinCommonAncestors(edge) {
        if (this.PortToShapes == null) {
            this.PortToShapes = Nudger.MapPortsToShapes(this.AncestorsSets.keys());
        }
        const commonAncestors = IntersectSets(this.AncestorsForPort(edge.sourcePort), this.AncestorsForPort(edge.targetPort));
        return Array.from(commonAncestors).filter((anc) => !anc.Children.some((child) => commonAncestors.has(child)));
    }
    AncestorsForPort(port) {
        const shape = this.PortToShapes.get(port);
        if (shape) {
            return this.AncestorsSets.get(shape);
        }
        // This is a FreePort or Waypoint; return all spatial parents.
        return new Set(this.HierarchyOfGroups.AllHitItems(_math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkPP(port.Location, port.Location), null));
    }
    BoundAxisEdgeAdjacentToObstaclePort(port, axisEdge) {
        if (port.Curve == null) {
            this.BoundAxisByPoint(port.Location, axisEdge);
        }
        else if (port.Curve.boundingBox.contains(port.Location)) {
            this.BoundAxisEdgeByRect(port.Curve.boundingBox, axisEdge);
        }
    }
    BoundAxisByPoint(point, axisEdge) {
        if (axisEdge != null && axisEdge.Direction === this.NudgingDirection) {
            if (this.NudgingDirection === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.North) {
                axisEdge.BoundFromLeft(point.x);
                axisEdge.BoundFromRight(point.x);
            }
            else {
                axisEdge.BoundFromLeft(-point.y);
                axisEdge.BoundFromRight(-point.y);
            }
        }
    }
    BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(path) {
        this.BoundAxisEdgeAdjacentToObstaclePort(path.GeomEdge.sourcePort, path.FirstEdge.AxisEdge);
        this.BoundAxisEdgeAdjacentToObstaclePort(path.GeomEdge.targetPort, path.LastEdge.AxisEdge);
    }
    BoundAxisEdgeByRect(rectangle, axisEdge) {
        if (axisEdge != null && axisEdge.Direction === this.NudgingDirection) {
            if (this.NudgingDirection === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.North) {
                axisEdge.BoundFromLeft(rectangle.left);
                axisEdge.BoundFromRight(rectangle.right);
            }
            else {
                axisEdge.BoundFromLeft(rectangle.top * -1);
                axisEdge.BoundFromRight(rectangle.bottom * -1);
            }
        }
    }
    CreateLongestNudgedSegments() {
        const projectionToPerp = this.NudgingDirection === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.East ? (p) => -p.y : (p) => p.x;
        this.LongestNudgedSegs = new Array();
        for (let i = 0; i < this.Paths.length; i++) {
            this.CreateLongestNudgedSegmentsForPath(this.Paths[i], projectionToPerp);
        }
    }
    CreateLongestNudgedSegmentsForPath(path, projectionToPerp) {
        // ShowEdgesOfEdgePath(path);
        this.GoOverPathAndCreateLongSegs(path);
        Nudger.CalculateIdealPositionsForLongestSegs(path, projectionToPerp);
    }
    static CalculateIdealPositionsForLongestSegs(path, projectionToPerp) {
        let currentLongSeg = null;
        let ret = null;
        let prevOffset = projectionToPerp(path.Start);
        for (const edge of path.PathEdges()) {
            if (edge.LongestNudgedSegment != null) {
                currentLongSeg = edge.LongestNudgedSegment;
                if (ret != null) {
                    let t;
                    Nudger.SetIdealPositionForSeg(ret, (t = projectionToPerp(ret.start)), prevOffset, projectionToPerp(currentLongSeg.Start));
                    prevOffset = t;
                    ret = null;
                }
            }
            else if (currentLongSeg != null) {
                ret = currentLongSeg;
                currentLongSeg = null;
            }
        }
        if (ret != null) {
            Nudger.SetIdealPositionForSeg(ret, projectionToPerp(ret.Start), prevOffset, projectionToPerp(path.End));
        }
        else if (currentLongSeg != null) {
            currentLongSeg.IdealPosition = projectionToPerp(currentLongSeg.Start);
        }
    }
    static SetIdealPositionForSeg(segment, segPosition, offset0, offset1) {
        const max = Math.max(offset0, offset1);
        const min = Math.min(offset0, offset1);
        if (min + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_7__.GeomConstants.distanceEpsilon < segPosition) {
            if (segPosition < max) {
                segment.IdealPosition = 0.5 * (max + min);
            }
            else {
                segment.IdealPosition = max;
            }
        }
        else {
            segment.IdealPosition = min;
        }
    }
    GoOverPathAndCreateLongSegs(path) {
        let currentLongestSeg = null;
        const oppositeDir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__.CompassVector.OppositeDir(this.NudgingDirection);
        for (const edge of path.PathEdges()) {
            const edgeDir = edge.Direction;
            if (edgeDir === this.NudgingDirection || edgeDir === oppositeDir) {
                if (currentLongestSeg == null) {
                    edge.LongestNudgedSegment = currentLongestSeg = new _LongestNudgedSegment__WEBPACK_IMPORTED_MODULE_13__.LongestNudgedSegment(this.LongestNudgedSegs.length);
                    this.LongestNudgedSegs.push(currentLongestSeg);
                }
                else {
                    edge.LongestNudgedSegment = currentLongestSeg;
                }
                if (edge.IsFixed) {
                    currentLongestSeg.IsFixed = true;
                }
            }
            else {
                // the edge is perpendicular to "direction"
                edge.LongestNudgedSegment = null;
                currentLongestSeg = null;
            }
        }
    }
    static BuildPolylineForPath(path) {
        const t = { points: path.PathPoints.map((p) => p.clone()) };
        Nudger.ExtendPolylineToPorts(t, path);
        /* for (let i = 0; i < t.points.length - 1; i++) {
    // Assert.assert(
            CompassVector.IsPureDirectionPP(t.points[i], t.points[i + 1]),
          )
        }*/
        return t.points;
    }
    static ExtendPolylineToPorts(t, path) {
        Nudger.ExtendPolylineToSourcePort(t, path.GeomEdge.sourcePort.Location);
        Nudger.ExtendPolylineToTargetPort(t, path.GeomEdge.targetPort.Location);
        // In some overlapped cases where the source or target vertex used for the path
        // coincides with the target or source port location, we can end up with a single-point
        // path.  In that case, we just force a straightline path.
        if (t.points.length < 2) {
            t.points = new Array(2);
            t.points[0] = path.GeomEdge.sourcePort.Location;
            t.points[1] = path.GeomEdge.targetPort.Location;
        }
    }
    static ExtendPolylineToTargetPort(t, location) {
        const n = t.points.length - 1;
        const dir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__.CompassVector.VectorDirectionPP(t.points[n - 1], t.points[n]);
        if (Nudger.ProjectionsAreClose(t.points[n - 1], dir, location)) {
            // it might be that the last point on polyline is at the port already
            // then we just drop the last point
            t.points = t.points.slice(0, n);
            return;
        }
        const p = t.points[n];
        if (dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.East || dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.West) {
            t.points[n] = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(location.x, p.y);
        }
        else {
            t.points[n] = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(p.x, location.y);
        }
    }
    static ProjectionsAreClose(a, dir, b) {
        if (dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.East || dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.West) {
            return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_10__.closeDistEps)(a.x, b.x);
        }
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_10__.closeDistEps)(a.y, b.y);
    }
    static ExtendPolylineToSourcePort(t, location) {
        const dir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__.CompassVector.VectorDirectionPP(t.points[0], t.points[1]);
        if (Nudger.ProjectionsAreClose(t.points[1], dir, location)) {
            // it might be that the second point on polyline is at the port already
            // then we just drop the first point
            t.points = t.points.slice(1);
            return;
        }
        const p = t.points[0];
        if (dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.East || dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.West) {
            t.points[0] = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(location.x, p.y);
        }
        else {
            t.points[0] = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(p.x, location.y);
        }
    }
    static RemoveSwitchbacksAndMiddlePoints(points) {
        const ret = [];
        let a = points[0];
        ret.push(a);
        let b = points[1];
        let prevDir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__.CompassVector.VectorDirectionPP(a, b);
        let i = 1;
        while (++i < points.length) {
            const dir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__.CompassVector.VectorDirectionPP(b, points[i]);
            if (!(dir === prevDir || _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_3__.CompassVector.OppositeDir(dir) === prevDir || dir === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.None)) {
                if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(a, b)) {
                    // make sure that we are not returning the same point twice
                    ret.push((a = Nudger.Rectilinearise(a, b)));
                }
                prevDir = dir;
            }
            b = points[i];
        }
        if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(a, b)) {
            ret.push(Nudger.Rectilinearise(a, b));
        }
        return ret;
    }
    // this function defines the final path coordinates
    // the set of paths, point sequences
    // the radius of the arc inscribed into the path corners
    // an enumeration of padded obstacles
    //
    //
    // <returns>the mapping of the path to its modified path</returns>
    static NudgePaths(paths, cornerFitRadius, paddedObstacles, ancestorsSets, removeStaircases) {
        if (paths.length === 0) {
            return;
        }
        const nudger = new Nudger(paths, cornerFitRadius, paddedObstacles, ancestorsSets);
        nudger.Calculate(_math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.North, true);
        nudger.Calculate(_math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.East, false);
        nudger.Calculate(_math_geometry_direction__WEBPACK_IMPORTED_MODULE_6__.Direction.North, false);
        if (removeStaircases) {
            nudger.RemoveStaircases();
        }
        for (const path of paths) {
            path.GeomEdge.curve = _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_9__.Polyline.mkFromPoints(Nudger.BuildPolylineForPath(path));
        }
    }
    RemoveStaircases() {
        _StaircaseRemover__WEBPACK_IMPORTED_MODULE_15__.StaircaseRemover.RemoveStaircases(this.Paths, this.HierarchyOfObstacles);
    }
    static MapPortsToShapes(listOfShapes) {
        const portToShapes = new Map();
        for (const shape of listOfShapes) {
            for (const port of shape.Ports) {
                portToShapes.set(port, shape);
            }
        }
        return portToShapes;
    }
    // ShowPathsDebug(edgePaths: Iterable<Path>, fn: string) {
    //  const debCurves = GetObstacleBoundaries(this.Obstacles, 'black')
    //  const i = 0
    //  for (const edgePath of edgePaths) {
    //    for (const c of Nudger.GetEdgePathFromPathEdgesAsDebugCurves(
    //      0.1,
    //      1.0,
    //      DebugCurve.colors[(i + 1) % DebugCurve.colors.length],
    //      edgePath,
    //    )) {
    //      debCurves.push(c)
    //    }
    //  }
    //  SvgDebugWriter.dumpDebugCurves(fn, debCurves)
    // }
    static *GetEdgePathFromPathEdgesAsDebugCurves(startWidth, endWidth, color, path) {
        const points = path.ArrayOfPathPoints();
        const count = points.length;
        const deltaW = count > 1 ? (endWidth - startWidth) / (count - 1) : 1;
        // if count ==1 the value of deltaW does not matter
        for (let i = 0; i < points.length - 1; i++) {
            yield _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_5__.DebugCurve.mkDebugCurveTWCI(200, startWidth + deltaW * i, color, _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_8__.LineSegment.mkPP(points[i], points[i + 1]));
        }
    }
}
// function GetObstacleBoundaries(
//  obstacles: Array<Polyline>,
//  color: string,
// ): Array<DebugCurve> {
//  const debugCurves = new Array<DebugCurve>()
//  if (obstacles != null) {
//    for (const o of obstacles)
//      debugCurves.push(DebugCurve.mkDebugCurveTWCI(50, 0.3, color, o))
//  }
//  return debugCurves
// }
function IntersectSets(a, b) {
    const r = new Set();
    if (a.size < b.size) {
        for (const x of a)
            if (b.has(x))
                r.add(x);
    }
    else {
        for (const x of b)
            if (a.has(x))
                r.add(x);
    }
    return r;
}
//# sourceMappingURL=Nudger.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/Path.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _LinkedPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPoint.js");


// represents the path for an GeomEdge
class Path {
    get PathPoints() {
        return this._pathPoints;
    }
    set PathPoints(value) {
        this._pathPoints = value;
    }
    get Width() {
        return this.GeomEdge.lineWidth;
    }
    // constructor
    constructor(edgeGeometry) {
        this.GeomEdge = edgeGeometry;
    }
    get End() {
        return this.LastEdge.Target;
    }
    get Start() {
        return this.FirstEdge.Source;
    }
    ArrayOfPathPoints() {
        if (this._pathPoints instanceof _LinkedPoint__WEBPACK_IMPORTED_MODULE_1__.LinkedPoint) {
            return Array.from(iteratePoints(this._pathPoints));
        }
        else {
            return this._pathPoints;
        }
    }
    *PathEdges() {
        for (let e = this.FirstEdge; e != null; e = e.Next) {
            yield e;
        }
    }
    AddEdge(edge) {
        edge.Path = this;
        /*Assert.assert(edge.Source === this.LastEdge.Target)*/
        this.LastEdge.Next = edge;
        edge.Prev = this.LastEdge;
        this.LastEdge = edge;
    }
    SetFirstEdge(edge) {
        this.FirstEdge = edge;
        this.LastEdge = edge;
        edge.Path = this;
    }
    //
    toString() {
        const sb = new typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.StringBuilder();
        if (this.PathPoints instanceof _LinkedPoint__WEBPACK_IMPORTED_MODULE_1__.LinkedPoint)
            sb.Append('L');
        for (const p of iteratePoints(this.PathPoints))
            sb.Append(p.toString());
        return sb.ToString();
    }
}
function* iteratePoints(pathPoints) {
    if (pathPoints instanceof _LinkedPoint__WEBPACK_IMPORTED_MODULE_1__.LinkedPoint) {
        for (let p = pathPoints; p != null; p = p.Next) {
            yield p.Point;
        }
    }
    else {
        for (const p of pathPoints)
            yield p;
    }
}
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PathEdge: () => (/* binding */ PathEdge)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
// A place holder for an edge in a path to keep it inside of a linked list representing a path.
// Each PathEdge belongs to only one path


// In the last case the PathEdge is marked as Reversed. Several PathEdges can share the same AxisEdge.
class PathEdge {
    toString() {
        return this.Source + (' ' + this.Target);
    }
    constructor(edgeForNudging, width) {
        // A fixed edge cannot be shifted from its visibility edge; offset is always 0.
        // Such an edge can be, for example, a terminal edge going to a port.
        this.IsFixed = false;
        // if set to true then in the path the edge is reversed
        this.Reversed = false;
        this.index = -1;
        this.AxisEdge = edgeForNudging;
        this.Width = width;
    }
    // It is the offset of the edge from the underlying line segment
    // [VisibilityEdge.SourcePoint, VisibilityEdge.TargetPoint] in to the direction of the VisibilityEdge.Perpendicular.
    // Offset holder is the same for the maximal parallel sequence of connected PathEdges
    get LongestNudgedSegment() {
        return this.longestNudgedSegment;
    }
    set LongestNudgedSegment(value) {
        this.longestNudgedSegment = value;
        if (this.longestNudgedSegment != null) {
            this.longestNudgedSegment.AddEdge(this);
            this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment);
        }
    }
    get Source() {
        return !this.Reversed ? this.AxisEdge.SourcePoint : this.AxisEdge.TargetPoint;
    }
    get Target() {
        return this.Reversed ? this.AxisEdge.SourcePoint : this.AxisEdge.TargetPoint;
    }
    static VectorsAreParallel(a, b) {
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.closeDistEps)(a.x * b.y - a.y * b.x, 0);
    }
    static EdgesAreParallel(edge, pathEdge) {
        return PathEdge.VectorsAreParallel(edge.AxisEdge.TargetPoint.sub(edge.AxisEdge.SourcePoint), pathEdge.AxisEdge.TargetPoint.sub(pathEdge.AxisEdge.SourcePoint));
    }
    get Direction() {
        return this.Reversed ? _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.OppositeDir(this.AxisEdge.Direction) : this.AxisEdge.Direction;
    }
    // not set yet
    // the index of the edge in the order
    get Index() {
        return this.index;
    }
    set Index(value) {
        this.index = value;
    }
}
//# sourceMappingURL=PathEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathMerger.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PathMerger: () => (/* binding */ PathMerger)
/* harmony export */ });
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
/* harmony import */ var _LinkedPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPoint.js");
// Avoid a situation where two paths cross each other more than once. Remove self loops.
//


class PathMerger {
    constructor(paths) {
        this.verticesToPathOffsets = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_0__.PointMap();
        this.Paths = paths;
    }
    // Avoid a situation where two paths cross each other more than once. Remove self loops.
    MergePaths() {
        this.InitVerticesToPathOffsetsAndRemoveSelfCycles();
        for (const path of this.Paths) {
            this.ProcessPath(path);
        }
    }
    ProcessPath(path) {
        const departedPaths = new Map();
        let prevLocationPathOffsets = null;
        for (let linkedPoint = path.PathPoints; linkedPoint != null; linkedPoint = linkedPoint.Next) {
            const pathOffsets = this.verticesToPathOffsets.get(linkedPoint.Point);
            if (prevLocationPathOffsets != null) {
                // handle returning paths
                if (departedPaths.size > 0) {
                    for (const [path0, v] of pathOffsets) {
                        const departerLinkedPoint = departedPaths.get(path0);
                        if (departerLinkedPoint) {
                            // returned!
                            this.CollapseLoopingPath(path0, departerLinkedPoint, v, path, linkedPoint);
                            departedPaths.delete(path0);
                        }
                    }
                }
                // find departed paths
                for (const [k, v] of prevLocationPathOffsets) {
                    if (!pathOffsets.has(k))
                        departedPaths.set(k, v);
                }
            }
            prevLocationPathOffsets = pathOffsets;
        }
    }
    //        bool Correct() {
    //            foreach (var kv of verticesToPathOffsets) {
    //                Point p = kv.Key;
    //                Map<Path, LinkedPoint> pathOffs = kv.Value;
    //                foreach (var pathOff of pathOffs) {
    //                    var path = pathOff.Key;
    //                    var linkedPoint = pathOff.Value;
    //                    if (linkedPoint.Point !== p)
    //                        return false;
    //                    if (FindLinkedPointInPath(path, p) == null ) {
    //                        return false;
    //                    }
    //                }
    //            }
    //            return true;
    //        }
    CollapseLoopingPath(loopingPath, departureFromLooping, arrivalToLooping, stemPath, arrivalToStem) {
        const departurePointOnStem = PathMerger.FindLinkedPointInPath(stemPath, departureFromLooping.Point);
        const pointsToInsert = Array.from(PathMerger.GetPointsInBetween(departurePointOnStem, arrivalToStem));
        if (PathMerger.Before(departureFromLooping, arrivalToLooping)) {
            this.CleanDisappearedPiece(departureFromLooping, arrivalToLooping, loopingPath);
            this.ReplacePiece(departureFromLooping, arrivalToLooping, pointsToInsert, loopingPath);
        }
        else {
            this.CleanDisappearedPiece(arrivalToLooping, departureFromLooping, loopingPath);
            this.ReplacePiece(arrivalToLooping, departureFromLooping, pointsToInsert.reverse(), loopingPath);
        }
    }
    static *GetPointsInBetween(a, b) {
        for (let i = a.Next; i !== b; i = i.Next) {
            yield i.Point;
        }
    }
    ReplacePiece(a, b, points, loopingPath) {
        let prevPoint = a;
        for (const point of points) {
            const lp = new _LinkedPoint__WEBPACK_IMPORTED_MODULE_1__.LinkedPoint(point);
            prevPoint.Next = lp;
            prevPoint = lp;
            const pathOffset = this.verticesToPathOffsets.get(point);
            /*Assert.assert(!pathOffset.has(loopingPath))*/
            pathOffset.set(loopingPath, prevPoint);
        }
        prevPoint.Next = b;
    }
    CleanDisappearedPiece(a, b, loopingPath) {
        for (const point of PathMerger.GetPointsInBetween(a, b)) {
            const pathOffset = this.verticesToPathOffsets.get(point);
            /*Assert.assert(pathOffset.has(loopingPath))*/
            pathOffset.delete(loopingPath);
        }
    }
    // checks that a is before b of the path
    // <returns>true is a is before b of the path</returns>
    static Before(a, b) {
        for (a = a.Next; a != null; a = a.Next) {
            if (a === b) {
                return true;
            }
        }
        return false;
    }
    static FindLinkedPointInPath(path, point) {
        // this function is supposed to always succeed. it will throw a null reference exception otherwise
        for (let linkedPoint = path.PathPoints;; linkedPoint = linkedPoint.Next) {
            if (linkedPoint.Point.equal(point)) {
                return linkedPoint;
            }
        }
    }
    InitVerticesToPathOffsetsAndRemoveSelfCycles() {
        for (const path of this.Paths) {
            for (let linkedPoint = path.PathPoints; linkedPoint != null; linkedPoint = linkedPoint.Next) {
                let pathOffsets = this.verticesToPathOffsets.get(linkedPoint.Point);
                if (!pathOffsets) {
                    this.verticesToPathOffsets.set(linkedPoint.Point, (pathOffsets = new Map()));
                }
                // check for the loop
                const loopPoint = pathOffsets.get(path);
                if (loopPoint) {
                    // we have a loop
                    this.CleanDisappearedPiece(loopPoint, linkedPoint, path);
                    loopPoint.Next = linkedPoint.Next;
                }
                else {
                    pathOffsets.set(path, linkedPoint);
                }
            }
        }
    }
}
//# sourceMappingURL=PathMerger.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathRefiner.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PathRefiner: () => (/* binding */ PathRefiner)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/direction.js");
/* harmony import */ var _LinkedPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPoint.js");
/* harmony import */ var _LinkedPointSplitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/LinkedPointSplitter.js");
/* harmony import */ var _PathMerger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/PathMerger.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
// If two paths intersect then insert the intersection point as a vertex into both paths.
// Remove path self loops. Merge paths between the crossings if they have multiple crossings.
// If a path passes through a vertex of another path then insert this vertex into the first path.






class PathRefiner {
    static RefinePaths(paths, mergePaths) {
        PathRefiner.AdjustPaths(paths);
        const pathsToFirstLinkedVertices = PathRefiner.CreatePathsToFirstLinkedVerticesMap(paths);
        PathRefiner.Refine(Array.from(pathsToFirstLinkedVertices.values()));
        PathRefiner.CrossVerticalAndHorizontalSegs(pathsToFirstLinkedVertices.values());
        PathRefiner.ReconstructPathsFromLinkedVertices(pathsToFirstLinkedVertices);
        if (mergePaths) {
            new _PathMerger__WEBPACK_IMPORTED_MODULE_4__.PathMerger(paths).MergePaths();
        }
    }
    // make sure that every two different points of paths are separated by at least 10e-6
    static AdjustPaths(paths) {
        for (const path of paths) {
            path.PathPoints = PathRefiner.AdjustPathPoints(path.PathPoints);
        }
    }
    static AdjustPathPoints(points) {
        if (!points || points.length === 0)
            return;
        const arr = [];
        let p = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(points[0]);
        arr.push(p);
        for (let i = 1; i < points.length; i++) {
            const np = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.RoundPoint(points[i]);
            if (!p.equal(np)) {
                p = np;
                arr.push(p);
            }
        }
        return arr;
    }
    static CrossVerticalAndHorizontalSegs(pathsFirstLinked) {
        const horizontalPoints = new Array();
        const verticalPoints = new Array();
        for (const pnt of pathsFirstLinked) {
            for (let p = pnt; p.Next != null; p = p.Next) {
                if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_5__.closeDistEps)(p.Point.x, p.Next.Point.x)) {
                    verticalPoints.push(p);
                }
                else {
                    horizontalPoints.push(p);
                }
            }
        }
        new _LinkedPointSplitter__WEBPACK_IMPORTED_MODULE_3__.LinkedPointSplitter(horizontalPoints, verticalPoints).SplitPoints();
    }
    static ReconstructPathsFromLinkedVertices(pathsToPathLinkedPoints) {
        for (const [k, v] of pathsToPathLinkedPoints) {
            k.PathPoints = v;
        }
    }
    static Refine(pathFirstPoints) {
        PathRefiner.RefineInDirection(_math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.North, pathFirstPoints);
        PathRefiner.RefineInDirection(_math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East, pathFirstPoints);
    }
    // refines all segments that are parallel to "direction"
    static *groupByProj(proj, linkedPointsInDirection) {
        const map = new Map();
        for (const lp of linkedPointsInDirection) {
            const p = proj(lp.Point);
            let arr = map.get(p);
            if (!arr) {
                arr = new Array();
                map.set(p, arr);
            }
            arr.push(lp);
        }
        for (const v of map.values()) {
            yield v;
        }
    }
    static RefineInDirection(direction, pathFirstPoints) {
        const t = {
            projectionToPerp: undefined,
            projectionToDirection: undefined,
        };
        PathRefiner.GetProjectionsDelegates(direction, t);
        const linkedPointsInDirection = Array.from(PathRefiner.GetAllLinkedVertsInDirection(t.projectionToPerp, pathFirstPoints));
        const colliniarBuckets = PathRefiner.groupByProj(t.projectionToPerp, linkedPointsInDirection);
        for (const pathLinkedPointBucket of colliniarBuckets) {
            PathRefiner.RefineCollinearBucket(pathLinkedPointBucket, t.projectionToDirection);
        }
    }
    static GetProjectionsDelegates(direction, t) {
        if (direction === _math_geometry_direction__WEBPACK_IMPORTED_MODULE_1__.Direction.East) {
            t.projectionToDirection = (p) => p.x;
            t.projectionToPerp = (p) => p.y;
        }
        else {
            t.projectionToPerp = (p) => p.x;
            t.projectionToDirection = (p) => p.y;
        }
    }
    static *GetAllLinkedVertsInDirection(projectionToPerp, initialVerts) {
        for (const vert of initialVerts) {
            for (let v = vert; v.Next != null; v = v.Next) {
                if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_5__.closeDistEps)(projectionToPerp(v.Point), projectionToPerp(v.Next.Point))) {
                    yield v;
                }
            }
        }
    }
    // refine vertices belonging to a bucket;
    // pathLinkedVertices belong to a line parallel to the direction of the refinement
    static RefineCollinearBucket(pathLinkedVertices, projectionToDirection) {
        const coords = new Set();
        const pointProjPairs = new Array();
        for (const pathLinkedPoint of pathLinkedVertices) {
            let x = projectionToDirection(pathLinkedPoint.Point);
            if (!coords.has(x)) {
                coords.add(x);
                pointProjPairs.push([pathLinkedPoint.Point, x]);
            }
            x = projectionToDirection(pathLinkedPoint.Next.Point);
            if (!coords.has(x)) {
                coords.add(x);
                pointProjPairs.push([pathLinkedPoint.Next.Point, x]);
            }
        }
        pointProjPairs.sort((a, b) => a[1] - b[1]);
        const points = pointProjPairs.map(a => a[0]);
        const coordToIndex = new Map();
        for (let i = 0; i < pointProjPairs.length; i++)
            coordToIndex.set(pointProjPairs[i][1], i);
        for (const pathLinkedVertex of pathLinkedVertices) {
            const i = coordToIndex.get(projectionToDirection(pathLinkedVertex.Point));
            const j = coordToIndex.get(projectionToDirection(pathLinkedVertex.Next.Point));
            if (Math.abs(j - i) > 1) {
                PathRefiner.InsertPoints(pathLinkedVertex, points, i, j);
            }
        }
    }
    static InsertPoints(pathLinkedVertex, arrayOfPoints, i, j) {
        if (i < j) {
            pathLinkedVertex.InsertVerts(i, j, arrayOfPoints);
        }
        else {
            pathLinkedVertex.InsertVertsInReverse(j, i, arrayOfPoints);
        }
    }
    static CreatePathsToFirstLinkedVerticesMap(edgePaths) {
        const dict = new Map();
        for (const path of edgePaths) {
            dict.set(path, PathRefiner.CreateLinkedVertexOfEdgePath(path));
        }
        return dict;
    }
    static CreateLinkedVertexOfEdgePath(path) {
        const arr = path.PathPoints;
        let pathPoint = new _LinkedPoint__WEBPACK_IMPORTED_MODULE_2__.LinkedPoint(arr[0]);
        const first = pathPoint;
        for (let i = 1; i < arr.length; i++) {
            pathPoint.Next = new _LinkedPoint__WEBPACK_IMPORTED_MODULE_2__.LinkedPoint(arr[i]);
            pathPoint = pathPoint.Next;
        }
        return first;
    }
}
//# sourceMappingURL=PathRefiner.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/SegWithIndex.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SegWithIndex: () => (/* binding */ SegWithIndex)
/* harmony export */ });
class SegWithIndex {
    // offset
    constructor(pts, i) {
        /*Assert.assert(i < pts.length && i >= 0)*/
        this.Points = pts;
        this.I = i;
    }
    static equal(a, b) {
        return a.I === b.I && a.Points === b.Points;
    }
    get Start() {
        return this.Points[this.I];
    }
    get End() {
        return this.Points[this.I + 1];
    }
}
//# sourceMappingURL=SegWithIndex.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/nudging/StaircaseRemover.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaircaseRemover: () => (/* binding */ StaircaseRemover)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _SegWithIndex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/nudging/SegWithIndex.js");




class StaircaseRemover {
    constructor(paths, hierarchyOfObstacles) {
        this.segTree = new _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__.BinaryRTree(null);
        this.crossedOutPaths = new Set();
        this.HierarchyOfObstacles = new _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__.BinaryRTree(hierarchyOfObstacles);
        this.Paths = paths;
    }
    static RemoveStaircases(paths, hierarchyOfObstacles) {
        const r = new StaircaseRemover(paths, hierarchyOfObstacles);
        r.Calculate();
    }
    Calculate() {
        this.InitHierarchies();
        let success;
        do {
            success = false;
            for (const path of this.Paths.filter((p) => !this.crossedOutPaths.has(p))) {
                if (this.ProcessPath(path))
                    success = true;
            }
        } while (success);
    }
    ProcessPath(path) {
        const t = { pts: path.PathPoints, canHaveStaircase: false };
        if (this.ProcessPoints(t)) {
            path.PathPoints = t.pts;
            return true;
        }
        if (!t.canHaveStaircase) {
            this.crossedOutPaths.add(path);
        }
        return false;
    }
    ProcessPoints(t) {
        const staircaseStart = this.FindStaircaseStart(t);
        if (staircaseStart < 0) {
            return false;
        }
        t.pts = this.RemoveStaircasePN(t.pts, staircaseStart);
        return true;
    }
    FindStaircaseStart(t) {
        t.canHaveStaircase = false;
        if (t.pts.length < 5) {
            return -1;
        }
        const segs = [new _SegWithIndex__WEBPACK_IMPORTED_MODULE_3__.SegWithIndex(t.pts, 0), new _SegWithIndex__WEBPACK_IMPORTED_MODULE_3__.SegWithIndex(t.pts, 1), new _SegWithIndex__WEBPACK_IMPORTED_MODULE_3__.SegWithIndex(t.pts, 2), new _SegWithIndex__WEBPACK_IMPORTED_MODULE_3__.SegWithIndex(t.pts, 3)];
        let segToReplace = 0;
        for (let i = 0;;) {
            const w = { canHaveStaircaseAtI: false };
            if (this.IsStaircase(t.pts, i, segs, w)) {
                t.canHaveStaircase = true;
                return i;
            }
            t.canHaveStaircase = t.canHaveStaircase || w.canHaveStaircaseAtI;
            i++;
            if (t.pts.length < i + 5) {
                return -1;
            }
            segs[segToReplace] = new _SegWithIndex__WEBPACK_IMPORTED_MODULE_3__.SegWithIndex(t.pts, i + 3);
            segToReplace++;
            segToReplace %= 4;
        }
    }
    static GetFlippedPoint(pts, offset) {
        const horiz = (0,_utils_compare__WEBPACK_IMPORTED_MODULE_2__.closeDistEps)(pts[offset].y, pts[offset + 1].y);
        return horiz ? new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(pts[offset + 4].x, pts[offset].y) : new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(pts[offset].x, pts[offset + 4].y);
    }
    // ignoring crossing at a
    Crossing(a, b, segsToIgnore) {
        return StaircaseRemover.IsCrossing(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(a, b), this.segTree, segsToIgnore);
    }
    // ignoring crossing at ls.Start
    static IsCrossing(ls, rTree, segsToIgnore) {
        for (const seg of rTree.GetAllIntersecting(ls.boundingBox))
            if (segsToIgnore.findIndex((p) => p === seg) === -1)
                return true;
        return false;
    }
    IntersectObstacleHierarchyPPP(a, b, c) {
        return this.IntersectObstacleHierarchyL(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(a, b)) || this.IntersectObstacleHierarchyL(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(b, c));
    }
    IntersectObstacleHierarchyL(ls) {
        return this.HierarchyOfObstacles.GetAllIntersecting(ls.boundingBox).some((poly) => _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.intersectionOne(ls, poly, false) != null);
    }
    IsStaircase(pts, offset, segsToIgnore, w) {
        const a = pts[offset];
        const b = pts[offset + 1];
        let c = pts[offset + 2];
        const d = pts[offset + 3];
        const f = pts[offset + 4];
        w.canHaveStaircaseAtI = false;
        if (_math_geometry__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(a, b) !== _math_geometry__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(c, d) ||
            _math_geometry__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(b, c) !== _math_geometry__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(d, f)) {
            return false;
        }
        c = StaircaseRemover.GetFlippedPoint(pts, offset);
        if (this.IntersectObstacleHierarchyPPP(b, c, d)) {
            return false;
        }
        w.canHaveStaircaseAtI = true;
        return !this.Crossing(b, c, segsToIgnore);
    }
    RemoveStaircasePN(pts, staircaseStart) {
        const a = pts[staircaseStart];
        const b = pts[staircaseStart + 1];
        const horiz = Math.abs(a.y - b.y) < _math_geometry__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon / 2;
        return this.RemoveStaircasePNB(pts, staircaseStart, horiz);
    }
    RemoveStaircasePNB(pts, staircaseStart, horiz) {
        this.RemoveSegs(pts);
        const ret = new Array(pts.length - 2);
        ArrayCopyAAN(pts, ret, staircaseStart + 1);
        const a = pts[staircaseStart + 1];
        const c = pts[staircaseStart + 3];
        ret[staircaseStart + 1] = horiz ? new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(c.x, a.y) : new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(a.x, c.y);
        ArrayCopyANANN(pts, staircaseStart + 4, ret, staircaseStart + 2, ret.length - staircaseStart - 2);
        this.InsertNewSegs(ret, staircaseStart);
        return ret;
    }
    RemoveSegs(pts) {
        for (let i = 0; i < pts.length - 1; i++) {
            this.RemoveSeg(new _SegWithIndex__WEBPACK_IMPORTED_MODULE_3__.SegWithIndex(pts, i));
        }
    }
    RemoveSeg(seg) {
        this.segTree.Remove(StaircaseRemover.Rect(seg), seg);
    }
    InsertNewSegs(pts, staircaseStart) {
        this.InsSeg(pts, staircaseStart);
        this.InsSeg(pts, staircaseStart + 1);
    }
    InitHierarchies() {
        for (const path of this.Paths) {
            this.InsertPathSegs(path);
        }
    }
    InsertPathSegs(path) {
        this.InsertSegs(path.PathPoints);
    }
    InsertSegs(pts) {
        for (let i = 0; i < pts.length - 1; i++) {
            this.InsSeg(pts, i);
        }
    }
    InsSeg(pts, i) {
        const seg = new _SegWithIndex__WEBPACK_IMPORTED_MODULE_3__.SegWithIndex(pts, i);
        this.segTree.Add(StaircaseRemover.Rect(seg), seg);
    }
    static Rect(seg) {
        return _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkPP(seg.Start, seg.End);
    }
}
function ArrayCopyANANN(a, ai, b, bi, length) {
    while (length-- > 0) {
        b[bi++] = a[ai++];
    }
}
function ArrayCopyAAN(a, b, length) {
    /*Assert.assert(a.length >= length)*/
    /*Assert.assert(b.length >= length)*/
    let i = 0;
    while (length-- > 0) {
        b[i++] = a[i++];
    }
}
//# sourceMappingURL=StaircaseRemover.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/rectilinear/obstacle.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Obstacle: () => (/* binding */ Obstacle)
/* harmony export */ });
/* harmony import */ var _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/compassVector.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/interactiveObstacleCalculator.js");
/* harmony import */ var _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/rectilinear/BasicObstacleSide.js");







class Obstacle {
    get PaddedPolyline() {
        return this._PaddedPolyline;
    }
    set PaddedPolyline(value) {
        this._PaddedPolyline = value;
    }
    get looseVisibilityPolyline() {
        if (this._looseVisibilityPolyline == null) {
            this._looseVisibilityPolyline = Obstacle.CreateLoosePolyline(this.VisibilityPolyline);
        }
        return this._looseVisibilityPolyline;
    }
    set looseVisibilityPolyline(value) {
        this._looseVisibilityPolyline = value;
    }
    GetPortChanges(t) {
        t.addedPorts = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.substractSets)(this.InputShape.Ports, this.Ports);
        t.removedPorts = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.substractSets)(this.Ports, this.InputShape.Ports);
        if (0 === t.addedPorts.size && 0 === t.removedPorts.size) {
            return false;
        }
        this.Ports = new Set(this.InputShape.Ports);
        return true;
    }
    get IsInConvexHull() {
        return this.ConvexHull != null;
    }
    get IsGroup() {
        return this.InputShape != null && this.InputShape.IsGroup;
    }
    get VisibilityBoundingBox() {
        return this.VisibilityPolyline.boundingBox;
    }
    get VisibilityPolyline() {
        return this.ConvexHull != null ? this.ConvexHull.Polyline : this.PaddedPolyline;
    }
    static CreateSentinel(a, b, scanDir, scanlineOrdinal) {
        const sentinel = Obstacle.mk(a, b, scanlineOrdinal);
        sentinel.CreateInitialSides(sentinel.PaddedPolyline.startPoint, scanDir);
        return sentinel;
    }
    CreateInitialSides(startPoint, scanDir) {
        /*Assert.assert(
          this.ActiveLowSide == null  && this.ActiveHighSide == null ,
          'Cannot call SetInitialSides when sides are already set',
        )*/
        this.ActiveLowSide = new _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_6__.LowObstacleSide(this, startPoint, scanDir);
        this.ActiveHighSide = new _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_6__.HighObstacleSide(this, startPoint, scanDir);
        if (scanDir.IsFlatS(this.ActiveHighSide)) {
            // No flat sides in the scanline; we'll do lookahead processing in the scanline to handle overlaps
            // with existing segments, and normal neighbor handling will take care of collinear OpenVertexEvents.
            this.ActiveHighSide = new _BasicObstacleSide__WEBPACK_IMPORTED_MODULE_6__.HighObstacleSide(this, this.ActiveHighSide.EndVertex, scanDir);
        }
    }
    constructor(shape, padding) {
        if (shape == null) {
            return;
        }
        this.PaddedPolyline = _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_5__.InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(shape.BoundaryCurve, padding);
        Obstacle.RoundVerticesAndSimplify(this.PaddedPolyline);
        this.IsRectangle = this.IsPolylineRectangle();
        this.InputShape = shape;
        this.Ports = new Set(this.InputShape.Ports);
    }
    static mk(a, b, scanlineOrdinal) {
        const obs = new Obstacle(null, 0);
        obs.PaddedPolyline = _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_3__.Polyline.mkClosedFromPoints([_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.RoundPoint(a), _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.RoundPoint(b)]);
        obs.Ordinal = scanlineOrdinal;
        return obs;
    }
    IsPolylineRectangle() {
        if (this.PaddedPolyline.count !== 4) {
            return false;
        }
        let ppt = this.PaddedPolyline.startPoint;
        let nextPpt = ppt.nextOnPolyline;
        let dir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.VectorDirectionPP(ppt.point, nextPpt.point);
        if (!_math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.IsPureDirection(dir)) {
            return false;
        }
        do {
            ppt = nextPpt;
            nextPpt = ppt.nextOnPolyline;
            const nextDir = _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.DirectionFromPointToPoint(ppt.point, nextPpt.point);
            // We know the polyline is clockwise.
            if (nextDir !== _math_geometry_compassVector__WEBPACK_IMPORTED_MODULE_0__.CompassVector.RotateRight(dir)) {
                return false;
            }
            dir = nextDir;
        } while (ppt !== this.PaddedPolyline.startPoint);
        return true;
    }
    static RoundVerticesAndSimplify(polyline) {
        /*Assert.assert(polyline.isClockwise(), 'Polyline is not clockwise')*/
        /*Assert.assert(polyline.closed)*/
        // Following creation of the padded border, round off the vertices for consistency
        // in later operations (intersections and event ordering).
        let ppt = polyline.startPoint;
        do {
            ppt.point = _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.RoundPoint(ppt.point);
            ppt = ppt.nextOnPolyline;
        } while (ppt !== polyline.startPoint);
        Obstacle.RemoveCloseAndCollinearVerticesInPlace(polyline);
        // We've modified the points so the BoundingBox may have changed; force it to be recalculated.
        polyline.setInitIsRequired();
        // Verify that the polyline is still clockwise.
        /*Assert.assert(
          polyline.isClockwise(),
          'Polyline is not clockwise after RoundVertices',
        )*/
    }
    // A single convex hull is shared by all obstacles contained by it and we only want one occurrence of that
    // convex hull's polyline in the visibility graph generation.
    get IsPrimaryObstacle() {
        return this.ConvexHull == null || this === this.ConvexHull.PrimaryObstacle;
    }
    static RemoveCloseAndCollinearVerticesInPlace(polyline) {
        const epsilon = _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon * 10;
        for (let pp = polyline.startPoint.next; pp != null; pp = pp.next) {
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.close(pp.prev.point, pp.point, epsilon)) {
                if (pp.next == null) {
                    polyline.RemoveEndPoint();
                }
                else {
                    pp.prev.next = pp.next;
                    pp.next.prev = pp.prev;
                }
            }
        }
        if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.close(polyline.start, polyline.end, epsilon)) {
            polyline.RemoveStartPoint();
        }
        polyline = polyline.RemoveCollinearVertices();
        if (polyline.endPoint.prev != null &&
            polyline.endPoint.prev !== polyline.startPoint &&
            _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.getTriangleOrientation(polyline.endPoint.prev.point, polyline.end, polyline.start) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Collinear) {
            polyline.RemoveEndPoint();
        }
        if (polyline.startPoint.next != null &&
            polyline.endPoint.prev !== polyline.startPoint &&
            _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.getTriangleOrientation(polyline.end, polyline.start, polyline.startPoint.next.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Collinear) {
            polyline.RemoveStartPoint();
        }
        polyline.setInitIsRequired();
        return polyline;
    }
    get isOverlapped() {
        return this.clump !== undefined && this.clump.length > 0;
    }
    get IsSentinel() {
        return this.InputShape == null;
    }
    IsInSameClump(other) {
        return this.isOverlapped && this.clump === other.clump;
    }
    Close() {
        this.ActiveLowSide = null;
        this.ActiveHighSide = null;
    }
    SetConvexHull(hull) {
        // This obstacle may have been in a rectangular obstacle or clump that was now found to overlap with a non-rectangular obstacle.
        this.clump = null;
        this.IsRectangle = false;
        this.ConvexHull = hull;
        this.looseVisibilityPolyline = null;
    }
    static CreateLoosePolyline(polyline) {
        const loosePolyline = _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_5__.InteractiveObstacleCalculator.CreatePaddedPolyline(polyline, _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon * 10);
        Obstacle.RoundVerticesAndSimplify(loosePolyline);
        return loosePolyline;
    }
    get IsTransparentAncestor() {
        return this.InputShape == null ? false : this.InputShape.IsTransparent;
    }
    set IsTransparentAncestor(value) {
        this.InputShape.IsTransparent = value;
    }
}
Obstacle.FirstSentinelOrdinal = 1;
Obstacle.FirstNonSentinelOrdinal = 10;
//# sourceMappingURL=obstacle.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/shape.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Shape: () => (/* binding */ Shape)
/* harmony export */ });
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");

let id_global = 0;
class Shape {
    get Parents() {
        return Array.from(this.parents.values());
    }
    get Children() {
        return Array.from(this.children.values());
    }
    get BoundaryCurve() {
        return this.boundaryCurve;
    }
    set BoundaryCurve(value) {
        this.boundaryCurve = value;
    }
    // The bounding box of the shape.
    get BoundingBox() {
        return this.BoundaryCurve.boundingBox;
    }
    // The set of Ports for this obstacle, usually RelativePorts.  In the event of overlapping
    // obstacles, this identifies the obstacle to which the port applies.
    get Ports() {
        return this.ports;
    }
    // Default constructor.
    static mkShape() {
        return new Shape(null);
    }
    /**  Constructor taking the curve of the shape.*/
    constructor(boundaryCurve = null) {
        this.parents = new Set();
        this.children = new Set();
        this.ports = new Set();
        this.BoundaryCurve = boundaryCurve;
    }
    /**  A group is a shape that has children.*/
    get IsGroup() {
        return this.children.size > 0;
    }
    *Descendants() {
        const q = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
        for (const shape of this.Children) {
            q.enqueue(shape);
        }
        while (q.length > 0) {
            const sh = q.dequeue();
            yield sh;
            for (const shape of sh.Children) {
                q.enqueue(shape);
            }
        }
    }
    *Ancestors() {
        const q = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
        for (const shape of this.Parents) {
            q.enqueue(shape);
        }
        while (q.length > 0) {
            const sh = q.dequeue();
            yield sh;
            for (const shape of sh.Parents) {
                q.enqueue(shape);
            }
        }
    }
    // Adds a parent. A shape can have several parents
    AddParent(shape) {
        this.parents.add(shape);
        shape.children.add(this);
    }
    AddChild(shape) {
        shape.parents.add(this);
        this.children.add(shape);
    }
    //
    RemoveChild(shape) {
        this.children.delete(shape);
        shape.parents.delete(this);
    }
    //
    RemoveParent(shape) {
        this.parents.delete(shape);
        shape.children.delete(this);
    }
    ToString() {
        return this.UserData ? this.UserData.toString() : 'null';
    }
}
//# sourceMappingURL=shape.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/splineRouter.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SplineRouter: () => (/* binding */ SplineRouter),
/* harmony export */   routeSplines: () => (/* binding */ routeSplines)
/* harmony export */ });
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/shape.js");
/* harmony import */ var _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js");
/* harmony import */ var _layout_core_geomEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/geomEdge.js");
/* harmony import */ var _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/relativeFloatingPort.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
/* harmony import */ var _spline_coneSpanner_LineSweeper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LineSweeper.js");
/* harmony import */ var _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _spline_coneSpanner_ConeSpanner__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSpanner.js");
/* harmony import */ var _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/hookUpAnywhereFromInsidePort.js");
/* harmony import */ var _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ClusterBoundaryPort.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/curvePort.js");
/* harmony import */ var _BundlingSettings__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/BundlingSettings.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _ShapeCreatorForRoutingToParents__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ShapeCreatorForRoutingToParents.js");
/* harmony import */ var _ShapeObstacleCalculator__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ShapeObstacleCalculator.js");
/* harmony import */ var _interactiveEdgeRouter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/interactiveEdgeRouter.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");
/* harmony import */ var _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/arrowhead.js");
/* harmony import */ var _visibility_Polygon__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/Polygon.js");
/* harmony import */ var _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/pointPairMap.js");
/* harmony import */ var _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/interactiveObstacleCalculator.js");
/* harmony import */ var _ShapeCreator__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ShapeCreator.js");
/* harmony import */ var _layout_driver__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/driver.js");
/* harmony import */ var _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/pointPair.js");
/* harmony import */ var _MultiEdgeRouter__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/MultiEdgeRouter.js");
/* harmony import */ var _spline_bundling_BundleRouter__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/BundleRouter.js");
/* harmony import */ var _spline_bundling_SdShortestPath__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/SdShortestPath.js");
/* harmony import */ var _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");
/* harmony import */ var _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/debugCurve.js");
/* harmony import */ var _spline_pathOptimizer__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/pathOptimizer.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _structs_graph__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/graph.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");
/* harmony import */ var _RelativeShape__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/RelativeShape.js");








































/**  routing edges around shapes */
class SplineRouter extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_5__.Algorithm {
    get ContinueOnOverlaps() {
        return this.continueOnOverlaps;
    }
    set ContinueOnOverlaps(value) {
        this.continueOnOverlaps = value;
    }
    get LoosePadding() {
        return this.loosePadding;
    }
    set LoosePadding(value) {
        this.loosePadding = value;
    }
    get MultiEdgesSeparation() {
        return this.multiEdgesSeparation;
    }
    set MultiEdgesSeparation(value) {
        this.multiEdgesSeparation = value;
    }
    static mk2(graph, edgeRoutingSettings) {
        return SplineRouter.mk5(graph, edgeRoutingSettings.Padding, edgeRoutingSettings.PolylinePadding, edgeRoutingSettings.ConeAngle, edgeRoutingSettings.bundlingSettings);
    }
    static mk4(graph, tightTightPadding, loosePadding, coneAngle) {
        return new SplineRouter(graph, Array.from(graph.deepEdges), tightTightPadding, loosePadding, coneAngle, null);
    }
    // Creates a spline group router for the given graph
    static mk5(graph, tightTightPadding, loosePadding, coneAngle, bundlingSettings) {
        return new SplineRouter(graph, Array.from(graph.deepEdges), tightTightPadding, loosePadding, coneAngle, bundlingSettings);
    }
    // Creates a spline group router for a given GeomGraph.
    constructor(graph, edges, tightPadding = 1, loosePadding = 2, coneAngle = 30 * (Math.PI / 180), bundlingSettings = null, cancelToken = null) {
        super(cancelToken);
        // setting this to true forces the calculation to go on even when node overlaps are present
        //
        this.continueOnOverlaps = true;
        this.shapesToTightLooseCouples = new Map();
        this.multiEdgesSeparation = 0.5;
        this.routeMultiEdgesAsBundles = true;
        // if set to true the algorithm will try to shortcut a shortest polyline inner points
        this.UsePolylineEndShortcutting = true;
        // if set to true the algorithm will try to shortcut a shortest polyline start and end
        this.UseInnerPolylingShortcutting = true;
        this.AllowedShootingStraightLines = true;
        this._overlapsDetected = false;
        this.edges = edges;
        this.BundlingSettings = bundlingSettings;
        this.geomGraph = graph;
        this.LoosePadding = loosePadding;
        this.tightPadding = tightPadding;
        this.coneAngle = coneAngle;
        this.routeMultiEdgesAsBundles = edges.length < 1000 && graph.deepNodeCount < 1000;
    }
    static mk6(graph, tightPadding, loosePadding, coneAngle, inParentEdges, outParentEdges) {
        const ret = SplineRouter.mk4(graph, tightPadding, loosePadding, coneAngle);
        const obstacles = _ShapeCreatorForRoutingToParents__WEBPACK_IMPORTED_MODULE_18__.ShapeCreatorForRoutingToParents.GetShapes(inParentEdges, outParentEdges);
        ret.Initialize(obstacles, coneAngle);
        return ret;
    }
    Initialize(obstacles, coneAngleValue) {
        this.rootShapes = obstacles.filter((s) => s.Parents == null || s.Parents.length === 0);
        this.coneAngle = coneAngleValue;
        if (this.coneAngle === 0) {
            this.coneAngle = Math.PI / 6;
        }
    }
    // Executes the algorithm.
    run() {
        if (this.edges.length == 0) {
            return;
        }
        if (this.geomGraph.isEmpty()) {
            return;
        }
        console.time('SplineRouter');
        const obstacles = _ShapeCreator__WEBPACK_IMPORTED_MODULE_27__.ShapeCreator.GetShapes(this.geomGraph, this.edges);
        if (this.BundlingSettings == null &&
            this.geomGraph.layoutSettings &&
            this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings &&
            this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings) {
            this.BundlingSettings = this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings;
        }
        this.Initialize(obstacles, this.coneAngle);
        this.GetOrCreateRoot();
        this.RouteOnRoot();
        this.RemoveRoot();
        console.timeEnd('SplineRouter');
    }
    /** Uses the existing routes and optimizing them only to avoid 'activeNodes'.   */
    rerouteOnSubsetOfNodes(activeNodes) {
        this.RouteMultiEdgesAsBundles = false;
        this.edges = Array.from(this.geomGraph.deepEdges).filter((e) => (0,_structs_graph__WEBPACK_IMPORTED_MODULE_37__.edgeNodesBelongToSet)(e.edge, activeNodes));
        const obstacles = _ShapeCreator__WEBPACK_IMPORTED_MODULE_27__.ShapeCreator.GetShapes(this.geomGraph, this.edges);
        this.rootShapes = obstacles.filter((s) => s.Parents == null || s.Parents.length === 0);
        this.GetOrCreateRoot();
        this.CalculateShapeToBoundaries(this.root);
        this.calcLooseShapesToNodes();
        this.CalculatePortsToShapes();
        this.rerouteOnActiveNodes(activeNodes);
        this.RemoveRoot();
    }
    calcLooseShapesToNodes() {
        this.loosePolylinesToNodes = new Map();
        if (!this.OverlapsDetected) {
            for (const [nodeShape, cpl] of this.shapesToTightLooseCouples) {
                this.loosePolylinesToNodes.set(cpl.LooseShape.BoundaryCurve, new Set([nodeShape.node.node]));
            }
            return;
        }
        const nodeTree = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.createRectangleNodeOnData)(this.geomGraph.nodesBreadthFirst, (n) => n.boundingBox);
        const looseTree = this.GetLooseHierarchy();
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_36__.CrossRectangleNodes)(looseTree, nodeTree, (poly, geomNode) => {
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_6__.Curve.CurveIsInsideOther(geomNode.boundaryCurve, poly)) {
                let polyNodes = this.loosePolylinesToNodes.get(poly);
                for (const an of geomNode.getAncestors()) {
                    if (an instanceof ___WEBPACK_IMPORTED_MODULE_17__.GeomGraph && an.parent == null)
                        continue;
                    if (an.boundaryCurve == null)
                        continue;
                    if (_math_geometry__WEBPACK_IMPORTED_MODULE_6__.Curve.CurveIsInsideOther(an.boundaryCurve, poly))
                        return; // we need to take an ancestor instead
                }
                if (polyNodes == null) {
                    this.loosePolylinesToNodes.set(poly, (polyNodes = new Set()));
                }
                polyNodes.add(geomNode.node);
            }
        });
    }
    RouteOnRoot() {
        (0,_utils_random__WEBPACK_IMPORTED_MODULE_38__.initRandom)(0);
        this.CalculatePortsToShapes();
        this.CalculatePortsToEnterableShapes();
        this.CalculateShapeToBoundaries(this.root);
        if (this.OverlapsDetected && !this.ContinueOnOverlaps) {
            return;
        }
        this.BindLooseShapes();
        this.SetLoosePolylinesForAnywherePorts();
        this.CalculateVisibilityGraph();
        this.RouteOnVisGraph();
    }
    CalculatePortsToEnterableShapes() {
        this.portsToEnterableShapes = new Map();
        for (const [port, shape] of this.portsToShapes) {
            const portShapes = new Set();
            if (!SplineRouter.EdgesAttachedToPortAvoidTheNode(port)) {
                portShapes.add(shape);
            }
            this.portsToEnterableShapes.set(port, portShapes);
        }
        for (const rootShape of this.rootShapes) {
            for (const sh of rootShape.Descendants()) {
                for (const port of sh.Ports) {
                    const enterableSet = this.portsToEnterableShapes.get(port);
                    (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.insertRange)(enterableSet, Array.from(sh.Ancestors()).filter((s) => s.BoundaryCurve != null));
                }
            }
        }
    }
    static EdgesAttachedToPortAvoidTheNode(port) {
        return port instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_15__.CurvePort || port instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_13__.ClusterBoundaryPort;
    }
    SetLoosePolylinesForAnywherePorts() {
        for (const [shape, cpl] of this.shapesToTightLooseCouples) {
            for (const port of shape.Ports) {
                const isHport = port instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_12__.HookUpAnywhereFromInsidePort;
                if (isHport) {
                    const aport = port;
                    aport.LoosePolyline = cpl.LooseShape.BoundaryCurve;
                }
                if (port instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_13__.ClusterBoundaryPort) {
                    const c = port;
                    c.LoosePolyline = cpl.LooseShape.BoundaryCurve;
                }
            }
        }
    }
    BindLooseShapes() {
        this.looseRoot = new _shape__WEBPACK_IMPORTED_MODULE_0__.Shape();
        for (const shape of this.root.Children) {
            const looseShape = this.shapesToTightLooseCouples.get(shape).LooseShape;
            this.BindLooseShapesUnderShape(shape);
            this.looseRoot.AddChild(looseShape);
        }
    }
    BindLooseShapesUnderShape(shape) {
        const loose = this.shapesToTightLooseCouples.get(shape).LooseShape;
        for (const child of shape.Children) {
            const childLooseShape = this.shapesToTightLooseCouples.get(child).LooseShape;
            loose.AddChild(childLooseShape);
            this.BindLooseShapesUnderShape(child);
        }
    }
    CalculateShapeToBoundaries(shape) {
        this.ProgressStep();
        if (shape.Children.length === 0) {
            return;
        }
        for (const child of shape.Children) {
            this.CalculateShapeToBoundaries(child);
        }
        let loosePaddingMax = Number.POSITIVE_INFINITY;
        if (shape instanceof _RelativeShape__WEBPACK_IMPORTED_MODULE_39__.RelativeShape) {
            const node = shape.node;
            const padding = node.padding;
            this.tightPadding = Math.min(this.tightPadding, 0.4 * padding);
            loosePaddingMax = 0.4 * padding;
        }
        this.obstacleCalculator = new _ShapeObstacleCalculator__WEBPACK_IMPORTED_MODULE_19__.ShapeObstacleCalculator(shape, this.tightPadding, Math.min(this.AdjustedLoosePadding, loosePaddingMax), this.shapesToTightLooseCouples);
        this.obstacleCalculator.Calculate(0.01);
        this.OverlapsDetected || (this.OverlapsDetected = this.obstacleCalculator.OverlapsDetected);
    }
    get OverlapsDetected() {
        return this._overlapsDetected;
    }
    set OverlapsDetected(value) {
        this._overlapsDetected = value;
    }
    get AdjustedLoosePadding() {
        return this.BundlingSettings == null ? this.LoosePadding : this.LoosePadding * _spline_bundling_BundleRouter__WEBPACK_IMPORTED_MODULE_31__.BundleRouter.SuperLoosePaddingCoefficient;
    }
    GroupEdgesByPassport() {
        const ret = new Array();
        for (const edge of this.edges) {
            const edgePassport = this.EdgePassport(edge); // todo : is ret.find() too slow?
            let pair = ret.find((p) => (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.setsAreEqual)(p.passport, edgePassport));
            if (!pair) {
                pair = { passport: edgePassport, edges: [] };
                ret.push(pair);
            }
            pair.edges.push(edge);
        }
        return ret;
    }
    RouteOnVisGraph() {
        this.ancestorSets = SplineRouter.GetAncestorSetsMap(Array.from(this.root.Descendants()));
        if (this.BundlingSettings == null) {
            const edgeGroups = this.GroupEdgesByPassport();
            for (let i = 0; i < edgeGroups.length; i++) {
                const edgeGroup = edgeGroups[i];
                const passport = edgeGroup.passport;
                const obstacleShapes = this.GetObstaclesFromPassport(passport);
                const interactiveEdgeRouter = this.CreateInteractiveEdgeRouter(Array.from(obstacleShapes));
                this.RouteEdgesWithTheSamePassport(edgeGroup, interactiveEdgeRouter, obstacleShapes);
            }
        }
        else {
            this.RouteBundles();
        }
    }
    rerouteOnActiveNodes(activeNodeSet) {
        this.ancestorSets = SplineRouter.GetAncestorSetsMap(Array.from(this.root.Descendants()));
        if (this.BundlingSettings == null) {
            for (const edgeGroup of this.GroupEdgesByPassport()) {
                const passport = edgeGroup.passport;
                const obstacleShapes = this.GetObstaclesFromPassport(passport);
                const filteredObstacleShapes = new Set();
                for (const sh of obstacleShapes) {
                    const lsh = this.LooseShapeOfOriginalShape(sh);
                    for (const n of this.loosePolylinesToNodes.get(lsh.BoundaryCurve)) {
                        if (activeNodeSet.has(n)) {
                            filteredObstacleShapes.add(sh);
                        }
                    }
                }
                const interactiveEdgeRouter = this.CreateInteractiveEdgeRouter(Array.from(filteredObstacleShapes));
                this.rerouteEdgesWithTheSamePassportActiveNodes(edgeGroup, interactiveEdgeRouter, filteredObstacleShapes, activeNodeSet);
            }
        }
        else {
            this.RouteBundles();
        }
    }
    getDebugCurvesFromEdgesAndCdt(cdt) {
        const ret = Array.from(this.geomGraph.deepEdges)
            .map((e) => e.curve)
            .filter((c) => c != null)
            .filter((c) => c.count > 5)
            .map((c) => _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_34__.DebugCurve.mkDebugCurveTWCI(200, 1, 'Red', c));
        for (const s of cdt.PointsToSites.values()) {
            for (const e of s.Edges) {
                ret.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_34__.DebugCurve.mkDebugCurveTWCI(200, 0.5, e.constrained ? 'Blue' : 'Green', _math_geometry__WEBPACK_IMPORTED_MODULE_6__.LineSegment.mkPP(e.lowerSite.point, e.upperSite.point)));
            }
        }
        return ret;
    }
    RouteEdgesWithTheSamePassport(edgeGeometryGroup, interactiveEdgeRouter, obstacleShapes) {
        const t = {
            regularEdges: [],
            multiEdges: [],
        };
        try {
            const cdtOnLooseObstacles = this.getCdtFromPassport(obstacleShapes);
            interactiveEdgeRouter.pathOptimizer.setCdt(cdtOnLooseObstacles);
        }
        catch (e) {
            interactiveEdgeRouter.pathOptimizer.setCdt(null);
        }
        if (this.RouteMultiEdgesAsBundles) {
            this.SplitOnRegularAndMultiedges(edgeGeometryGroup.edges, t);
            if (t.regularEdges.length > 0) {
                for (let i = 0; i < t.regularEdges.length; i++) {
                    this.routeEdge(interactiveEdgeRouter, t.regularEdges[i]);
                }
            }
            if (t.multiEdges != null) {
                this.ScaleDownLooseHierarchy(interactiveEdgeRouter, obstacleShapes);
                this.RouteMultiEdges(t.multiEdges, interactiveEdgeRouter, edgeGeometryGroup.passport);
            }
        }
        else {
            for (let i = 0; i < edgeGeometryGroup.edges.length; i++) {
                this.routeEdge(interactiveEdgeRouter, edgeGeometryGroup.edges[i]);
            }
        }
    }
    /** edgeToPolys maps edges to their original polyline routes */
    rerouteEdgesWithTheSamePassportActiveNodes(edgeGeometryGroup, interactiveEdgeRouter, obstacleShapes, activeNodes) {
        const t = {
            regularEdges: [],
            multiEdges: [],
        };
        try {
            const cdtOnLooseObstacles = this.getCdtFromPassport(obstacleShapes);
            interactiveEdgeRouter.pathOptimizer.setCdt(cdtOnLooseObstacles);
        }
        catch (e) {
            console.log(e);
            interactiveEdgeRouter.pathOptimizer.setCdt(null);
        }
        if (this.RouteMultiEdgesAsBundles) {
            this.SplitOnRegularAndMultiedges(edgeGeometryGroup.edges, t);
            if (t.regularEdges.length > 0) {
                for (let i = 0; i < t.regularEdges.length; i++) {
                    const e = t.regularEdges[i];
                    ___WEBPACK_IMPORTED_MODULE_17__.Assert.assert((0,_structs_graph__WEBPACK_IMPORTED_MODULE_37__.edgeNodesBelongToSet)(e.edge, activeNodes));
                    this.rerouteEdge(interactiveEdgeRouter, e);
                }
            }
            if (t.multiEdges != null) {
                this.ScaleDownLooseHierarchy(interactiveEdgeRouter, obstacleShapes);
                this.RouteMultiEdges(t.multiEdges, interactiveEdgeRouter, edgeGeometryGroup.passport);
            }
        }
        else {
            for (let i = 0; i < edgeGeometryGroup.edges.length; i++) {
                const e = edgeGeometryGroup.edges[i];
                if ((0,_structs_graph__WEBPACK_IMPORTED_MODULE_37__.edgeNodesBelongToSet)(e.edge, activeNodes)) {
                    this.rerouteEdge(interactiveEdgeRouter, e);
                }
            }
        }
    }
    /** poly gives the polyline to reroute */
    rerouteEdge(interactiveEdgeRouter, edge) {
        try {
            interactiveEdgeRouter.rerouteEdge(edge);
            _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_23__.Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.sourcePort.Curve, edge.targetPort.Curve, edge.curve, false);
        }
        catch (e) {
            console.log('failed');
            // It is fine for reroute to fail
            // Just do nothing in this case: the edge will remain unchanged.
            // this happens when the polyline corresponding to the edge is crossing a loose polyline, passinge too close to a node.
            // This might happen, for example, when the polyline was generated by from the Sugiyama layout.
            // Consider in the future to try to fix the polyline in this case, TODO
        }
    }
    getCdtFromPassport(passport) {
        // we need a set here because a loose polyline could be the same for different shapes
        // in the case of overlaps
        const loosePolys = new Set();
        const ports = [];
        // we cannot rely on the bounding box of the graph because it is not updated, or might be too large - would create thin triangles
        const bb = _math_geometry__WEBPACK_IMPORTED_MODULE_6__.Rectangle.mkEmpty();
        for (const shape of passport) {
            const lp = this.LoosePolyOfOriginalShape(shape);
            if (lp == null)
                continue;
            loosePolys.add(lp);
            for (const port of shape.Ports) {
                ports.push(port.Location);
            }
            bb.addRecSelf(lp.boundingBox);
        }
        bb.pad(Math.max(bb.diagonal / 4, 100));
        const lps = Array.from(loosePolys);
        lps.push(bb.perimeter()); // this will give some space for the edges to be routed near the graph border
        const cdt = new _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_33__.Cdt(ports, lps, []);
        cdt.run();
        return cdt;
    }
    // if set to true routes multi edges as ordered bundles
    get RouteMultiEdgesAsBundles() {
        return this.routeMultiEdgesAsBundles;
    }
    set RouteMultiEdgesAsBundles(value) {
        this.routeMultiEdgesAsBundles = value;
    }
    routeEdge(interactiveEdgeRouter, edge) {
        const transparentShapes = this.makeTransparentShapesOfEdgeAndGetTheShapes(edge);
        this.ProgressStep();
        this.RouteEdgeInternal(edge, interactiveEdgeRouter);
        SplineRouter.SetTransparency(transparentShapes, false);
    }
    ScaleDownLooseHierarchy(interactiveEdgeRouter, obstacleShapes) {
        const loosePolys = new Array();
        for (const obstacleShape of obstacleShapes) {
            const tl = this.shapesToTightLooseCouples.get(obstacleShape);
            loosePolys.push(_interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_26__.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tl.TightPolyline, tl.Distance / 1.1, // 1.1 is BundleRouter.SuperLoosePaddingCoefficient,
            0));
        }
        interactiveEdgeRouter.LooseHierarchy = SplineRouter.CreateLooseObstacleHierarachy(loosePolys);
        interactiveEdgeRouter.ClearActivePolygons();
        interactiveEdgeRouter.AddActivePolygons(loosePolys.map((poly) => new _visibility_Polygon__WEBPACK_IMPORTED_MODULE_24__.Polygon(poly)));
    }
    RouteMultiEdges(multiEdges, interactiveEdgeRouter, parents) {
        const nodeBoundaries = [];
        for (const p of parents) {
            for (const ch of p.Children)
                nodeBoundaries.push(ch.BoundaryCurve);
        }
        const bs = new _BundlingSettings__WEBPACK_IMPORTED_MODULE_16__.BundlingSettings();
        //giving more importance to ink might produce weird routings with huge detours, maybe 0 is the best value here
        bs.InkImportance = 0.00001;
        bs.EdgeSeparation = this.MultiEdgesSeparation;
        const mer = new _MultiEdgeRouter__WEBPACK_IMPORTED_MODULE_30__.MultiEdgeRouter(multiEdges, interactiveEdgeRouter, nodeBoundaries, bs, (a) => this.makeTransparentShapesOfEdgeAndGetTheShapes(a));
        mer.run();
    }
    SplitOnRegularAndMultiedges(edges, t) {
        const portLocationPairsToEdges = new _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_25__.PointPairMap();
        for (const eg of edges) {
            if (SplineRouter.IsEdgeToParent(eg)) {
                t.regularEdges.push(eg);
            }
            else {
                SplineRouter.RegisterInPortLocationsToEdges(eg, portLocationPairsToEdges);
            }
        }
        t.multiEdges = null;
        for (const edgeGroup of portLocationPairsToEdges.values()) {
            if (edgeGroup.length === 1 || this.OverlapsDetected) {
                (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.addRange)(t.regularEdges, edgeGroup);
            }
            else {
                if (t.multiEdges == null) {
                    t.multiEdges = new Array();
                }
                t.multiEdges.push(edgeGroup);
            }
        }
    }
    static RegisterInPortLocationsToEdges(eg, portLocationPairsToEdges) {
        let list;
        const pp = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_29__.PointPair(eg.sourcePort.Location, eg.targetPort.Location);
        list = portLocationPairsToEdges.get(pp);
        if (!list) {
            list = new Array();
            portLocationPairsToEdges.set(pp, list);
        }
        list.push(eg);
    }
    static IsEdgeToParent(e) {
        return e.sourcePort instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_12__.HookUpAnywhereFromInsidePort || e.targetPort instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_12__.HookUpAnywhereFromInsidePort;
    }
    CreateInteractiveEdgeRouter(obstacleShapes) {
        // we need to create a set here because one loose polyline can hold several original shapes
        const loosePolys = new Set(obstacleShapes.map((sh) => this.shapesToTightLooseCouples.get(sh).LooseShape.BoundaryCurve));
        const router = new _interactiveEdgeRouter__WEBPACK_IMPORTED_MODULE_20__.InteractiveEdgeRouter(this.cancelToken);
        router.pathOptimizer = new _spline_pathOptimizer__WEBPACK_IMPORTED_MODULE_35__.PathOptimizer();
        router.ObstacleCalculator = new _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_26__.InteractiveObstacleCalculator(obstacleShapes.map((sh) => sh.BoundaryCurve), this.tightPadding, this.loosePadding, false);
        router.VisibilityGraph = this.visGraph;
        router.TightHierarchy = this.CreateTightObstacleHierarachy(obstacleShapes);
        router.LooseHierarchy = SplineRouter.CreateLooseObstacleHierarachy(Array.from(loosePolys));
        router.UseSpanner = true;
        router.LookForRoundedVertices = true;
        router.TightPadding = this.tightPadding;
        router.LoosePadding = this.LoosePadding;
        router.UseEdgeLengthMultiplier = this.UseEdgeLengthMultiplier;
        router.UsePolylineEndShortcutting = this.UsePolylineEndShortcutting;
        router.UseInnerPolylingShortcutting = this.UseInnerPolylingShortcutting;
        router.AllowedShootingStraightLines = this.AllowedShootingStraightLines;
        router.AddActivePolygons(Array.from(loosePolys).map((polyline) => new _visibility_Polygon__WEBPACK_IMPORTED_MODULE_24__.Polygon(polyline)));
        return router;
    }
    GetObstaclesFromPassport(passport) {
        if (passport.size === 0) {
            return new Set(this.root.Children);
        }
        const commonAncestors = this.GetCommonAncestorsAbovePassport(passport);
        const allAncestors = this.GetAllAncestors(passport);
        const ret = new Set();
        for (const p of passport) {
            for (const child of p.Children) {
                if (!allAncestors.has(child))
                    ret.add(child);
            }
        }
        const enqueued = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.uniteSets)(new Set(passport), ret);
        const queue = new queue_typescript__WEBPACK_IMPORTED_MODULE_22__.Queue();
        for (const shape of passport) {
            if (!commonAncestors.has(shape))
                queue.enqueue(shape);
        }
        while (queue.length > 0) {
            const a = queue.dequeue();
            for (const parent of a.Parents) {
                for (const sibling of parent.Children) {
                    if (!allAncestors.has(sibling)) {
                        ret.add(sibling);
                    }
                }
                if (!commonAncestors.has(parent) && !enqueued.has(parent)) {
                    queue.enqueue(parent);
                    enqueued.add(parent);
                }
            }
        }
        return ret;
    }
    GetAllAncestors(passport) {
        if (passport.size === 0) {
            return new Set();
        }
        let ret = new Set(passport);
        for (const shape of passport) {
            ret = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.uniteSets)(ret, this.ancestorSets.get(shape));
        }
        return ret;
    }
    GetCommonAncestorsAbovePassport(passport) {
        if (passport.size === 0) {
            return new Set();
        }
        const en = Array.from(passport);
        let ret = this.ancestorSets.get(en[0]);
        for (let i = 1; i < en.length; i++) {
            const shape = en[i];
            ret = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.setIntersection)(ret, this.ancestorSets.get(shape));
        }
        return ret;
    }
    RouteBundles() {
        this.ScaleLooseShapesDown();
        this.CalculateEdgeEnterablePolylines();
        const looseHierarchy = this.GetLooseHierarchy();
        const cdt = (0,_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_33__.createCDTOnPolylineRectNode)(looseHierarchy);
        // CdtSweeper.ShowFront(cdt.GetTriangles(), null, null,this.visGraph.Edges.Select(e=>new LineSegment(e.SourcePoint,e.TargetPoint)));
        const shortestPath = new _spline_bundling_SdShortestPath__WEBPACK_IMPORTED_MODULE_32__.SdShortestPath((a) => this.makeTransparentShapesOfEdgeAndGetTheShapes(a), cdt, this.FindCdtGates(cdt));
        const bundleRouter = new _spline_bundling_BundleRouter__WEBPACK_IMPORTED_MODULE_31__.BundleRouter(this.edges, shortestPath, this.visGraph, this.BundlingSettings, this.LoosePadding, this.GetTightHierarchy(), looseHierarchy, this.enterableLoose, this.enterableTight, (port) => this.LoosePolyOfOriginalShape(this.portsToShapes.get(port)));
        bundleRouter.run();
    }
    CreateTheMapToParentLooseShapes(shape, loosePolylinesToLooseParentShapeMap) {
        for (const childShape of shape.Children) {
            const tightLooseCouple = this.shapesToTightLooseCouples.get(childShape);
            const poly = tightLooseCouple.LooseShape.BoundaryCurve;
            loosePolylinesToLooseParentShapeMap.set(poly, shape);
            this.CreateTheMapToParentLooseShapes(childShape, loosePolylinesToLooseParentShapeMap);
        }
    }
    FindCdtGates(cdt) {
        const loosePolylinesToLooseParentShapeMap = new Map();
        this.CreateTheMapToParentLooseShapes(this.root, loosePolylinesToLooseParentShapeMap);
        // looking for Cdt edges connecting two siblings; only those we define as gates
        const gates = new Set();
        for (const cdtSite of cdt.PointsToSites.values()) {
            for (const cdtEdge of cdtSite.Edges) {
                if (cdtEdge.CwTriangle == null && cdtEdge.CcwTriangle == null) {
                    continue;
                }
                const a = cdtSite.Owner;
                const b = cdtEdge.lowerSite.Owner;
                if (a === b) {
                    continue;
                }
                const aParent = loosePolylinesToLooseParentShapeMap.get(a);
                if (aParent) {
                    const bParent = loosePolylinesToLooseParentShapeMap.get(b);
                    if (aParent === bParent) {
                        gates.add(cdtEdge);
                    }
                }
            }
        }
        // CdtSweeper.ShowFront(cdt.GetTriangles(), null,
        //                    gates.Select(g => new LineSegment(g.upperSite.Point, g.lowerSite.Point)), null);
        return gates;
    }
    CalculateEdgeEnterablePolylines() {
        this.enterableLoose = new Map();
        this.enterableTight = new Map();
        for (const edge of this.edges) {
            const looseSet = new Set();
            const tightSet = new Set();
            this.GetEdgeEnterablePolylines(edge, looseSet, tightSet);
            this.enterableLoose.set(edge, looseSet);
            this.enterableTight.set(edge, tightSet);
        }
    }
    GetEdgeEnterablePolylines(edge, looseEnterable, tightEnterable) {
        const sourceShape = this.portsToShapes.get(edge.sourcePort);
        const targetShape = this.portsToShapes.get(edge.targetPort);
        if (sourceShape !== this.root) {
            this.GetEnterablesForShape(sourceShape, looseEnterable, tightEnterable);
        }
        if (targetShape !== this.root) {
            this.GetEnterablesForShape(targetShape, looseEnterable, tightEnterable);
        }
    }
    GetEnterablesForShape(shape, looseEnterable, tightEnterable) {
        for (const a of this.ancestorSets.get(shape)) {
            const la = this.LoosePolyOfOriginalShape(a);
            if (la) {
                looseEnterable.add(la);
            }
            const ta = this.TightPolyOfOriginalShape(a);
            if (ta) {
                tightEnterable.add(ta);
            }
        }
    }
    GetTightHierarchy() {
        return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.CreateRectNodeOnArrayOfRectNodes)(Array.from(this.shapesToTightLooseCouples.values()).map((tl) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.mkRectangleNode)(tl.TightPolyline, tl.TightPolyline.boundingBox)));
    }
    GetLooseHierarchy() {
        const loosePolylines = new Set();
        for (const t of this.shapesToTightLooseCouples.values()) {
            loosePolylines.add(t.LooseShape.BoundaryCurve);
        }
        return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.CreateRectNodeOnArrayOfRectNodes)(Array.from(loosePolylines).map((p) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.mkRectangleNode)(p, p.boundingBox)));
    }
    ScaleLooseShapesDown() {
        for (const [, tl] of this.shapesToTightLooseCouples) {
            tl.LooseShape.BoundaryCurve = _interactiveObstacleCalculator__WEBPACK_IMPORTED_MODULE_26__.InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tl.TightPolyline, tl.Distance / _spline_bundling_BundleRouter__WEBPACK_IMPORTED_MODULE_31__.BundleRouter.SuperLoosePaddingCoefficient, 0);
        }
    }
    /**
     * The set of shapes where the edge source and target ports shapes are citizens: the shapes who's interior the edge can cross
     *   In the simple case it is the union of the target port shape parents and the sourceport shape parents.
     *   When one end shape contains another, the passport is the set consisting of the end shape and all other shape parents.
     */
    EdgePassport(edge) {
        const ret = new Set();
        const sourceShape = this.portsToShapes.get(edge.sourcePort);
        const targetShape = this.portsToShapes.get(edge.targetPort);
        if (this.IsAncestor(sourceShape, targetShape)) {
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.insertRange)(ret, targetShape.Parents);
            ret.add(sourceShape);
            return ret;
        }
        if (this.IsAncestor(targetShape, sourceShape)) {
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.insertRange)(ret, sourceShape.Parents);
            ret.add(targetShape);
            return ret;
        }
        if (sourceShape !== this.looseRoot) {
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.insertRange)(ret, sourceShape.Parents);
        }
        if (targetShape !== this.looseRoot) {
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.insertRange)(ret, targetShape.Parents);
        }
        return ret;
    }
    *AllPorts() {
        for (const edge of this.edges) {
            yield edge.sourcePort;
            yield edge.targetPort;
        }
    }
    CalculatePortsToShapes() {
        this.portsToShapes = new Map();
        for (const shape of this.root.Descendants()) {
            for (const port of shape.Ports) {
                this.portsToShapes.set(port, shape);
            }
        }
        // assign all orphan ports to the root
        for (const port of this.AllPorts()) {
            if (!this.portsToShapes.has(port)) {
                this.root.Ports.add(port);
                this.portsToShapes.set(port, this.root);
            }
        }
    }
    RouteEdgeInternal(edge, iRouter) {
        const addedEdges = new Array();
        if (!(edge.sourcePort instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_12__.HookUpAnywhereFromInsidePort)) {
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.addRange)(addedEdges, this.AddVisibilityEdgesFromPort(edge.sourcePort));
        }
        if (!(edge.targetPort instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_12__.HookUpAnywhereFromInsidePort)) {
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_21__.addRange)(addedEdges, this.AddVisibilityEdgesFromPort(edge.targetPort));
        }
        const t = { smoothedPolyline: null };
        if (!_math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.closeDistEps(edge.sourcePort.Location, edge.targetPort.Location)) {
            edge.curve = iRouter.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(edge.sourcePort, edge.targetPort, true, t);
        }
        else {
            edge.curve = _layout_core_geomEdge__WEBPACK_IMPORTED_MODULE_2__.GeomEdge.RouteSelfEdge(edge.sourcePort.Curve, Math.max(this.LoosePadding * 2, edge.GetMaxArrowheadLength()), t);
        }
        edge.smoothedPolyline = null; // t.smoothedPolyline
        if (edge.curve == null) {
            throw new Error();
        }
        for (const visibilityEdge of addedEdges) {
            _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_10__.VisibilityGraph.RemoveEdge(visibilityEdge);
        }
        _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_23__.Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.sourcePort.Curve, edge.targetPort.Curve, edge.curve, false);
        //  SetTransparency(transparentShapes, false);
    }
    *AddVisibilityEdgesFromPort(port) {
        let portShape;
        let boundaryCouple;
        if (port instanceof _layout_core_curvePort__WEBPACK_IMPORTED_MODULE_15__.CurvePort ||
            !(portShape = this.portsToShapes.get(port)) ||
            !(boundaryCouple = this.shapesToTightLooseCouples.get(portShape))) {
            return;
        }
        const portLoosePoly = boundaryCouple.LooseShape;
        for (const point of portLoosePoly.BoundaryCurve) {
            if (this.visGraph.FindEdgePP(port.Location, point) == null)
                yield this.visGraph.AddEdgePP(port.Location, point);
        }
    }
    makeTransparentShapesOfEdgeAndGetTheShapes(edge) {
        // it is OK here to repeat a shape in the returned list
        const sourceShape = this.portsToShapes.get(edge.sourcePort);
        const targetShape = this.portsToShapes.get(edge.targetPort);
        const transparentLooseShapes = new Array();
        for (const shape of this.GetTransparentShapes(edge.sourcePort, edge.targetPort, sourceShape, targetShape)) {
            if (shape != null) {
                transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));
            }
        }
        for (const shape of this.portsToEnterableShapes.get(edge.sourcePort)) {
            transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));
        }
        for (const shape of this.portsToEnterableShapes.get(edge.targetPort)) {
            transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));
        }
        SplineRouter.SetTransparency(transparentLooseShapes, true);
        return transparentLooseShapes;
    }
    LooseShapeOfOriginalShape(s) {
        if (s === this.root) {
            return this.looseRoot;
        }
        return this.shapesToTightLooseCouples.get(s).LooseShape;
    }
    LoosePolyOfOriginalShape(s) {
        return this.LooseShapeOfOriginalShape(s).BoundaryCurve;
    }
    TightPolyOfOriginalShape(s) {
        if (s === this.root) {
            return null;
        }
        return this.shapesToTightLooseCouples.get(s).TightPolyline;
    }
    //    static GetEdgeColor(e: VisibilityEdge, sourcePort: Port, targetPort: Port): string {
    //  if (((sourcePort == null )
    //    || (targetPort == null ))) {
    //    return "green";
    //  }
    //  if ((closeDistEps(e.SourcePoint, sourcePort.Location)
    //    || (closeDistEps(e.SourcePoint, targetPort.Location)
    //      || (closeDistEps(e.TargetPoint, sourcePort.Location) || closeDistEps(e.TargetPoint, targetPort.Location))))) {
    //    return "lightgreen";
    //  }
    //  return "green";
    //  // TODO: Warning!!!, inline IF is not supported ?
    //  ((e.IsPassable == null )
    //    || e.IsPassable());
    //  "red";
    // }
    *GetTransparentShapes(sourcePort, targetPort, sourceShape, targetShape) {
        for (const s of this.ancestorSets.get(sourceShape)) {
            yield s;
        }
        for (const s of this.ancestorSets.get(targetShape)) {
            yield s;
        }
        if (!SplineRouter.EdgesAttachedToPortAvoidTheNode(sourcePort))
            yield sourceShape;
        if (!SplineRouter.EdgesAttachedToPortAvoidTheNode(targetPort))
            yield targetShape;
    }
    static SetTransparency(shapes, v) {
        for (const shape of shapes) {
            shape.IsTransparent = v;
        }
    }
    IsAncestor(possibleAncestor, possiblePredecessor) {
        let ancestors;
        return (possiblePredecessor != null && (ancestors = this.ancestorSets.get(possiblePredecessor)) != null && ancestors.has(possibleAncestor));
    }
    static CreateLooseObstacleHierarachy(loosePolys) {
        return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.CreateRectNodeOnArrayOfRectNodes)(loosePolys.map((poly) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.mkRectangleNode)(poly, poly.boundingBox)));
    }
    CreateTightObstacleHierarachy(obstacles) {
        const tightPolys = obstacles.map((sh) => this.shapesToTightLooseCouples.get(sh).TightPolyline);
        return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.CreateRectNodeOnArrayOfRectNodes)(tightPolys.map((tightPoly) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_14__.mkRectangleNode)(tightPoly, tightPoly.boundingBox)));
    }
    CalculateVisibilityGraph() {
        const setOfPortLocations = this.LineSweeperPorts != null ? _utils_PointSet__WEBPACK_IMPORTED_MODULE_8__.PointSet.mk(this.LineSweeperPorts) : new _utils_PointSet__WEBPACK_IMPORTED_MODULE_8__.PointSet();
        this.ProcessHookAnyWherePorts(setOfPortLocations);
        this.portRTree = (0,_math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_1__.mkRTree)(Array.from(setOfPortLocations.values()).map((p) => [_math_geometry__WEBPACK_IMPORTED_MODULE_6__.Rectangle.rectangleOnPoint(p), p]));
        this.visGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_10__.VisibilityGraph();
        this.FillVisibilityGraphUnderShape(this.root);
        // debug start
        //this.dumpSvg()
        // throw new Error()
    }
    // dumpSvg() {
    //  SplineRouter.ShowVisGraph(
    //    './tmp/vg.svg',
    //    this.visGraph,
    //    Array.from(new Set<Polyline>(Array.from(this.shapesToTightLooseCouples.values()).map((tl) => <Polyline>tl.LooseShape.BoundaryCurve))),
    //    Array.from(this.geomGraph.shallowNodes)
    //      .map((n) => n.boundaryCurve)
    //      .concat(Array.from(this.root.Descendants()).map((d) => d.BoundaryCurve)),
    //    null,
    //  )
    // }
    static ShowVisGraph(fileName, tmpVisGraph, obstacles, greenCurves = null, redCurves = null) {
        const l = Array.from(tmpVisGraph.Edges).map((e) => _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_34__.DebugCurve.mkDebugCurveTWCI(100, 1, e.IsPassable != null && e.IsPassable() ? 'green' : 'black', _math_geometry__WEBPACK_IMPORTED_MODULE_6__.LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));
        if (obstacles != null) {
            for (const p of obstacles) {
                l.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_34__.DebugCurve.mkDebugCurveTWCI(100, 0.3, 'brown', p));
                for (const t of p) {
                    l.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_34__.DebugCurve.mkDebugCurveTWCI(100, 1, 'green', _math_geometry__WEBPACK_IMPORTED_MODULE_6__.CurveFactory.mkCircle(1, t)));
                }
            }
        }
        if (greenCurves != null) {
            for (const p of greenCurves) {
                l.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_34__.DebugCurve.mkDebugCurveTWCI(100, 10, 'navy', p));
            }
        }
        if (redCurves != null) {
            for (const p of redCurves)
                l.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_34__.DebugCurve.mkDebugCurveTWCI(100, 10, 'red', p));
        }
        // SvgDebugWriter.dumpDebugCurves(fileName, l)
    }
    ProcessHookAnyWherePorts(setOfPortLocations) {
        for (const edge of this.edges) {
            if (!(edge.sourcePort instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_12__.HookUpAnywhereFromInsidePort || edge.sourcePort instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_13__.ClusterBoundaryPort)) {
                setOfPortLocations.add(edge.sourcePort.Location);
            }
            if (!(edge.targetPort instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_12__.HookUpAnywhereFromInsidePort || edge.targetPort instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_13__.ClusterBoundaryPort)) {
                setOfPortLocations.add(edge.targetPort.Location);
            }
        }
    }
    // this function might change the shape's loose polylines by inserting new points
    FillVisibilityGraphUnderShape(shape) {
        // going depth first
        const children = shape.Children;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            this.FillVisibilityGraphUnderShape(child);
        }
        const tightLooseCouple = this.shapesToTightLooseCouples.get(shape);
        const looseBoundary = tightLooseCouple ? tightLooseCouple.LooseShape.BoundaryCurve : null;
        const looseShape = tightLooseCouple ? tightLooseCouple.LooseShape : this.looseRoot;
        const obstacles = new Set(looseShape.Children.map((c) => c.BoundaryCurve));
        const portLocations = this.RemoveInsidePortsAndSplitBoundaryIfNeeded(looseBoundary);
        let tmpVisGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_10__.VisibilityGraph();
        let coneSpanner = _spline_coneSpanner_ConeSpanner__WEBPACK_IMPORTED_MODULE_11__.ConeSpanner.mk([], tmpVisGraph, this.coneAngle, portLocations, looseBoundary);
        coneSpanner.run();
        //SplineRouter.ShowVisGraph('c:/tmp/vg' + this.debcount++ + '.svg', tmpVisGraph, Array.from(obstacles))
        // now run the spanner again to create the correct visibility graph around the inner obstacles
        tmpVisGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_10__.VisibilityGraph();
        coneSpanner = _spline_coneSpanner_ConeSpanner__WEBPACK_IMPORTED_MODULE_11__.ConeSpanner.mk(Array.from(obstacles), tmpVisGraph, this.coneAngle, portLocations, looseBoundary);
        coneSpanner.run();
        // SplineRouter.ShowVisGraph('./tmp/splineRouter' + ++SplineRouter.debCount + '.svg', tmpVisGraph, Array.from(obstacles))
        this.ProgressStep();
        for (const edge of tmpVisGraph.Edges) {
            this.TryToCreateNewEdgeAndSetIsPassable(edge, looseShape);
        }
        this.AddBoundaryEdgesToVisGraph(looseBoundary);
        //            if (obstacles.Count > 0)
        //                SplineRouter.ShowVisGraph(tmpVisGraph, obstacles, null, null);
    }
    // #if TEST_MSAGL
    //     static internal void ShowVisGraph(VisibilityGraph tmpVisGraph, Iterable<Polyline> obstacles, Iterable<ICurve> greenCurves, Iterable<ICurve> redCurves) {
    //       var l = new Array<DebugCurve>(tmpVisGraph.Edges.Select(e => new DebugCurve(100, 1,
    //           e.IsPassable != null && e.IsPassable() ? "green" : "black"
    //           , new LineSegment(e.SourcePoint, e.TargetPoint))));
    //       if (obstacles != null)
    //         l.AddRange(obstacles.Select(p => new DebugCurve(100, 1, "brown", p)));
    //       if (greenCurves != null)
    //         l.AddRange(greenCurves.Select(p => new DebugCurve(100, 10, "navy", p)));
    //       if (redCurves != null)
    //         l.AddRange(redCurves.Select(p => new DebugCurve(100, 10, "red", p)));
    //       LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    //     }
    // #endif
    TryToCreateNewEdgeAndSetIsPassable(edge, looseShape) {
        let e = this.visGraph.FindEdgePP(edge.SourcePoint, edge.TargetPoint);
        if (e != null) {
            return;
        }
        e = this.visGraph.AddEdgePP(edge.SourcePoint, edge.TargetPoint);
        if (looseShape != null)
            e.IsPassable = () => looseShape.IsTransparent;
    }
    AddBoundaryEdgesToVisGraph(boundary) {
        if (boundary == null) {
            return;
        }
        let pn;
        for (let p = boundary.startPoint; true; p = pn) {
            pn = p.nextOnPolyline;
            this.visGraph.AddEdgePP(p.point, pn.point);
            if (pn === boundary.startPoint) {
                break;
            }
        }
    }
    /** this run will split the polyline enough to route later from the inner ports */
    RemoveInsidePortsAndSplitBoundaryIfNeeded(boundary) {
        const ret = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_8__.PointSet();
        if (boundary == null) {
            for (const point of this.portRTree.GetAllLeaves()) {
                ret.add(point);
            }
            this.portRTree.clear();
            return ret;
        }
        const boundaryBox = boundary.boundingBox;
        const portLocationsInQuestion = this.portRTree.GetAllIntersecting(boundaryBox);
        for (const point of portLocationsInQuestion) {
            switch (_math_geometry__WEBPACK_IMPORTED_MODULE_6__.Curve.PointRelativeToCurveLocation(point, boundary)) {
                case _math_geometry__WEBPACK_IMPORTED_MODULE_6__.PointLocation.Inside:
                    ret.add(point);
                    this.portRTree.Remove(_math_geometry__WEBPACK_IMPORTED_MODULE_6__.Rectangle.rectangleOnPoint(point), point);
                    break;
                case _math_geometry__WEBPACK_IMPORTED_MODULE_6__.PointLocation.Boundary:
                    this.portRTree.Remove(_math_geometry__WEBPACK_IMPORTED_MODULE_6__.Rectangle.rectangleOnPoint(point), point);
                    const polylinePoint = SplineRouter.FindPointOnPolylineToInsertAfter(boundary, point);
                    if (polylinePoint != null) {
                        _spline_coneSpanner_LineSweeper__WEBPACK_IMPORTED_MODULE_9__.LineSweeper.InsertPointIntoPolylineAfter(boundary, polylinePoint, point);
                    }
                    else {
                        throw new Error();
                    }
                    break;
            }
        }
        return ret;
    }
    static FindPointOnPolylineToInsertAfter(boundary, point) {
        for (let p = boundary.startPoint;;) {
            const pn = p.nextOnPolyline;
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.closeDistEps(point, p.point) || _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.closeDistEps(point, pn.point)) {
                return null;
            }
            // the point is already inside
            const dist = _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point.distToLineSegment(point, p.point, pn.point).dist;
            if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_7__.closeDistEps)(dist, 0)) {
                return p;
            }
            p = pn;
            if (p === boundary.startPoint) {
                throw new Error();
            }
        }
    }
    // creates a root; a shape with BoundaryCurve set to null
    GetOrCreateRoot() {
        if (this.rootShapes.length === 1) {
            const r = this.rootShapes[0];
            if (r.BoundaryCurve == null) {
                this.root = r;
                return;
            }
        }
        this.rootWasCreated = true;
        this.root = new _shape__WEBPACK_IMPORTED_MODULE_0__.Shape(null);
        for (const rootShape of this.rootShapes) {
            this.root.AddChild(rootShape);
        }
    }
    RemoveRoot() {
        if (!this.rootWasCreated)
            return;
        for (const rootShape of this.rootShapes) {
            rootShape.RemoveParent(this.root);
        }
        this.root = null;
        this.rootWasCreated = false;
    }
    // #if TEST_MSAGL
    //     // ReSharper disable UnusedMember.Local
    //     static void Show(
    //         Iterable<GeomEdge> edgeGeometries, Iterable<Shape> listOfShapes) {
    //       // ReSharper restore UnusedMember.Local
    //       var r = new Random(1);
    //       LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(
    //           listOfShapes.Select(s => s.BoundaryCurve).Select(
    //               c => new DebugCurve(50, 1, DebugCurve.Colors[r.Next(DebugCurve.Colors.Length - 1)], c)).Concat(
    //                   edgeGeometries.Select(e => new DebugCurve(100, 1, "red", e.Curve))));
    //     }
    // #endif
    static GetAncestorSetsMap(shapes) {
        const ancSets = new Map();
        for (const child of shapes.filter((child) => !ancSets.has(child))) {
            ancSets.set(child, SplineRouter.GetAncestorSet(child, ancSets));
        }
        return ancSets;
    }
    static GetAncestorSet(child, ancSets) {
        const ret = new Set(child.Parents);
        for (const parent of child.Parents) {
            let addition = ancSets.get(parent);
            if (!addition) {
                ancSets.set(parent, (addition = SplineRouter.GetAncestorSet(parent, ancSets)));
            }
            for (const t of addition)
                ret.add(t);
        }
        return ret;
    }
    static CreatePortsIfNeeded(edges) {
        for (const edge of edges) {
            if (edge.sourcePort == null) {
                const ed = edge;
                new _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_3__.RelativeFloatingPort(() => ed.source.boundaryCurve, () => ed.source.center, new _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0));
            }
            if (edge.targetPort == null) {
                const ed = edge;
                new _layout_core_relativeFloatingPort__WEBPACK_IMPORTED_MODULE_3__.RelativeFloatingPort(() => ed.target.boundaryCurve, () => ed.target.center, new _math_geometry_point__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0));
            }
        }
    }
}
function routeSplines(gg, edgesToRoute, cancelToken) {
    const ers = (0,_layout_driver__WEBPACK_IMPORTED_MODULE_28__.getEdgeRoutingSettingsFromAncestorsOrDefault)(gg);
    const sr = new SplineRouter(gg, edgesToRoute, ers.Padding, ers.PolylinePadding, ers.coneAngle, ers.bundlingSettings, cancelToken);
    sr.run();
}
//# sourceMappingURL=splineRouter.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/BundleBase.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BundleBase: () => (/* binding */ BundleBase)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");


class BundleBase {
    isCorrectlyOrienected() {
        const orientation = ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.Curve.boundingBox.center, this.Curve.value(this.parEnd), this.Curve.value(this.parStart));
        return orientation !== _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise;
    }
    get Count() {
        return this.points.length;
    }
    constructor(count, boundaryCurve, position, belongsToRealNode) {
        this.BelongsToRealNode = belongsToRealNode;
        this.Curve = boundaryCurve;
        this.Position = position;
        this.points = new Array(count);
        this.tangents = new Array(count);
        this.OrientedHubSegments = new Array(count);
    }
    get CurveCenter() {
        return this.Curve.boundingBox.center;
    }
    get OppositeBase() {
        return this.OutgoingBundleInfo != null ? this.OutgoingBundleInfo.TargetBase : this.IncomingBundleInfo.SourceBase;
    }
    get length() {
        return this.points.length;
    }
    get Points() {
        return this.points;
    }
    get Tangents() {
        return this.tangents;
    }
    get InitialMidParameter() {
        return this.initialMidParameter;
    }
    set InitialMidParameter(value) {
        this.initialMidParameter = value;
        this.InitialMidPoint = this.Curve.value(value);
    }
    /**
     * corresponds to the left point of the base: if looking from the center of
     * this.Curve.boundingBox.center
     */
    get ParStart() {
        return this.parStart;
    }
    set ParStart(value) {
        this.parStart = value;
        this.StartPoint = this.Curve.value(this.parStart);
    }
    /**
     * corresponds to the right point of the base: if looking from the center of
     * this.Curve.boundingBox.center */
    get ParEnd() {
        return this.parEnd;
    }
    set ParEnd(value) {
        this.parEnd = value;
        this.EndPoint = this.Curve.value(this.parEnd);
    }
    get ParMid() {
        return (this.parStart + this.parEnd) / 2;
    }
    get MidPoint() {
        return ___WEBPACK_IMPORTED_MODULE_0__.Point.middle(this.StartPoint, this.EndPoint);
    }
    get Span() {
        return this.SpanBetweenTwoParameters(this.parStart, this.parEnd);
    }
    SpanBetweenTwoParameters(start, end) {
        return start <= end ? end - start : end - start + (0,___WEBPACK_IMPORTED_MODULE_0__.parameterSpan)(this.Curve);
    }
    RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange) {
        if (rotationOfSourceLeftPoint === 0) {
            return this.EndPoint;
        }
        return this.RotatePoint(rotationOfSourceLeftPoint, this.parEnd, parameterChange);
    }
    RotateRigthPoint(rotationOfSourceRightPoint, parameterChange) {
        if (rotationOfSourceRightPoint === 0) {
            return this.StartPoint;
        }
        return this.RotatePoint(rotationOfSourceRightPoint, this.parStart, parameterChange);
    }
    RotatePoint(rotation, t, parameterChange) {
        const change = (0,___WEBPACK_IMPORTED_MODULE_0__.parameterSpan)(this.Curve) * parameterChange;
        t += rotation * change;
        t = this.AdjustParam(t);
        return this.Curve.value(t);
    }
    AdjustParam(t) {
        if (t > this.Curve.parEnd)
            t = this.Curve.parStart + (t - this.Curve.parEnd);
        else if (t < this.Curve.parStart)
            t = this.Curve.parEnd - (this.Curve.parStart - t);
        return t;
    }
    RotateBy(rotationOfRightPoint, rotationOfLeftPoint, parameterChange) {
        const change = (0,___WEBPACK_IMPORTED_MODULE_0__.parameterSpan)(this.Curve) * parameterChange;
        if (rotationOfRightPoint !== 0) {
            this.ParStart = this.AdjustParam(this.ParStart + rotationOfRightPoint * change);
        }
        if (rotationOfLeftPoint !== 0) {
            this.ParEnd = this.AdjustParam(this.ParEnd + rotationOfLeftPoint * change);
        }
    }
    RelativeOrderOfBasesIsPreserved(rotationOfRightPoint, rotationOfLeftPoint, parameterChange) {
        const change = (0,___WEBPACK_IMPORTED_MODULE_0__.parameterSpan)(this.Curve) * parameterChange;
        //we do not swap parRight and parLeft
        const rnew = this.parStart + rotationOfRightPoint * change;
        const lnew = this.parStart < this.parEnd
            ? this.parEnd + rotationOfLeftPoint * change
            : this.parEnd + (0,___WEBPACK_IMPORTED_MODULE_0__.parameterSpan)(this.Curve) + rotationOfLeftPoint * change;
        if (rnew > lnew)
            return false;
        //span could not be greater than pi
        if (this.SpanBetweenTwoParameters(rnew, lnew) > (0,___WEBPACK_IMPORTED_MODULE_0__.parameterSpan)(this.Curve) / 2.0)
            return false;
        //the base is the only base in the hub
        if (this.Prev == null)
            return true;
        //distance between mid points is larger than parameterChange => we can't change the order
        if (this.SpanBetweenTwoParameters(this.Prev.ParMid, this.ParMid) > change &&
            this.SpanBetweenTwoParameters(this.ParMid, this.Next.ParMid) > change)
            return true;
        const rSoP = this.RotateLeftPoint(rotationOfLeftPoint, parameterChange);
        const lSoP = this.RotateRigthPoint(rotationOfRightPoint, parameterChange);
        const newMidPoint = ___WEBPACK_IMPORTED_MODULE_0__.Point.middle(rSoP, lSoP);
        const curMidPoint = this.MidPoint;
        //check Prev
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, curMidPoint) !=
            ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, newMidPoint))
            return false;
        //Next
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, curMidPoint) !=
            ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, newMidPoint))
            return false;
        return true;
    }
}
//# sourceMappingURL=BundleBase.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/BundleBasesCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BundleBasesCalculator: () => (/* binding */ BundleBasesCalculator)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _BundleBase__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/BundleBase.js");
/* harmony import */ var _BundleInfo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/BundleInfo.js");
/* harmony import */ var _MetroGraphData__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/MetroGraphData.js");
/* harmony import */ var _OrientedHubSegment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/OrientedHubSegment.js");









class BundleBasesCalculator {
    constructor(metroOrdering, metroGraphData, bundlingSettings) {
        this.fixedBundles = new Set();
        // the cooling scheme follows Yifan Hu, Efficient and high quality force-directed graph drawing
        this.stepsWithProgress = 0;
        this.metroOrdering = metroOrdering;
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
    }
    Run() {
        // HubDebugger.ShowHubs(metroGraphData, bundlingSettings, true);
        // HubDebugger.ShowHubs(metroGraphData, bundlingSettings);
        this.AllocateBundleBases();
        this.SetBasesRightLeftParamsToTheMiddles();
        if (this.bundlingSettings.KeepOverlaps) {
            this.UpdateSourceAndTargetBases();
            this.CreateOrientedSegs();
        }
        else {
            this.SetRightLeftParamsFeasiblySymmetrically();
            // EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);
            // these bases can be too wide and overlap each other, so we need to adjust them
            this.AdjustStartEndParamsToAvoidBaseOverlaps();
            this.UpdateSourceAndTargetBases();
            // EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);
            this.CreateOrientedSegs();
            // EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);
            // optimization: moving bases to reduce cost
            // TimeMeasurer.DebugOutput("Initial cost of bundle bases: " + Cost());
            if (this.bundlingSettings.RotateBundles)
                this.RotateBundlesToDiminishCost();
            // EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);
            this.AdjustStartEndParamsToAvoidBaseOverlaps();
            this.UpdateSourceAndTargetBases();
        }
        // TimeMeasurer.DebugOutput("Optimized cost of bundle bases: " + Cost());
        //            EdgeNudger.ShowHubs(metroGraphData, metroOrdering, null);
    }
    AllocateBundleBases() {
        this.externalBases = new Map();
        this.internalBases = new Map();
        this.Bundles = new Array();
        for (const station of this.metroGraphData.Stations) {
            if (station.BoundaryCurve == null)
                station.BoundaryCurve = _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_2__.Ellipse.mkCircle(station.Radius, station.Position);
        }
        for (const station of this.metroGraphData.Stations) {
            for (const neighbor of station.Neighbors) {
                if (station.SerialNumber < neighbor.SerialNumber) {
                    const bb = new _BundleBase__WEBPACK_IMPORTED_MODULE_5__.BundleBase(this.metroGraphData.RealEdgeCount(station, neighbor), station.BoundaryCurve, station.Position, station.IsReal);
                    station.BundleBases.set(neighbor, bb);
                    const bb2 = new _BundleBase__WEBPACK_IMPORTED_MODULE_5__.BundleBase(this.metroGraphData.RealEdgeCount(station, neighbor), neighbor.BoundaryCurve, neighbor.Position, neighbor.IsReal);
                    neighbor.BundleBases.set(station, bb2);
                    if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.PointRelativeToCurveLocation(neighbor.Position, station.BoundaryCurve) !== _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Outside) {
                        bb.IsParent = true;
                        (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.addToMapOfArrays)(this.internalBases, station, bb);
                        (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.addToMapOfArrays)(this.externalBases, neighbor, bb2);
                    }
                    else if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.PointRelativeToCurveLocation(station.Position, neighbor.BoundaryCurve) !== _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Outside) {
                        bb2.IsParent = true;
                        (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.addToMapOfArrays)(this.externalBases, station, bb);
                        (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.addToMapOfArrays)(this.internalBases, neighbor, bb2);
                    }
                    else {
                        (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.addToMapOfArrays)(this.externalBases, station, bb);
                        (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.addToMapOfArrays)(this.externalBases, neighbor, bb2);
                    }
                    const obstaclesToIgnore = this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(station, neighbor);
                    const bundle = new _BundleInfo__WEBPACK_IMPORTED_MODULE_6__.BundleInfo(bb, bb2, obstaclesToIgnore, Array.from(this.metroOrdering.GetOrder(station, neighbor)).map((l) => l.Width / 2));
                    bb.OutgoingBundleInfo = bb2.IncomingBundleInfo = bundle;
                    this.Bundles.push(bundle);
                }
            }
        }
        //neighbors
        this.SetBundleBaseNeighbors();
    }
    SetBundleBaseNeighbors() {
        for (const c of this.externalBases.keys()) {
            const list = this.externalBases.get(c);
            this.SortBundlesCounterClockwise(list);
            //set left
            this.SetLeftRightBases(list);
        }
        for (const c of this.internalBases.keys()) {
            const list = this.internalBases.get(c);
            this.SortBundlesCounterClockwise(list);
            //set left
            this.SetLeftRightBases(list);
        }
    }
    SortBundlesCounterClockwise(list) {
        if (list.length > 2) {
            const pivot = list[0].OppositeBase.Position;
            const center = list[0].CurveCenter;
            list.sort((u, v) => {
                return (0,_MetroGraphData__WEBPACK_IMPORTED_MODULE_7__.getOrientationOf3Vectors)(pivot.sub(center), u.OppositeBase.Position.sub(center), v.OppositeBase.Position.sub(center));
            });
        }
    }
    SetLeftRightBases(bases) {
        const count = bases.length;
        if (count <= 1) {
            return;
        }
        for (let i = 0; i < count; i++) {
            bases[i].Prev = bases[(i - 1 + count) % count];
            bases[i].Next = bases[(i + 1) % count];
        }
    }
    CreateOrientedSegs() {
        for (const metroline of this.metroGraphData.Metrolines) {
            this.CreateOrientedSegsOnLine(metroline);
        }
    }
    CreateOrientedSegsOnLine(line) {
        for (let polyPoint = line.Polyline.startPoint.next; polyPoint.next != null; polyPoint = polyPoint.next) {
            this.CreateOrientedSegsOnLineVertex(line, polyPoint);
        }
    }
    CreateOrientedSegsOnLineVertex(line, polyPoint) {
        const u = this.metroGraphData.PointToStations.get(polyPoint.prev.point);
        const v = this.metroGraphData.PointToStations.get(polyPoint.point);
        const w = this.metroGraphData.PointToStations.get(polyPoint.next.point);
        const h0 = v.BundleBases.get(u);
        const h1 = v.BundleBases.get(w);
        const j0 = this.metroOrdering.GetLineIndexInOrder(u, v, line);
        const j1 = this.metroOrdering.GetLineIndexInOrder(w, v, line);
        const or0 = (h0.OrientedHubSegments[j0] = new _OrientedHubSegment__WEBPACK_IMPORTED_MODULE_8__.OrientedHubSegment(null, false, j0, h0));
        const or1 = (h1.OrientedHubSegments[j1] = new _OrientedHubSegment__WEBPACK_IMPORTED_MODULE_8__.OrientedHubSegment(null, true, j1, h1));
        or1.Other = or0;
        or0.Other = or1;
    }
    UpdateSourceAndTargetBases() {
        for (const bundleInfo of this.Bundles) {
            bundleInfo.UpdateSourceAndTargetBases(true, true);
        }
    }
    SetBasesRightLeftParamsToTheMiddles() {
        for (const bundle of this.Bundles) {
            const sbase = bundle.SourceBase;
            const tbase = bundle.TargetBase;
            sbase.ParEnd = sbase.ParStart = this.GetBaseMiddleParamInDirection(sbase, sbase.Position, tbase.Position);
            tbase.ParEnd = tbase.ParStart = this.GetBaseMiddleParamInDirection(tbase, tbase.Position, sbase.Position);
        }
    }
    GetBaseMiddleParamInDirection(targetBase, sPos, neighbPos) {
        const curve = targetBase.Curve;
        const isCircle = curve instanceof _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_2__.Ellipse;
        if (isCircle) {
            const circle = curve;
            if (circle.isArc()) {
                return _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.angle(circle.aAxis, neighbPos.sub(sPos));
            }
        }
        const intersections = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.getAllIntersections(curve, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(sPos, neighbPos), true);
        for (const intersectionInfo of intersections) {
            const xP = intersectionInfo.x;
            if (xP.sub(sPos).dot(xP.sub(neighbPos)) <= 0) {
                return intersectionInfo.par0;
            }
        }
        // SvgDebugWriter.dumpDebugCurves('./tmp/baseMiddle.svg', [
        //  DebugCurve.mkDebugCurveTWCI(100, 1, 'Red', curve),
        //  DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', LineSegment.mkPP(sPos, neighbPos)),
        // ])
        throw new Error();
    }
    SetRightLeftParamsFeasiblySymmetrically() {
        for (const bundle of this.Bundles) {
            bundle.SetParamsFeasiblySymmetrically(this.metroGraphData.TightTree);
        }
    }
    AdjustStartEndParamsToAvoidBaseOverlaps() {
        for (const c of this.externalBases.values())
            this.AdjustCurrentBundleWidthsOnCurve(c);
        for (const c of this.internalBases.values())
            this.AdjustCurrentBundleWidthsOnCurve(c);
    }
    AdjustCurrentBundleWidthsOnCurve(bases) {
        const count = bases.length;
        if (count <= 1)
            return;
        for (let i = 0; i < count; i++) {
            const rBase = bases[i];
            const lBase = rBase.Next;
            this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(rBase, lBase);
            // Assert.assert(rBase.isCorrectlyOrienected() && lBase.isCorrectlyOrienected())
        }
    }
    ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(rBase, lBase) {
        const interval = intersectBases(rBase, lBase);
        if (interval == null)
            return;
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_3__.closeDistEps)(interval.start, interval.end))
            return;
        const rM = interval.rbaseMiddle;
        const lM = interval.lbaseMiddle;
        if (rM < lM) {
            //swap
            const t = rBase;
            rBase = lBase;
            lBase = t;
        }
        const rBaseSpan = rBase.Span;
        const lBaseSpan = lBase.Span;
        const x = (interval.end * rBaseSpan + interval.start * lBaseSpan) / (lBaseSpan + rBaseSpan);
        rBase.ParStart = rBase.AdjustParam(x + _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon);
        lBase.ParEnd = lBase.AdjustParam(x - _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon);
        // Assert.assert(intersectBases(rBase, lBase) == null )
    }
    // find a cut point for 2 segments
    RegularCut(l1, r1, l2, r2, span1, span2) {
        let cutParam = (span1 * r2 + span2 * l1) / (span1 + span2);
        const mn = Math.min(r1, r2);
        const mx = Math.max(l1, l2);
        // //Assert.assert((lessOrEqual(mx, cutParam) && ApproximateComparer.LessOrEqual(cutParam, mn)));
        if (cutParam < mx) {
            cutParam = mx;
        }
        if (cutParam > mn) {
            cutParam = mn;
        }
        return cutParam;
    }
    RotateBundlesToDiminishCost() {
        let parameterChange = BundleBasesCalculator.MaxParameterChange;
        const t = { cost: this.Cost() };
        let iteration = 0;
        // HubDebugger.ShowHubs(metroGraphData, bundlingSettings, true);
        while (iteration++ < BundleBasesCalculator.MaxIterations) {
            const oldCost = t.cost;
            this.RotateBundlesToDiminishCostOneIteration(parameterChange, t);
            parameterChange = this.UpdateParameterChange(parameterChange, oldCost, t.cost);
            if (parameterChange < BundleBasesCalculator.MinParameterChange) {
                break;
            }
        }
        // TimeMeasurer.DebugOutput("bases optimization completed after " + iteration + " iterations (cost=" + cost + ")");
    }
    UpdateParameterChange(step, oldEnergy, newEnergy) {
        // cooling factor
        const T = 0.8;
        if (newEnergy + 1 < oldEnergy) {
            this.stepsWithProgress++;
            if (this.stepsWithProgress >= 5) {
                this.stepsWithProgress = 0;
                // step = Math.Min(MaxParameterChange, step / T);
                this.fixedBundles.clear();
            }
        }
        else {
            this.stepsWithProgress = 0;
            step *= T;
            this.fixedBundles.clear();
        }
        return step;
    }
    RotateBundlesToDiminishCostOneIteration(parameterChange, t) {
        let progress = false;
        for (const bundleInfo of this.Bundles) {
            if (this.fixedBundles.has(bundleInfo))
                continue;
            if (this.OptimizeBundle(bundleInfo, parameterChange, t)) {
                progress = true;
                /*bool isClusterS = bundleInfo.SourceBase.CurveCenter !== bundleInfo.SourceBase.Position;
                            bool isClusterT = bundleInfo.TargetBase.CurveCenter !== bundleInfo.TargetBase.Position;
                            while ((isClusterS || isClusterT) && OptimizeBundle(bundleInfo, parameterChange, ref cost)) { }*/
            }
            else
                this.fixedBundles.add(bundleInfo);
        }
        return progress;
    }
    OptimizeBundle(bundleInfo, parameterChange, t) {
        const bundleCost = this.CostBi(bundleInfo);
        if (bundleCost < BundleBasesCalculator.CostThreshold) {
            return false;
        }
        // choose the best step
        let bestDelta = 0;
        let bestJ = -1;
        let bestI = -1;
        for (let i = 0; i < BundleBasesCalculator.Deltas.length - 1; i++) {
            let delta = this.DeltaWithChangedAngles(BundleBasesCalculator.Deltas[i][0], BundleBasesCalculator.Deltas[i][1], 0, 0, bundleInfo, bundleCost, parameterChange);
            if (delta > BundleBasesCalculator.CostDeltaThreshold && delta > bestDelta) {
                bestI = i;
                bestJ = BundleBasesCalculator.Deltas.length - 1;
                bestDelta = delta;
            }
            delta = this.DeltaWithChangedAngles(0, 0, BundleBasesCalculator.Deltas[i][0], BundleBasesCalculator.Deltas[i][1], bundleInfo, bundleCost, parameterChange);
            if (delta > BundleBasesCalculator.CostDeltaThreshold && delta > bestDelta) {
                bestI = BundleBasesCalculator.Deltas.length - 1;
                bestJ = i;
                bestDelta = delta;
            }
        }
        if (bestDelta < BundleBasesCalculator.CostDeltaThreshold) {
            return false;
        }
        t.cost -= bestDelta;
        bundleInfo.RotateBy(BundleBasesCalculator.Deltas[bestI][0], BundleBasesCalculator.Deltas[bestI][1], BundleBasesCalculator.Deltas[bestJ][0], BundleBasesCalculator.Deltas[bestJ][1], parameterChange);
        return true;
    }
    DeltaWithChangedAngles(rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, bundleInfo, bundleCost, parameterChange) {
        if (!bundleInfo.RotationIsLegal(rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, parameterChange)) {
            return 0;
        }
        bundleInfo.RotateBy(rotationOfSourceRigthPoint, rotationOfSourceLeftPoint, rotationOfTargetRigthPoint, rotationOfTargetLeftPoint, parameterChange);
        const newCost = this.CostBN(bundleInfo, bundleCost);
        // restoring
        bundleInfo.RotateBy(rotationOfSourceRigthPoint * -1, rotationOfSourceLeftPoint * -1, rotationOfTargetRigthPoint * -1, rotationOfTargetLeftPoint * -1, parameterChange);
        return bundleCost - newCost;
    }
    CostBi(bundleInfo) {
        return (BundleBasesCalculator.SeparationCoeff * this.SeparationCost(bundleInfo) +
            (BundleBasesCalculator.SqueezeCoeff * this.SqueezeCost(bundleInfo) +
                (BundleBasesCalculator.AssymetryCoeff * this.AssymetryCost(bundleInfo) +
                    BundleBasesCalculator.CenterCoeff * this.CenterCostBi(bundleInfo))));
    }
    // this is an accelerated version of the above function (calculate cost partly)
    CostBN(bundleInfo, limit) {
        let cost = 0;
        cost = cost + BundleBasesCalculator.CenterCoeff * this.CenterCostBi(bundleInfo);
        if (cost > limit) {
            return cost;
        }
        cost = cost + BundleBasesCalculator.SeparationCoeff * this.SeparationCost(bundleInfo);
        if (cost > limit) {
            return cost;
        }
        cost = cost + BundleBasesCalculator.SqueezeCoeff * this.SqueezeCost(bundleInfo);
        if (cost > limit) {
            return cost;
        }
        cost = cost + BundleBasesCalculator.AssymetryCoeff * this.AssymetryCost(bundleInfo);
        return cost;
    }
    SqueezeCost(bundleInfo) {
        const middleLineDir = bundleInfo.TargetBase.MidPoint.sub(bundleInfo.SourceBase.MidPoint).normalize();
        const perp = middleLineDir.rotate90Ccw();
        const projecton0 = Math.abs(bundleInfo.SourceBase.StartPoint.sub(bundleInfo.SourceBase.EndPoint).dot(perp));
        const projecton1 = Math.abs(bundleInfo.TargetBase.StartPoint.sub(bundleInfo.TargetBase.EndPoint).dot(perp));
        const del0 = Math.abs(bundleInfo.TotalRequiredWidth - projecton0) / bundleInfo.TotalRequiredWidth;
        const del1 = Math.abs(bundleInfo.TotalRequiredWidth - projecton1) / bundleInfo.TotalRequiredWidth;
        const del = Math.abs(projecton0 - projecton1) / bundleInfo.TotalRequiredWidth;
        const cost = Math.exp(del0 * 10) - 1 + (Math.exp(del1 * 10) - 1);
        return cost + del;
    }
    CenterCostBi(bundleInfo) {
        if (!bundleInfo.SourceBase.BelongsToRealNode && !bundleInfo.TargetBase.BelongsToRealNode) {
            return 0;
        }
        return this.CenterCostBb(bundleInfo.SourceBase) + this.CenterCostBb(bundleInfo.TargetBase);
    }
    CenterCostBb(bundleBase) {
        if (!bundleBase.BelongsToRealNode) {
            return 0;
        }
        const currentMid = bundleBase.ParMid;
        const mn = Math.min(bundleBase.InitialMidParameter, currentMid);
        const mx = Math.max(bundleBase.InitialMidParameter, currentMid);
        const dist = Math.min(mx - mn, mn + ((0,_math_geometry__WEBPACK_IMPORTED_MODULE_1__.parameterSpan)(bundleBase.Curve) - mx));
        if (bundleBase.CurveCenter.equal(bundleBase.Position) || bundleBase.IsParent) {
            return 25 * (dist * dist);
        }
        else {
            return 500 * (dist * dist);
        }
    }
    AssymetryCost(bundleInfo) {
        return this.GetAssymetryCostForBase(bundleInfo.SourceBase) + this.GetAssymetryCostForBase(bundleInfo.TargetBase);
    }
    GetAssymetryCostForBase(bundleBase) {
        if (bundleBase.BelongsToRealNode) {
            return 0;
        }
        const assymetryWeight = bundleBase.OppositeBase.BelongsToRealNode ? 200 : 500;
        let cost = 0;
        for (const o of bundleBase.OrientedHubSegments) {
            const i0 = o.Index;
            const i1 = o.Other.Index;
            const a = bundleBase.Points[i0];
            const ta = bundleBase.Tangents[i0];
            const oppositeBase = o.Other.BundleBase;
            const b = oppositeBase.Points[i1];
            const tb = oppositeBase.Tangents[i1];
            const s = bundleBase.Count + oppositeBase.Count;
            cost += this.GetAssymetryCostOnData(a, ta, b, tb, assymetryWeight) / s;
        }
        return cost;
    }
    GetAssymetryCostOnData(a, tangentA, b, tangentB, assymetryWeight) {
        const xAxis = a.sub(b);
        const len = xAxis.length;
        if (len < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            return 0;
        }
        len;
        // Tangents both have length 1. If they compensate each other on x-asis,
        // then their projections on y-axis are the same.
        const delx = tangentA.add(tangentB).dot(xAxis);
        // const yAxis = xAxis.Rotate90Ccw();
        // const ay = tangentA * yAxis;
        // const by = tangentB * yAxis;
        const ay = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.crossProduct(xAxis, tangentA);
        const by = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.crossProduct(xAxis, tangentB);
        const dely = ay - by;
        // double ac = Math.Sqrt(delx * delx + dely * dely);
        // double bc = Math.Sqrt(ay * ay + by * by);
        const ac = delx * delx + dely * dely;
        const bc = ay * ay + by * by;
        return 10 * ac + assymetryWeight * bc;
    }
    SeparationCost(bundleInfo) {
        return this.SeparationCostForBundleBase(bundleInfo.SourceBase) + this.SeparationCostForBundleBase(bundleInfo.TargetBase);
    }
    SeparationCostForBundleBase(bBase) {
        if (bBase.Prev == null) {
            return 0;
        }
        return this.SeparationCostForAdjacentBundleBases(bBase, bBase.Prev) + this.SeparationCostForAdjacentBundleBases(bBase, bBase.Next);
    }
    SeparationCostForAdjacentBundleBases(base0, base1) {
        //Assert.assert(base0.Curve === base1.Curve)
        const boundaryCurve = base0.Curve;
        const len = this.IntervalsOverlapLength(base0.ParStart, base0.ParEnd, base1.ParStart, base1.ParEnd, boundaryCurve);
        const mn = Math.min(base0.Span, base1.Span);
        //Assert.assert(ApproximateComparer.LessOrEqual(len, mn));
        //Assert.assert((mn > 0));
        return Math.exp(len / (mn * 10)) - 1;
    }
    // returns the length of the overlapped interval of parameter space
    IntervalsOverlapLength(a, b, c, d, curve) {
        const s = curve.parStart;
        const e = curve.parEnd;
        if (a < b) {
            if (c < d) {
                return this.IntersectRegularIntervals(a, b, c, d);
            }
            return this.IntersectRegularIntervals(a, b, c, e) + this.IntersectRegularIntervals(a, b, s, d);
        }
        if (c < d) {
            return this.IntersectRegularIntervals(a, e, c, d) + this.IntersectRegularIntervals(s, b, c, d);
        }
        return this.IntersectRegularIntervals(a, e, c, e) + this.IntersectRegularIntervals(s, b, s, d);
    }
    IntersectRegularIntervals(a, b, c, d) {
        const low = Math.max(a, c);
        const up = Math.min(b, d);
        if (low < up) {
            return up - low;
        }
        return 0;
    }
    Cost() {
        let cost = 0;
        for (const bundleInfo of this.Bundles) {
            const c1 = BundleBasesCalculator.SeparationCoeff * this.SeparationCost(bundleInfo);
            const c2 = BundleBasesCalculator.AssymetryCoeff * this.AssymetryCost(bundleInfo);
            const c3 = BundleBasesCalculator.SqueezeCoeff * this.SqueezeCost(bundleInfo);
            const c4 = BundleBasesCalculator.CenterCoeff * this.CenterCostBi(bundleInfo);
            cost += (c1 + c2) / 2 + c3 + c4;
            //Assert.assert(cost < Number.POSITIVE_INFINITY)
        }
        return cost;
    }
}
/** 1(-1) rotate point CCW(CW)*/
BundleBasesCalculator.Deltas = [
    [1, -1],
    // [0, 1],
    //[-1, 1],
    // [1, 0],
    // [-1, 0],
    //[1, -1],
    // [0, -1],
    [1, -1], //rotating the left point cw, the right ccw
];
BundleBasesCalculator.SeparationCoeff = 1;
BundleBasesCalculator.SqueezeCoeff = 1;
BundleBasesCalculator.CenterCoeff = 10;
BundleBasesCalculator.AssymetryCoeff = 1;
BundleBasesCalculator.MaxIterations = 200;
BundleBasesCalculator.MaxParameterChange = 8 / 360;
// it would be one degree for a circle
BundleBasesCalculator.MinParameterChange = 0.1 / 360;
BundleBasesCalculator.CostThreshold = 1e-5;
BundleBasesCalculator.CostDeltaThreshold = 0.01;
function intersectBases(rBase, lBase) {
    // here rBase.Curve is the same as lBase.Curve
    // getting the parameter span of the curve
    const fullSpan = (0,_math_geometry__WEBPACK_IMPORTED_MODULE_1__.parameterSpan)(rBase.Curve);
    let e = rBase.ParEnd;
    let s = rBase.ParStart < rBase.ParEnd ? rBase.ParStart : rBase.ParStart - fullSpan;
    let oe = lBase.ParEnd;
    let os = lBase.ParStart < lBase.ParEnd ? lBase.ParStart : lBase.ParStart - fullSpan;
    // We have where s < e, and os < oe. Also e,s, os, oe <= rBase.Curve.ParEnd, but we can have s, os < rBase.Curve.ParStart
    // In addition, we are going to fit the intervals into an interval which is not longer then fullSpan.
    // To achive this we might need to shift one of the intervals by fullSpan
    if (e > oe) {
        // here also e > os
        if (e - os > fullSpan) {
            os += fullSpan;
            oe += fullSpan;
        }
    }
    else {
        // here oe >= e > s
        if (oe - s > fullSpan) {
            s += fullSpan;
            e += fullSpan;
        }
    }
    // Assert.assert(s < e)
    // Assert.assert(os < oe)
    // Assert.assert(Math.abs(e - s) <= fullSpan, 'e - s <= fullSpan')
    // Assert.assert(Math.abs(oe - os) <= fullSpan, 'oe - os <= fullSpan')
    // Assert.assert(Math.abs(oe - s) <= fullSpan, 'oe - s <= fullSpan')
    // Assert.assert(Math.abs(e - os) <= fullSpan, 'e - os <= fullSpan')
    const xEnd = Math.min(e, oe);
    const xStart = Math.max(s, os);
    return xStart <= xEnd ? { start: xStart, end: xEnd, rbaseMiddle: (s + e) / 2, lbaseMiddle: (os + oe) / 2 } : null;
}
//# sourceMappingURL=BundleBasesCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/BundleInfo.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BundleInfo: () => (/* binding */ BundleInfo)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _Intersections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/Intersections.js");
//


class BundleInfo {
    constructor(sourceBase, targetBase, obstaclesToIgnore, halfWidthArray) {
        this.SourceBase = sourceBase;
        this.TargetBase = targetBase;
        this.obstaclesToIgnore = obstaclesToIgnore;
        this.HalfWidthArray = halfWidthArray;
        this.TotalRequiredWidth = this.HalfWidthArray.reduce((a, b) => a + b, 0) * 2;
        this.longEnoughSideLength = sourceBase.Curve.boundingBox.addRec(targetBase.Curve.boundingBox).diagonal;
        // sometimes TotalRequiredWidth is too large to fit into the circle, so we evenly scale everything
        const mn = Math.max(sourceBase.Curve.boundingBox.diagonal, targetBase.Curve.boundingBox.diagonal);
        if (this.TotalRequiredWidth > mn) {
            const scale = this.TotalRequiredWidth / mn;
            for (let i = 0; i < this.HalfWidthArray.length; i++)
                this.HalfWidthArray[i] /= scale;
            this.TotalRequiredWidth /= scale;
        }
    }
    SetParamsFeasiblySymmetrically(tightTree) {
        this.CalculateTightObstaclesForBundle(tightTree, this.obstaclesToIgnore);
        this.SetEndParamsSymmetrically();
    }
    CalculateTightObstaclesForBundle(tightTree, obstaclesToIgnore) {
        const sRadius = this.SourceBase.Curve.boundingBox.diagonal / 2;
        const tRadius = this.TargetBase.Curve.boundingBox.diagonal / 2;
        const bundle = _Intersections__WEBPACK_IMPORTED_MODULE_1__.Intersections.Create4gon(this.SourceBase.Position, this.TargetBase.Position, sRadius * 2, tRadius * 2);
        this.tightObstaclesInTheBoundingBox = Array.from(tightTree.AllHitItems(bundle.boundingBox, (p) => !obstaclesToIgnore.has(p) && _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.ClosedCurveInteriorsIntersect(bundle, p)));
    }
    SetEndParamsSymmetrically() {
        const targetPos = this.TargetBase.Position;
        const sourcePos = this.SourceBase.Position;
        const dir = targetPos.sub(sourcePos).normalize();
        const perp = dir.rotate90Ccw();
        const middle = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.middle(targetPos, sourcePos);
        const mdir = dir.mul(this.longEnoughSideLength);
        const a = middle.add(mdir);
        const b = middle.sub(mdir);
        // [a,b] is a long enough segment
        // we are already fine
        if (this.SetRLParamsIfWidthIsFeasible(perp.mul(this.TotalRequiredWidth / 2), a, b)) {
            this.SetInitialMidParams();
            return;
        }
        // find the segment using binary search
        let uw = this.TotalRequiredWidth;
        let lw = 0;
        let mw = uw / 2;
        while (uw - lw > BundleInfo.FeasibleWidthEpsilon) {
            if (this.SetRLParamsIfWidthIsFeasible(perp.mul(mw / 2), a, b)) {
                lw = mw;
            }
            else {
                uw = mw;
            }
            mw = 0.5 * (uw + lw);
        }
        if (mw <= BundleInfo.FeasibleWidthEpsilon) {
            // try one side
            if (this.SetRLParamsIfWidthIsFeasible_(perp.mul(BundleInfo.FeasibleWidthEpsilon), new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0), a, b) ||
                this.SetRLParamsIfWidthIsFeasible_(new _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0), perp.mul(-BundleInfo.FeasibleWidthEpsilon), a, b)) {
                mw = 2 * BundleInfo.FeasibleWidthEpsilon;
            }
        }
        //Assert.assert(mw > BundleInfo.FeasibleWidthEpsilon)
        this.SourceBase.InitialMidParameter = this.SourceBase.AdjustParam(this.SourceBase.ParStart + this.SourceBase.Span / 2);
        this.TargetBase.InitialMidParameter = this.TargetBase.AdjustParam(this.TargetBase.ParStart + this.TargetBase.Span / 2);
    }
    mkNameFromLRST() {
        return './tmp/leftRight' + this.SourceBase.Position.toString() + '_' + this.TargetBase.Position.toString() + '.svg';
    }
    SetRLParamsIfWidthIsFeasible(perp, a, b) {
        return this.SetRLParamsIfWidthIsFeasible_(perp, perp.neg(), a, b);
    }
    SetRLParamsIfWidthIsFeasible_(perpL, perpR, a, b) {
        const targetLParam = { par: 0 };
        const sourceLParam = { par: 0 };
        const targetRParam = { par: 0 };
        const sourceRParam = { par: 0 };
        let ls = this.TrimSegWithBoundaryCurves(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(a.add(perpL), b.add(perpL)), sourceLParam, targetRParam);
        if (ls == null) {
            return false;
        }
        const intersected = this.tightObstaclesInTheBoundingBox.find((t) => _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.intersectionOne(ls, t, false) != null);
        if (intersected) {
            return false;
        }
        ls = this.TrimSegWithBoundaryCurves(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(a.add(perpR), b.add(perpR)), sourceRParam, targetLParam);
        if (ls == null) {
            return false;
        }
        if (this.tightObstaclesInTheBoundingBox.find((t) => _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.intersectionOne(ls, t, false) != null)) {
            return false;
        }
        if (this.SourceBase.IsParent) {
            this.SourceBase.ParStart = sourceLParam.par;
            this.SourceBase.ParEnd = sourceRParam.par;
        }
        else {
            this.SourceBase.ParStart = sourceRParam.par;
            this.SourceBase.ParEnd = sourceLParam.par;
        }
        // SourceBase.InitialMidParameter = SourceBase.AdjustParam(SourceBase.ParRight + SourceBase.Span / 2);
        if (this.TargetBase.IsParent) {
            this.TargetBase.ParStart = targetLParam.par;
            this.TargetBase.ParEnd = targetRParam.par;
        }
        else {
            this.TargetBase.ParStart = targetRParam.par;
            this.TargetBase.ParEnd = targetLParam.par;
        }
        //  SvgDebugWriter.dumpDebugCurves(this.mkNameFromLRST(), [
        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Red', this.SourceBase.Curve),
        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Blue', this.TargetBase.Curve),
        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Green', LineSegment.mkPP(this.TargetBase.LeftPoint, this.SourceBase.LeftPoint)),
        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Yellow', LineSegment.mkPP(this.TargetBase.RightPoint, this.SourceBase.RightPoint)),
        //    DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Black', LineSegment.mkPP(a, b)),
        //  ])
        // }
        // //Assert.assert(this.SourceBase.LeftPoint.sub(this.SourceBase.Position).dot(perpL) > 0)
        // //Assert.assert(this.TargetBase.LeftPoint.sub(this.SourceBase.Position).dot(perpL) < 0)
        // Assert.assert(this.SourceBase.isCorrectlyOrienected() && this.TargetBase.isCorrectlyOrienected())
        return true;
    }
    SetInitialMidParams() {
        const t = { par: 0 };
        const s = { par: 0 };
        const ls = this.TrimSegWithBoundaryCurves(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(this.TargetBase.CurveCenter, this.TargetBase.CurveCenter), s, t);
        if (ls != null) {
            this.SourceBase.InitialMidParameter = s.par;
            this.TargetBase.InitialMidParameter = t.par;
        }
        else {
            this.SourceBase.InitialMidParameter = this.SourceBase.AdjustParam(this.SourceBase.ParStart + this.SourceBase.Span / 2);
            this.TargetBase.InitialMidParameter = this.TargetBase.AdjustParam(this.TargetBase.ParStart + this.TargetBase.Span / 2);
        }
        // SvgDebugWriter.dumpDebugCurves(this.mkNameFromST(), [
        //  DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', this.SourceBase.Curve),
        //  DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Blue', this.TargetBase.Curve),
        //  DebugCurve.mkDebugCurveTWCI(
        //    100,
        //    0.2,
        //    'Red',
        //    CurveFactory.mkCircle(2, this.SourceBase.Curve.value(this.SourceBase.InitialMidParameter)),
        //  ),
        //  DebugCurve.mkDebugCurveTWCI(
        //    100,
        //    0.2,
        //    'Blue',
        //    CurveFactory.mkCircle(2, this.TargetBase.Curve.value(this.TargetBase.InitialMidParameter)),
        //  ),
        // ])
    }
    mkNameFromST() {
        return './tmp/mparam' + this.SourceBase.Position.toString() + '_' + this.TargetBase.Position.toString() + '.svg';
    }
    TrimSegWithBoundaryCurves(ls, s, t) {
        // ls goes from target to source
        let inters = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.getAllIntersections(ls, this.SourceBase.Curve, true);
        if (inters.length === 0) {
            t.par = 0;
            s.par = 0;
            return null;
        }
        let sourceX;
        if (inters.length === 1)
            sourceX = inters[0];
        else {
            if (!this.SourceBase.IsParent)
                sourceX = inters[0].par0 < inters[1].par0 ? inters[0] : inters[1];
            else
                sourceX = inters[0].par0 < inters[1].par0 ? inters[1] : inters[0];
        }
        inters = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.getAllIntersections(ls, this.TargetBase.Curve, true);
        if (inters.length === 0) {
            t.par = 0;
            s.par = 0;
            return null;
        }
        let targetX;
        if (inters.length === 1)
            targetX = inters[0];
        else {
            if (!this.TargetBase.IsParent)
                targetX = inters[0].par0 > inters[1].par0 ? inters[0] : inters[1];
            else
                targetX = inters[0].par0 > inters[1].par0 ? inters[1] : inters[0];
        }
        s.par = sourceX.par1;
        t.par = targetX.par1;
        //   //Assert.assert(Point.closeDistEps(sourceX.x, this.SourceBase.Curve.value(sourceX.par1)))
        // //Assert.assert(Point.closeDistEps(targetX.x, this.TargetBase.Curve.value(targetX.par1)))
        // SvgDebugWriter.dumpDebugCurves('./tmp/trim_result' + ls.start.toString() + ls.end.toString() + '.svg', [
        //  DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', this.SourceBase.Curve),
        //  DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Blue', this.TargetBase.Curve),
        //  DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Black', ls),
        //  DebugCurve.mkDebugCurveTWCI(100, 0.5, 'Brown', LineSegment.mkPP(sourceX.x, targetX.x)),
        // ])
        return _math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(sourceX.x, targetX.x);
    }
    RotateBy(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange) {
        const needToUpdateSource = rotationOfSourceRightPoint !== 0 || rotationOfSourceLeftPoint !== 0;
        const needToUpdateTarget = rotationOfTargetRightPoint !== 0 || rotationOfTargetLeftPoint !== 0;
        if (needToUpdateSource) {
            this.SourceBase.RotateBy(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, parameterChange);
        }
        if (needToUpdateTarget) {
            this.TargetBase.RotateBy(rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange);
        }
        this.UpdateSourceAndTargetBases(needToUpdateSource, needToUpdateTarget);
    }
    UpdateSourceAndTargetBases(sourceChanged, targetChanged) {
        if (sourceChanged) {
            this.UpdatePointsOnBundleBase(this.SourceBase);
        }
        if (targetChanged) {
            this.UpdatePointsOnBundleBase(this.TargetBase);
        }
        this.UpdateTangentsOnBases();
    }
    UpdateTangentsOnBases() {
        const count = this.TargetBase.length;
        // updating tangents
        for (let i = 0; i < count; i++) {
            let d = this.TargetBase.Points[i].sub(this.SourceBase.Points[count - 1 - i]);
            const len = d.length;
            if (len >= _math_geometry__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance) {
                d = d.div(len);
                this.TargetBase.Tangents[i] = d;
                this.SourceBase.Tangents[count - 1 - i] = d.neg();
            }
            else {
                // Assert.assert(false)
            }
        }
    }
    UpdatePointsOnBundleBase(bb) {
        const count = bb.length;
        const pns = bb.Points;
        const ls = _math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(bb.EndPoint, bb.StartPoint);
        const scale = 1.0 / this.TotalRequiredWidth;
        let t = this.HalfWidthArray[0];
        pns[0] = ls.value(t * scale);
        for (let i = 1; i < count; i++) {
            t += this.HalfWidthArray[i - 1] + this.HalfWidthArray[i];
            pns[i] = ls.value(t * scale);
        }
    }
    RotationIsLegal(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange) {
        // 1. we can't have intersections with obstacles
        // (we check borderlines of the bundle only)
        if (!this.SourceBase.IsParent && !this.TargetBase.IsParent) {
            if (rotationOfSourceLeftPoint !== 0 || rotationOfTargetRightPoint !== 0) {
                const rSoP = this.SourceBase.RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange);
                const lTarP = this.TargetBase.RotateRigthPoint(rotationOfTargetRightPoint, parameterChange);
                if (!this.LineIsLegal(rSoP, lTarP)) {
                    return false;
                }
            }
            if (rotationOfSourceRightPoint !== 0 || rotationOfTargetLeftPoint !== 0) {
                const lSoP = this.SourceBase.RotateRigthPoint(rotationOfSourceRightPoint, parameterChange);
                const rTarP = this.TargetBase.RotateLeftPoint(rotationOfTargetLeftPoint, parameterChange);
                if (!this.LineIsLegal(lSoP, rTarP)) {
                    return false;
                }
            }
        }
        else {
            if (rotationOfSourceLeftPoint !== 0 || rotationOfTargetLeftPoint !== 0) {
                const lSoP = this.SourceBase.RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange);
                const lTarP = this.TargetBase.RotateLeftPoint(rotationOfTargetLeftPoint, parameterChange);
                if (!this.LineIsLegal(lSoP, lTarP)) {
                    return false;
                }
            }
            if (rotationOfSourceRightPoint !== 0 || rotationOfTargetRightPoint !== 0) {
                const rSoP = this.SourceBase.RotateRigthPoint(rotationOfSourceRightPoint, parameterChange);
                const rTarP = this.TargetBase.RotateRigthPoint(rotationOfTargetRightPoint, parameterChange);
                if (!this.LineIsLegal(rSoP, rTarP)) {
                    return false;
                }
            }
        }
        // 2. we are also not allowed to change the order of bundles around a hub
        if (rotationOfSourceRightPoint !== 0 || rotationOfSourceLeftPoint !== 0) {
            if (!this.SourceBase.RelativeOrderOfBasesIsPreserved(rotationOfSourceRightPoint, rotationOfSourceLeftPoint, parameterChange)) {
                return false;
            }
        }
        if (rotationOfTargetRightPoint !== 0 || rotationOfTargetLeftPoint !== 0) {
            if (!this.TargetBase.RelativeOrderOfBasesIsPreserved(rotationOfTargetRightPoint, rotationOfTargetLeftPoint, parameterChange)) {
                return false;
            }
        }
        return true;
    }
    LineIsLegal(a, b) {
        return this.tightObstaclesInTheBoundingBox.find((t) => _math_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.intersectionOne(_math_geometry__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(a, b), t, false) != null) == null;
    }
}
BundleInfo.FeasibleWidthEpsilon = 0.1;
//# sourceMappingURL=BundleInfo.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/BundleRouter.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BundleRouter: () => (/* binding */ BundleRouter)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/hookUpAnywhereFromInsidePort.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ClusterBoundaryPort.js");
/* harmony import */ var _SingleSourceMultipleTargetsShortestPathOnVisibilityGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.js");
/* harmony import */ var _BundlingStatus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/BundlingStatus.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _MetroGraphData__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/MetroGraphData.js");
/* harmony import */ var _StationPositionsAdjuster__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/StationPositionsAdjuster.js");
/* harmony import */ var _EdgeNudger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/EdgeNudger.js");
/* harmony import */ var _MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/arrowhead.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");
// The class is responsible for general edge bundling with ordered bundles.
// Currently the router will fail if there are node overlaps.















class BundleRouter extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_6__.Algorithm {
    constructor(edgesToRoute, shortestPathRouter, visibilityGraph, bundlingSettings, loosePadding, tightHierarchy, looseHierarchy, edgeLooseEnterable, edgeTightEnterable, loosePolylineOfPort) {
        super(null);
        this.bundlingSettings = bundlingSettings;
        this.bundlingSettings.edgeWidthShrinkCoeff = 1;
        this.edgesToRoute = edgesToRoute;
        this.regularEdges = edgesToRoute.filter((e) => e.source !== e.target);
        this.VisibilityGraph = visibilityGraph;
        this.shortestPathRouter = shortestPathRouter;
        this.LoosePadding = loosePadding;
        this.LooseHierarchy = looseHierarchy;
        this.TightHierarchy = tightHierarchy;
        this.EdgeLooseEnterable = edgeLooseEnterable;
        this.EdgeTightEnterable = edgeTightEnterable;
        this.loosePolylineOfPort = loosePolylineOfPort;
        (0,_utils_random__WEBPACK_IMPORTED_MODULE_14__.initRandom)(0);
    }
    ThereAreOverlaps(hierarchy) {
        return (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_7__.FindIntersectionWithProperty)(hierarchy, hierarchy, _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve.CurvesIntersect);
    }
    // edge routing with Ordered Bundles:
    // 1. route edges with bundling
    // 2. nudge bundles and hubs
    // 3. order paths
    run() {
        if (this.ThereAreOverlaps(this.TightHierarchy)) {
            this.Status = _BundlingStatus__WEBPACK_IMPORTED_MODULE_5__.BundlingStatus.Overlaps;
            return;
        }
        this.FixLocationsForHookAnywherePorts(this.edgesToRoute);
        this.RoutePathsWithSteinerDijkstra();
        this.FixChildParentEdges();
        if (!this.bundlingSettings.StopAfterShortestPaths) {
            this.OrderOptimizeNudgeEtc();
        }
        this.RouteSelfEdges();
        this.FixArrowheads();
    }
    OrderOptimizeNudgeEtc() {
        const metroGraphData = new _MetroGraphData__WEBPACK_IMPORTED_MODULE_8__.MetroGraphData(this.regularEdges, this.LooseHierarchy, this.TightHierarchy, this.bundlingSettings, this.shortestPathRouter.cdt, this.EdgeLooseEnterable, this.EdgeTightEnterable, this.loosePolylineOfPort);
        _StationPositionsAdjuster__WEBPACK_IMPORTED_MODULE_9__.StationPositionsAdjuster.FixRouting(metroGraphData, this.bundlingSettings);
        new _EdgeNudger__WEBPACK_IMPORTED_MODULE_10__.EdgeNudger(metroGraphData, this.bundlingSettings).run();
    }
    // set endpoint of the edge from child to parent (cluster) to the boundary of the parent
    // TODO: is there a better solution?
    FixChildParentEdges() {
        for (const edge of this.regularEdges) {
            const sPort = edge.sourcePort;
            const ePort = edge.targetPort;
            if (sPort.Curve.boundingBox.containsRect(ePort.Curve.boundingBox)) {
                const ii = _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve.intersectionOne(sPort.Curve, _math_geometry__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(edge.curve.start, edge.curve.end), false);
                const poly = edge.curve;
                poly.startPoint.point = ii.x;
            }
            if (ePort.Curve.boundingBox.containsRect(sPort.Curve.boundingBox)) {
                const ii = _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve.intersectionOne(ePort.Curve, _math_geometry__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(edge.curve.start, edge.curve.end), true);
                const poly = edge.curve;
                poly.endPoint.point = ii.x;
            }
        }
    }
    // ReSharper disable UnusedMember.Local
    // ShowGraphLocal() {
    //  //  ReSharper restore UnusedMember.Local
    //  const l = new List<ICurve>()
    //  l.Clear()
    //  for (const e in this.geometryGraph.edges) {
    //    l.Add(new Ellipse(2, 2, e.Curve.Start))
    //    l.Add(CurveFactory.CreateDiamond(5, 5, e.Curve.End))
    //    l.Add(e.Curve)
    //  }
    //  SplineRouter.ShowVisGraph(this.VisibilityGraph, this.LooseHierarchy.GetAllLeaves(), null, l)
    // }
    FixLocationsForHookAnywherePorts(edges) {
        for (const edge of edges) {
            let isHookPort = edge.sourcePort instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_1__.HookUpAnywhereFromInsidePort;
            if (isHookPort) {
                const hookPort = edge.sourcePort;
                hookPort.SetLocation(this.FigureOutHookLocation(hookPort.LoosePolyline, edge.targetPort, edge));
            }
            else {
                isHookPort = edge.targetPort instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_1__.HookUpAnywhereFromInsidePort;
                if (isHookPort) {
                    const hookPort = edge.targetPort;
                    hookPort.SetLocation(this.FigureOutHookLocation(hookPort.LoosePolyline, edge.sourcePort, edge));
                }
            }
        }
    }
    FigureOutHookLocation(poly, otherEdgeEndPort, edgeGeom) {
        const isClusterPort = otherEdgeEndPort instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_3__.ClusterBoundaryPort;
        if (!isClusterPort) {
            return this.FigureOutHookLocationForSimpleOtherPort(poly, otherEdgeEndPort, edgeGeom);
        }
        return this.FigureOutHookLocationForClusterOtherPort(poly, otherEdgeEndPort, edgeGeom);
    }
    FigureOutHookLocationForClusterOtherPort(poly, otherEdgeEndPort, edgeGeom) {
        const shapes = this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(edgeGeom);
        // SplineRouter.ShowVisGraph(this.VisibilityGraph, this.LooseHierarchy.GetAllLeaves(),
        //    shapes.Select(sh => sh.BoundaryCurve), new[] { new LineSegment(edgeGeom.SourcePort.Location, edgeGeom.TargetPort.Location) });
        const s = new _MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph__WEBPACK_IMPORTED_MODULE_11__.MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph(Array.from(otherEdgeEndPort.LoosePolyline).map(this.VisibilityGraph.FindVertex.bind), Array.from(poly).map(this.VisibilityGraph.FindVertex.bind), this.VisibilityGraph);
        const path = s.GetPath();
        for (const sh of shapes) {
            sh.IsTransparent = false;
        }
        return path[path.length - 1].point;
    }
    FigureOutHookLocationForSimpleOtherPort(poly, otherEdgeEndPort, edgeGeom) {
        const otherEdgeEnd = otherEdgeEndPort.Location;
        const shapes = this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(edgeGeom);
        // SplineRouter.ShowVisGraph(this.VisibilityGraph, this.LooseHierarchy.GetAllLeaves(),
        //    shapes.Select(sh => sh.BoundaryCurve), new[] { new LineSegment(edgeGeom.SourcePort.Location, edgeGeom.TargetPort.Location) });
        const s = new _SingleSourceMultipleTargetsShortestPathOnVisibilityGraph__WEBPACK_IMPORTED_MODULE_4__.SingleSourceMultipleTargetsShortestPathOnVisibilityGraph(this.VisibilityGraph.FindVertex(otherEdgeEnd), Array.from(poly).map((p) => this.VisibilityGraph.FindVertex(p)), this.VisibilityGraph);
        const path = s.GetPath();
        for (const sh of shapes) {
            sh.IsTransparent = false;
        }
        return path[path.length - 1].point;
    }
    RoutePathsWithSteinerDijkstra() {
        this.shortestPathRouter.VisibilityGraph = this.VisibilityGraph;
        this.shortestPathRouter.BundlingSettings = this.bundlingSettings;
        this.shortestPathRouter.geomEdges = this.regularEdges;
        this.shortestPathRouter.ObstacleHierarchy = this.LooseHierarchy;
        this.shortestPathRouter.RouteEdges();
        // find appropriate edge separation
        if (this.shortestPathRouter.cdt != null) {
            this.AdjustEdgeSeparation();
        }
    }
    // calculates maximum possible edge separation for the computed routing
    //   if it is greater than bundlingSettings.EdgeSeparation, then proceed
    //   if it is smaller, then either
    //     stop edge bundling, or
    //     reduce edge separation, or
    //     move obstacles to get more free space
    AdjustEdgeSeparation() {
        const crossedCdtEdges = new Map();
        this.shortestPathRouter.FillCrossedCdtEdges(crossedCdtEdges);
        const pathsOnCdtEdge = this.GetPathsOnCdtEdge(crossedCdtEdges);
        this.bundlingSettings.edgeWidthShrinkCoeff = this.CalculateEdgeWidthShrinkCoeff(pathsOnCdtEdge);
    }
    //  //  reducing edge separation
    //  //  TimeMeasurer.DebugOutput("reducing edge separation to " + es);
    //  this.bundlingSettings.EdgeSeparation = es
    //  this.shortestPathRouter.RouteEdges()
    //  return true
    // }
    GetPathsOnCdtEdge(crossedEdges) {
        const res = new Map();
        for (const edge of crossedEdges.keys()) {
            for (const cdtEdge of crossedEdges.get(edge)) {
                (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_12__.addToMapOfSets)(res, cdtEdge, edge);
            }
        }
        return res;
    }
    CalculateEdgeWidthShrinkCoeff(pathsOnCdtEdge) {
        let l = 0;
        let r = this.bundlingSettings.edgeWidthShrinkCoeff;
        if (this.EdgeSeparationIsOkMN(pathsOnCdtEdge, r)) {
            return r;
        }
        let lHasChanged = false;
        while (!lHasChanged || Math.abs(r - l) > 0.01) {
            const cen = (l + r) / 2;
            if (this.EdgeSeparationIsOkMN(pathsOnCdtEdge, cen)) {
                l = cen;
                lHasChanged = true;
            }
            else {
                r = cen;
            }
        }
        return l;
    }
    EdgeSeparationIsOkMN(pathsOnCdtEdge, widthShrinkCoeff) {
        for (const edge of pathsOnCdtEdge.keys()) {
            if (!this.EdgeSeparationIsOk(edge, pathsOnCdtEdge.get(edge), widthShrinkCoeff)) {
                return false;
            }
        }
        return true;
    }
    EdgeSeparationIsOk(edge, paths, shrinkCoeff) {
        const requiredWidth = Array.from(paths)
            .map((e) => this.bundlingSettings.ActualEdgeWidth(e, shrinkCoeff))
            .reduce((a, b) => a + b, 0);
        return requiredWidth <= edge.Capacity;
    }
    RouteSelfEdges() {
        for (const edge of this.edgesToRoute) {
            if (edge.source === edge.target) {
                const t = { smoothedPolyline: null };
                edge.curve = ___WEBPACK_IMPORTED_MODULE_0__.GeomEdge.RouteSelfEdge(edge.source.boundaryCurve, this.LoosePadding * 2, t);
            }
        }
    }
    FixArrowheads() {
        for (const edge of this.edgesToRoute) {
            _layout_core_arrowhead__WEBPACK_IMPORTED_MODULE_13__.Arrowhead.trimSplineAndCalculateArrowheadsII(edge, edge.source.boundaryCurve, edge.target.boundaryCurve, edge.curve, false);
        }
    }
}
// for the shortest path calculation we will use not loosePadding, but loosePadding*SuperLoosePaddingCoefficient
/* const */ BundleRouter.SuperLoosePaddingCoefficient = 1.1;
//# sourceMappingURL=BundleRouter.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/BundlingStatus.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BundlingStatus: () => (/* binding */ BundlingStatus)
/* harmony export */ });
var BundlingStatus;
(function (BundlingStatus) {
    BundlingStatus[BundlingStatus["Success"] = 0] = "Success";
    BundlingStatus[BundlingStatus["Overlaps"] = 1] = "Overlaps";
    BundlingStatus[BundlingStatus["EdgeSeparationIsTooLarge"] = 2] = "EdgeSeparationIsTooLarge";
})(BundlingStatus || (BundlingStatus = {}));
//# sourceMappingURL=BundlingStatus.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/CdtIntersections.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CdtIntersections: () => (/* binding */ CdtIntersections)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");
/* harmony import */ var _CdtThreader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/CdtThreader.js");




// Check intersections between edges and obstacles using triangulation (faster than kd-tree)
class CdtIntersections {
    EdgeIsLegal_(start, end, currentTriangle, obstaclesToIgnore) {
        //Assert.assert(Cdt.PointIsInsideOfTriangle(start, currentTriangle))
        if (_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_2__.Cdt.PointIsInsideOfTriangle(end, currentTriangle)) {
            return true;
        }
        const threader = new _CdtThreader__WEBPACK_IMPORTED_MODULE_3__.CdtThreader(currentTriangle, start, end);
        while (threader.MoveNext()) {
            const piercedEdge = threader.CurrentPiercedEdge;
            if (piercedEdge.constrained) {
                //Assert.assert(piercedEdge.lowerSite.Owner === piercedEdge.upperSite.Owner)
                const poly = piercedEdge.lowerSite.Owner;
                if (!obstaclesToIgnore.has(poly)) {
                    return false;
                }
            }
        }
        return true;
    }
    constructor(metroGraphData, bundlingSettings) {
        this.ComputeForcesForBundles = false;
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
    }
    /**   returns false iff an edge overlap an obstacle,
   otherwise it calulates distances to the closest obstacles */
    BundleAvoidsObstacles(v, u, vPosition, uPosition, upperBound, t) {
        t.closestDist = new Array();
        const obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(v, u);
        const closeObstacles = this.FindCloseObstaclesForBundle(u.cdtTriangle, uPosition, vPosition, obstaclesToIgnore, upperBound);
        if (closeObstacles == null) {
            return false;
        }
        for (const item of closeObstacles) {
            const dist = item[1];
            t.closestDist.push(dist);
        }
        return true;
    }
    // returns null iff the edge overlap an obstacle
    FindCloseObstaclesForBundle(startTriangle, start, end, obstaclesToIgnore, upperBound) {
        const obstacles = new Map();
        const list = [];
        if (!this.ThreadLineSegmentThroughTriangles(startTriangle, start, end, obstaclesToIgnore, list)) {
            return null;
        }
        if (!this.ComputeForcesForBundles && !this.bundlingSettings.HighestQuality) {
            return obstacles;
        }
        const checkedSites = new Set();
        for (const t of list) {
            for (const s of t.Sites) {
                if (checkedSites.has(s))
                    continue;
                checkedSites.add(s);
                const poly = s.Owner;
                if (obstaclesToIgnore.has(poly))
                    continue;
                const pp = CdtIntersections.FindPolylinePoint(poly, s.point);
                const t1 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.minDistBetweenLineSegments(pp.point, pp.nextOnPolyline.point, start, end);
                //out par11, out par12);
                const d12 = t1.dist;
                const par11 = t1.parab;
                const par12 = t1.parcd;
                const t2 = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.minDistBetweenLineSegments(pp.point, pp.prevOnPolyline.point, start, end);
                //out par21, out par22);
                const d22 = t2.dist;
                const par21 = t2.parab;
                const par22 = t2.parcd;
                let r1, r2;
                let dist;
                if (d12 < d22) {
                    dist = d12;
                    if (dist > upperBound)
                        continue;
                    r1 = pp.point.add(pp.nextOnPolyline.point.sub(pp.point).mul(par11));
                    r2 = start.add(end.sub(start).mul(par12));
                }
                else {
                    dist = d22;
                    if (dist > upperBound)
                        continue;
                    r1 = pp.point.add(pp.prevOnPolyline.point.sub(pp.point).mul(par21));
                    r2 = start.add(end.sub(start).mul(par22));
                }
                //if (dist > upperBound) continue;
                const currentValue = obstacles.get(poly);
                if (!currentValue)
                    obstacles.set(poly, [r1, r2]);
            }
        }
        return obstacles;
    }
    /**   returns false iff the edge overlap an obstacle*/
    ThreadLineSegmentThroughTriangles(currentTriangle, start, end, obstaclesToIgnore, triangles) {
        if (_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_2__.Cdt.PointIsInsideOfTriangle(end, currentTriangle)) {
            triangles.push(currentTriangle);
            return true;
        }
        const threader = new _CdtThreader__WEBPACK_IMPORTED_MODULE_3__.CdtThreader(currentTriangle, start, end);
        triangles.push(currentTriangle);
        while (threader.MoveNext()) {
            triangles.push(threader.CurrentTriangle);
            const piercedEdge = threader.CurrentPiercedEdge;
            if (piercedEdge.constrained) {
                //Assert.assert(piercedEdge.lowerSite.Owner === piercedEdge.upperSite.Owner)
                const poly = piercedEdge.lowerSite.Owner;
                if (!obstaclesToIgnore.has(poly)) {
                    return false;
                }
            }
        }
        if (threader.CurrentTriangle != null) {
            triangles.push(threader.CurrentTriangle);
        }
        //
        //            int positiveSign, negativeSign;
        //            CdtEdge piercedEdge = FindFirstPiercedEdge(currentTriangle, start, end, out negativeSign, out positiveSign,  null);
        //
        //            //Assert.assert(positiveSign > negativeSign);
        //
        //            //Assert.assert(piercedEdge != null);
        //
        //            do {
        //                triangles.Add(currentTriangle);
        //                if (piercedEdge.Constrained) {
        //                    //Assert.assert(piercedEdge.lowerSite.Owner === piercedEdge.upperSite.Owner);
        //                    Polyline poly = (Polyline)piercedEdge.lowerSite.Owner;
        //                    if (!obstaclesToIgnore.Contains(poly)) return false;
        //                }
        //            }
        //            while (FindNextPierced(start, end, ref currentTriangle, ref piercedEdge, ref negativeSign, ref positiveSign));
        //            if (currentTriangle != null)
        //                triangles.Add(currentTriangle);
        return true;
    }
    static PointLocationInsideTriangle(p, triangle) {
        let seenBoundary = false;
        for (let i = 0; i < 3; i++) {
            const area = ___WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(p, triangle.Sites.getItem(i).point, triangle.Sites.getItem(i + 1).point);
            if (area < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon * -1) {
                return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Outside;
            }
            if (area < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                seenBoundary = true;
            }
        }
        return seenBoundary ? _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Boundary : _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Inside;
    }
    static FindPolylinePoint(poly, point) {
        for (const ppp of poly.polylinePoints()) {
            if (ppp.point.equal(point)) {
                return ppp;
            }
        }
        throw new Error('polyline point ' + point + ' not found');
    }
    // checks if an edge intersects obstacles
    // otherwise it calulates distances to the closest obstacles
    EdgeIsLegal(v, u, vPosition, uPosition) {
        const list = [];
        const obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(v, u);
        return this.ThreadLineSegmentThroughTriangles(v.cdtTriangle, vPosition, uPosition, obstaclesToIgnore, list);
    }
    // checks if an edge intersects obstacles
    // otherwise it calulates distances to the closest obstacles
    EdgeIsLegalSSPPS(v, u, obstaclesToIgnore) {
        // if (CdtIntersections.closedeb(u, v) || CdtIntersections.closedeb(v, u)) {
        //  console.log(this)
        // }
        const start = v.Position;
        const currentTriangle = v.cdtTriangle;
        //Assert.assert(Cdt.PointIsInsideOfTriangle(start, currentTriangle))
        const end = u.Position;
        if (_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_2__.Cdt.PointIsInsideOfTriangle(end, currentTriangle)) {
            return true;
        }
        const threader = new _CdtThreader__WEBPACK_IMPORTED_MODULE_3__.CdtThreader(currentTriangle, start, end);
        while (threader.MoveNext()) {
            const piercedEdge = threader.CurrentPiercedEdge;
            if (piercedEdge.constrained) {
                //Assert.assert(piercedEdge.lowerSite.Owner === piercedEdge.upperSite.Owner)
                const poly = piercedEdge.lowerSite.Owner;
                if (!obstaclesToIgnore.has(poly)) {
                    return false;
                }
            }
        }
        return true;
    }
}
//# sourceMappingURL=CdtIntersections.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/CdtThreader.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CdtThreader: () => (/* binding */ CdtThreader)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");



class CdtThreader {
    get CurrentPiercedEdge() {
        return this.currentPiercedEdge;
    }
    get CurrentTriangle() {
        return this.currentTriangle;
    }
    constructor(startTriangle, start, end) {
        this.currentTriangle = startTriangle;
        this.start = start;
        this.end = end;
        //Assert.assert(CdtTriangle.PointLocationForTriangle(start, startTriangle) !== PointLocation.Outside)
    }
    /**This method finds the first edge of the current triangle that
     * is pierced by a segment (start,end). It assumes that the start
     * point is inside or on the boundary of the current triangle,
     *  and the end point is outside.
     * The function works by computing the sign of each vertex
     *  of the current triangle with respect to the segment.
     *  The sign is zero if the vertex is on the segment,
     * positive if it is to the right of the segment  (when looking from the start point to the end point),
     * and negative if it is to the left.
     * The function then checks if there are two consecutive
     * vertices with different signs. If so, it means that the edge between them is pierced by the segment. The function returns that edge as the result.
  
  The function also sets the positiveSign and negativeSign fields to store the signs of the vertices on either side of the pierced edge. This is useful for finding the next triangle in the path of the segment. */
    FindFirstPiercedEdge() {
        //Assert.assert(CdtTriangle.PointLocationForTriangle(this.start, this.currentTriangle) !== PointLocation.Outside)
        //Assert.assert(CdtTriangle.PointLocationForTriangle(this.end, this.currentTriangle) === PointLocation.Outside)
        const sign0 = this.GetHyperplaneSign(this.currentTriangle.Sites.item0);
        const sign1 = this.GetHyperplaneSign(this.currentTriangle.Sites.item1);
        if (sign0 !== sign1) {
            if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.end, this.currentTriangle.Sites.item0.point, this.currentTriangle.Sites.item1.point) ==
                _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Clockwise) {
                this.positiveSign = sign0;
                this.negativeSign = sign1;
                return this.currentTriangle.Edges.item0;
            }
        }
        const sign2 = this.GetHyperplaneSign(this.currentTriangle.Sites.item2);
        if (sign1 !== sign2) {
            if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.end, this.currentTriangle.Sites.item1.point, this.currentTriangle.Sites.item2.point) ==
                _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Clockwise) {
                this.positiveSign = sign1;
                this.negativeSign = sign2;
                return this.currentTriangle.Edges.item1;
            }
        }
        this.positiveSign = sign2;
        this.negativeSign = sign0;
        //Assert.assert(this.positiveSign > this.negativeSign)
        return this.currentTriangle.Edges.item2;
    }
    FindNextPierced() {
        //Assert.assert(this.negativeSign < this.positiveSign)
        this.currentTriangle = this.currentPiercedEdge.GetOtherTriangle_T(this.currentTriangle);
        //            ShowDebug(null,currentPiercedEdge,currentTriangle);
        if (this.currentTriangle == null) {
            this.currentPiercedEdge = null;
            return;
        }
        const i = this.currentTriangle.Edges.index(this.currentPiercedEdge);
        let j;
        // pierced index
        const oppositeSite = this.currentTriangle.Sites.getItem(i + 2);
        const oppositeSiteSign = this.GetHyperplaneSign(oppositeSite);
        if (this.negativeSign === 0) {
            //Assert.assert(this.positiveSign === 1)
            if (oppositeSiteSign === -1 || oppositeSiteSign === 0) {
                this.negativeSign = oppositeSiteSign;
                j = i + 1;
            }
            else {
                j = i + 2;
            }
        }
        else if (this.positiveSign === 0) {
            //Assert.assert(this.negativeSign === -1)
            if (oppositeSiteSign === 1 || oppositeSiteSign === 0) {
                this.positiveSign = oppositeSiteSign;
                j = i + 2;
            }
            else {
                j = i + 1;
            }
        }
        else if (oppositeSiteSign !== this.positiveSign) {
            this.negativeSign = oppositeSiteSign;
            j = i + 1;
        }
        else {
            //Assert.assert(this.negativeSign !== oppositeSiteSign)
            this.positiveSign = oppositeSiteSign;
            j = i + 2;
        }
        this.currentPiercedEdge =
            ___WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(this.end, this.currentTriangle.Sites.getItem(j).point, this.currentTriangle.Sites.getItem(j + 1).point) < -_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon
                ? this.currentTriangle.Edges.getItem(j)
                : null;
    }
    //        void ShowDebug(Array<CdtTriangle> cdtTriangles, CdtEdge cdtEdge, CdtTriangle cdtTriangle) {
    //            var l = new Array<DebugCurve> { new DebugCurve(10,"red",new LineSegment(start,end)) };
    //            if(cdtEdge!=null)
    //                l.Add(new DebugCurve(100,3,"navy", new LineSegment(cdtEdge.upperSite.point,cdtEdge.lowerSite.point)));
    //            AddTriangleToListOfDebugCurves(l,cdtTriangle,100,2,"brown");
    //            LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    //
    //        }
    //        static void AddTriangleToListOfDebugCurves(Array<DebugCurve> debugCurves,CdtTriangle triangle,byte transparency,double width,string color) {
    //            foreach(var cdtEdge of triangle.Edges) {
    //                debugCurves.Add(new DebugCurve(transparency,width,color,new LineSegment(cdtEdge.upperSite.point,cdtEdge.lowerSite.point)));
    //            }
    //        }
    GetHyperplaneSign(cdtSite) {
        const area = ___WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(this.start, cdtSite.point, this.end);
        if (area > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            return 1;
        }
        if (area < -_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            return -1;
        }
        return 0;
    }
    MoveNext() {
        if (this.currentPiercedEdge == null) {
            this.currentPiercedEdge = this.FindFirstPiercedEdge();
        }
        else {
            this.FindNextPierced();
        }
        return this.currentPiercedEdge != null;
    }
}
//# sourceMappingURL=CdtThreader.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/CostCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CostCalculator: () => (/* binding */ CostCalculator)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/HubRadiiCalculator.js");
/* harmony import */ var _MetroGraphData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/MetroGraphData.js");



// Calculates the cost of the routing
class CostCalculator {
    constructor(metroGraphData, bundlingSettings) {
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
    }
    // Error of ink
    static InkError(oldInk, newInk, bundlingSettings) {
        return (oldInk - newInk) * bundlingSettings.InkImportance;
    }
    // Error of path lengths
    static PathLengthsError(oldLength, newLength, idealLength, bundlingSettings) {
        return (oldLength - newLength) * (bundlingSettings.PathLengthImportance / idealLength);
    }
    // Error of hubs
    static RError(idealR, nowR, bundlingSettings) {
        if (idealR <= nowR) {
            return 0;
        }
        const res = bundlingSettings.HubRepulsionImportance * ((1 - nowR / idealR) * (idealR - nowR));
        return res;
    }
    // Error of bundles
    static BundleError(idealWidth, nowWidth, bundlingSettings) {
        if (idealWidth <= nowWidth) {
            return 0;
        }
        const res = bundlingSettings.BundleRepulsionImportance * ((1 - nowWidth / idealWidth) * (idealWidth - nowWidth));
        return res;
    }
    // Cost of the whole graph
    static Cost(metroGraphData, bundlingSettings) {
        let cost = bundlingSettings.InkImportance * metroGraphData.Ink;
        //path lengths
        for (const metroline of metroGraphData.Metrolines) {
            cost += (bundlingSettings.PathLengthImportance * metroline.Length) / metroline.IdealLength;
        }
        cost += this.CostOfForces(metroGraphData);
        return cost;
    }
    // Cost of the whole graph (hubs and bundles)
    static CostOfForces(metroGraphData) {
        let cost = 0;
        // hubs
        for (const v of metroGraphData.VirtualStations()) {
            cost = cost + v.cachedRadiusCost;
        }
        // bundles
        for (const edge of metroGraphData.VirtualEdges()) {
            const v = edge[0];
            const u = edge[1];
            cost += metroGraphData.GetIjInfo(v, u).cachedBundleCost;
        }
        return cost;
    }
    // Gain of ink
    InkGain(node, newPosition) {
        // ink
        const oldInk = this.metroGraphData.Ink;
        let newInk = this.metroGraphData.Ink;
        for (const adj of node.Neighbors) {
            const adjPosition = adj.Position;
            newInk -= adjPosition.sub(node.Position).length;
            newInk += adjPosition.sub(newPosition).length;
        }
        return CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);
    }
    // Gain of path lengths
    PathLengthsGain(node, newPosition) {
        let gain = 0;
        //edge lengths
        for (const e of this.metroGraphData.MetroNodeInfosOfNode(node)) {
            const oldLength = e.Metroline.Length;
            const prev = e.PolyPoint.prev.point;
            const next = e.PolyPoint.next.point;
            const newLength = e.Metroline.Length +
                next.sub(newPosition).length +
                prev.sub(newPosition).length -
                next.sub(node.Position).length -
                prev.sub(node.Position).length;
            gain += CostCalculator.PathLengthsError(oldLength, newLength, e.Metroline.IdealLength, this.bundlingSettings);
        }
        return gain;
    }
    // Gain of radii
    RadiusGain(node, newPosition) {
        let gain = 0;
        gain = gain + node.cachedRadiusCost;
        gain = gain - this.RadiusCost(node, newPosition);
        return gain;
    }
    RadiusCost(node, newPosition) {
        let idealR;
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(node.Position, newPosition)) {
            idealR = node.cachedIdealRadius;
        }
        else {
            idealR = _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_1__.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBNP(this.metroGraphData, this.bundlingSettings, node, newPosition);
        }
        const t = { touchedObstacles: [] };
        if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(node, newPosition, idealR, t)) {
            return CostCalculator.Inf;
        }
        let cost = 0;
        for (const d of t.touchedObstacles) {
            const dist = d[1].sub(newPosition).length;
            cost += CostCalculator.RError(idealR, dist, this.bundlingSettings);
        }
        return cost;
    }
    // Gain of bundles
    // if a newPosition is not valid (e.g. intersect obstacles) the result is -inf
    BundleGain(node, newPosition) {
        let gain = node.cachedBundleCost;
        for (const adj of node.Neighbors) {
            const lgain = this.BundleCost(node, adj, newPosition);
            if ((0,_MetroGraphData__WEBPACK_IMPORTED_MODULE_2__.GreaterOrEqual)(lgain, CostCalculator.Inf))
                return -CostCalculator.Inf;
            gain -= lgain;
        }
        return gain;
    }
    BundleCost(node, adj, newPosition) {
        const idealWidth = this.metroGraphData.GetWidthSSN(node, adj, this.bundlingSettings.EdgeSeparation);
        const t = { closestDist: [] };
        //find conflicting obstacles
        if (!this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(node, adj, newPosition, adj.Position, idealWidth, t)) {
            return CostCalculator.Inf;
        }
        let cost = 0;
        for (const pair of t.closestDist) {
            const dist = pair[0].sub(pair[1]).length;
            cost += CostCalculator.BundleError(idealWidth / 2, dist, this.bundlingSettings);
        }
        return cost;
    }
}
CostCalculator.Inf = 1000000000;
//# sourceMappingURL=CostCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/EdgeNudger.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeNudger: () => (/* binding */ EdgeNudger)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/bezierSeg.js");
/* harmony import */ var _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/debugCurve.js");
/* harmony import */ var _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/ellipse.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _BundleBasesCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/BundleBasesCalculator.js");
/* harmony import */ var _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/HubRadiiCalculator.js");
/* harmony import */ var _GeneralMetroMapOrdering__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/GeneralMetroMapOrdering.js");
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");











//
// import {Assert} from '../../../utils/assert'
/** this class nudges the edges, sorts the edges that run in parallel in a way that minimezes the number of crossings*/
class EdgeNudger extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_6__.Algorithm {
    // Constructor
    constructor(metroGraphData, bundlingSettings) {
        super(null);
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
    }
    run() {
        this.CreateMetroOrdering();
        this.InitRadii();
        this.FinalizePaths();
    }
    InitRadii() {
        new _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_8__.HubRadiiCalculator(this.metroGraphData, this.bundlingSettings).CreateNodeRadii();
    }
    // bundle-map ordering
    CreateMetroOrdering() {
        this.metroOrdering = new _GeneralMetroMapOrdering__WEBPACK_IMPORTED_MODULE_9__.GeneralMetroMapOrdering(this.metroGraphData.Metrolines);
    }
    FinalizePaths() {
        this.CreateBundleBases();
        this.CreateSegmentsInsideHubs();
        this.CreateCurves();
    }
    CreateBundleBases() {
        const bbCalc = new _BundleBasesCalculator__WEBPACK_IMPORTED_MODULE_7__.BundleBasesCalculator(this.metroOrdering, this.metroGraphData, this.bundlingSettings);
        bbCalc.Run();
    }
    CreateCurves() {
        //Assert.assert(this.metroGraphData.Metrolines.length === this.metroGraphData.Edges.length)
        for (let i = 0; i < this.metroGraphData.Metrolines.length; i++) {
            this.CreateCurveLine(this.metroGraphData.Metrolines[i], this.metroGraphData.Edges[i]);
        }
    }
    CreateCurveLine(line, edge) {
        const c = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve();
        const start = EdgeNudger.FindCurveStart(this.metroGraphData, this.metroOrdering, line);
        let currentEnd = start;
        const hubSegsOfLine = EdgeNudger.HubSegsOfLine(this.metroGraphData, this.metroOrdering, line);
        for (const seg of hubSegsOfLine) {
            if (seg == null) {
                continue;
            }
            c.addSegment(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(currentEnd, seg.start));
            c.addSegment(seg);
            currentEnd = seg.end;
        }
        c.addSegment(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(currentEnd, EdgeNudger.FindCurveEnd(this.metroGraphData, this.metroOrdering, line)));
        edge.curve = c;
    }
    static FindCurveStart(metroGraphData, metroOrdering, metroline) {
        const u = metroGraphData.PointToStations.get(metroline.Polyline.startPoint.point);
        const v = metroGraphData.PointToStations.get(metroline.Polyline.startPoint.next.point);
        const bb = u.BundleBases.get(v);
        const index = !bb.IsParent
            ? metroOrdering.GetLineIndexInOrder(v, u, metroline)
            : metroOrdering.GetLineIndexInOrder(u, v, metroline);
        return bb.Points[index];
    }
    static FindCurveEnd(metroGraphData, metroOrdering, metroline) {
        const u = metroGraphData.PointToStations.get(metroline.Polyline.endPoint.prev.point);
        const v = metroGraphData.PointToStations.get(metroline.Polyline.endPoint.point);
        const bb = v.BundleBases.get(u);
        const index = !bb.IsParent ? metroOrdering.GetLineIndexInOrder(u, v, metroline) : metroOrdering.GetLineIndexInOrder(v, u, metroline);
        return bb.Points[index];
    }
    static *HubSegsOfLine(metroGraphData, metroOrdering, line) {
        for (let i = line.Polyline.startPoint.next; i.next != null; i = i.next)
            yield EdgeNudger.SegOnLineVertex(metroGraphData, metroOrdering, line, i);
    }
    static SegOnLineVertex(metroGraphData, metroOrdering, line, i) {
        const u = metroGraphData.PointToStations.get(i.prev.point);
        const v = metroGraphData.PointToStations.get(i.point);
        const h0 = v.BundleBases.get(u);
        const j0 = metroOrdering.GetLineIndexInOrder(u, v, line);
        if (h0.OrientedHubSegments[j0] == null || h0.OrientedHubSegments[j0].Segment == null) {
            const w = metroGraphData.PointToStations.get(i.next.point);
            const otherBase = v.BundleBases.get(w);
            const j1 = metroOrdering.GetLineIndexInOrder(w, v, line);
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(h0.Points[j0], otherBase.Points[j1]);
        }
        return h0.OrientedHubSegments[j0].Segment;
    }
    CreateSegmentsInsideHubs() {
        for (const metroline of this.metroGraphData.Metrolines) {
            this.CreateOrientedSegsOnLine(metroline);
        }
        if (this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs) {
            this.FanBezierSegs();
        }
    }
    CreateOrientedSegsOnLine(line) {
        for (let polyPoint = line.Polyline.startPoint.next; polyPoint.next != null; polyPoint = polyPoint.next) {
            this.CreateICurveForOrientedSeg(line, polyPoint);
        }
    }
    CreateICurveForOrientedSeg(line, polyPoint) {
        const u = this.metroGraphData.PointToStations.get(polyPoint.prev.point);
        const v = this.metroGraphData.PointToStations.get(polyPoint.point);
        const w = this.metroGraphData.PointToStations.get(polyPoint.next.point);
        const h0 = v.BundleBases.get(u);
        const h1 = v.BundleBases.get(w);
        const j0 = this.metroOrdering.GetLineIndexInOrder(u, v, line);
        const j1 = this.metroOrdering.GetLineIndexInOrder(w, v, line);
        const seg = this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs
            ? EdgeNudger.StandardBezier(h0.Points[j0], h0.Tangents[j0], h1.Points[j1], h1.Tangents[j1])
            : EdgeNudger.BiArc(h0.Points[j0], h0.Tangents[j0], h1.Points[j1], h1.Tangents[j1]);
        h0.OrientedHubSegments[j0].Segment = seg;
        h1.OrientedHubSegments[j1].Segment = seg;
        // if (seg instanceof BezierSeg) {
        //  const dc = [
        //    DebugCurve.mkDebugCurveTWCI(200, 1, 'Blue', LineSegment.mkPP(h1.Points[0], h1.Points[h1.length - 1])),
        //    DebugCurve.mkDebugCurveTWCI(200, 1, 'Black', LineSegment.mkPP(h0.Points[0], h0.Points[h0.length - 1])),
        //    DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Red', LineSegment.mkPP(h0.Points[j0], h0.Points[j0].add(h0.Tangents[j0]))),
        //    DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Green', LineSegment.mkPP(h1.Points[j1], h1.Points[j1].add(h1.Tangents[j1]))),
        //  ]
        //  dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.1, 'Brown', seg))
        //  dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Pink', line.Polyline))
        //  dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Tan', u.BoundaryCurve))
        //  dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Plum', v.BoundaryCurve))
        //  dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'DarkOrange', w.BoundaryCurve))
        //  SvgDebugWriter.dumpDebugCurves('./tmp/hubs' + EdgeNudger.debCount + '.svg', dc)
        // }
    }
    static ShowHubs(metroGraphData, metroMapOrdering, station, fileName, moreCurves = []) {
        let ttt = EdgeNudger.GetAllDebugCurves(metroMapOrdering, metroGraphData);
        if (station != null) {
            ttt.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_3__.DebugCurve.mkDebugCurveTWCI(255, 1, 'red', _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkDiamond(5, 25, station.Position)));
        }
        ttt = ttt.concat(moreCurves);
        // SvgDebugWriter.dumpDebugCurves(fileName, ttt) // uncomment this line to get the SVG output
    }
    static GetAllDebugCurves(metroMapOrdering, metroGraphData) {
        return EdgeNudger.GraphNodes(metroGraphData)
            .concat(EdgeNudger.VertexDebugCurves(metroMapOrdering, metroGraphData))
            .concat(EdgeNudger.DebugEdges(metroGraphData));
    }
    static DebugEdges(metroGraphData1) {
        return metroGraphData1.Edges.map((e) => _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_3__.DebugCurve.mkDebugCurveTWCI(40, 0.1, 'gray', e.curve));
    }
    static VertexDebugCurves(metroMapOrdering, metroGraphData) {
        return EdgeNudger.DebugCircles(metroGraphData)
            .concat(EdgeNudger.DebugHubBases(metroGraphData))
            .concat(EdgeNudger.DebugSegs(metroGraphData))
            .concat(EdgeNudger.BetweenHubs(metroMapOrdering, metroGraphData));
    }
    static BetweenHubs(metroMapOrdering, metroGraphData) {
        const ret = [];
        for (const ml of metroGraphData.Metrolines) {
            const segs = EdgeNudger.GetInterestingSegs(metroGraphData, metroMapOrdering, ml);
            const color = EdgeNudger.GetMonotoneColor(ml.Polyline.start, ml.Polyline.end, segs);
            for (const seg of segs) {
                ret.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_3__.DebugCurve.mkDebugCurveTWCI(100, ml.Width, color, _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(seg[0], seg[1])));
            }
        }
        return ret;
    }
    static GetInterestingSegs(metroGraphData, metroMapOrdering, line) {
        const ret = new Array();
        if (metroGraphData.Stations.length === 0 ||
            metroGraphData.Stations[0].BundleBases == null ||
            metroGraphData.Stations[0].BundleBases.size === 0)
            return [];
        let start = EdgeNudger.FindCurveStart(metroGraphData, metroMapOrdering, line);
        const cubicSegs = EdgeNudger.HubSegsOfLine(metroGraphData, metroMapOrdering, line);
        for (const seg of cubicSegs) {
            if (seg == null) {
                continue;
            }
            ret.push([start, seg.start]);
            start = seg.end;
        }
        ret.push([start, EdgeNudger.FindCurveEnd(metroGraphData, metroMapOrdering, line)]);
        return ret;
    }
    static GetMonotoneColor(start, end, segs) {
        return 'green';
        //            Point dir = end - start;
        //            bool monotone = segs.All(seg => (seg.Second - seg.First)*dir >= 0);
        //            return monotone ? "green" : "magenta";
    }
    static DebugHubBases(metroGraphData) {
        const dc = new Array();
        for (const s of metroGraphData.Stations) {
            for (const h of s.BundleBases.values()) {
                dc.push(_math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_3__.DebugCurve.mkDebugCurveTWCI(100, 1, 'red', _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(h.EndPoint, h.StartPoint)));
            }
        }
        return dc;
        // return
        //    metroGraphData.Stations.SelectMany(s => s.BundleBases.Values).Select(
        //        h => new DebugCurve(100, 0.01, "red", new LineSegment(h.Points[0], h.Points.Last())));
    }
    static DebugCircles(metroGraphData) {
        return metroGraphData.Stations.map((station) => _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_3__.DebugCurve.mkDebugCurveTWCI(100, 0.1, 'blue', _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkCircle(station.Radius, station.Position)));
    }
    static DebugSegs(metroGraphData) {
        const ls = new Array();
        for (const s of metroGraphData.VirtualStations()) {
            for (const b of s.BundleBases.values()) {
                for (const h of b.OrientedHubSegments) {
                    if (h == null) {
                        continue;
                    }
                    if (h.Segment == null) {
                        const uBase = h.Other.BundleBase;
                        const i = h.Index;
                        const j = h.Other.Index;
                        ls.push(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(b.Points[i], uBase.Points[j]));
                    }
                    else {
                        ls.push(h.Segment);
                    }
                }
            }
        }
        return ls.map((s) => _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_3__.DebugCurve.mkDebugCurveTWCI(100, 0.01, 'green', s));
    }
    static GraphNodes(metroGraphData) {
        const nodes = metroGraphData.Edges.map((e) => e.sourcePort.Curve).concat(metroGraphData.Edges.map((e) => e.targetPort.Curve));
        return nodes.map((n) => _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_3__.DebugCurve.mkDebugCurveTWCI(40, 1, 'black', n));
    }
    static BiArc(p0, ts, p4, te) {
        //Assert.assert(closeDistEps(ts.lengthSquared, 1))
        //Assert.assert(closeDistEps(te.lengthSquared, 1))
        const v = p0.sub(p4);
        if (v.length < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon)
            return null;
        const vtse = v.dot(ts.sub(te));
        const tste = -ts.dot(te);
        //bad input for BiArc. we shouldn't allow such cases during bundle bases construction
        if (ts.dot(p4.sub(p0)) <= 0 && ts.dot(te) <= 0) {
            //switch to Bezier
            return EdgeNudger.StandardBezier(p0, ts, p4, te);
        }
        //solving a quadratic equation
        const a = 2 * (tste - 1);
        const b = 2 * vtse;
        const c = v.dot(v);
        let al;
        if (Math.abs(a) < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            //we have b*al+c=0
            if (Math.abs(b) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                al = -c / b;
            }
            else {
                return null;
            }
        }
        else {
            let d = b * b - 4 * a * c;
            //Assert.assert(d >= -GeomConstants.tolerance)
            if (d < 0)
                d = 0;
            d = Math.sqrt(d);
            al = (-b + d) / (2 * a);
            if (al < 0)
                al = (-b - d) / (2 * a);
        }
        const p1 = p0.add(ts.mul(al));
        const p3 = p4.add(te.mul(al));
        const p2 = ___WEBPACK_IMPORTED_MODULE_0__.Point.middle(p1, p3);
        const orient1 = ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(p0, p1, p2);
        const orient2 = ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(p2, p3, p4);
        if (orient1 !== orient2) {
            return EdgeNudger.StandardBezier(p0, ts, p4, te);
        }
        const curve = new _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve();
        curve.addSegs([EdgeNudger.ArcOn(p0, p1, p2), EdgeNudger.ArcOn(p2, p3, p4)]);
        return curve;
    }
    // returns the arc that a,b,c touches
    static ArcOn(a, b, c) {
        const t = { center: null };
        if (Math.abs(___WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(a, b, c)) < 0.0001 || !EdgeNudger.FindArcCenter(a, b, c, t)) {
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(a, c);
        }
        const center = t.center;
        const radius = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.distPP)(a, center);
        const chordLength = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.distPP)(a, b);
        if (chordLength / radius < 0.0001) {
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(a, c);
        }
        const cenA = a.sub(center);
        let aAngle = Math.atan2(cenA.y, cenA.x);
        const cenC = c.sub(center);
        let cAngle = Math.atan2(cenC.y, cenC.x);
        let delac = cAngle - aAngle;
        if (delac < 0) {
            delac += 2 * Math.PI;
            cAngle += 2 * Math.PI;
        }
        if (delac <= Math.PI) {
            // going ccw
            const el = new _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_4__.Ellipse(aAngle, cAngle, new ___WEBPACK_IMPORTED_MODULE_0__.Point(radius, 0), new ___WEBPACK_IMPORTED_MODULE_0__.Point(0, radius), center);
            return el;
        }
        // going clockwise
        if (cAngle > 2 * Math.PI) {
            cAngle -= 2 * Math.PI;
        }
        aAngle = Math.PI - aAngle;
        cAngle = Math.PI - cAngle;
        if (aAngle < 0) {
            aAngle += 2 * Math.PI;
        }
        while (cAngle < aAngle) {
            cAngle += 2 * Math.PI;
        }
        delac = cAngle - aAngle;
        //Assert.assert(delac <= Math.PI)
        return new _math_geometry_ellipse__WEBPACK_IMPORTED_MODULE_4__.Ellipse(aAngle, cAngle, new ___WEBPACK_IMPORTED_MODULE_0__.Point(-radius, 0), new ___WEBPACK_IMPORTED_MODULE_0__.Point(0, radius), center);
    }
    static FindArcCenter(a, b, c, t) {
        const perp0 = b.sub(a).rotate90Cw();
        const perp1 = b.sub(c).rotate90Cw();
        t.center = ___WEBPACK_IMPORTED_MODULE_0__.Point.lineLineIntersection(a, a.add(perp0), c, c.add(perp1));
        return t.center != null;
    }
    static StandardBezier(segStart, tangentAtStart, segEnd, tangentAtEnd) {
        const len = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_5__.distPP)(segStart, segEnd) / 4;
        return _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_2__.BezierSeg.mkBezier([segStart, segStart.add(tangentAtStart.mul(len)), segEnd.add(tangentAtEnd.mul(len)), segEnd]);
    }
    FanBezierSegs() {
        let progress = true;
        const maxSteps = 5;
        let steps = 0;
        while (progress && steps++ < maxSteps) {
            progress = false;
            for (const s of this.metroGraphData.Stations)
                for (const segmentHub of s.BundleBases.values())
                    progress || (progress = this.FanEdgesOfHubSegment(segmentHub));
        }
    }
    FanEdgesOfHubSegment(bundleHub) {
        let ret = false;
        for (let i = 0; i < bundleHub.Count - 1; i++) {
            ret || (ret = this.FanCouple(bundleHub, i, bundleHub.CurveCenter, bundleHub.Curve.boundingBox.diagonal / 2));
        }
        return ret;
    }
    // fans the couple i,i+1
    FanCouple(bundleHub, i, center, radius) {
        const lSeg = bundleHub.OrientedHubSegments[i];
        const rSeg = bundleHub.OrientedHubSegments[i + 1];
        if (lSeg == null) {
            return false;
        }
        const x = (0,_math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_10__.segmentsIntersect)(lSeg.Segment.start, lSeg.Segment.end, rSeg.Segment.start, rSeg.Segment.end);
        if (x) {
            // it doesn not make sense to push these segs apart
            return false;
        }
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(lSeg.value(0), lSeg.value(0.5), lSeg.value(1)) !=
            ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(rSeg.value(0), rSeg.value(0.5), rSeg.value(1))) {
            return false;
        }
        const ll = this.BaseLength(lSeg);
        const rl = this.BaseLength(rSeg);
        if (Math.abs(ll - rl) < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon) {
            return false;
        }
        if (ll > rl) {
            return this.AdjustLongerSeg(lSeg, rSeg, center, radius);
        }
        return this.AdjustLongerSeg(rSeg, lSeg, center, radius);
    }
    AdjustLongerSeg(longerSeg, shorterSeg, center, radius) {
        const del0 = longerSeg.value(0).sub(shorterSeg.value(0));
        const del1 = longerSeg.value(1).sub(shorterSeg.value(1));
        const minDelLength = Math.min(del0.length, del1.length);
        const midPointOfShorter = shorterSeg.value(0.5);
        const maxDelLen = Math.max(del0.length, del1.length);
        if (this.NicelyAligned(longerSeg.Segment, del0, del1, midPointOfShorter, minDelLength, maxDelLen) === 0) {
            return false;
        }
        return this.FitLonger(longerSeg, del0, del1, midPointOfShorter, minDelLength, maxDelLen, center, radius);
    }
    FitLonger(longerOrientedSeg, del0, del1, midPointOfShorter, minDelLength, maxDel, center, radius) {
        let seg = longerOrientedSeg.Segment;
        const start = seg.start;
        const end = seg.end;
        // LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve("green", shorterDebugOnly), new DebugCurve("red", seg));
        let steps = 0;
        const maxSteps = 10;
        let lowP1 = seg.start.mul(1 - EdgeNudger.SqueezeBound).add(seg.B(1).mul(EdgeNudger.SqueezeBound));
        let lowP2 = seg.end.mul(1 - EdgeNudger.SqueezeBound).add(seg.B(2).mul(EdgeNudger.SqueezeBound));
        let highP1 = seg.B(1).mul(2).sub(seg.start);
        // originally the tangents were 0.25 of the length of seg[1]-seg[0] - so were are safe to lengthen two times
        let highP2 = seg.B(2).mul(2).sub(seg.end);
        const t = { highP: highP1 };
        this.PullControlPointToTheCircle(seg.start, t, center, radius);
        highP1 = t.highP;
        let r = this.NicelyAligned(seg, del0, del1, midPointOfShorter, minDelLength, maxDel);
        do {
            if (r === -1) {
                // pull the control points lower
                const p1 = ___WEBPACK_IMPORTED_MODULE_0__.Point.middle(seg.B(1), lowP1);
                const p2 = ___WEBPACK_IMPORTED_MODULE_0__.Point.middle(seg.B(2), lowP2);
                highP1 = seg.B(1);
                highP2 = seg.B(2);
                seg = new _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_2__.BezierSeg(start, p1, p2, end);
            }
            else {
                //Assert.assert(r === 1)
                // pull the control points higher
                const p1 = ___WEBPACK_IMPORTED_MODULE_0__.Point.middle(seg.B(1), highP1);
                const p2 = (seg.B(2), highP2);
                lowP1 = seg.B(1);
                lowP2 = seg.B(2);
                seg = new _math_geometry_bezierSeg__WEBPACK_IMPORTED_MODULE_2__.BezierSeg(start, p1, p2, end);
            }
            if ((r = this.NicelyAligned(seg, del0, del1, midPointOfShorter, minDelLength, maxDel)) === 0) {
                longerOrientedSeg.Segment = seg;
                longerOrientedSeg.Other.Segment = seg;
                return true;
            }
            if (steps++ > maxSteps)
                return false; //cannot fix it
            // cannot fix it
        } while (true);
    }
    PullControlPointToTheCircle(start, t, center, radius) {
        const closestPointOnLine = ___WEBPACK_IMPORTED_MODULE_0__.Point.ProjectionToLine(start, t.highP, center);
        // the max offset from closestPointOnLine
        const maxOffset = Math.sqrt(radius * radius - closestPointOnLine.sub(center).lengthSquared);
        const offsetNow = t.highP.sub(closestPointOnLine);
        const offsetLen = offsetNow.length;
        if (offsetLen > maxOffset) {
            t.highP = closestPointOnLine.add(offsetNow.mul(maxOffset / offsetLen));
        }
    }
    //
    NicelyAligned(longerSeg, del0, del1, midPointOfShorter, minDelLength, maxDelLen) {
        const eps = 0.001;
        const midDel = longerSeg.value(0.5).sub(midPointOfShorter);
        const midDelLen = midDel.length;
        if (del0.dot(midDel) < 0 || del1.dot(midDel) < 0) {
            return 1;
        }
        if (midDelLen < minDelLength - eps) {
            return 1;
        }
        if (midDelLen > maxDelLen + eps) {
            return -1;
        }
        return 0;
    }
    BaseLength(seg) {
        return seg.value(0).sub(seg.value(1)).lengthSquared;
    }
}
/* const */ EdgeNudger.SqueezeBound = 0.2;
//# sourceMappingURL=EdgeNudger.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/FlipSwitcher.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FlipSwitcher: () => (/* binding */ FlipSwitcher)
/* harmony export */ });
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");
/* harmony import */ var _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js");
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _MetroGraphData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/MetroGraphData.js");
/* harmony import */ var _PathFixer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/PathFixer.js");







class FlipSwitcher {
    get Polylines() {
        return Array.from(this.polylineToEdgeGeom.keys());
    }
    constructor(metroGraphData) {
        this.polylineToEdgeGeom = new Map();
        this.pathsThroughPoints = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_2__.PointMap();
        this.interestingPoints = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_3__.PointSet();
        this.metroGraphData = metroGraphData;
    }
    Run() {
        // TimeMeasurer.DebugOutput("switching flips...");
        this.Init();
        this.SwitchFlips();
    }
    Init() {
        for (const e of this.metroGraphData.Edges) {
            this.polylineToEdgeGeom.set(e.curve, e);
        }
        for (const poly of this.Polylines) {
            this.RegisterPolylinePointInPathsThrough(poly.polylinePoints());
        }
    }
    RegisterPolylinePointInPathsThrough(points) {
        for (const pp of points)
            this.RegisterPolylinePointInPathsThroughP(pp);
    }
    RegisterPolylinePointInPathsThroughP(pp) {
        addToPointMap(this.pathsThroughPoints, pp.point, pp);
    }
    UnregisterPolylinePointsInPathsThrough(points) {
        for (const pp of points)
            this.UnregisterPolylinePointInPathsThrough(pp);
    }
    UnregisterPolylinePointInPathsThrough(pp) {
        removeFromPointMap(this.pathsThroughPoints, pp.point, pp);
    }
    SwitchFlips() {
        const queued = new Set(this.Polylines);
        const queue = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
        for (const e of this.Polylines) {
            queue.enqueue(e);
        }
        while (queue.length > 0) {
            const initialPolyline = queue.dequeue();
            queued.delete(initialPolyline);
            const changedPolyline = this.ProcessPolyline(initialPolyline);
            if (changedPolyline != null) {
                // we changed both polylines
                if (!queued.has(initialPolyline)) {
                    queued.add(initialPolyline);
                    queue.enqueue(initialPolyline);
                }
                if (!queued.has(changedPolyline)) {
                    queued.add(changedPolyline);
                    queue.enqueue(changedPolyline);
                }
            }
        }
    }
    ProcessPolyline(polyline) {
        const departed = new Map();
        for (let pp = polyline.startPoint.next; pp != null; pp = pp.next) {
            this.FillDepartedPolylinePoints(pp, departed);
            // find returning
            for (const polyPoint of this.pathsThroughPoints.get(pp.point)) {
                const departingPP = departed.get(polyPoint.polyline);
                if (departingPP) {
                    if (this.ProcessFlip(pp, departingPP)) {
                        return polyPoint.polyline;
                    }
                    departed.delete(polyPoint.polyline);
                }
            }
        }
        return null;
    }
    FillDepartedPolylinePoints(pp, departed) {
        const prevPoint = pp.prev.point;
        for (const polyPoint of this.pathsThroughPoints.get(prevPoint)) {
            if (!this.IsNeighborOnTheSamePolyline(polyPoint, pp)) {
                if (!departed.has(polyPoint.polyline)) {
                    departed.set(polyPoint.polyline, polyPoint);
                }
            }
        }
    }
    ProcessFlip(flipStartPP, flipEndPP) {
        // temporary switching polylines of the same width only
        // need to check capacities here
        const polyA = flipStartPP.polyline;
        const polyB = flipEndPP.polyline;
        const flipStart = flipStartPP.point;
        const flipEnd = flipEndPP.point;
        const ea = this.polylineToEdgeGeom.get(polyA);
        const eb = this.polylineToEdgeGeom.get(polyB);
        if (ea.lineWidth !== eb.lineWidth ||
            this.metroGraphData.EdgeLooseEnterable == null ||
            !(0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_4__.setsAreEqual)(this.metroGraphData.EdgeLooseEnterable.get(ea), this.metroGraphData.EdgeLooseEnterable.get(eb))) {
            return false;
        }
        //    polyA.init()
        // polyB.init()
        // FlipSwitcher.debugCount++
        // if (FlipSwitcher.debugCount === 3) {
        //  const da = DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', polyA)
        //  const aStart = DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', CurveFactory.mkCircle(10, polyA.start))
        //  const aEnd = DebugCurve.mkDebugCurveTWCI(100, 0.2, 'Red', CurveFactory.mkCircle(5, polyA.end))
        //  const db = DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Blue', polyB)
        //  const bStart = DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Blue', CurveFactory.mkCircle(4, polyB.start))
        //  const bEnd = DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Blue', CurveFactory.mkCircle(2, polyB.end))
        //  SvgDebugWriter.dumpDebugCurves('./tmp/dadb_.svg', [da, db, aStart, aEnd, bStart, bEnd])
        //  //   throw new Error()
        // }
        let pts = this.FindPointsOnPolyline(polyA, flipStart, flipEnd);
        const aFirst = pts[0];
        const aLast = pts[1];
        const forwardOrderA = pts[2];
        pts = this.FindPointsOnPolyline(polyB, flipStart, flipEnd);
        const bFirst = pts[0];
        const bLast = pts[1];
        const forwardOrderB = pts[2];
        //Assert.assert(this.PolylinePointsAreInForwardOrder(aFirst, aLast) === forwardOrderA)
        //Assert.assert(this.PolylinePointsAreInForwardOrder(bFirst, bLast) === forwardOrderB)
        // 0 - the end
        // 1 - not intersect
        // 2 - intersect
        const rel1 = this.FindRelationOnFirstPoint(aFirst, bFirst, forwardOrderA, forwardOrderB);
        const rel2 = this.FindRelationOnLastPoint(aLast, bLast, forwardOrderA, forwardOrderB);
        // no intersection on both sides
        if (rel1 !== 2 && rel2 !== 2) {
            return false;
        }
        // can't swap to reduce crossings
        if (rel1 === 1 || rel2 === 1) {
            return false;
        }
        // unregister
        this.UnregisterPolylinePointsInPathsThrough(polyA.polylinePoints());
        this.UnregisterPolylinePointsInPathsThrough(polyB.polylinePoints());
        // switching
        this.Swap(aFirst, bFirst, aLast, bLast, forwardOrderA, forwardOrderB);
        // register back
        this.RegisterPolylinePointInPathsThrough(polyA.polylinePoints());
        this.RegisterPolylinePointInPathsThrough(polyB.polylinePoints());
        this.RegisterInterestingPoint(aFirst.point);
        this.RegisterInterestingPoint(aLast.point);
        this.numberOfReducedCrossings++;
        return true;
    }
    FindPointsOnPolyline(polyline, first, last) {
        let ppFirst;
        let ppLast;
        for (let pp = polyline.startPoint; pp != null; pp = pp.next) {
            if (ppFirst == null) {
                if (pp.point.equal(first)) {
                    if (ppLast != null) {
                        return [pp, ppLast, false];
                    }
                    ppFirst = pp;
                }
                else {
                    if (ppLast == null && pp.point.equal(last)) {
                        ppLast = pp;
                    }
                }
            }
            else {
                // got ppFirst arleady
                if (pp.point.equal(last)) {
                    return [ppFirst, pp, true];
                }
            }
        }
        //Assert.assert(false)
    }
    PolylinePointsAreInForwardOrder(u, v) {
        //Assert.assert(u.polyline === v.polyline)
        for (let p = u; p != null; p = p.next) {
            if (p === v) {
                return true;
            }
        }
        return false;
    }
    Next(p, forwardOrder) {
        return forwardOrder ? p.next : p.prev;
    }
    Prev(p, forwardOrder) {
        return forwardOrder ? p.prev : p.next;
    }
    FindRelationOnFirstPoint(aFirst, bFirst, forwardOrderA, forwardOrderB) {
        //Assert.assert(aFirst.point.equal(bFirst.point))
        const a0 = aFirst;
        const b0 = bFirst;
        while (true) {
            const prevA = this.Prev(aFirst, forwardOrderA);
            const prevB = this.Prev(bFirst, forwardOrderB);
            if (prevA == null || prevB == null) {
                //Assert.assert(prevA == null  && prevB == null )
                return 0;
            }
            if (!prevA.point.equal(prevB.point)) {
                break;
            }
            aFirst = prevA;
            bFirst = prevB;
        }
        return this.PolylinesIntersect(a0, b0, aFirst, bFirst, forwardOrderA, forwardOrderB);
    }
    FindRelationOnLastPoint(aLast, bLast, forwardOrderA, forwardOrderB) {
        //Assert.assert(aLast.point.equal(bLast.point))
        const a0 = aLast;
        const b0 = bLast;
        while (true) {
            const nextA = this.Next(aLast, forwardOrderA);
            const nextB = this.Next(bLast, forwardOrderB);
            if (nextA == null || nextB == null) {
                //Assert.assert(nextA == null  && nextB == null )
                return 0;
            }
            if (!nextA.point.equal(nextB.point)) {
                break;
            }
            aLast = nextA;
            bLast = nextB;
        }
        while (this.Next(aLast, forwardOrderA).point.equal(this.Prev(bLast, forwardOrderB).point)) {
            aLast = this.Next(aLast, forwardOrderA);
            bLast = this.Prev(bLast, forwardOrderB);
        }
        return this.PolylinesIntersect(aLast, bLast, a0, b0, forwardOrderA, forwardOrderB);
    }
    PolylinesIntersect(a0, b0, a1, b1, forwardOrderA, forwardOrderB) {
        const a0p = this.Prev(a0, forwardOrderA);
        const a0n = this.Next(a0, forwardOrderA);
        const a1n = this.Next(a1, forwardOrderA);
        const a1p = this.Prev(a1, forwardOrderA);
        const b0n = this.Next(b0, forwardOrderB);
        const b1p = this.Prev(b1, forwardOrderB);
        if (a0.point.equal(a1.point)) {
            const bs = a0.point;
            const left0 = (0,_MetroGraphData__WEBPACK_IMPORTED_MODULE_5__.getOrientationOf3Vectors)(a1p.point.sub(bs), b1p.point.sub(bs), a0n.point.sub(bs));
            const left1 = (0,_MetroGraphData__WEBPACK_IMPORTED_MODULE_5__.getOrientationOf3Vectors)(a1p.point.sub(bs), b0n.point.sub(bs), a0n.point.sub(bs));
            //Assert.assert(left0 !== 0 && left1 !== 0)
            return left0 === left1 ? 1 : 2;
        }
        else {
            const left0 = (0,_MetroGraphData__WEBPACK_IMPORTED_MODULE_5__.getOrientationOf3Vectors)(a0p.point.sub(a0.point), a0n.point.sub(a0.point), b0n.point.sub(a0.point));
            const left1 = (0,_MetroGraphData__WEBPACK_IMPORTED_MODULE_5__.getOrientationOf3Vectors)(a1n.point.sub(a1.point), b1p.point.sub(a1.point), a1p.point.sub(a1.point));
            //Assert.assert(left0 !== 0 && left1 !== 0)
            return left0 === left1 ? 1 : 2;
        }
    }
    Swap(aFirst, bFirst, aLast, bLast, forwardOrderA, forwardOrderB) {
        const intermediateAPoints = this.GetRangeOnPolyline(this.Next(aFirst, forwardOrderA), aLast, forwardOrderA);
        const intermediateBPoints = this.GetRangeOnPolyline(this.Next(bFirst, forwardOrderB), bLast, forwardOrderB);
        // changing a
        this.ChangePolylineSegment(aFirst, aLast, forwardOrderA, intermediateBPoints);
        // changing b
        this.ChangePolylineSegment(bFirst, bLast, forwardOrderB, intermediateAPoints);
        // resulting polylines might have cycles
        _PathFixer__WEBPACK_IMPORTED_MODULE_6__.PathFixer.RemoveSelfCyclesFromPolyline(aFirst.polyline);
        //Assert.assert(this.PolylineIsOK(aFirst.polyline))
        _PathFixer__WEBPACK_IMPORTED_MODULE_6__.PathFixer.RemoveSelfCyclesFromPolyline(bFirst.polyline);
        //Assert.assert(this.PolylineIsOK(bFirst.polyline))
    }
    ChangePolylineSegment(aFirst, aLast, forwardOrderA, intermediateBPoints) {
        let curA = aFirst;
        for (const b of intermediateBPoints) {
            const newp = _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_1__.PolylinePoint.mkFromPoint(b.point);
            newp.polyline = curA.polyline;
            if (forwardOrderA) {
                newp.prev = curA;
                curA.next = newp;
            }
            else {
                newp.next = curA;
                curA.prev = newp;
            }
            curA = newp;
        }
        if (forwardOrderA) {
            curA.next = aLast;
            aLast.prev = curA;
        }
        else {
            curA.prev = aLast;
            aLast.next = curA;
        }
    }
    GetRangeOnPolyline(start, end, forwardOrder) {
        const res = new Array();
        for (let pp = start; pp !== end; pp = this.Next(pp, forwardOrder)) {
            res.push(pp);
        }
        return res;
    }
    IsNeighborOnTheSamePolyline(a, b) {
        return (a.prev != null && a.prev.point.equal(b.point)) || (a.next != null && a.next.point.equal(b.point));
    }
    RegisterInterestingPoint(p) {
        if (!this.interestingPoints.has(p)) {
            this.interestingPoints.add(p);
        }
    }
    GetChangedHubs() {
        return this.interestingPoints;
    }
    NumberOfReducedCrossings() {
        return this.numberOfReducedCrossings;
    }
    PolylineIsOK(poly) {
        const pointsToPP = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_3__.PointSet();
        for (let pp = poly.startPoint; pp != null; pp = pp.next) {
            if (pp === poly.startPoint) {
                if (pp.prev != null) {
                    return false;
                }
            }
            else if (pp.prev.next !== pp) {
                return false;
            }
            if (pp === poly.endPoint) {
                if (pp.next != null) {
                    return false;
                }
            }
            else if (pp.next.prev !== pp) {
                return false;
            }
            if (pointsToPP.has(pp.point)) {
                return false;
            }
            pointsToPP.add(pp.point);
        }
        if (poly.startPoint.prev != null) {
            return false;
        }
        if (poly.endPoint.next != null) {
            return false;
        }
        return true;
    }
}
function addToPointMap(pointMap, point, pp) {
    let s = pointMap.get(point);
    if (!s) {
        s = new Set();
        pointMap.set(point, s);
    }
    s.add(pp);
}
function removeFromPointMap(pathsThroughPoints, point, pp) {
    const s = pathsThroughPoints.get(point);
    if (!s)
        return;
    s.delete(pp);
    if (s.size === 0) {
        pathsThroughPoints.deleteP(point);
    }
}
//# sourceMappingURL=FlipSwitcher.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/GeneralMetroMapOrdering.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeneralMetroMapOrdering: () => (/* binding */ GeneralMetroMapOrdering)
/* harmony export */ });
/* harmony import */ var _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/pointPair.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/pointPairMap.js");
/* harmony import */ var _MetroGraphData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/MetroGraphData.js");
/* harmony import */ var _PointPairOrder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/PointPairOrder.js");





// greedy bundle map ordering based on path comparison
class GeneralMetroMapOrdering {
    // Initialize bundle graph and build the ordering
    constructor(Metrolines) {
        this.Metrolines = Metrolines;
        this.BuildOrder();
    }
    *GetOrder(u, v) {
        const pointPair = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__.PointPair(u.Position, v.Position);
        const orderedMetrolineListForUv = this.bundles.get(pointPair).Metrolines;
        if (u.Position === pointPair.first) {
            for (let i = 0; i < orderedMetrolineListForUv.length; i++) {
                yield orderedMetrolineListForUv[i];
            }
        }
        else {
            for (let i = orderedMetrolineListForUv.length - 1; i >= 0; i--) {
                yield orderedMetrolineListForUv[i];
            }
        }
    }
    /**   Get the index of line on the edge (u->v) and node u */
    GetLineIndexInOrder(u, v, ml) {
        const pp = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__.PointPair(u.Position, v.Position);
        const reversed = u.Position !== pp.first; // we can use the object comparison here because there is no cloning in PointPair
        const d = this.bundles.get(pp).LineIndexInOrder;
        return !reversed ? d.get(ml) : d.size - 1 - d.get(ml);
    }
    /**   Do the main job */
    BuildOrder() {
        this.bundles = new _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_2__.PointPairMap();
        // initialization
        for (const ml of this.Metrolines) {
            for (let p = ml.Polyline.startPoint; p.next != null; p = p.next) {
                const e = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__.PointPair(p.point, p.next.point);
                let li = this.bundles.get(e);
                if (!li) {
                    this.bundles.set(e, (li = new _PointPairOrder__WEBPACK_IMPORTED_MODULE_4__.PointPairOrder()));
                }
                li.Add(ml);
            }
        }
        for (const edge of this.bundles) {
            this.BuildOrderPP(edge[0], edge[1]);
        }
    }
    /**   Build an order for edge (u->v) */
    BuildOrderPP(pair, order) {
        if (order.orderFixed) {
            return;
        }
        order.Metrolines.sort((line0, line1) => this.CompareLines(line0, line1, pair.first, pair.second));
        // save order
        order.orderFixed = true;
        order.LineIndexInOrder = new Map();
        for (let i = 0; i < order.Metrolines.length; i++) {
            order.LineIndexInOrder.set(order.Metrolines[i], i);
        }
    }
    /**   Compare two lines on station u with respect to edge (u->v) */
    CompareLines(ml0, ml1, u, v) {
        const t = { polyPoint: null, next: null, prev: null };
        this.FindStationOnLine(u, v, ml0, t);
        const polylinePoint0 = t.polyPoint;
        const next0 = t.next;
        const prev0 = t.prev;
        this.FindStationOnLine(u, v, ml1, t);
        const polylinePoint1 = t.polyPoint;
        const next1 = t.next;
        const prev1 = t.prev;
        // go backward
        let p0 = polylinePoint0;
        let p1 = polylinePoint1;
        let p11;
        let p00;
        while ((p00 = prev0(p0)) != null && (p11 = prev1(p1)) != null && p00.point.equal(p11.point)) {
            const edge = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__.PointPair(p00.point, p0.point);
            if (this.bundles.get(edge).orderFixed) {
                return this.CompareOnFixedOrder(edge, ml0, ml1, !p00.point.equal(edge.first));
            }
            p0 = p00;
            p1 = p11;
        }
        if (p00 != null && p11 != null) {
            // we have a backward fork
            const forkBase = p0.point;
            return -GeneralMetroMapOrdering.IsLeft(next0(p0).point.sub(forkBase), p00.point.sub(forkBase), p11.point.sub(forkBase));
        }
        // go forward
        p0 = polylinePoint0;
        p1 = polylinePoint1;
        while ((p00 = next0(p0)) != null && (p11 = next1(p1)) != null && p00.point.equal(p11.point)) {
            const edge = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__.PointPair(p00.point, p0.point);
            if (this.bundles.get(edge).orderFixed) {
                return this.CompareOnFixedOrder(edge, ml0, ml1, !p0.point.equal(edge.first));
            }
            p0 = p00;
            p1 = p11;
        }
        if (p00 != null && p11 != null) {
            // compare forward fork
            const forkBase = p0.point;
            return GeneralMetroMapOrdering.IsLeft(prev0(p0).point.sub(forkBase), p00.point.sub(forkBase), p11.point.sub(forkBase));
        }
        // these are multiple edges
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(ml0.Index, ml1.Index);
    }
    CompareOnFixedOrder(edge, ml0, ml1, reverse) {
        const mlToIndex = this.bundles.get(edge).LineIndexInOrder;
        const r = reverse ? -1 : 1;
        return r * (0,_utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(mlToIndex.get(ml0), mlToIndex.get(ml1));
    }
    /** Fills Next and Prev functions according to the direction of the metroline */
    // todo?  Reimplement it in more efficient way!!! (cache indexes)
    FindStationOnLine(u, v, ml, t) {
        for (let p = ml.Polyline.startPoint; p.next != null; p = p.next) {
            if (p.point.equal(u) && p.next.point.equal(v)) {
                t.next = (k) => k.next;
                t.prev = (k) => k.prev;
                t.polyPoint = p;
                return;
            }
            if (p.point.equal(v) && p.next.point.equal(u)) {
                t.next = (k) => k.prev;
                t.prev = (k) => k.next;
                t.polyPoint = p.next;
                return;
            }
        }
        throw new Error();
    }
    /**  computes orientation of three vectors with a common source
       (compare the polar angles of v1 and v2 with respect to v0),
        return -1 if the orientation is v0 v1 v2,
                 1 if the orientation is v0 v2 v1,
                 0  if v1 and v2 are collinear and codirectinal, TODO: seems fishy */
    static IsLeft(v0, v1, v2) {
        return (0,_MetroGraphData__WEBPACK_IMPORTED_MODULE_3__.getOrientationOf3Vectors)(v0, v1, v2);
    }
}
//# sourceMappingURL=GeneralMetroMapOrdering.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/HubRadiiCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HubRadiiCalculator: () => (/* binding */ HubRadiiCalculator)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");




// Calculates node radii with 'water algorithm'
class HubRadiiCalculator {
    constructor(metroGraphData, bundlingSettings) {
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
    }
    // calculate node radii with fixed hubs
    CreateNodeRadii() {
        // set radii to zero
        for (const v of this.metroGraphData.VirtualStations()) {
            v.Radius = 0;
            v.cachedIdealRadius = HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, v);
        }
        // TimeMeasurer.DebugOutput("Initial cost of radii: " + Cost());
        this.GrowHubs(false);
        // maximally use free space
        this.GrowHubs(true);
        // TimeMeasurer.DebugOutput("Optimized cost of radii: " + Cost());
        // ensure radii are not zero
        for (const v of this.metroGraphData.VirtualStations()) {
            v.Radius = Math.max(v.Radius, this.bundlingSettings.MinHubRadius);
        }
    }
    // Grow hubs
    GrowHubs(useHalfEdgesAsIdealR) {
        const queue = new _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_2__.GenericBinaryHeapPriorityQueue(_utils_compare__WEBPACK_IMPORTED_MODULE_3__.compareNumbers);
        for (const v of this.metroGraphData.VirtualStations()) {
            queue.Enqueue(v, -this.CalculatePotential(v, useHalfEdgesAsIdealR));
        }
        let progress = false;
        // choose a hub with the greatest potential
        while (!queue.IsEmpty()) {
            const t = { priority: 0 };
            const v = queue.DequeueAndGetPriority(t);
            if (t.priority >= 0) {
                break;
            }
            // grow the hub
            if (this.TryGrowHub(v, useHalfEdgesAsIdealR)) {
                queue.Enqueue(v, -this.CalculatePotential(v, useHalfEdgesAsIdealR));
                progress = true;
            }
        }
        return progress;
    }
    TryGrowHub(v, useHalfEdgesAsIdealR) {
        const allowedRadius = this.CalculateAllowedHubRadius(v);
        //Debug.Assert(allowedRadius > 0);
        if (v.Radius >= allowedRadius)
            return false;
        const idealR = useHalfEdgesAsIdealR
            ? HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings, v)
            : v.cachedIdealRadius;
        //Debug.Assert(idealR > 0);
        if (v.Radius >= idealR)
            return false;
        const step = 0.05;
        let delta = step * (idealR - v.Radius);
        if (delta < 1.0)
            delta = 1.0;
        const newR = Math.min(v.Radius + delta, allowedRadius);
        if (newR <= v.Radius)
            return false;
        v.Radius = newR;
        return true;
    }
    CalculatePotential(v, useHalfEdgesAsIdealR) {
        const idealR = useHalfEdgesAsIdealR
            ? HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings, v)
            : v.cachedIdealRadius;
        if (idealR <= v.Radius) {
            return 0;
        }
        return (idealR - v.Radius) / idealR;
    }
    // Returns the maximal possible radius of the node
    CalculateAllowedHubRadius(node) {
        let r = this.bundlingSettings.MaxHubRadius;
        //adjacent nodes
        for (const adj of node.Neighbors) {
            const dist = adj.Position.sub(node.Position).length;
            //Debug.Assert(dist - 0.05 * (node.Radius + adj.Radius) + 1 >= node.Radius + adj.Radius);
            r = Math.min(r, dist / 1.05 - adj.Radius);
        }
        //TODO: still we can have two intersecting hubs for not adjacent nodes
        //obstacles
        const minimalDistance = this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(node, node.Position, r);
        if (minimalDistance < r)
            r = minimalDistance - 0.001;
        return Math.max(r, 0.1);
    }
    // Returns the ideal radius of the hub
    static CalculateIdealHubRadius(metroGraphData, bundlingSettings, node) {
        let r = 1.0;
        for (const adj of node.Neighbors) {
            const width = metroGraphData.GetWidthSSN(adj, node, bundlingSettings.EdgeSeparation);
            const nr = width / 2.0 + bundlingSettings.EdgeSeparation;
            r = Math.max(r, nr);
        }
        r = Math.min(r, 2 * bundlingSettings.MaxHubRadius);
        return r;
    }
    // Returns the ideal radius of the hub
    static CalculateIdealHubRadiusWithNeighborsMBS(metroGraphData, bundlingSettings, node) {
        return HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBNP(metroGraphData, bundlingSettings, node, node.Position);
    }
    // Returns the ideal radius of the hub
    static CalculateIdealHubRadiusWithNeighborsMBNP(metroGraphData, bundlingSettings, node, newPosition) {
        let r = HubRadiiCalculator.CalculateIdealHubRadius(metroGraphData, bundlingSettings, node);
        if (node.Neighbors.length > 1) {
            const adjNodes = node.Neighbors;
            // there must be enough space between neighbor bundles
            for (let i = 0; i < adjNodes.length; i++) {
                const adj = adjNodes[i];
                const nextAdj = adjNodes[(i + 1) % adjNodes.length];
                r = Math.max(r, HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles(r, node, newPosition, adj, nextAdj, metroGraphData, bundlingSettings));
            }
        }
        r = Math.min(r, 2 * bundlingSettings.MaxHubRadius);
        return r;
    }
    // Returns the ideal radius of the hub
    static CalculateIdealHubRadiusWithAdjacentEdges(bundlingSettings, node) {
        let r = bundlingSettings.MaxHubRadius;
        for (const adj of node.Neighbors)
            r = Math.min(r, node.Position.sub(adj.Position).length / 2);
        return r;
    }
    static GetMinRadiusForTwoAdjacentBundles(r, node, nodePosition, adj0, adj1, metroGraphData, bundlingSettings) {
        const w0 = metroGraphData.GetWidthSSN(node, adj0, bundlingSettings.EdgeSeparation);
        const w1 = metroGraphData.GetWidthSSN(node, adj1, bundlingSettings.EdgeSeparation);
        return HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(r, nodePosition, adj0.Position, adj1.Position, w0, w1, bundlingSettings);
    }
    // Radius we need to draw to separate adjacent bundles ab and ac
    static GetMinRadiusForTwoAdjacentBundlesNPPPNNB(r, a, b, c, widthAB, widthAC, bundlingSettings) {
        if (widthAB < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon || widthAC < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            return r;
        }
        let angle = ___WEBPACK_IMPORTED_MODULE_0__.Point.anglePCP(b, a, c);
        angle = Math.min(angle, Math.PI * 2 - angle);
        if (angle < _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            return 2 * bundlingSettings.MaxHubRadius;
        }
        if (angle >= Math.PI / 2) {
            return r * 1.05;
        }
        // find the intersection point of two bundles
        const sina = Math.sin(angle);
        const cosa = Math.cos(angle);
        const aa = widthAB / (4 * sina);
        const bb = widthAC / (4 * sina);
        let d = 2 * Math.sqrt(aa * aa + (bb * bb + 2 * (aa * (bb * cosa))));
        d = Math.min(d, 2 * bundlingSettings.MaxHubRadius);
        d = Math.max(d, r);
        return d;
    }
}
//# sourceMappingURL=HubRadiiCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/IntersectionCache.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IntersectionCache: () => (/* binding */ IntersectionCache)
/* harmony export */ });
/* harmony import */ var _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/hitTestBehavior.js");
/* harmony import */ var _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");
/* harmony import */ var _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/HubRadiiCalculator.js");



// Stores intersections between edges, hubs, and obstacles to speed up simulated annealing
class IntersectionCache {
    constructor(metroGraphData, bundlingSettings, costCalculator, cdt) {
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
        this.costCalculator = costCalculator;
        this.cdt = cdt;
    }
    InitializeCostCache() {
        for (const v of this.metroGraphData.VirtualStations()) {
            v.cachedIdealRadius = _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_2__.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, v);
            v.cachedRadiusCost = this.costCalculator.RadiusCost(v, v.Position);
            v.cachedBundleCost = 0;
        }
        for (const edge of this.metroGraphData.VirtualEdges()) {
            const v = edge[0];
            const u = edge[1];
            const edgeInfo = this.metroGraphData.GetIjInfo(v, u);
            edgeInfo.cachedBundleCost = this.costCalculator.BundleCost(v, u, v.Position);
            v.cachedBundleCost += edgeInfo.cachedBundleCost;
            u.cachedBundleCost += edgeInfo.cachedBundleCost;
        }
    }
    UpdateCostCache(node) {
        const cdtTree = this.cdt.getRectangleNodeOnTriangles();
        node.cdtTriangle = cdtTree.FirstHitNodeWithPredicate(node.Position, IntersectionCache.testPointInside).UserData;
        node.cachedIdealRadius = _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_2__.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, node);
        node.cachedRadiusCost = this.costCalculator.RadiusCost(node, node.Position);
        node.cachedBundleCost = 0;
        for (const adj of node.Neighbors) {
            if (!adj.IsReal) {
                adj.cachedIdealRadius = _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_2__.HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, adj);
                adj.cachedRadiusCost = this.costCalculator.RadiusCost(adj, adj.Position);
            }
            const edgeInfo = this.metroGraphData.GetIjInfo(node, adj);
            adj.cachedBundleCost -= edgeInfo.cachedBundleCost;
            edgeInfo.cachedBundleCost = this.costCalculator.BundleCost(node, adj, node.Position);
            node.cachedBundleCost += edgeInfo.cachedBundleCost;
            adj.cachedBundleCost += edgeInfo.cachedBundleCost;
        }
    }
    static testPointInside(pnt, t) {
        return _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_1__.Cdt.PointIsInsideOfTriangle(pnt, t) ? _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_0__.HitTestBehavior.Stop : _math_geometry_RTree_hitTestBehavior__WEBPACK_IMPORTED_MODULE_0__.HitTestBehavior.Continue;
    }
}
//# sourceMappingURL=IntersectionCache.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/Intersections.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Intersections: () => (/* binding */ Intersections)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
// Check intersections between hubs and obstacles with kd-tree



class Intersections {
    constructor(metroGraphData, bundlingSettings, obstacleTree, obstaclesToIgnore) {
        this.metroGraphData = metroGraphData;
        this.obstaclesToIgnoreLambda = obstaclesToIgnore;
        this.bundlingSettings = bundlingSettings;
        this.obstacleTree = obstacleTree;
    }
    ObstaclesToIgnoreForBundle(u, v) {
        if (u != null && v != null) {
            return (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_2__.uniteSets)(this.obstaclesToIgnoreLambda(u), this.obstaclesToIgnoreLambda(v));
        }
        if (u == null && v == null) {
            return new Set();
        }
        if (u != null) {
            return this.obstaclesToIgnoreLambda(u);
        }
        else {
            return this.obstaclesToIgnoreLambda(v);
        }
    }
    HubAvoidsObstaclesSPNBA(node, center, upperBound, t) {
        const md = { minimalDistance: upperBound };
        return Intersections.IntersectCircleWithTree(this.obstacleTree, center, upperBound, this.obstaclesToIgnoreLambda(node), t.touchedObstacles, md);
    }
    HubAvoidsObstaclesPNS__(center, upperBound, obstaclesToIgnore) {
        const t = { touchedObstacles: Array() };
        const md = { minimalDistance: 0 };
        return this.HubAvoidsObstaclesPNSTT(center, upperBound, obstaclesToIgnore, t, md);
    }
    GetMinimalDistanceToObstacles(node, nodePosition, upperBound) {
        const touchedObstacles = new Array();
        const t = { minimalDistance: upperBound };
        if (!Intersections.IntersectCircleWithTree(this.obstacleTree, nodePosition, upperBound, this.obstaclesToIgnoreLambda(node), touchedObstacles, t)) {
            return 0;
        }
        return t.minimalDistance;
    }
    HubAvoidsObstaclesPNSTT(center, upperBound, obstaclesToIgnore, t, m) {
        t.touchedObstacles = new Array();
        m.minimalDistance = upperBound;
        return Intersections.IntersectCircleWithTree(this.obstacleTree, center, upperBound, obstaclesToIgnore, t.touchedObstacles, m);
    }
    // Computes the intersection between the hub and obstacles
    // Returns false iff the center is inside of an obstacle, which is not ignored
    static IntersectCircleWithTree(node, center, radius, obstaclesToIgnore, touchedObstacles, t) {
        if (!node.irect.contains_point_radius(center, radius)) {
            return true;
        }
        if (node.UserData == null) {
            let res = Intersections.IntersectCircleWithTree(node.Left, center, radius, obstaclesToIgnore, touchedObstacles, t);
            if (!res) {
                return false;
            }
            res = Intersections.IntersectCircleWithTree(node.Right, center, radius, obstaclesToIgnore, touchedObstacles, t);
            if (!res) {
                return false;
            }
        }
        else {
            const obstacle = node.UserData;
            if (obstaclesToIgnore.has(obstacle)) {
                return true;
            }
            const pl = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.PointRelativeToCurveLocation(center, obstacle);
            if (pl !== _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Outside) {
                Intersections.containingPoly = obstacle;
                return false;
            }
            const touchPoint = obstacle.value(obstacle.closestParameter(center));
            const dist = touchPoint.sub(center).length;
            if (dist <= radius) {
                touchedObstacles.push([obstacle, touchPoint]);
            }
            t.minimalDistance = Math.min(dist, t.minimalDistance);
        }
        return true;
    }
    static Create4gon(apex, baseCenter, width1, width2) {
        let norm = baseCenter.sub(apex).normalize();
        norm = new ___WEBPACK_IMPORTED_MODULE_0__.Point(norm.y, norm.x * -1);
        return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Polyline.mkFromPoints([
            apex.add(norm.mul(width1 / 2)),
            apex.sub(norm.mul(width1 / 2)),
            baseCenter.sub(norm.mul(width2 / 2)),
            baseCenter.add(norm.mul(width2 / 2)),
        ]);
    }
}
//#if TEST_MSAGL && TEST_MSAGL
// check the validness of the drawing:
//    // 1. hubs are not inside loose obstacles
//    // 2. bundles do not cross loose obstacles
//    // <
//     bool HubPositionsAreOK() {
//        //check polylines
//        foreach(var line of metroGraphData.Metrolines) {
//            var poly = line.Polyline;
//            foreach(var p of poly.PolylinePoints)
//            Assert.assert(metroGraphData.PointToStations.ContainsKey(p.point));
//        }
//        foreach(var station of metroGraphData.Stations) {
//            if (!station.IsRealNode && !HubAvoidsObstacles(station.Position, 0, obstaclesToIgnore(station))) {
//                if (LayoutAlgorithmSettings.ShowDebugCurvesEnumeration != null) {
//                    HubDebugger.ShowHubs(metroGraphData, bundlingSettings, station);
//                    ShowStationWithObstaclesToIgnore(station, obstacleTree.AllHitItems(station.Position));
//                }
//                return false;
//            }
//            //bundles
//            foreach(var adj of station.Neighbors) {
//                if (Point.closeDistEps(adj.Position, station.Position))
//                    return false;
//                if (!EdgeIsLegal(station, adj, station.Position, adj.Position)) {
//                    if (LayoutAlgorithmSettings.ShowDebugCurvesEnumeration != null) {
//                        //debug visualization
//                        var l = new Array<DebugCurve>();
//                        //foreach (var st of metroGraphData.Stations) {
//                        //    l.Add(new DebugCurve(100, 0.5, "grey", st.BoundaryCurve));
//                        //}
//                        foreach(var poly of obstaclesToIgnore(station)) {
//                            l.Add(new DebugCurve(100, 5, "green", poly));
//                        }
//                        foreach(var obstacle of obstacleTree.GetAllLeaves()) {
//                            l.Add(new DebugCurve(100, 1, "red", obstacle));
//                        }
//                        l.Add(new DebugCurve(1, "blue", station.BoundaryCurve));
//                        l.Add(new DebugCurve(1, "blue", adj.BoundaryCurve));
//                        l.Add(new DebugCurve(1, "blue", new LineSegment(adj.Position, adj.Neighbors.First().Position)));
//                        l.Add(new DebugCurve(1, "blue", new LineSegment(station.Position, adj.Position)));
//                        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
//                        //end debug visualization
//                        return false;
//                    }
//                }
//            }
//        }
//        return true;
//    }
//    void ShowStationWithObstaclesToIgnore(Station station, Array < Polyline > allHitItems) {
//        var l = new Array<DebugCurve>();
//        foreach(var poly of allHitItems) {
//            l.Add(new DebugCurve(100, 0.5, "brown", poly));
//        }
//        if (obstaclesToIgnore(station) != null)
//            foreach(var poly of obstaclesToIgnore(station))
//        l.Add(new DebugCurve(100, 1, "red", poly));
//        foreach(var obstacle of obstacleTree.GetAllLeaves())
//        l.Add(new DebugCurve(50, 0.1, "green", obstacle));
//        l.Add(new DebugCurve(0.1, "blue", new Ellipse(1, 1, station.Position)));
//        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
//    }
//    // edge doesn't cross obstacles
//    // NOTE: use method in CdtIntersection insetad!
//    // <
//    bool EdgeIsLegal(Station stationA, Station stationB, Point a, Point b) {
//        var crossings = InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(new LineSegment(a, b), obstacleTree);
//        Set < Polyline > obstaclesToIgnoreForBundle = ObstaclesToIgnoreForBundle(stationA, stationB);
//        if (crossings.Count < 0) {
//            var l = new Array<DebugCurve>();
//            var crossingSet = new Set<ICurve>(crossings.Select(ii => ii.Segment1));
//            l.AddRange(crossingSet.Select(p => new DebugCurve(100, 1, "red", p)));
//            l.AddRange(obstaclesToIgnoreForBundle.Select(p => new DebugCurve(100, 0.5, "green", p)));
//            LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
//        }
//        return crossings.All(intersectionInfo => obstaclesToIgnoreForBundle.Contains((Polyline)intersectionInfo.Segment1));
//    }
// #endif
// }
//# sourceMappingURL=Intersections.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/MetroGraphData.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GreaterOrEqual: () => (/* binding */ GreaterOrEqual),
/* harmony export */   MetroGraphData: () => (/* binding */ MetroGraphData),
/* harmony export */   getOrientationOf3Vectors: () => (/* binding */ getOrientationOf3Vectors)
/* harmony export */ });
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
/* harmony import */ var _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");
/* harmony import */ var _CdtIntersections__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/CdtIntersections.js");
/* harmony import */ var _Intersections__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/Intersections.js");
/* harmony import */ var _MetroLine__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/MetroLine.js");
/* harmony import */ var _MetroNodeInfo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/MetroNodeInfo.js");
/* harmony import */ var _Station__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/Station.js");
/* harmony import */ var _StationEdgeInfo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/StationEdgeInfo.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _IntersectionCache__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/IntersectionCache.js");
/* harmony import */ var _tupleMap__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/tupleMap.js");
// Wrapper for geometry graph with coinciding edges:
//  'real' nodes stand for edge ends (source,target)
//  'virtual' nodes stand for polyline control points
//
//  'real' edges are original graph edges
















//  'virtual' edges are polyline segments
class MetroGraphData {
    constructor(regularEdges, looseTree, tightTree, bundlingSettings, cdt, edgeLooseEnterable, edgeTightEnterable, loosePolylineOfPort) {
        this.cachedEnterableLooseForEnd = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_3__.PointMap();
        this.bundlingSettings = bundlingSettings;
        // Assert.assert(cdt != null);
        this.regularEdges = regularEdges;
        if (cdt != null) {
            this.cdt = cdt;
        }
        else {
            this.cdt = (0,_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_5__.createCDTOnPolylineRectNode)(looseTree);
        }
        this.EdgeLooseEnterable = edgeLooseEnterable;
        this.EdgeTightEnterable = edgeTightEnterable;
        this.LoosePolylineOfPort = loosePolylineOfPort;
        this.looseIntersections = new _Intersections__WEBPACK_IMPORTED_MODULE_7__.Intersections(this, bundlingSettings, looseTree, (station) => station.getELP());
        this.tightIntersections = new _Intersections__WEBPACK_IMPORTED_MODULE_7__.Intersections(this, bundlingSettings, tightTree, (station) => station.EnterableTightPolylines);
        this.cdtIntersections = new _CdtIntersections__WEBPACK_IMPORTED_MODULE_6__.CdtIntersections(this, bundlingSettings);
        this.Initialize(false);
    }
    get Ink() {
        return this.ink;
    }
    get Edges() {
        return this.regularEdges;
    }
    VirtualStations() {
        return Array.from(this.Stations).filter((s) => !s.IsReal);
    }
    get Metrolines() {
        return this.metrolines;
    }
    get LooseTree() {
        return this.looseIntersections.obstacleTree;
    }
    get TightTree() {
        return this.tightIntersections.obstacleTree;
    }
    *VirtualEdges() {
        for (const k of this.edgeInfoDictionary.keys())
            yield k;
    }
    // number of real edges passing the edge uv
    RealEdgeCount(u, v) {
        const couple = u.SerialNumber < v.SerialNumber ? [u, v] : [v, u];
        const cw = this.edgeInfoDictionary.get(couple[0], couple[1]);
        if (cw)
            return cw.Count;
        return 0;
    }
    // real edges passing the node
    MetroNodeInfosOfNode(node) {
        return node.MetroNodeInfos;
    }
    // real edges passing the edge uv
    GetIjInfo(u, v) {
        const couple = u.SerialNumber < v.SerialNumber ? [u, v] : [v, u];
        return this.edgeInfoDictionary.get(couple[0], couple[1]);
    }
    // Move node to the specified position
    MoveNode(node, newPosition) {
        const oldPosition = node.Position;
        this.PointToStations.deleteP(oldPosition);
        this.PointToStations.set(newPosition, node);
        node.Position = newPosition;
        //move curves
        for (const metroNodeInfo of this.MetroNodeInfosOfNode(node))
            metroNodeInfo.PolyPoint.point = newPosition;
        // update lengths
        for (const e of this.MetroNodeInfosOfNode(node)) {
            const metroLine = e.Metroline;
            const prev = e.PolyPoint.prev.point;
            const succ = e.PolyPoint.next.point;
            metroLine.Length +=
                succ.sub(newPosition).length + prev.sub(newPosition).length - succ.sub(oldPosition).length - prev.sub(oldPosition).length;
        }
        // update ink
        for (const adj of node.Neighbors)
            this.ink += newPosition.sub(adj.Position).length - oldPosition.sub(adj.Position).length;
        // update neighbors order
        this.SortNeighbors(node);
        for (const adj of node.Neighbors)
            this.SortNeighbors(adj);
    }
    GetWidthSSN(u, v, edgeSeparation) {
        const couple = u.SerialNumber < v.SerialNumber ? [u, v] : [v, u];
        const cw = this.edgeInfoDictionary.get(couple[0], couple[1]);
        return cw ? cw.Width + (cw.Count - 1) * edgeSeparation : 0;
    }
    GetWidthAN(metrolines, edgeSeparation) {
        let width = 0;
        for (const metroline of metrolines) {
            width += metroline.Width;
        }
        const count = metrolines.length;
        width += count > 0 ? (count - 1) * edgeSeparation : 0;
        //Debug.Assert(GeomConstants.GreaterOrEqual(width, 0));
        return width;
    }
    // Initialize data
    Initialize(initTightTree) {
        // TimeMeasurer.DebugOutput("bundle graph data initializing...");
        this.SimplifyRegularEdges();
        this.InitializeStationData();
        this.InitializeEdgeData();
        this.InitializeVirtualGraph();
        this.InitializeEdgeNodeInfo(initTightTree);
        this.InitializeCdtInfo();
        //            Assert.assert(looseIntersections.HubPositionsAreOK());
        //          Assert.assert(tightIntersections.HubPositionsAreOK());
    }
    // remove self-cycles
    SimplifyRegularEdges() {
        for (const edge of this.regularEdges) {
            this.SimplifyRegularEdge(edge);
        }
    }
    // change the polyline by removing cycles
    SimplifyRegularEdge(edge) {
        const polyline = edge.curve;
        const stack = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        const seen = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_4__.PointSet();
        for (let p = polyline.endPoint; p != null; p = p.prev) {
            const v = p.point;
            if (seen.has(p.point)) {
                let pp = p.next;
                do {
                    const u = stack.top;
                    if (!u.equal(v)) {
                        seen.delete(u);
                        stack.pop();
                        pp = pp.next;
                    }
                    else
                        break;
                } while (true);
                pp.prev = p.prev;
                pp.prev.next = pp;
            }
            else {
                stack.push(v);
                seen.add(v);
            }
        }
    }
    InitializeStationData() {
        this.Stations = [];
        //create indexes
        this.PointToStations = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_3__.PointMap();
        for (const edge of this.regularEdges) {
            const poly = edge.curve;
            this.ProcessPolylinePoints(poly);
        }
    }
    ProcessPolylinePoints(poly) {
        let p = poly.startPoint;
        this.RegisterStation(p, true);
        for (p = p.next; p !== poly.endPoint; p = p.next) {
            this.RegisterStation(p, false);
        }
        this.RegisterStation(p, true);
    }
    RegisterStation(pp, isRealNode) {
        if (!this.PointToStations.has(pp.point)) {
            const station = new _Station__WEBPACK_IMPORTED_MODULE_10__.Station(this.Stations.length, isRealNode, pp.point);
            this.PointToStations.set(pp.point, station);
            this.Stations.push(station);
        }
        else {
            //  #if(TEST_MSAGL && TEST_MSAGL)
            //  const s = this.PointToStations[pp.point]
            //  Assert.assert(s.IsRealNode === isRealNode)
            //  #endif
        }
    }
    InitializeEdgeData() {
        this.metrolines = new Array();
        for (let i = 0; i < this.regularEdges.length; i++) {
            const geomEdge = this.regularEdges[i];
            this.InitEdgeData(geomEdge, i);
        }
    }
    InitEdgeData(geomEdge, index) {
        const metroEdge = new _MetroLine__WEBPACK_IMPORTED_MODULE_8__.Metroline(geomEdge.curve, this.bundlingSettings.ActualEdgeWidth(geomEdge), this.EdgeSourceAndTargetFunc(geomEdge), index);
        this.metrolines.push(metroEdge);
        this.PointToStations.get(metroEdge.Polyline.start).BoundaryCurve = geomEdge.sourcePort.Curve;
        this.PointToStations.get(metroEdge.Polyline.end).BoundaryCurve = geomEdge.targetPort.Curve;
    }
    EdgeSourceAndTargetFunc(geomEdge) {
        return () => [this.LoosePolylineOfPort(geomEdge.sourcePort), this.LoosePolylineOfPort(geomEdge.targetPort)];
    }
    /**   Initialize graph comprised of stations and their neighbors */
    InitializeVirtualGraph() {
        const neighbors = new Map();
        for (const metroline of this.metrolines) {
            let u = this.PointToStations.get(metroline.Polyline.start);
            let v;
            for (let p = metroline.Polyline.startPoint; p.next != null; p = p.next, u = v) {
                v = this.PointToStations.get(p.next.point);
                (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_12__.addToMapOfSets)(neighbors, u, v);
                (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_12__.addToMapOfSets)(neighbors, v, u);
            }
        }
        for (const s of this.Stations) {
            s.Neighbors = Array.from(neighbors.get(s));
        }
    }
    GetUnorderedIjInfo(i, j) {
        return i.SerialNumber < j.SerialNumber ? this.GetCreateOrderedIjInfo(i, j) : this.GetCreateOrderedIjInfo(j, i);
    }
    static closedeb(u, v) {
        return u.Position.sub(new ___WEBPACK_IMPORTED_MODULE_1__.Point(360.561, 428.416)).length < 0.1 && v.Position.sub(new ___WEBPACK_IMPORTED_MODULE_1__.Point(414.281, 440.732)).length < 0.1;
    }
    GetCreateOrderedIjInfo(i, j) {
        //Assert.assert(i.SerialNumber < j.SerialNumber)
        let cw = this.edgeInfoDictionary.get(i, j);
        if (cw) {
            return cw;
        }
        // if (MetroGraphData.closedeb(i, j) || MetroGraphData.closedeb(j, i)) {
        //  console.log(this)
        // }
        cw = new _StationEdgeInfo__WEBPACK_IMPORTED_MODULE_11__.StationEdgeInfo();
        this.edgeInfoDictionary.set(i, j, cw);
        return cw;
    }
    InitializeEdgeNodeInfo(initTightTree) {
        this.edgeInfoDictionary = new _tupleMap__WEBPACK_IMPORTED_MODULE_15__.TupleMap();
        this.InitAllMetroNodeInfos(initTightTree);
        this.SortAllNeighbors();
        this.InitEdgeIjInfos();
        this.ink = 0;
        for (const edge of this.VirtualEdges()) {
            this.ink += edge[0].Position.sub(edge[1].Position).length;
        }
    }
    InitAllMetroNodeInfos(initTightTree) {
        for (let i = 0; i < this.metrolines.length; i++) {
            const metroline = this.metrolines[i];
            this.InitMetroNodeInfos(metroline);
            this.InitNodeEnterableLoosePolylines(metroline, this.regularEdges[i]);
            if (initTightTree) {
                this.InitNodeEnterableTightPolylines(metroline, this.regularEdges[i]);
            }
            metroline.UpdateLengths();
        }
    }
    InitMetroNodeInfos(metroline) {
        for (let pp = metroline.Polyline.startPoint; pp != null; pp = pp.next) {
            const station = this.PointToStations.get(pp.point);
            station.MetroNodeInfos.push(new _MetroNodeInfo__WEBPACK_IMPORTED_MODULE_9__.MetroNodeInfo(metroline, station, pp));
        }
    }
    InitNodeEnterableLoosePolylines(metroline, regularEdge) {
        //If we have groups, EdgeLooseEnterable are precomputed.
        const metrolineEnterable = this.EdgeLooseEnterable != null ? this.EdgeLooseEnterable.get(regularEdge) : new Set();
        for (let p = metroline.Polyline.startPoint.next; p != null && p.next != null; p = p.next) {
            const v = this.PointToStations.get(p.point);
            if (v.getELP() != null)
                v.setELP((0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_12__.setIntersection)(v.getELP(), metrolineEnterable));
            else
                v.setELP(new Set(metrolineEnterable));
        }
        this.AddLooseEnterableForMetrolineStartEndPoints(metroline);
    }
    AddLooseEnterableForMetrolineStartEndPoints(metroline) {
        this.AddLooseEnterableForEnd(metroline.Polyline.start);
        this.AddLooseEnterableForEnd(metroline.Polyline.end);
    }
    AddTightEnterableForMetrolineStartEndPoints(metroline) {
        this.AddTightEnterableForEnd(metroline.Polyline.start);
        this.AddTightEnterableForEnd(metroline.Polyline.end);
    }
    AddLooseEnterableForEnd(point) {
        const station = this.PointToStations.get(point);
        if (!this.cachedEnterableLooseForEnd.has(point)) {
            for (const poly of this.LooseTree.AllHitItems_(point))
                if (_math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve.PointRelativeToCurveLocation(point, poly) === _math_geometry__WEBPACK_IMPORTED_MODULE_2__.PointLocation.Inside)
                    station.AddEnterableLoosePolyline(poly);
            this.cachedEnterableLooseForEnd.set(point, station.getELP());
        }
        else {
            station.setELP(this.cachedEnterableLooseForEnd.get(point));
        }
    }
    AddTightEnterableForEnd(point) {
        const station = this.PointToStations.get(point);
        for (const poly of this.TightTree.AllHitItems_(point))
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve.PointRelativeToCurveLocation(point, poly) === _math_geometry__WEBPACK_IMPORTED_MODULE_2__.PointLocation.Inside) {
                station.AddEnterableTightPolyline(poly);
            }
    }
    InitNodeEnterableTightPolylines(metroline, regularEdge) {
        //If we have groups, EdgeTightEnterable are precomputed.
        const metrolineEnterable = this.EdgeTightEnterable != null ? this.EdgeTightEnterable.get(regularEdge) : new Set();
        for (let p = metroline.Polyline.startPoint.next; p != null && p.next != null; p = p.next) {
            const v = this.PointToStations.get(p.point);
            const nodeEnterable = v.EnterableTightPolylines;
            if (nodeEnterable != null)
                v.EnterableTightPolylines = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_12__.setIntersection)(nodeEnterable, metrolineEnterable);
            else
                v.EnterableTightPolylines = new Set(metrolineEnterable);
        }
        this.AddTightEnterableForMetrolineStartEndPoints(metroline);
    }
    SortAllNeighbors() {
        // counter-clockwise sorting
        for (const station of this.Stations)
            this.SortNeighbors(station);
    }
    SortNeighbors(station) {
        // nothing to sort
        if (station.Neighbors.length <= 2) {
            return;
        }
        const pivot = station.Neighbors[0].Position;
        const center = station.Position;
        station.Neighbors.sort((u, v) => getOrientationOf3Vectors(pivot.sub(center), u.Position.sub(center), v.Position.sub(center)));
    }
    InitEdgeIjInfos() {
        for (const metroLine of this.metrolines) {
            const poly = metroLine.Polyline;
            let u = this.PointToStations.get(poly.start);
            let v;
            for (let p = metroLine.Polyline.startPoint; p.next != null; p = p.next, u = v) {
                v = this.PointToStations.get(p.next.point);
                const info = this.GetUnorderedIjInfo(u, v);
                info.Width += metroLine.Width;
                info.Metrolines.push(metroLine);
            }
        }
    }
    InitializeCdtInfo() {
        const cdtTree = this.cdt.getRectangleNodeOnTriangles();
        for (const station of this.Stations) {
            station.cdtTriangle = cdtTree.FirstHitNodeWithPredicate(station.Position, _IntersectionCache__WEBPACK_IMPORTED_MODULE_14__.IntersectionCache.testPointInside).UserData;
            //Debug.Assert(station.CdtTriangle != null);
        }
    }
    PointIsAcceptableForEdge(metroline, point) {
        if (this.LoosePolylineOfPort == null) {
            return true;
        }
        const polys = metroline.sourceAndTargetLoosePolylines();
        return (_math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve.PointRelativeToCurveLocation(point, polys[0]) === _math_geometry__WEBPACK_IMPORTED_MODULE_2__.PointLocation.Outside &&
            _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Curve.PointRelativeToCurveLocation(point, polys[1]) === _math_geometry__WEBPACK_IMPORTED_MODULE_2__.PointLocation.Outside);
    }
}
/**  computes orientation of three vectors with a common source
     (compare the polar angles of v1 and v2 with respect to v0)
      return -1 if the orientation is v0 v1 v2
               1 if the orientation is v0 v2 v1
               0  if v1 and v2 are collinear and codirectinal */
function getOrientationOf3Vectors(v0, v1, v2) {
    const xp2 = ___WEBPACK_IMPORTED_MODULE_1__.Point.crossProduct(v0, v2);
    const dotp2 = v0.dot(v2);
    const xp1 = ___WEBPACK_IMPORTED_MODULE_1__.Point.crossProduct(v0, v1);
    const dotp1 = v0.dot(v1);
    // v1 is collinear with v0
    if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_13__.closeDistEps)(xp1, 0) && GreaterOrEqual(dotp1, 0)) {
        if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_13__.closeDistEps)(xp2, 0) && GreaterOrEqual(dotp2, 0)) {
            return 0;
        }
        return 1;
    }
    // v2 is collinear with v0
    if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_13__.closeDistEps)(xp2, 0) && GreaterOrEqual(dotp2, 0)) {
        return -1;
    }
    if ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_13__.closeDistEps)(xp1, 0) || (0,_utils_compare__WEBPACK_IMPORTED_MODULE_13__.closeDistEps)(xp2, 0) || xp1 * xp2 > 0) {
        // both on same side of v0, compare to each other
        return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_13__.compareNumbersDistEps)(___WEBPACK_IMPORTED_MODULE_1__.Point.crossProduct(v2, v1), 0);
    }
    // vectors "less than" zero degrees are actually large, near 2 pi
    return -(0,_utils_compare__WEBPACK_IMPORTED_MODULE_13__.compareNumbersDistEps)(Math.sign(xp1), 0);
}
function GreaterOrEqual(numberA, numberB) {
    return (0,_utils_compare__WEBPACK_IMPORTED_MODULE_13__.compareNumbersDistEps)(numberA, numberB) >= 0;
}
//# sourceMappingURL=MetroGraphData.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/MetroLine.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Metroline: () => (/* binding */ Metroline)
/* harmony export */ });
// holds the data of a path
class Metroline {
    constructor(polyline, width, sourceAndTargetLoosePolys, index) {
        this.Width = width;
        this.Polyline = polyline;
        this.sourceAndTargetLoosePolylines = sourceAndTargetLoosePolys;
        this.Index = index;
    }
    UpdateLengths() {
        let l = 0;
        for (let p = this.Polyline.startPoint; p.next != null; p = p.next) {
            l += p.next.point.sub(p.point).length;
        }
        this.Length = l;
        this.IdealLength = this.Polyline.end.sub(this.Polyline.start).length;
    }
}
//# sourceMappingURL=MetroLine.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/MetroNodeInfo.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MetroNodeInfo: () => (/* binding */ MetroNodeInfo)
/* harmony export */ });
class MetroNodeInfo {
    constructor(metroline, station, polyPoint) {
        this.metroline = metroline;
        this.station = station;
        this.polyPoint = polyPoint;
    }
    get Metroline() {
        return this.metroline;
    }
    get PolyPoint() {
        return this.polyPoint;
    }
}
//# sourceMappingURL=MetroNodeInfo.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/OrientedHubSegment.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrientedHubSegment: () => (/* binding */ OrientedHubSegment)
/* harmony export */ });
class OrientedHubSegment {
    get Segment() {
        return this.segment;
    }
    set Segment(value) {
        this.segment = value;
    }
    constructor(seg, reversed, index, bundleBase) {
        this.Segment = seg;
        this.Reversed = reversed;
        this.Index = index;
        this.BundleBase = bundleBase;
    }
    value(t) {
        return this.Reversed ? this.Segment.value(this.Segment.parEnd - t) : this.Segment.value(t);
    }
}
//# sourceMappingURL=OrientedHubSegment.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/PathFixer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PathFixer: () => (/* binding */ PathFixer)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/pointPair.js");
/* harmony import */ var _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rTree.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
/* harmony import */ var _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/pointPairMap.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _FlipSwitcher__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/FlipSwitcher.js");














class PathFixer {
    constructor(metroGraphData, polylineAcceptsPoint) {
        this.foundCrossings = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_11__.PointSet();
        this.crossingsThatShouldBecomeHubs = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_11__.PointSet();
        this.metroGraphData = metroGraphData;
        this.polylineAcceptsPoint = polylineAcceptsPoint;
    }
    *Vertices() {
        for (const poly of this.Polylines) {
            for (const p of poly.polylinePoints()) {
                yield p;
            }
        }
    }
    get Polylines() {
        return this.metroGraphData.Edges.map((e) => e.curve);
    }
    Edges() {
        const map = new _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_10__.PointPairMap(); // we need the keys only
        for (const pp of this.Vertices()) {
            if (pp.next)
                map.set(new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_3__.PointPair(pp.point, pp.next.point), 0);
        }
        return Array.from(map.keys());
    }
    run() {
        if (this.metroGraphData.Edges.length === 0) {
            return false;
        }
        const splittingPoints = new _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_10__.PointPairMap();
        const treeOfVertices = new _math_geometry_RTree_rTree__WEBPACK_IMPORTED_MODULE_7__.BinaryRTree(null);
        for (const vertex of this.Vertices()) {
            const r = ___WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkOnPoints([vertex.point]);
            r.pad(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon);
            treeOfVertices.Add(r, vertex.point);
        }
        const treeOfEdges = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_5__.createRectangleNodeOnData)(this.Edges(), (e) => ___WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkPP(e.first, e.second));
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_6__.CrossRectangleNodesSameType)(treeOfEdges, treeOfEdges, (a, b) => this.IntersectTwoEdges.bind(a, b, splittingPoints, treeOfVertices));
        this.SortInsertedPoints(splittingPoints);
        const pointsInserted = this.InsertPointsIntoPolylines(splittingPoints);
        const progress = this.FixPaths();
        const pointsRemoved = this.RemoveUnimportantCrossings();
        return progress || pointsInserted || pointsRemoved;
    }
    FixPaths() {
        let progress = false;
        if (this.RemoveSelfCycles()) {
            progress = true;
        }
        // if (CollapseCycles()) progress = true;
        if (this.ReduceEdgeCrossings()) {
            progress = true;
        }
        return progress;
    }
    SortInsertedPoints(splittingPoints) {
        for (const pair of splittingPoints)
            this.SortInsideSegment(pair[0], pair[1]);
    }
    SortInsideSegment(edge, list) {
        //System.Diagnostics.Debug.Assert(list.Count > 0, "an edge should not be present with an empty list");
        list.sort((a, b) => (0,_utils_compare__WEBPACK_IMPORTED_MODULE_8__.compareNumbers)((0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.distPP)(a, edge.first), (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.distPP)(b, edge.first)));
    }
    InsertPointsIntoPolylines(splittingPoints) {
        let inserted = false;
        for (const metroline of this.metroGraphData.Metrolines) {
            if (this.InsertPointsIntoPolyline(metroline, splittingPoints)) {
                inserted = true;
            }
            return inserted;
        }
    }
    InsertPointsIntoPolyline(metroline, splittingPoints) {
        let inserted = false;
        for (let pp = metroline.Polyline.startPoint; pp.next != null; pp = pp.next) {
            if (this.InsertPointsOnPolypoint(pp, splittingPoints, metroline)) {
                inserted = true;
            }
        }
        return inserted;
    }
    InsertPointsOnPolypoint(pp, splittingPoints, metroline) {
        const pointPair = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_3__.PointPair(pp.point, pp.next.point);
        const reversed = pp.point !== pointPair.first;
        const list = splittingPoints.get(pointPair);
        if (!list) {
            return false;
        }
        const endPolyPoint = pp.next;
        const poly = pp.polyline;
        if (reversed)
            for (let i = list.length - 1; i >= 0; i--) {
                if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(metroline, list[i]))
                    continue;
                const p = _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_4__.PolylinePoint.mkFromPoint(list[i]);
                p.prev = pp;
                p.polyline = poly;
                pp.next = p;
                pp = p;
            }
        else
            for (let i = 0; i < list.length; i++) {
                if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(metroline, list[i]))
                    continue;
                const p = _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_4__.PolylinePoint.mkFromPoint(list[i]);
                p.prev = pp;
                p.polyline = poly;
                pp.next = p;
                pp = p;
            }
        pp.next = endPolyPoint;
        endPolyPoint.prev = pp;
        return true;
    }
    RemoveSelfCycles() {
        let progress = false;
        for (const poly of this.Polylines)
            if (PathFixer.RemoveSelfCyclesFromPolyline(poly)) {
                progress = true;
            }
        return progress;
    }
    // returns removed points
    static RemoveSelfCyclesFromPolyline(poly) {
        let progress = false;
        const pointsToPp = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_9__.PointMap();
        for (let pp = poly.startPoint; pp != null; pp = pp.next) {
            const point = pp.point;
            const previous = pointsToPp.get(point);
            if (previous) {
                // we have a cycle
                for (let px = previous.next; px !== pp.next; px = px.next) {
                    pointsToPp.deleteP(px.point);
                }
                previous.next = pp.next;
                pp.next.prev = previous;
                progress = true;
            }
            else {
                pointsToPp.set(pp.point, pp);
            }
        }
        return progress;
    }
    // bool CollapseCycles() {
    //    var cycleCollapser = new FlipCollapser(metroGraphData, bundlingSettings, cdt);
    //    cycleCollapser.Run();
    //    crossingsThatShouldBecomeHubs.InsertRange(cycleCollapser.GetChangedCrossing());
    //    //TimeMeasurer.DebugOutput("#crossingsThatShouldBecomeHubs = " + crossingsThatShouldBecomeHubs.Count);
    //    return false;
    // }
    ReduceEdgeCrossings() {
        const cycleCollapser = new _FlipSwitcher__WEBPACK_IMPORTED_MODULE_13__.FlipSwitcher(this.metroGraphData);
        cycleCollapser.Run();
        for (const t of cycleCollapser.GetChangedHubs())
            this.crossingsThatShouldBecomeHubs.add(t);
        // TimeMeasurer.DebugOutput("#reduced crossings = " + cycleCollapser.NumberOfReducedCrossings());
        return cycleCollapser.NumberOfReducedCrossings() > 0;
    }
    RemoveUnimportantCrossings() {
        let removed = false;
        this.pointsToDelete = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_12__.substractPointSets)(this.foundCrossings, this.crossingsThatShouldBecomeHubs);
        for (const polyline of this.Polylines) {
            if (this.RemoveUnimportantCrossingsFromPolyline(polyline)) {
                removed = true;
            }
        }
        return removed;
    }
    RemoveUnimportantCrossingsFromPolyline(polyline) {
        let removed = false;
        for (let p = polyline.startPoint.next; p != null && p.next != null; p = p.next) {
            if (this.pointsToDelete.has(p.point) &&
                ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(p.prev.point, p.point, p.next.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Collinear) {
                // forget p
                const pp = p.prev;
                const pn = p.next;
                pp.next = pn;
                pn.prev = pp;
                p = pp;
                removed = true;
            }
        }
        return removed;
    }
    IntersectTwoEdges(a, b, splittingPoints, tree) {
        const x = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.IntersectPPPP(a.first, a.second, b.first, b.second);
        if (x) {
            const vertex = this.FindExistingVertexOrCreateNew(tree, x);
            if (this.AddVertexToSplittingList(a, splittingPoints, vertex) || this.AddVertexToSplittingList(b, splittingPoints, vertex)) {
                this.foundCrossings.add(vertex);
            }
        }
    }
    FindExistingVertexOrCreateNew(tree, x) {
        const p = tree.RootNode.FirstHitNode(x);
        if (p != null) {
            return p.UserData;
        }
        const rect = ___WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkOnPoints([x]);
        rect.pad(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.intersectionEpsilon);
        tree.Add(rect, x);
        return x;
    }
    AddVertexToSplittingList(a, splittingPoints, intersectionPoint) {
        //let t: number
        //Assert.assert(Point.distToLineSegment(intersectionPoint, a.First, a.Second, /* out */ t) < ApproximateComparer.IntersectionEpsilon)
        if (!_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.closeIntersectionPoints(intersectionPoint, a.first) && !_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.closeIntersectionPoints(intersectionPoint, a.second)) {
            let list = splittingPoints.get(a);
            if (!list) {
                list = new Array();
                splittingPoints.set(a, list);
            }
            if (!list.find((p) => p.equal(intersectionPoint))) {
                list.push(intersectionPoint);
                return true;
            }
        }
        return false;
    }
}
//# sourceMappingURL=PathFixer.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/PointPairOrder.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointPairOrder: () => (/* binding */ PointPairOrder)
/* harmony export */ });
class PointPairOrder {
    constructor() {
        // array of metrolines for node u of edge u->v
        this.Metrolines = new Array();
    }
    Add(metroline) {
        this.Metrolines.push(metroline);
    }
}
//# sourceMappingURL=PointPairOrder.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/SdBoneEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SdBoneEdge: () => (/* binding */ SdBoneEdge)
/* harmony export */ });
//    [DebuggerDisplay("({SourcePoint.x},{SourcePoint.y})->({TargetPoint.x},{TargetPoint.y})")]
class SdBoneEdge {
    constructor(visibilityEdge, source, target) {
        this.numberOfPassedPaths = 0;
        this.VisibilityEdge = visibilityEdge;
        this.Source = source;
        this.Target = target;
    }
    get TargetPoint() {
        return this.Target.Point;
    }
    get SourcePoint() {
        return this.Source.Point;
    }
    get IsOccupied() {
        return this.numberOfPassedPaths > 0;
    }
    get IsPassable() {
        return (this.Target.IsTargetOfRouting ||
            this.Source.IsSourceOfRouting ||
            this.VisibilityEdge.IsPassable == null ||
            this.VisibilityEdge.IsPassable());
    }
    AddOccupiedEdge() {
        this.numberOfPassedPaths++;
    }
    RemoveOccupiedEdge() {
        this.numberOfPassedPaths--;
        /*Assert.assert(this.numberOfPassedPaths >= 0)*/
    }
}
//# sourceMappingURL=SdBoneEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/SdShortestPath.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SdShortestPath: () => (/* binding */ SdShortestPath)
/* harmony export */ });
/* harmony import */ var _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/layout/core/hookUpAnywhereFromInsidePort.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/rectangle.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ClusterBoundaryPort.js");
/* harmony import */ var _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");
/* harmony import */ var _visibility_Polygon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/Polygon.js");
/* harmony import */ var _CdtThreader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/CdtThreader.js");
/* harmony import */ var _SdBoneEdge__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/SdBoneEdge.js");
/* harmony import */ var _SdVertex__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/SdVertex.js");













class SdShortestPath {
    constructor(makeTransparentShapesOfEdgeGeometryAndGetTheShapes, cdt, gates) {
        this.EdgesToRoutes = new Map();
        this.EdgesToRouteSources = new Map();
        this.MakeTransparentShapesOfEdgeGeometry = makeTransparentShapesOfEdgeGeometryAndGetTheShapes;
        this.cdt = cdt;
        this.Gates = gates;
    }
    CreateGraphElements() {
        for (const sdVertex of this.vertexArray) {
            const vv = sdVertex.VisibilityVertex;
            for (const vEdge of vv.InEdges) {
                const boneEdge = new _SdBoneEdge__WEBPACK_IMPORTED_MODULE_11__.SdBoneEdge(vEdge, this.VisibilityVerticesToSdVerts.get(vEdge.Source), this.VisibilityVerticesToSdVerts.get(vEdge.Target));
                const otherSdVertex = this.VisibilityVerticesToSdVerts.get(vEdge.Source);
                sdVertex.InBoneEdges.push(boneEdge);
                otherSdVertex.OutBoneEdges.push(boneEdge);
            }
        }
    }
    CreateRoutingGraph() {
        this.vertexArray = [];
        this.VisibilityVerticesToSdVerts = new Map();
        for (const v of this.VisibilityGraph.Vertices()) {
            const sdVert = new _SdVertex__WEBPACK_IMPORTED_MODULE_12__.SdVertex(v);
            this.vertexArray.push(sdVert);
            this.VisibilityVerticesToSdVerts.set(v, sdVert);
        }
        this.CreateGraphElements();
    }
    // routing of the edges minimizing (ink+path length+capacity penalty)
    RouteEdges() {
        this.Initialize();
        this.RestoreCapacities();
        for (const geomEdge of this.geomEdges) {
            this.EdgesToRoutes.set(geomEdge, this.RouteEdge(geomEdge));
        }
        this.RerouteEdges();
        for (const geomEdge of this.geomEdges)
            this.SetEdgeGeometryCurve(geomEdge);
    }
    SetEdgeGeometryCurve(geomEdge) {
        const poly = new _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_1__.Polyline();
        let curV = this.EdgesToRouteSources.get(geomEdge);
        poly.addPoint(curV.Point);
        for (const edge of this.EdgesToRoutes.get(geomEdge)) {
            if (edge.SourcePoint.equal(curV.Point)) {
                poly.addPoint(edge.TargetPoint);
                curV = edge.Target;
            }
            else {
                poly.addPoint(edge.SourcePoint);
                curV = edge.Source;
            }
        }
        geomEdge.curve = poly;
        const isClusterSourcePort = geomEdge.sourcePort instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_7__.ClusterBoundaryPort;
        if (isClusterSourcePort)
            SdShortestPath.ExtendPolylineStartToClusterBoundary(poly, geomEdge.sourcePort.Curve);
        const isClusterTargetPort = geomEdge.targetPort instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_7__.ClusterBoundaryPort;
        if (isClusterTargetPort)
            SdShortestPath.ExtendPolylineEndToClusterBoundary(poly, geomEdge.targetPort.Curve);
    }
    static ExtendPolylineEndToClusterBoundary(poly, curve) {
        const par = curve.closestParameter(poly.end);
        poly.addPoint(curve.value(par));
    }
    static ExtendPolylineStartToClusterBoundary(poly, curve) {
        const par = curve.closestParameter(poly.start);
        poly.PrependPoint(curve.value(par));
    }
    RerouteEdges() {
        this.RestoreCapacities();
        for (const geomEdge of this.geomEdges) {
            const newRoute = this.RerouteEdge(geomEdge);
            this.EdgesToRoutes.set(geomEdge, newRoute);
        }
    }
    RestoreCapacities() {
        if (this.cdt != null) {
            this.cdt.RestoreEdgeCapacities();
        }
    }
    // Reroute edge
    RerouteEdge(geomEdge) {
        const route = this.EdgesToRoutes.get(geomEdge);
        for (const edge of route)
            edge.RemoveOccupiedEdge();
        return this.RouteEdge(geomEdge);
    }
    RouteEdge(geomEdge) {
        this.CurrentEdgeGeometry = geomEdge;
        for (let i = 0; i < this.vertexArray.length; i++) {
            const sdv = this.vertexArray[i];
            sdv.SetPreviousToNull();
            sdv.IsTargetOfRouting = sdv.IsSourceOfRouting = false;
        }
        const transparentShapes = this.MakeTransparentShapesOfEdgeGeometry(geomEdge);
        const ret = this.RouteEdgeWithGroups();
        for (const shape of transparentShapes)
            shape.IsTransparent = false;
        return ret;
    }
    RouteEdgeWithGroups() {
        for (let i = 0; i < 2; i++) {
            this.SetLengthCoefficient();
            this.Queue = new _structs_genericBinaryHeapPriorityQueue__WEBPACK_IMPORTED_MODULE_5__.GenericBinaryHeapPriorityQueue();
            this.sourceLoosePoly = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.sourcePort, true);
            this.targetLoosePoly = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.targetPort, false);
            const ret = this.RouteOnKnownSourceTargetVertices(this.CurrentEdgeGeometry.targetPort.Location.sub(this.CurrentEdgeGeometry.sourcePort.Location).normalize(), i === 0);
            if (ret != null) {
                return ret;
            }
            for (let j = 0; j < this.vertexArray.length; j++) {
                this.vertexArray[j].SetPreviousToNull();
            }
        }
        // SplineRouter.ShowVisGraph('./tmp/badVis.svg', this.VisibilityGraph, Array.from(this.ObstacleHierarchy.GetAllLeaves()), null, [
        //  LineSegment.mkPP(this.CurrentEdgeGeometry.sourcePort.Location, this.CurrentEdgeGeometry.targetPort.Location),
        // ])
        throw new Error();
    }
    RouteOnKnownSourceTargetVertices(pathDirection, lookingForMonotonePath) {
        this.LowestCostToTarget = Number.POSITIVE_INFINITY;
        this.ClosestTargetVertex = null;
        while (this.Queue.count > 0) {
            const hu = { priority: 0 };
            const bestNode = this.Queue.DequeueAndGetPriority(hu);
            if (hu.priority >= this.LowestCostToTarget) {
                continue;
            }
            // update the rest
            for (let i = 0; i < bestNode.OutBoneEdges.length; i++) {
                const outBoneEdge = bestNode.OutBoneEdges[i];
                if (outBoneEdge.IsPassable) {
                    this.ProcessOutcomingBoneEdge(bestNode, outBoneEdge, pathDirection, lookingForMonotonePath);
                }
            }
            for (let i = 0; i < bestNode.InBoneEdges.length; i++) {
                const inBoneEdge = bestNode.InBoneEdges[i];
                if (inBoneEdge.IsPassable) {
                    this.ProcessIncomingBoneEdge(bestNode, inBoneEdge, pathDirection, lookingForMonotonePath);
                }
            }
        }
        return this.GetPathAndUpdateRelatedCosts();
    }
    ProcessOutcomingBoneEdge(v, outBoneEdge, pathDirection, lookingForMonotonePath) {
        //Assert.assert(v === outBoneEdge.Source)
        if (lookingForMonotonePath && pathDirection.dot(outBoneEdge.TargetPoint.sub(outBoneEdge.SourcePoint)) < 0) {
            return;
        }
        this.ProcessBoneEdge(v, outBoneEdge.Target, outBoneEdge);
    }
    ProcessIncomingBoneEdge(v, inBoneEdge, pathDirection, lookingForMonotonePath) {
        //Assert.assert(v === inBoneEdge.Target)
        if (lookingForMonotonePath && pathDirection.dot(inBoneEdge.SourcePoint.sub(inBoneEdge.TargetPoint)) < 0) {
            return;
        }
        this.ProcessBoneEdge(v, inBoneEdge.Source, inBoneEdge);
    }
    ProcessBoneEdge(v, queueCandidate, boneEdge) {
        const newCost = this.GetEdgeAdditionalCost(boneEdge, v.Cost);
        if (queueCandidate.Cost <= newCost) {
            return;
        }
        queueCandidate.Cost = newCost;
        queueCandidate.PrevEdge = boneEdge;
        if (this.Queue.ContainsElement(queueCandidate)) {
            this.Queue.DecreasePriority(queueCandidate, newCost);
        }
        else {
            if (queueCandidate.IsTargetOfRouting) {
                let costToTarget = 0;
                if (this.CurrentEdgeGeometry.targetPort instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_7__.ClusterBoundaryPort) {
                    costToTarget = this.LengthCoefficient * queueCandidate.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length;
                }
                if (newCost + costToTarget < this.LowestCostToTarget) {
                    this.LowestCostToTarget = newCost + costToTarget;
                    this.ClosestTargetVertex = queueCandidate;
                }
                return;
                // do not enqueue the target vertices
            }
            this.Enqueue(queueCandidate);
        }
    }
    GetPathAndUpdateRelatedCosts() {
        // restore the path by moving backwards
        let current = this.ClosestTargetVertex;
        if (current == null) {
            return null;
        }
        const result = new Array();
        while (current.PrevEdge != null) {
            result.push(current.PrevEdge);
            this.RegisterPathInBoneEdge(current.PrevEdge);
            current = current.Prev;
        }
        this.EdgesToRouteSources.set(this.CurrentEdgeGeometry, current);
        result.reverse();
        //Assert.assert(result.length > 0)
        return result;
    }
    RegisterPathInBoneEdge(boneEdge) {
        boneEdge.AddOccupiedEdge();
        if (this.cdt != null && this.BundlingSettings.CapacityOverflowCoefficient !== 0) {
            this.UpdateResidualCostsOfCrossedCdtEdges(boneEdge);
        }
    }
    UpdateResidualCostsOfCrossedCdtEdges(boneEdge) {
        for (const cdtEdge of boneEdge.CrossedCdtEdges) {
            if (this.AdjacentToSourceOrTarget(cdtEdge))
                continue;
            if (cdtEdge.ResidualCapacity === cdtEdge.Capacity) {
                cdtEdge.ResidualCapacity -= this.BundlingSettings.edgeWidthShrinkCoeff * this.CurrentEdgeGeometry.lineWidth;
            }
            else {
                cdtEdge.ResidualCapacity -= this.BundlingSettings.ActualEdgeWidth(this.CurrentEdgeGeometry);
            }
        }
    }
    H(v) {
        return v.Cost + this.LengthCoefficient * v.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length;
    }
    GetEdgeAdditionalCost(boneEdge, previousCost) {
        const len = boneEdge.TargetPoint.sub(boneEdge.SourcePoint).length;
        return (this.LengthCoefficient * len +
            previousCost +
            (boneEdge.IsOccupied ? 0 : this.BundlingSettings.InkImportance * len) +
            this.CapacityOverflowCost(boneEdge));
    }
    CapacityOverflowCost(boneEdge) {
        if (this.cdt == null || this.BundlingSettings.CapacityOverflowCoefficient === 0)
            return 0;
        let ret = 0;
        for (const cdtEdge of this.CrossedCdtEdgesOfBoneEdge(boneEdge)) {
            ret += this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier, this.BundlingSettings, this.CurrentEdgeGeometry, cdtEdge);
        }
        return ret;
    }
    CrossedCdtEdgesOfBoneEdge(boneEdge) {
        if (boneEdge.CrossedCdtEdges != null)
            return Array.from(boneEdge.CrossedCdtEdges);
        return Array.from((boneEdge.CrossedCdtEdges = this.ThreadBoneEdgeThroughCdt(boneEdge)));
    }
    ThreadBoneEdgeThroughCdt(boneEdge) {
        const start = boneEdge.SourcePoint;
        const currentTriangle = boneEdge.Source.Triangle;
        //Assert.assert(Cdt.PointIsInsideOfTriangle(start, currentTriangle))
        const crossedEdges = new Set();
        const end = boneEdge.TargetPoint;
        if (_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_8__.Cdt.PointIsInsideOfTriangle(end, currentTriangle)) {
            return crossedEdges;
        }
        const threader = new _CdtThreader__WEBPACK_IMPORTED_MODULE_10__.CdtThreader(currentTriangle, start, end);
        while (threader.MoveNext()) {
            const piercedEdge = threader.CurrentPiercedEdge;
            //Assert.assert(piercedEdge != null)
            if (this.Gates.has(piercedEdge)) {
                crossedEdges.add(piercedEdge);
            }
        }
        // if(ddd(boneEdge))
        // CdtSweeper.ShowFront(Cdt.GetTriangles(),null,new []{new LineSegment(boneEdge.SourcePoint,boneEdge.TargetPoint)}, crossedEdges.Select(e=>new LineSegment(e.upperSite.point,e.lowerSite.point)));
        return crossedEdges;
    }
    // TODO: method incorrect since id doesn't check AdjacentToSourceOrTarget condition
    static CostOfCrossingCdtEdge(capacityOverflMult, bundlingSettings, currentEdgeGeometry, e) {
        let w = currentEdgeGeometry.lineWidth * bundlingSettings.edgeWidthShrinkCoeff;
        if (e.Capacity !== e.ResidualCapacity) {
            w += bundlingSettings.EdgeSeparation * bundlingSettings.edgeWidthShrinkCoeff;
        }
        const del = e.ResidualCapacity - w;
        if (del >= 0) {
            return 0;
        }
        return -del * capacityOverflMult;
    }
    CostOfCrossingCdtEdgeLocal(capacityOverflMult, bundlingSettings, currentEdgeGeometry, e) {
        if (this.AdjacentToSourceOrTarget(e)) {
            return 0;
        }
        return SdShortestPath.CostOfCrossingCdtEdge(capacityOverflMult, bundlingSettings, currentEdgeGeometry, e);
    }
    AdjacentToSourceOrTarget(e) {
        return (e.upperSite.Owner === this.sourceLoosePoly ||
            e.lowerSite.Owner === this.sourceLoosePoly ||
            e.upperSite.Owner === this.targetLoosePoly ||
            e.lowerSite.Owner === this.targetLoosePoly);
    }
    SetLengthCoefficient() {
        const idealEdgeLength = this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);
        this.LengthCoefficient = this.BundlingSettings.PathLengthImportance / idealEdgeLength;
    }
    GetIdealDistanceBetweenSourceAndTarget(geomEdge) {
        return geomEdge.sourcePort.Location.sub(geomEdge.targetPort.Location).length;
    }
    SetPortVerticesAndObstacles(port, sources) {
        let poly;
        if (port instanceof _ClusterBoundaryPort__WEBPACK_IMPORTED_MODULE_7__.ClusterBoundaryPort) {
            const cbport = port;
            //SplineRouter.ShowVisGraph(this.VisibilityGraph, this.ObstacleHierarchy.GetAllLeaves(), null, new[]{cbport.LoosePolyline});
            poly = cbport.LoosePolyline;
            for (const point of poly) {
                let initialCost = 0;
                if (sources) {
                    //we prefer paths starting from the center of the group
                    initialCost = this.LengthCoefficient * point.sub(this.CurrentEdgeGeometry.sourcePort.Location).length;
                }
                this.AddAndEnqueueVertexToEnds(point, sources, initialCost);
            }
        }
        else {
            if (port instanceof _layout_core_hookUpAnywhereFromInsidePort__WEBPACK_IMPORTED_MODULE_0__.HookUpAnywhereFromInsidePort) {
                const anywherePort = port;
                poly = anywherePort.LoosePolyline;
                for (const point of poly)
                    this.AddAndEnqueueVertexToEnds(point, sources, 0);
            }
            else {
                this.AddAndEnqueueVertexToEnds(port.Location, sources, 0);
                const polys = Array.from(this.ObstacleHierarchy.GetNodeItemsIntersectingRectangle(port.Curve.boundingBox));
                let mindiag = polys[0].boundingBox.diagonal;
                poly = polys[0];
                for (let i = 1; i < polys.length; i++) {
                    const pl = polys[i];
                    const diag = pl.boundingBox.diagonal;
                    if (diag < mindiag) {
                        mindiag = diag;
                        poly = pl;
                    }
                }
            }
        }
        return poly;
    }
    Enqueue(simpleSdVertex) {
        this.Queue.Enqueue(simpleSdVertex, this.H(simpleSdVertex));
    }
    AddAndEnqueueVertexToEnds(point, isSource, initialCost) {
        const v = this.FindVertex(point);
        const sdVert = this.VisibilityVerticesToSdVerts.get(v);
        if (isSource) {
            sdVert.IsSourceOfRouting = true;
            sdVert.Cost = initialCost;
            this.Enqueue(sdVert);
        }
        else {
            sdVert.IsTargetOfRouting = true;
        }
    }
    FindVertex(p) {
        return this.VisibilityGraph.FindVertex(p); // in the C# version there is a backup search with rounding
    }
    Initialize() {
        this.CreateRoutingGraph();
        if (this.cdt != null) {
            this.capacityOverlowPenaltyMultiplier = SdShortestPath.CapacityOverflowPenaltyMultiplier(this.BundlingSettings);
            this.SetVertexTriangles();
            this.CalculateCapacitiesOfTrianglulation();
        }
    }
    CalculateCapacitiesOfTrianglulation() {
        for (const e of this.Gates)
            SdShortestPath.CalculateCdtEdgeCapacityForEdge(e);
    }
    static CalculateCdtEdgeCapacityForEdge(e) {
        if (e.constrained || e.CwTriangle == null || e.CcwTriangle == null) {
            return;
        }
        // this is a convex hull edge or an obstacle edge
        const startPoly = e.upperSite.Owner;
        const endPoly = e.lowerSite.Owner;
        if (startPoly !== endPoly) {
            // e.Capacity = Polygon.Distance(new Polygon(startPoly), new Polygon(endPoly)); //todo: cache this
            // e.Capacity = (e.upperSite.point - e.lowerSite.point).length;
            const distA = _visibility_Polygon__WEBPACK_IMPORTED_MODULE_9__.Polygon.DistancePoint(new _visibility_Polygon__WEBPACK_IMPORTED_MODULE_9__.Polygon(startPoly), e.lowerSite.point);
            const distB = _visibility_Polygon__WEBPACK_IMPORTED_MODULE_9__.Polygon.DistancePoint(new _visibility_Polygon__WEBPACK_IMPORTED_MODULE_9__.Polygon(endPoly), e.upperSite.point);
            e.Capacity = (distA + distB) / 2;
        }
        // else - it is a diagonal of an obstacle, do not care
    }
    SetVertexTriangles() {
        const triangleTree = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__.CreateRectNodeOnArrayOfRectNodes)(Array.from(this.cdt.GetTriangles()).map((t) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__.mkRectangleNode)(t, t.BoundingBox())));
        const vertexTree = (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__.CreateRectNodeOnArrayOfRectNodes)(this.vertexArray.map((v) => (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_3__.mkRectangleNode)(v, _math_geometry_rectangle__WEBPACK_IMPORTED_MODULE_2__.Rectangle.mkOnPoints([v.Point]))));
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_4__.CrossRectangleNodes)(triangleTree, vertexTree, (a, b) => this.TryToAssigenTriangleToVertex(a, b));
    }
    TryToAssigenTriangleToVertex(triangle, vertex) {
        if (vertex.Triangle != null) {
            return;
        }
        if (_ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_8__.Cdt.PointIsInsideOfTriangle(vertex.Point, triangle)) {
            vertex.Triangle = triangle;
        }
    }
    static CapacityOverflowPenaltyMultiplier(bundlingSettings) {
        return bundlingSettings.CapacityOverflowCoefficient * (bundlingSettings.PathLengthImportance + bundlingSettings.InkImportance);
    }
    // compute cdt edges crossed by paths
    FillCrossedCdtEdges(crossedCdtEdges) {
        for (const geometryEdge of this.geomEdges) {
            this.sourceLoosePoly = this.SetPortVerticesAndObstacles(geometryEdge.sourcePort, true);
            this.targetLoosePoly = this.SetPortVerticesAndObstacles(geometryEdge.targetPort, false);
            //crossedCdtEdges.Add(geometryEdge, new Set<CdtEdge>());
            for (const boneEdge of this.EdgesToRoutes.get(geometryEdge)) {
                for (const cdtEdge of this.CrossedCdtEdgesOfBoneEdge(boneEdge)) {
                    if (this.AdjacentToSourceOrTarget(cdtEdge))
                        continue;
                    (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_6__.addToMapOfSets)(crossedCdtEdges, geometryEdge, cdtEdge);
                }
            }
        }
    }
}
//# sourceMappingURL=SdShortestPath.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/SdVertex.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SdVertex: () => (/* binding */ SdVertex)
/* harmony export */ });
class SdVertex {
    get Prev() {
        if (this.PrevEdge == null) {
            return null;
        }
        return this.PrevEdge.Source === this ? this.PrevEdge.Target : this.PrevEdge.Source;
    }
    constructor(visibilityVertex) {
        this.InBoneEdges = new Array();
        this.OutBoneEdges = new Array();
        this.VisibilityVertex = visibilityVertex;
    }
    get Point() {
        return this.VisibilityVertex.point;
    }
    get Cost() {
        if (this.IsSourceOfRouting) {
            return this.cost;
        }
        return this.Prev == null ? Number.POSITIVE_INFINITY : this.cost;
    }
    set Cost(value) {
        this.cost = value;
    }
    SetPreviousToNull() {
        this.PrevEdge = null;
    }
}
//# sourceMappingURL=SdVertex.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/SimulatedAnnealing.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SimulatedAnnealing: () => (/* binding */ SimulatedAnnealing)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/debugCurve.js");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/random.js");
/* harmony import */ var _CostCalculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/CostCalculator.js");
/* harmony import */ var _EdgeNudger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/EdgeNudger.js");
/* harmony import */ var _IntersectionCache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/IntersectionCache.js");
/* harmony import */ var _Intersections__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/Intersections.js");
// Adjust current bundle-routing








class SimulatedAnnealing {
    // fix routing by simulated annealing algorithm
    static FixRouting(metroGraphData, bundlingSettings) {
        return this.FixRoutingMBP(metroGraphData, bundlingSettings, null);
    }
    static FixRoutingMBP(metroGraphData, bundlingSettings, changedPoints) {
        return new SimulatedAnnealing(metroGraphData, bundlingSettings).FixRoutingP(changedPoints);
    }
    constructor(metroGraphData, bundlingSettings) {
        this.stepsWithProgress = 0;
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
        this.costCalculator = new _CostCalculator__WEBPACK_IMPORTED_MODULE_4__.CostCalculator(this.metroGraphData, this.bundlingSettings);
        this.cache = new _IntersectionCache__WEBPACK_IMPORTED_MODULE_6__.IntersectionCache(this.metroGraphData, this.bundlingSettings, this.costCalculator, this.metroGraphData.cdt);
    }
    // Use constraint edge routing to reduce ink
    FixRoutingP(changedPoints) {
        //Assert.assert(SimulatedAnnealing.stationsArePositionedCorrectly(this.metroGraphData))
        this.stationsForOptimizations = this.GetStationsForOptimizations(changedPoints);
        this.cache.InitializeCostCache();
        let step = SimulatedAnnealing.MaxStep;
        let energy = Number.POSITIVE_INFINITY;
        let x = this.metroGraphData.VirtualStations().map((v) => v.Position);
        let iteration = 0;
        while (iteration++ < SimulatedAnnealing.MaxIterations) {
            const coordinatesChanged = this.TryMoveStations();
            //TimeMeasurer.DebugOutput("  #iter = " + iteration + " moved: " + cnt + "/" + metroGraphData.VirtualNodes().Count() + " step: " + step);
            if (iteration <= 1 && !coordinatesChanged)
                return false;
            if (!coordinatesChanged)
                break;
            const oldEnergy = energy;
            energy = _CostCalculator__WEBPACK_IMPORTED_MODULE_4__.CostCalculator.Cost(this.metroGraphData, this.bundlingSettings);
            //TimeMeasurer.DebugOutput("energy: " + energy);
            step = this.UpdateMaxStep(step, oldEnergy, energy);
            const oldX = x;
            x = this.metroGraphData.VirtualStations().map((v) => v.Position);
            if (step < SimulatedAnnealing.MinStep || this.Converged(step, oldX, x)) {
                break;
            }
        }
        // TimeMeasurer.DebugOutput("SA completed after " + iteration + " iterations");
        return true;
    }
    static stationsArePositionedCorrectly(metroGraphData) {
        for (const e of metroGraphData.VirtualEdges()) {
            if (!this.edgeIsPositionedCorrectly(e, metroGraphData))
                return false;
        }
        return true;
    }
    static edgeIsPositionedCorrectly(e, metroGraphData) {
        const u = e[0];
        const v = e[1];
        const allowedToIntersect = metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(u, v);
        const ls = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(u.Position, v.Position);
        const intersected = Array.from(metroGraphData.looseIntersections.obstacleTree.GetNodeItemsIntersectingRectangle(ls.boundingBox))
            .filter((poly) => !allowedToIntersect.has(poly))
            .filter((poly) => _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.CurvesIntersect(ls, poly));
        if (intersected.length > 0) {
            _EdgeNudger__WEBPACK_IMPORTED_MODULE_5__.EdgeNudger.ShowHubs(metroGraphData, null, null, './tmp/badcross.svg', [
                _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(200, 1, 'Brown', ls),
                _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(200, 1, 'Red', _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkCircle(2, u.Position)),
                _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(200, 1, 'Blue', _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkCircle(5, v.Position)),
                _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkCircle(5, v.Position)),
            ].concat(intersected.map((p) => _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(100, 1, 'Pink', p))));
            return false;
        }
        else {
            return true;
        }
    }
    GetStationsForOptimizations(changedPoints) {
        if (changedPoints == null) {
            return new Set(this.metroGraphData.VirtualStations());
        }
        else {
            const result = new Set();
            for (const p of changedPoints) {
                const s = this.metroGraphData.PointToStations.get(p);
                if (s && !s.IsReal)
                    result.add(s);
            }
            return result;
        }
    }
    // stop SA if relative changes are small
    Converged(step, oldx, newx) {
        // return false;
        let den = 0;
        let num = 0;
        for (let i = 0; i < oldx.length; i++) {
            num += oldx[i].sub(newx[i]).lengthSquared;
            den += oldx[i].lengthSquared;
        }
        const res = Math.sqrt(num / den);
        return res < SimulatedAnnealing.MinRelativeChange;
    }
    UpdateMaxStep(step, oldEnergy, newEnergy) {
        // cooling factor
        const T = 0.8;
        if (newEnergy + 1 < oldEnergy) {
            this.stepsWithProgress++;
            if (this.stepsWithProgress >= 5) {
                this.stepsWithProgress = 0;
                step = Math.min(SimulatedAnnealing.MaxStep, step / T);
            }
        }
        else {
            this.stepsWithProgress = 0;
            step *= T;
        }
        return step;
    }
    TryMoveStations() {
        let coordinatesChanged = false;
        const movedStations = new Set();
        // for (var node of metroGraphData.VirtualNodes()) {
        for (const node of this.stationsForOptimizations) {
            if (this.TryMoveStation(node)) {
                //Assert.assert(this.stationsForOptimizations.has(node))
                coordinatesChanged = true;
                movedStations.add(node);
                for (const adj of node.Neighbors) {
                    if (!adj.IsReal) {
                        movedStations.add(adj);
                    }
                }
            }
        }
        this.stationsForOptimizations = movedStations;
        return coordinatesChanged;
    }
    /**
      Move node to decrease the cost of the drawing
     Returns true iff position has changed
  */
    TryMoveStation(s) {
        let direction = this.BuildDirection(s);
        if (direction.length === 0) {
            return false;
        }
        let stepLength = this.BuildStepLength(s, direction);
        if (stepLength < SimulatedAnnealing.MinStep) {
            // try random direction
            direction = RandomPoint();
            stepLength = this.BuildStepLength(s, direction);
            if (stepLength < SimulatedAnnealing.MinStep) {
                return false;
            }
        }
        const step = direction.mul(stepLength);
        const newPosition = s.Position.add(step);
        // can this happen?
        if (this.metroGraphData.PointToStations.has(newPosition)) {
            return false;
        }
        if (!this.moveIsLegalForAdjacentBundles(s, newPosition)) {
            return false;
        }
        this.metroGraphData.MoveNode(s, newPosition);
        this.cache.UpdateCostCache(s);
        return true;
    }
    /** checking the node position and neigborhood bundles */
    moveIsLegalForAdjacentBundles(s, sNewPosition) {
        for (const poly of this.metroGraphData.looseIntersections.obstacleTree.AllHitItems(_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.mkOnPoints([sNewPosition]), (poly) => _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Curve.PointRelativeToCurveLocation(sNewPosition, poly) !== _math_geometry__WEBPACK_IMPORTED_MODULE_1__.PointLocation.Outside)) {
            if (s.getELP().has(poly) === false) {
                return false;
            }
        }
        for (const t of s.Neighbors) {
            const obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t, s);
            if (!this.metroGraphData.cdtIntersections.EdgeIsLegal_(t.Position, sNewPosition, t.cdtTriangle, obstaclesToIgnore))
                return false;
        }
        return true;
    }
    // Calculate the direction to improve the ink function
    BuildDirection(node) {
        const forceInk = this.BuildForceForInk(node);
        const forcePL = this.BuildForceForPathLengths(node);
        const forceR = this.BuildForceForRadius(node);
        const forceBundle = this.BuildForceForBundle(node);
        const force = forceInk.add(forcePL.add(forceR.add(forceBundle)));
        if (force.length < 0.1) {
            return new ___WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
        }
        return force.normalize();
    }
    BuildStepLength(node, direction) {
        let stepLength = SimulatedAnnealing.MinStep;
        let costGain = this.CostGain(node, node.Position.add(direction.mul(stepLength)));
        if (costGain < 0.01) {
            return 0;
        }
        while (2 * stepLength <= SimulatedAnnealing.MaxStep) {
            const newCostGain = this.CostGain(node, node.Position.add(direction.mul(stepLength * 2)));
            if (newCostGain <= costGain) {
                break;
            }
            stepLength *= 2;
            costGain = newCostGain;
        }
        return stepLength;
    }
    // Computes cost delta when moving the node
    // the cost will be negative if a new position overlaps obstacles
    CostGain(node, newPosition) {
        const MInf = -12345678;
        const rGain = this.costCalculator.RadiusGain(node, newPosition);
        if (rGain < MInf) {
            return MInf;
        }
        const bundleGain = this.costCalculator.BundleGain(node, newPosition);
        if (bundleGain < MInf) {
            return MInf;
        }
        const inkGain = this.costCalculator.InkGain(node, newPosition);
        const plGain = this.costCalculator.PathLengthsGain(node, newPosition);
        return rGain + inkGain + plGain + bundleGain;
    }
    // force to decrease ink
    BuildForceForInk(node) {
        //return new Point(0,0);
        let direction = new ___WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
        for (const adj of node.Neighbors) {
            const p = adj.Position.sub(node.Position);
            direction = direction.add(p.normalize());
        }
        //derivative
        const force = direction.mul(this.bundlingSettings.InkImportance);
        return force;
    }
    // direction to decrease path lengths
    BuildForceForPathLengths(node) {
        // return new Point(0,0);
        let direction = new ___WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
        for (const mni of this.metroGraphData.MetroNodeInfosOfNode(node)) {
            const metroline = mni.Metroline;
            const u = mni.PolyPoint.next.point;
            const v = mni.PolyPoint.prev.point;
            const p1 = u.sub(node.Position);
            const p2 = v.sub(node.Position);
            direction = direction.add(p1.div(p1.length * metroline.IdealLength));
            direction = direction.add(p2.div(p2.length * metroline.IdealLength));
        }
        // derivative
        const force = direction.mul(this.bundlingSettings.PathLengthImportance);
        return force;
    }
    // direction to increase radii
    BuildForceForRadius(node) {
        let direction = new ___WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
        const idealR = node.cachedIdealRadius;
        const t = { touchedObstacles: [] };
        const res = this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(node, node.Position, idealR, t);
        if (!res) {
            _EdgeNudger__WEBPACK_IMPORTED_MODULE_5__.EdgeNudger.ShowHubs(this.metroGraphData, null, node, './tmp/hubs.svg', [
                _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(255, 1, 'Brown', _Intersections__WEBPACK_IMPORTED_MODULE_7__.Intersections.containingPoly),
                _math_geometry_debugCurve__WEBPACK_IMPORTED_MODULE_2__.DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkCircle(idealR, node.Position)),
            ]);
            throw new Error();
        }
        // throw new Error()
        //Assert.assert(res) // problem here
        for (const d of t.touchedObstacles) {
            const dist = d[1].sub(node.Position).length;
            //Assert.assert(dist <= idealR)
            const lforce = 2 * (1 - dist / idealR);
            const dir = node.Position.sub(d[1]).normalize();
            direction = direction.add(dir.mul(lforce));
        }
        // derivative
        const force = direction.mul(this.bundlingSettings.HubRepulsionImportance);
        return force;
    }
    /** calculates the direction to push a bundle away from obstacle*/
    BuildForceForBundle(station) {
        let direction = new ___WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
        for (const adjStation of station.Neighbors) {
            const idealWidth = this.metroGraphData.GetWidthSSN(station, adjStation, this.bundlingSettings.EdgeSeparation);
            const t = { closestDist: [] };
            const res = this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(station, adjStation, station.Position, adjStation.Position, idealWidth / 2, t);
            if (!res && false) {}
            //Assert.assert(res) //todo : still unsolved
            for (const d of t.closestDist) {
                const dist = d[0].sub(d[1]).length;
                // Debug.//Assert(LessOrEqual(dist, idealWidth / 2));
                const lforce = 2.0 * (1.0 - dist / (idealWidth / 2));
                const dir = d[0].sub(d[1]).normalize().neg();
                direction = direction.add(dir.mul(lforce));
            }
        }
        //derivative
        const force = direction.mul(this.bundlingSettings.BundleRepulsionImportance);
        return force;
    }
}
SimulatedAnnealing.MaxIterations = 100;
SimulatedAnnealing.MaxStep = 50;
SimulatedAnnealing.MinStep = 1;
SimulatedAnnealing.MinRelativeChange = 0.0005;
function RandomPoint() {
    return new ___WEBPACK_IMPORTED_MODULE_0__.Point(1 + 2 * (0,_utils_random__WEBPACK_IMPORTED_MODULE_3__.random)(), 1 + 2 * (0,_utils_random__WEBPACK_IMPORTED_MODULE_3__.random)());
}
//# sourceMappingURL=SimulatedAnnealing.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/Station.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Station: () => (/* binding */ Station)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");

// (this needs to be public because it's used elsewhere in an interface implementation)
class Station {
    constructor(serialNumber, isRealNode, position) {
        // radius of the corresponding hub
        this.Radius = 0;
        // it maps each neighbor to its hub
        this.BundleBases = new Map();
        // MetroNodeInfos corresponding to the node
        this.MetroNodeInfos = new Array();
        this._cachedIdealRadius = 0;
        this.SerialNumber = serialNumber;
        this.IsReal = isRealNode;
        this.Position = position;
        // if (this.debStop()) {
        //  console.log(this)
        // }
    }
    debStop() {
        return (
        //(this.SerialNumber === 1 && this.Position.sub(new Point(706.0327200902565, 203.36018761064003)).length < 0.01) ||
        this.SerialNumber === 28 && this.Position.sub(new ___WEBPACK_IMPORTED_MODULE_0__.Point(841.2662778763244, 303.3817005853006)).length < 0.001);
    }
    get Position() {
        return this._Position;
    }
    set Position(value) {
        this._Position = value;
        // if (this.debStop()) {
        //  console.log(this)
        // }
    }
    getELP() {
        return this.EnterableLoosePolylines;
    }
    setELP(s) {
        // if (this.SerialNumber === 32 && s.size > 0) {
        //  console.log(this)
        // }
        this.EnterableLoosePolylines = s;
    }
    addEL(p) {
        // if (this.SerialNumber === 32) {
        //  console.log(this)
        // }
        this.EnterableLoosePolylines.add(p);
    }
    get cachedIdealRadius() {
        return this._cachedIdealRadius;
    }
    set cachedIdealRadius(value) {
        //Assert.assert(!isNaN(value))
        this._cachedIdealRadius = value;
    }
    AddEnterableLoosePolyline(poly) {
        if (this.EnterableLoosePolylines == null) {
            this.EnterableLoosePolylines = new Set();
        }
        this.EnterableLoosePolylines.add(poly);
    }
    AddEnterableTightPolyline(poly) {
        if (this.EnterableTightPolylines == null) {
            this.EnterableTightPolylines = new Set();
        }
        this.EnterableTightPolylines.add(poly);
    }
}
//# sourceMappingURL=Station.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/StationEdgeInfo.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StationEdgeInfo: () => (/* binding */ StationEdgeInfo)
/* harmony export */ });
class StationEdgeInfo {
    constructor() {
        this.Width = 0;
        this.Metrolines = new Array();
        this.cachedBundleCost = 0;
    }
    get Count() {
        return this.Metrolines.length;
    }
}
//# sourceMappingURL=StationEdgeInfo.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/StationPositionsAdjuster.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StationPositionsAdjuster: () => (/* binding */ StationPositionsAdjuster)
/* harmony export */ });
/* harmony import */ var stack_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/stack-typescript/lib/src/index.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/pointPair.js");
/* harmony import */ var _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js");
/* harmony import */ var _math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNode.js");
/* harmony import */ var _math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/RTree/rectangleNodeUtils.js");
/* harmony import */ var _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/pointPairMap.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
/* harmony import */ var _utils_setOperations__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/setOperations.js");
/* harmony import */ var _interactiveEdgeRouter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/interactiveEdgeRouter.js");
/* harmony import */ var _CostCalculator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/CostCalculator.js");
/* harmony import */ var _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/HubRadiiCalculator.js");
/* harmony import */ var _PathFixer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/PathFixer.js");
/* harmony import */ var _SimulatedAnnealing__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/SimulatedAnnealing.js");
/* harmony import */ var _tupleMap__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/bundling/tupleMap.js");

















// Adjust current bundle-routing with a number of heuristic
class StationPositionsAdjuster {
    constructor(metroGraphData, bundlingSettings) {
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
    }
    /**  apply a number of heuristics to improve current routing */
    static FixRouting(metroGraphData, bundlingSettings) {
        const adjuster = new StationPositionsAdjuster(metroGraphData, bundlingSettings);
        adjuster.GlueConflictingStations();
        adjuster.UnglueEdgesFromBundleToSaveInk(true);
        let step = 0;
        const MaxSteps = 10;
        while (++step < MaxSteps) {
            // heuristics to improve routing
            let progress = adjuster.GlueConflictingStations();
            progress || (progress = adjuster.RelaxConstrainedEdges());
            progress || (progress = step <= 3 && adjuster.UnglueEdgesFromBundleToSaveInk(false));
            progress || (progress = adjuster.GlueCollinearNeighbors(step));
            progress || (progress = step === 3 && adjuster.RemoveDoublePathCrossings());
            if (!progress) {
                break;
            }
        }
        //one SA has to be executed with bundle forces
        metroGraphData.cdtIntersections.ComputeForcesForBundles = true;
        adjuster.RemoveDoublePathCrossings();
        adjuster.UnglueEdgesFromBundleToSaveInk(true);
        while (adjuster.GlueConflictingStations()) { }
        metroGraphData.Initialize(true);
        //this time initialize the tight enterables also
        // this time initialize the tight enterables also
        //            HubDebugger.ShowHubs(metroGraphData, bundlingSettings);
        // TimeMeasurer.DebugOutput("NodePositionsAdjuster stopped after " + step + " steps");
        // HubDebugger.ShowHubs(metroGraphData, bundlingSettings, true);
        // TimeMeasurer.DebugOutput("Final cost: " + CostCalculator.Cost(metroGraphData, bundlingSettings));
        // TimeMeasurer.DebugOutput("Final cost of forces: " + CostCalculator.CostOfForces(metroGraphData, bundlingSettings));
    }
    /** unite the nodes that are close to each other */
    GlueConflictingStations() {
        //Assert.assert(SimulatedAnnealing.stationsArePositionedCorrectly(this.metroGraphData))
        const circlesHierarchy = this.GetCirclesHierarchy();
        if (circlesHierarchy == null) {
            return false;
        }
        const gluingMap = new Map();
        const gluedDomain = new Set();
        (0,_math_geometry_RTree_rectangleNodeUtils__WEBPACK_IMPORTED_MODULE_7__.CrossRectangleNodesSameType)(circlesHierarchy, circlesHierarchy, (i, j) => this.TryToGlueStations(i, j, gluingMap, gluedDomain));
        if (gluingMap.size === 0) {
            return false;
        }
        //Assert.assert(SimulatedAnnealing.stationsArePositionedCorrectly(this.metroGraphData))
        for (let i = 0; i < this.metroGraphData.Edges.length; i++) {
            this.RegenerateEdge(gluingMap, i);
        }
        const affectedPoints = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_9__.PointSet();
        for (const s of gluedDomain) {
            affectedPoints.add(s.Position);
            for (const neig of s.Neighbors)
                if (!neig.IsReal)
                    affectedPoints.add(neig.Position);
        }
        // TimeMeasurer.DebugOutput("gluing nodes");
        this.metroGraphData.Initialize(false);
        _SimulatedAnnealing__WEBPACK_IMPORTED_MODULE_15__.SimulatedAnnealing.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, affectedPoints);
        return true;
    }
    GetCirclesHierarchy() {
        for (const v of this.metroGraphData.VirtualStations())
            v.Radius = this.GetCurrentHubRadius(v);
        const t = this.metroGraphData.VirtualStations().map(rectNodeOfStation);
        return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_6__.CreateRectNodeOnArrayOfRectNodes)(t);
        function rectNodeOfStation(i) {
            const p = i.Position;
            const r = Math.max(i.Radius, 5);
            const del = new ___WEBPACK_IMPORTED_MODULE_1__.Point(r, r);
            const b = _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.mkPP(p.add(del), p.sub(del));
            return (0,_math_geometry_RTree_rectangleNode__WEBPACK_IMPORTED_MODULE_6__.mkRectangleNode)(i, b);
        }
    }
    GetCurrentHubRadius(node) {
        if (node.IsReal) {
            return node.BoundaryCurve.boundingBox.diagonal / 2;
        }
        else {
            const idealR = node.cachedIdealRadius;
            //TODO: which one?
            let r = this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(node, node.Position, idealR);
            //const r = idealR;
            //Assert.assert(r <= idealR)
            for (const adj of node.Neighbors)
                r = Math.min(r, node.Position.sub(adj.Position).length);
            return r;
        }
    }
    TryToGlueStations(i, j, gluingMap, gluedDomain) {
        //Assert.assert(i !== j)
        if (!(0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.setsAreEqual)(i.getELP(), j.getELP()))
            return false;
        const d = i.Position.sub(j.Position).length;
        const r1 = Math.max(i.Radius, 5);
        const r2 = Math.max(j.Radius, 5);
        if (d >= r1 + r2) {
            return;
        }
        // we are greedily trying to glue i to j
        if (!this.TryGlueOrdered(i, j, gluedDomain, gluingMap)) {
            this.TryGlueOrdered(j, i, gluedDomain, gluingMap);
        }
    }
    TryGlueOrdered(i, j, gluedDomain, gluingMap) {
        if (!gluingMap.has(i) && !gluedDomain.has(i) && this.StationGluingIsAllowed(i, j, gluingMap)) {
            this.Map(i, j, gluedDomain, gluingMap);
            // TimeMeasurer.DebugOutput("gluing nodes " + i.serialNumber + " and " + j.serialNumber);
            return true;
        }
        return false;
    }
    Map(i, j, gluedDomain, gluingMap) {
        gluingMap.set(i, j);
        gluedDomain.add(j);
    }
    /**  trying to glue i to j */
    StationGluingIsAllowed(i, j, gluingMap) {
        for (const adj of i.Neighbors) {
            const k = StationPositionsAdjuster.Glued(adj, gluingMap);
            //1. check that we can merge these stations (== no intersections)
            const obstaclesToIgnore = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(k, i);
            if (!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(k, j, obstaclesToIgnore))
                return false;
        }
        //2. check that cost of the routing is reduced
        const delta = this.ComputeCostDeltaAfterStationGluing(i, j, gluingMap);
        if (delta < 0)
            return false;
        return true;
    }
    ComputeCostDeltaAfterStationGluing(i, j, gluingMap) {
        const d = i.Position.sub(j.Position).length;
        if (i.Radius >= d || j.Radius >= d) {
            return 1;
        }
        let gain = 0;
        // ink
        const oldInk = this.metroGraphData.Ink;
        let newInk = this.metroGraphData.Ink - j.Position.sub(i.Position).length;
        for (const adj of i.Neighbors) {
            const k = StationPositionsAdjuster.Glued(adj, gluingMap);
            newInk -= k.Position.sub(i.Position).length;
            newInk += this.metroGraphData.RealEdgeCount(k, j) === 0 ? k.Position.sub(j.Position).length : 0;
        }
        gain += _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);
        //path lengths
        for (const metroInfo of this.metroGraphData.MetroNodeInfosOfNode(i)) {
            const oldLength = metroInfo.Metroline.Length;
            let newLength = metroInfo.Metroline.Length;
            const pi = metroInfo.PolyPoint;
            const pa = pi.prev;
            const pb = pi.next;
            newLength -= pa.point.sub(i.Position).length + pb.point.sub(i.Position).length;
            newLength += pa.point.sub(j.Position).length + pb.point.sub(j.Position).length;
            gain += _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.PathLengthsError(oldLength, newLength, metroInfo.Metroline.IdealLength, this.bundlingSettings);
        }
        return gain;
    }
    RegenerateEdge(gluingMap, edgeIndex) {
        const poly = this.metroGraphData.Metrolines[edgeIndex].Polyline;
        for (const p of poly) {
            if (!this.metroGraphData.PointToStations.has(p)) {
                return;
            }
        }
        let atLeastOnGlued = false;
        for (const p of poly) {
            if (gluingMap.has(this.metroGraphData.PointToStations.get(p))) {
                atLeastOnGlued = true;
                break;
            }
        }
        if (!atLeastOnGlued) {
            return;
        }
        const metrolines = Array.from(poly).map((p) => this.metroGraphData.PointToStations.get(p));
        this.metroGraphData.Edges[edgeIndex].curve = _math_geometry__WEBPACK_IMPORTED_MODULE_2__.Polyline.mkFromPoints(StationPositionsAdjuster.GluedPolyline(metrolines, gluingMap));
        return;
    }
    static GluedPolyline(metroline, gluedMap) {
        let i;
        const ret = new stack_typescript__WEBPACK_IMPORTED_MODULE_0__.Stack();
        ret.push(metroline[0]);
        const seenStations = new Set();
        for (i = 1; i < metroline.length - 1; i++) {
            const station = StationPositionsAdjuster.Glued(metroline[i], gluedMap);
            if (seenStations.has(station)) {
                // we made a cycle - need to cut it out
                while (ret.top !== station) {
                    seenStations.delete(ret.pop());
                }
                continue;
            }
            if (___WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(station.Position, ret.top.Position)) {
                continue;
            }
            seenStations.add(station);
            ret.push(station);
        }
        ret.push(metroline[i]);
        return Array.from(ret)
            .reverse()
            .map((n) => n.Position);
    }
    static Glued(i, gluedMap) {
        var _a;
        return (_a = gluedMap.get(i)) !== null && _a !== void 0 ? _a : i;
    }
    // Unbundle unnecessary edges:
    //  instead of one bundle (a->bcd) we get two bundles (a->b,a->cd) with smaller ink
    UnglueEdgesFromBundleToSaveInk(alwaysExecuteSA) {
        const segsToPolylines = new _utils_pointPairMap__WEBPACK_IMPORTED_MODULE_8__.PointPairMap();
        this.ink = this.metroGraphData.Ink;
        this.polylineLength = new Map();
        // create polylines
        for (const metroline of this.metroGraphData.Metrolines) {
            this.polylineLength.set(metroline, metroline.Length);
            for (let pp = metroline.Polyline.startPoint; pp.next != null; pp = pp.next) {
                const segment = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_4__.PointPair(pp.point, pp.next.point);
                (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.addToPointPairMap)(segsToPolylines, segment, metroline);
            }
        }
        const affectedPoints = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_9__.PointSet();
        let progress = false;
        for (const metroline of this.metroGraphData.Metrolines) {
            const obstaclesAllowedToIntersect = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.setIntersection)(this.metroGraphData.PointToStations.get(metroline.Polyline.start).getELP(), this.metroGraphData.PointToStations.get(metroline.Polyline.end).getELP());
            if (this.TrySeparateOnPolyline(metroline, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect))
                progress = true;
        }
        if (progress)
            //TimeMeasurer.DebugOutput("unbundling");
            this.metroGraphData.Initialize(false);
        if (alwaysExecuteSA || progress) {
            _SimulatedAnnealing__WEBPACK_IMPORTED_MODULE_15__.SimulatedAnnealing.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, alwaysExecuteSA ? null : affectedPoints);
        }
        return progress;
    }
    TrySeparateOnPolyline(metroline, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect) {
        let progress = false;
        let relaxing = true;
        while (relaxing) {
            relaxing = false;
            for (let p = metroline.Polyline.startPoint; p.next != null && p.next.next != null; p = p.next) {
                if (this.TryShortcutPolypoint(p, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect)) {
                    relaxing = true;
                }
            }
            if (relaxing) {
                progress = true;
            }
        }
        return progress;
    }
    TryShortcutPolypoint(pp, segsToPolylines, affectedPoints, obstaclesAllowedToIntersect) {
        if (this.SeparationShortcutAllowed(pp, segsToPolylines, obstaclesAllowedToIntersect)) {
            affectedPoints.add(pp.point);
            affectedPoints.add(pp.next.point);
            affectedPoints.add(pp.next.next.point);
            this.RemoveShortcuttedPolypoint(pp, segsToPolylines);
            return true;
        }
        return false;
    }
    // allowed iff line (a,c) is legal and inkgain > 0
    SeparationShortcutAllowed(pp, segsToPolylines, obstaclesAllowedToIntersect) {
        const a = pp.point;
        const b = pp.next.point;
        const c = pp.next.next.point;
        const aStation = this.metroGraphData.PointToStations.get(a);
        const bStation = this.metroGraphData.PointToStations.get(b);
        const cStation = this.metroGraphData.PointToStations.get(c);
        // 1. intersections
        const aUc = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.uniteSets)(aStation.getELP(), cStation.getELP());
        const obstaclesToIgnore = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.setIntersectionOfArray)([obstaclesAllowedToIntersect, bStation.getELP(), aUc]);
        if (!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(aStation, cStation, obstaclesToIgnore)) {
            return false;
        }
        // 2. cost gain
        const inkgain = this.GetInkgain(pp, segsToPolylines, a, b, c);
        if (inkgain < 0) {
            return false;
        }
        return true;
    }
    GetInkgain(pp, segsToPolylines, a, b, c) {
        //const abPolylines:Set<Metroline>, bcPolylines:Set<Metroline>, abcPolylines:Set<Metroline>;
        const [abPolylines, bcPolylines, abcPolylines] = this.FindPolylines(pp, segsToPolylines);
        let gain = 0;
        //ink
        const oldInk = this.ink;
        let newInk = this.ink;
        const ab = a.sub(b).length;
        const bc = b.sub(c).length;
        const ac = a.sub(c).length;
        if (abPolylines.size === abcPolylines.size)
            newInk -= ab;
        if (bcPolylines.size === abcPolylines.size)
            newInk -= bc;
        const t = segsToPolylines.get(new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_4__.PointPair(a, c));
        if (!t || t.size === 0)
            newInk += ac;
        gain += _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);
        //path lengths
        for (const metroline of abcPolylines) {
            const oldLength = this.polylineLength.get(metroline);
            const newLength = oldLength - (ab + bc - ac);
            gain += _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.PathLengthsError(oldLength, newLength, metroline.IdealLength, this.bundlingSettings);
        }
        //radii
        let nowR = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(a));
        const widthABC = this.metroGraphData.GetWidthAN(Array.from(abcPolylines), this.bundlingSettings.EdgeSeparation);
        const widthABD = this.metroGraphData.GetWidthAN(Array.from((0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.substractSets)(abPolylines, abcPolylines)), this.bundlingSettings.EdgeSeparation);
        let idealR = _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_13__.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(nowR, a, c, b, widthABC, widthABD, this.bundlingSettings);
        if (idealR > nowR) {
            gain -= _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.RError(idealR, nowR, this.bundlingSettings);
        }
        //check opposite side
        nowR = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(c));
        const widthCBD = this.metroGraphData.GetWidthAN(Array.from((0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.substractSets)(bcPolylines, abcPolylines)), this.bundlingSettings.EdgeSeparation);
        idealR = _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_13__.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(nowR, c, b, a, widthCBD, widthABC, this.bundlingSettings);
        if (idealR > nowR) {
            gain -= _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.RError(idealR, nowR, this.bundlingSettings);
        }
        return gain;
    }
    RemoveShortcuttedPolypoint(pp, segsToPolylines) {
        const a = pp.point;
        const b = pp.next.point;
        const c = pp.next.next.point;
        const [abPolylines, bcPolylines, abcPolylines] = this.FindPolylines(pp, segsToPolylines);
        const ab = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(a, b);
        const bc = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(b, c);
        const ac = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(a, c);
        //fixing ink
        if (abPolylines.size === abcPolylines.size)
            this.ink -= ab;
        if (bcPolylines.size === abcPolylines.size)
            this.ink -= bc;
        const t = segsToPolylines.get(new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_4__.PointPair(a, c));
        if (!t || t.size === 0)
            this.ink += ac;
        //fixing edge lengths
        for (const metroline of abcPolylines) {
            const l = this.polylineLength.get(metroline);
            this.polylineLength.set(metroline, l - (ab + bc - ac));
        }
        //fixing polylines
        for (const metroline of abcPolylines) {
            const pp = Array.from(metroline.Polyline.polylinePoints()).find((p) => p.point.equal(b));
            this.RemovePolypoint(pp);
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.removeFromPointPairMapTuple)(segsToPolylines, [a, b], metroline);
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.removeFromPointPairMapTuple)(segsToPolylines, [b, c], metroline);
            (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.addToPointMapTuple)(segsToPolylines, [a, c], metroline);
        }
    }
    FindPolylines(pp, segsToPolylines) {
        const a = pp.point;
        const b = pp.next.point;
        const c = pp.next.next.point;
        const abPolylines = segsToPolylines.getPP(a, b);
        const bcPolylines = segsToPolylines.getPP(b, c);
        const abcPolylines = (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.setIntersection)(abPolylines, bcPolylines);
        return [abPolylines, bcPolylines, abcPolylines];
    }
    RemovePolypoint(p) {
        const prev = p.prev;
        const next = p.next;
        prev.next = next;
        next.prev = prev;
    }
    /**   Fix the situation where a station has two neighbors that are almost in the same directions */
    GlueCollinearNeighbors(step) {
        const affectedPoints = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_9__.PointSet();
        let progress = false;
        for (const node of this.metroGraphData.Stations)
            if (this.GlueCollinearNeighborsSPN(node, affectedPoints, step)) {
                progress = true;
            }
        if (progress) {
            // TimeMeasurer.DebugOutput("gluing edges");
            this.metroGraphData.Initialize(false);
            _SimulatedAnnealing__WEBPACK_IMPORTED_MODULE_15__.SimulatedAnnealing.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, affectedPoints);
        }
        return progress;
    }
    GlueCollinearNeighborsSPN(node, affectedPoints, step) {
        if (node.Neighbors.length <= 1) {
            return false;
        }
        // node,adj => new via point
        const gluedEdges = new _tupleMap__WEBPACK_IMPORTED_MODULE_16__.TupleMap();
        const neighbors = node.Neighbors;
        for (let i = 0; i < neighbors.length; i++) {
            this.TryToGlueEdges(node, neighbors[i], neighbors[(i + 1) % neighbors.length], gluedEdges, step);
        }
        if (gluedEdges.isEmpty) {
            return false;
        }
        for (const keyValueTriple of gluedEdges) {
            this.GlueEdge(keyValueTriple);
            affectedPoints.add(keyValueTriple[0].Position);
            affectedPoints.add(keyValueTriple[1].Position);
            affectedPoints.add(keyValueTriple[2]);
        }
        return true;
    }
    TryToGlueEdges(node, a, b, gluedEdges, step) {
        //Assert.assert(a !== b)
        const angle = ___WEBPACK_IMPORTED_MODULE_1__.Point.anglePCP(a.Position, node.Position, b.Position);
        if (angle < this.bundlingSettings.AngleThreshold) {
            const la = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(a.Position, node.Position);
            const lb = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(b.Position, node.Position);
            const ratio = Math.min(la, lb) / Math.max(la, lb);
            if (ratio < 0.05) {
                return;
            }
            if (la < lb) {
                if (this.EdgeGluingIsAllowedSSS(node, a, b)) {
                    this.AddEdgeToGlue(node, b, a, a.Position, gluedEdges);
                    return;
                }
            }
            else if (this.EdgeGluingIsAllowedSSS(node, b, a)) {
                this.AddEdgeToGlue(node, a, b, b.Position, gluedEdges);
                return;
            }
            // TODO: need this???
            if (step < 5 && ratio > 0.5) {
                const newPosition = this.ConstructGluingPoint(node, a, b);
                if (this.EdgeGluingIsAllowedSSSP(node, a, b, newPosition)) {
                    this.AddEdgeToGlue(node, b, a, newPosition, gluedEdges);
                }
            }
        }
    }
    ConstructGluingPoint(node, a, b) {
        // temp
        const len = Math.min((0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(a.Position, node.Position), (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(b.Position, node.Position) / 2);
        const dir = a.Position.sub(node.Position).normalize().add(b.Position.sub(node.Position).normalize());
        return node.Position.add(dir.mul(len / 2));
    }
    EdgeGluingIsAllowedSSS(node, a, b) {
        // 0. can't pass through real nodes
        if (a.IsReal || b.IsReal) {
            return false;
        }
        // 0.5 do not glue the stations with the different passports
        if (!(0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.setsAreEqual)(a.getELP(), b.getELP())) {
            return false;
        }
        // 1. check intersections)  Here we are bending the edge (node->b) to pass through a.Position.
        // We need to be sure that segments (node,a) and (a,b) intersect only obstacles enterable for the bundle (node, b)
        if (!this.metroGraphData.cdtIntersections.EdgeIsLegal(a, b, a.Position, b.Position)) {
            return false;
        }
        const enterableForEdgeNodeB = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(node, b);
        const crossingsOfEdgeNodeA = _interactiveEdgeRouter__WEBPACK_IMPORTED_MODULE_11__.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(_math_geometry__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(node.Position, a.Position), this.metroGraphData.LooseTree);
        if (crossingsOfEdgeNodeA.find((ii) => !enterableForEdgeNodeB.has(ii.seg1))) {
            return false;
        }
        const crossingsOfEdgeab = _interactiveEdgeRouter__WEBPACK_IMPORTED_MODULE_11__.InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(_math_geometry__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(a.Position, b.Position), this.metroGraphData.LooseTree);
        if (crossingsOfEdgeab.find((ii) => !enterableForEdgeNodeB.has(ii.seg1))) {
            return false;
        }
        // 2. check cost
        const delta = this.ComputeCostDeltaAfterEdgeGluing(node, a, b, a.Position);
        if (delta < 0) {
            return false;
        }
        return true;
    }
    EdgeGluingIsAllowedSSSP(node, a, b, gluingPoint) {
        // 0. can't pass through real nodes
        if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(gluingPoint, 0, (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.setIntersection)(a.getELP(), b.getELP()))) {
            return false;
        }
        // 1. check intersections
        if (!this.metroGraphData.cdtIntersections.EdgeIsLegal(node, null, node.Position, gluingPoint)) {
            return false;
        }
        if (!this.metroGraphData.cdtIntersections.EdgeIsLegal(a, null, a.Position, gluingPoint)) {
            return false;
        }
        if (!this.metroGraphData.cdtIntersections.EdgeIsLegal(b, null, b.Position, gluingPoint)) {
            return false;
        }
        // 2. check cost
        const delta = this.ComputeCostDeltaAfterEdgeGluing(node, a, b, gluingPoint);
        if (delta < 0) {
            return false;
        }
        return true;
    }
    ComputeCostDeltaAfterEdgeGluing(node, a, b, newp) {
        let gain = 0;
        //ink
        const oldInk = this.metroGraphData.Ink;
        const newInk = this.metroGraphData.Ink -
            (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, b.Position) -
            (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, a.Position) +
            (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, newp) +
            (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(newp, a.Position) +
            (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(newp, b.Position);
        gain += _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.InkError(oldInk, newInk, this.bundlingSettings);
        //path lengths
        for (const metroline of this.metroGraphData.GetIjInfo(node, b).Metrolines) {
            const oldLength = metroline.Length;
            const newLength = metroline.Length - (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, b.Position) + (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, newp) + (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(newp, b.Position);
            gain += _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.PathLengthsError(oldLength, newLength, metroline.IdealLength, this.bundlingSettings);
        }
        for (const metroline of this.metroGraphData.GetIjInfo(node, a).Metrolines) {
            const oldLength = metroline.Length;
            const newLength = metroline.Length - (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, a.Position) + (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, newp) + (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(newp, a.Position);
            gain += _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.PathLengthsError(oldLength, newLength, metroline.IdealLength, this.bundlingSettings);
        }
        //also compute radii gain
        //let nowR = Math.Min(GetCurrentHubRadius(node), (node.Position - newp).Length);
        //let id2 = HubRadiiCalculator.CalculateIdealHubRadiusWithNeighbors(metroGraphData, bundlingSettings, node);
        const id2 = node.cachedIdealRadius;
        const nowR = this.GetCurrentHubRadius(node);
        const idealR = _HubRadiiCalculator__WEBPACK_IMPORTED_MODULE_13__.HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles(nowR, node, node.Position, a, b, this.metroGraphData, this.bundlingSettings);
        if (idealR > nowR) {
            gain += _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.RError(idealR, nowR, this.bundlingSettings);
        }
        if (id2 > (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, newp) && !node.IsReal) {
            gain -= _CostCalculator__WEBPACK_IMPORTED_MODULE_12__.CostCalculator.RError(id2, (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(node.Position, newp), this.bundlingSettings);
        }
        return gain;
    }
    AddEdgeToGlue(node, b, a, newp, gluedEdges) {
        // same edge in the reverse direction
        if (gluedEdges.has(a, node)) {
            return;
        }
        if (gluedEdges.has(b, node)) {
            return;
        }
        if (gluedEdges.has(node, a)) {
            return;
        }
        if (gluedEdges.has(node, b)) {
            return;
        }
        gluedEdges.set(node, a, newp);
        gluedEdges.set(node, b, newp);
    }
    GlueEdge(keyValuePair) {
        const node = keyValuePair[0];
        const a = keyValuePair[1];
        const newp = keyValuePair[2];
        for (const polylinePoint of node.MetroNodeInfos.map((i) => i.PolyPoint)) {
            if (polylinePoint.next != null && polylinePoint.next.point.equal(a.Position)) {
                this.SplitPolylinePoint(polylinePoint, newp);
            }
            else if (polylinePoint.prev != null && polylinePoint.prev.point.equal(a.Position)) {
                this.SplitPolylinePoint(polylinePoint.prev, newp);
            }
        }
    }
    SplitPolylinePoint(node, pointToInsert) {
        if (node.point === pointToInsert || node.next.point === pointToInsert) {
            return;
        }
        const p = _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_5__.PolylinePoint.mkFromPoint(pointToInsert);
        p.polyline = node.polyline;
        p.next = node.next;
        p.prev = node;
        p.next.prev = p;
        p.prev.next = p;
    }
    // split each edge that is too much constrained by the obstacles
    RelaxConstrainedEdges() {
        const affectedPoints = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_9__.PointSet();
        let progress = false;
        for (const edge of this.metroGraphData.VirtualEdges())
            if (this.RelaxConstrainedEdge(edge[0], edge[1], affectedPoints))
                progress = true;
        if (progress) {
            //TimeMeasurer.DebugOutput("relaxing constrained edges");
            this.metroGraphData.Initialize(false);
            _SimulatedAnnealing__WEBPACK_IMPORTED_MODULE_15__.SimulatedAnnealing.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, affectedPoints);
        }
        return progress;
    }
    RelaxConstrainedEdge(a, b, affectedPoints) {
        //find conflicting obstacles
        const idealWidth = this.metroGraphData.GetWidthSSN(a, b, this.bundlingSettings.EdgeSeparation);
        const t = { closestDist: new Array() };
        this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(a, b, a.Position, b.Position, (0.99 * idealWidth) / 2.0, t);
        // //Assert.assert(res); //todo still unsolved
        const closestPoints = t.closestDist;
        if (closestPoints.length > 0) {
            //find closest obstacle
            let bestDist = -1;
            let bestPoint;
            for (const d of closestPoints) {
                //should not be too close
                const distToSegmentEnd = Math.min((0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(a.Position, d[1]), (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(b.Position, d[1]));
                const distAB = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(a.Position, b.Position);
                const ratio = distToSegmentEnd / distAB;
                if (ratio < 0.1)
                    continue;
                //choose the closest
                const dist = (0,_math_geometry_point__WEBPACK_IMPORTED_MODULE_3__.distPP)(d[0], d[1]);
                if (bestDist === -1 || dist < bestDist) {
                    bestDist = dist;
                    bestPoint = d[1];
                }
            }
            if (bestDist === -1)
                return false;
            if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(bestPoint, 0, (0,_utils_setOperations__WEBPACK_IMPORTED_MODULE_10__.setIntersection)(a.getELP(), b.getELP())))
                return false;
            affectedPoints.add(bestPoint);
            affectedPoints.add(a.Position);
            affectedPoints.add(b.Position);
            for (const metroline of this.metroGraphData.GetIjInfo(a, b).Metrolines) {
                let pp = null;
                //TODO: replace the cycle!
                for (const ppp of metroline.Polyline.polylinePoints())
                    if (ppp.point.equal(a.Position)) {
                        pp = ppp;
                        break;
                    }
                //Assert.assert(pp != null)
                if (pp.next != null && pp.next.point.equal(b.Position))
                    this.SplitPolylinePoint(pp, bestPoint);
                else
                    this.SplitPolylinePoint(pp.prev, bestPoint);
            }
            return true;
        }
        return false;
    }
    // switch flips
    RemoveDoublePathCrossings() {
        const progress = new _PathFixer__WEBPACK_IMPORTED_MODULE_14__.PathFixer(this.metroGraphData, this.metroGraphData.PointIsAcceptableForEdge.bind(this)).run();
        if (progress) {
            this.metroGraphData.Initialize(false);
            _SimulatedAnnealing__WEBPACK_IMPORTED_MODULE_15__.SimulatedAnnealing.FixRouting(this.metroGraphData, this.bundlingSettings);
        }
        return progress;
    }
}
//# sourceMappingURL=StationPositionsAdjuster.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/bundling/tupleMap.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TupleMap: () => (/* binding */ TupleMap)
/* harmony export */ });
class TupleMap {
    constructor() {
        this.mainMap = new Map();
    }
    get isEmpty() {
        return this.mainMap.size === 0 || this.everyMapIsEmpty();
    }
    everyMapIsEmpty() {
        for (const b of this.mainMap.values()) {
            if (b.size)
                return false;
        }
        return true;
    }
    get(a, b) {
        const m = this.mainMap.get(a);
        if (m)
            return m.get(b);
    }
    has(a, b) {
        const m = this.mainMap.get(a);
        if (!m)
            return false;
        return m.has(b);
    }
    set(a, b, c) {
        let m = this.mainMap.get(a);
        if (!m) {
            m = new Map();
            this.mainMap.set(a, m);
        }
        m.set(b, c);
    }
    *[Symbol.iterator]() {
        for (const [a, m] of this.mainMap) {
            for (const [b, c] of m) {
                yield [a, b, c];
            }
        }
    }
    *keys() {
        for (const [a, m] of this.mainMap) {
            for (const [b] of m) {
                yield [a, b];
            }
        }
    }
}
//# sourceMappingURL=tupleMap.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/BrokenConeSide.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrokenConeSide: () => (/* binding */ BrokenConeSide)
/* harmony export */ });
/* harmony import */ var _ConeSide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSide.js");

// represents a cone side that is broken by the obstacle
class BrokenConeSide extends _ConeSide__WEBPACK_IMPORTED_MODULE_0__.ConeSide {
    get Start() {
        return this.start;
    }
    get End() {
        return this.EndVertex.point;
    }
    constructor(start, end, coneSide) {
        super();
        this.start = start;
        this.EndVertex = end;
        this.ConeSide = coneSide;
    }
    get Direction() {
        return this.End.sub(this.Start);
    }
    toString() {
        return 'BrokenConeSide: ' + (this.Start + (',' + this.End));
    }
}
//# sourceMappingURL=BrokenConeSide.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/Cone.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cone: () => (/* binding */ Cone)
/* harmony export */ });
class Cone {
    get Removed() {
        return this.removed;
    }
    set Removed(value) {
        this.removed = value;
    }
    constructor(apex, coneSweeper) {
        this.apex = apex;
        this.coneSweeper = coneSweeper;
    }
    get Apex() {
        return this.apex;
    }
    set Apex(value) {
        this.apex = value;
    }
    get RightSideDirection() {
        return this.coneSweeper.ConeRightSideDirection;
    }
    get LeftSideDirection() {
        return this.coneSweeper.ConeLeftSideDirection;
    }
    get RightSide() {
        return this.rightSide;
    }
    set RightSide(value) {
        this.rightSide = value;
        this.rightSide.Cone = this;
    }
    get LeftSide() {
        return this.leftSide;
    }
    set LeftSide(value) {
        this.leftSide = value;
        this.leftSide.Cone = this;
    }
}
//# sourceMappingURL=Cone.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeClosureEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConeClosureEvent: () => (/* binding */ ConeClosureEvent)
/* harmony export */ });
/* harmony import */ var _SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");
// this event caused by the intersection of a ObstacleSideSegment and the other cone side of the same cone
// when this event happens the cone has to be removed

class ConeClosureEvent extends _SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    get ConeToClose() {
        return this.coneToClose;
    }
    get Site() {
        return this.site;
    }
    constructor(site, cone) {
        super();
        this.site = site;
        this.coneToClose = cone;
    }
    toString() {
        return 'ConeClosureEvent ' + this.site;
    }
}
//# sourceMappingURL=ConeClosureEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeLeftSide.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConeLeftSide: () => (/* binding */ ConeLeftSide)
/* harmony export */ });
/* harmony import */ var _ConeSide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSide.js");

class ConeLeftSide extends _ConeSide__WEBPACK_IMPORTED_MODULE_0__.ConeSide {
    constructor(cone) {
        super();
        this.Cone = cone;
    }
    get Start() {
        return this.Cone.Apex;
    }
    get Direction() {
        return this.Cone.LeftSideDirection;
    }
    toString() {
        return 'ConeLeftSide ' + this.Start + (' ' + this.Direction);
    }
}
//# sourceMappingURL=ConeLeftSide.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeRightSide.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConeRightSide: () => (/* binding */ ConeRightSide)
/* harmony export */ });
/* harmony import */ var _ConeSide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSide.js");

class ConeRightSide extends _ConeSide__WEBPACK_IMPORTED_MODULE_0__.ConeSide {
    constructor(cone) {
        super();
        this.Cone = cone;
    }
    get Start() {
        return this.Cone.Apex;
    }
    get Direction() {
        return this.Cone.RightSideDirection;
    }
    toString() {
        return 'ConeRightSide ' + this.Start + ' ' + this.Direction;
    }
}
//# sourceMappingURL=ConeRightSide.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSide.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConeSide: () => (/* binding */ ConeSide)
/* harmony export */ });
class ConeSide {
    constructor() {
        this.Removed = false;
    }
}
//# sourceMappingURL=ConeSide.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSideComparer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConeSideComparer: () => (/* binding */ ConeSideComparer)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _BrokenConeSide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/BrokenConeSide.js");
/* harmony import */ var _ConeLeftSide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeLeftSide.js");




class ConeSideComparer {
    SetOperand(activeElement) {
        this.x = this.IntersectionOfSegmentAndSweepLine(activeElement);
    }
    constructor(coneSweeper) {
        this.coneSweeper = coneSweeper;
    }
    Compare(a, b) {
        const aIsBrokenConeSide = a instanceof _BrokenConeSide__WEBPACK_IMPORTED_MODULE_2__.BrokenConeSide;
        const bIsBrokenConeSide = b instanceof _BrokenConeSide__WEBPACK_IMPORTED_MODULE_2__.BrokenConeSide;
        if (aIsBrokenConeSide) {
            return bIsBrokenConeSide ? this.CompareBrokenSides(a, b) : this.CompareObstacleSideAndConeSide(b);
        }
        else {
            // a is ConeSide
            return bIsBrokenConeSide
                ? this.CompareConeSideAndObstacleSide(a, b)
                : ConeSideComparer.CompareNotIntersectingSegs(a, b);
        }
    }
    static CompareNotIntersectingSegs(a, b) {
        const signedArea = ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(a.Start, b.Start, b.Start.add(b.Direction));
        switch (signedArea) {
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise:
                return -1;
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Clockwise:
                return 1;
            default:
                return 0;
        }
    }
    CompareObstacleSideAndConeSide(coneSide) {
        const orientation = ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.x, coneSide.Start, coneSide.Start.add(coneSide.Direction));
        if (orientation === _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise) {
            return -1;
        }
        if (orientation === _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Clockwise) {
            return 1;
        }
        // we have the case where x belongs to the cone side
        return coneSide instanceof _ConeLeftSide__WEBPACK_IMPORTED_MODULE_3__.ConeLeftSide ? -1 : 1;
    }
    CompareConeSideAndObstacleSide(coneSide, brokenConeSide) {
        const orientation = ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.x, brokenConeSide.start, brokenConeSide.End);
        if (orientation === _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise) {
            return -1;
        }
        if (orientation === _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Clockwise) {
            return 1;
        }
        // we have the case where x belongs to the cone side
        //      lineSweeper.Show(CurveFactory.CreateDiamond(5,5, brokenConeSide.EndVertex.point));
        return coneSide instanceof _ConeLeftSide__WEBPACK_IMPORTED_MODULE_3__.ConeLeftSide ? 1 : -1;
    }
    IntersectionOfSegmentAndSweepLine(obstacleSide) {
        const den = obstacleSide.Direction.dot(this.coneSweeper.SweepDirection);
        //Assert.assert(Math.abs(den) > 0)
        const t = (this.coneSweeper.Z - obstacleSide.Start.dot(this.coneSweeper.SweepDirection)) / den;
        return obstacleSide.Start.add(obstacleSide.Direction.mul(t));
    }
    CompareBrokenSides(aObst, bObst) {
        if (aObst.EndVertex === bObst.EndVertex) {
            return ConeSideComparer.CompareNotIntersectingSegs(aObst.ConeSide, bObst.ConeSide);
        }
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.x, bObst.start, bObst.EndVertex.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise) {
            return -1;
        }
        return 1;
    }
}
//# sourceMappingURL=ConeSideComparer.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSpanner.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConeSpanner: () => (/* binding */ ConeSpanner)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _utils_PointSet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");
/* harmony import */ var _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _LineSweeper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LineSweeper.js");





class ConeSpanner extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_1__.Algorithm {
    constructor(obstacles, visibilityGraph) {
        super(null);
        /** the angle of the cone */
        this.coneAngle = Math.PI / 6;
        this.ports = new _utils_PointSet__WEBPACK_IMPORTED_MODULE_2__.PointSet();
        this._obstacles = Array.from(_visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_3__.VisibilityGraph.OrientHolesClockwise(obstacles));
        this._visibilityGraph = visibilityGraph;
    }
    static mk(obstacles, visibilityGraph, coneAngle, ports, borderPolyline) {
        const ret = new ConeSpanner(obstacles, visibilityGraph);
        // Assert.assert(borderPolyline == null  || obstacles.every((o) => Curve.CurveIsInsideOther(o, borderPolyline)))
        // Assert.assert(
        //  borderPolyline == null  ||
        //  Array.from(ports.values()).every((o) => Curve.PointRelativeToCurveLocation(o, borderPolyline) === PointLocation.Inside),
        // )
        // Assert.assert(obstacles.All(o => ports.All(p => Curve.PointRelativeToCurveLocation(p, o) === PointLocation.Outside)));
        // todo: uncomment this assert - it failes on D:\progression\src\ddsuites\src\vs\Progression\ScenarioTests\Grouping\GroupingResources\GroupBySelection2.dgml
        // when dragging
        // Assert.assert(coneAngle > Math.PI / (180 * 2) && coneAngle <= Math.PI / 2)
        ret.Ports = ports;
        ret.BorderPolyline = borderPolyline;
        ret.ConeAngle = coneAngle;
        return ret;
    }
    get ConeAngle() {
        return this.coneAngle;
    }
    set ConeAngle(value) {
        this.coneAngle = value;
    }
    get Ports() {
        return this.ports;
    }
    set Ports(value) {
        this.ports = value;
    }
    get BorderPolyline() {
        return this.borderPolyline;
    }
    set BorderPolyline(value) {
        this.borderPolyline = value;
    }
    // If set to true then a smaller visibility graph is created.
    // An edge is added to the visibility graph only if it is found at least twice:
    // once sweeping with a direction d and the second time with -d
    get Bidirectional() {
        return this._bidirectional;
    }
    set Bidirectional(value) {
        this._bidirectional = value;
    }
    static GetTotalSteps(coneAngle) {
        return Math.floor((2 * Math.PI - coneAngle / 2) / coneAngle) + 1;
    }
    run() {
        const offset = 2 * Math.PI - this.coneAngle / 2;
        if (!this.Bidirectional) {
            let angle;
            for (let i = 0; (angle = this.coneAngle * i) <= offset; i++) {
                super.ProgressStep();
                this.AddDirection(new ___WEBPACK_IMPORTED_MODULE_0__.Point(Math.cos(angle), Math.sin(angle)), this.BorderPolyline, this._visibilityGraph);
            }
        }
        else {
            this.HandleBideractionalCase();
        }
    }
    HandleBideractionalCase() {
        const k = (Math.PI / this.coneAngle);
        for (let i = 0; i < k; i++) {
            const angle = i * this.coneAngle;
            const vg0 = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_3__.VisibilityGraph();
            this.AddDirection(new ___WEBPACK_IMPORTED_MODULE_0__.Point(Math.cos(angle), Math.sin(angle)), this.BorderPolyline, vg0);
            const vg1 = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_3__.VisibilityGraph();
            this.AddDirection(new ___WEBPACK_IMPORTED_MODULE_0__.Point(Math.cos(angle) * -1, Math.sin(angle) * -1), this.BorderPolyline, vg1);
            this.AddIntersectionOfBothDirectionSweepsToTheResult(vg0, vg1);
        }
    }
    AddIntersectionOfBothDirectionSweepsToTheResult(vg0, vg1) {
        for (const edge of vg0.Edges) {
            if (vg1.FindEdgePP(edge.SourcePoint, edge.TargetPoint) != null) {
                this._visibilityGraph.AddEdgePP(edge.SourcePoint, edge.TargetPoint);
            }
        }
    }
    AddDirection(direction, borderPolyline, visibilityGraph) {
        _LineSweeper__WEBPACK_IMPORTED_MODULE_4__.LineSweeper.Sweep(this._obstacles, direction, this.coneAngle, visibilityGraph, this.Ports, borderPolyline);
    }
}
//# sourceMappingURL=ConeSpanner.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftIntersectionEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LeftIntersectionEvent: () => (/* binding */ LeftIntersectionEvent)
/* harmony export */ });
/* harmony import */ var _SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");
// left here means an intersection of a left cone side with an obstacle edge

class LeftIntersectionEvent extends _SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    get EndVertex() {
        return this.endVertex;
    }
    constructor(coneLeftSide, intersectionPoint, endVertex) {
        super();
        this.coneLeftSide = coneLeftSide;
        this.intersectionPoint = intersectionPoint;
        this.endVertex = endVertex;
    }
    get Site() {
        return this.intersectionPoint;
    }
    toString() {
        return 'LeftIntersectionEvent ' + this.intersectionPoint;
    }
}
//# sourceMappingURL=LeftIntersectionEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftObstacleSide.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LeftObstacleSide: () => (/* binding */ LeftObstacleSide)
/* harmony export */ });
/* harmony import */ var _ObstacleSide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ObstacleSide.js");

class LeftObstacleSide extends _ObstacleSide__WEBPACK_IMPORTED_MODULE_0__.ObstacleSide {
    constructor(startVertex) {
        super(startVertex);
        this.end = startVertex.nextOnPolyline.point;
    }
    get End() {
        return this.end;
    }
    get EndVertex() {
        return this.StartVertex.nextOnPolyline;
    }
}
//# sourceMappingURL=LeftObstacleSide.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftVertexEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LeftVertexEvent: () => (/* binding */ LeftVertexEvent)
/* harmony export */ });
/* harmony import */ var _VertexEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/VertexEvent.js");

class LeftVertexEvent extends _VertexEvent__WEBPACK_IMPORTED_MODULE_0__.VertexEvent {
    constructor(p) {
        super(p);
    }
}
//# sourceMappingURL=LeftVertexEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LineSweeper.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineSweeper: () => (/* binding */ LineSweeper)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js");
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _visibility_LineSweeperBase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/LineSweeperBase.js");
/* harmony import */ var _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js");
/* harmony import */ var _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _BrokenConeSide__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/BrokenConeSide.js");
/* harmony import */ var _Cone__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/Cone.js");
/* harmony import */ var _ConeClosureEvent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeClosureEvent.js");
/* harmony import */ var _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeLeftSide.js");
/* harmony import */ var _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeRightSide.js");
/* harmony import */ var _ConeSideComparer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ConeSideComparer.js");
/* harmony import */ var _LeftIntersectionEvent__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftIntersectionEvent.js");
/* harmony import */ var _LeftObstacleSide__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftObstacleSide.js");
/* harmony import */ var _LeftVertexEvent__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LeftVertexEvent.js");
/* harmony import */ var _RightIntersectionEvent__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightIntersectionEvent.js");
/* harmony import */ var _RightObstacleSide__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightObstacleSide.js");
/* harmony import */ var _RightVertexEvent__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightVertexEvent.js");
/* harmony import */ var _VertexEvent__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/VertexEvent.js");
// sweeps a given direction of cones and adds discovered edges to the graph






















class LineSweeper extends _visibility_LineSweeperBase__WEBPACK_IMPORTED_MODULE_6__.LineSweeperBase /*implements IConeSweeper*/ {
    constructor(obstacles, direction, coneRsDir, coneLsDir, visibilityGraph, ports, borderPolyline) {
        super(obstacles, direction);
        this.visibilityGraph = visibilityGraph;
        this.ConeRightSideDirection = coneRsDir;
        this.ConeLeftSideDirection = coneLsDir;
        this.coneSideComparer = new _ConeSideComparer__WEBPACK_IMPORTED_MODULE_14__.ConeSideComparer(this);
        this.leftConeSides = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_4__.RBTree((a, b) => this.coneSideComparer.Compare(a, b));
        this.rightConeSides = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_4__.RBTree((a, b) => this.coneSideComparer.Compare(a, b));
        this.Ports = ports;
        this.BorderPolyline = borderPolyline;
        this.PortEdgesCreator = (a, b) => {
            return new _visibility_TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_7__.TollFreeVisibilityEdge(a, b, 0);
        };
    }
    static Sweep(obstacles, direction, coneAngle, visibilityGraph, ports, borderPolyline) {
        const cs = new LineSweeper(obstacles, direction, direction.rotate(-coneAngle / 2), direction.rotate(coneAngle / 2), visibilityGraph, ports, borderPolyline);
        cs.Calculate();
    }
    Calculate() {
        this.InitQueueOfEvents();
        while (this.EventQueue.Count > 0) {
            this.ProcessEvent(this.EventQueue.Dequeue());
        }
        if (this.BorderPolyline != null) {
            this.CloseRemainingCones();
        }
        this.CreatePortEdges();
    }
    CreatePortEdges() {
        if (this.portEdgesGraph != null) {
            for (const edge of this.portEdgesGraph.Edges) {
                this.visibilityGraph.AddEdgeF(edge.SourcePoint, edge.TargetPoint, this.PortEdgesCreator);
            }
        }
    }
    CloseRemainingCones() {
        if (this.leftConeSides.count === 0) {
            return;
        }
        //Assert.assert(this.leftConeSides.count === this.rightConeSides.count)
        let p = this.BorderPolyline.startPoint;
        let steps = this.leftConeSides.count;
        // we cannot make more than leftConeSides.Count if the data is correct
        // because at each step we remove at least one cone
        do {
            const cone = this.leftConeSides.treeMinimum().item.Cone;
            p = this.FindPolylineSideIntersectingConeRightSide(p, cone);
            p = this.GetPolylinePointInsideOfConeAndRemoveCones(p, cone);
            steps--;
        } while (this.leftConeSides.count > 0 && steps > 0);
    }
    GetPolylinePointInsideOfConeAndRemoveCones(p, cone) {
        const pn = p.nextOnPolyline;
        const insidePoint = LineSweeper.FindInsidePoint(p.point, pn.point, cone);
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(insidePoint, p.point)) {
            this.AddEdgeAndRemoveCone(cone, p.point);
            this.AddEdgesAndRemoveRemainingConesByPoint(p.point);
            // we don't move p forward here. In the next iteration we just cross [p,pn] with the new leftmost cone right side
        }
        else if (___WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(insidePoint, pn.point)) {
            this.AddEdgeAndRemoveCone(cone, pn.point);
            this.AddEdgesAndRemoveRemainingConesByPoint(pn.point);
            p = pn;
        }
        else {
            p = LineSweeper.InsertPointIntoPolylineAfter(this.BorderPolyline, p, insidePoint);
            this.AddEdgeAndRemoveCone(cone, p.point);
            this.AddEdgesAndRemoveRemainingConesByPoint(p.point);
        }
        return p;
    }
    static FindInsidePoint(leftPoint, rightPoint, cone) {
        //            if (debug)
        //                LayoutAlgorithmSettings.Show(CurveFactory.CreateCircle(3, leftPoint),
        //                                             CurveFactory.CreateDiamond(3, 3, rightPoint),
        //                                             BorderPolyline, ExtendSegmentToZ(cone.LeftSide),
        //                                             ExtendSegmentToZ(cone.RightSide));
        return LineSweeper.FindInsidePointBool(leftPoint, rightPoint, cone.Apex, cone.Apex.add(cone.LeftSideDirection), cone.Apex.add(cone.RightSideDirection));
    }
    static FindInsidePointBool(leftPoint, rightPoint, apex, leftSideConePoint, rightSideConePoint) {
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(leftPoint, rightPoint)) {
            return leftPoint;
        }
        // does not matter which one to return
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.PointIsInsideCone(leftPoint, apex, leftSideConePoint, rightSideConePoint)) {
            return leftPoint;
        }
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.PointIsInsideCone(rightPoint, apex, leftSideConePoint, rightSideConePoint)) {
            return rightPoint;
        }
        const m = ___WEBPACK_IMPORTED_MODULE_0__.Point.middle(leftPoint, rightPoint);
        if (___WEBPACK_IMPORTED_MODULE_0__.Point.pointToTheLeftOfLine(m, apex, leftSideConePoint)) {
            return LineSweeper.FindInsidePointBool(m, rightPoint, apex, leftSideConePoint, rightSideConePoint);
        }
        return LineSweeper.FindInsidePointBool(leftPoint, m, apex, leftSideConePoint, rightSideConePoint);
    }
    AddEdgesAndRemoveRemainingConesByPoint(point) {
        const conesToRemove = new Array();
        for (const leftConeSide of this.leftConeSides) {
            if (___WEBPACK_IMPORTED_MODULE_0__.Point.PointToTheRightOfLineOrOnLine(point, leftConeSide.Start, leftConeSide.Start.add(leftConeSide.Direction))) {
                conesToRemove.push(leftConeSide.Cone);
            }
            else {
                break;
            }
        }
        for (const cone of conesToRemove)
            this.AddEdgeAndRemoveCone(cone, point);
    }
    FindPolylineSideIntersectingConeRightSide(p, cone) {
        const startPoint = p;
        const a = cone.Apex;
        const b = cone.Apex.add(this.ConeRightSideDirection);
        let pSign = LineSweeper.GetSign(p, a, b);
        for (; true;) {
            const pn = p.nextOnPolyline;
            const pnSigh = LineSweeper.GetSign(pn, a, b);
            if (pnSigh - pSign > 0) {
                return p;
            }
            p = pn;
            pSign = pnSigh;
            if (p === startPoint) {
                throw new Error('cannod decide if the polyline intersects the cone!');
                //Assert.assert(false)
            }
        }
    }
    // #if TEST_MSAGL
    //         // ReSharper disable UnusedMember.Local
    //         static ICurve Box(Point p) {
    //             // ReSharper restore UnusedMember.Local
    //             return CurveFactory.CreateRectangle(2, 2, p);
    //         }
    //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
    //         )]
    //         void PrintOutRightSegTree() {
    //             System.Diagnostics.Debug.WriteLine("right segment tree");
    //             foreach(var t of rightConeSides)
    //             System.Diagnostics.Debug.WriteLine(t);
    //             System.Diagnostics.Debug.WriteLine("end of right segments");
    //         }
    // #endif
    static GetSign(p, a, b) {
        const d = ___WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(a, b, p.point);
        if (d < 0) {
            return 1;
        }
        return d > 0 ? -1 : 0;
    }
    // #if TEST_MSAGL && TEST_MSAGL
    //         void Showside(PolylinePoint p, Point a, Point b, PolylinePoint pn) {
    //             ShowBothTrees(new DebugCurve(100, 1, "brown", BorderPolyline), new DebugCurve(100, 2, "blue",
    //                 new LineSegment(a, b)),
    //                 new DebugCurve(100, 2, "green",
    //                     new LineSegment(
    //                         pn.point, p.point)
    //                 ));
    //         }
    // #endif
    //        void CheckThatPolylineIsLegal()
    //        {
    //            var p = BorderPolyline.startPoint;
    //            do
    //            {
    //                var pn = p.NextOnPolyline;
    //                Assert.assert(!Point.closeDistEps(p.point, pn.point));
    //                Assert.assert((pn.point - p.point)*(pn.NextOnPolyline.point - pn.point) > -GeomConstants.tolerance);
    //                p = pn;
    //            } while (p !== BorderPolyline.startPoint);
    //        }
    // #if TEST_MSAGL
    //         void ShowBoundaryPolyline() {
    //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(CreateBoundaryPolyDebugCurves());
    //         }
    //         Array < DebugCurve > CreateBoundaryPolyDebugCurves() {
    //             int i = 0;
    //             for (var p = BorderPolyline.startPoint; p != null; p = p.next) {
    //                 yield return new DebugCurve(new Ellipse(1, 1, p.point), i++);
    //             }
    //         }
    // #endif
    AddEdgeAndRemoveCone(cone, p) {
        if (this.Ports != null && this.Ports.has(cone.Apex)) {
            this.CreatePortEdge(cone, p);
        }
        else {
            this.visibilityGraph.AddEdgePP(cone.Apex, p);
        }
        this.RemoveCone(cone);
    }
    CreatePortEdge(cone, p) {
        if (this.portEdgesGraph == null) {
            this.portEdgesGraph = new _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_8__.VisibilityGraph();
        }
        const coneApexVert = this.portEdgesGraph.FindVertex(cone.Apex);
        // all previous edges adjacent to cone.Apex
        const edgesToFix = coneApexVert != null ? Array.from(coneApexVert.InEdges).concat(Array.from(coneApexVert.OutEdges.allNodes())) : null;
        if (edgesToFix) {
            for (const edge of edgesToFix) {
                const otherPort = (edge.Target === coneApexVert ? edge.Source : edge.Target).point;
                _visibility_VisibilityGraph__WEBPACK_IMPORTED_MODULE_8__.VisibilityGraph.RemoveEdge(edge);
                this.portEdgesGraph.AddEdgePP(otherPort, p);
            }
        }
        this.portEdgesGraph.AddEdgePP(cone.Apex, p);
    }
    static InsertPointIntoPolylineAfter(borderPolyline, insertAfter, pointToInsert) {
        let np;
        if (insertAfter.next != null) {
            np = _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_3__.PolylinePoint.mkFromPoint(pointToInsert);
            np.prev = insertAfter;
            np.next = insertAfter.next;
            insertAfter.next.prev = np;
            insertAfter.next = np;
        }
        else {
            np = _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_3__.PolylinePoint.mkFromPoint(pointToInsert);
            np.prev = insertAfter;
            insertAfter.next = np;
            borderPolyline.endPoint = np;
        }
        np.polyline = borderPolyline;
        // Assert.assert(
        //  !(
        //    Point.closeDistEps(np.point, np.prevOnPolyline.point) ||
        //    Point.closeDistEps(np.point, np.nextOnPolyline.point)
        //  ),
        // )
        borderPolyline.setInitIsRequired();
        return np;
    }
    ProcessEvent(p) {
        // Assert.assert(this.invariant())
        if (p instanceof _VertexEvent__WEBPACK_IMPORTED_MODULE_21__.VertexEvent) {
            this.ProcessVertexEvent(p);
        }
        else {
            if (p instanceof _RightIntersectionEvent__WEBPACK_IMPORTED_MODULE_18__.RightIntersectionEvent) {
                this.ProcessRightIntersectionEvent(p);
            }
            else {
                if (p instanceof _LeftIntersectionEvent__WEBPACK_IMPORTED_MODULE_15__.LeftIntersectionEvent) {
                    this.ProcessLeftIntersectionEvent(p);
                }
                else {
                    if (p instanceof _ConeClosureEvent__WEBPACK_IMPORTED_MODULE_11__.ConeClosureEvent) {
                        if (!p.ConeToClose.Removed) {
                            this.RemoveCone(p.ConeToClose);
                        }
                    }
                    else {
                        this.ProcessPortObstacleEvent(p);
                    }
                    this.Z = this.GetZS(p);
                }
            }
        }
        // Assert.assert(TreesAreCorrect());
    }
    // #if TEST_MSAGL
    //        protected override bool TreesAreCorrect() {
    //            return TreeIsCorrect(leftConeSides) && TreeIsCorrect(rightConeSides);
    //        }
    //
    //        bool TreeIsCorrect(RBTree<ConeSide> tree) {
    //            var y = Number.NEGATIVE_INFINITY;
    //            foreach (var t of tree) {
    //                var x = coneSideComparer.IntersectionOfSegmentAndSweepLine(t);
    //                var yp = x*DirectionPerp;
    //                if (yp < y - GeomConstants.distanceEpsilon)
    //                    return false;
    //                y = yp;
    //            }
    //            return true;
    //        }
    // #endif
    ProcessPortObstacleEvent(portObstacleEvent) {
        this.Z = this.GetZS(portObstacleEvent);
        this.GoOverConesSeeingVertexEvent(portObstacleEvent);
        this.CreateConeOnVertex(portObstacleEvent);
    }
    ProcessLeftIntersectionEvent(leftIntersectionEvent) {
        if (leftIntersectionEvent.coneLeftSide.Removed === false) {
            if (Math.abs(leftIntersectionEvent.EndVertex.point.sub(leftIntersectionEvent.Site).dot(this.SweepDirection)) <
                _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                // the cone is totally covered by a horizontal segment
                this.RemoveCone(leftIntersectionEvent.coneLeftSide.Cone);
            }
            else {
                this.RemoveSegFromLeftTree(leftIntersectionEvent.coneLeftSide);
                this.Z = this.GetZP(leftIntersectionEvent.Site);
                // it is safe now to restore the order
                const leftSide = new _BrokenConeSide__WEBPACK_IMPORTED_MODULE_9__.BrokenConeSide(leftIntersectionEvent.Site, leftIntersectionEvent.EndVertex, leftIntersectionEvent.coneLeftSide);
                this.InsertToTree(this.leftConeSides, leftSide);
                leftIntersectionEvent.coneLeftSide.Cone.LeftSide = leftSide;
                this.LookForIntersectionOfObstacleSideAndLeftConeSide(leftIntersectionEvent.Site, leftIntersectionEvent.EndVertex);
                this.TryCreateConeClosureForLeftSide(leftSide);
            }
        }
        else {
            this.Z = this.GetZP(leftIntersectionEvent.Site);
        }
    }
    TryCreateConeClosureForLeftSide(leftSide) {
        if (leftSide.Cone.RightSide instanceof _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__.ConeRightSide) {
            const coneRightSide = leftSide.Cone.RightSide;
            if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(coneRightSide.Start, coneRightSide.Start.add(coneRightSide.Direction), leftSide.EndVertex.point) ==
                _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Clockwise) {
                this.CreateConeClosureEvent(leftSide, coneRightSide);
            }
        }
    }
    CreateConeClosureEvent(brokenConeSide, otherSide) {
        const x = ___WEBPACK_IMPORTED_MODULE_0__.Point.RayIntersectsRayInteriors(brokenConeSide.start, brokenConeSide.Direction, otherSide.Start, otherSide.Direction);
        if (x) {
            const cc = new _ConeClosureEvent__WEBPACK_IMPORTED_MODULE_11__.ConeClosureEvent(x, brokenConeSide.Cone);
            this.EnqueueEvent(cc);
        }
    }
    ProcessRightIntersectionEvent(rightIntersectionEvent) {
        // restore Z for the time being
        // Z = PreviousZ;
        if (!rightIntersectionEvent.coneRightSide.Removed) {
            // it can happen that the cone side participating in the intersection is gone;
            // obstracted by another obstacle or because of a vertex found inside of the cone
            // PrintOutRightSegTree();
            this.RemoveSegFromRightTree(rightIntersectionEvent.coneRightSide);
            this.Z = this.GetZP(rightIntersectionEvent.Site);
            const rightSide = new _BrokenConeSide__WEBPACK_IMPORTED_MODULE_9__.BrokenConeSide(rightIntersectionEvent.Site, rightIntersectionEvent.EndVertex, rightIntersectionEvent.coneRightSide);
            this.InsertToTree(this.rightConeSides, rightSide);
            rightIntersectionEvent.coneRightSide.Cone.RightSide = rightSide;
            this.LookForIntersectionOfObstacleSideAndRightConeSide(rightIntersectionEvent.Site, rightIntersectionEvent.EndVertex);
            this.TryCreateConeClosureForRightSide(rightSide);
        }
        else {
            this.Z = this.GetZP(rightIntersectionEvent.Site);
        }
    }
    TryCreateConeClosureForRightSide(rightSide) {
        if (rightSide.Cone.LeftSide instanceof _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__.ConeLeftSide) {
            const coneLeftSide = rightSide.Cone.LeftSide;
            if (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(coneLeftSide.Start, coneLeftSide.Start.add(coneLeftSide.Direction), rightSide.EndVertex.point) ==
                _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise) {
                this.CreateConeClosureEvent(rightSide, coneLeftSide);
            }
        }
    }
    RemoveConesClosedBySegment(leftPoint, rightPoint) {
        this.CloseConesCoveredBySegment(leftPoint, rightPoint, this.GetZP(leftPoint) > this.GetZP(rightPoint) ? this.leftConeSides : this.rightConeSides);
    }
    CloseConesCoveredBySegment(leftPoint, rightPoint, tree) {
        //Assert.assert(rightPoint.sub(leftPoint).dot(this.directionPerp) > GeomConstants.distanceEpsilon)
        let node = tree.findFirst((s) => ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(s.Start, s.Start.add(s.Direction), leftPoint) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise);
        if (node == null)
            return;
        const x = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(leftPoint, rightPoint, node.item.Start, node.item.Direction);
        if (!x) {
            return;
        }
        const conesToRemove = new Array();
        do {
            conesToRemove.push(node.item.Cone);
            node = tree.next(node);
        } while (node != null && ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(leftPoint, rightPoint, node.item.Start, node.item.Direction) !== undefined);
        for (const cone of conesToRemove)
            this.RemoveCone(cone);
    }
    ProcessVertexEvent(vertexEvent) {
        this.Z = this.GetZS(vertexEvent);
        this.GoOverConesSeeingVertexEvent(vertexEvent);
        this.AddConeAndEnqueueEvents(vertexEvent);
    }
    // #if TEST_MSAGL
    //         // ReSharper disable UnusedMember.Local
    //         static Ellipse EllipseOnVert(SweepEvent vertexEvent) {
    //             // ReSharper restore UnusedMember.Local
    //             return new Ellipse(5, 5, vertexEvent.Site);
    //         }
    //         // ReSharper disable UnusedMember.Local
    //         static Ellipse EllipseOnPolylinePoint(PolylinePoint pp) {
    //             // ReSharper restore UnusedMember.Local
    //             return EllipseOnPolylinePoint(pp, 5);
    //         }
    //         // ReSharper disable UnusedMember.Local
    //         static Ellipse EllipseOnPolylinePoint(PolylinePoint pp, double i)
    //         // ReSharper restore UnusedMember.Local
    //         {
    //             return new Ellipse(i, i, pp.point);
    //         }
    static Diamond(p) {
        return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.CurveFactory.mkDiamond(2, 2, p);
    }
    //         // ReSharper disable UnusedMember.Local
    //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
    //         ),
    //         void CheckConsistency() {
    //             // ReSharper restore UnusedMember.Local
    //             foreach(var s of rightConeSides) {
    //                 coneSideComparer.SetOperand(s);
    //             }
    //             foreach(var s of leftConeSides) {
    //                 coneSideComparer.SetOperand(s);
    //                 if (!rightConeSides.Contains(s.Cone.RightSide)) {
    //                     PrintOutRightSegTree();
    //                     PrintOutLeftSegTree();
    //                     ShowLeftTree();
    //                     ShowRightTree();
    //                 }
    //             }
    //         }
    //         void ShowRightTree(params ICurve[] curves) {
    //             var l = Obstacles.Select(p => new DebugCurve(100, 5, "green", p)).ToList();
    //             l.AddRange(rightConeSides.Select(s => new DebugCurve(100, 5, "blue", ExtendSegmentToZ(s))));
    //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
    //             //                l.Add(BezierOnEdge(edge));
    //             l.AddRange(curves.Select(c => new DebugCurve(100, 5, "brown", c)));
    //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    //         }
    //         void ShowBothTrees(params DebugCurve[] curves) {
    //             var l = Obstacles.Select(p => new DebugCurve(100, 5, "green", p)).ToList();
    //             l.AddRange(leftConeSides.Select(s => new DebugCurve(ExtendSegmentToZ(s))));
    //             l.AddRange(rightConeSides.Select(s => new DebugCurve(ExtendSegmentToZ(s))));
    //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
    //             //                l.Add(BezierOnEdge(edge));
    //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    //         }
    //         void ShowLeftTree(params ICurve[] curves) {
    //             var l = Obstacles.Select(p => new DebugCurve(100, 0.01, "green", p)).ToList();
    //             var range = new RealNumberSpan();
    //             var ellipseSize = 0.01;
    //             foreach(var s of leftConeSides) {
    //                 var curve = ExtendSegmentToZ(s);
    //                 range.AddValue(curve.start * DirectionPerp);
    //                 range.AddValue(curve.End * DirectionPerp);
    //                 l.Add(new DebugCurve(100, 0.1, "red", curve));
    //                 l.Add(new DebugCurve(200, 0.1, "black", new Ellipse(ellipseSize, ellipseSize, curve.End)));
    //                 ellipseSize += 2;
    //             }
    //             l.Add(DebugSweepLine(range));
    //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
    //             //                l.Add(BezierOnEdge(edge));
    //             l.AddRange(curves.Select(c => new DebugCurve(100, 0.5, "brown", c)));
    //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    //         }
    //         DebugCurve DebugSweepLine(RealNumberSpan range) {
    //             var ls = new LineSegment(Z * SweepDirection + DirectionPerp * range.Min, Z * SweepDirection + DirectionPerp * range.Max);
    //             return new DebugCurve(100, 0.1, "magenta", ls);
    //         }
    // #endif
    AddConeAndEnqueueEvents(vertexEvent) {
        if (vertexEvent instanceof _LeftVertexEvent__WEBPACK_IMPORTED_MODULE_17__.LeftVertexEvent) {
            const nextPoint = vertexEvent.Vertex.nextOnPolyline;
            this.CloseConesAddConeAtLeftVertex(vertexEvent, nextPoint);
        }
        else {
            if (vertexEvent instanceof _RightVertexEvent__WEBPACK_IMPORTED_MODULE_20__.RightVertexEvent) {
                const nextPoint = vertexEvent.Vertex.prevOnPolyline;
                this.CloseConesAddConeAtRightVertex(vertexEvent, nextPoint);
            }
            else {
                this.CloseConesAddConeAtLeftVertex(vertexEvent, vertexEvent.Vertex.nextOnPolyline);
                this.CloseConesAddConeAtRightVertex(vertexEvent, vertexEvent.Vertex.prevOnPolyline);
            }
        }
    }
    CloseConesAddConeAtRightVertex(rightVertexEvent, nextVertex) {
        const prevSite = rightVertexEvent.Vertex.nextOnPolyline.point;
        if (this.directionPerp.dot(rightVertexEvent.Site.sub(prevSite)) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            this.RemoveConesClosedBySegment(prevSite, rightVertexEvent.Vertex.point);
        }
        if (this.directionPerp.dot(nextVertex.point.sub(rightVertexEvent.Site)) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            this.RemoveConesClosedBySegment(rightVertexEvent.Site, nextVertex.point);
        }
        const site = rightVertexEvent.Site;
        const coneLp = site.add(this.ConeLeftSideDirection);
        const coneRp = site.add(this.ConeRightSideDirection);
        const nextSite = nextVertex.point;
        // SugiyamaLayoutSettings.Show(new LineSegment(site, coneLP), new LineSegment(site, coneRP), new LineSegment(site, nextSite));
        // try to remove the right side
        if (this.GetZP(site.sub(prevSite)) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            this.RemoveRightSide(new _RightObstacleSide__WEBPACK_IMPORTED_MODULE_19__.RightObstacleSide(rightVertexEvent.Vertex.nextOnPolyline));
        }
        if (this.GetZP(site.sub(nextVertex.point)) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            this.RemoveLeftSide(new _LeftObstacleSide__WEBPACK_IMPORTED_MODULE_16__.LeftObstacleSide(nextVertex));
        }
        if (this.GetZP(nextSite) + _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon < this.GetZS(rightVertexEvent)) {
            this.CreateConeOnVertex(rightVertexEvent);
        }
        if (!___WEBPACK_IMPORTED_MODULE_0__.Point.PointToTheRightOfLineOrOnLine(nextSite, site, coneLp)) {
            // if (angle <= -coneAngle / 2) {
            this.CreateConeOnVertex(rightVertexEvent);
            if (___WEBPACK_IMPORTED_MODULE_0__.Point.PointToTheLeftOfLineOrOnLine(nextSite.add(this.DirectionPerp), nextSite, site)) {
                this.EnqueueRightVertexEvent(new _RightVertexEvent__WEBPACK_IMPORTED_MODULE_20__.RightVertexEvent(nextVertex));
            }
            //  TryEnqueueRighVertexEvent(nextVertex);
        }
        else if (___WEBPACK_IMPORTED_MODULE_0__.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneRp)) {
            this.CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent, nextVertex);
        }
        else {
            if (this.GetZP(nextSite.sub(site)) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                this.LookForIntersectionOfObstacleSideAndLeftConeSide(rightVertexEvent.Site, nextVertex);
                this.InsertRightSide(new _RightObstacleSide__WEBPACK_IMPORTED_MODULE_19__.RightObstacleSide(rightVertexEvent.Vertex));
            }
            this.EnqueueRightVertexEvent(new _RightVertexEvent__WEBPACK_IMPORTED_MODULE_20__.RightVertexEvent(nextVertex));
        }
    }
    CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent, nextVertex) {
        this.EnqueueRightVertexEvent(new _RightVertexEvent__WEBPACK_IMPORTED_MODULE_20__.RightVertexEvent(nextVertex));
        // the obstacle side is inside of the cone
        // we need to create an obstacle left side segment instead of the left cone side
        const cone = new _Cone__WEBPACK_IMPORTED_MODULE_10__.Cone(rightVertexEvent.Vertex.point, this);
        const obstacleSideSeg = new _BrokenConeSide__WEBPACK_IMPORTED_MODULE_9__.BrokenConeSide(cone.Apex, nextVertex, new _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__.ConeLeftSide(cone));
        cone.LeftSide = obstacleSideSeg;
        cone.RightSide = new _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__.ConeRightSide(cone);
        const rnode = this.InsertToTree(this.rightConeSides, cone.RightSide);
        this.LookForIntersectionWithConeRightSide(rnode);
        const lnode = this.InsertToTree(this.leftConeSides, cone.LeftSide);
        this.FixConeLeftSideIntersections(obstacleSideSeg, lnode);
        if (this.GetZP(nextVertex.point.sub(rightVertexEvent.Site)) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            this.InsertRightSide(new _RightObstacleSide__WEBPACK_IMPORTED_MODULE_19__.RightObstacleSide(rightVertexEvent.Vertex));
        }
    }
    LookForIntersectionOfObstacleSideAndRightConeSide(obstacleSideStart, obstacleSideVertex) {
        const node = this.GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart);
        if (node != null) {
            if (node.item instanceof _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__.ConeRightSide) {
                const intersection = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(obstacleSideStart, obstacleSideVertex.point, node.item.Start, this.ConeRightSideDirection);
                if (intersection && this.SegmentIsNotHorizontal(intersection, obstacleSideVertex.point)) {
                    this.EnqueueEvent(this.CreateRightIntersectionEvent(node.item, intersection, obstacleSideVertex));
                }
            }
        }
    }
    CreateRightIntersectionEvent(coneRightSide, intersection, obstacleSideVertex) {
        // Assert.assert(
        //  Math.abs(this.GetZP(obstacleSideVertex.point.sub(intersection))) > 0,
        // )
        return new _RightIntersectionEvent__WEBPACK_IMPORTED_MODULE_18__.RightIntersectionEvent(coneRightSide, intersection, obstacleSideVertex);
    }
    GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart) {
        return this.rightConeSides.findLast((s) => LineSweeper.PointIsToTheRightOfSegment(obstacleSideStart, s));
    }
    LookForIntersectionOfObstacleSideAndLeftConeSide(obstacleSideStart, obstacleSideVertex) {
        const node = this.GetFirstNodeToTheRightOfPoint(obstacleSideStart);
        //          ShowLeftTree(Box(obstacleSideStart));
        if (node == null) {
            return;
        }
        if (!(node.item instanceof _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__.ConeLeftSide))
            return;
        const coneLeftSide = node.item;
        const intersection = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(obstacleSideStart, obstacleSideVertex.point, coneLeftSide.Start, this.ConeLeftSideDirection);
        if (intersection) {
            this.EnqueueEvent(new _LeftIntersectionEvent__WEBPACK_IMPORTED_MODULE_15__.LeftIntersectionEvent(coneLeftSide, intersection, obstacleSideVertex));
        }
    }
    GetFirstNodeToTheRightOfPoint(p) {
        return this.leftConeSides.findFirst((s) => LineSweeper.PointIsToTheLeftOfSegment(p, s));
    }
    static PointIsToTheLeftOfSegment(p, seg) {
        return ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(seg.Start, seg.Start.add(seg.Direction), p) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise;
    }
    static PointIsToTheRightOfSegment(p, seg) {
        return ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(seg.Start, seg.Start.add(seg.Direction), p) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Clockwise;
    }
    FixConeLeftSideIntersections(leftSide, rbNode) {
        // the first intersection can happen only with succesors of leftSide
        // Assert.assert(rbNode != null)
        do {
            // this loop usually works only once
            rbNode = this.leftConeSides.next(rbNode);
        } while (rbNode != null &&
            ___WEBPACK_IMPORTED_MODULE_0__.Point.PointToTheRightOfLineOrOnLine(leftSide.Start, rbNode.item.Start, rbNode.item.Start.add(rbNode.item.Direction)));
        if (rbNode != null) {
            if (rbNode.item instanceof _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__.ConeLeftSide) {
                const seg = rbNode.item;
                const intersection = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(leftSide.start, leftSide.End, seg.Start, seg.Direction);
                if (intersection) {
                    this.EnqueueEvent(new _LeftIntersectionEvent__WEBPACK_IMPORTED_MODULE_15__.LeftIntersectionEvent(seg, intersection, leftSide.EndVertex));
                }
            }
        }
    }
    InsertToTree(tree, coneSide) {
        //Assert.assert(this.GetZP(coneSide.Direction) > 0)
        this.coneSideComparer.SetOperand(coneSide);
        return tree.insert(coneSide);
    }
    CloseConesAddConeAtLeftVertex(leftVertexEvent, nextVertex) {
        // close segments first
        const prevSite = leftVertexEvent.Vertex.prevOnPolyline.point;
        if (leftVertexEvent.Site.sub(prevSite).dot(this.directionPerp) < -_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            // we have a low non-vertical side going to the left from prevSite to leftVertexEvent
            this.RemoveConesClosedBySegment(leftVertexEvent.Site, prevSite);
        }
        if (nextVertex.point.sub(leftVertexEvent.Site).dot(this.directionPerp) < -_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            this.RemoveConesClosedBySegment(nextVertex.point, leftVertexEvent.Site);
        }
        const site = leftVertexEvent.Site;
        const coneLp = site.add(this.ConeLeftSideDirection);
        const coneRp = site.add(this.ConeRightSideDirection);
        const nextSite = nextVertex.point;
        // SugiyamaLayoutSettings.Show(new LineSegment(site, coneLP), new LineSegment(site, coneRP), new LineSegment(site, nextSite));
        if (this.GetZP(site.sub(prevSite)) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            this.RemoveLeftSide(new _LeftObstacleSide__WEBPACK_IMPORTED_MODULE_16__.LeftObstacleSide(leftVertexEvent.Vertex.prevOnPolyline));
        }
        const nextDelZ = this.GetZP(nextSite) - this.Z;
        if (nextDelZ < -_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
            this.RemoveRightSide(new _RightObstacleSide__WEBPACK_IMPORTED_MODULE_19__.RightObstacleSide(nextVertex));
        }
        const toNext = nextSite.sub(leftVertexEvent.Site);
        if (nextDelZ < -_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon ||
            ((0,_utils_compare__WEBPACK_IMPORTED_MODULE_5__.closeDistEps)(nextDelZ, 0) && this.GetZP(toNext) > 0 && toNext.dot(this.directionPerp) > -_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon)) {
            // if (angle > Math.PI / 2)
            this.CreateConeOnVertex(leftVertexEvent); // it is the last left vertex on this obstacle
        }
        else if (!___WEBPACK_IMPORTED_MODULE_0__.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneRp)) {
            // if (angle >= coneAngle / 2) {
            this.CreateConeOnVertex(leftVertexEvent);
            this.EnqueueEvent(new _LeftVertexEvent__WEBPACK_IMPORTED_MODULE_17__.LeftVertexEvent(nextVertex));
            // we schedule LeftVertexEvent for a vertex with horizontal segment to the left on the top of the obstace
        }
        else if (!___WEBPACK_IMPORTED_MODULE_0__.Point.PointToTheLeftOfLineOrOnLine(nextSite, site, coneLp)) {
            // if (angle >= -coneAngle / 2) {
            // we cannot completely obscure the cone here
            this.EnqueueEvent(new _LeftVertexEvent__WEBPACK_IMPORTED_MODULE_17__.LeftVertexEvent(nextVertex));
            // the obstacle side is inside of the cone
            // we need to create an obstacle right side segment instead of the cone side
            const cone = new _Cone__WEBPACK_IMPORTED_MODULE_10__.Cone(leftVertexEvent.Vertex.point, this);
            const rightSide = new _BrokenConeSide__WEBPACK_IMPORTED_MODULE_9__.BrokenConeSide(leftVertexEvent.Vertex.point, nextVertex, new _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__.ConeRightSide(cone));
            cone.RightSide = rightSide;
            cone.LeftSide = new _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__.ConeLeftSide(cone);
            this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides, cone.LeftSide));
            const rbNode = this.InsertToTree(this.rightConeSides, rightSide);
            this.FixConeRightSideIntersections(rightSide, rbNode);
            if (this.GetZP(toNext) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                this.InsertLeftSide(new _LeftObstacleSide__WEBPACK_IMPORTED_MODULE_16__.LeftObstacleSide(leftVertexEvent.Vertex));
            }
        }
        else {
            this.EnqueueEvent(new _LeftVertexEvent__WEBPACK_IMPORTED_MODULE_17__.LeftVertexEvent(nextVertex));
            if (this.GetZP(toNext) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon) {
                // if( angle >- Pi/2
                // Assert.assert(angle > -Math.PI / 2);
                this.LookForIntersectionOfObstacleSideAndRightConeSide(leftVertexEvent.Site, nextVertex);
                this.InsertLeftSide(new _LeftObstacleSide__WEBPACK_IMPORTED_MODULE_16__.LeftObstacleSide(leftVertexEvent.Vertex));
            }
        }
    }
    RemoveCone(cone) {
        // the following should not happen if the containment hierarchy is correct.
        // If containment is not correct it still should not result in a fatal error, just a funny looking route.
        // Assert.assert(cone.Removed === false);
        cone.Removed = true;
        this.RemoveSegFromLeftTree(cone.LeftSide);
        this.RemoveSegFromRightTree(cone.RightSide);
    }
    RemoveSegFromRightTree(coneSide) {
        //   ShowRightTree();
        //Assert.assert(coneSide.Removed === false)
        this.coneSideComparer.SetOperand(coneSide);
        let b = this.rightConeSides.remove(coneSide);
        coneSide.Removed = true;
        if (b == null) {
            const tmpZ = this.Z;
            this.Z = Math.max(this.GetZP(coneSide.Start), this.Z - 0.01);
            // we need to return to the past a little bit when the order was still correc
            this.coneSideComparer.SetOperand(coneSide);
            b = this.rightConeSides.remove(coneSide);
            this.Z = tmpZ;
            // #if TEST_MSAGL
            //                 if (b == null ) {
            //                     PrintOutRightSegTree();
            //                 }
            // #endif
        }
    }
    RemoveSegFromLeftTree(coneSide) {
        //Assert.assert(coneSide.Removed === false)
        coneSide.Removed = true;
        this.coneSideComparer.SetOperand(coneSide);
        const b = this.leftConeSides.remove(coneSide);
        if (b == null) {
            const tmpZ = this.Z;
            this.Z = Math.max(this.GetZP(coneSide.Start), this.Z - 0.01);
            this.coneSideComparer.SetOperand(coneSide);
            // #if TEST_MSAGL
            //                 b =
            // #endif
            this.leftConeSides.remove(coneSide);
            this.Z = tmpZ;
            // #if TEST_MSAGL
            //                 if (b == null ) {
            //                     PrintOutLeftSegTree();
            //                     ShowLeftTree(new Ellipse(2, 2, coneSide.start));
            //                 }
            // #endif
        }
        //Assert.assert(b != null)
    }
    FixConeRightSideIntersections(rightSide, rbNode) {
        // the first intersection can happen only with predecessors of rightSide
        //Assert.assert(rbNode != null)
        do {
            // this loop usually works only once
            rbNode = this.rightConeSides.previous(rbNode);
        } while (rbNode != null &&
            ___WEBPACK_IMPORTED_MODULE_0__.Point.PointToTheLeftOfLineOrOnLine(rightSide.start, rbNode.item.Start, rbNode.item.Start.add(rbNode.item.Direction)));
        if (rbNode != null) {
            let intersection;
            if (rbNode.item instanceof _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__.ConeRightSide) {
                const seg = rbNode.item;
                if ((intersection = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(rightSide.start, rightSide.End, seg.Start, seg.Direction))) {
                    this.EnqueueEvent(this.CreateRightIntersectionEvent(seg, intersection, rightSide.EndVertex));
                    // Show(CurveFactory.CreateDiamond(3, 3, intersection));
                }
            }
        }
    }
    CreateConeOnVertex(sweepEvent) {
        const cone = new _Cone__WEBPACK_IMPORTED_MODULE_10__.Cone(sweepEvent.Site, this);
        cone.LeftSide = new _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__.ConeLeftSide(cone);
        cone.RightSide = new _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__.ConeRightSide(cone);
        const leftNode = this.InsertToTree(this.leftConeSides, cone.LeftSide);
        const rightNode = this.InsertToTree(this.rightConeSides, cone.RightSide);
        this.LookForIntersectionWithConeRightSide(rightNode);
        this.LookForIntersectionWithConeLeftSide(leftNode);
    }
    LookForIntersectionWithConeLeftSide(leftNode) {
        // Show(new Ellipse(1, 1, leftNode.item.start));
        if (leftNode.item instanceof _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__.ConeLeftSide) {
            const coneLeftSide = leftNode.item;
            const rightObstacleSide = this.FindFirstObstacleSideToTheLeftOfPoint(coneLeftSide.Start);
            if (rightObstacleSide != null) {
                this.TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide, rightObstacleSide);
            }
        }
        else {
            const seg = leftNode.item;
            leftNode = this.leftConeSides.next(leftNode);
            if (leftNode != null) {
                if (leftNode.item instanceof _ConeLeftSide__WEBPACK_IMPORTED_MODULE_12__.ConeLeftSide) {
                    this.TryIntersectionOfConeLeftSideAndObstacleConeSide(leftNode.item, seg);
                }
            }
        }
    }
    LookForIntersectionWithConeRightSide(rightNode) {
        // Show(new Ellipse(10, 5, rightNode.item.start));
        if (rightNode.item instanceof _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__.ConeRightSide) {
            const crs = rightNode.item;
            const leftObstacleSide = this.FindFirstObstacleSideToToTheRightOfPoint(crs.Start);
            if (leftObstacleSide != null) {
                this.TryIntersectionOfConeRightSideAndObstacleSide(crs, leftObstacleSide);
            }
        }
        else {
            const seg = rightNode.item;
            rightNode = this.rightConeSides.previous(rightNode);
            if (rightNode != null) {
                if (rightNode.item instanceof _ConeRightSide__WEBPACK_IMPORTED_MODULE_13__.ConeRightSide) {
                    this.TryIntersectionOfConeRightSideAndObstacleConeSide(rightNode.item, seg);
                }
            }
        }
    }
    TryIntersectionOfConeRightSideAndObstacleConeSide(coneRightSide, seg) {
        const x = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(seg.start, seg.End, coneRightSide.Start, coneRightSide.Direction);
        if (x) {
            this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, x, seg.EndVertex));
            // Show(CurveFactory.CreateDiamond(3, 3, x));
        }
    }
    TryIntersectionOfConeRightSideAndObstacleSide(coneRightSide, side) {
        const x = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(side.Start, side.End, coneRightSide.Start, coneRightSide.Direction);
        if (x) {
            this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide, x, side.EndVertex));
            // Show(CurveFactory.CreateDiamond(3, 3, x));
        }
    }
    TryIntersectionOfConeLeftSideAndObstacleConeSide(coneLeftSide, seg) {
        const x = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(seg.start, seg.End, coneLeftSide.Start, coneLeftSide.Direction);
        if (x) {
            this.EnqueueEvent(new _LeftIntersectionEvent__WEBPACK_IMPORTED_MODULE_15__.LeftIntersectionEvent(coneLeftSide, x, seg.EndVertex));
            // Show(CurveFactory.CreateDiamond(3, 3, x));
        }
    }
    TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide, side) {
        const x = ___WEBPACK_IMPORTED_MODULE_0__.Point.IntervalIntersectsRay(side.Start, side.End, coneLeftSide.Start, coneLeftSide.Direction);
        if (x) {
            this.EnqueueEvent(new _LeftIntersectionEvent__WEBPACK_IMPORTED_MODULE_15__.LeftIntersectionEvent(coneLeftSide, x, side.EndVertex));
            //    Show(CurveFactory.CreateDiamond(3, 3, x));
        }
    }
    // Show(curves: ICurve[], fn: string) {
    //   let l = Array.from(this.Obstacles).map((o) => DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Blue', o))
    //   for (const s of this.rightConeSides) {
    //     l.push(DebugCurve.mkDebugCurveWCI(0.5, 'Brown', this.ExtendSegmentToZ(s)))
    //     if (s instanceof BrokenConeSide) l.push(DebugCurve.mkDebugCurveCI('Brown', LineSweeper.Diamond(s.start)))
    //     l.push(DebugCurve.mkDebugCurveWCI(0.5, 'Green', this.ExtendSegmentToZ(s.Cone.LeftSide)))
    //     if (s.Cone.LeftSide instanceof BrokenConeSide) l.push(DebugCurve.mkDebugCurveCI('Green', LineSweeper.Diamond(s.Cone.LeftSide.start)))
    //   }
    //   l.push(
    //     ...Array.from(this.visibilityGraph.Edges).map((edge) =>
    //       DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Cyan', LineSegment.mkPP(edge.SourcePoint, edge.TargetPoint)),
    //     ),
    //   )
    //   l.push(...curves.map((c) => DebugCurve.mkDebugCurveCI('Red', c)))
    //   l.push(
    //     ...Array.from(this.eventQueue)
    //       .filter((e) => e instanceof RightIntersectionEvent)
    //       .map((e) => DebugCurve.mkDebugCurveCI('Black', LineSweeper.mkRightIntersDiamond(e.Site))),
    //   )
    //   SvgDebugWriter.dumpDebugCurves(fn, l)
    // }
    //         static BezierSeg BezierOnEdge(VisibilityEdge edge) {
    //             return new BezierSeg(edge.SourcePoint, 2.0 / 3.0 * edge.SourcePoint + 1.0 / 3.0 * edge.TargetPoint,
    //                 1.0 / 3.0 * edge.SourcePoint + 2.0 / 3.0 * edge.TargetPoint, edge.TargetPoint);
    //         }
    ExtendSegmentToZ(segment) {
        const den = segment.Direction.dot(this.SweepDirection);
        //Assert.assert(Math.Abs(den) > GeomConstants.distanceEpsilon);
        const t = (this.Z + 40 - segment.Start.dot(this.SweepDirection)) / den;
        return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.LineSegment.mkPP(segment.Start, segment.Start.add(segment.Direction.mul(t)));
    }
    //         internal ICurve ExtendSegmentToZPlus1(ConeSide segment) {
    //             double den = segment.Direction * SweepDirection;
    //             Assert.assert(Math.Abs(den) > GeomConstants.distanceEpsilon);
    //             double t = (Z + 1 - segment.start * SweepDirection) / den;
    //             return new LineSegment(segment.start, segment.start + segment.Direction * t);
    //         }
    // #endif
    GoOverConesSeeingVertexEvent(vertexEvent) {
        let rbNode = this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent);
        if (rbNode == null) {
            return;
        }
        const coneRightSide = rbNode.item;
        const cone = coneRightSide.Cone;
        const leftConeSide = cone.LeftSide;
        if (LineSweeper.VertexIsToTheLeftOfSegment(vertexEvent, leftConeSide)) {
            return;
        }
        const visibleCones = [cone];
        this.coneSideComparer.SetOperand(leftConeSide);
        rbNode = this.leftConeSides.find(leftConeSide);
        if (rbNode == null) {
            //this.Show([CurveFactory.CreateDiamond(10, 10, vertexEvent.Site)], './tmp/bug.svg')
            const tmpZ = this.Z;
            this.Z = Math.max(this.GetZP(leftConeSide.Start), this.PreviousZ);
            // we need to return to the past a little bit when the order was still correct
            this.coneSideComparer.SetOperand(leftConeSide);
            rbNode = this.leftConeSides.find(leftConeSide);
            this.Z = tmpZ;
            // #if TEST_MSAGL
            // //                if (rbNode == null ) {
            //                     //GeometryGraph gg = CreateGraphFromObstacles();
            //                     //gg.Save("c:\\tmp\\bug");
            // //                    PrintOutLeftSegTree();
            // //                    System.Diagnostics.Debug.WriteLine(leftConeSide);
            // //                    ShowLeftTree(new Ellipse(3, 3, vertexEvent.Site));
            // //                    ShowRightTree(new Ellipse(3, 3, vertexEvent.Site));
            // //                }
            // #endif
        }
        // the following should not happen if the containment hierarchy is correct.
        // If containment is not correct it still should not result in a fatal error, just a funny looking route.
        // Assert.assert(rbNode!=null);
        if (rbNode == null) {
            // it is an emergency measure and should not happen
            rbNode = this.GetRbNodeEmergency(leftConeSide);
            if (rbNode == null) {
                return; // the cone is not there! and it is a bug
            }
        }
        rbNode = this.leftConeSides.next(rbNode);
        while (rbNode != null && !LineSweeper.VertexIsToTheLeftOfSegment(vertexEvent, rbNode.item)) {
            visibleCones.push(rbNode.item.Cone);
            rbNode = this.leftConeSides.next(rbNode);
        }
        for (const visCone of visibleCones)
            this.AddEdgeAndRemoveCone(visCone, vertexEvent.Site);
    }
    GetRbNodeEmergency(leftConeSide) {
        if (this.leftConeSides.count === 0)
            return null;
        for (let node = this.leftConeSides.treeMinimum(); node != null; node = this.leftConeSides.next(node)) {
            if (node.item === leftConeSide) {
                return node;
            }
        }
        return null;
    }
    // #if TEST_MSAGL
    //             MessageId = "System.Int32.ToString")]
    //         internal static GeometryGraph CreateGraphFromObstacles(Array < Polyline > obstacles) {
    //             var gg = new GeometryGraph();
    //             foreach(var ob of obstacles) {
    //                 gg.Nodes.Add(new Node(ob.ToCurve()));
    //             }
    //             return gg;
    //         }
    //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
    //         )]
    //         void PrintOutLeftSegTree() {
    //             System.Diagnostics.Debug.WriteLine("Left cone segments########");
    //             foreach(var t of leftConeSides) {
    //                 var x = coneSideComparer.IntersectionOfSegmentAndSweepLine(t);
    //                 System.Diagnostics.Debug.WriteLine("{0} x={1}", t, x * DirectionPerp);
    //             }
    //             System.Diagnostics.Debug.WriteLine("##########end of left cone segments");
    //         }
    // #endif
    static VertexIsToTheLeftOfSegment(vertexEvent, seg) {
        return ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(seg.Start, seg.Start.add(seg.Direction), vertexEvent.Site) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise;
    }
    static VertexIsToTheRightOfSegment(vertexEvent, seg) {
        return ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(seg.Start, seg.Start.add(seg.Direction), vertexEvent.Site) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Clockwise;
    }
    FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent) {
        return this.rightConeSides.findFirst((s) => !LineSweeper.VertexIsToTheRightOfSegment(vertexEvent, s));
    }
    EnqueueRightVertexEvent(vertexEvent) {
        if (this.GetZP(vertexEvent.Site.sub(vertexEvent.Vertex.prevOnPolyline.point)) > _math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
            // otherwise we enqueue the vertex twice; once as a LeftVertexEvent and once as a RightVertexEvent
            return;
        }
        this.EnqueueEvent(vertexEvent);
    }
    invariant() {
        // if (this.leftConeSides.count !== this.rightConeSides.count) {
        //  return false
        // }
        for (const cs of this.leftConeSides) {
            if (cs.Removed) {
                return false;
            }
        }
        for (const cs of this.rightConeSides) {
            if (cs.Removed) {
                return false;
            }
        }
        // const lsSet = new Set<ConeSide>(this.leftConeSides)
        // const rsSet = new Set<ConeSide>(this.rightConeSides)
        // if (lsSet.size !== rsSet.size) return false
        // const cones = new Set<Cone>()
        // for (const ls of lsSet) {
        //  const cone = ls.Cone
        //  if (!rsSet.has(cone.RightSide)) return false
        //  cones.add(cone)
        // }
        // if (cones.size !== lsSet.size) return false
        // for (const rs of rsSet) {
        //  if (!cones.has(rs.Cone)) {
        //    return false
        //  }
        // }
        // for (const ls of lsSet) {
        //  if (!cones.has(ls.Cone)) {
        //    return false
        //  }
        // }
        return true;
    }
}
//# sourceMappingURL=LineSweeper.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LowestVertexEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LowestVertexEvent: () => (/* binding */ LowestVertexEvent)
/* harmony export */ });
/* harmony import */ var _VertexEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/VertexEvent.js");

class LowestVertexEvent extends _VertexEvent__WEBPACK_IMPORTED_MODULE_0__.VertexEvent {
    constructor(p) {
        super(p);
    }
}
//# sourceMappingURL=LowestVertexEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ObstacleSide.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObstacleSide: () => (/* binding */ ObstacleSide)
/* harmony export */ });
/* harmony import */ var _visibility_SegmentBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/SegmentBase.js");

class ObstacleSide extends _visibility_SegmentBase__WEBPACK_IMPORTED_MODULE_0__.SegmentBase {
    Init(sv) {
        this.StartVertex = sv;
    }
    constructor(startVertex) {
        super();
        this.Init(startVertex);
    }
    get Polyline() {
        return this.StartVertex.polyline;
    }
    get Start() {
        return this.StartVertex.point;
    }
    get End() {
        return this.EndVertex.point;
    }
}
//# sourceMappingURL=ObstacleSide.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightIntersectionEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RightIntersectionEvent: () => (/* binding */ RightIntersectionEvent)
/* harmony export */ });
/* harmony import */ var _SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");

// right here means an intersection of a right cone side with an obstacle edge
class RightIntersectionEvent extends _SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    get EndVertex() {
        return this.endVertex;
    }
    set EndVertex(value) {
        this.endVertex = value;
    }
    constructor(coneRightSide, intersectionPoint, endVertex) {
        super();
        this.coneRightSide = coneRightSide;
        this.intersectionPoint = intersectionPoint;
        this.endVertex = endVertex;
    }
    get Site() {
        return this.intersectionPoint;
    }
    toString() {
        return 'RightIntersectionEvent ' + this.intersectionPoint;
    }
}
//# sourceMappingURL=RightIntersectionEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightObstacleSide.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RightObstacleSide: () => (/* binding */ RightObstacleSide)
/* harmony export */ });
/* harmony import */ var _ObstacleSide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/ObstacleSide.js");

class RightObstacleSide extends _ObstacleSide__WEBPACK_IMPORTED_MODULE_0__.ObstacleSide {
    constructor(startVertex) {
        super(startVertex);
        this.end = startVertex.prevOnPolyline.point;
    }
    get End() {
        return this.end;
    }
    get EndVertex() {
        return this.StartVertex.prevOnPolyline;
    }
}
//# sourceMappingURL=RightObstacleSide.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/RightVertexEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RightVertexEvent: () => (/* binding */ RightVertexEvent)
/* harmony export */ });
/* harmony import */ var _VertexEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/VertexEvent.js");

class RightVertexEvent extends _VertexEvent__WEBPACK_IMPORTED_MODULE_0__.VertexEvent {
    constructor(p) {
        super(p);
    }
}
//# sourceMappingURL=RightVertexEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SweepEvent: () => (/* binding */ SweepEvent)
/* harmony export */ });
class SweepEvent {
}
//# sourceMappingURL=SweepEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/coneSpanner/VertexEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VertexEvent: () => (/* binding */ VertexEvent)
/* harmony export */ });
/* harmony import */ var _SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");

class VertexEvent extends _SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    get Site() {
        return this.Vertex.point;
    }
    constructor(p) {
        super();
        this.Vertex = p;
    }
    get Polyline() {
        return this.Vertex.polyline;
    }
}
//# sourceMappingURL=VertexEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/spline/pathOptimizer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PathOptimizer: () => (/* binding */ PathOptimizer)
/* harmony export */ });
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/ConstrainedDelaunayTriangulation/Cdt.js");




//import {SvgDebugWriter} from '../../../test/utils/svgDebugWriter'
//import {DebugCurve} from '../../math/geometry/debugCurve'
/** Optimize path locally, without changing its topology.
 * The obstacles are represented by constrained edges of cdd, the Delaunay triangulation.
 * It is not assumed that the polyline passes only through the sites of the cdt.
//  */
let debCount = 0;
let drawCount = 0;
class PathOptimizer {
    constructor() {
        this.triangles = new Set();
        // threader region
    }
    setCdt(cdt) {
        this.cdt = cdt;
        this.cdt.SetInEdges();
        const polys = new Set();
        for (const t of cdt.GetTriangles()) {
            for (const s of t.Sites) {
                if (s.Owner != null)
                    polys.add(s.Owner);
            }
        }
    }
    outsideOfObstacles(t) {
        var _a;
        if (t == null)
            return false;
        const owner = (_a = t.Sites.item0.Owner) !== null && _a !== void 0 ? _a : t.Sites.item1.Owner;
        return owner === this.sourcePoly || owner === this.targetPoly || !triangleIsInsideOfObstacle(t);
    }
    /** following "https://page.mi.fu-berlin.de/mulzer/notes/alggeo/polySP.pdf" */
    run(poly) {
        // console.log('debCount=', ++debCount)
        this.triangles.clear();
        this.poly = poly;
        this.d = [];
        if (poly.count <= 2 || this.cdt == null)
            return;
        this.sourcePoly = this.findPoly(poly.start);
        this.targetPoly = this.findPoly(poly.end);
        // if (debCount == 132) {
        //   this.debugDraw(Array.from(this.cdt.GetTriangles()), null, null, poly)
        // }
        this.findChannelTriangles();
        // if (debCount == 132) this.debugDraw(Array.from(this.triangles), null, null, poly)
        let perimeter = this.getPerimeterEdges();
        perimeter = this.fillTheCollapedSites(perimeter);
        // if (debCount == 132) {
        //   this.debugDraw(Array.from(this.cdt.GetTriangles()), perimeter, null, this.poly)
        // }
        const localCdt = new _ConstrainedDelaunayTriangulation_Cdt__WEBPACK_IMPORTED_MODULE_3__.Cdt([], [], Array.from(perimeter).map((e) => {
            return { A: e.lowerSite.point, B: e.upperSite.point };
        }));
        localCdt.run();
        // if (debCount == 132) {
        //   this.debugDraw(Array.from(localCdt.GetTriangles()), null, null, poly)
        // }
        const sleeve = this.getSleeve(this.findSourceTriangle(localCdt));
        if (sleeve == null) {
            // this.poly remains unchanged in this case
            // in one case the original polyline was crossing a wrong obstacle and it caused the peremiter polyline
            // not having the end inside
            console.log('failed to create sleeve');
            return;
        }
        if (sleeve.length == 0) {
            this.poly = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Polyline.mkFromPoints([poly.start, poly.end]);
            return;
        }
        this.initDiagonals(sleeve);
        this.refineFunnel();
    }
    /**A function that returns an array of all crossed triangles
     * by a line segment from start to end
     * assuming the initial triangle contains the start point*/
    getAllCrossedTriangles(t, start, end) {
        // Initialize an empty array to store the crossed triangles
        let crossed = [];
        // Initialize a queue to store the triangles to visit
        let queue = [];
        let containsEnd = null;
        // Add the initial triangle to the queue
        queue.push(t);
        // Loop until the queue is empty
        while (queue.length > 0) {
            // Dequeue a triangle from the queue
            let current = queue.pop();
            if (containsEnd == null && current.containsPoint(end)) {
                containsEnd = current;
            }
            // Check if the triangle intersects the line segment
            if (current.intersectsLine(start, end, 0)) {
                // Add the triangle to the crossed array
                crossed.push(current);
                // Loop through the neighbors of the triangle
                for (const e of current.Edges) {
                    // Check if the neighbor exists and is not already in the crossed array or the queue
                    const tr = e.GetOtherTriangle_T(current);
                    if (tr && !crossed.includes(tr) && !queue.includes(tr)) {
                        // Add the neighbor to the queue
                        queue.push(tr);
                    }
                }
            }
        }
        // Return the crossed array
        return { triangles: crossed, containsEnd: containsEnd };
    }
    findChannelTriangles() {
        const site = this.cdt.FindSite(this.poly.start);
        let t = site.Triangles().next().value;
        this.triangles.clear();
        for (let p = this.poly.startPoint; p.next != null; p = p.next) {
            const res = this.getAllCrossedTriangles(t, p.point, p.next.point);
            t = res.containsEnd;
            for (const tr of res.triangles) {
                if (this.outsideOfObstacles(tr))
                    this.triangles.add(tr);
            }
        }
    }
    findPoly(p) {
        var _a;
        const site = this.cdt.FindSite(p);
        for (const edge of site.Edges) {
            const poly = (_a = edge.lowerSite.Owner) !== null && _a !== void 0 ? _a : edge.upperSite.Owner;
            return poly;
        }
    }
    /** Because of the floating point operations we might miss some triangles and get a polygon collapsing to a point somewhere inside of the polyline.
     * This point will correspond to a site adjacent to more than two edges from 'perimeter'.
     * We add to the polygon all the 'legal' triangles adjacent to this cite.
     */
    fillTheCollapedSites(perimeter) {
        const siteToEdges = new Map();
        for (const e of perimeter) {
            addEdgeToMap(e.lowerSite, e);
            addEdgeToMap(e.upperSite, e);
        }
        const sitesToFix = [];
        for (const [site, es] of siteToEdges) {
            if (es.length > 2) {
                sitesToFix.push(site);
            }
        }
        if (sitesToFix.length == 0)
            return perimeter;
        for (const s of sitesToFix) {
            for (const t of s.Triangles()) {
                if (this.outsideOfObstacles(t)) {
                    this.triangles.add(t);
                }
            }
        }
        return this.getPerimeterEdges();
        function addEdgeToMap(site, e) {
            let es = siteToEdges.get(site);
            if (es == null) {
                siteToEdges.set(site, (es = []));
            }
            es.push(e);
        }
    }
    findSourceTriangle(localCdt) {
        let sourceTriangle;
        for (const t of localCdt.GetTriangles()) {
            if (t.containsPoint(this.poly.start)) {
                sourceTriangle = t;
                break;
            }
        }
        return sourceTriangle;
    }
    // debugDraw(triangles: Tr[], perimEdges: Set<Ed>, poly: Polyline, originalPoly: Polyline, strangeObs: ICurve[] = [], ls: ICurve = null) {
    //   const dc = []
    //   if (ls) {
    //     dc.push(DebugCurve.mkDebugCurveTWCI(255, 5, 'PapayaWhip', ls))
    //   }
    //   const box = this.poly.boundingBox.clone()
    //   box.addRec(this.sourcePoly.boundingBox)
    //   box.addRec(this.targetPoly.boundingBox)
    //   for (const t of triangles) {
    //     // if (t.BoundingBox().intersects(box) == false) continue
    //     for (const e of t.Edges) {
    //       dc.push(
    //         DebugCurve.mkDebugCurveTWCI(
    //           e.constrained ? 150 : 100,
    //           e.constrained ? 1.5 : 1,
    //           e.constrained ? 'DarkSeaGreen' : 'Cyan',
    //           LineSegment.mkPP(e.upperSite.point, e.lowerSite.point),
    //         ),
    //       )
    //     }
    //   }
    //   if (perimEdges) {
    //     for (const e of perimEdges) {
    //       dc.push(DebugCurve.mkDebugCurveTWCI(200, 2.5, 'Blue', LineSegment.mkPP(e.lowerSite.point, e.upperSite.point)))
    //     }
    //   }
    //   if (poly) dc.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Green', poly))
    //   for (const strangeOb of strangeObs) {
    //     dc.push(DebugCurve.mkDebugCurveTWCI(200, 3, 'Pink', strangeOb))
    //   }
    //   if (originalPoly) dc.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Brown', originalPoly))
    //   dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Violet', this.sourcePoly))
    //   dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Magenta', this.targetPoly))
    //   SvgDebugWriter.dumpDebugCurves('./tmp/poly' + ++drawCount + '.svg', dc)
    // }
    refineFunnel( /*dc: Array<DebugCurve>*/) {
        // remove param later:Debug
        const prefix = []; // the path befor apex
        let v = this.poly.start; // the apex point
        const leftChainStart = { point: v };
        const rightChainStart = { point: v };
        let leftChainEnd = { point: this.d[0].left, prev: leftChainStart };
        let rightChainEnd = { point: this.d[0].right, prev: rightChainStart };
        leftChainStart.next = leftChainEnd;
        rightChainStart.next = rightChainEnd;
        let z;
        for (let i = 1; i < this.d.length; i++) {
            processDiagonal(i, this.d);
        }
        // the shortest path will be on the right chain
        this.d.push({ right: this.poly.end, left: leftChainEnd.point });
        processDiagonal(this.d.length - 1, this.d);
        const newPoly = _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Polyline.mkFromPoints(prefix);
        for (let p = rightChainStart; p != null; p = p.next) {
            newPoly.addPoint(p.point);
        }
        this.poly = newPoly;
        function processDiagonal(i, d) {
            const leftStep = d[i - 1].left !== d[i].left;
            // Assert.assert(!leftStep || d[i - 1].left.equal(d[i].left) == false)
            // Assert.assert(leftStep || d[i - 1].right !== d[i].right)
            if (leftStep) {
                z = d[i].left;
                //draw(d[i - 1], d[i], dc)
                let p = leftChainEnd;
                for (; !(isApex(p) || reflexLeft(p)); p = p.prev) {
                    // just stepping back on the left chain
                }
                if (isApex(p)) {
                    walkForwardOnTheRigthUntilSeeZ();
                }
                else {
                    extendLeftChainFromP(p);
                }
            }
            else {
                // right step: the diagonal advanced on the right chain
                z = d[i].right;
                let p = rightChainEnd;
                for (; !(isApex(p) || reflexRight(p)); p = p.prev) {
                    // just stepping back on the right chain
                }
                if (isApex(p)) {
                    walkForwardOnTheLeftUntilSeeZ();
                }
                else {
                    extendRightChainFromP(p);
                }
            }
            //draw(d[i - 1], d[i], dc)
        }
        // function draw(d: Diagonal, dn: Diagonal, dc: DebugCurve[]) {
        //   if (debCount < 1000000) return
        //   const ldc = dc.map((d) => d.clone())
        //   ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'Yellow', LineSegment.mkPP(d.left, d.right)))
        //   ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'cyan', LineSegment.mkPP(dn.left, dn.right)))
        //   for (let l: PathPoint = leftChainStart; l && l.next; l = l.next) {
        //     ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'Magenta', LineSegment.mkPP(l.point, l.next.point)))
        //   }
        //   for (let r: PathPoint = rightChainStart; r && r.next; r = r.next) {
        //     ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'Navy', LineSegment.mkPP(r.point, r.next.point)))
        //   }
        //   ldc.push(DebugCurve.mkDebugCurveTWCI(100, 3, 'red', CurveFactory.mkCircle(3, v)))
        //   if (prefix.length) {
        //     for (let i = 0; i < prefix.length - 1; i++) {
        //       ldc.push(DebugCurve.mkDebugCurveTWCI(200, 3, 'Black', LineSegment.mkPP(prefix[i], prefix[i + 1])))
        //     }
        //     ldc.push(DebugCurve.mkDebugCurveTWCI(200, 3, 'Black', LineSegment.mkPP(prefix[prefix.length - 1], v)))
        //   }
        //   //SvgDebugWriter.dumpDebugCurves('/tmp/dc_' + ++debCount + '.svg', ldc)
        // }
        function visibleRight(pp) {
            if (pp.next == null) {
                return true;
            }
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.pointToTheLeftOfLineOrOnLine(z, pp.point, pp.next.point);
        }
        function visibleLeft(pp) {
            if (pp.next == null) {
                return true;
            }
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.pointToTheRightOfLineOrOnLine(z, pp.point, pp.next.point);
        }
        function reflexLeft(pp) {
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.pointToTheLeftOfLine(z, pp.prev.point, pp.point);
        }
        function reflexRight(pp) {
            return _math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.pointToTheRightOfLine(z, pp.prev.point, pp.point);
        }
        function walkForwardOnTheRigthUntilSeeZ() {
            let p = rightChainStart;
            while (!visibleRight(p)) {
                p = p.next;
            }
            if (!isApex(p)) {
                // got the new apex in p
                let r = rightChainStart;
                for (; !r.point.equal(p.point); r = r.next) {
                    prefix.push(r.point);
                }
                rightChainStart.point = r.point;
                rightChainStart.next = r.next; // need to keep rightChainStart and rightChainEnd different while r might be rightChainEnd here
                v = r.point;
                if (rightChainEnd.point.equal(rightChainStart.point)) {
                    rightChainEnd.prev = rightChainEnd.next = null;
                }
            }
            leftChainStart.point = v;
            leftChainEnd.point = z;
            leftChainEnd.prev = leftChainStart;
            leftChainStart.next = leftChainEnd;
        }
        function walkForwardOnTheLeftUntilSeeZ() {
            let p = leftChainStart;
            while (!visibleLeft(p)) {
                p = p.next;
            }
            if (!isApex(p)) {
                // got the new apex at p
                let r = leftChainStart;
                for (; !r.point.equal(p.point); r = r.next) {
                    prefix.push(r.point);
                }
                leftChainStart.point = r.point; //  need to keep leftChainStart and leftChainEnd different while r might be leftChainEnd here
                leftChainStart.next = r.next;
                v = r.point;
                if (leftChainEnd.point.equal(leftChainStart.point)) {
                    leftChainEnd.prev = leftChainStart.next = null;
                }
            }
            rightChainStart.point = v;
            rightChainEnd.point = z;
            rightChainEnd.prev = rightChainStart;
            rightChainStart.next = rightChainEnd;
        }
        function isApex(pp) {
            const ret = pp.point == v;
            //Assert.assert(ret || !pp.point.equal(v))
            return ret;
        }
        function extendRightChainFromP(p) {
            if (p != rightChainEnd) {
                rightChainEnd.point = z;
                rightChainEnd.prev = p;
                p.next = rightChainEnd;
            }
            else {
                rightChainEnd = { point: z, prev: p };
                p.next = rightChainEnd;
            }
        }
        function extendLeftChainFromP(p) {
            if (p != leftChainEnd) {
                leftChainEnd.point = z;
                leftChainEnd.prev = p;
                p.next = leftChainEnd;
            }
            else {
                leftChainEnd = { point: z, prev: p };
                p.next = leftChainEnd;
            }
        }
    }
    initDiagonals(sleeve) {
        for (const sleeveEdge of sleeve) {
            const e = sleeveEdge.edge;
            const site = sleeveEdge.source.OppositeSite(e);
            if (_math_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientation(site.point, e.lowerSite.point, e.upperSite.point) == _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise) {
                this.d.push({ left: e.upperSite.point, right: e.lowerSite.point });
            }
            else {
                this.d.push({ right: e.upperSite.point, left: e.lowerSite.point });
            }
        }
    }
    getSleeve(sourceTriangle) {
        const q = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
        //Assert.assert(sourceTriangle != null)
        q.enqueue(sourceTriangle);
        // Assert.assert(sourceTriangle != null)
        const edgeMap = new Map();
        edgeMap.set(sourceTriangle, undefined);
        while (q.length > 0) {
            const t = q.dequeue();
            const edgeIntoT = edgeMap.get(t);
            if (t.containsPoint(this.poly.end)) {
                return this.recoverPath(sourceTriangle, edgeMap, t);
            }
            for (const e of t.Edges) {
                if (e.constrained)
                    continue; // do not leave the polygon:
                // we walk a dual graph of a triangulation of a polygon:
                // it is not always a simple polygon, but usually it is
                if (edgeIntoT !== undefined && e === edgeIntoT)
                    continue;
                const ot = e.GetOtherTriangle_T(t);
                if (ot == null)
                    continue;
                if (edgeMap.has(ot))
                    continue;
                edgeMap.set(ot, e);
                q.enqueue(ot);
            }
        }
    }
    recoverPath(sourceTriangle, edgeMap, t) {
        const ret = [];
        for (let tr = t; tr != sourceTriangle;) {
            if (tr === sourceTriangle)
                break;
            const e = edgeMap.get(tr);
            tr = e.GetOtherTriangle_T(tr);
            ret.push({ source: tr, edge: e });
        }
        return ret.reverse();
    }
    getPerimeterEdges() {
        const perimeter = new Set();
        for (const t of this.triangles) {
            for (const e of t.Edges) {
                if (!this.triangles.has(e.GetOtherTriangle_T(t))) {
                    perimeter.add(e);
                }
            }
        }
        return perimeter;
    }
}
function triangleIsInsideOfObstacle(t) {
    if (t.Sites.item0.Owner == null || t.Sites.item1.Owner == null || t.Sites.item2.Owner == null) {
        return true; // one of the sites corresponds to a Port
    }
    return t.Sites.item0.Owner == t.Sites.item1.Owner && t.Sites.item0.Owner == t.Sites.item2.Owner;
}
//# sourceMappingURL=pathOptimizer.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/ActiveDiagonalComparerWithRay.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActiveDiagonalComparerWithRay: () => (/* binding */ ActiveDiagonalComparerWithRay)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry_linearSystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/linearSystem.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");



class ActiveDiagonalComparerWithRay {
    get PointOnTangentAndInsertedDiagonal() {
        return this.pointOnTheRay;
    }
    set PointOnTangentAndInsertedDiagonal(value) {
        this.pointOnTheRay = value;
    }
    Compare(x, y) {
        // Assert.assert(ActiveDiagonalComparerWithRay.BelongsToTheDiagonal(this.PointOnTangentAndInsertedDiagonal, x.Start, x.End))
        if (!x.Start.equal(y.Start)) {
            switch (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.PointOnTangentAndInsertedDiagonal, y.Start, y.End)) {
                case _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise:
                    return -1;
                default:
                    return 1;
            }
        }
        else {
            return 0;
        }
    }
    static BelongsToTheDiagonal(IntersectionOfTheRayAndInsertedEdge, start, end) {
        return ___WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(IntersectionOfTheRayAndInsertedEdge, ___WEBPACK_IMPORTED_MODULE_0__.Point.ClosestPointAtLineSegment(IntersectionOfTheRayAndInsertedEdge, start, end));
    }
    static IntersectDiagonalWithRay(pivot, pointOnRay, diagonal) {
        const ray = pointOnRay.sub(pivot);
        const source = diagonal.Start;
        const target = diagonal.End;
        // let x(t-s)+s is on the ray, then for some y we x(t-s)+s=y*ray+pivot, or x(t-s)-y*ray=pivot-s
        const result = _math_geometry_linearSystem__WEBPACK_IMPORTED_MODULE_1__.LinearSystem2.solve(target.x - source.x, ray.x * -1, pivot.x - source.x, target.y - source.y, ray.y * -1, pivot.y - source.y);
        // Assert.assert(result && -GeomConstants.tolerance <= result.x && result.x <= 1 + GeomConstants.tolerance)
        return pivot.add(ray.mul(result.y));
    }
}
//# sourceMappingURL=ActiveDiagonalComparerWithRay.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/ActiveEdgeComparerWithRay.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActiveEdgeComparerWithRay: () => (/* binding */ ActiveEdgeComparerWithRay)
/* harmony export */ });
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _math_geometry_linearSystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/linearSystem.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");



class ActiveEdgeComparerWithRay {
    get Pivot() {
        return this.pivot;
    }
    set Pivot(value) {
        this.pivot = value;
    }
    get IntersectionOfTheRayAndInsertedEdge() {
        return this.pointOnTheRay;
    }
    set IntersectionOfTheRayAndInsertedEdge(value) {
        this.pointOnTheRay = value;
    }
    Compare(x, y) {
        //Assert.assert(this.IntersectionPointBelongsToTheInsertedEdge(x))
        switch (_math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.Point.getTriangleOrientation(this.IntersectionOfTheRayAndInsertedEdge, y.point, y.nextOnPolyline.point)) {
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise:
                return -1;
            default:
                return 1;
        }
    }
    IntersectionPointBelongsToTheInsertedEdge(x) {
        const a = x.point.sub(this.IntersectionOfTheRayAndInsertedEdge);
        const b = x.nextOnPolyline.point.sub(this.IntersectionOfTheRayAndInsertedEdge);
        return Math.abs(a.x * b.y - b.x * a.y) < _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon;
    }
    IntersectEdgeWithRayPPP(source, target, ray) {
        //let x(t-s)+s is on the ray, then for some y we x(t-s)+s=y*ray+pivot, or x(t-s)-y*ray=pivot-s
        const result = _math_geometry_linearSystem__WEBPACK_IMPORTED_MODULE_1__.LinearSystem2.solve(target.x - source.x, -ray.x, this.Pivot.x - source.x, target.y - source.y, -ray.y, this.Pivot.y - source.y);
        if (!(-_math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance <= result.x && result.x <= 1 + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance))
            throw new Error();
        if (!result)
            throw new Error();
        return this.Pivot.add(ray.mul(result.y));
    }
    IntersectEdgeWithRay(side, ray) {
        return this.IntersectEdgeWithRayPPP(side.point, side.nextOnPolyline.point, ray);
    }
    static constructorPP(pivot, pointOnTheRay) {
        const r = new ActiveEdgeComparerWithRay();
        r.pivot = pivot;
        r.pointOnTheRay = pointOnTheRay;
        return r;
    }
}
//# sourceMappingURL=ActiveEdgeComparerWithRay.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/BimodalSequence.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BimodalSequence: () => (/* binding */ BimodalSequence)
/* harmony export */ });
/* harmony import */ var _UnimodalSequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/UnimodalSequence.js");

// following https://dl.acm.org/doi/pdf/10.1145/7531.24036?casa_token=eU7GWug-Y98AAAAA%3A4GZQqc2mZBx14I_lLJyQrp6JLhxvxyn9pDaVCAisU2KozgOCW5HbSVYviPBxgN0RWf8GCUshDaW5
// 'Intersection of Convex Objects in Two and Three Dimensions' by Chazelle, and Dobkin
// For our purposes, it suffices to define a bimodal function as
// one for which there is an r in [0, n-1] such that
// [f(r), f(r + 1), . . . , f(n), f( 1), . . . ,  f(r - 1)] is unimodal. In our case no three sequential elements have the same value
class BimodalSequence {
    toArray() {
        const r = [];
        for (let i = 0; i < this.length; i++)
            r.push(this.f(i));
        return r;
    }
    constructor(sequence, length) {
        this.f = sequence;
        this.length = length;
    }
    GetAdjustedSequenceForMinimum() {
        const leftVal = this.f(0);
        const rightVal = this.f(this.length - 1);
        const k = (rightVal - leftVal) / (this.length - 1);
        return (i) => Math.min(this.f(i), leftVal + k * i);
    }
    GetAdjustedSequenceForMaximum() {
        const leftVal = this.f(0);
        const rightVal = this.f(this.length - 1);
        const k = (rightVal - leftVal) / (this.length - 1);
        return (i) => Math.max(this.f(i), leftVal + k * i);
    }
    // following Chazelle, Dobkin
    FindMinimum() {
        if (this.f(0) === this.f(this.length - 1)) {
            //we have an unimodal function
            return new _UnimodalSequence__WEBPACK_IMPORTED_MODULE_0__.UnimodalSequence(this.f, this.length).FindMinimum();
        }
        return new _UnimodalSequence__WEBPACK_IMPORTED_MODULE_0__.UnimodalSequence(this.GetAdjustedSequenceForMinimum(), this.length).FindMinimum();
    }
    FindMaximum() {
        if (this.f(0) === this.f(this.length - 1)) {
            //we have an unimodal function
            return new _UnimodalSequence__WEBPACK_IMPORTED_MODULE_0__.UnimodalSequence(this.f, this.length).FindMaximum();
        }
        return new _UnimodalSequence__WEBPACK_IMPORTED_MODULE_0__.UnimodalSequence(this.GetAdjustedSequenceForMaximum(), this.length).FindMaximum();
    }
}
//# sourceMappingURL=BimodalSequence.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/Diagonal.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Diagonal: () => (/* binding */ Diagonal)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");

class Diagonal {
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0},{1}', this.Start, this.End);
    }
    get Start() {
        return this.leftTangent.End.point;
    }
    get End() {
        return this.rightTangent.End.point;
    }
    constructor(leftTangent, rightTangent) {
        this.LeftTangent = leftTangent;
        this.RightTangent = rightTangent;
    }
    get LeftTangent() {
        return this.leftTangent;
    }
    set LeftTangent(value) {
        this.leftTangent = value;
    }
    get RightTangent() {
        return this.rightTangent;
    }
    set RightTangent(value) {
        this.rightTangent = value;
    }
    get RbNode() {
        return this.rbNode;
    }
    set RbNode(value) {
        this.rbNode = value;
    }
}
//# sourceMappingURL=Diagonal.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/InteractiveTangentVisibilityGraphCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InteractiveTangentVisibilityGraphCalculator: () => (/* binding */ InteractiveTangentVisibilityGraphCalculator)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _TangentPair__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TangentPair.js");
/* harmony import */ var _VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js");
/* harmony import */ var _utils_algorithm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/algorithm.js");
/* harmony import */ var _Diagonal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/Diagonal.js");
/* harmony import */ var _Tangent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/Tangent.js");
/* harmony import */ var _ActiveDiagonalComparerWithRay__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/ActiveDiagonalComparerWithRay.js");
/* harmony import */ var _StemStartPointComparer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/StemStartPointComparer.js");










class InteractiveTangentVisibilityGraphCalculator extends _utils_algorithm__WEBPACK_IMPORTED_MODULE_5__.Algorithm {
    // we calculate tangents between activePolygons and between activePolygons and existingObsacles
    run() {
        this.useLeftPTangents = true;
        this.CalculateAndAddEdges();
        // use another family of tangents
        this.useLeftPTangents = false;
        this.CalculateAndAddEdges();
    }
    CalculateAndAddEdges() {
        for (const p of this.addedPolygons) {
            this.CalculateVisibleTangentsFromPolygon(p);
        }
        this.ProgressStep();
    }
    CalculateVisibleTangentsFromPolygon(polygon) {
        this.currentPolygon = polygon;
        this.AllocateDataStructures();
        this.OrganizeTangents();
        this.InitActiveDiagonals();
        this.Sweep();
    }
    AllocateDataStructures() {
        this.tangents = new Array();
        this.diagonals = new Array();
        this.activeDiagonalTree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_2__.RBTree(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer));
    }
    Sweep() {
        if (this.tangents.length < 2) {
            return;
        }
        for (let i = 1; i < this.tangents.length; i++) {
            // we processed the first element already
            const t = this.tangents[i];
            if (t.Diagonal != null) {
                if (t.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum()) {
                    this.AddVisibleEdge(t);
                }
                if (t.IsHigh) {
                    this.RemoveDiagonalFromActiveNodes(t.Diagonal);
                }
            }
            else if (t.IsLow) {
                this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = t.End.point;
                this.InsertActiveDiagonal(new _Diagonal__WEBPACK_IMPORTED_MODULE_6__.Diagonal(t, t.Comp));
                if (t.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum()) {
                    this.AddVisibleEdge(t);
                }
            }
        }
    }
    AddVisibleEdge(t) {
        _VisibilityGraph__WEBPACK_IMPORTED_MODULE_4__.VisibilityGraph.AddEdgeVV(getVertex(this.visibilityGraph, t.start), getVertex(this.visibilityGraph, t.End));
    }
    // this function will also add the first tangent to the visible edges if needed
    InitActiveDiagonals() {
        if (this.tangents.length === 0) {
            return;
        }
        const firstTangent = this.tangents[0];
        const firstTangentStart = firstTangent.start.point;
        const firstTangentEnd = firstTangent.End.point;
        for (const diagonal of this.diagonals) {
            if (InteractiveTangentVisibilityGraphCalculator.RayIntersectDiagonal(firstTangentStart, firstTangentEnd, diagonal)) {
                this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = _ActiveDiagonalComparerWithRay__WEBPACK_IMPORTED_MODULE_8__.ActiveDiagonalComparerWithRay.IntersectDiagonalWithRay(firstTangentStart, firstTangentEnd, diagonal);
                this.InsertActiveDiagonal(diagonal);
            }
        }
        if (firstTangent.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum()) {
            this.AddVisibleEdge(firstTangent);
        }
        if (firstTangent.IsLow === false) {
            // remove the diagonal of the top tangent from active edges
            const diag = firstTangent.Diagonal;
            this.RemoveDiagonalFromActiveNodes(diag);
        }
    }
    RemoveDiagonalFromActiveNodes(diag) {
        const changedNode = this.activeDiagonalTree.deleteSubTree(diag.RbNode);
        if (changedNode != null) {
            if (changedNode.item != null) {
                changedNode.item.RbNode = changedNode;
            }
        }
        diag.LeftTangent.Diagonal = null;
        diag.RightTangent.Diagonal = null;
    }
    InsertActiveDiagonal(diagonal) {
        diagonal.RbNode = this.activeDiagonalTree.insert(diagonal);
        InteractiveTangentVisibilityGraphCalculator.MarkDiagonalAsActiveInTangents(diagonal);
    }
    static MarkDiagonalAsActiveInTangents(diagonal) {
        diagonal.LeftTangent.Diagonal = diagonal;
        diagonal.RightTangent.Diagonal = diagonal;
    }
    static RayIntersectDiagonal(pivot, pointOnRay, diagonal) {
        const a = diagonal.Start;
        const b = diagonal.End;
        return (___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(pivot, a, b) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise &&
            ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(pivot, pointOnRay, a) !== _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Counterclockwise &&
            ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(pivot, pointOnRay, b) !== _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Clockwise);
    }
    // compare tangents by measuring the counterclockwise angle between the tangent and the edge
    static TangentComparison(e0, e1) {
        return _StemStartPointComparer__WEBPACK_IMPORTED_MODULE_9__.StemStartPointComparer.CompareVectorsByAngleToXAxis(e0.End.point.sub(e0.start.point), e1.End.point.sub(e1.start.point));
    }
    *AllObstacles() {
        for (const p of this.addedPolygons) {
            yield p;
        }
        if (this.polygons) {
            for (const p of this.polygons) {
                yield p;
            }
        }
    }
    OrganizeTangents() {
        for (const q of this.AllObstacles()) {
            if (q !== this.currentPolygon) {
                this.ProcessPolygonQ(q);
            }
        }
        this.tangents.sort(InteractiveTangentVisibilityGraphCalculator.TangentComparison);
    }
    ProcessPolygonQ(q) {
        const tangentPair = new _TangentPair__WEBPACK_IMPORTED_MODULE_3__.TangentPair(this.currentPolygon, q);
        if (this.useLeftPTangents) {
            tangentPair.CalculateLeftTangents();
        }
        else {
            tangentPair.CalculateRightTangents();
        }
        let couple = this.useLeftPTangents ? tangentPair.leftPLeftQ : tangentPair.rightPLeftQ;
        const t0 = new _Tangent__WEBPACK_IMPORTED_MODULE_7__.Tangent(this.currentPolygon.pp(couple[0]), q.pp(couple[1]));
        t0.IsLow = true;
        t0.SeparatingPolygons = !this.useLeftPTangents;
        couple = this.useLeftPTangents ? tangentPair.leftPRightQ : tangentPair.rightPRightQ;
        const t1 = new _Tangent__WEBPACK_IMPORTED_MODULE_7__.Tangent(this.currentPolygon.pp(couple[0]), q.pp(couple[1]));
        t1.IsLow = false;
        t1.SeparatingPolygons = this.useLeftPTangents;
        t0.Comp = t1;
        t1.Comp = t0;
        this.tangents.push(t0);
        this.tangents.push(t1);
        this.diagonals.push(new _Diagonal__WEBPACK_IMPORTED_MODULE_6__.Diagonal(t0, t1));
    }
    constructor(holes, addedPolygons, visibilityGraph) {
        super(null); // TODO: add cancelToken
        // the list of obstacles
        this.polygons = [];
        this.activeDiagonalComparer = new _ActiveDiagonalComparerWithRay__WEBPACK_IMPORTED_MODULE_8__.ActiveDiagonalComparerWithRay();
        this.polygons = holes;
        this.visibilityGraph = visibilityGraph;
        this.addedPolygons = addedPolygons;
    }
}
function getVertex(vg, pp) {
    return vg.FindVertex(pp.point);
}
//# sourceMappingURL=InteractiveTangentVisibilityGraphCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/LineSweeperBase.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineSweeperBase: () => (/* binding */ LineSweeperBase)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");
/* harmony import */ var _structs_BinaryHeapWithComparer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/BinaryHeapWithComparer.js");
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _spline_coneSpanner_LowestVertexEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/LowestVertexEvent.js");
/* harmony import */ var _ObstacleSideComparer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/ObstacleSideComparer.js");
/* harmony import */ var _PortObstacleEvent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/PortObstacleEvent.js");
//







class LineSweeperBase {
    constructor(obstacles, sweepDirection) {
        this.PreviousZ = Number.NEGATIVE_INFINITY;
        this.z = Number.NEGATIVE_INFINITY;
        this.Obstacles = obstacles !== null && obstacles !== void 0 ? obstacles : [];
        this.SweepDirection = sweepDirection;
        this.DirectionPerp = sweepDirection.rotate(-Math.PI / 2);
        this.EventQueue = new _structs_BinaryHeapWithComparer__WEBPACK_IMPORTED_MODULE_2__.BinaryHeapWithComparer((a, b) => this.Compare(a, b));
        this.ObstacleSideComparer = new _ObstacleSideComparer__WEBPACK_IMPORTED_MODULE_5__.ObstacleSideComparer(this);
        this.LeftObstacleSideTree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_3__.RBTree((a, b) => this.ObstacleSideComparer.Compare(a, b));
        this.RightObstacleSideTree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_3__.RBTree((a, b) => this.ObstacleSideComparer.Compare(a, b));
    }
    get EventQueue() {
        return this.eventQueue;
    }
    set EventQueue(value) {
        this.eventQueue = value;
    }
    // sweep direction rotated by 90 degrees clockwise
    get DirectionPerp() {
        return this.directionPerp;
    }
    set DirectionPerp(value) {
        this.directionPerp = value;
    }
    get Z() {
        return this.z;
    }
    set Z(value) {
        if (value > this.z + _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.tolerance) {
            this.PreviousZ = this.z;
        }
        this.z = value;
    }
    GetZS(eve) {
        return this.SweepDirection.dot(eve.Site);
    }
    GetZP(point) {
        return this.SweepDirection.dot(point);
    }
    SegmentIsNotHorizontal(a, b) {
        return Math.abs(a.sub(b).dot(this.SweepDirection)) > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.distanceEpsilon;
    }
    RemoveLeftSide(side) {
        this.ObstacleSideComparer.SetOperand(side);
        this.LeftObstacleSideTree.remove(side);
    }
    RemoveRightSide(side) {
        this.ObstacleSideComparer.SetOperand(side);
        this.RightObstacleSideTree.remove(side);
    }
    InsertLeftSide(side) {
        this.ObstacleSideComparer.SetOperand(side);
        this.LeftObstacleSideTree.insert(side);
    }
    InsertRightSide(side) {
        this.ObstacleSideComparer.SetOperand(side);
        this.RightObstacleSideTree.insert(side);
    }
    FindFirstObstacleSideToTheLeftOfPoint(point) {
        const node = this.RightObstacleSideTree.findLast((s) => _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.pointToTheRightOfLineOrOnLine(point, s.Start, s.End));
        return node == null ? null : node.item;
    }
    FindFirstObstacleSideToToTheRightOfPoint(point) {
        const node = this.LeftObstacleSideTree.findFirst((s) => !_math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.pointToTheRightOfLineOrOnLine(point, s.Start, s.End));
        return node == null ? null : node.item;
    }
    EnqueueEvent(eve) {
        /*Assert.assert(this.GetZP(eve.Site) >= this.PreviousZ)*/
        this.eventQueue.Enqueue(eve);
    }
    InitQueueOfEvents() {
        for (const obstacle of this.Obstacles) {
            this.EnqueueLowestPointsOnObstacles(obstacle);
        }
        if (this.Ports != null) {
            for (const point of this.Ports.values()) {
                this.EnqueueEvent(new _PortObstacleEvent__WEBPACK_IMPORTED_MODULE_6__.PortObstacleEvent(point));
            }
        }
    }
    EnqueueLowestPointsOnObstacles(poly) {
        const candidate = this.GetLowestPoint(poly);
        this.EnqueueEvent(new _spline_coneSpanner_LowestVertexEvent__WEBPACK_IMPORTED_MODULE_4__.LowestVertexEvent(candidate));
    }
    GetLowestPoint(poly) {
        let candidate = poly.startPoint;
        let pp = poly.startPoint.next;
        for (; pp != null; pp = pp.next) {
            if (this.Less(pp.point, candidate.point)) {
                candidate = pp;
            }
        }
        return candidate;
    }
    // imagine that direction points up,
    // lower events have higher priorities,
    // for events at the same level events to the left have higher priority
    Compare(a, b) {
        const aSite = a.Site;
        const bSite = b.Site;
        return this.ComparePoints(/* ref */ aSite, /* ref */ bSite);
    }
    Less(a, b) {
        return this.ComparePoints(/* ref */ a, /* ref */ b) < 0;
    }
    ComparePoints(aSite, bSite) {
        let aProjection = this.SweepDirection.dot(aSite);
        let bProjection = this.SweepDirection.dot(bSite);
        if (aProjection < bProjection) {
            return -1;
        }
        if (aProjection > bProjection) {
            return 1;
        }
        aProjection = this.directionPerp.dot(aSite);
        bProjection = this.directionPerp.dot(bSite);
        return aProjection < bProjection ? -1 : aProjection > bProjection ? 1 : 0;
    }
}
//# sourceMappingURL=LineSweeperBase.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/ObstacleSideComparer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObstacleSideComparer: () => (/* binding */ ObstacleSideComparer)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");

// import {GeomConstants} from '../../math/geometry/geomConstants'

class ObstacleSideComparer {
    constructor(lineSweeper) {
        this.lineSweeper = lineSweeper;
    }
    Compare(a, b) {
        const orient = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(b.Start, b.End, this.x);
        switch (orient) {
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear:
                return 0;
                break;
            case _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Clockwise:
                return 1;
                break;
            default:
                return -1;
                break;
        }
    }
    SetOperand(side) {
        this.x = this.IntersectionOfSideAndSweepLine(side);
    }
    IntersectionOfSideAndSweepLine(obstacleSide) {
        const den = obstacleSide.Direction.dot(this.lineSweeper.SweepDirection);
        /*Assert.assert(Math.abs(den) > GeomConstants.distanceEpsilon)*/
        const t = (this.lineSweeper.Z - obstacleSide.Start.dot(this.lineSweeper.SweepDirection)) / den;
        return obstacleSide.Start.add(obstacleSide.Direction.mul(t));
    }
}
//# sourceMappingURL=ObstacleSideComparer.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/PointVisibilityCalculator.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointVisibilityCalculator: () => (/* binding */ PointVisibilityCalculator)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polylinePoint.js");
/* harmony import */ var _structs_BinaryHeapWithComparer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/BinaryHeapWithComparer.js");
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");
/* harmony import */ var _ActiveEdgeComparerWithRay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/ActiveEdgeComparerWithRay.js");
/* harmony import */ var _Stem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/Stem.js");
/* harmony import */ var _StemStartPointComparer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/StemStartPointComparer.js");
/* harmony import */ var _TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js");
/* harmony import */ var _VisibilityKind__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityKind.js");
// following "Visibility Algorithms in the Plane", Ghosh











class PointVisibilityCalculator {
    get QVertex() {
        return this.qV;
    }
    set QVertex(value) {
        this.qV = value;
    }
    // "point" can belong to the boundary of one of the holes
    // tangent or regural visibility
    // "qVertex" : the graph vertex corresponding to the pivot
    static CalculatePointVisibilityGraph(listOfHoles, visibilityGraph, point, visibilityKind) {
        // maybe there is nothing to do
        const qv = visibilityGraph.FindVertex(point);
        if (qv != null) {
            return qv;
        }
        const calculator = new PointVisibilityCalculator(listOfHoles, visibilityGraph, point, visibilityKind);
        calculator.FillGraph();
        return calculator.QVertex;
    }
    FillGraph() {
        this.ComputeHoleBoundariesPossiblyVisibleFromQ();
        if (this.visibleBoundaries.size > 0) {
            this.SortSAndInitActiveSides();
            // CheckActiveSidesAreConsistent();
            this.Sweep();
        }
    }
    // sorts the set of potentially visible vertices around point q
    SortSAndInitActiveSides() {
        this.InitHeapAndInsertActiveSides();
        for (let stem = this.heapForSorting.GetMinimum();; stem = this.heapForSorting.GetMinimum()) {
            this.sortedListOfPolypoints.push(stem.Start);
            if (stem.MoveStartClockwise()) {
                this.heapForSorting.ChangeMinimum(stem);
            }
            else {
                this.heapForSorting.Dequeue();
            }
            if (this.heapForSorting.Count === 0) {
                break;
            }
        }
    }
    InitHeapAndInsertActiveSides() {
        for (const pp of this.GetInitialVisibleBoundaryStemsAndInsertActiveSides()) {
            this.heapForSorting.Enqueue(pp);
        }
    }
    // these are chuncks of the visible boundaries growing from the polyline  point just above its crossing with the horizontal ray or
    // from the visible part start
    // In the general case we have two stems from one polyline
    *GetInitialVisibleBoundaryStemsAndInsertActiveSides() {
        for (const [hole, stem] of this.visibleBoundaries) {
            let crosses = false;
            for (const side of stem.Sides()) {
                const source = side;
                if (source.point.y < this.q.y) {
                    if (side.nextOnPolyline.point.y >= this.q.y) {
                        const orientation = ___WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(this.q, source.point, side.nextOnPolyline.point);
                        if (orientation === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Counterclockwise || orientation === _math_geometry_point__WEBPACK_IMPORTED_MODULE_2__.TriangleOrientation.Collinear) {
                            crosses = true;
                            // we have two stems here
                            yield new _Stem__WEBPACK_IMPORTED_MODULE_7__.Stem(stem.Start, side);
                            yield new _Stem__WEBPACK_IMPORTED_MODULE_7__.Stem(side.nextOnPolyline, stem.End);
                            this.RegisterActiveSide(side);
                            break;
                        }
                    }
                }
                else if (source.point.y > this.q.y) {
                    break;
                }
                else if (side.point.x >= this.q.x) {
                    // we have pp.Y==q.Y
                    crosses = true;
                    // we need to add one or two stems here
                    yield new _Stem__WEBPACK_IMPORTED_MODULE_7__.Stem(side, stem.End);
                    if (side !== stem.Start) {
                        yield new _Stem__WEBPACK_IMPORTED_MODULE_7__.Stem(stem.Start, hole.prev(source));
                    }
                    this.RegisterActiveSide(side);
                    break;
                }
            }
            // there is no intersection with the ray
            if (!crosses) {
                yield stem;
            }
        }
    }
    RegisterActiveSide(side) {
        this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge = this.activeEdgeComparer.IntersectEdgeWithRay(side, new ___WEBPACK_IMPORTED_MODULE_0__.Point(1, 0));
        this.sideNodes.set(side, this.activeSidesTree.insert(side));
    }
    // private Polyline GetPolylineBetweenPolyPointsTest(Polyline hole, PolylinePoint p0, PolylinePoint p1) {
    //    Polyline ret = new Polyline();
    //    while (p0 !== p1) {
    //        ret.AddPoint(p0.Point);
    //        p0 = hole.Next(p0);
    //    }
    //    ret.AddPoint(p1.Point);
    //    return ret;
    // }
    constructor(holes, visibilityGraph, point, visibilityKind) {
        // A mapping from sides to their RBNodes
        this.sideNodes = new Map();
        // These are parts of hole boundaries visible from q where each node is taken in isolation
        this.visibleBoundaries = new Map();
        // the sorted list of possibly visible vertices
        this.sortedListOfPolypoints = new Array();
        this.holes = Array.from(holes);
        // this.graphOfHoleBoundaries = holeBoundariesGraph;
        this.visibilityGraph = visibilityGraph;
        this.q = point;
        this.qPolylinePoint = _math_geometry_polylinePoint__WEBPACK_IMPORTED_MODULE_3__.PolylinePoint.mkFromPoint(this.q);
        this.QVertex = this.visibilityGraph.AddVertexP(this.qPolylinePoint.point);
        this.visibilityKind = visibilityKind;
        const comp = new _StemStartPointComparer__WEBPACK_IMPORTED_MODULE_8__.StemStartPointComparer(this.q);
        this.heapForSorting = new _structs_BinaryHeapWithComparer__WEBPACK_IMPORTED_MODULE_4__.BinaryHeapWithComparer(comp.IComparer.bind(comp));
    }
    Sweep() {
        for (const polylinePoint of this.sortedListOfPolypoints) {
            this.SweepPolylinePoint(polylinePoint);
        }
    }
    // this code will work for convex holes
    SweepPolylinePoint(v) {
        const inSide = PointVisibilityCalculator.GetIncomingSide(v);
        const outSide = this.GetOutgoingSide(v);
        // if (inEdge != null && outEdge != null)
        //    SugiyamaLayoutSettings.Show(new LineSegment(inEdge.Start.Point, inEdge.End.Point), new LineSegment(outEdge.Start.Point,
        //        outEdge.End.Point), new LineSegment(this.q, v.Point));
        // else if (inEdge != null)
        //    SugiyamaLayoutSettings.Show(new LineSegment(inEdge.Start.Point, inEdge.End.Point), new LineSegment(this.q, v.Point));
        // else if (outEdge != null)
        //    SugiyamaLayoutSettings.Show(new LineSegment(outEdge.Start.Point, outEdge.End.Point), new LineSegment(this.q, v.Point));
        this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge = v.point;
        let node;
        if ((node = this.sideNodes.get(inSide))) {
            // we have an active edge
            if (node === this.activeSidesTree.treeMinimum()) {
                this.AddEdge(v);
            }
            if (outSide != null) {
                node.item = outSide;
                // just replace the edge since the order does not change
                this.sideNodes.set(outSide, node);
            }
            else {
                const changedNode = this.activeSidesTree.deleteSubTree(node);
                if (changedNode != null) {
                    if (changedNode.item != null) {
                        this.sideNodes.set(changedNode.item, changedNode);
                    }
                }
            }
            this.sideNodes.delete(inSide);
        }
        else if (outSide != null) {
            let outsideNode;
            if (!(outsideNode = this.sideNodes.get(outSide))) {
                outsideNode = this.activeSidesTree.insert(outSide);
                this.sideNodes.set(outSide, outsideNode);
                if (outsideNode === this.activeSidesTree.treeMinimum()) {
                    this.AddEdge(v);
                }
            }
        }
        else {
            throw new Error();
        }
    }
    AddEdge(v) {
        if (this.visibilityKind === _VisibilityKind__WEBPACK_IMPORTED_MODULE_10__.VisibilityKind.Regular ||
            (this.visibilityKind === _VisibilityKind__WEBPACK_IMPORTED_MODULE_10__.VisibilityKind.Tangent && PointVisibilityCalculator.LineTouchesPolygon(this.QVertex.point, v))) {
            this.visibilityGraph.AddEdgeF(this.QVertex.point, v.point, (a, b) => new _TollFreeVisibilityEdge__WEBPACK_IMPORTED_MODULE_9__.TollFreeVisibilityEdge(a, b));
        }
    }
    static LineTouchesPolygon(a, p) {
        const prev = p.polyline.prev(p).point;
        const next = p.polyline.next(p).point;
        const v = p.point;
        return ___WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(a, v, prev) * ___WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(a, v, next) >= 0;
    }
    // ReSharper disable UnusedMember.Local
    /*
          DrawActiveEdgesAndVisibleGraph() {
              // ReSharper restore UnusedMember.Local
              let l = new Array<ICurve>();
              for (let pe: VisibilityEdge in this.visibilityGraph.Edges) {
                  l.Add(new LineSegment(pe.SourcePoint, pe.TargetPoint));
              }
              
              for (let pe: PolylinePoint in this.activeSidesTree) {
                  l.Add(new LineSegment(pe.Point, pe.NextOnPolyline.Point));
              }
              
              l.Add(new Ellipse(0.1, 0.1, this.q));
              LayoutAlgorithmSettings.Show(l.ToArray());
          }
    */
    GetOutgoingSide(v) {
        const visibleStem = this.visibleBoundaries.get(v.polyline);
        if (v === visibleStem.End) {
            return null;
        }
        return v;
    }
    static GetIncomingSide(v) {
        return v.prevOnPolyline;
    }
    ComputeHoleBoundariesPossiblyVisibleFromQ() {
        this.InitActiveEdgesAndActiveEdgesComparer();
        for (const hole of this.holes) {
            this.ComputeVisiblePartOfTheHole(hole);
        }
    }
    InitActiveEdgesAndActiveEdgesComparer() {
        this.activeEdgeComparer = new _ActiveEdgeComparerWithRay__WEBPACK_IMPORTED_MODULE_6__.ActiveEdgeComparerWithRay();
        this.activeEdgeComparer.pivot = this.q;
        this.activeSidesTree = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_5__.RBTree(this.activeEdgeComparer.Compare.bind(this.activeEdgeComparer));
    }
    ComputeVisiblePartOfTheHole(hole) {
        // find a separating edge
        let a;
        let needToGoCounterclockWise = true;
        for (a = hole.startPoint; !this.HoleSideIsVisibleFromQ(hole, a); a = hole.next(a)) {
            //Assert.assert(needToGoCounterclockWise || a !== hole.startPoint)
            // check that we have not done the full circle
            needToGoCounterclockWise = false;
        }
        let b = hole.next(a);
        // now the side a, a.Next - is separating
        if (needToGoCounterclockWise) {
            while (this.HoleSideIsVisibleFromQ(hole, hole.prev(a))) {
                a = hole.prev(a);
            }
        }
        // go clockwise starting from b
        for (; this.HoleSideIsVisibleFromQ(hole, b); b = hole.next(b)) { }
        this.visibleBoundaries.set(hole, new _Stem__WEBPACK_IMPORTED_MODULE_7__.Stem(a, b));
    }
    HoleSideIsVisibleFromQ(hole, b) {
        return ___WEBPACK_IMPORTED_MODULE_0__.Point.signedDoubledTriangleArea(this.q, b.point, hole.next(b).point) >= -_math_geometry__WEBPACK_IMPORTED_MODULE_1__.GeomConstants.squareOfDistanceEpsilon;
    }
}
//# sourceMappingURL=PointVisibilityCalculator.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/Polygon.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polygon: () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _math_geometry_polyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/polyline.js");
/* harmony import */ var _BimodalSequence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/BimodalSequence.js");
/* harmony import */ var _TangentPair__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/TangentPair.js");





class Polygon {
    static mkFromPoints(pts) {
        return new Polygon(_math_geometry_polyline__WEBPACK_IMPORTED_MODULE_2__.Polyline.mkClosedFromPoints(pts));
    }
    get Polyline() {
        return this.polyline;
    }
    constructor(polyline) {
        this.polyline = polyline;
        this.points = new Array();
        for (let pp = this.polyline.startPoint; pp; pp = pp.next)
            this.points.push(pp);
        /*Assert.assert(
          polyline.count < 3 ||
            Point.getTriangleOrientation(this.pnt(0), this.pnt(1), this.pnt(2)) !=
              TriangleOrientation.Counterclockwise,
        )*/
    }
    Next(i) {
        return this.Module(i + 1);
    }
    Prev(i) {
        return this.Module(i - 1);
    }
    get count() {
        return this.Polyline.count;
    }
    Module(i) {
        if (i < 0) {
            return i + this.count;
        }
        if (i < this.count) {
            return i;
        }
        return i - this.count;
    }
    pp(i) {
        return this.points[this.Module(i)];
    }
    // LineSegment ls(Point pivot, int p) {
    //    return new LineSegment(pivot, Pnt(p));
    // }
    pnt(i) {
        return this.pp(i).point;
    }
    toString() {
        return this.polyline.toString();
    }
    // the median of a chunk going clockwise from p1 to p2
    Median(p1, p2) {
        /*Assert.assert(p1 !== p2)*/
        // otherwise we do not know what arc is mean: the whole one or just the point
        if (p2 > p1) {
            return Math.floor((p2 + p1) / 2);
        }
        return this.Module(p2 + Math.floor((this.count + p1) / 2));
    }
    // p1 and p2 represent the closest feature. Two cases are possible p1=p2, or p1 and p2 share an edge going from p1 to p2
    // Remind that the polygons are oriented clockwise
    FindTheFurthestVertexFromBisector(p1, p2, bisectorPivot, bisectorRay) {
        let directionToTheHill = bisectorRay.rotate(Math.PI / 2);
        if (this.polyline.startPoint.point.sub(bisectorPivot).dot(directionToTheHill) < 0) {
            directionToTheHill = directionToTheHill.mul(-1);
        }
        if (p1 === p2) {
            p2 = this.Next(p1);
        }
        // binary search
        do {
            const m = this.Median(p2, p1);
            // now the chunk goes clockwise from p2 to p1
            const mp = this.pnt(m);
            if (this.pnt(this.Next(m)).sub(mp).dot(directionToTheHill) >= 0) {
                p2 = this.Next(m);
            }
            else if (this.pnt(this.Prev(m)).sub(mp).dot(directionToTheHill) >= 0) {
                p1 = this.Prev(m);
            }
            else {
                p2 = m;
            }
            p1 = m;
        } while (p1 !== p2);
        return p1;
    }
    static TestPolygonDist(a, b) {
        let ret = Number.MAX_SAFE_INTEGER;
        for (let i = 0; i < a.count; i++) {
            for (let j = 0; j < b.count; j++) {
                const t = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_0__.LineSegment.minDistBetweenLineSegments(a.pnt(i), a.pnt(i + 1), b.pnt(j), b.pnt(j + 1));
                ret = Math.min(ret, t.dist);
            }
        }
        return ret;
    }
    // Distance between two polygons
    // p and q are the closest points
    // The function doesn't work if the polygons intersect each other
    static Distance(a, b) {
        const tp = new _TangentPair__WEBPACK_IMPORTED_MODULE_4__.TangentPair(a, b);
        const pq = tp.FindClosestPoints();
        //    #if(TEST_MSAGL)
        // if (!Point.closeDistEps((p - q).length, Polygon.TestPolygonDist(a, b))) {
        //  let stream = File.Open("c:\tmp\polygonBug", FileMode.Create);
        //  let bf = new BinaryFormatter();
        //  bf.Serialize(stream, a);
        //  bf.Serialize(stream, b);
        //  LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve(100, 0.1, "red", a.Polyline), new DebugCurve(100, 0.1, "blue", b.Polyline), new DebugCurve(100, 0.1, "black", new LineSegment(p, q)));
        //  System.Diagnostics.Debug.Fail("wrong distance between two polygons");
        // }
        //    #endif
        return {
            p: pq.pClosest,
            q: pq.qClosest,
            dist: pq.pClosest.sub(pq.qClosest).length,
        };
    }
    // Distance between two polygons
    static DistanceOnly(a, b) {
        /*Assert.assert(Polygon.PolygonIsLegalDebug(a))*/
        /*Assert.assert(Polygon.PolygonIsLegalDebug(b))*/
        return Polygon.Distance(a, b).dist;
    }
    static PolygonIsLegalDebug(a) {
        const poly = a.Polyline;
        for (let p = poly.startPoint; p.next != null && p.next.next != null; p = p.next) {
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientation(p.point, p.next.point, p.next.next.point) === _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.TriangleOrientation.Collinear) {
                return false;
            }
        }
        return true;
    }
    // Distance between polygon and point, assuming the point is outside of the polygon
    static DistancePoint(poly, b) {
        let res = Number.MAX_VALUE;
        for (let i = 0; i < poly.count; i++) {
            const dist = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.distToLineSegment(b, poly.points[i].point, poly.points[(i + 1) % poly.count].point).dist;
            res = Math.min(res, dist);
        }
        return res;
    }
    GetTangentPoints(t, point) {
        const bimodalSequence = new _BimodalSequence__WEBPACK_IMPORTED_MODULE_3__.BimodalSequence(this.GetSequenceDelegate(point), this.count);
        t.leftTangentPoint = bimodalSequence.FindMaximum();
        t.rightTangentPoint = bimodalSequence.FindMinimum();
    }
    GetSequenceDelegate(point) {
        const pointOfP = this.pnt(0);
        return (i) => {
            const d = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.anglePCP(pointOfP, point, this.pnt(i));
            return d < Math.PI ? d : d - 2 * Math.PI;
        };
    }
}
//# sourceMappingURL=Polygon.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/PortObstacleEvent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PortObstacleEvent: () => (/* binding */ PortObstacleEvent)
/* harmony export */ });
/* harmony import */ var _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/spline/coneSpanner/SweepEvent.js");

class PortObstacleEvent extends _spline_coneSpanner_SweepEvent__WEBPACK_IMPORTED_MODULE_0__.SweepEvent {
    constructor(site) {
        super();
        this.site = site;
    }
    get Site() {
        return this.site;
    }
}
//# sourceMappingURL=PortObstacleEvent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/SegmentBase.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SegmentBase: () => (/* binding */ SegmentBase)
/* harmony export */ });
class SegmentBase {
    get Direction() {
        return this.End.sub(this.Start);
    }
    toString() {
        return this.Start + ' ' + this.End;
    }
}
//# sourceMappingURL=SegmentBase.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/Stem.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stem: () => (/* binding */ Stem)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");

// represents a chunk of a hole boundary
class Stem {
    get Start() {
        return this.start;
    }
    set Start(value) {
        this.start = value;
    }
    get End() {
        return this.end;
    }
    set End(value) {
        this.end = value;
    }
    constructor(start, end) {
        //Assert.assert(start.polyline === end.polyline)
        this.start = start;
        this.end = end;
    }
    *Sides() {
        let v = this.start;
        while (v !== this.end) {
            const side = v;
            yield side;
            v = side.nextOnPolyline;
        }
    }
    MoveStartClockwise() {
        if (this.Start !== this.End) {
            this.Start = this.Start.nextOnPolyline;
            return true;
        }
        return false;
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('Stem({0},{1})', this.Start, this.End);
    }
}
//# sourceMappingURL=Stem.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/StemStartPointComparer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StemStartPointComparer: () => (/* binding */ StemStartPointComparer)
/* harmony export */ });
/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/index.js");
// compares couples only by looking at the couple first point

// we need the couple to hold the stem
class StemStartPointComparer {
    constructor(p) {
        this.pivot = p;
    }
    IComparer(i, j) {
        if (i === j)
            return 0;
        if (i == null)
            return -1;
        if (j == null)
            return 1;
        const a = i.Start.point.sub(this.pivot);
        const b = j.Start.point.sub(this.pivot);
        return StemStartPointComparer.CompareVectorsByAngleToXAxis(a, b);
    }
    static CompareVectorsByAngleToXAxis(a, b) {
        if (a.y >= 0) {
            if (b.y < 0) {
                return -1;
            }
            return StemStartPointComparer.CompareVectorsPointingToTheSameYHalfPlane(a, b);
        }
        else {
            // a.y <0
            if (b.y >= 0) {
                return 1;
            }
            return StemStartPointComparer.CompareVectorsPointingToTheSameYHalfPlane(a, b);
        }
    }
    static CompareVectorsPointingToTheSameYHalfPlane(a, b) {
        // now we know that a and b do not point to different Y half planes
        const sign = a.x * b.y - a.y * b.x;
        if (sign > _math_geometry__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance) {
            return -1;
        }
        if (sign < -_math_geometry__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.tolerance) {
            return 1;
        }
        // are they on the opposite sides of the pivot by X?
        if (a.x >= 0) {
            if (b.x < 0) {
                return -1;
            }
        }
        else if (b.x >= 0) {
            return 1;
        }
        let del = Math.abs(a.x) - Math.abs(b.x);
        if (del < 0) {
            return -1;
        }
        if (del > 0) {
            return 1;
        }
        del = Math.abs(a.y) - Math.abs(b.y);
        if (del < 0) {
            return -1;
        }
        if (del > 0) {
            return 1;
        }
        return 0;
        // points are equal
    }
}
//# sourceMappingURL=StemStartPointComparer.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/Tangent.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tangent: () => (/* binding */ Tangent)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");

class Tangent {
    // the complimentary tangent
    get Comp() {
        return this.comp;
    }
    set Comp(value) {
        this.comp = value;
    }
    get IsHigh() {
        return !this.IsLow;
    }
    // true means that it is a low tangent to Q, false meanst that it is a high tangent to Q
    get IsLow() {
        return this.lowTangent;
    }
    set IsLow(value) {
        this.lowTangent = value;
    }
    get SeparatingPolygons() {
        return this.separatingPolygons;
    }
    set SeparatingPolygons(value) {
        this.separatingPolygons = value;
    }
    // the diagonal will be not a null only when it is active
    get Diagonal() {
        return this.diagonal;
    }
    set Diagonal(value) {
        this.diagonal = value;
    }
    get Start() {
        return this.start;
    }
    set Start(value) {
        this.start = value;
    }
    get End() {
        return this.end;
    }
    set End(value) {
        this.end = value;
    }
    constructor(start, end) {
        this.start = start;
        this.End = end;
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.String.Format('{0},{1}', this.Start, this.End);
    }
}
//# sourceMappingURL=Tangent.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/TangentPair.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TangentPair: () => (/* binding */ TangentPair)
/* harmony export */ });
/* harmony import */ var _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/lineSegment.js");
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
// calculates the pair of tangent line segments between two convex non-intersecting polygons H and Q


// we suppose that polygons are clockwise oriented
class TangentPair {
    constructor(polygonP, polygonQ) {
        this.P = polygonP;
        this.Q = polygonQ;
    }
    LeftFromLineOnP(vertexIndex, lineStart, lineEnd) {
        const p = this.P.pnt(vertexIndex);
        if (this.upperBranchOnP) {
            return _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.pointToTheLeftOfLineOrOnLine(lineEnd, p, lineStart);
        }
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.pointToTheRightOfLineOrOnLine(lineEnd, p, lineStart);
    }
    LeftFromLineOnQ(vertexIndex, lineStart, lineEnd) {
        const point = this.Q.pnt(vertexIndex);
        if (this.lowerBranchOnQ) {
            return _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.pointToTheLeftOfLineOrOnLine(lineEnd, point, lineStart);
        }
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.pointToTheRightOfLineOrOnLine(lineEnd, point, lineStart);
    }
    PrevOnP(i) {
        if (this.upperBranchOnP) {
            return this.P.Prev(i);
        }
        return this.P.Next(i);
    }
    PrevOnQ(i) {
        if (this.lowerBranchOnQ) {
            return this.Q.Prev(i);
        }
        return this.Q.Next(i);
    }
    NextOnP(i) {
        if (this.upperBranchOnP) {
            return this.P.Next(i);
        }
        return this.P.Prev(i);
    }
    NextOnQ(i) {
        if (this.lowerBranchOnQ) {
            return this.Q.Next(i);
        }
        return this.Q.Prev(i);
    }
    MedianOnP(i, j) {
        if (this.upperBranchOnP) {
            return this.P.Median(i, j);
        }
        return this.P.Median(j, i);
    }
    MedianOnQ(i, j) {
        if (this.lowerBranchOnQ) {
            return this.Q.Median(i, j);
        }
        return this.Q.Median(j, i);
    }
    ModuleP(p0, p1) {
        if (this.upperBranchOnP) {
            return this.P.Module(p1 - p0);
        }
        return this.P.Module(p0 - p1);
    }
    ModuleQ(q0, q1) {
        if (this.lowerBranchOnQ) {
            return this.Q.Module(q1 - q0);
        }
        return this.Q.Module(q0 - q1);
    }
    // we pretend here that the branches go clockwise from p0 to p1, and from q0 to q1
    TangentBetweenBranches(p0, p1, q0, q1) {
        while (p1 !== p0 || q1 !== q0) {
            const mp = p1 !== p0 ? this.MedianOnP(p0, p1) : p0;
            const mq = q1 !== q0 ? this.MedianOnQ(q0, q1) : q0;
            const mpp = this.P.pnt(mp);
            const mqp = this.Q.pnt(mq);
            // SugiyamaLayoutSettings.Show(P.Polyline, ls(mp, mq), ls(p1,q0), ls(p0,q1), Q.Polyline);
            let moveOnP = true;
            if (this.ModuleP(p0, p1) > 1) {
                if (this.LeftFromLineOnP(this.NextOnP(mp), mpp, mqp)) {
                    p0 = mp;
                }
                else if (this.LeftFromLineOnP(this.PrevOnP(mp), mpp, mqp)) {
                    p1 = mp;
                }
                else {
                    moveOnP = false;
                }
            }
            else if (p1 !== p0) {
                // we have only two point in the branch
                // try to move p0 clockwise
                if (this.LeftFromLineOnP(p1, this.P.pnt(p0), mqp)) {
                    p0 = p1;
                }
                else if (this.LeftFromLineOnP(p0, this.P.pnt(p1), mqp)) {
                    p1 = p0;
                }
                else {
                    moveOnP = false;
                }
            }
            else {
                moveOnP = false;
            }
            let moveOnQ = true;
            if (this.ModuleQ(q0, q1) > 1) {
                if (this.LeftFromLineOnQ(this.NextOnQ(mq), mqp, mpp)) {
                    q0 = mq;
                }
                else if (this.LeftFromLineOnQ(this.PrevOnQ(mq), mqp, mpp)) {
                    q1 = mq;
                }
                else {
                    moveOnQ = false;
                }
            }
            else if (q1 !== q0) {
                // we have only two points in the branch
                if (this.LeftFromLineOnQ(q1, this.Q.pnt(q0), mpp)) {
                    q0 = q1;
                }
                else if (this.LeftFromLineOnQ(q0, this.Q.pnt(q1), mpp)) {
                    q1 = q0;
                }
                else {
                    moveOnQ = false;
                }
            }
            else {
                moveOnQ = false;
            }
            if (!moveOnP && !moveOnQ) {
                p0 = mp;
                p1 = mp;
                q0 = mq;
                q1 = mq;
            }
        }
        return [p0, q1];
    }
    // following the paper of Edelsbrunner
    FindDividingBisector(t) {
        const m = {
            pClosest: undefined,
            qClosest: undefined,
            p1: undefined,
            p2: undefined,
            q1: undefined,
            q2: undefined,
        };
        this.FindClosestFeatures(m);
        t.bisectorPivot = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.middle(m.pClosest, m.qClosest);
        t.bisectorRay = m.pClosest.sub(m.qClosest).rotate(Math.PI / 2);
        t.p1 = m.p1;
        t.p2 = m.p2;
        t.q1 = m.q1;
        t.q2 = m.q2;
        // number p=P.FindTheFurthestVertexFromBisector(
        // #if TEST_MSAGL
        //             //if (!Point.closeDistEps(pClosest, qClosest))
        //             //    SugiyamaLayoutSettings.Show(this.P.Polyline, this.Q.Polyline, new LineSegment(pClosest, qClosest));
        // #endif
    }
    FindClosestPoints() {
        const m = {
            q2: undefined,
            p1: undefined,
            p2: undefined,
            q1: undefined,
            pClosest: undefined,
            qClosest: undefined,
        };
        this.FindClosestFeatures(m);
        return { pClosest: m.pClosest, qClosest: m.qClosest };
    }
    FindClosestFeatures(m) {
        const r = {
            leftTangentPoint: undefined,
            rightTangentPoint: undefined,
        };
        this.P.GetTangentPoints(r, this.Q.pp(0).point);
        // LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve(P.Polyline), new DebugCurve(Q.Polyline), new DebugCurve("red",Ls(p2, 0)), new DebugCurve("blue",Ls(p1, 0)));
        m.p2 = r.leftTangentPoint;
        m.p1 = r.rightTangentPoint;
        if (m.p2 === m.p1)
            m.p2 += this.P.count;
        this.Q.GetTangentPoints(r, this.P.pp(0).point);
        // LayoutAlgorithmSettings.Show(P.Polyline, Q.Polyline, Ls(0, q1), Ls(0, q2));
        m.q1 = r.leftTangentPoint;
        m.q2 = r.rightTangentPoint;
        if (m.q2 === m.q1) {
            m.q2 += this.Q.count;
        }
        this.FindClosestPoints_(m);
    }
    //chunks go clockwise from p1 to p2 and from q2 to q1
    FindClosestPoints_(t) {
        while (this.ChunksAreLong(t.p2, t.p1, t.q2, t.q1))
            this.ShrinkChunks(t);
        if (t.p1 === t.p2) {
            t.pClosest = this.P.pp(t.p2).point;
            if (t.q1 === t.q2)
                t.qClosest = this.Q.pp(t.q1).point;
            else {
                //                   if(debug) LayoutAlgorithmSettings.Show(new LineSegment(P.Pnt(p2), Q.Pnt(q2)), new LineSegment(P.Pnt(p1), Q.Pnt(q1)), P.Polyline, Q.Polyline);
                t.qClosest = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.ClosestPointAtLineSegment(t.pClosest, this.Q.pp(t.q1).point, this.Q.pp(t.q2).point);
                if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(t.qClosest, this.Q.pnt(t.q1)))
                    t.q2 = t.q1;
                else if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(t.qClosest, this.Q.pnt(t.q2)))
                    t.q1 = t.q2;
            }
        }
        else {
            /*Assert.assert(t.q1 === t.q2)*/
            t.qClosest = this.Q.pp(t.q1).point;
            t.pClosest = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.ClosestPointAtLineSegment(t.qClosest, this.P.pp(t.p1).point, this.P.pp(t.p2).point);
            if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(t.pClosest, this.P.pnt(t.p1)))
                t.p2 = t.p1;
            else if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.closeDistEps(t.qClosest, this.P.pnt(t.p2)))
                t.p1 = t.p2;
        }
    }
    ChunksAreLong(p2, p1, q2, q1) {
        const pLength = this.P.Module(p2 - p1) + 1;
        if (pLength > 2) {
            return true;
        }
        const qLength = this.Q.Module(q1 - q2) + 1;
        if (qLength > 2) {
            return true;
        }
        if (pLength === 2 && qLength === 2) {
            return true;
        }
        return false;
    }
    ShrinkChunks(t) {
        const mp = t.p1 === t.p2 ? t.p1 : this.P.Median(t.p1, t.p2);
        const mq = t.q1 === t.q2 ? t.q1 : this.Q.Median(t.q2, t.q1);
        const mP = this.P.pp(mp).point;
        const mQ = this.Q.pp(mq).point;
        const angles = {
            a1: undefined,
            a2: undefined,
            b1: undefined,
            b2: undefined,
        };
        this.GetAnglesAtTheMedian(mp, mq, mP, mQ, angles);
        //           Core.Layout.LayoutAlgorithmSettings.Show(new LineSegment(P.Pnt(t.p2), Q.Pnt(t.t.q2)), new LineSegment(P.Pnt(t.p1), Q.Pnt(t.q1)), new LineSegment(P.Pnt(mp),Q.Pnt( mq)), P.Polyline, Q.Polyline);
        //if (MovingAlongHiddenSide(ref t.p1, ref t.p2, ref t.q1, ref t.q2, mp, mq, a1, a2, b1, b2)) {
        // //  SugiyamaLayoutSettings.Show(ls(t.p2, t.q2), ls(t.p1, t.q1), ls(mp, mq), P.Polyline, Q.Polyline);
        //   return;
        //}
        if (this.InternalCut(t, mp, mq, angles.a1, angles.a2, angles.b1, angles.b2)) {
            //              if(debug) LayoutAlgorithmSettings.Show(P.Polyline, Q.Polyline, Ls(t.p1, q1), Ls(t.p2,q2));
            return;
        }
        //case 1
        if (TangentPair.OneOfChunksContainsOnlyOneVertex(t, mp, mq, angles.a1, angles.b1))
            return;
        //case 2
        if (this.OnlyOneChunkContainsExactlyTwoVertices(t, { mp: mp, mq: mq }, angles))
            return;
        // the case where we have exactly two vertices in each chunk
        if (t.p2 === this.P.Next(t.p1) && t.q1 === this.Q.Next(t.q2)) {
            const md = _math_geometry_lineSegment__WEBPACK_IMPORTED_MODULE_0__.LineSegment.minDistBetweenLineSegments(this.P.pnt(t.p1), this.P.pnt(t.p2), this.Q.pnt(t.q1), this.Q.pnt(t.q2));
            //Assert.assert(res);
            if (md.parab === 0)
                t.p2 = t.p1;
            else if (md.parab === 1)
                t.p1 = t.p2;
            else if (md.parcd === 0)
                t.q2 = t.q1;
            else if (md.parcd === 1)
                t.q1 = t.q2;
            /*Assert.assert(t.p1 === t.p2 || t.q1 === t.q2)*/
            return;
            //we have trapeze {t.p1,t.p2,q2,q1} here
            //let t.p1,t.p2 be the low base of the trapes
            //where is the closest vertex , on the left side or on the rigth side?
            //if (Point.angle(P.Pnt(t.p2), P.Pnt(t.p1), Q.Pnt(q1)) + Point.angle(P.Pnt(t.p1), Q.Pnt(q1), Q.Pnt(q2)) >= Math.PI)
            //   ProcessLeftSideOfTrapez(ref t.p1, ref t.p2, ref q2, ref q1);
            //else {
            //   SwapPQ();
            //   ProcessLeftSideOfTrapez(ref q2, ref q1, ref t.p1, ref t.p2);
            //   SwapPQ();
            //}
            //return;
        }
        //case 3
        if (angles.a1 <= Math.PI && angles.a2 <= Math.PI && angles.b1 <= Math.PI && angles.b2 <= Math.PI) {
            if (angles.a1 + angles.b1 > Math.PI) {
                if (angles.a1 >= Math.PI / 2)
                    t.p1 = mp;
                else
                    t.q1 = mq;
            }
            else {
                /*Assert.assert(
                  angles.a2 + angles.b2 >= Math.PI - GeomConstants.tolerance,
                )*/
                if (angles.a2 >= Math.PI / 2)
                    t.p2 = mp;
                else
                    t.q2 = mq;
            }
        }
        else {
            if (angles.a1 > Math.PI)
                t.p1 = mp;
            else if (angles.a2 > Math.PI)
                t.p2 = mp;
            else if (angles.b1 > Math.PI)
                t.q1 = mq;
            else {
                /*Assert.assert(angles.b2 > Math.PI)*/
                t.q2 = mq;
            }
        }
    }
    InternalCut(t, mp, mq, a1, a2, b1, b2) {
        let ret = false;
        if (a1 >= Math.PI && a2 >= Math.PI) {
            //Find out who is on the same side from [mq,mp] as Q[0], the next or the prev. Remember that we found the first chunk from Q[0]
            //System.Diagnostics.Debug.WriteLine("cutting P");
            //               if(debug) LayoutAlgorithmSettings.Show(P.Polyline, Q.Polyline, Ls(p1, q1), Ls(p2, q2), Ls(mp, mq));
            const mpp = this.P.pp(mp).point;
            const mqp = this.Q.pp(mq).point;
            const mpnp = this.P.pp(this.P.Next(mp)).point;
            const orientation = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientation(mpp, mqp, this.Q.pp(0).point);
            const nextOrientation = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientation(mpp, mqp, mpnp);
            if (orientation === nextOrientation)
                t.p1 = this.P.Next(mp);
            else
                t.p2 = this.P.Prev(mp);
            ret = true;
        }
        if (b1 >= Math.PI && b2 >= Math.PI) {
            //Find out who is on the same side from [mq,mp] as P[0], the next or the prev. Remember that we found the first chunk from P[0]
            //System.Diagnostics.Debug.WriteLine("cutting Q");
            //               if (debug) LayoutAlgorithmSettings.Show(P.Polyline, Q.Polyline, Ls(p1, q1), Ls(p2, q2), Ls(mp, mq));
            const mpp = this.P.pp(mp).point;
            const mqp = this.Q.pp(mq).point;
            const mqnp = this.Q.pp(this.Q.Next(mq)).point;
            const orientation = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientation(mpp, mqp, this.P.pp(0).point);
            const nextOrientation = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.getTriangleOrientation(mpp, mqp, mqnp);
            if (orientation === nextOrientation)
                t.q2 = this.Q.Next(mq);
            else
                t.q1 = this.Q.Prev(mq);
            ret = true;
        }
        return ret;
    }
    // void ProcessLeftSideOfTrapez(ref number p1, ref number p2, ref number q2, ref number q1) {
    //   //the closest vertex is on the left side
    //   Point pn1 = P.Pnt(p1); Point pn2 = P.Pnt(p2);
    //   Point qn1 = Q.Pnt(q1); Point qn2 = Q.Pnt(q2);
    //  //SugiyamaLayoutSettings.Show(new LineSegment(pn1, pn2), new LineSegment(pn2, qn2), new LineSegment(qn2, qn1), new LineSegment(qn1, pn1));
    //   number ap1 = Point.angle(pn2, pn1, qn1);
    //   number aq1 = Point.angle(pn1, qn1, qn2);
    //   Assert.assert(ap1 + aq1 >= Math.PI);
    //   //the point is on the left side
    //   if (ap1 >= Math.PI / 2 && aq1 >= Math.PI / 2) {
    //       q2 = q1; //the vertices of the left side gives the solution
    //       p2 = p1;
    //   } else if (ap1 < Math.PI / 2) {
    //       q2 = q1;
    //       if (!Point.CanProject(qn1, pn1, pn2))
    //           p1 = p2;
    //   } else { //aq1<Pi/2
    //       p2 = p1;
    //       if (!Point.CanProject(pn1, qn1, qn2))
    //           q1 = q2;
    //   }
    //}
    GetAnglesAtTheMedian(mp, mq, mP, mQ, t) {
        t.a1 = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.anglePCP(mQ, mP, this.P.pnt(this.P.Prev(mp)));
        t.a2 = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.anglePCP(this.P.pnt(this.P.Next(mp)), mP, mQ);
        t.b1 = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.anglePCP(this.Q.pnt(this.Q.Next(mq)), mQ, mP);
        t.b2 = _math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.anglePCP(mP, mQ, this.Q.pnt(this.Q.Prev(mq)));
    }
    // we know here that p1!=p2 and q1!=q2
    OnlyOneChunkContainsExactlyTwoVertices(t, l, angles) {
        const pSideIsShort = t.p2 === this.P.Next(t.p1);
        const qSideIsShort = t.q1 === this.Q.Next(t.q2);
        if (pSideIsShort && !qSideIsShort) {
            this.ProcessShortSide(t, l.mp, l.mq, angles.a1, angles.b1, angles.a2, angles.b2);
            return true;
        }
        if (qSideIsShort && !pSideIsShort) {
            this.SwapEverything(t, l, angles);
            this.ProcessShortSide(t, l.mp, l.mq, angles.a1, angles.b1, angles.a2, angles.b2);
            this.SwapEverything(t, l, angles);
            return true;
        }
        return false;
    }
    SwapEverything(t, l, angles) {
        this.SwapPq();
        let u = t.p2;
        t.p2 = t.q1;
        t.q1 = u;
        u = t.q2;
        t.q2 = t.p1;
        t.p1 = u;
        u = l.mq;
        l.mq = l.mp;
        l.mp = u;
        u = angles.a2;
        angles.a2 = angles.b1;
        angles.b1 = u;
        u = angles.b2;
        angles.b2 = angles.a1;
        angles.a1 = u;
    }
    ProcessShortSide(t, mp, mq, a1, b1, a2, b2) {
        //case 2.1
        if (mp === t.p2)
            this.ProcessSide(t, mq, a1, b1, b2);
        else {
            if (a2 <= Math.PI) {
                if (a2 + b2 >= Math.PI) {
                    if (a2 >= Math.PI / 2)
                        t.p2 = t.p1;
                    else
                        t.q2 = mq;
                }
                else {
                    if (b1 >= Math.PI / 2)
                        t.q1 = mq;
                    else if (a2 < b2) {
                        //SugiyamaLayoutSettings.Show(new LineSegment(P.Pnt(p2), Q.Pnt(q2)), new LineSegment(P.Pnt(p1), Q.Pnt(q1)), new LineSegment(P.Pnt(p1), Q.Pnt(mq)), P.Polyline, Q.Polyline);
                        if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.canProject(this.Q.pnt(mq), this.P.pp(t.p1).point, this.P.pp(t.p2).point))
                            t.q1 = mq;
                        else
                            t.p1 = t.p2;
                    }
                }
            }
            else {
                //a2>Pi , case 2.2
                if (a1 + b1 <= Math.PI)
                    t.p1 = t.p2;
                else
                    t.p2 = t.p1;
            }
        }
    }
    SwapPq() {
        const t = this.P;
        this.P = this.Q;
        this.Q = t;
    }
    ProcessSide(t, mq, a1, b1, b2) {
        //SugiyamaLayoutSettings.Show(new LineSegment(P.Pnt(p2), Q.Pnt(q2)), new LineSegment(P.Pnt(p1), Q.Pnt(q1)),new LineSegment(P.Pnt(p1), Q.Pnt(mq)), P.Polyline, Q.Polyline);
        const mQ = this.Q.pnt(mq);
        if (a1 <= Math.PI) {
            if (a1 + b1 >= Math.PI) {
                if (a1 >= Math.PI / 2)
                    t.p1 = t.p2;
                else
                    t.q1 = mq;
            }
            else if (b2 >= Math.PI / 2)
                t.q2 = mq;
            else if (a1 < b2) {
                if (_math_geometry_point__WEBPACK_IMPORTED_MODULE_1__.Point.canProject(mQ, this.P.pp(t.p1).point, this.P.pp(t.p2).point))
                    t.q2 = mq;
                else
                    t.p2 = t.p1;
            }
        }
        else {
            //a1>Pi , case 2.2
            t.p2 = t.p1;
            if (b1 >= Math.PI)
                t.q1 = mq;
            else if (b2 >= Math.PI)
                t.q2 = mq;
        }
    }
    static OneOfChunksContainsOnlyOneVertex(t, mp, mq, a1, b1) {
        if (t.p1 === t.p2) {
            if (b1 >= Math.PI / 2)
                t.q1 = mq;
            else
                t.q2 = mq;
            return true;
        }
        if (t.q1 === t.q2) {
            if (a1 >= Math.PI / 2)
                t.p1 = mp;
            else
                t.p2 = mp;
            return true;
        }
        return false;
    }
    CalculateLeftTangents() {
        const t = {
            bisectorPivot: null,
            bisectorRay: null,
            p1: 0,
            p2: 0,
            q1: 0,
            q2: 0,
        };
        this.FindDividingBisector(t);
        const pFurthest = this.P.FindTheFurthestVertexFromBisector(t.p1, t.p2, t.bisectorPivot, t.bisectorRay);
        const qFurthest = this.Q.FindTheFurthestVertexFromBisector(t.q2, t.q1, t.bisectorPivot, t.bisectorRay);
        this.upperBranchOnP = false;
        this.lowerBranchOnQ = true;
        this.leftPLeftQ = this.TangentBetweenBranches(pFurthest, t.p1, qFurthest, t.q1); //we need to take maximally wide branches
        this.lowerBranchOnQ = false;
        this.leftPRightQ = this.TangentBetweenBranches(pFurthest, t.p1, qFurthest, t.q2);
    }
    // bool QContains(number x ,number y) {
    //   foreach (Point p of Q.Polyline) {
    //       if (p.x === x && p.y === y)
    //           return true;
    //   }
    //   return false;
    //}
    //bool PContains(number x, number y) {
    //   foreach (Point p of P.Polyline) {
    //       if (p.x === x && p.y === y)
    //           return true;
    //   }
    //   return false;
    //}
    CalculateRightTangents() {
        const t = { bisectorPivot: null, bisectorRay: null, p1: 0, p2: 0, q1: 0, q2: 0 };
        this.FindDividingBisector(t);
        const pFurthest = this.P.FindTheFurthestVertexFromBisector(t.p1, t.p2, t.bisectorPivot, t.bisectorRay);
        const qFurthest = this.Q.FindTheFurthestVertexFromBisector(t.q2, t.q1, t.bisectorPivot, t.bisectorRay);
        //SugiyamaLayoutSettings.Show(ls(p1, q1), ls(p2, q2), ls(pFurthest, qFurthest), P.Polyline, Q.Polyline);
        this.upperBranchOnP = true;
        this.lowerBranchOnQ = true;
        this.rightPLeftQ = this.TangentBetweenBranches(pFurthest, t.p2, qFurthest, t.q1);
        this.lowerBranchOnQ = false;
        this.rightPRightQ = this.TangentBetweenBranches(pFurthest, t.p2, qFurthest, t.q2);
    }
}
//# sourceMappingURL=TangentPair.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/TollFreeVisibilityEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TollFreeVisibilityEdge: () => (/* binding */ TollFreeVisibilityEdge)
/* harmony export */ });
/* harmony import */ var _VisibilityEdge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityEdge.js");

class TollFreeVisibilityEdge extends _VisibilityEdge__WEBPACK_IMPORTED_MODULE_0__.VisibilityEdge {
    static constructorVV(source, target) {
        return new TollFreeVisibilityEdge(source, target, 0);
    }
    constructor(source, target, weight = 0) {
        super(source, target, weight);
    }
}
//# sourceMappingURL=TollFreeVisibilityEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/UnimodalSequence.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnimodalSequence: () => (/* binding */ UnimodalSequence)
/* harmony export */ });
// following https://dl.acm.org/doi/pdf/10.1145/7531.24036?casa_token=eU7GWug-Y98AAAAA%3A4GZQqc2mZBx14I_lLJyQrp6JLhxvxyn9pDaVCAisU2KozgOCW5HbSVYviPBxgN0RWf8GCUshDaW5
// 'Intersection of Convex Objects in Two and Three Dimensions' by Chazelle, and Dobkin
var Behavior;
(function (Behavior) {
    Behavior[Behavior["Increasing"] = 0] = "Increasing";
    Behavior[Behavior["Decreasing"] = 1] = "Decreasing";
    Behavior[Behavior["Extremum"] = 2] = "Extremum";
})(Behavior || (Behavior = {}));
// A real valued function f defined on
// the integers 0, 1, . . . , n-1 is said to be unimodal if there exists an integer m such that
// f is strictly increasing (respectively, decreasing) on [ 0, m] and
// decreasing (respectively, increasing) on [m + 1, n-1]
// No three sequential elements have the same value
class UnimodalSequence {
    // the sequence values
    get Sequence() {
        return this.f;
    }
    set Sequence(value) {
        this.f = value;
    }
    // the length of the sequence: the sequence starts from 0
    get Length() {
        return this.length;
    }
    set Length(value) {
        this.length = value;
    }
    constructor(sequenceDelegate, length) {
        this.f = sequenceDelegate;
        this.length = length;
    }
    FindMinimum() {
        // find out first that the minimum is inside of the domain
        let a = 0;
        let b = this.length - 1;
        let m = a + Math.floor((b - a) / 2);
        const valAtM = this.f(m);
        if (valAtM >= this.f(0) && valAtM >= this.f(this.length - 1))
            return this.f(0) < this.f(this.length - 1) ? 0 : this.length - 1;
        while (b - a > 1) {
            m = a + Math.floor((b - a) / 2);
            switch (this.BehaviourAtIndex(m)) {
                case Behavior.Decreasing:
                    a = m;
                    break;
                case Behavior.Increasing:
                    b = m;
                    break;
                case Behavior.Extremum:
                    return m;
            }
        }
        return a === b ? a : this.f(a) <= this.f(b) ? a : b;
    }
    BehaviourAtIndex(m) {
        const seqAtM = this.f(m);
        if (m === 0) {
            const seqAt1 = this.f(1);
            if (seqAt1 === seqAtM) {
                return Behavior.Extremum;
            }
            return seqAt1 > seqAtM ? Behavior.Increasing : Behavior.Decreasing;
        }
        if (m === this.length - 1) {
            const seqAt1 = this.f(this.length - 2);
            if (seqAt1 === seqAtM) {
                return Behavior.Extremum;
            }
            return seqAt1 > seqAtM ? Behavior.Decreasing : Behavior.Increasing;
        }
        const delLeft = seqAtM - this.f(m - 1);
        const delRight = this.f(m + 1) - seqAtM;
        if (delLeft * delRight <= 0) {
            return Behavior.Extremum;
        }
        return delLeft > 0 ? Behavior.Increasing : Behavior.Decreasing;
    }
    FindMaximum() {
        // find out first that the maximum is inside of the domain
        let a = 0;
        let b = this.length - 1;
        let m = a + Math.floor((b - a) / 2);
        const valAtM = this.f(m);
        if (valAtM <= this.f(0) && valAtM <= this.f(this.length - 1)) {
            return this.f(0) > this.f(this.length - 1) ? 0 : this.length - 1;
        }
        while (b - a > 1) {
            m = a + Math.floor((b - a) / 2);
            switch (this.BehaviourAtIndex(m)) {
                case Behavior.Decreasing:
                    b = m;
                    break;
                case Behavior.Increasing:
                    a = m;
                    break;
                case Behavior.Extremum:
                    return m;
            }
        }
        return a === b ? a : this.f(a) >= this.f(b) ? a : b;
    }
}
//# sourceMappingURL=UnimodalSequence.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/VisibilityEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VisibilityEdge: () => (/* binding */ VisibilityEdge)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");


// import {Assert} from '../../utils/assert'
// an edge connecting two VisibilityVertices
class VisibilityEdge {
    static closeuv(s, t) {
        return _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(s.point, VisibilityEdge.u, 0.1) && _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.closeDistEps(t.point, VisibilityEdge.v, 0.1);
    }
    constructor(s, t, weight = 1) {
        this.LengthMultiplier = 1;
        // Assert.assert(!source.point.equal(target.point), 'Self-edges are not allowed')
        // Assert.assert(!(VisibilityEdge.closeuv(s, t) || VisibilityEdge.closeuv(t, s)))
        this.Source = s;
        this.Target = t;
        this.Weight = weight;
    }
    // edge source point
    get SourcePoint() {
        return this.Source.point;
    }
    // edge target point
    get TargetPoint() {
        return this.Target.point;
    }
    get Length() {
        return this.SourcePoint.sub(this.TargetPoint).length * this.LengthMultiplier;
    }
    toString() {
        return typescript_string_operations__WEBPACK_IMPORTED_MODULE_1__.String.Format('{0}->{1} ({2})', this.Source, this.Target, this.Weight);
    }
    ReversedClone() {
        return new VisibilityEdge(this.Target, this.Source);
    }
    Clone() {
        return new VisibilityEdge(this.Source, this.Target);
    }
}
VisibilityEdge.u = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(545.833, 840.458);
VisibilityEdge.v = new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(606.1667261889578, 786.2917261889578);
VisibilityEdge.DefaultWeight = 1;
//# sourceMappingURL=VisibilityEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/VisibilityGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VisibilityGraph: () => (/* binding */ VisibilityGraph)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");
/* harmony import */ var _utils_PointMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointMap.js");
/* harmony import */ var _VisibilityEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityEdge.js");
/* harmony import */ var _VisibilityVertex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/routing/visibility/VisibilityVertex.js");




class VisibilityGraph {
    constructor() {
        this.activeVertices = new Set();
        // the default is just to return a new VisibilityVertex
        this.VertexFactory = (p) => new _VisibilityVertex__WEBPACK_IMPORTED_MODULE_3__.VisibilityVertex(p);
        this.pointToVertexMap = new _utils_PointMap__WEBPACK_IMPORTED_MODULE_1__.PointMap();
    }
    *edges_() {
        for (const u of this.pointToVertexMap.values()) {
            for (const e of u.OutEdges)
                yield e;
        }
    }
    get Edges() {
        return this.edges_();
    }
    ClearPrevEdgesTable() {
        for (const v of this.activeVertices)
            v.prevEdge = null;
        this.activeVertices.clear();
    }
    ShrinkLengthOfPrevEdge(v, lengthMultiplier) {
        v.prevEdge.LengthMultiplier = lengthMultiplier;
    }
    // needed for shortest path calculations
    PreviosVertex(v) {
        const prev = v.prevEdge;
        if (!prev)
            return null;
        if (prev.Source === v) {
            return prev.Target;
        }
        return prev.Source;
    }
    SetPreviousEdge(v, e) {
        /*Assert.assert(v === e.Source || v === e.Target)*/
        this.activeVertices.add(v);
        v.prevEdge = e;
    }
    //  static GetVisibilityGraphForShortestPath(pathStart: Point, pathEnd: Point, obstacles: Array<Polyline>, /* out */sourceVertex: VisibilityVertex, /* out */targetVertex: VisibilityVertex): VisibilityGraph {
    //      let holes = new Array<Polyline>(VisibilityGraph.OrientHolesClockwise(obstacles));
    //      let visibilityGraph = VisibilityGraph.CalculateGraphOfBoundaries(holes);
    //      let polygons = holes.Select(() => {  }, new Polygon(holes)).ToList();
    //      TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);
    //      PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathStart, VisibilityKind.Tangent, /* out */sourceVertex);
    //      PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathEnd, VisibilityKind.Tangent, /* out */targetVertex);
    //      return visibilityGraph;
    //  }
    //  //  Calculates the tangent visibility graph
    //  public static FillVisibilityGraphForShortestPath(obstacles: Array<Polyline>): VisibilityGraph {
    //      let holes = new Array<Polyline>(VisibilityGraph.OrientHolesClockwise(obstacles));
    //      let visibilityGraph = VisibilityGraph.CalculateGraphOfBoundaries(holes);
    //      let polygons = holes.Select(() => {  }, new Polygon(hole)).ToList();
    //      TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);
    //      return visibilityGraph;
    //  }
    //  static CalculateGraphOfBoundaries(holes: Array<Polyline>): VisibilityGraph {
    //      let graphOfHoleBoundaries = new VisibilityGraph();
    //      for (let polyline: Polyline of holes) {
    //          graphOfHoleBoundaries.AddHole(polyline);
    //      }
    //      return graphOfHoleBoundaries;
    //  }
    AddHole(polyline) {
        let p = polyline.startPoint;
        while (p !== polyline.endPoint) {
            this.AddEdgePlPl(p, p.next);
            p = p.next;
        }
        this.AddEdgePlPl(polyline.endPoint, polyline.startPoint);
    }
    static *OrientHolesClockwise(holes) {
        for (const poly of holes) {
            for (let p = poly.startPoint;; p = p.next) {
                // Find the first non-collinear segments and see which direction the triangle is.
                // If it's consistent with Clockwise, then return the polyline, else return its Reverse.
                const orientation = _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point.getTriangleOrientation(p.point, p.next.point, p.next.next.point);
                if (orientation !== _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Collinear) {
                    yield orientation === _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.TriangleOrientation.Clockwise ? poly : poly.reverse();
                    break;
                }
            }
        }
    }
    //  static CheckThatPolylinesAreConvex(holes: Array<Polyline>) {
    //      for (let polyline of holes) {
    //          VisibilityGraph.CheckThatPolylineIsConvex(polyline);
    //      }
    //  }
    //  static CheckThatPolylineIsConvex(polyline: Polyline) {
    //      Assert.assert(polyline.closed, "Polyline is not closed");
    //      let a: PolylinePoint = polyline.startPoint;
    //      let b: PolylinePoint = a.next;
    //      let c: PolylinePoint = b.next;
    //      let orient: TriangleOrientation = Point.getTriangleOrientation(a.point, b.point, c.point);
    //      while ((c !== polyline.endPoint)) {
    //          a = a.next;
    //          b = b.next;
    //          c = c.next;
    //          let currentOrient = Point.getTriangleOrientation(a.point, b.point, c.point);
    //          if ((currentOrient === TriangleOrientation.Collinear)) {
    //              continue
    //          }
    //          if ((orient === TriangleOrientation.Collinear)) {
    //              orient = currentOrient;
    //          }
    //          else if ((orient !== currentOrient)) {
    //              throw new InvalidOperationException();
    //          }
    //      }
    //      let o = Point.getTriangleOrientation(polyline.endPoint.Point, polyline.startPoint.Point, polyline.startPoint.Next.Point);
    //      if (((o !== TriangleOrientation.Collinear)
    //                  && (o !== orient))) {
    //          throw new InvalidOperationException();
    //      }
    //  }
    //  //  TEST || VERIFY
    //  //  Enumerate all VisibilityEdges in the VisibilityGraph.
    //  public get Edges(): Array<VisibilityEdge> {
    //      return PointToVertexMap.Values.SelectMany(() => {  }, vertex.OutEdges);
    //  }
    //  get PointToVertexMap(): Map<Point, VisibilityVertex> {
    //      return this.pointToVertexMap;
    //  }
    //  get VertexCount(): number {
    //      return this.PointToVertexMap.Count;
    //  }
    //  AddVertex(polylinePoint: PolylinePoint): VisibilityVertex {
    //      return this.AddVertex(polylinePoint.point);
    //  }
    AddVertexP(point) {
        const currentVertex = this.pointToVertexMap.get(point);
        if (currentVertex) {
            return currentVertex;
        }
        const newVertex = this.VertexFactory(point);
        this.pointToVertexMap.set(point, newVertex);
        return newVertex;
    }
    AddVertexV(vertex) {
        /*Assert.assert(
          !this.pointToVertexMap.hasP(vertex.point),
          'A vertex already exists at this location',
        )*/
        this.pointToVertexMap.set(vertex.point, vertex);
    }
    ContainsVertex(point) {
        return this.pointToVertexMap.has(point);
    }
    static AddEdgeVV(source, target) {
        let visEdge;
        if ((visEdge = source.get(target))) {
            return visEdge;
        }
        if (source === target) {
            //Assert.assert(false, 'Self-edges are not allowed')
            throw new Error('Self-edges are not allowed');
        }
        const edge = new _VisibilityEdge__WEBPACK_IMPORTED_MODULE_2__.VisibilityEdge(source, target);
        source.OutEdges.insert(edge);
        target.InEdges.push(edge);
        return edge;
    }
    AddEdgePlPl(source, target) {
        this.AddEdgePP(source.point, target.point);
    }
    static AddEdge(edge) {
        /*Assert.assert(edge.Source !== edge.Target)*/
        edge.Source.OutEdges.insert(edge);
        edge.Target.addInEdge(edge);
    }
    AddEdgeF(source, target, edgeCreator) {
        let sourceV = this.FindVertex(source);
        let targetV = null;
        if (sourceV != null) {
            targetV = this.FindVertex(target);
            if (targetV != null) {
                const edge = sourceV.get(targetV);
                if (edge)
                    return edge;
            }
        }
        if (sourceV == null) {
            // then targetV is also null
            sourceV = this.AddVertexP(source);
            targetV = this.AddVertexP(target);
        }
        else if (targetV == null) {
            targetV = this.AddVertexP(target);
        }
        const edge = edgeCreator(sourceV, targetV);
        sourceV.OutEdges.insert(edge);
        targetV.addInEdge(edge);
        return edge;
    }
    AddEdgePP(source, target) {
        return this.AddEdgeF(source, target, (a, b) => new _VisibilityEdge__WEBPACK_IMPORTED_MODULE_2__.VisibilityEdge(a, b));
    }
    FindVertex(point) {
        return this.pointToVertexMap.get(point);
    }
    Vertices() {
        return this.pointToVertexMap.values();
    }
    RemoveVertex(vertex) {
        // Assert.assert(PointToVertexMap.ContainsKey(vertex.Point), "Cannot find vertex in PointToVertexMap");
        for (const edge of vertex.OutEdges) {
            edge.Target.RemoveInEdge(edge);
        }
        for (const edge of vertex.InEdges) {
            edge.Source.RemoveOutEdge(edge);
        }
        this.pointToVertexMap.deleteP(vertex.point);
    }
    //  RemoveEdge(v1: VisibilityVertex, v2: VisibilityVertex) {
    //      let edge: VisibilityEdge;
    //      if (!v1.TryGetEdge(v2, /* out */edge)) {
    //          return;
    //      }
    //      edge.Source.RemoveOutEdge(edge);
    //      edge.Target.RemoveInEdge(edge);
    //  }
    //  RemoveEdge(p1: Point, p2: Point) {
    //      //  the order of p1 and p2 is not important.
    //      let edge: VisibilityEdge = this.FindEdge(p1, p2);
    //      if ((edge == null )) {
    //          return;
    //      }
    //      edge.Source.RemoveOutEdge(edge);
    //      edge.Target.RemoveInEdge(edge);
    //  }
    //  static FindEdge(edge: VisibilityEdge): VisibilityEdge {
    //      if (edge.Source.TryGetEdge(edge.Target, /* out */edge)) {
    //          return edge;
    //      }
    //      return null;
    //  }
    FindEdgePP(source, target) {
        const sourceV = this.FindVertex(source);
        if (sourceV == null) {
            return null;
        }
        const targetV = this.FindVertex(target);
        if (targetV == null) {
            return null;
        }
        return sourceV.get(targetV);
    }
    static RemoveEdge(edge) {
        edge.Source.RemoveOutEdge(edge);
        // not efficient!
        edge.Target.RemoveInEdge(edge);
    }
    ClearEdges() {
        for (const visibilityVertex of this.Vertices()) {
            visibilityVertex.ClearEdges();
        }
    }
}
//# sourceMappingURL=VisibilityGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/VisibilityKind.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VisibilityKind: () => (/* binding */ VisibilityKind)
/* harmony export */ });
var VisibilityKind;
(function (VisibilityKind) {
    VisibilityKind[VisibilityKind["Regular"] = 0] = "Regular";
    VisibilityKind[VisibilityKind["Tangent"] = 1] = "Tangent";
})(VisibilityKind || (VisibilityKind = {}));
//# sourceMappingURL=VisibilityKind.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/routing/visibility/VisibilityVertex.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VisibilityVertex: () => (/* binding */ VisibilityVertex)
/* harmony export */ });
/* harmony import */ var _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/RBTree/rbTree.js");

class VisibilityVertex {
    get InEdges() {
        return this._inEdges;
    }
    // this collection is sorted by the target point, in the lexicographical order
    get OutEdges() {
        return this._outEdges;
    }
    get Degree() {
        return this._inEdges.length + this.OutEdges.count;
    }
    InEdgesLength() {
        return this._inEdges.length;
    }
    addInEdge(e) {
        this._inEdges.push(e);
    }
    get IsTerminal() {
        return this._isTerminal;
    }
    set IsTerminal(value) {
        this._isTerminal = value;
    }
    get IsShortestPathTerminal() {
        return this._isShortestPathTerminal;
    }
    set IsShortestPathTerminal(value) {
        this._isShortestPathTerminal = value;
    }
    constructor(point) {
        this._inEdges = new Array();
        this._outEdges = new _math_RBTree_rbTree__WEBPACK_IMPORTED_MODULE_0__.RBTree((a, b) => this.Compare(a, b));
        this.point = point;
    }
    toString() {
        return this.point.toString();
    }
    // These iterate from the end of the list because Array.Remove is linear in
    // the number of items, so callers have been optimized where possible to
    // remove only the last or next-to-last edges (but in some cases such as
    // rectilinear, this optimization isn't always possible).
    RemoveOutEdge(edge) {
        this.OutEdges.remove(edge);
    }
    RemoveInEdge(edge) {
        // eslint-disable-next-line for-direction
        const i = this._inEdges.indexOf(edge);
        if (i === -1)
            return;
        const last = this._inEdges.length - 1;
        if (i !== last) {
            this._inEdges[i] = this._inEdges[last];
        }
        this._inEdges.pop();
    }
    // avoiding using delegates in calling RBTree.FindFirst because of the memory allocations
    static FindFirst(tree, targetPoint) {
        return VisibilityVertex.FindFirst_t(tree.root, tree, targetPoint);
    }
    static FindFirst_t(n, tree, targetPoint) {
        if (n === tree.nil) {
            return null;
        }
        let ret = null;
        while (n !== tree.nil) {
            n = n.item.TargetPoint.compareTo(targetPoint) >= 0 ? (ret = n).left : n.right;
        }
        return ret;
    }
    get(target) {
        let node = VisibilityVertex.FindFirst(this.OutEdges, target.point);
        if (node != null) {
            if (node.item.Target === target) {
                return node.item;
            }
        }
        node = VisibilityVertex.FindFirst(target.OutEdges, this.point);
        if (node != null) {
            if (node.item.Target === this) {
                return node.item;
            }
        }
        return null;
    }
    Compare(a, b) {
        return a.TargetPoint.compareTo(b.TargetPoint);
    }
    ClearEdges() {
        this._outEdges.clear();
        this._inEdges = [];
    }
}
//# sourceMappingURL=VisibilityVertex.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/BasicGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicGraph: () => (/* binding */ BasicGraph)
/* harmony export */ });
/* harmony import */ var _basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js");

class BasicGraph extends _basicGraphOnEdges__WEBPACK_IMPORTED_MODULE_0__.BasicGraphOnEdges {
    constructor(edges, numberOfVerts) {
        super();
        this.SetEdges(edges, numberOfVerts);
    }
}
//# sourceMappingURL=BasicGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/BinaryHeapPriorityQueue.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryHeapPriorityQueue: () => (/* binding */ BinaryHeapPriorityQueue)
/* harmony export */ });
// A priority queue based on the binary heap algorithm
class BinaryHeapPriorityQueue {
    get Count() {
        return this.heapSize;
    }
    // the constructor
    // we assume that all integers inserted into the queue will be non-negative and less then n
    constructor(n) {
        this.heapSize = 0;
        this._priors = new Array(n);
        this._heap = new Array(n + 1);
        // because indexing for A starts from 1
        this._reverse_heap = new Array(n);
    }
    SwapWithParent(i) {
        const parent = this._heap[i >> 1];
        this.PutAtI(i >> 1, this._heap[i]);
        this.PutAtI(i, parent);
    }
    Enqueue(o, priority) {
        this.heapSize++;
        let i = this.heapSize;
        this._priors[o] = priority;
        this.PutAtI(i, o);
        while (i > 1 && this._priors[this._heap[i >> 1]] > priority) {
            this.SwapWithParent(i);
            i >>= 1;
        }
    }
    PutAtI(i, h) {
        this._heap[i] = h;
        this._reverse_heap[h] = i;
    }
    // return the first element of the queue and removes it from the queue
    Dequeue() {
        if (this.heapSize === 0) {
            throw new Error();
        }
        const ret = this._heap[1];
        if (this.heapSize > 1) {
            this.PutAtI(1, this._heap[this.heapSize]);
            let i = 1;
            while (true) {
                let smallest = i;
                const l = i << 1;
                if (l <= this.heapSize && this._priors[this._heap[l]] < this._priors[this._heap[i]]) {
                    smallest = l;
                }
                const r = l + 1;
                if (r <= this.heapSize && this._priors[this._heap[r]] < this._priors[this._heap[smallest]]) {
                    smallest = r;
                }
                if (smallest !== i) {
                    this.SwapWithParent(smallest);
                }
                else {
                    break;
                }
                i = smallest;
            }
        }
        this.heapSize--;
        return ret;
    }
    IsEmpty() {
        return this.heapSize === 0;
    }
    DecreasePriority(o, newPriority) {
        // System.Diagnostics.Debug.WriteLine("delcrease "+ o.ToString()+" to "+ newPriority.ToString());
        this._priors[o] = newPriority;
        let i = this._reverse_heap[o];
        while (i > 1) {
            if (this._priors[this._heap[i]] < this._priors[this._heap[i >> 1]]) {
                this.SwapWithParent(i);
            }
            else {
                break;
            }
            i >>= 1;
        }
    }
}
//# sourceMappingURL=BinaryHeapPriorityQueue.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/BinaryHeapWithComparer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryHeapWithComparer: () => (/* binding */ BinaryHeapWithComparer)
/* harmony export */ });
// A priority queue based on the binary heap algorithm.
// This class needs a comparer object to compare elements of the queue.
class BinaryHeapWithComparer {
    *[Symbol.iterator]() {
        for (let i = 1; i <= this.heapSize; i++) {
            yield this.A[i];
        }
    }
    Enqueue(element) {
        let i = this.heapSize + 1;
        this.A[i] = element;
        this.heapSize++;
        let j = i >> 1;
        let son;
        let parent;
        while (i > 1 && this.Less((son = this.A[i]), (parent = this.A[j]))) {
            this.A[j] = son;
            this.A[i] = parent;
            i = j;
            j = i >> 1;
        }
    }
    Dequeue() {
        if (this.heapSize < 1) {
            throw new Error();
        }
        const ret = this.A[1];
        const candidate = this.A[this.heapSize];
        this.heapSize--;
        this.ChangeMinimum(candidate);
        return ret;
    }
    ChangeMinimum(candidate) {
        this.A[1] = candidate;
        let j = 1;
        let i = 2;
        let done = false;
        while (i < this.heapSize && !done) {
            done = true;
            // both sons exist
            const leftSon = this.A[i];
            const rigthSon = this.A[i + 1];
            const compareResult = this.compare(leftSon, rigthSon);
            if (compareResult < 0) {
                // left son is the smallest
                if (this.compare(leftSon, candidate) < 0) {
                    this.A[j] = leftSon;
                    this.A[i] = candidate;
                    done = false;
                    j = i;
                    i = j << 1;
                }
            }
            else {
                // right son in not the greatest
                if (this.compare(rigthSon, candidate) < 0) {
                    this.A[j] = rigthSon;
                    this.A[i + 1] = candidate;
                    done = false;
                    j = i + 1;
                    i = j << 1;
                }
            }
        }
        if (i === this.heapSize) {
            // can we do one more step:
            const leftSon = this.A[i];
            if (this.compare(leftSon, candidate) < 0) {
                this.A[j] = leftSon;
                this.A[i] = candidate;
            }
        }
    }
    get Count() {
        return this.heapSize;
    }
    Less(a, b) {
        return this.compare(a, b) < 0;
    }
    constructor(compare) {
        // array of the heap elems starting at A[1]
        this.heapSize = 0;
        this.A = [];
        this.compare = compare;
    }
    GetMinimum() {
        return this.A[1];
    }
}
//# sourceMappingURL=BinaryHeapWithComparer.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/algorithmData.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlgorithmData: () => (/* binding */ AlgorithmData)
/* harmony export */ });
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attribute.js");
/* harmony import */ var _attributeRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/attributeRegistry.js");


class AlgorithmData extends _attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute {
    clone() {
        throw new Error('Method not implemented.');
    }
    rebind(e) {
        this.entity = e;
        this.bind(_attributeRegistry__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.AlgorithmDataIndex);
    }
    constructor(entity, data = null) {
        super(entity, _attributeRegistry__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.AlgorithmDataIndex);
        this.data = data;
    }
    static getAlgData(attrCont) {
        return attrCont.getAttr(_attributeRegistry__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.AlgorithmDataIndex);
    }
}
//# sourceMappingURL=algorithmData.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/attribute.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* binding */ Attribute)
/* harmony export */ });
/** The class to support attributes of Entity */
class Attribute {
    /** this in the index of where the attribute is positioned in the attribute array of the entity */
    bind(index) {
        if (this.entity)
            this.entity.setAttr(index, this);
    }
    /** The arguments are the underlying entity and the attribute index in the attribute array */
    constructor(entity, index) {
        this.entity = entity;
        this.bind(index);
    }
}
//# sourceMappingURL=attribute.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/attributeRegistry.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeRegistry: () => (/* binding */ AttributeRegistry)
/* harmony export */ });
class AttributeRegistry {
}
AttributeRegistry.GeomObjectIndex = 0;
AttributeRegistry.DrawingObjectIndex = 1;
AttributeRegistry.AlgorithmDataIndex = 2;
AttributeRegistry.ViewerIndex = 3;
//# sourceMappingURL=attributeRegistry.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/basicGraphOnEdges.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicGraphOnEdges: () => (/* binding */ BasicGraphOnEdges),
/* harmony export */   mkGraphOnEdges: () => (/* binding */ mkGraphOnEdges),
/* harmony export */   mkGraphOnEdgesArray: () => (/* binding */ mkGraphOnEdgesArray),
/* harmony export */   mkGraphOnEdgesN: () => (/* binding */ mkGraphOnEdgesN)
/* harmony export */ });
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");

function mkGraphOnEdges(edges) {
    const n = new BasicGraphOnEdges();
    n.SetEdges(edges, BasicGraphOnEdges.vertexCount(edges));
    return n;
}
function mkGraphOnEdgesArray(edges) {
    const n = new BasicGraphOnEdges();
    n.SetEdges(edges, BasicGraphOnEdges.vertexCount(edges));
    return n;
}
function mkGraphOnEdgesN(edges, numberOfVerts) {
    const n = new BasicGraphOnEdges();
    n.SetEdges(edges, numberOfVerts);
    return n;
}
class BasicGraphOnEdges {
    constructor() {
        this.nodeCount = 0;
    }
    *incidentEdges(v) {
        for (const e of this.outEdges[v])
            yield e;
        for (const e of this.inEdges[v])
            yield e;
    }
    static deleteFromArray(arr, obj) {
        const index = arr.indexOf(obj, 0);
        if (index > -1) {
            arr.splice(index, 1);
        }
    }
    // the method is not efficient, takes linear time
    removeEdge(edge) {
        BasicGraphOnEdges.deleteFromArray(this.edges, edge);
        if (edge.source !== edge.target) {
            BasicGraphOnEdges.deleteFromArray(this.outEdges[edge.source], edge);
            BasicGraphOnEdges.deleteFromArray(this.inEdges[edge.target], edge);
        }
        else {
            BasicGraphOnEdges.deleteFromArray(this.selfEdges[edge.source], edge);
        }
    }
    // This method should be static be
    // finds the maximum of sources and targets, and return it incremented by 1
    static vertexCount(edges) {
        let nov = 0;
        for (const ie of edges) {
            if (ie.source >= nov)
                nov = ie.source;
            if (ie.target >= nov)
                nov = ie.target;
        }
        return ++nov;
    }
    // sets edges of the graph
    SetEdges(valEdges, nov) {
        this.edges = valEdges;
        this.nodeCount = nov;
        const outEdgesCounts = new Array(this.nodeCount).fill(0);
        const inEdgesCounts = new Array(this.nodeCount).fill(0);
        const selfEdgesCounts = new Array(this.nodeCount).fill(0);
        this.outEdges = new Array(this.nodeCount);
        this.inEdges = new Array(this.nodeCount);
        this.selfEdges = new Array(this.nodeCount);
        for (const e of this.edges) {
            if (e.source !== e.target) {
                outEdgesCounts[e.source]++;
                inEdgesCounts[e.target]++;
            }
            else {
                selfEdgesCounts[e.source]++;
            }
        }
        //allocate now
        for (let i = 0; i < this.nodeCount; i++) {
            this.outEdges[i] = new Array(outEdgesCounts[i]);
            outEdgesCounts[i] = 0; //used later for edge insertion
            this.inEdges[i] = new Array(inEdgesCounts[i]);
            inEdgesCounts[i] = 0; //used later for edge insertion
            this.selfEdges[i] = new Array(selfEdgesCounts[i]);
            selfEdgesCounts[i] = 0; //used later for edge insertion
        }
        //set the edges now
        for (const e of this.edges) {
            const u = e.source;
            const v = e.target;
            if (u !== v) {
                this.outEdges[u][outEdgesCounts[u]++] = e;
                this.inEdges[v][inEdgesCounts[v]++] = e;
            }
            else {
                this.selfEdges[u][selfEdgesCounts[u]++] = e;
            }
        }
    }
    inEdgesCount(node) {
        return this.inEdges[node].length;
    }
    outEdgesCount(node) {
        return this.outEdges[node].length;
    }
    selfEdgesCount(node) {
        return this.selfEdges[node].length;
    }
    addEdge(e) {
        this.edges.push(e);
        if (e.source !== e.target) {
            this.outEdges[e.source].push(e);
            this.inEdges[e.target].push(e);
        }
        else {
            this.selfEdges[e.source].push(e);
        }
    }
    // We assume that the graph is connected here
    *nodesOfConnectedGraph() {
        if (this.edges.length === 0)
            return;
        const enqueed = new Set();
        const q = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
        let i = this.edges[0].source;
        BasicGraphOnEdges.enqueue(enqueed, q, i);
        yield i;
        while (q.length > 0) {
            i = q.dequeue();
            for (const e of this.outEdges[i]) {
                const s = e.target;
                if (!enqueed.has(s)) {
                    BasicGraphOnEdges.enqueue(enqueed, q, s);
                    yield s;
                }
            }
            for (const e of this.inEdges[i]) {
                const s = e.source;
                if (!enqueed.has(s)) {
                    BasicGraphOnEdges.enqueue(enqueed, q, s);
                    yield s;
                }
            }
        }
    }
    *pred(n) {
        for (const e of this.inEdges[n]) {
            yield e.source;
        }
    }
    *succ(n) {
        for (const e of this.outEdges[n]) {
            yield e.target;
        }
    }
    static enqueue(enqueed, q, i) {
        q.enqueue(i);
        enqueed.add(i);
    }
}
//# sourceMappingURL=basicGraphOnEdges.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/edge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Edge: () => (/* binding */ Edge),
/* harmony export */   ToAncestorEnum: () => (/* binding */ ToAncestorEnum)
/* harmony export */ });
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/entity.js");
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/graph.js");


/** characterize edge if it connects an node and its ancestor */
var ToAncestorEnum;
(function (ToAncestorEnum) {
    /** the source and the target are siblings */
    ToAncestorEnum[ToAncestorEnum["None"] = 0] = "None";
    /** the source is an ancestor of the target */
    ToAncestorEnum[ToAncestorEnum["FromAncestor"] = 1] = "FromAncestor";
    /** the target is an ancestor of the source */
    ToAncestorEnum[ToAncestorEnum["ToAncestor"] = 2] = "ToAncestor";
})(ToAncestorEnum || (ToAncestorEnum = {}));
class Edge extends _entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    constructor(s, t) {
        super();
        this.source = s;
        this.target = t;
        if (s !== t) {
            s.outEdges.add(this);
            t.inEdges.add(this);
        }
        else {
            s.selfEdges.add(this);
        }
    }
    add() {
        if (this.source !== this.target) {
            this.source.outEdges.add(this);
            this.target.inEdges.add(this);
        }
        else {
            this.source.selfEdges.add(this);
        }
    }
    remove() {
        if (this.source !== this.target) {
            this.source.outEdges.delete(this);
            this.target.inEdges.delete(this);
        }
        else {
            this.source.selfEdges.delete(this);
        }
    }
    toString() {
        return '(' + this.source.toString() + '->' + this.target.toString() + ')';
    }
    isInterGraphEdge() {
        return this.source.parent !== this.target.parent;
    }
    EdgeToAncestor() {
        if (this.source instanceof _graph__WEBPACK_IMPORTED_MODULE_1__.Graph) {
            if (this.target.isDescendantOf(this.source))
                return ToAncestorEnum.FromAncestor;
        }
        if (this.target instanceof _graph__WEBPACK_IMPORTED_MODULE_1__.Graph) {
            if (this.source.isDescendantOf(this.target))
                return ToAncestorEnum.ToAncestor;
        }
        return ToAncestorEnum.None;
    }
}
//# sourceMappingURL=edge.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/entity.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Entity: () => (/* binding */ Entity)
/* harmony export */ });
/**
 * Entity is an attribute container with a parent.
 * It also keeps an array of event functions.
 */
class Entity {
    constructor() {
        /** keeps entity attributes: for example, drawing attributes, geometry attributes, etc */
        this.attrs = [];
        this._parent = null;
    }
    /** adds an event function */
    addEvent(event) {
        this.events.push(event);
    }
    /** trying to remove an event function */
    removeEvent(event) {
        const index = this.events.indexOf(event);
        if (index >= 0) {
            this.events = this.events.splice(index, 1);
        }
    }
    /** raises all available events on the given data */
    raiseEvents(data) {
        this.events.forEach((event) => event(data));
    }
    /** removes all the attributes form the entity */
    clearAttr() {
        this.attrs = [];
    }
    /** sets the attribute at the given position */
    setAttr(position, val) {
        this.attrs[position] = val;
    }
    /** gets the attribute at the given position */
    getAttr(position) {
        return this.attrs[position];
    }
    get parent() {
        return this._parent;
    }
    set parent(value) {
        this._parent = value;
    }
    *getAncestors() {
        let p = this.parent;
        while (p != null) {
            yield p;
            p = p.parent;
        }
    }
    /**  Determines if this node is a descendant of the given graph.*/
    isDescendantOf(graph) {
        for (const p of this.getAncestors()) {
            if (p === graph)
                return true;
        }
        return false;
    }
}
//# sourceMappingURL=entity.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/genericBinaryHeapPriorityQueue.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GenericBinaryHeapPriorityQueue: () => (/* binding */ GenericBinaryHeapPriorityQueue)
/* harmony export */ });
/* harmony import */ var typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/typescript-string-operations/dist/index.js");
/* harmony import */ var _utils_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/compare.js");
/* harmony import */ var _genericHeapElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/genericHeapElement.js");
// Generic version priority queue based on the binary heap algorithm where



// the priority of each element is passed as a parameter.
class GenericBinaryHeapPriorityQueue {
    get count() {
        return this.heapSize;
    }
    ContainsElement(key) {
        return this.cache.has(key);
    }
    constructor(compare = _utils_compare__WEBPACK_IMPORTED_MODULE_1__.compareNumbers) {
        this.heapSize = 0;
        this.compare = compare;
        this.cache = new Map();
        this.A = [];
    }
    SwapWithParent(i) {
        const parent = this.A[i >> 1];
        this.PutAtI(i >> 1, this.A[i]);
        this.PutAtI(i, parent);
    }
    Enqueue(element, priority) {
        let i = ++this.heapSize;
        const h = new _genericHeapElement__WEBPACK_IMPORTED_MODULE_2__.GenericHeapElement(i, priority, element);
        this.cache.set(element, h);
        this.A[i] = h;
        while (i > 1 && this.compare(this.A[i >> 1].priority, priority) > 0) {
            this.SwapWithParent(i);
            i >>= 1;
        }
    }
    IsEmpty() {
        return this.heapSize === 0;
    }
    PutAtI(i, h) {
        this.A[i] = h;
        h.indexToA = i;
    }
    Dequeue() {
        if (this.heapSize === 0) {
            throw new Error('dequeue on an empty queue');
        }
        const ret = this.A[1].v;
        this.MoveQueueOneStepForward(ret);
        return ret;
    }
    DequeueAndGetPriority(t) {
        if (this.heapSize === 0) {
            throw new Error('dequeue on an empty queue');
        }
        const ret = this.A[1].v;
        t.priority = this.A[1].priority;
        this.MoveQueueOneStepForward(ret);
        return ret;
    }
    MoveQueueOneStepForward(ret) {
        this.cache.delete(ret);
        this.PutAtI(1, this.A[this.heapSize]);
        let i = 1;
        while (true) {
            let smallest = i;
            const l = i << 1;
            if (l <= this.heapSize && this.compare(this.A[l].priority, this.A[i].priority) < 0) {
                smallest = l;
            }
            const r = l + 1;
            if (r <= this.heapSize && this.compare(this.A[r].priority, this.A[smallest].priority) < 0) {
                smallest = r;
            }
            if (smallest !== i) {
                this.SwapWithParent(smallest);
            }
            else {
                break;
            }
            i = smallest;
        }
        this.heapSize--;
    }
    DecreasePriority(element, newPriority) {
        const h = this.cache.get(element);
        // ignore the element if it is not in the queue
        if (!h) {
            return;
        }
        // var h = cache[element];
        h.priority = newPriority;
        let i = h.indexToA;
        while (i > 1) {
            if (this.compare(this.A[i].priority, this.A[i >> 1].priority) < 0) {
                this.SwapWithParent(i);
            }
            else {
                break;
            }
            i >>= 1;
        }
    }
    *GetEnumerator() {
        for (let i = 1; i <= this.heapSize; i++) {
            yield this.A[i].v;
        }
    }
    //
    Peek(t) {
        if (this.count === 0) {
            t.priority = 0;
            return;
        }
        t.priority = this.A[1].priority;
        return this.A[1].v;
    }
    toString() {
        const sb = new typescript_string_operations__WEBPACK_IMPORTED_MODULE_0__.StringBuilder();
        for (const i of this.A) {
            sb.Append(i + ',');
        }
        return sb.ToString();
    }
}
//# sourceMappingURL=genericBinaryHeapPriorityQueue.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/genericHeapElement.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GenericHeapElement: () => (/* binding */ GenericHeapElement)
/* harmony export */ });
class GenericHeapElement {
    // value
    constructor(index, priority, v) {
        this.indexToA = index;
        this.priority = priority;
        this.v = v;
    }
}
//# sourceMappingURL=genericHeapElement.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/graph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graph: () => (/* binding */ Graph),
/* harmony export */   edgeNodesBelongToSet: () => (/* binding */ edgeNodesBelongToSet),
/* harmony export */   pagerank: () => (/* binding */ pagerank),
/* harmony export */   setNewParent: () => (/* binding */ setNewParent),
/* harmony export */   shallowConnectedComponents: () => (/* binding */ shallowConnectedComponents)
/* harmony export */ });
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/assert.js");
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/edge.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/node.js");
/* harmony import */ var _nodeCollection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/nodeCollection.js");


// import {Assert} from '../utils/assert'



/** This class keeps the connection between the nodes and the edges of the graph. The nodes of a Graph can also be Graphs.  */
class Graph extends _node__WEBPACK_IMPORTED_MODULE_3__.Node {
    remove(node) {
        this.nodeCollection.remove(node);
    }
    /** Removes itself from under the parent.
     *  Also removes all the edges leading out of the graph.
     */
    removeSubgraph() {
        const parent = this.parent;
        if (parent)
            parent.removeNode(this);
        for (const c of this.outGoingEdges()) {
            if (c.attachedAtSource) {
                c.node.removeOutEdge(c.edge);
            }
            else {
                c.node.removeInEdge(c.edge);
            }
        }
    }
    /** returns the objects that show how the edge is adjacent to a node  that is outside of the graph */
    *outGoingEdges() {
        for (const e of this.outEdges) {
            const t = e.target;
            if (!this.isAncestor(t)) {
                yield { edge: e, node: t, attachedAtSource: false };
            }
        }
        for (const e of this.inEdges) {
            const s = e.source;
            if (!this.isAncestor(s)) {
                yield { edge: e, node: s, attachedAtSource: true };
            }
        }
        for (const n of this.nodesBreadthFirst) {
            for (const e of n.outEdges) {
                const t = e.target;
                if (t === this)
                    continue;
                if (!this.isAncestor(t)) {
                    yield { edge: e, node: t, attachedAtSource: false };
                }
            }
            for (const e of n.inEdges) {
                const s = e.source;
                if (s === this)
                    continue;
                if (!this.isAncestor(s)) {
                    yield { edge: e, node: s, attachedAtSource: true };
                }
            }
        }
    }
    isAncestor(entity) {
        for (const ant of entity.getAncestors()) {
            if (ant === this) {
                return true;
            }
        }
        return false;
    }
    /**  Iterates over all connected components of the graph and for each component
     * returns all its nodes with "this" as the parent
     */
    *getClusteredConnectedComponents() {
        const processed = new Set();
        const q = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
        for (const v of this.nodesBreadthFirst) {
            if (processed.has(v))
                continue;
            processed.add(v);
            q.enqueue(v);
            const component = new Set();
            do {
                const u = q.dequeue();
                if (u.parent === this) {
                    component.add(u);
                }
                for (const w of this.reachableFrom(u)) {
                    if (!processed.has(w)) {
                        processed.add(w);
                        q.enqueue(w);
                    }
                }
            } while (q.length > 0);
            yield Array.from(component);
        }
    }
    *reachableFrom(u) {
        for (const e of u.outEdges) {
            yield e.target;
        }
        for (const e of u.inEdges) {
            yield e.source;
        }
        if (u instanceof Graph) {
            yield* u.shallowNodes;
        }
        if (u.parent != this) {
            yield u.parent;
        }
    }
    hasSomeAttrOnIndex(index) {
        for (const n of this.nodesBreadthFirst) {
            if (n.getAttr(index))
                return true;
        }
        for (const n of this.deepEdges) {
            if (n.getAttr(index))
                return true;
        }
        return false;
    }
    *graphs() {
        for (const g of this.nodeCollection.graphs) {
            yield g;
        }
    }
    noEmptySubgraphs() {
        for (const g of this.subgraphsBreadthFirst()) {
            if (g.shallowNodeCount === 0)
                return false;
        }
        return true;
    }
    hasSubgraphs() {
        for (const n of this.shallowNodes)
            if (n instanceof Graph)
                return true;
        return false;
    }
    /** iterates breadth first  */
    *subgraphsBreadthFirst() {
        for (const n of this.nodesBreadthFirst) {
            if (n instanceof Graph)
                yield n;
        }
    }
    isEmpty() {
        return this.shallowNodeCount === 0;
    }
    setEdge(sourceId, targetId) {
        const s = this.nodeCollection.findShallow(sourceId);
        if (s == null)
            return;
        const t = this.nodeCollection.findShallow(targetId);
        if (t == null)
            return;
        return new _edge__WEBPACK_IMPORTED_MODULE_2__.Edge(s, t);
    }
    /** Iterates over the nodes of the current graph but not entering the subgraphs.
     *  Yields the top subgraphs among the nodes as well
     */
    get shallowNodes() {
        return this.nodeCollection.nodesShallow;
    }
    /** Iterates over all the nodes of including the subgraphs.
     * The iteration happens in the breadth first pattern.
     */
    get nodesBreadthFirst() {
        return this.nodesBreadthFirst_();
    }
    /** iterates breadth first  */
    *nodesBreadthFirst_() {
        for (const n of this.nodeCollection.nodesShallow) {
            yield n;
            if (n instanceof Graph) {
                yield* n.nodesBreadthFirst;
            }
        }
    }
    constructor(id = '__graph__') {
        super(id);
        this.nodeCollection = new _nodeCollection__WEBPACK_IMPORTED_MODULE_4__.NodeCollection();
    }
    /**
     * Finds the node with the givin id belonging to a graph or one of its subgraphs.
     */
    findNodeRecursive(id) {
        const n = this.nodeCollection.findShallow(id);
        if (n) {
            return n;
        }
        for (const g of this.shallowNodes) {
            if (g instanceof Graph) {
                const nn = g.findNodeRecursive(id);
                if (nn)
                    return nn;
            }
        }
        return null;
    }
    /** Returns a node belonging to this graph having the same id.
     * If a node with the given id belongs to a subgraph than it would no be returned.
     * To find such a deeper nested node use findNodeRecursive
     */
    findNode(id) {
        return this.nodeCollection.findShallow(id);
    }
    /** iterates over the edges of the graph which adjacent to the nodes of the graph:
     * not iterating over the subgraphs
     */
    get shallowEdges() {
        return this.nodeCollection.edges;
    }
    /** iterates over the edges of the graph including subgraphs */
    get deepEdges() {
        return this.deepEdgesIt();
    }
    *deepEdgesIt() {
        for (const node of this.nodesBreadthFirst) {
            for (const e of node.outEdges) {
                yield e;
            }
            for (const e of node.selfEdges) {
                yield e;
            }
            for (const e of node.inEdges) {
                if (!this.isAncestor(e.source))
                    yield e;
            }
        }
    }
    isConsistent() {
        if (this.parent)
            return this.parent.isConsistent();
        return this.eachNodeIdIsUnique() && this.nodeCollection.isConsistent();
    }
    nodeIsConsistent(n) {
        return this.nodeCollection.nodeIsConsistent(n);
    }
    /** Detouches all the node's edges and removes the node from the graph.
     * This method does not change the parent of the node.
     */
    removeNode(node) {
        for (const e of node.outEdges) {
            e.target.inEdges.delete(e);
        }
        for (const e of node.inEdges) {
            e.source.outEdges.delete(e);
        }
        this.nodeCollection.remove(node);
        for (const p of this.subgraphsBreadthFirst()) {
            p.removeNode(node);
        }
    }
    /** adds a node to the graph */
    addNode(n) {
        _utils_assert__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(this.findNodeRecursive(n.id) == null);
        /*Assert.assert(n.parent == null  || n.parent === this)*/
        n.parent = this;
        this.nodeCollection.addNode(n);
        // Assert.assert(this.isConsistent())
        return n;
    }
    get shallowNodeCount() {
        return this.nodeCollection.nodeShallowCount;
    }
    get nodeCountDeep() {
        let count = this.nodeCollection.size;
        for (const p of this.shallowNodes) {
            if (p instanceof Graph) {
                count += p.nodeCountDeep;
            }
        }
        return count;
    }
    get edgeCount() {
        return this.nodeCollection.edgeCount;
    }
    // If n has an ancestor which is the graph child then return it.
    // Otherwise return null
    liftNode(n) {
        while (n != null && n.parent !== this) {
            n = n.parent;
        }
        return n;
    }
    /** return the number of all edges in the graph, including the subgraphs */
    get deepEdgesCount() {
        let count = 0;
        for (const p of this.nodesBreadthFirst) {
            count += p.outDegree + p.selfDegree;
        }
        return count;
    }
    eachNodeIdIsUnique() {
        const ids = new Set();
        for (const n of this.nodesBreadthFirst) {
            if (ids.has(n.id)) {
                return false;
            }
            ids.add(n.id);
        }
        return true;
    }
    /** returns all the nodes under graph and the edges with at least one end adjacent to the graph */
    *allElements() {
        for (const n of this.allSuccessorsWidthFirst()) {
            yield n;
            for (const e of n.selfEdges) {
                yield e;
            }
            for (const e of n.outEdges) {
                yield e;
            }
            for (const e of n.inEdges) {
                if (!this.isAncestor(e.source)) {
                    yield e;
                }
            }
        }
        yield* this.edges; // uses get edges() of Node
    }
    *allSuccessorsWidthFirst() {
        for (const n of this.shallowNodes) {
            yield n;
        }
        for (const n of this.shallowNodes) {
            if (n instanceof Graph) {
                yield* n.allSuccessorsWidthFirst();
            }
        }
    }
    *allSuccessorsDepthFirst() {
        for (const n of this.shallowNodes) {
            if (n instanceof Graph) {
                yield* n.allSuccessorsDepthFirst();
            }
            yield n;
        }
    }
}
function* shallowConnectedComponents(graph) {
    const enqueueed = new Set();
    const queue = new queue_typescript__WEBPACK_IMPORTED_MODULE_0__.Queue();
    for (const n of graph.shallowNodes) {
        if (enqueueed.has(n))
            continue;
        const nodes = new Array();
        enqueue(n, queue, enqueueed);
        while (queue.length > 0) {
            const s = queue.dequeue();
            nodes.push(s);
            for (const neighbor of neighbors(s)) {
                enqueue(neighbor, queue, enqueueed);
            }
        }
        yield nodes;
    }
    function* neighbors(n) {
        for (const e of n.outEdges)
            yield e.target;
        for (const e of n.inEdges)
            yield e.source;
    }
    function enqueue(n, queue, enqueueed) {
        if (!enqueueed.has(n)) {
            queue.enqueue(n);
            enqueueed.add(n);
        }
    }
}
/** sets a new Graph as the parent of the node */
function setNewParent(newParent, node) {
    if (node.parent) {
        const oldParent = node.parent;
        oldParent.remove(node);
    }
    newParent.addNode(node);
    // let p = newParent
    // while (p.parent) p = p.parent as Graph
    // Assert.assert(p.isConsistent())
}
/** implements the google PageRank.
 * omega is the probability of following a link
 * */
function pagerank(graph, omega) {
    let p = new Map();
    const n = graph.nodeCountDeep;
    let initialVal = 1 / n;
    for (const v of graph.nodesBreadthFirst) {
        p.set(v, initialVal);
    }
    // repeat 50 times
    for (let c = 0; c < 50; c++) {
        initialVal = (1 - omega) / n;
        const q = new Map();
        for (const v of graph.nodesBreadthFirst) {
            q.set(v, initialVal);
        }
        //  forward propagation
        for (const v of graph.nodesBreadthFirst) {
            let qv = q.get(v);
            for (const edge of v.inEdges) {
                const u = edge.source;
                qv += omega * (p.get(u) / u.outDegree);
            }
            q.set(v, qv);
        }
        p = q;
    }
    return p;
}
function edgeNodesBelongToSet(e, s) {
    return s.has(e.source) && s.has(e.target);
}
//# sourceMappingURL=graph.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/label.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Label: () => (/* binding */ Label)
/* harmony export */ });
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/entity.js");

class Label extends _entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    /** parent is the entity having this label */
    toString() {
        return 'label of ' + (this.parent ? this.parent.toString() : 'null');
    }
    constructor(labelledParent) {
        super();
        this.parent = labelledParent;
    }
}
//# sourceMappingURL=label.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/node.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Node: () => (/* binding */ Node)
/* harmony export */ });
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/entity.js");

/** Represent a node of a graph: has id, which is a string, and sets of in/out/self edges */
class Node extends _entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    removeOutEdge(edge) {
        this.outEdges.delete(edge);
    }
    removeInEdge(edge) {
        this.inEdges.delete(edge);
    }
    /** the unique, in the parent graph, id of the node */
    get id() {
        return this._id;
    }
    set id(value) {
        /*Assert.assert(value != null)*/
        this._id = value;
    }
    toString() {
        return this.id;
    }
    constructor(id) {
        super();
        this.inEdges = new Set();
        this.outEdges = new Set();
        this.selfEdges = new Set();
        // Assert.assert(id != null && id.toString() === id)
        this.id = id;
    }
    *_edges() {
        for (const e of this.inEdges)
            yield e;
        for (const e of this.outEdges)
            yield e;
        for (const e of this.selfEdges)
            yield e;
    }
    get edges() {
        return this._edges();
    }
    get outDegree() {
        return this.outEdges.size;
    }
    get inDegree() {
        return this.inEdges.size;
    }
    get selfDegree() {
        return this.selfEdges.size;
    }
    get degree() {
        return this.outDegree + this.inDegree + this.selfDegree;
    }
}
//# sourceMappingURL=node.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/structs/nodeCollection.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeCollection: () => (/* binding */ NodeCollection)
/* harmony export */ });
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/structs/graph.js");

class NodeCollection {
    constructor() {
        this.nodeMap = new Map();
    }
    remove(node) {
        this.nodeMap.delete(node.id);
    }
    get size() {
        return this.nodeMap.size;
    }
    *nodes_() {
        for (const p of this.nodeMap.values())
            yield p;
    }
    *graphs_() {
        for (const n of this.nodes_()) {
            if (n instanceof _graph__WEBPACK_IMPORTED_MODULE_0__.Graph) {
                yield n;
            }
        }
    }
    findShallow(id) {
        return this.nodeMap.get(id);
    }
    get nodesShallow() {
        return this.nodes_();
    }
    get graphs() {
        return this.graphs_();
    }
    *_edges() {
        // if we go over node.inEdges too then not self edges will be reported twice
        for (const node of this.nodeMap.values()) {
            for (const e of node.outEdges) {
                yield e;
            }
            for (const e of node.selfEdges) {
                yield e;
            }
        }
    }
    interGraphEdges() {
        throw new Error('not implemented');
    }
    get nodeShallowCount() {
        return this.nodeMap.size;
    }
    // caution: it is a linear by the number of nodes method
    get edgeCount() {
        let count = 0;
        for (const p of this.nodeMap.values()) {
            count += p.outDegree + p.selfDegree;
        }
        return count;
    }
    /**  returns the edges of shallow nodes */
    get edges() {
        return this._edges();
    }
    addNode(node) {
        this.nodeMap.set(node.id, node);
    }
    nodeIsConsistent(n) {
        for (const e of n.outEdges) {
            if (e.source !== n) {
                return false;
            }
            if (e.source === e.target) {
                return false;
            }
        }
        for (const e of n.inEdges) {
            if (e.target !== n) {
                return false;
            }
            if (e.source === e.target) {
                return false;
            }
        }
        for (const e of n.selfEdges) {
            if (e.target !== e.source) {
                return false;
            }
            if (e.source !== n) {
                return false;
            }
        }
        return true;
    }
    isConsistent() {
        for (const node of this.nodeMap.values()) {
            if (!this.nodeIsConsistent(node)) {
                return false;
            }
        }
        return true;
    }
}
//# sourceMappingURL=nodeCollection.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/IntPair.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IntPair: () => (/* binding */ IntPair)
/* harmony export */ });
// represents the minimal int->int edge
class IntPair {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    get source() {
        return this.x;
    }
    get target() {
        return this.y;
    }
    isDiagonal() {
        return this.x === this.y;
    }
}
//# sourceMappingURL=IntPair.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/IntPairMap.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IntPairMap: () => (/* binding */ IntPairMap)
/* harmony export */ });
/* harmony import */ var _IntPair__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");

class IntPairMap {
    isEmpty() {
        if (this.arrayOfMaps.length === 0)
            return true;
        for (const t of this.arrayOfMaps) {
            if (t.size > 0) {
                return false;
            }
        }
        return true;
    }
    set(x, y, v) {
        let m = this.arrayOfMaps[x];
        if (m === undefined)
            this.arrayOfMaps[x] = m = new Map();
        m.set(y, v);
    }
    setPair(p, v) {
        this.set(p.x, p.y, v);
    }
    delete(x, y) {
        if (x < 0 || x >= this.arrayOfMaps.length) {
            return;
        }
        const m = this.arrayOfMaps[x];
        if (m === undefined)
            return;
        m.delete(y);
        if (m.size === 0)
            this.arrayOfMaps[x] = undefined;
    }
    has(x, y) {
        if (x < 0 || x >= this.arrayOfMaps.length) {
            return false;
        }
        const m = this.arrayOfMaps[x];
        if (m === undefined)
            return false;
        return m.has(y);
    }
    get(x, y) {
        if (x < 0 || x >= this.arrayOfMaps.length) {
            return null;
        }
        const m = this.arrayOfMaps[x];
        if (m === undefined)
            return null;
        return m.get(y);
    }
    getI(p) {
        return this.get(p.x, p.y);
    }
    /** n is the maximum of (x + 1) where (x, *) runs over the keys  */
    constructor() {
        this.arrayOfMaps = new Array();
    }
    *keys() {
        for (let i = 0; i < this.arrayOfMaps.length; i++) {
            const map = this.arrayOfMaps[i];
            if (map === undefined)
                continue;
            for (const p of map) {
                yield new _IntPair__WEBPACK_IMPORTED_MODULE_0__.IntPair(i, p[0]);
            }
        }
    }
    *keyValues() {
        for (let i = 0; i < this.arrayOfMaps.length; i++) {
            const map = this.arrayOfMaps[i];
            if (map === undefined)
                continue;
            for (const p of map) {
                yield [new _IntPair__WEBPACK_IMPORTED_MODULE_0__.IntPair(i, p[0]), p[1]];
            }
        }
    }
    *values() {
        for (let i = 0; i < this.arrayOfMaps.length; i++) {
            const map = this.arrayOfMaps[i];
            if (map === undefined)
                continue;
            for (const p of map) {
                yield p[1];
            }
        }
    }
    get size() {
        let r = 0;
        for (let i = 0; i < this.arrayOfMaps.length; i++) {
            const map = this.arrayOfMaps[i];
            if (map === undefined)
                continue;
            r += map.size;
        }
        return r;
    }
}
//# sourceMappingURL=IntPairMap.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/IntPairSet.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IntPairSet: () => (/* binding */ IntPairSet)
/* harmony export */ });
/* harmony import */ var _IntPair__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/IntPair.js");

class IntPairSet {
    has(p) {
        return this.hasxy(p.x, p.y);
    }
    remove(p) {
        if (p.x < 0 || p.x >= this.arrayOfSets.length) {
            return;
        }
        return this.arrayOfSets[p.x].delete(p.y);
    }
    hasxy(x, y) {
        if (x < 0 || x >= this.arrayOfSets.length) {
            return false;
        }
        const s = this.arrayOfSets[x];
        return s !== undefined && s.has(y);
    }
    constructor() {
        this.arrayOfSets = new Array();
    }
    static mk(ps) {
        const r = new IntPairSet();
        for (const p of ps)
            r.add(p);
        return r;
    }
    *values() {
        for (let i = 0; i < this.arrayOfSets.length; i++) {
            const arr = this.arrayOfSets[i];
            if (!arr)
                continue;
            for (const j of arr.values())
                yield new _IntPair__WEBPACK_IMPORTED_MODULE_0__.IntPair(i, j);
        }
    }
    add(p) {
        let s = this.arrayOfSets[p.x];
        if (s == null) {
            this.arrayOfSets[p.x] = s = new Set();
        }
        s.add(p.y);
    }
    addNN(x, y) {
        let s = this.arrayOfSets[x];
        if (s == null) {
            this.arrayOfSets[x] = s = new Set();
        }
        s.add(y);
    }
    clear() {
        for (const s of this.arrayOfSets) {
            if (s)
                s.clear();
        }
    }
}
//# sourceMappingURL=IntPairSet.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/PointMap.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointMap: () => (/* binding */ PointMap)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");

class PointMap {
    deleteP(point) {
        return this.delete(point.x, point.y);
    }
    clear() {
        this.m.clear();
    }
    get size() {
        return this.m.size;
    }
    setxy(x, y, v) {
        this.m.set(getKey(x, y), v);
    }
    set(p, v) {
        this.setxy(p.x, p.y, v);
    }
    delete(x, y) {
        return this.m.delete(getKey(x, y));
    }
    hasxy(x, y) {
        return this.m.has(getKey(x, y));
    }
    has(p) {
        return this.hasxy(p.x, p.y);
    }
    getxy(x, y) {
        return this.m.get(getKey(x, y));
    }
    get(p) {
        return this.getxy(p.x, p.y);
    }
    constructor() {
        this.m = new Map();
    }
    *keys() {
        for (const p of this.m.keys()) {
            const parts = p.split(',');
            yield new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(Number(parts[0]), Number(parts[1]));
        }
    }
    *[Symbol.iterator]() {
        for (const [p, v] of this.m) {
            const parts = p.split(',');
            yield [new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(Number(parts[0]), Number(parts[1])), v];
        }
    }
    *values() {
        yield* this.m.values();
    }
}
function getKey(x, y) {
    return x.toString() + ',' + y.toString();
}
//# sourceMappingURL=PointMap.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/PointSet.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointSet: () => (/* binding */ PointSet)
/* harmony export */ });
/* harmony import */ var _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/point.js");

class PointSet {
    delete(point) {
        return this.deletexy(point.x, point.y);
    }
    clear() {
        this.mapOfSets.clear();
        this.size_ = 0;
    }
    get size() {
        return this.size_;
    }
    static mk(points) {
        const ret = new PointSet();
        for (const p of points) {
            ret.add(p);
        }
        return ret;
    }
    addxy(x, y) {
        let m = this.mapOfSets.get(x);
        if (m == null)
            this.mapOfSets.set(x, (m = new Set()));
        if (!m.has(y)) {
            this.size_++;
        }
        m.add(y);
    }
    add(p) {
        this.addxy(p.x, p.y);
        return this;
    }
    deletexy(x, y) {
        const m = this.mapOfSets.get(x);
        if (m != null) {
            if (m.delete(y)) {
                this.size_--;
                return true;
            }
        }
        return false;
    }
    hasxy(x, y) {
        return this.mapOfSets.has(x) && this.mapOfSets.get(x).has(y);
    }
    has(p) {
        return this.hasxy(p.x, p.y);
    }
    constructor() {
        this.size_ = 0;
        this.mapOfSets = new Map();
    }
    forEach(callbackfn, thisArg) {
        for (const p of this) {
            callbackfn(p, p, thisArg);
        }
    }
    *entries() {
        for (const p of this) {
            yield [p, p];
        }
    }
    keys() {
        return this.values();
    }
    *values() {
        for (const p of this.mapOfSets) {
            for (const yV of p[1]) {
                yield new _math_geometry_point__WEBPACK_IMPORTED_MODULE_0__.Point(p[0], yV);
            }
        }
    }
    [(Symbol.toStringTag, Symbol.iterator)]() {
        return this.values();
    }
}
//# sourceMappingURL=PointSet.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/RealNumberSpan.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RealNumberSpan: () => (/* binding */ RealNumberSpan)
/* harmony export */ });
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");

// this class behaves like one dimensional bounding box
class RealNumberSpan {
    constructor() {
        this.isEmpty = true;
    }
    AddValue(x) {
        if (this.isEmpty) {
            this.max = x;
            this.min = x;
            this.isEmpty = false;
        }
        else if (x < this.min) {
            this.min = x;
        }
        else if (x > this.max) {
            this.max = x;
        }
    }
    get length() {
        return this.max - this.min;
    }
    // 0  if value is close to zero;
    // 1  if value is strictly greater than zero;
    // -1 if value is strictly lower than zero;
    static sign(value) {
        return value > _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon ? 1 : value < -_math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon ? -1 : 0;
    }
}
//# sourceMappingURL=RealNumberSpan.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/algorithm.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Algorithm: () => (/* binding */ Algorithm)
/* harmony export */ });
class Algorithm {
    ProgressStep() {
        // todo: Implement
    }
    constructor(cancelToken) {
        this.cancelToken = cancelToken;
    }
}
//# sourceMappingURL=algorithm.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/assert.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Assert: () => (/* binding */ Assert)
/* harmony export */ });
class Assert {
    static assert(p, s = null) {
        if (!p) {
            if (s != null) {
                console.log(s);
                throw new Error(s);
            }
            throw new Error('condition does not hold');
        }
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/cancelToken.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CancelToken: () => (/* binding */ CancelToken)
/* harmony export */ });
// a place holder for the cancelled flag
class CancelToken {
    throwIfCanceled() {
        throw new Error('Algorithm was cancelled');
    }
    // Set this flag to true when you want to cancel the layout.
    get canceled() {
        return this.canceled_;
    }
    set canceled(value) {
        this.canceled_ = value;
    }
}
//# sourceMappingURL=cancelToken.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/compare.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeDistEps: () => (/* binding */ closeDistEps),
/* harmony export */   compareBooleans: () => (/* binding */ compareBooleans),
/* harmony export */   compareNumbers: () => (/* binding */ compareNumbers),
/* harmony export */   compareNumbersDistEps: () => (/* binding */ compareNumbersDistEps),
/* harmony export */   comparePointsXY: () => (/* binding */ comparePointsXY),
/* harmony export */   comparePointsYFirst: () => (/* binding */ comparePointsYFirst),
/* harmony export */   greaterDistEps: () => (/* binding */ greaterDistEps),
/* harmony export */   lessDistEps: () => (/* binding */ lessDistEps)
/* harmony export */ });
/* harmony import */ var _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/geomConstants.js");

function compareBooleans(a, b) {
    // return a - b
    return (a ? 1 : 0) - (b ? 1 : 0);
}
function compareNumbers(a, b) {
    const t = a - b;
    return t < 0 ? -1 : t === 0 ? 0 : 1;
}
function comparePointsYFirst(a, b) {
    const cmp = compareNumbers(a.y, b.y);
    return cmp ? cmp : compareNumbers(a.x, b.x);
}
function comparePointsXY(a, b) {
    const cmp = compareNumbers(a.x, b.x);
    return cmp ? cmp : compareNumbers(a.y, b.y);
}
function closeDistEps(a, b) {
    const d = a - b;
    return -_math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon <= d && d <= _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon;
}
/** return true iff a >= b + GeomConstants.distanceEpsilon */
function greaterDistEps(a, b) {
    return compareNumbersDistEps(a, b) > 0;
}
/** return true iff a <= b - GeomConstants.distanceEpsilon */
function lessDistEps(a, b) {
    return compareNumbersDistEps(a, b) < 0;
}
/** returns -1 when a-b <= - GeomConstants.distanceEpsilon
 * returns 1 when a-b >=  GeomConstants.distanceEpsilon
 * return 0 otherwise
 */
function compareNumbersDistEps(a, b) {
    const c = a - b;
    // The <= and >= here complement the < and > in Close(double, double).
    if (c <= -_math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon) {
        return -1;
    }
    if (c >= _math_geometry_geomConstants__WEBPACK_IMPORTED_MODULE_0__.GeomConstants.distanceEpsilon) {
        return 1;
    }
    return 0;
}
//# sourceMappingURL=compare.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/copy.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyTo: () => (/* binding */ copyTo)
/* harmony export */ });
function copyTo(s, t) {
    for (let i = 0; i < s.length; i++)
        t[i] = s[i];
}
//# sourceMappingURL=copy.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/pointPairMap.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointPairMap: () => (/* binding */ PointPairMap)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/pointPair.js");


class PointPairMap {
    constructor() {
        this.m = new Map();
    }
    clear() {
        this.m.clear();
    }
    get size() {
        return this.m.size;
    }
    set(pp, v) {
        this.m.set(getKey(pp), v);
    }
    delete(pp) {
        this.m.delete(getKey(pp));
    }
    has(pp) {
        return this.m.has(getKey(pp));
    }
    getPP(p, q) {
        return this.get(new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_1__.PointPair(p, q));
    }
    get(pp) {
        return this.m.get(getKey(pp));
    }
    *keys() {
        for (const sKey of this.m.keys()) {
            const pp = getPP(sKey);
            yield pp;
        }
    }
    *[Symbol.iterator]() {
        for (const [x, t] of this.m) {
            yield [getPP(x), t];
        }
    }
    *values() {
        yield* this.m.values();
    }
}
function getPP(sKey) {
    const pointString = sKey.split(' ');
    const firstS = pointString[0];
    const secondS = pointString[1];
    // Remove the parentheses and split by comma
    let parts = firstS.split(',');
    // Convert the parts to numbers
    const first = new ___WEBPACK_IMPORTED_MODULE_0__.Point(Number(parts[0]), Number(parts[1]));
    parts = secondS.split(',');
    const second = new ___WEBPACK_IMPORTED_MODULE_0__.Point(Number(parts[0]), Number(parts[1]));
    const pp = new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_1__.PointPair(first, second);
    return pp;
}
function getKeyPP(first, second) {
    return [localToString(first), localToString(second)].sort().join(' ');
}
function getKey(pp) {
    return getKeyPP(pp.first, pp.second);
}
function localToString(p) {
    return p.x.toString() + ',' + p.y.toString();
}
//# sourceMappingURL=pointPairMap.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/random.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initRandom: () => (/* binding */ initRandom),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   randomInt: () => (/* binding */ randomInt)
/* harmony export */ });
/* harmony import */ var reliable_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/reliable-random/dist/index.esm.js");
// if max is an integer then returns random in the range [0, max-1]

let generator;
function randomInt(max) {
    if (generator == null) {
        generator = new reliable_random__WEBPACK_IMPORTED_MODULE_0__.Random(0, 0);
    }
    return generator.randint(max);
}
function initRandom(seed) {
    generator = new reliable_random__WEBPACK_IMPORTED_MODULE_0__.Random(seed, 0);
}
function random() {
    if (generator == null) {
        generator = new reliable_random__WEBPACK_IMPORTED_MODULE_0__.Random(0, 0);
    }
    return generator.random();
}
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "./node_modules/@msagl/core/dist/utils/setOperations.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRange: () => (/* binding */ addRange),
/* harmony export */   addToMapOfArrays: () => (/* binding */ addToMapOfArrays),
/* harmony export */   addToMapOfSets: () => (/* binding */ addToMapOfSets),
/* harmony export */   addToPointMapTuple: () => (/* binding */ addToPointMapTuple),
/* harmony export */   addToPointPairMap: () => (/* binding */ addToPointPairMap),
/* harmony export */   flattenArray: () => (/* binding */ flattenArray),
/* harmony export */   insertRange: () => (/* binding */ insertRange),
/* harmony export */   removeFromArray: () => (/* binding */ removeFromArray),
/* harmony export */   removeFromPointPairMap: () => (/* binding */ removeFromPointPairMap),
/* harmony export */   removeFromPointPairMapTuple: () => (/* binding */ removeFromPointPairMapTuple),
/* harmony export */   setIntersection: () => (/* binding */ setIntersection),
/* harmony export */   setIntersectionOfArray: () => (/* binding */ setIntersectionOfArray),
/* harmony export */   setsAreEqual: () => (/* binding */ setsAreEqual),
/* harmony export */   substractPointSets: () => (/* binding */ substractPointSets),
/* harmony export */   substractSets: () => (/* binding */ substractSets),
/* harmony export */   uniteSets: () => (/* binding */ uniteSets)
/* harmony export */ });
/* harmony import */ var _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/math/geometry/pointPair.js");
/* harmony import */ var _PointSet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/utils/PointSet.js");


function substractSets(a, b) {
    const ret = new Set();
    for (const u of a) {
        if (!b.has(u))
            ret.add(u);
    }
    return ret;
}
function substractPointSets(a, b) {
    const ret = new _PointSet__WEBPACK_IMPORTED_MODULE_1__.PointSet();
    for (const u of a) {
        if (!b.has(u))
            ret.add(u);
    }
    return ret;
}
function uniteSets(a, b) {
    const ret = new Set(a);
    for (const v of b) {
        ret.add(v);
    }
    return ret;
}
function addRange(array, addedIterable) {
    for (const t of addedIterable)
        array.push(t);
}
function setIntersection(a, b) {
    const ret = new Set();
    if (a.size < b.size) {
        for (const t of a) {
            if (b.has(t))
                ret.add(t);
        }
    }
    else {
        for (const t of b) {
            if (a.has(t))
                ret.add(t);
        }
    }
    return ret;
}
function setIntersectionOfArray(arr) {
    if (arr.length === 0)
        return new Set();
    let ret = arr[0];
    for (let i = 1; i < arr.length; i++) {
        ret = setIntersection(ret, arr[i]);
    }
    return ret;
}
function insertRange(collection, addedArray) {
    for (const t of addedArray)
        collection.add(t);
}
function setsAreEqual(a, b) {
    if (a.size !== b.size)
        return false;
    for (const u of a)
        if (!b.has(u))
            return false;
    return true;
}
/** return the concatenated array of items */
function flattenArray(arr, callback) {
    const ret = [];
    for (const f of arr) {
        for (const u of callback(f))
            ret.push(u);
    }
    return ret;
}
/** adds val to map.get(key) if the key exists, otherwise creates the key pair and
 * executes the former instruction
 */
function addToMapOfSets(map, key, val) {
    let s = map.get(key);
    if (!s) {
        s = new Set();
        map.set(key, s);
    }
    s.add(val);
}
function addToMapOfArrays(map, key, val) {
    let s = map.get(key);
    if (!s) {
        s = new Array();
        map.set(key, s);
    }
    s.push(val);
}
function addToPointPairMap(map, key, val) {
    let s = map.get(key);
    if (!s) {
        s = new Set();
        map.set(key, s);
    }
    s.add(val);
}
function addToPointMapTuple(map, key, val) {
    addToPointPairMap(map, new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__.PointPair(key[0], key[1]), val);
}
function removeFromPointPairMap(map, key, val) {
    const s = map.get(key);
    if (s)
        s.delete(val);
}
function removeFromPointPairMapTuple(map, key, val) {
    removeFromPointPairMap(map, new _math_geometry_pointPair__WEBPACK_IMPORTED_MODULE_0__.PointPair(key[0], key[1]), val);
}
function removeFromArray(arr, OverlapRemovalNode) {
    const i = arr.findIndex((a) => a === OverlapRemovalNode);
    if (i >= 0) {
        arr.splice(i, 1);
    }
}
//# sourceMappingURL=setOperations.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/arrowTypeEnum.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrowTypeEnum: () => (/* binding */ ArrowTypeEnum)
/* harmony export */ });
var ArrowTypeEnum;
(function (ArrowTypeEnum) {
    ArrowTypeEnum[ArrowTypeEnum["normal"] = 0] = "normal";
    ArrowTypeEnum[ArrowTypeEnum["inv"] = 1] = "inv";
    ArrowTypeEnum[ArrowTypeEnum["dot"] = 2] = "dot";
    ArrowTypeEnum[ArrowTypeEnum["invdot"] = 3] = "invdot";
    ArrowTypeEnum[ArrowTypeEnum["odot"] = 4] = "odot";
    ArrowTypeEnum[ArrowTypeEnum["invodot"] = 5] = "invodot";
    ArrowTypeEnum[ArrowTypeEnum["none"] = 6] = "none";
    ArrowTypeEnum[ArrowTypeEnum["tee"] = 7] = "tee";
    ArrowTypeEnum[ArrowTypeEnum["empty"] = 8] = "empty";
    ArrowTypeEnum[ArrowTypeEnum["invempty"] = 9] = "invempty";
    ArrowTypeEnum[ArrowTypeEnum["diamond"] = 10] = "diamond";
    ArrowTypeEnum[ArrowTypeEnum["odiamond"] = 11] = "odiamond";
    ArrowTypeEnum[ArrowTypeEnum["ediamond"] = 12] = "ediamond";
    ArrowTypeEnum[ArrowTypeEnum["crow"] = 13] = "crow";
    ArrowTypeEnum[ArrowTypeEnum["box"] = 14] = "box";
    ArrowTypeEnum[ArrowTypeEnum["obox"] = 15] = "obox";
    ArrowTypeEnum[ArrowTypeEnum["open"] = 16] = "open";
    ArrowTypeEnum[ArrowTypeEnum["halfopen"] = 17] = "halfopen";
    ArrowTypeEnum[ArrowTypeEnum["vee"] = 18] = "vee";
})(ArrowTypeEnum || (ArrowTypeEnum = {}));
//# sourceMappingURL=arrowTypeEnum.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/color.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color)
/* harmony export */ });
class Color {
    static mkWithKeyword(a, r, g, b, keyword) {
        const ret = new Color(a, r, g, b);
        ret.keyword = keyword;
        return ret;
    }
    static parse(keyword) {
        switch (keyword.toLowerCase()) {
            case 'aliceblue':
                return Color.AliceBlue;
            case 'antiquewhite':
                return Color.AntiqueWhite;
            case 'aqua':
                return Color.Aqua;
            case 'aquamarine':
                return Color.Aquamarine;
            case 'azure':
                return Color.Azure;
            case 'beige':
                return Color.Beige;
            case 'bisque':
                return Color.Bisque;
            case 'black':
                return Color.Black;
            case 'blanchedalmond':
                return Color.BlanchedAlmond;
            case 'blue':
                return Color.Blue;
            case 'blueviolet':
                return Color.BlueViolet;
            case 'brown':
                return Color.Brown;
            case 'burlywood':
                return Color.BurlyWood;
            case 'cadetblue':
                return Color.CadetBlue;
            case 'chartreuse':
                return Color.Chartreuse;
            case 'chocolate':
                return Color.Chocolate;
            case 'coral':
                return Color.Coral;
            case 'cornflowerblue':
                return Color.CornflowerBlue;
            case 'cornsilk':
                return Color.Cornsilk;
            case 'crimson':
                return Color.Crimson;
            case 'cyan':
                return Color.Cyan;
            case 'darkblue':
                return Color.DarkBlue;
            case 'darkcyan':
                return Color.DarkCyan;
            case 'darkgoldenrod':
                return Color.DarkGoldenrod;
            case 'darkgray':
                return Color.DarkGray;
            case 'darkgreen':
                return Color.DarkGreen;
            case 'darkkhaki':
                return Color.DarkKhaki;
            case 'darkmagenta':
                return Color.DarkMagenta;
            case 'darkolivegreen':
                return Color.DarkOliveGreen;
            case 'darkorange':
                return Color.DarkOrange;
            case 'darkorchid':
                return Color.DarkOrchid;
            case 'darkred':
                return Color.DarkRed;
            case 'darksalmon':
                return Color.DarkSalmon;
            case 'darkseagreen':
                return Color.DarkSeaGreen;
            case 'darkslateblue':
                return Color.DarkSlateBlue;
            case 'darkslategray':
                return Color.DarkSlateGray;
            case 'darkturquoise':
                return Color.DarkTurquoise;
            case 'darkviolet':
                return Color.DarkViolet;
            case 'deeppink':
                return Color.DeepPink;
            case 'deepskyblue':
                return Color.DeepSkyBlue;
            case 'dimgray':
                return Color.DimGray;
            case 'dodgerblue':
                return Color.DodgerBlue;
            case 'firebrick':
                return Color.Firebrick;
            case 'floralwhite':
                return Color.FloralWhite;
            case 'forestgreen':
                return Color.ForestGreen;
            case 'fuchsia':
                return Color.Fuchsia;
            case 'gainsboro':
                return Color.Gainsboro;
            case 'ghostwhite':
                return Color.GhostWhite;
            case 'gold':
                return Color.Gold;
            case 'goldenrod':
                return Color.Goldenrod;
            case 'gray':
                return Color.Gray;
            case 'green':
                return Color.Green;
            case 'greenyellow':
                return Color.GreenYellow;
            case 'honeydew':
                return Color.Honeydew;
            case 'hotpink':
                return Color.HotPink;
            case 'indianred':
                return Color.IndianRed;
            case 'indigo':
                return Color.Indigo;
            case 'ivory':
                return Color.Ivory;
            case 'khaki':
                return Color.Khaki;
            case 'lavender':
                return Color.Lavender;
            case 'lavenderblush':
                return Color.LavenderBlush;
            case 'lawngreen':
                return Color.LawnGreen;
            case 'lemonchiffon':
                return Color.LemonChiffon;
            case 'lightblue':
                return Color.LightBlue;
            case 'lightcoral':
                return Color.LightCoral;
            case 'lightcyan':
                return Color.LightCyan;
            case 'lightgoldenrodyellow':
                return Color.LightGoldenrodYellow;
            case 'lightgray':
            case 'lightgrey':
                return Color.LightGray;
            case 'lightgreen':
                return Color.LightGreen;
            case 'lightpink':
                return Color.LightPink;
            case 'lightsalmon':
                return Color.LightSalmon;
            case 'lightseagreen':
                return Color.LightSeaGreen;
            case 'lightskyblue':
                return Color.LightSkyBlue;
            case 'lightslategray':
                return Color.LightSlateGray;
            case 'lightsteelblue':
                return Color.LightSteelBlue;
            case 'lightyellow':
                return Color.LightYellow;
            case 'lime':
                return Color.Lime;
            case 'limegreen':
                return Color.LimeGreen;
            case 'linen':
                return Color.Linen;
            case 'magenta':
                return Color.Magenta;
            case 'maroon':
                return Color.Maroon;
            case 'mediumaquamarine':
                return Color.MediumAquamarine;
            case 'mediumblue':
                return Color.MediumBlue;
            case 'mediumorchid':
                return Color.MediumOrchid;
            case 'mediumpurple':
                return Color.MediumPurple;
            case 'mediumseagreen':
                return Color.MediumSeaGreen;
            case 'mediumslateblue':
                return Color.MediumSlateBlue;
            case 'mediumspringgreen':
                return Color.MediumSpringGreen;
            case 'mediumturquoise':
                return Color.MediumTurquoise;
            case 'mediumvioletred':
                return Color.MediumVioletRed;
            case 'midnightblue':
                return Color.MidnightBlue;
            case 'mintcream':
                return Color.MintCream;
            case 'mistyrose':
                return Color.MistyRose;
            case 'moccasin':
                return Color.Moccasin;
            case 'navajowhite':
                return Color.NavajoWhite;
            case 'navy':
                return Color.Navy;
            case 'oldlace':
                return Color.OldLace;
            case 'olive':
                return Color.Olive;
            case 'olivedrab':
                return Color.OliveDrab;
            case 'orange':
                return Color.Orange;
            case 'orangered':
                return Color.OrangeRed;
            case 'orchid':
                return Color.Orchid;
            case 'palegoldenrod':
                return Color.PaleGoldenrod;
            case 'palegreen':
                return Color.PaleGreen;
            case 'paleturquoise':
                return Color.PaleTurquoise;
            case 'palevioletred':
                return Color.PaleVioletRed;
            case 'papayawhip':
                return Color.PapayaWhip;
            case 'peachpuff':
                return Color.PeachPuff;
            case 'peru':
                return Color.Peru;
            case 'pink':
                return Color.Pink;
            case 'plum':
                return Color.Plum;
            case 'powderblue':
                return Color.PowderBlue;
            case 'purple':
                return Color.Purple;
            case 'red':
                return Color.Red;
            case 'rosybrown':
                return Color.RosyBrown;
            case 'royalblue':
                return Color.RoyalBlue;
            case 'saddlebrown':
                return Color.SaddleBrown;
            case 'salmon':
                return Color.Salmon;
            case 'sandybrown':
                return Color.SandyBrown;
            case 'seagreen':
                return Color.SeaGreen;
            case 'seashell':
                return Color.SeaShell;
            case 'sienna':
                return Color.Sienna;
            case 'silver':
                return Color.Silver;
            case 'skyblue':
                return Color.SkyBlue;
            case 'slateblue':
                return Color.SlateBlue;
            case 'slategray':
                return Color.SlateGray;
            case 'snow':
                return Color.Snow;
            case 'springgreen':
                return Color.SpringGreen;
            case 'steelblue':
                return Color.SteelBlue;
            case 'tan':
                return Color.Tan;
            case 'teal':
                return Color.Teal;
            case 'thistle':
                return Color.Thistle;
            case 'tomato':
                return Color.Tomato;
            case 'transparent':
                return Color.Transparent;
            case 'turquoise':
                return Color.Turquoise;
            case 'violet':
                return Color.Violet;
            case 'wheat':
                return Color.Wheat;
            case 'white':
                return Color.White;
            case 'whitesmoke':
                return Color.WhiteSmoke;
            case 'yellow':
                return Color.Yellow;
            case 'yellowgreen':
                return Color.YellowGreen;
            default:
                return undefined;
        }
    }
    get keyword() {
        return this.keyword_;
    }
    set keyword(value) {
        this.keyword_ = value;
    }
    // constructor with alpha and red, green, bluee components
    constructor(a, r, g, b) {
        this.a = a;
        this.r = r;
        this.g = g;
        this.b = b;
    }
    // opaque color
    static mkRGB(r, g, b) {
        return new Color(255, r, g, b);
    }
    /**  The color opaqueness: changes from 0 to 255 */
    get A() {
        return this.a;
    }
    set A(value) {
        this.a = value;
    }
    /** The red component: changes form 0 to 255 */
    get R() {
        return this.r;
    }
    /** The red component: changes form 0 to 255 */
    set R(value) {
        this.r = value;
    }
    /** The green component: changes form 0 to 255 */
    get G() {
        return this.g;
    }
    /** The red component: changes form 0 to 255 */
    set G(value) {
        this.g = value;
    }
    /** The blue component: changes form 0 to 255 */
    get B() {
        return this.b;
    }
    /** The blue component: changes form 0 to 255 */
    set B(value) {
        this.b = value;
    }
    static Xex(i) {
        const s = i.toString(16);
        if (s.length === 1) {
            return '0' + s;
        }
        return s.substring(s.length - 2, 2);
    }
    static equal(a, b) {
        return a.a === b.a && a.r === b.r && a.b === b.b && a.g === b.g;
    }
    // !=
    toString() {
        return this.keyword
            ? this.keyword
            : '"#' + Color.Xex(this.R) + Color.Xex(this.G) + Color.Xex(this.B) + (this.A === 255 ? '' : Color.Xex(this.A)) + '"';
    }
    //
    static get AliceBlue() {
        return Color.mkWithKeyword(255, 240, 248, 255, 'aliceblue');
    }
    //
    static get AntiqueWhite() {
        return Color.mkWithKeyword(255, 250, 235, 215, 'antiquewhite');
    }
    //
    static get Aqua() {
        return Color.mkWithKeyword(255, 0, 255, 255, 'aqua');
    }
    //
    static get Aquamarine() {
        return Color.mkWithKeyword(255, 127, 255, 212, 'aquamarine');
    }
    //
    static get Azure() {
        return Color.mkWithKeyword(255, 240, 255, 255, 'azure');
    }
    //
    static get Beige() {
        return Color.mkWithKeyword(255, 245, 245, 220, 'beige');
    }
    //
    static get Bisque() {
        return Color.mkWithKeyword(255, 255, 228, 196, 'bisque');
    }
    //
    static get Black() {
        return Color.mkWithKeyword(255, 0, 0, 0, 'black');
    }
    //
    static get BlanchedAlmond() {
        return Color.mkWithKeyword(255, 255, 235, 205, 'blanchedalmond');
    }
    //
    static get Blue() {
        return Color.mkWithKeyword(255, 0, 0, 255, 'blue');
    }
    //
    static get BlueViolet() {
        return Color.mkWithKeyword(255, 138, 43, 226, 'blueviolet');
    }
    //
    static get Brown() {
        return Color.mkWithKeyword(255, 165, 42, 42, 'brown');
    }
    //
    static get BurlyWood() {
        return Color.mkWithKeyword(255, 222, 184, 135, 'burlywood');
    }
    //
    static get CadetBlue() {
        return Color.mkWithKeyword(255, 95, 158, 160, 'cadetblue');
    }
    //
    static get Chartreuse() {
        return Color.mkWithKeyword(255, 127, 255, 0, 'chartreuse');
    }
    //
    static get Chocolate() {
        return Color.mkWithKeyword(255, 210, 105, 30, 'chocolate');
    }
    //
    static get Coral() {
        return Color.mkWithKeyword(255, 255, 127, 80, 'coral');
    }
    //
    static get CornflowerBlue() {
        return Color.mkWithKeyword(255, 100, 149, 237, 'cornflowerblue');
    }
    //
    static get Cornsilk() {
        return Color.mkWithKeyword(255, 255, 248, 220, 'cornsilk');
    }
    //
    static get Crimson() {
        return Color.mkWithKeyword(255, 220, 20, 60, 'crimson');
    }
    //
    static get Cyan() {
        return Color.mkWithKeyword(255, 0, 255, 255, 'cyan');
    }
    //
    static get DarkBlue() {
        return Color.mkWithKeyword(255, 0, 0, 139, 'darkblue');
    }
    //
    static get DarkCyan() {
        return Color.mkWithKeyword(255, 0, 139, 139, 'darkcyan');
    }
    //
    static get DarkGoldenrod() {
        return Color.mkWithKeyword(255, 184, 134, 11, 'darkgoldenrod');
    }
    //
    static get DarkGray() {
        return Color.mkWithKeyword(255, 169, 169, 169, 'darkgray');
    }
    //
    static get DarkGreen() {
        return Color.mkWithKeyword(255, 0, 100, 0, 'darkgreen');
    }
    //
    static get DarkKhaki() {
        return Color.mkWithKeyword(255, 189, 183, 107, 'darkkhaki');
    }
    //
    static get DarkMagenta() {
        return Color.mkWithKeyword(255, 139, 0, 139, 'darkmagenta');
    }
    //
    static get DarkOliveGreen() {
        return Color.mkWithKeyword(255, 85, 107, 47, 'darkolivegreen');
    }
    //
    static get DarkOrange() {
        return Color.mkWithKeyword(255, 255, 140, 0, 'darkorange');
    }
    //
    static get DarkOrchid() {
        return Color.mkWithKeyword(255, 153, 50, 204, 'darkorchid');
    }
    //
    static get DarkRed() {
        return Color.mkWithKeyword(255, 139, 0, 0, 'darkred');
    }
    //
    static get DarkSalmon() {
        return Color.mkWithKeyword(255, 233, 150, 122, 'darksalmon');
    }
    //
    static get DarkSeaGreen() {
        return Color.mkWithKeyword(255, 143, 188, 139, 'darkseagreen');
    }
    //
    static get DarkSlateBlue() {
        return Color.mkWithKeyword(255, 72, 61, 139, 'darkslateblue');
    }
    //
    static get DarkSlateGray() {
        return Color.mkWithKeyword(255, 47, 79, 79, 'darkslategray');
    }
    //
    static get DarkTurquoise() {
        return Color.mkWithKeyword(255, 0, 206, 209, 'darkturquoise');
    }
    //
    static get DarkViolet() {
        return Color.mkWithKeyword(255, 148, 0, 211, 'darkviolet');
    }
    //
    static get DeepPink() {
        return Color.mkWithKeyword(255, 255, 20, 147, 'deeppink');
    }
    //
    static get DeepSkyBlue() {
        return Color.mkWithKeyword(255, 0, 191, 255, 'deepskyblue');
    }
    //
    static get DimGray() {
        return Color.mkWithKeyword(255, 105, 105, 105, 'dimgray');
    }
    //
    static get DodgerBlue() {
        return Color.mkWithKeyword(255, 30, 144, 255, 'dodgerblue');
    }
    //
    static get Firebrick() {
        return Color.mkWithKeyword(255, 178, 34, 34, 'firebrick');
    }
    //
    static get FloralWhite() {
        return Color.mkWithKeyword(255, 255, 250, 240, 'floralwhite');
    }
    //
    static get ForestGreen() {
        return Color.mkWithKeyword(255, 34, 139, 34, 'forestgreen');
    }
    //
    static get Fuchsia() {
        return Color.mkWithKeyword(255, 255, 0, 255, 'fuchsia');
    }
    //
    static get Gainsboro() {
        return Color.mkWithKeyword(255, 220, 220, 220, 'gainsboro');
    }
    //
    static get GhostWhite() {
        return Color.mkWithKeyword(255, 248, 248, 255, 'ghostwhite');
    }
    //
    static get Gold() {
        return Color.mkWithKeyword(255, 255, 215, 0, 'gold');
    }
    //
    static get Goldenrod() {
        return Color.mkWithKeyword(255, 218, 165, 32, 'goldenrod');
    }
    //
    static get Gray() {
        return Color.mkWithKeyword(255, 128, 128, 128, 'gray');
    }
    //
    static get Green() {
        return Color.mkWithKeyword(255, 0, 128, 0, 'green');
    }
    //
    static get GreenYellow() {
        return Color.mkWithKeyword(255, 173, 255, 47, 'greenyellow');
    }
    //
    static get Honeydew() {
        return Color.mkWithKeyword(255, 240, 255, 240, 'honeydew');
    }
    //
    static get HotPink() {
        return Color.mkWithKeyword(255, 255, 105, 180, 'hotpink');
    }
    //
    static get IndianRed() {
        return Color.mkWithKeyword(255, 205, 92, 92, 'indianred');
    }
    //
    static get Indigo() {
        return Color.mkWithKeyword(255, 75, 0, 130, 'indigo');
    }
    //
    static get Ivory() {
        return Color.mkWithKeyword(255, 255, 255, 240, 'ivory');
    }
    //
    static get Khaki() {
        return Color.mkWithKeyword(255, 240, 230, 140, 'khaki');
    }
    //
    static get Lavender() {
        return Color.mkWithKeyword(255, 230, 230, 250, 'lavender');
    }
    //
    static get LavenderBlush() {
        return Color.mkWithKeyword(255, 255, 240, 245, 'lavenderblush');
    }
    //
    static get LawnGreen() {
        return Color.mkWithKeyword(255, 124, 252, 0, 'lawngreen');
    }
    //
    static get LemonChiffon() {
        return Color.mkWithKeyword(255, 255, 250, 205, 'lemonchiffon');
    }
    //
    static get LightBlue() {
        return Color.mkWithKeyword(255, 173, 216, 230, 'lightblue');
    }
    //
    static get LightCoral() {
        return Color.mkWithKeyword(255, 240, 128, 128, 'lightcoral');
    }
    //
    static get LightCyan() {
        return Color.mkWithKeyword(255, 224, 255, 255, 'lightcyan');
    }
    //
    static get LightGoldenrodYellow() {
        return Color.mkWithKeyword(255, 250, 250, 210, 'lightgoldenrodyellow');
    }
    //
    static get LightGray() {
        return Color.mkWithKeyword(255, 211, 211, 211, 'lightgray');
    }
    //
    static get LightGreen() {
        return Color.mkWithKeyword(255, 144, 238, 144, 'lightgreen');
    }
    //
    static get LightPink() {
        return Color.mkWithKeyword(255, 255, 182, 193, 'lightpink');
    }
    //
    static get LightSalmon() {
        return Color.mkWithKeyword(255, 255, 160, 122, 'lightsalmon');
    }
    //
    static get LightSeaGreen() {
        return Color.mkWithKeyword(255, 32, 178, 170, 'lightseagreen');
    }
    //
    static get LightSkyBlue() {
        return Color.mkWithKeyword(255, 135, 206, 250, 'lightskyblue');
    }
    //
    static get LightSlateGray() {
        return Color.mkWithKeyword(255, 119, 136, 153, 'lightslategray');
    }
    //
    static get LightSteelBlue() {
        return Color.mkWithKeyword(255, 176, 196, 222, 'lightsteelblue');
    }
    //
    static get LightYellow() {
        return Color.mkWithKeyword(255, 255, 255, 224, 'lightyellow');
    }
    //
    static get Lime() {
        return Color.mkWithKeyword(255, 0, 255, 0, 'lime');
    }
    //
    static get LimeGreen() {
        return Color.mkWithKeyword(255, 50, 205, 50, 'limegreen');
    }
    //
    static get Linen() {
        return Color.mkWithKeyword(255, 250, 240, 230, 'linen');
    }
    //
    static get Magenta() {
        return Color.mkWithKeyword(255, 255, 0, 255, 'magenta');
    }
    //
    static get Maroon() {
        return Color.mkWithKeyword(255, 128, 0, 0, 'maroon');
    }
    //
    static get MediumAquamarine() {
        return Color.mkWithKeyword(255, 102, 205, 170, 'mediumaquamarine');
    }
    //
    static get MediumBlue() {
        return Color.mkWithKeyword(255, 0, 0, 205, 'mediumblue');
    }
    //
    static get MediumOrchid() {
        return Color.mkWithKeyword(255, 186, 85, 211, 'mediumorchid');
    }
    //
    static get MediumPurple() {
        return Color.mkWithKeyword(255, 147, 112, 219, 'mediumpurple');
    }
    //
    static get MediumSeaGreen() {
        return Color.mkWithKeyword(255, 60, 179, 113, 'mediumseagreen');
    }
    //
    static get MediumSlateBlue() {
        return Color.mkWithKeyword(255, 123, 104, 238, 'mediumslateblue');
    }
    //
    static get MediumSpringGreen() {
        return Color.mkWithKeyword(255, 0, 250, 154, 'mediumspringgreen');
    }
    //
    static get MediumTurquoise() {
        return Color.mkWithKeyword(255, 72, 209, 204, 'mediumturquoise');
    }
    //
    static get MediumVioletRed() {
        return Color.mkWithKeyword(255, 199, 21, 133, 'mediumvioletred');
    }
    //
    static get MidnightBlue() {
        return Color.mkWithKeyword(255, 25, 25, 112, 'midnightblue');
    }
    //
    static get MintCream() {
        return Color.mkWithKeyword(255, 245, 255, 250, 'mintcream');
    }
    //
    static get MistyRose() {
        return Color.mkWithKeyword(255, 255, 228, 225, 'mistyrose');
    }
    //
    static get Moccasin() {
        return Color.mkWithKeyword(255, 255, 228, 181, 'moccasin');
    }
    //
    static get NavajoWhite() {
        return Color.mkWithKeyword(255, 255, 222, 173, 'navajowhite');
    }
    //
    static get Navy() {
        return Color.mkWithKeyword(255, 0, 0, 128, 'navy');
    }
    //
    static get OldLace() {
        return Color.mkWithKeyword(255, 253, 245, 230, 'oldlace');
    }
    //
    static get Olive() {
        return Color.mkWithKeyword(255, 128, 128, 0, 'olive');
    }
    //
    static get OliveDrab() {
        return Color.mkWithKeyword(255, 107, 142, 35, 'olivedrab');
    }
    //
    static get Orange() {
        return Color.mkWithKeyword(255, 255, 165, 0, 'orange');
    }
    //
    static get OrangeRed() {
        return Color.mkWithKeyword(255, 255, 69, 0, 'orangered');
    }
    //
    static get Orchid() {
        return Color.mkWithKeyword(255, 218, 112, 214, 'orchid');
    }
    //
    static get PaleGoldenrod() {
        return Color.mkWithKeyword(255, 238, 232, 170, 'palegoldenrod');
    }
    //
    static get PaleGreen() {
        return Color.mkWithKeyword(255, 152, 251, 152, 'palegreen');
    }
    //
    static get PaleTurquoise() {
        return Color.mkWithKeyword(255, 175, 238, 238, 'paleturquoise');
    }
    //
    static get PaleVioletRed() {
        return Color.mkWithKeyword(255, 219, 112, 147, 'palevioletred');
    }
    //
    static get PapayaWhip() {
        return Color.mkWithKeyword(255, 255, 239, 213, 'papayawhip');
    }
    //
    static get PeachPuff() {
        return Color.mkWithKeyword(255, 255, 218, 185, 'peachpuff');
    }
    //
    static get Peru() {
        return Color.mkWithKeyword(255, 205, 133, 63, 'peru');
    }
    //
    static get Pink() {
        return Color.mkWithKeyword(255, 255, 192, 203, 'pink');
    }
    //
    static get Plum() {
        return Color.mkWithKeyword(255, 221, 160, 221, 'plum');
    }
    //
    static get PowderBlue() {
        return Color.mkWithKeyword(255, 176, 224, 230, 'powderblue');
    }
    //
    static get Purple() {
        return Color.mkWithKeyword(255, 128, 0, 128, 'purple');
    }
    //
    static get Red() {
        return Color.mkWithKeyword(255, 255, 0, 0, 'red');
    }
    //
    static get RosyBrown() {
        return Color.mkWithKeyword(255, 188, 143, 143, 'rosybrown');
    }
    //
    static get RoyalBlue() {
        return Color.mkWithKeyword(255, 65, 105, 225, 'royalblue');
    }
    //
    static get SaddleBrown() {
        return Color.mkWithKeyword(255, 139, 69, 19, 'saddlebrown');
    }
    //
    static get Salmon() {
        return Color.mkWithKeyword(255, 250, 128, 114, 'salmon');
    }
    //
    static get SandyBrown() {
        return Color.mkWithKeyword(255, 244, 164, 96, 'sandybrown');
    }
    //
    static get SeaGreen() {
        return Color.mkWithKeyword(255, 46, 139, 87, 'seagreen');
    }
    //
    static get SeaShell() {
        return Color.mkWithKeyword(255, 255, 245, 238, 'seashell');
    }
    //
    static get Sienna() {
        return Color.mkWithKeyword(255, 160, 82, 45, 'sienna');
    }
    //
    static get Silver() {
        return Color.mkWithKeyword(255, 192, 192, 192, 'silver');
    }
    //
    static get SkyBlue() {
        return Color.mkWithKeyword(255, 135, 206, 235, 'skyblue');
    }
    //
    static get SlateBlue() {
        return Color.mkWithKeyword(255, 106, 90, 205, 'slateblue');
    }
    //
    static get SlateGray() {
        return Color.mkWithKeyword(255, 112, 128, 144, 'slategray');
    }
    //
    static get Snow() {
        return Color.mkWithKeyword(255, 255, 250, 250, 'snow');
    }
    //
    static get SpringGreen() {
        return Color.mkWithKeyword(255, 0, 255, 127, 'springgreen');
    }
    //
    static get SteelBlue() {
        return Color.mkWithKeyword(255, 70, 130, 180, 'steelblue');
    }
    //
    static get Tan() {
        return Color.mkWithKeyword(255, 210, 180, 140, 'tan');
    }
    //
    static get Teal() {
        return Color.mkWithKeyword(255, 0, 128, 128, 'teal');
    }
    //
    static get Thistle() {
        return Color.mkWithKeyword(255, 216, 191, 216, 'thistle');
    }
    //
    static get Tomato() {
        return Color.mkWithKeyword(255, 255, 99, 71, 'tomato');
    }
    //
    static get Transparent() {
        return Color.mkWithKeyword(0, 255, 255, 255, 'transparent');
    }
    //
    static get Turquoise() {
        return Color.mkWithKeyword(255, 64, 224, 208, 'turquoise');
    }
    //
    static get Violet() {
        return Color.mkWithKeyword(255, 238, 130, 238, 'violet');
    }
    //
    static get Wheat() {
        return Color.mkWithKeyword(255, 245, 222, 179, 'wheat');
    }
    //
    static get White() {
        return Color.mkWithKeyword(255, 255, 255, 255, 'white');
    }
    //
    static get WhiteSmoke() {
        return Color.mkWithKeyword(255, 245, 245, 245, 'whitesmoke');
    }
    //
    static get Yellow() {
        return Color.mkWithKeyword(255, 255, 255, 0, 'yellow');
    }
    //
    static get YellowGreen() {
        return Color.mkWithKeyword(255, 154, 205, 50, 'yellowgreen');
    }
}
//# sourceMappingURL=color.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/dirTypeEnum.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DirTypeEnum: () => (/* binding */ DirTypeEnum)
/* harmony export */ });
var DirTypeEnum;
(function (DirTypeEnum) {
    DirTypeEnum[DirTypeEnum["forward"] = 0] = "forward";
    DirTypeEnum[DirTypeEnum["back"] = 1] = "back";
    DirTypeEnum[DirTypeEnum["both"] = 2] = "both";
    DirTypeEnum[DirTypeEnum["none"] = 3] = "none";
})(DirTypeEnum || (DirTypeEnum = {}));
//# sourceMappingURL=dirTypeEnum.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/drawingEdge.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawingEdge: () => (/* binding */ DrawingEdge)
/* harmony export */ });
/* harmony import */ var _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/drawing/dist/arrowTypeEnum.js");
/* harmony import */ var _drawingObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingObject.js");


class DrawingEdge extends _drawingObject__WEBPACK_IMPORTED_MODULE_1__.DrawingObject {
    constructor(entity, directed) {
        super(entity);
        this.directed = true;
        this.directed = directed;
        if (directed) {
            this.arrowhead = _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_0__.ArrowTypeEnum.normal;
        }
        else {
            this.arrowhead = _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_0__.ArrowTypeEnum.none;
        }
        this.arrowtail = _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_0__.ArrowTypeEnum.none;
    }
    clone() {
        const ret = new DrawingEdge(null, this.directed);
        _drawingObject__WEBPACK_IMPORTED_MODULE_1__.DrawingObject.copyValidFields(this, ret);
        ret.directed = this.directed;
        ret.arrowtail = this.arrowtail;
        ret.arrowhead = this.arrowhead;
        return ret;
    }
}
//# sourceMappingURL=drawingEdge.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/drawingGraph.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawingGraph: () => (/* binding */ DrawingGraph)
/* harmony export */ });
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _drawingObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingObject.js");
/* harmony import */ var _drawingNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingNode.js");
/* harmony import */ var _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/drawing/dist/arrowTypeEnum.js");
/* harmony import */ var _drawingEdge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingEdge.js");
/* harmony import */ var _shapeEnum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/drawing/dist/shapeEnum.js");






/**
 * DrawingGraph is an attribute on Graph.
 * It keeps the attributes for nodes and edges rendering.
 *  It facilitates the geometry creation, mostly for the bounding curves of the nodes, from drawing attributes and labels
 * */
class DrawingGraph extends _drawingNode__WEBPACK_IMPORTED_MODULE_2__.DrawingNode {
    constructor() {
        super(...arguments);
        /** this node does not belong to the graph,
         but rather serves as a template for the other node's attributes (like filledColor, style, etc.) */
        this.graphVisData = {
            sameRanks: new Array(),
            minRanks: new Array(),
            maxRanks: new Array(),
            sourceRanks: new Array(),
            sinkRanks: new Array(),
        };
    }
    get defaultNodeObject() {
        return this._defaultNodeObject;
    }
    set defaultNodeObject(value) {
        this._defaultNodeObject = value;
    }
    static getDrawingGraph(g) {
        return _drawingObject__WEBPACK_IMPORTED_MODULE_1__.DrawingObject.getDrawingObj(g);
    }
    get graph() {
        return this.entity;
    }
    findNode(id) {
        const gr = this.graph;
        const n = gr.findNode(id);
        if (n == null)
            return null;
        return _drawingObject__WEBPACK_IMPORTED_MODULE_1__.DrawingObject.getDrawingObj(n);
    }
    hasDirectedEdge() {
        for (const e of this.graph.deepEdges) {
            const drawingEdge = _drawingObject__WEBPACK_IMPORTED_MODULE_1__.DrawingObject.getDrawingObj(e);
            if (drawingEdge.directed) {
                return true;
            }
        }
        return false;
    }
    createGeometry(textMeasure = (str) => {
        if (!str)
            return null;
        return new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Size(str.length * 8 + 8, 20);
    }) {
        const geomGraph = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph(this.graph);
        this.textMeasure = textMeasure;
        const opts = { fontFamily: this.fontname, fontSize: this.fontsize, fontStyle: 'normal' };
        if (this.labelText)
            geomGraph.labelSize = textMeasure(this.labelText, opts);
        for (const n of this.graph.nodesBreadthFirst) {
            this.createNodeGeometry(n);
        }
        for (const e of this.graph.deepEdges) {
            this.createEdgeGeometry(e);
        }
        if (this.rankdir) {
            // we must have the Sugiyama scheme here
            const ss = (geomGraph.layoutSettings = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.SugiyamaLayoutSettings());
            ss.layerDirection = this.rankdir;
        }
        return geomGraph;
    }
    createEdgeGeometry(e) {
        // if the drawing edge is not defined, we create it as a directed edge
        const drawingEdge = _drawingEdge__WEBPACK_IMPORTED_MODULE_4__.DrawingEdge.getDrawingObj(e) || new _drawingEdge__WEBPACK_IMPORTED_MODULE_4__.DrawingEdge(e, true);
        const geomEdge = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge(e);
        if (drawingEdge.arrowhead != _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_3__.ArrowTypeEnum.none) {
            geomEdge.targetArrowhead = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Arrowhead();
        }
        if (drawingEdge.arrowtail != _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_3__.ArrowTypeEnum.none) {
            geomEdge.sourceArrowhead = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Arrowhead();
        }
        if (drawingEdge.labelText) {
            const size = this.textMeasure(drawingEdge.labelText, {
                fontSize: drawingEdge.fontsize,
                fontFamily: drawingEdge.fontname,
                fontStyle: 'normal',
            });
            const label = (e.label = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Label(e));
            new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomLabel(label, _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkPP(new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0), new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Point(size.width, size.height)));
            drawingEdge.measuredTextSize = size;
        }
        if (drawingEdge.penwidth) {
            geomEdge.lineWidth = drawingEdge.penwidth;
        }
    }
    curveByShape(width, height, center, drawingNode) {
        let curve;
        switch (drawingNode.shape) {
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.diamond:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkDiamond(width, height, center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.ellipse:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkEllipse(width / 1.6, height / 1.6, center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.record:
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.box:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkRectangleWithRoundedCorners(width, height, drawingNode.XRadius, drawingNode.YRadius, center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.circle:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkCircle(Math.sqrt(width * width + height * height), center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.plaintext:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.point:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.mdiamond:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.msquare:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.polygon:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.doublecircle:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkCircle(Math.sqrt(width * width + height * height) + 2 * drawingNode.penwidth, center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.house:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.createHouse(width, height, center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.invhouse:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.createInvertedHouse(width, height, center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.parallelogram:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.createParallelogram(width, height, center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.octagon:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.createOctagon(width, height, center);
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.tripleoctagon:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.triangle:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.trapezium:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.drawFromGeometry:
                break;
            case _shapeEnum__WEBPACK_IMPORTED_MODULE_5__.ShapeEnum.hexagon:
                curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.createHexagon(width, height, center);
                break;
        }
        return curve !== null && curve !== void 0 ? curve : _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurveFactory.mkRectangleWithRoundedCorners(width, height, drawingNode.XRadius, drawingNode.YRadius, center);
    }
    createNodeGeometry(n, center = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0)) {
        if (n instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Graph) {
            const subDg = _drawingObject__WEBPACK_IMPORTED_MODULE_1__.DrawingObject.getDrawingObj(n) || new DrawingGraph(n);
            const geomGraph = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph(n);
            if (subDg.labelText) {
                geomGraph.labelSize = subDg.measuredTextSize = measureTextSize(subDg, this.textMeasure);
            }
        }
        else {
            // if the drawingNode attribute is not defined, we create a new DrawingNode
            const drawingNode = _drawingNode__WEBPACK_IMPORTED_MODULE_2__.DrawingNode.getDrawingObj(n) || new _drawingNode__WEBPACK_IMPORTED_MODULE_2__.DrawingNode(n);
            let textSize = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Size(1, 1);
            if (drawingNode.labelText) {
                textSize = measureTextSize(drawingNode, this.textMeasure);
            }
            drawingNode.measuredTextSize = textSize;
            const geomNode = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomNode(n);
            const width = textSize.width + drawingNode.LabelMargin * 2;
            const height = textSize.height + drawingNode.LabelMargin * 2;
            geomNode.boundaryCurve = this.curveByShape(width, height, center, drawingNode);
        }
    }
    measureLabelSizes(textMeasure) {
        var _a;
        for (const n of this.graph.nodesBreadthFirst) {
            const dn = _drawingNode__WEBPACK_IMPORTED_MODULE_2__.DrawingNode.getDrawingObj(n);
            dn.measuredTextSize = (_a = measureTextSize(dn, textMeasure)) !== null && _a !== void 0 ? _a : new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Size(1, 1);
        }
    }
}
function measureTextSize(drawingNode, textMeasure) {
    if (drawingNode.labelText) {
        return textMeasure(drawingNode.labelText, {
            fontSize: drawingNode.fontsize,
            fontFamily: drawingNode.fontname,
            fontStyle: 'normal', // TODO: find in styles?
        });
    }
    return null;
}
//# sourceMappingURL=drawingGraph.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/drawingNode.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawingNode: () => (/* binding */ DrawingNode)
/* harmony export */ });
/* harmony import */ var _drawingObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingObject.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/color.js");
/* harmony import */ var _shapeEnum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/drawing/dist/shapeEnum.js");



class DrawingNode extends _drawingObject__WEBPACK_IMPORTED_MODULE_0__.DrawingObject {
    clone() {
        throw new Error('Method not implemented.');
    }
    get Padding() {
        return this.padding;
    }
    set Padding(value) {
        this.padding = Math.max(0, value);
        // //RaiseVisualsChangedEvent(this, null);
    }
    // x radius of the rectangle box
    get XRadius() {
        return this.xRad;
    }
    set XRadius(value) {
        this.xRad = value;
        //RaiseVisualsChangedEvent(this, null);
    }
    // y radius of the rectangle box
    get YRadius() {
        return this.yRad;
    }
    set YRadius(value) {
        this.yRad = value;
    }
    // the default fill color
    static get DefaultFillColor() {
        return DrawingNode.defaultFillColor;
    }
    static set DefaultFillColor(value) {
        DrawingNode.defaultFillColor = value;
    }
    get ShapeEnum() {
        return this.shape;
    }
    set ShapeEnum(value) {
        this.shape = value;
        //RaiseVisualsChangedEvent(this, null);
    }
    // the node label margin
    get LabelMargin() {
        return this.labelMargin;
    }
    set LabelMargin(value) {
        this.labelMargin = value;
        //RaiseVisualsChangedEvent(this, null);
    }
    constructor(n) {
        super(n);
        this.shape = _shapeEnum__WEBPACK_IMPORTED_MODULE_2__.ShapeEnum.box;
        this.padding = 2;
        this.xRad = 3;
        this.yRad = 3;
        this.labelMargin = 1;
        // the non adgjacent edges should avoid being closer to the node than Padding
        this.labelWidthToHeightRatio = 1;
        if (n != null) {
            this.labelText = n.id;
        }
    }
    // the label width to height ratio.
    get LabelWidthToHeightRatio() {
        return this.labelWidthToHeightRatio;
    }
    set LabelWidthToHeightRatio(value) {
        this.labelWidthToHeightRatio = value;
    }
    get node() {
        return this.entity;
    }
    get id() {
        return this.node ? this.node.id : '';
    }
}
DrawingNode.defaultFillColor = _color__WEBPACK_IMPORTED_MODULE_1__.Color.LightGray;
//# sourceMappingURL=drawingNode.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/drawingObject.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawingObject: () => (/* binding */ DrawingObject)
/* harmony export */ });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/drawing/dist/color.js");
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");


/** DrawingObject ment to be an attribute on an Entity, with some additional information necessery for rendering. Many fields of this class support of Dot language */
class DrawingObject extends _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Attribute {
    rebind(e) {
        this.entity = e;
        this.bind(_msagl_core__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.DrawingObjectIndex);
    }
    static copyValidFields(source, target) {
        if (source == null || target == null)
            return;
        if (source.color && source.color.keyword && source.color.keyword.toLowerCase() !== 'black') {
            target.color = source.color;
        }
        if (source.fillColor) {
            target.fillColor = source.fillColor;
        }
        if (source.labelfontcolor && source.labelfontcolor.keyword.toLowerCase() !== 'black') {
            target.labelfontcolor = source.labelfontcolor;
        }
        if (source.labelText != null && source.labelText !== '' && source.labelText !== source.id) {
            target.labelText = source.labelText;
        }
        if (source.fontColor && source.fontColor.keyword && source.fontColor.keyword.toLowerCase() !== 'black') {
            target.fontColor = source.fontColor;
        }
        if (source.styles && source.styles.length) {
            target.styles = source.styles.map((a) => a);
        }
        if (source.pencolor && source.pencolor.keyword !== 'black') {
            target.pencolor = source.pencolor;
        }
        if (source.penwidth && source.penwidth !== 1) {
            target.penwidth = source.penwidth;
        }
        if (source.rankdir) {
            target.rankdir = source.rankdir;
        }
        if (source.fontname && source.fontname !== DrawingObject.defaultLabelFontName) {
            target.fontname = source.fontname;
        }
        if (source.margin) {
            target.margin = source.margin;
        }
        if (source.fontsize && source.fontsize !== DrawingObject.defaultLabelFontSize) {
            target.fontsize = source.fontsize;
        }
        if (source.orientation) {
            target.orientation = source.orientation;
        }
        if (source.ranksep) {
            target.ranksep = source.ranksep;
        }
        if (source.arrowtail) {
            target.arrowtail = source.arrowtail;
        }
        if (source.arrowhead) {
            target.arrowhead = source.arrowhead;
        }
        if (source.ordering) {
            target.ordering = source.ordering;
        }
        if (source.bgcolor) {
            target.bgcolor = source.bgcolor;
        }
        if (source.pos) {
            target.pos = source.pos;
        }
        if (source.nodesep) {
            target.nodesep = source.nodesep;
        }
        if (source.arrowsize) {
            target.arrowsize = source.arrowsize;
        }
        if (source.samehead) {
            target.samehead = source.samehead;
        }
        if (source.layersep) {
            target.layersep = source.layersep;
        }
        if (source.clusterRank) {
            target.clusterRank = source.clusterRank;
        }
    }
    get labelText() {
        return this._labelText;
    }
    set labelText(value) {
        this._labelText = value;
    }
    get arrowhead() {
        return this._arrowhead;
    }
    set arrowhead(value) {
        this._arrowhead = value;
    }
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    constructor(entity) {
        super(entity, _msagl_core__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.DrawingObjectIndex);
        this.labelfontcolor = _color__WEBPACK_IMPORTED_MODULE_0__.Color.Black;
        this.styles = [];
        this.penwidth = 1;
        this.fontname = DrawingObject.defaultLabelFontName;
        this.fontsize = DrawingObject.defaultLabelFontSize;
    }
    static getDrawingObj(attrCont) {
        if (attrCont == null) {
            return null;
        }
        else {
            return attrCont.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.DrawingObjectIndex);
        }
    }
}
/** the index of the DrawingObject in the list of attributes of Entity */
/**  This is the field from the Graph. It is used to keep the connection with the underlying graph */
// not all attributes can be used in derived classes
DrawingObject.defaultLabelFontName = 'Times-Roman';
DrawingObject.defaultLabelFontSize = 12;
//# sourceMappingURL=drawingObject.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrowTypeEnum: () => (/* reexport safe */ _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_0__.ArrowTypeEnum),
/* harmony export */   Color: () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_6__.Color),
/* harmony export */   DirTypeEnum: () => (/* reexport safe */ _dirTypeEnum__WEBPACK_IMPORTED_MODULE_4__.DirTypeEnum),
/* harmony export */   DrawingEdge: () => (/* reexport safe */ _drawingEdge__WEBPACK_IMPORTED_MODULE_8__.DrawingEdge),
/* harmony export */   DrawingGraph: () => (/* reexport safe */ _drawingGraph__WEBPACK_IMPORTED_MODULE_7__.DrawingGraph),
/* harmony export */   DrawingNode: () => (/* reexport safe */ _drawingNode__WEBPACK_IMPORTED_MODULE_9__.DrawingNode),
/* harmony export */   DrawingObject: () => (/* reexport safe */ _drawingObject__WEBPACK_IMPORTED_MODULE_10__.DrawingObject),
/* harmony export */   IncrementalDragger: () => (/* reexport safe */ _layoutEditing_incrementalDragger__WEBPACK_IMPORTED_MODULE_14__.IncrementalDragger),
/* harmony export */   InsertionMode: () => (/* reexport safe */ _layoutEditing_iViewer__WEBPACK_IMPORTED_MODULE_12__.InsertionMode),
/* harmony export */   LayoutEditor: () => (/* reexport safe */ _layoutEditing_layoutEditor__WEBPACK_IMPORTED_MODULE_11__.LayoutEditor),
/* harmony export */   ModifierKeysEnum: () => (/* reexport safe */ _layoutEditing_modifierKeys__WEBPACK_IMPORTED_MODULE_13__.ModifierKeysEnum),
/* harmony export */   OrderingEnum: () => (/* reexport safe */ _orderingEnum__WEBPACK_IMPORTED_MODULE_5__.OrderingEnum),
/* harmony export */   RankEnum: () => (/* reexport safe */ _rankEnum__WEBPACK_IMPORTED_MODULE_2__.RankEnum),
/* harmony export */   ShapeEnum: () => (/* reexport safe */ _shapeEnum__WEBPACK_IMPORTED_MODULE_1__.ShapeEnum),
/* harmony export */   StyleEnum: () => (/* reexport safe */ _styleEnum__WEBPACK_IMPORTED_MODULE_3__.StyleEnum),
/* harmony export */   viewerObj: () => (/* reexport safe */ _layoutEditing_layoutEditor__WEBPACK_IMPORTED_MODULE_11__.viewerObj)
/* harmony export */ });
/* harmony import */ var _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/drawing/dist/arrowTypeEnum.js");
/* harmony import */ var _shapeEnum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/shapeEnum.js");
/* harmony import */ var _rankEnum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/drawing/dist/rankEnum.js");
/* harmony import */ var _styleEnum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/drawing/dist/styleEnum.js");
/* harmony import */ var _dirTypeEnum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/drawing/dist/dirTypeEnum.js");
/* harmony import */ var _orderingEnum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/drawing/dist/orderingEnum.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/drawing/dist/color.js");
/* harmony import */ var _drawingGraph__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingGraph.js");
/* harmony import */ var _drawingEdge__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingEdge.js");
/* harmony import */ var _drawingNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingNode.js");
/* harmony import */ var _drawingObject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingObject.js");
/* harmony import */ var _layoutEditing_layoutEditor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/layoutEditor.js");
/* harmony import */ var _layoutEditing_iViewer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/iViewer.js");
/* harmony import */ var _layoutEditing_modifierKeys__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/modifierKeys.js");
/* harmony import */ var _layoutEditing_incrementalDragger__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/incrementalDragger.js");
















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/bumperPusher.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BumperPusher: () => (/* binding */ BumperPusher)
/* harmony export */ });
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var queue_typescript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/queue-typescript/lib/src/index.js");
//  pushes the nodes it got bumped to: pushes horizontally or vertically



class BumperPusher {
    //
    constructor(pushedNodes, separation, pushingNodes) {
        this.fixedNodes = new Set();
        this.separation = separation;
        this.rtree = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.RTree((0,_msagl_core__WEBPACK_IMPORTED_MODULE_0__.createRectangleNodeOnData)(pushedNodes, (n) => this.GetPaddedBoxOfNode(n)));
        // LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(rtree.GetAllLeaves().Select(n=>new DebugCurve(n.BoundaryCurve)));
        this.pushingNodes = pushingNodes;
    }
    get FixedNodes() {
        return this.fixedNodes;
    }
    GetPaddedBoxOfNode(n) {
        const ret = n.boundaryCurve.boundingBox.clone();
        ret.pad(this.separation / 2);
        return ret;
    }
    //
    PushNodes() {
        this.fixedNodes.clear();
        (0,_msagl_core__WEBPACK_IMPORTED_MODULE_0__.insertRange)(this.fixedNodes, this.pushingNodes);
        const q = new queue_typescript__WEBPACK_IMPORTED_MODULE_1__.Queue();
        for (const pn of this.pushingNodes)
            q.enqueue(pn);
        const ret = new Array();
        while (q.length > 0) {
            const n = q.dequeue();
            for (const node of this.PushByNodeAndReportPushedAsFixed(n)) {
                q.enqueue(node);
                this.fixedNodes.add(node);
                ret.push(node);
            }
        }
        return ret;
    }
    PushByNodeAndReportPushedAsFixed(pushingNode) {
        const ret = [];
        const pushingNodeBox = this.GetPaddedBoxOfNode(pushingNode);
        for (const rectNode of this.rtree.GetAllLeavesIntersectingRectangle(pushingNodeBox)) {
            if (this.fixedNodes.has(rectNode.UserData))
                continue;
            if (this.PushNodeAndUpdateRTree(pushingNode, rectNode))
                ret.push(rectNode.UserData);
        }
        return ret;
    }
    PushNodeAndUpdateRTree(pushingNode, pushed) {
        const del = pushed.UserData.center.sub(pushingNode.center);
        const w = pushingNode.width / 2 + pushed.UserData.width / 2;
        const h = pushingNode.height / 2 + pushed.UserData.height / 2;
        const absDelXBetweenCenters = Math.abs(del.x);
        const absDelYBetweenCenters = Math.abs(del.y);
        const xSep = absDelXBetweenCenters - w;
        const ySep = absDelYBetweenCenters - h;
        if (xSep >= this.separation || ySep >= this.separation)
            return false;
        if (absDelXBetweenCenters >= absDelYBetweenCenters) {
            const d = del.x > 0 ? this.separation - xSep : xSep - this.separation;
            this.PushByX(d, pushed);
        }
        else {
            const d = del.y > 0 ? this.separation - ySep : ySep - this.separation;
            this.PushByY(d, pushed);
        }
        this.UpdateBoundingBoxesOfPushedAndUpParents(pushed);
        return true;
    }
    PushByX(del, pushed) {
        const delPoint = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Point(del, 0);
        BumperPusher.PushByPoint(pushed, delPoint);
    }
    static PushByPoint(pushed, delPoint) {
        pushed.UserData.center = pushed.UserData.center.add(delPoint);
        if (pushed.UserData instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph) {
            pushed.UserData.translate(delPoint);
        }
    }
    PushByY(del, pushed) {
        const delPoint = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Point(0, del);
        BumperPusher.PushByPoint(pushed, delPoint);
    }
    UpdateBoundingBoxesOfPushedAndUpParents(pushed) {
        pushed.irect = this.GetPaddedBoxOfNode(pushed.UserData);
        let parent = pushed.Parent;
        while (parent != null) {
            parent.irect = parent.Left.irect.add_rect(parent.Right.irect);
            parent = parent.Parent;
        }
    }
    //
    UpdateRTreeByChangedNodeBox(cluster, previousBox) {
        const rectNode = this.FindClusterNode(cluster, previousBox);
        this.UpdateBoundingBoxesOfPushedAndUpParents(rectNode);
    }
    FindClusterNode(cluster, previousBox) {
        const node = this.rtree.RootNode;
        return this.FindClusterNodeRecurse(node, cluster, previousBox);
    }
    FindClusterNodeRecurse(node, cluster, previousBox) {
        if (node.UserData != null)
            return node.UserData === cluster ? node : null;
        let n0 = null;
        if (previousBox.intersects(node.left.irect))
            n0 = this.FindClusterNodeRecurse(node.Left, cluster, previousBox);
        if (n0 != null)
            return n0;
        if (previousBox.intersects(node.right.irect))
            return this.FindClusterNodeRecurse(node.Right, cluster, previousBox);
        return null;
    }
    FirstPushingNode() {
        return this.pushingNodes[0];
    }
}
//# sourceMappingURL=bumperPusher.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/geomGraphEditor.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DraggingMode: () => (/* binding */ DraggingMode),
/* harmony export */   GeometryGraphEditor: () => (/* binding */ GeometryGraphEditor)
/* harmony export */ });
/* harmony import */ var _incrementalDragger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/incrementalDragger.js");
/* harmony import */ var _undoRedoActionsList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/undoRedoActionsList.js");
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
//      the editor of a graph() layout



var DraggingMode;
(function (DraggingMode) {
    DraggingMode[DraggingMode["Incremental"] = 0] = "Incremental";
    DraggingMode[DraggingMode["Default"] = 1] = "Default";
})(DraggingMode || (DraggingMode = {}));
class GeometryGraphEditor {
    constructor() {
        this.edgesToReroute = new Set();
        this.objectsToDrag = new Set();
        this.undoList = new _undoRedoActionsList__WEBPACK_IMPORTED_MODULE_1__.UndoList();
    }
    updateDeltaForDragUndo(delta) {
        this.undoList.updateDeltaForDragUndo(delta);
    }
    registerDelete(entity) {
        this.undoList.registerDelete(entity);
    }
    registerAdd(entity) {
        this.undoList.registerAdd(entity);
    }
    *entitiesToBeChangedByRedo() {
        yield* this.undoList.entitiesToBeChangedByRedo();
    }
    *entitiesToBeChangedByUndo() {
        yield* this.undoList.entitiesToBeChangedByUndo();
    }
    createUndoPoint() {
        this.undoList.createUndoPoint();
    }
    /**      return the current undo action*/
    get LayoutSettings() {
        return this.graph().layoutSettings;
    }
    get EdgeRoutingMode() {
        return this.LayoutSettings.commonSettings.edgeRoutingSettings.EdgeRoutingMode;
    }
    /**  returns true if "undo" is available */
    get canUndo() {
        return this.undoList.canUndo();
    }
    /**  returns true if "redo" is available*/
    get canRedo() {
        return this.undoList.canRedo();
    }
    static calculateAttachmentSegment(label) {
        const edge = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(label.parent.entity);
        if (edge != null) {
            GeometryGraphEditor.CalculateAttachedSegmentEnd(label, edge);
            if (!_msagl_core__WEBPACK_IMPORTED_MODULE_2__.Point.closeDistEps(label.attachmentSegmentEnd, label.center)) {
                const x = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Curve.intersectionOne(label.boundingBox.perimeter(), _msagl_core__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(label.attachmentSegmentEnd, label.center), false);
                label.attachmentSegmentStart = x != null ? x.x : label.center;
            }
            else {
                label.attachmentSegmentStart = label.center;
            }
        }
    }
    static CalculateAttachedSegmentEnd(label, edge) {
        label.attachmentSegmentEnd = edge.curve.value(edge.curve.closestParameter(label.center));
    }
    /** drags elements by the delta,
     * and return the array of entities with the changed geometry
     *
     */
    drag(delta, draggingMode, lastMousePosition) {
        if (delta.x == 0 && delta.y == 0)
            return;
        for (const o of this.objectsToDrag) {
            this.registerForUndoDrag(o.entity);
        }
        if (this.geomEdgeWithSmoothedPolylineExposed == null) {
            if (this.EdgeRoutingMode !== _msagl_core__WEBPACK_IMPORTED_MODULE_2__.EdgeRoutingMode.Rectilinear && this.EdgeRoutingMode !== _msagl_core__WEBPACK_IMPORTED_MODULE_2__.EdgeRoutingMode.RectilinearToCenter) {
                this.dragObjectsForNonRectilinearCase(delta, draggingMode);
            }
            else {
                this.DragObjectsForRectilinearCase(delta);
            }
        }
        else {
            // this.EditedEdge != null
            this.dragPolylineCorner(lastMousePosition, delta);
        }
    }
    registerForUndoDrag(entity) {
        this.undoList.registerForUndoDrag(entity);
    }
    DragObjectsForRectilinearCase(delta) {
        for (const node of this.objectsToDrag) {
            if (node instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomNode) {
                node.translate(delta);
            }
        }
        _msagl_core__WEBPACK_IMPORTED_MODULE_2__.RectilinearInteractiveEditor.CreatePortsAndRouteEdges(this.LayoutSettings.commonSettings.NodeSeparation / 3, 1, this.graph().nodesBreadthFirst, this.graph().deepEdges, this.LayoutSettings.commonSettings.edgeRoutingSettings.EdgeRoutingMode);
        _msagl_core__WEBPACK_IMPORTED_MODULE_2__.EdgeLabelPlacement.constructorG(this.graph()).run();
        // for (const e of this.geomGraph.deepEdges) {
        //   this.UpdateGraphBoundingBoxWithCheck(e)
        // }
        // for (const n of this.geomGraph.deepNodes) {
        //   this.UpdateGraphBoundingBoxWithCheck(n)
        // }
        this.propagateChangesToClusterParents();
        throw new Error('not implemented');
    }
    dragObjectsForNonRectilinearCase(delta, draggingMode) {
        if (draggingMode === DraggingMode.Incremental) {
            this.DragIncrementally(delta);
        }
        else if (false) {}
        else {
            this.dragWithStraightLines(delta);
        }
    }
    dragWithStraightLines(delta) {
        for (const geomObj of this.objectsToDrag) {
            if (geomObj instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomGraph) {
                geomObj.deepTranslate(delta);
            }
            else {
                geomObj.translate(delta);
            }
        }
        this.propagateChangesToClusterParents();
        this.routeEdgesAsStraightLines();
    }
    propagateChangesToClusterParents() {
        const touchedWithChangedBorder = new Set();
        for (const n of this.objectsToDrag) {
            if (n instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomNode === false)
                continue;
            const geomNode = n;
            for (const c of geomNode.node.getAncestors()) {
                const gc = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomObject.getGeom(c);
                if (gc !== this.graph() && !this.objectsToDrag.has(gc)) {
                    touchedWithChangedBorder.add(gc);
                }
            }
        }
        if (touchedWithChangedBorder.size > 0) {
            for (const c of this.graph().subgraphsDepthFirst) {
                const gc = c;
                if (touchedWithChangedBorder.has(gc)) {
                    const newBox = gc.getPumpedGraphWithMarginsBox();
                    if (!newBox.equalEps(gc.boundingBox)) {
                        this.registerForUndo(gc.entity);
                        for (const e of gc.selfEdges()) {
                            this.addToEdgesToReroute(e);
                        }
                        for (const e of gc.inEdges()) {
                            this.addToEdgesToReroute(e);
                        }
                        for (const e of gc.outEdges()) {
                            this.addToEdgesToReroute(e);
                        }
                        gc.boundingBox = newBox;
                    }
                }
            }
        }
    }
    addToEdgesToReroute(e) {
        //    Assert.assert(!this.bothEndsInDragObjects(e))
        this.edgesToReroute.add(e);
    }
    //bothEndsInDragObjects(e: GeomEdge) {
    //  return this.objectsToDrag.has(e.source) && this.objectsToDrag.has(e.target)
    //}
    DragWithSplinesOrBundles(delta) {
        for (const geomObj of this.objectsToDrag) {
            if (geomObj instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomNode) {
                geomObj.translate(delta);
            }
        }
        this.RunSplineRouterAndPutLabels();
    }
    RunSplineRouterAndPutLabels() {
        const router = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.SplineRouter.mk5(this.graph(), this.LayoutSettings.commonSettings.edgeRoutingSettings.Padding, this.LayoutSettings.commonSettings.edgeRoutingSettings.PolylinePadding, this.LayoutSettings.commonSettings.edgeRoutingSettings.ConeAngle, this.LayoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings);
        router.run();
        const elp = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.EdgeLabelPlacement.constructorG(this.graph());
        elp.run();
    }
    registerForUndo(e) {
        this.undoList.registerForUndo(e);
    }
    routeEdgesAsStraightLines() {
        for (const edge of this.edgesToReroute) {
            this.registerForUndo(edge.entity);
            _msagl_core__WEBPACK_IMPORTED_MODULE_2__.StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(edge);
            if (edge.label) {
                this.registerForUndo(edge.edge.label);
            }
        }
        const ep = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.EdgeLabelPlacement.constructorGA(this.graph(), Array.from(this.edgesToReroute));
        ep.run();
    }
    // UpdateGraphBoundingBoxWithCheck_() {
    //   for (const node of this.graph().shallowNodes) {
    //     // shallow or deep?
    //     this.UpdateGraphBoundingBoxWithCheck(node)
    //   }
    //   for (const edge of this.graph().edges()) {
    //     // shallow or deep?
    //     this.UpdateGraphBoundingBoxWithCheck(edge)
    //   }
    // }
    DragIncrementally(delta) {
        if (this.incrementalDragger == null) {
            this.InitIncrementalDragger();
        }
        this.incrementalDragger.Drag(delta);
    }
    dragPolylineCorner(lastMousePosition, delta) {
        const site = GeometryGraphEditor.findClosestCornerForEdit(this.geomEdgeWithSmoothedPolylineExposed.smoothedPolyline, lastMousePosition);
        site.point = site.point.add(delta);
        if (site.prev == null) {
            pullSiteToTheNode(this.geomEdgeWithSmoothedPolylineExposed.source, site);
        }
        else if (site.next == null) {
            pullSiteToTheNode(this.geomEdgeWithSmoothedPolylineExposed.target, site);
        }
        GeometryGraphEditor.createCurveOnChangedPolyline(this.geomEdgeWithSmoothedPolylineExposed);
    }
    static dragEdgeWithSite(delta, e, site) {
        site.point = site.point.add(delta);
        GeometryGraphEditor.createCurveOnChangedPolyline(e);
    }
    static createCurveOnChangedPolyline(e) {
        const curve = e.smoothedPolyline.createCurve();
        if (!_msagl_core__WEBPACK_IMPORTED_MODULE_2__.Arrowhead.trimSplineAndCalculateArrowheadsII(e, e.source.boundaryCurve, e.target.boundaryCurve, curve, false)) {
            _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Arrowhead.createBigEnoughSpline(e);
        }
        e.sourcePort = new _msagl_core__WEBPACK_IMPORTED_MODULE_2__.RelativeFloatingPort(() => e.source.boundaryCurve, () => e.source.center, edgeStart().sub(e.source.center));
        e.targetPort = new _msagl_core__WEBPACK_IMPORTED_MODULE_2__.RelativeFloatingPort(() => e.target.boundaryCurve, () => e.target.center, edgeEnd().sub(e.target.center));
        function edgeStart() {
            return e.sourceArrowhead ? e.sourceArrowhead.tipPosition : e.curve.start;
        }
        function edgeEnd() {
            return e.targetArrowhead ? e.targetArrowhead.tipPosition : e.curve.end;
        }
    }
    prepareForObjectDragging(markedObjects, dragMode) {
        this.geomEdgeWithSmoothedPolylineExposed = null;
        this.calculateObjectToDragAndEdgesToReroute(markedObjects);
        this.undoList.createUndoPoint();
        if (dragMode === DraggingMode.Incremental) {
            this.InitIncrementalDragger();
        }
    }
    PrepareForClusterCollapseChange(changedClusters) {
        throw new Error('not implemented');
        // this.InsertToListAndSetTheBoxBefore(new ClustersCollapseExpandUndoRedoAction(this.graph()))
        // for (const iCluster of changedClusters) {
        //   throw new Error('not implemented') // this.CurrentUndoAction.AddAffectedObject(iCluster) //
        // }
    }
    InitIncrementalDragger() {
        this.incrementalDragger = new _incrementalDragger__WEBPACK_IMPORTED_MODULE_0__.IncrementalDragger(Array.from(this.objectsToDrag).filter((o) => o instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomNode), this.graph(), this.LayoutSettings);
    }
    clearDraggedSets() {
        this.objectsToDrag.clear();
        this.edgesToReroute.clear();
    }
    addToObjectsToDrag(geomObj) {
        this.objectsToDrag.add(geomObj);
    }
    /** fills the fields objectsToDrag, edgesToDrag */
    calculateObjectToDragAndEdgesToReroute(markedObjects) {
        this.clearDraggedSets();
        for (const geometryObject of markedObjects) {
            this.addToObjectsToDrag(geometryObject);
            const isEdge = geometryObject instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomEdge;
            if (isEdge) {
                this.addToObjectsToDrag(geometryObject.source);
                this.addToObjectsToDrag(geometryObject.target);
            }
        }
        this.removeClusterSuccessorsFromObjectsToDrag();
        this.calculateDragSetsForEdges();
    }
    removeClusterSuccessorsFromObjectsToDrag() {
        const listToRemove = new Array();
        for (const node of this.objectsToDrag) {
            if (this.hasAncestorInObjectsToDrag(node))
                listToRemove.push(node);
        }
        for (const node of listToRemove) {
            this.objectsToDrag.delete(node);
        }
    }
    // UpdateGraphBoundingBoxWithCheck(geomObj: GeomObject) {
    //   const bBox = geomObj.boundingBox.clone()
    //   const leftTop = new Point(-this.geomGraph.margins.left, this.geomGraph.margins.top)
    //   const rightBottom = new Point(-this.geomGraph.margins.right, -this.geomGraph.margins.bottom)
    //   const bounds = this.geomGraph.boundingBox.clone()
    //   this.GraphBoundingBoxGetsExtended ||=
    //     bounds.addWithCheck(bBox.leftTop.add(leftTop)) || bounds.addWithCheck(bBox.rightBottom.add(rightBottom))
    //   this.geomGraph.boundingBox = bounds
    // }
    calculateDragSetsForEdges() {
        // copy this.objectsToDrag to an array because new entities might be added to it
        for (const geomObj of Array.from(this.objectsToDrag)) {
            if (geomObj instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomGraph) {
                this.addGeomGraphEdgesToRerouteOrDrag(geomObj);
            }
            else if (geomObj instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomNode) {
                this.addNodeEdgesToRerouteOrDrag(geomObj);
            }
            else if (geomObj instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomEdge && geomObj.edge.label) {
                this.addToObjectsToDrag(geomObj.edge.label.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_2__.AttributeRegistry.GeomObjectIndex));
            }
        }
    }
    addNodeEdgesToRerouteOrDrag(node) {
        _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Assert.assert(node instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomGraph == false);
        for (const edge of node.selfEdges()) {
            this.addToObjectsToDrag(edge);
        }
        for (const edge of node.inEdges()) {
            if (this.hasSelfOrAncestorInObjectsToDrag(edge.source)) {
                // has to drag
                this.addToObjectsToDrag(edge);
            }
            else {
                this.addToEdgesToReroute(edge);
            }
        }
        for (const edge of node.outEdges()) {
            if (this.hasSelfOrAncestorInObjectsToDrag(edge.target)) {
                // has to drag
                this.addToObjectsToDrag(edge);
            }
            else {
                this.addToEdgesToReroute(edge);
            }
        }
        if (node instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomGraph)
            for (const n of node.nodesBreadthFirst) {
                this.addNodeEdgesToRerouteOrDrag(n);
            }
    }
    addGeomGraphEdgesToRerouteOrDrag(subg) {
        _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Assert.assert(subg instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_2__.GeomGraph);
        for (const edge of subg.selfEdges()) {
            this.addToObjectsToDrag(edge);
        }
        for (const edge of subg.inEdges()) {
            if (subg.isAncestor(edge.source))
                continue;
            if (this.hasSelfOrAncestorInObjectsToDrag(edge.source)) {
                this.addToObjectsToDrag(edge);
            }
            else {
                this.addToEdgesToReroute(edge);
            }
        }
        for (const edge of subg.outEdges()) {
            if (subg.isAncestor(edge.target))
                continue;
            if (this.hasSelfOrAncestorInObjectsToDrag(edge.target)) {
                // has to drag
                this.addToObjectsToDrag(edge);
            }
            else {
                this.addToEdgesToReroute(edge);
            }
        }
        for (const n of subg.nodesBreadthFirst) {
            for (const e of n.outEdges()) {
                const target = e.target;
                if (subg.isAncestor(target))
                    continue;
                if (this.hasSelfOrAncestorInObjectsToDrag(target))
                    this.addToObjectsToDrag(e);
                else
                    this.addToEdgesToReroute(e);
            }
            for (const e of n.inEdges()) {
                const source = e.source;
                if (subg.isAncestor(source))
                    continue;
                if (this.hasSelfOrAncestorInObjectsToDrag(source))
                    this.addToObjectsToDrag(e);
                else
                    this.addToEdgesToReroute(e);
            }
        }
    }
    /** returns true iff the edge is under a cluster belonging to this.objectsToDrag */
    hasSelfOrAncestorInObjectsToDrag(ent) {
        while (ent) {
            if (this.objectsToDrag.has(ent))
                return true;
            ent = ent.parent;
        }
        return false;
    }
    hasAncestorInObjectsToDrag(ent) {
        ent = ent.parent;
        while (ent) {
            if (this.objectsToDrag.has(ent))
                return true;
            ent = ent.parent;
        }
        return false;
    }
    static CalculateMiddleOffsetsForMultiedge(multiedge, node, offsetsInsideOfMultiedge, nodeSeparation) {
        const middleAngles = GeometryGraphEditor.GetMiddleAnglesOfMultiedge(multiedge, node);
        const sortedKeys = Array.from(middleAngles.keys()).sort((a, b) => a - b);
        const edges = sortedKeys.map(key => middleAngles.get(key)); // the edges should be sorted here
        const separation = nodeSeparation * 6;
        const k = edges.length / 2;
        const even = k * 2 === edges.length;
        let off;
        if (even) {
            off = -(separation / 2);
            for (let j = k - 1; j >= 0; j--) {
                const edge = edges[j];
                offsetsInsideOfMultiedge.set(edge, off);
                off -= separation + (edge.label ? edge.label.width : 0);
            }
            off = separation / 2;
            for (let j = k; j < edges.length; j++) {
                const edge = edges[j];
                offsetsInsideOfMultiedge.set(edge, off);
                off += separation + (edge.label ? edge.label.width : 0);
            }
        }
        else {
            off = 0;
            for (let j = k; j >= 0; j--) {
                const edge = edges[j];
                offsetsInsideOfMultiedge.set(edge, off);
                off = separation + (edge.label ? edge.label.width : 0);
            }
            off = separation;
            for (let j = k + 1; j < edges.length; j++) {
                const edge = edges[j];
                offsetsInsideOfMultiedge.set(edge, off);
                off += separation + (edge.label ? edge.label.width : 0);
            }
        }
    }
    static GetMiddleAnglesOfMultiedge(multiedge, node) {
        const ret = new Map();
        const firstEdge = multiedge[0];
        const a = node.center;
        const b = GeometryGraphEditor.Middle(firstEdge.curve);
        ret.set(0, firstEdge);
        for (let i = 1; i < multiedge.length; i++) {
            const edge = multiedge[i];
            const c = GeometryGraphEditor.Middle(edge.curve);
            let angle = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Point.anglePCP(b, a, c);
            if (angle > Math.PI) {
                angle -= Math.PI * 2;
            }
            ret.set(angle, edge);
        }
        return ret;
    }
    static Middle(iCurve) {
        return iCurve.value(0.5 * iCurve.parStart + 0.5 * iCurve.parEnd);
    }
    static *GetMultiEdges(node) {
        const nodeToMultiEdge = new Map();
        for (const edge of node.outEdges()) {
            GeometryGraphEditor.GetOrCreateListOfMultiedge(nodeToMultiEdge, edge.target).push(edge);
        }
        for (const edge of node.inEdges()) {
            GeometryGraphEditor.GetOrCreateListOfMultiedge(nodeToMultiEdge, edge.source).push(edge);
        }
        for (const list of nodeToMultiEdge.values()) {
            if (list.length > 1) {
                yield list;
            }
        }
    }
    static GetOrCreateListOfMultiedge(nodeToMultiEdge, node) {
        let ret = nodeToMultiEdge.get(node);
        if (ret)
            return ret;
        nodeToMultiEdge.set(node, (ret = []));
        return ret;
    }
    prepareForGeomEdgeChange(geometryEdge) {
        _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Assert.assert(this.geomEdgeWithSmoothedPolylineExposed === geometryEdge);
        this.createUndoPoint();
        this.registerForUndo(geometryEdge.edge);
    }
    //      Undoes the last editing.
    undo() {
        this.undoList.undo();
    }
    // createRedoActionIfNeeded() {
    //   const currentUndo = this.undoList.currentUndo
    //   if (currentUndo.Next != null) return
    //   let action: UndoRedoAction
    //   if (currentUndo instanceof ObjectDragUndoRedoAction) {
    //     action = new ObjectDragUndoRedoAction(currentUndo.geomGraph)
    //   } else {
    //     action = null
    //     throw new Error('not implemented')
    //   }
    //   currentUndo.Next = action
    //   action.Previous = currentUndo
    //   for (const e of currentUndo.EditedObjects) {
    //     action.addRestoreData(e, getRestoreData(e))
    //   }
    // }
    //      redo the dragging
    redo() {
        this.undoList.redo();
    }
    //      clear the editor
    clear() {
        this.objectsToDrag = new Set();
        this.edgesToReroute.clear();
        this.undoList = new _undoRedoActionsList__WEBPACK_IMPORTED_MODULE_1__.UndoList();
    }
    //      gets the enumerator pointing to the polyline corner before the point
    static getPreviousCornerSite(edge, point) {
        let prevSite = edge.smoothedPolyline.headSite;
        let nextSite = prevSite.next;
        for (; nextSite != null;) {
            if (GeometryGraphEditor.betweenSites(prevSite, nextSite, point)) {
                return prevSite;
            }
            prevSite = nextSite;
            nextSite = nextSite.next;
        }
        return null;
    }
    static betweenSites(prevSite, nextSite, point) {
        const par = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.LineSegment.closestParameterOnLineSegment(point, prevSite.point, nextSite.point);
        return par > 0.1 && par < 0.9;
    }
    //      insert a polyline corner
    insertSite(edge, point, siteBeforeInsertion) {
        this.prepareForGeomEdgeChange(edge);
        // creating the new site
        const s = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.CornerSite.mkSiteSPS(siteBeforeInsertion, point, siteBeforeInsertion.next);
        GeometryGraphEditor.dragEdgeWithSite(new _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Point(0, 0), edge, s);
    }
    //      deletes the polyline corner
    deleteSite(edge, site) {
        this.prepareForGeomEdgeChange(edge);
        _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Assert.assert(this.geomEdgeWithSmoothedPolylineExposed === edge);
        site.prev.next = site.next;
        // removing the site from the list
        site.next.prev = site.prev;
        // recalculate the edge geometry  in a correct way
        GeometryGraphEditor.dragEdgeWithSite(new _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Point(0, 0), edge, site.prev);
    }
    //      finds the polyline corner near the mouse position
    static findClosestCornerForEdit(sp, mousePoint, minDist = Number.POSITIVE_INFINITY) {
        if (minDist !== Number.POSITIVE_INFINITY) {
            minDist *= minDist;
        }
        let site = sp.headSite;
        let bestSite = site;
        let dist = bestSite.point.sub(mousePoint).lengthSquared;
        while (site.next != null) {
            site = site.next;
            const d = mousePoint.sub(site.point).lengthSquared;
            if (d < dist) {
                bestSite = site;
                dist = d;
            }
        }
        if (dist > minDist)
            return null;
        return bestSite;
    }
    ReactOnViewChange() {
        //this.LayoutSettings.Interactor.RunOnViewChange();
    }
    ForgetDragging() {
        this.incrementalDragger = null;
    }
}
function pullSiteToTheNode(node, site) {
    const bc = node.boundaryCurve;
    const location = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Curve.PointRelativeToCurveLocation(site.point, bc);
    if (location != _msagl_core__WEBPACK_IMPORTED_MODULE_2__.PointLocation.Outside)
        return;
    const ls = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.LineSegment.mkPP(node.center, site.point);
    const x = _msagl_core__WEBPACK_IMPORTED_MODULE_2__.Curve.intersectionOne(ls, bc, false);
    if (x) {
        site.point = x.x;
    }
}
//# sourceMappingURL=geomGraphEditor.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/iViewer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InsertionMode: () => (/* binding */ InsertionMode)
/* harmony export */ });
/**   the interface for the viewer for editing the graph layout, and the graph */
var InsertionMode;
(function (InsertionMode) {
    InsertionMode[InsertionMode["Default"] = 0] = "Default";
    InsertionMode[InsertionMode["Node"] = 1] = "Node";
    InsertionMode[InsertionMode["Edge"] = 2] = "Edge";
})(InsertionMode || (InsertionMode = {}));
//# sourceMappingURL=iViewer.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/incrementalDragger.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IncrementalDragger: () => (/* binding */ IncrementalDragger)
/* harmony export */ });
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _bumperPusher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/bumperPusher.js");
/* harmony import */ var _labelFixture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/labelFixture.js");



class IncrementalDragger {
    get geomGraph() {
        return this.geomGraph_;
    }
    set geomGraph(value) {
        this.geomGraph_ = value;
    }
    //
    constructor(pushingNodes, graph, layoutSettings) {
        this.listOfPushers = new Array();
        this.labelFixtures = new Map();
        this.geomGraph = graph;
        this.nodeSeparation = layoutSettings.NodeSeparation;
        this.layoutSettings = layoutSettings;
        this.pushingNodesArray = pushingNodes;
        // Debug.Assert((this.pushingNodesArray.All(() => {  }, (IncrementalDragger.DefaultClusterParent(n) == null ))
        //                 || (new Set<GeomNode>(this.pushingNodesArray.Select(() => {  }, n.ClusterParent)).Count === 1)), "dragged nodes have to belong to the same cluster");
        this.InitBumperPushers();
    }
    InitBumperPushers() {
        if (this.pushingNodesArray.length === 0) {
            return;
        }
        let gg = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(this.pushingNodesArray[0].node.parent);
        let pushingArray = this.pushingNodesArray;
        do {
            this.listOfPushers.push(new _bumperPusher__WEBPACK_IMPORTED_MODULE_1__.BumperPusher(gg.shallowNodes, this.nodeSeparation, pushingArray));
            if (gg.graph.parent) {
                gg = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(gg.graph.parent);
                pushingArray = [gg];
            }
            else {
                break;
            }
        } while (true);
    }
    RunPushers() {
        for (let i = 0; i < this.listOfPushers.length; i++) {
            const bumperPusher = this.listOfPushers[i];
            bumperPusher.PushNodes();
            const cluster = bumperPusher.FirstPushingNode().node.parent;
            if (cluster === this.geomGraph_.graph) {
                break;
            }
            const sg = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(cluster);
            const bbox = sg.boundingBox;
            sg.calculateBoundsFromChildren();
            const newBox = sg.boundingBox;
            if (newBox.equalEps(bbox)) {
                break;
            }
            this.listOfPushers[i + 1].UpdateRTreeByChangedNodeBox(sg, bbox);
        }
    }
    Drag(delta) {
        if (delta.x == null && delta.y == null)
            return;
        for (const n of this.pushingNodesArray) {
            n.translate(delta);
        }
        this.RunPushers();
        this.RouteChangedEdges();
    }
    RouteChangedEdges() {
        this.changedEdges = this.GetChangedEdges(this.GetChangedNodes());
        this.InitLabelFixtures(this.changedEdges);
        const router = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.SplineRouter(this.geomGraph_, this.changedEdges, this.layoutSettings.commonSettings.edgeRoutingSettings.Padding, this.layoutSettings.commonSettings.edgeRoutingSettings.PolylinePadding, this.layoutSettings.commonSettings.edgeRoutingSettings.ConeAngle, this.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings);
        router.run();
        this.PositionLabels(this.changedEdges);
    }
    PositionLabels(changedEdges) {
        for (const edge of changedEdges) {
            this.PositionEdgeLabel(edge);
        }
    }
    PositionEdgeLabel(edge) {
        const lf = this.labelFixtures.get(edge);
        if (lf == null)
            return;
        const curve = edge.curve;
        const lenAtLabelAttachment = curve.length * lf.RelativeLengthOnCurve;
        const par = curve.getParameterAtLength(lenAtLabelAttachment);
        const tang = curve.derivative(par);
        const norm = (lf.RightSide ? tang.rotate90Cw() : tang.rotate90Ccw()).normalize().mul(lf.NormalLength);
        edge.label.positionCenter(curve.value(par).add(norm));
    }
    InitLabelFixtures(edges) {
        for (const edge of edges) {
            this.InitLabelFixture(edge);
        }
    }
    InitLabelFixture(edge) {
        if (edge.label == null) {
            return;
        }
        if (this.labelFixtures.has(edge)) {
            return;
        }
        const attachmentPar = edge.curve.closestParameter(edge.label.center);
        const curve = edge.curve;
        const tang = curve.derivative(attachmentPar);
        const normal = tang.rotate90Cw();
        const fromCurveToLabel = edge.label.center.sub(curve.value(attachmentPar));
        const fixture = new _labelFixture__WEBPACK_IMPORTED_MODULE_2__.LabelFixture(curve.lengthPartial(0, attachmentPar) / curve.length, fromCurveToLabel.dot(normal) > 0, fromCurveToLabel.length);
        this.labelFixtures.set(edge, fixture);
    }
    GetChangedEdges(changedNodes) {
        const list = [];
        const box = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkOnRectangles(Array.from(changedNodes).map((n) => n.boundingBox));
        const boxPoly = box.perimeter();
        for (const e of this.geomGraph.deepEdges) {
            if (this.EdgeNeedsRouting(box, e, boxPoly, changedNodes)) {
                list.push(e);
            }
        }
        return list;
    }
    EdgeNeedsRouting(box, edge, boxPolyline, changedNodes) {
        if (edge.curve == null) {
            return true;
        }
        if (changedNodes.has(edge.source) || changedNodes.has(edge.target)) {
            return true;
        }
        if (edge.source.boundingBox.intersects(box) || edge.target.boundaryCurve.boundingBox.intersects(box)) {
            return true;
        }
        if (!edge.boundingBox.intersects(box)) {
            return false;
        }
        return _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Curve.intersectionOne(boxPolyline, edge.curve, false) != null;
    }
    GetChangedNodes() {
        const ret = new Set();
        for (const p of this.listOfPushers) {
            for (const n of p.FixedNodes)
                ret.add(n);
        }
        return ret;
    }
}
//# sourceMappingURL=incrementalDragger.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/labelFixture.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LabelFixture: () => (/* binding */ LabelFixture)
/* harmony export */ });
/**  to put a label go to RelativeLengthOnCurve position, take normal accordingly to the RightSide and follow NormalLength this direction */
class LabelFixture {
    constructor(relativeLengthOnCurve, rightSide, normalLength) {
        this.RelativeLengthOnCurve = relativeLengthOnCurve;
        this.RightSide = rightSide;
        this.NormalLength = normalLength;
    }
}
//# sourceMappingURL=labelFixture.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/layoutEditor.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayoutEditor: () => (/* binding */ LayoutEditor),
/* harmony export */   viewerObj: () => (/* binding */ viewerObj)
/* harmony export */ });
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/geomGraphEditor.js");
/* harmony import */ var _iViewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/iViewer.js");
/* harmony import */ var _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/drawing/dist/arrowTypeEnum.js");
/* harmony import */ var _drawingEdge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingEdge.js");
/* harmony import */ var _drawingNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingNode.js");
/* harmony import */ var _drawingObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingObject.js");
/* harmony import */ var _modifierKeys__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/modifierKeys.js");








function viewerObj(entity) {
    return entity.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.ViewerIndex);
}
function geomObjFromIViewerObj(obj) {
    return _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(obj.entity);
}
function isIViewerNode(obj) {
    return obj && obj.entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Node;
}
class LayoutEditor {
    resizeLabel(innerText, objectWithEditedLabel) {
        const dro = objectWithEditedLabel.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.DrawingObjectIndex);
        dro.labelText = innerText;
        this.viewer.invalidate(objectWithEditedLabel.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.ViewerIndex));
    }
    get hasEdgeInsertionPort() {
        return this.SourcePort != null || this.TargetPort != null;
    }
    get insertingEdge() {
        return this.insertionMode == _iViewer__WEBPACK_IMPORTED_MODULE_2__.InsertionMode.Edge;
    }
    createUndoPoint() {
        this.geomGraphEditor.createUndoPoint();
    }
    registerDelete(entity) {
        this.geomGraphEditor.registerDelete(entity);
    }
    registerAdd(entity) {
        this.geomGraphEditor.registerAdd(entity);
    }
    /** unregister the element from everywhere */
    forget(ent) {
        this.dragGroup.delete(ent);
        if (this.edgeWithSmoothedPolylineExposed === ent) {
            this.edgeWithSmoothedPolylineExposed = null;
        }
    }
    get edgeWithSmoothedPolylineExposed() {
        return this._edgeWithSmoothedPolylineExposed;
    }
    set edgeWithSmoothedPolylineExposed(value) {
        if (this._edgeWithSmoothedPolylineExposed !== value) {
            if (this._edgeWithSmoothedPolylineExposed) {
                this._edgeWithSmoothedPolylineExposed.selectedForEditing = false;
            }
        }
        this._edgeWithSmoothedPolylineExposed = value;
        if (value) {
            value.selectedForEditing = true;
            this.geomGraphEditor.geomEdgeWithSmoothedPolylineExposed = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge.getGeom(value.edge);
        }
        else {
            this.geomGraphEditor.geomEdgeWithSmoothedPolylineExposed = null;
        }
    }
    get ActiveDraggedObject() {
        return this.aActiveDraggedObject;
    }
    set ActiveDraggedObject(value) {
        this.aActiveDraggedObject = value;
    }
    get interactiveEdgeRouter() {
        return this._interactiveEdgeRouter;
    }
    set interactiveEdgeRouter(value) {
        this._interactiveEdgeRouter = value;
    }
    //  Constructor
    constructor(viewerPar) {
        this.RadiusOfPolylineCorner = 10;
        this.geomEdge = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge(null); // keep it to hold the geometry only
        this.EdgeAttr = new _drawingEdge__WEBPACK_IMPORTED_MODULE_4__.DrawingEdge(null, true);
        this.arrowheadLength = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Arrowhead.defaultArrowheadLength;
        this.dragGroup = new Set();
        this.geomGraphEditor = new _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__.GeometryGraphEditor();
        this.mouseMoveThreshold = 0.05;
        this.sourceLoosePolylineWrap = { loosePolyline: null };
        this.sourceOfInsertedEdgeWrap = { node: null };
        this.sourcePortWrap = { port: null };
        this.targetOfInsertedEdgeWrap = { node: null };
        this.targetPortWrap = { port: null };
        this.dragging = false;
        this.edgeAttr = new _drawingEdge__WEBPACK_IMPORTED_MODULE_4__.DrawingEdge(null, true);
        this.viewer = viewerPar;
        this.decorateObjectForDragging = this.defaultObjectDecorator;
        this.removeObjDraggingDecorations = this.defaultObjectDecoratorRemover;
        this.DecorateEdgeForDragging = LayoutEditor.TheDefaultEdgeDecoratorStub;
        this.decorateEdgeLabelForDragging = this.defaultEdgeLabelDecorator;
        this.RemoveEdgeDraggingDecorations = LayoutEditor.TheDefaultEdgeDecoratorStub;
        this.geomGraphEditor.graph = () => _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(this._graph);
    }
    ViewerObjectUnderMouseCursorChanged(sender, e) {
        if (this.TargetPort != null) {
            this.viewer.RemoveTargetPortEdgeRouting();
            this.TargetPort = null;
        }
    }
    ViewChangeEventHandler(sender, e) {
        if (this._graph == null) {
            return;
        }
    }
    /**  current graph under editing */
    get graph() {
        return this._graph;
    }
    set graph(value) {
        this._graph = value;
        this.geomGraphEditor.clear();
    }
    //  If the distance between the mouse down point and the mouse up point is greater than the threshold
    //  then we have a mouse move. Otherwise we have a click.
    get MouseMoveThreshold() {
        return this.mouseMoveThreshold;
    }
    set MouseMoveThreshold(value) {
        this.mouseMoveThreshold = value;
    }
    get DecorateEdgeForDragging() {
        return this.decorateEdgeForDragging;
    }
    set DecorateEdgeForDragging(value) {
        this.decorateEdgeForDragging = value;
    }
    //  a delegate to remove edge decorations
    get RemoveEdgeDraggingDecorations() {
        return this.removeEdgeDraggingDecorations;
    }
    set RemoveEdgeDraggingDecorations(value) {
        this.removeEdgeDraggingDecorations = value;
    }
    get NodeInsertPredicate() {
        return this.nodeInsertPredicate;
    }
    set NodeInsertPredicate(value) {
        this.nodeInsertPredicate = value;
    }
    get SourceOfInsertedEdge() {
        return this.sourceOfInsertedEdgeWrap.node;
    }
    set SourceOfInsertedEdge(value) {
        this.sourceOfInsertedEdgeWrap.node = value;
    }
    get TargetOfInsertedEdge() {
        return this.targetOfInsertedEdgeWrap.node;
    }
    set TargetOfInsertedEdge(value) {
        this.targetOfInsertedEdgeWrap.node = value;
    }
    /** gets the port from the wrapper */
    get SourcePort() {
        return this.sourcePortWrap.port;
    }
    /** set the port for the wrapper */
    set SourcePort(value) {
        this.sourcePortWrap.port = value;
    }
    /** gets the port from the wrapper */
    get TargetPort() {
        return this.targetPortWrap.port;
    }
    /** sets the port for the wrapper */
    set TargetPort(value) {
        this.targetPortWrap.port = value;
    }
    //  returns true if Undo is available
    get CanUndo() {
        return this.geomGraphEditor.canUndo;
    }
    //  return true if Redo is available
    get CanRedo() {
        return this.geomGraphEditor.canRedo;
    }
    get insertionMode() {
        if (this.viewer == null)
            return _iViewer__WEBPACK_IMPORTED_MODULE_2__.InsertionMode.Default;
        return this.viewer.insertionMode;
    }
    set insertionMode(value) {
        if (this.viewer == null)
            return;
        this.viewer.insertionMode = value;
    }
    viewerGraphChanged() {
        this._graph = this.viewer.graph;
        this.geomGraphEditor.clear();
        if (this._graph != null && _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(this._graph) != null) {
            this.geomGraphEditor.clear();
        }
        this.ActiveDraggedObject = null;
        this.dragGroup.clear();
        this.cleanObstacles();
    }
    cleanObstacles() {
        this.interactiveEdgeRouter = null;
        this.looseObstaclesToTheirViewerNodes = null;
        this.SourceOfInsertedEdge = null;
        this.TargetOfInsertedEdge = null;
        this.SourcePort = null;
        this.TargetPort = null;
        this.viewer.RemoveSourcePortEdgeRouting();
        this.viewer.RemoveTargetPortEdgeRouting();
    }
    RelayoutOnIsCollapsedChanged(iCluster) {
        this.geomGraphEditor.PrepareForClusterCollapseChange([iCluster]);
        const geomGraph = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(iCluster.node);
        if (geomGraph.isCollapsed) {
            this.CollapseCluster(iCluster.node);
        }
        else {
            this.ExpandCluster(geomGraph);
        }
        // LayoutAlgorithmSettings.ShowGraph(viewer.Graph.GeometryGraph);
        for (const o of this.geomGraphEditor.entitiesToBeChangedByUndo()) {
            this.invalidate(o);
        }
    }
    relayout(cluster) {
        let parent = cluster;
        while (parent.parent != null) {
            parent = parent.parent;
        }
        (0,_msagl_core__WEBPACK_IMPORTED_MODULE_0__.layoutGeomGraph)(parent); // TODO: this call relayouts everything. Try to optimize.
        this.MakeExpandedNodesVisible(cluster.entity);
    }
    ExpandCluster(cluster) {
        if (cluster == null)
            return;
        this.relayout(cluster);
    }
    MakeExpandedNodesVisible(cluster) {
        for (const node of cluster.shallowNodes) {
            const iviewerNode = viewerObj(node);
            LayoutEditor.UnhideNodeEdges(node);
            iviewerNode.isVisible = true;
            if (node instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Graph) {
                const geomGraph = node.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.GeomObjectIndex);
                if (geomGraph.isCollapsed == false)
                    this.MakeExpandedNodesVisible(node);
            }
        }
    }
    static UnhideNodeEdges(drn) {
        for (const e of drn.selfEdges) {
            const viewerObject = viewerObj(e);
            viewerObject.isVisible = true;
        }
        for (const e of drn.outEdges) {
            if (viewerObj(e.target).isVisible)
                viewerObj(e).isVisible = true;
        }
        for (const e of drn.inEdges) {
            if (viewerObj(e.source).isVisible)
                viewerObj(e).isVisible = true;
        }
    }
    CollapseCluster(graph) {
        LayoutEditor.HideCollapsed(graph);
        const geomCluster = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(graph);
        const center = geomCluster.center;
        geomCluster.boundingBox = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkSizeCenter(geomCluster.labelSize, center);
        this.relayout(geomCluster);
    }
    static HideCollapsed(cluster) {
        for (const n of cluster.shallowNodes) {
            viewerObj(n).isVisible = false;
            if (n instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Graph) {
                if (_msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(n).isCollapsed == false)
                    LayoutEditor.HideCollapsed(n);
            }
        }
    }
    defaultObjectDecorator(obj) {
        if (obj.entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Label) {
            this.decorateEdgeLabelForDragging(obj);
            return;
        }
        const drawingObj = _drawingNode__WEBPACK_IMPORTED_MODULE_5__.DrawingNode.getDrawingObj(obj.entity);
        const w = drawingObj.penwidth;
        if (!obj.unmarkedForDraggingCallback) {
            obj.unmarkedForDraggingCallback = () => (_drawingObject__WEBPACK_IMPORTED_MODULE_6__.DrawingObject.getDrawingObj(obj.entity).penwidth = w);
        }
        drawingObj.penwidth = Math.max(this.viewer.LineThicknessForEditing, w * 2);
        this.invalidate(obj.entity);
    }
    defaultObjectDecoratorRemover(obj) {
        const decoratorRemover = obj.unmarkedForDraggingCallback;
        if (decoratorRemover) {
            decoratorRemover();
            obj.unmarkedForDraggingCallback = null;
            this.invalidate(obj.entity);
        }
        const ent = obj.entity;
        if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Node) {
            for (const edge of ent.edges) {
                this.removeObjDraggingDecorations(viewerObj(edge));
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    static TheDefaultEdgeDecoratorStub(edge) { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    defaultEdgeLabelDecorator(label) {
        const geomLabel = label.entity.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.GeomObjectIndex);
        if (label.markedForDragging) {
            _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__.GeometryGraphEditor.calculateAttachmentSegment(geomLabel);
            label.unmarkedForDraggingCallback = () => {
                this.invalidate(label.entity);
            };
        }
        this.invalidate(label.entity);
    }
    static LeftButtonIsPressed(e) {
        return (e.buttons & 1) == 1;
    }
    static MiddleButtonIsPressed(e) {
        return (e.buttons & 4) == 4;
    }
    static RightButtonIsPressed(e) {
        return (e.buttons & 2) == 2;
    }
    MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e) {
        if (this.mouseDownScreenPoint == null)
            return false;
        const x = e.clientX;
        const y = e.clientY;
        const dx = (this.mouseDownScreenPoint.x - x) / this.viewer.DpiX;
        const dy = (this.mouseDownScreenPoint.y - y) / this.viewer.DpiY;
        return Math.sqrt(dx * dx + dy * dy) > this.MouseMoveThreshold / 3;
    }
    analyzeLeftMouseButtonClick(e) {
        if (this.edgeWithSmoothedPolylineExposed) {
            this.toggleCornerForSelectedEdge();
        }
        else if (this.viewer.objectUnderMouseCursor) {
            this.analyzeLeftMouseButtonClickOnObjectUnderCursor(e);
        }
    }
    analyzeLeftMouseButtonClickOnObjectUnderCursor(e) {
        const obj = this.viewer.objectUnderMouseCursor;
        const modifierKeyIsPressed = e.ctrlKey || e.shiftKey;
        const editableObj = obj.entity;
        if (editableObj instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Edge) {
            const geomEdge = editableObj.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.GeomObjectIndex);
            if (geomEdge != null && this.viewer.layoutEditingEnabled) {
                if (geomEdge.smoothedPolyline == null) {
                    geomEdge.smoothedPolyline = LayoutEditor.CreateUnderlyingPolyline(geomEdge);
                }
                if (this.edgeWithSmoothedPolylineExposed !== obj)
                    this.switchToEdgeEditing(obj);
            }
        }
        else {
            if (obj.markedForDragging) {
                this.unselectForDragging(obj);
            }
            else {
                if (!modifierKeyIsPressed) {
                    this.unselectEverything();
                }
                this.selectObjectForDragging(obj);
            }
            this.unselectEdge();
        }
    }
    toggleCornerForSelectedEdge() {
        const corner = _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__.GeometryGraphEditor.findClosestCornerForEdit(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).smoothedPolyline, this.mouseDownGraphPoint, this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner);
        if (corner == null) {
            this.tryInsertCorner();
        }
        else {
            if (corner.prev == null || corner.next == null) {
                return; // ignore the source and the target corners
            }
            this.geomGraphEditor.createUndoPoint();
            this.geomGraphEditor.registerForUndo(this.edgeWithSmoothedPolylineExposed.edge);
            this.geomGraphEditor.deleteSite(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), corner);
            this.invalidate(this.edgeWithSmoothedPolylineExposed.entity);
        }
    }
    tryInsertCorner() {
        // we have to be close enough to the curve
        if (!this.closeEnoughToSelectedEdge()) {
            this.unselectEdge();
        }
        else {
            const a = _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__.GeometryGraphEditor.getPreviousCornerSite(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), this.mouseDownGraphPoint);
            if (a == null)
                return;
            const b = a.next;
            if (b == null)
                return;
            this.geomGraphEditor.insertSite(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), this.mouseDownGraphPoint, a);
            this.invalidate(this.edgeWithSmoothedPolylineExposed.edge);
        }
    }
    closeEnoughToSelectedEdge() {
        const curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).curve;
        const t = curve.closestParameter(this.mouseDownGraphPoint);
        return curve.value(t).sub(this.mouseDownGraphPoint).length < this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner;
    }
    static CreateUnderlyingPolyline(geomEdge) {
        const ret = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.SmoothedPolyline.mkFromPoints(LayoutEditor.CurvePoints(geomEdge));
        return ret;
    }
    static *CurvePoints(geomEdge) {
        yield geomEdge.source.center;
        const isCurve = geomEdge.curve instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Curve;
        if (isCurve) {
            const curve = geomEdge.curve;
            if (curve.segs.length > 0)
                yield curve.start;
            for (let i = 0; i < curve.segs.length; i++)
                yield curve.segs[i].end;
        }
        yield geomEdge.target.center;
    }
    //         static void SetCoefficientsCorrecty(SmoothedPolyline ret, ICurve curve) {
    //            //  throw new NotImplementedException();
    //         }
    ModifierKeyIsPressed() {
        const modifierKeyWasUsed = (this.viewer.modifierKeys & _modifierKeys__WEBPACK_IMPORTED_MODULE_7__.ModifierKeysEnum.Control) == _modifierKeys__WEBPACK_IMPORTED_MODULE_7__.ModifierKeysEnum.Control ||
            (this.viewer.modifierKeys & _modifierKeys__WEBPACK_IMPORTED_MODULE_7__.ModifierKeysEnum.Shift) == _modifierKeys__WEBPACK_IMPORTED_MODULE_7__.ModifierKeysEnum.Shift;
        return modifierKeyWasUsed;
    }
    switchToEdgeEditing(edge) {
        this.unselectEverything();
        this.edgeWithSmoothedPolylineExposed = edge;
        edge.radiusOfPolylineCorner = this.viewer.smoothedPolylineCircleRadius;
        this.DecorateEdgeForDragging(edge);
        this.invalidate(edge.entity);
    }
    *ViewerNodes() {
        for (const o of this.viewer.entities) {
            if (o.entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Node)
                yield o.entity.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.ViewerIndex);
        }
    }
    selectObjectForDragging(obj) {
        if (obj.markedForDragging == false) {
            obj.markedForDragging = true;
            this.dragGroup.add(obj);
            this.decorateObjectForDragging(obj);
        }
    }
    prepareToRemoveFromDragGroup(obj) {
        obj.markedForDragging = false;
        this.removeObjDraggingDecorations(obj);
    }
    unselectForDragging(obj) {
        this.prepareToRemoveFromDragGroup(obj);
        this.dragGroup.delete(obj);
    }
    unselectEverything() {
        for (const obj of this.dragGroup) {
            this.prepareToRemoveFromDragGroup(obj);
        }
        this.dragGroup.clear();
        this.unselectEdge();
    }
    unselectEdge() {
        if (this.edgeWithSmoothedPolylineExposed != null) {
            this.edgeWithSmoothedPolylineExposed.selectedForEditing = false;
            this.removeEdgeDraggingDecorations(this.edgeWithSmoothedPolylineExposed);
            this.invalidate(this.edgeWithSmoothedPolylineExposed.edge);
            this.edgeWithSmoothedPolylineExposed = null;
        }
    }
    static *Edges(node) {
        for (const edge of node.entity.edges) {
            yield viewerObj(edge);
        }
    }
    // returns true if the editor needs own the events
    viewerMouseDown(sender, e) {
        if (!this.viewer.layoutEditingEnabled || this.viewer.graph == null) {
            return false;
        }
        this.viewer.setObjectUnderCursorFromEvent(e);
        this.mouseDownGraphPoint = this.viewer.screenToSource(e);
        this.mouseDownScreenPoint = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Point(e.clientX, e.clientY);
        if (!LayoutEditor.LeftButtonIsPressed(e))
            return false;
        this.leftMouseButtonWasPressed = true;
        if (this.insertingEdge) {
            // if (this.SourceOfInsertedEdge != null && this.SourcePort != null && this.DraggingStraightLine()) {
            //   this.viewer.StartDrawingRubberLine(this.sourcePort.port.Location)
            // }
            return true;
        }
        if (this.insertionMode == _iViewer__WEBPACK_IMPORTED_MODULE_2__.InsertionMode.Node) {
            this.insertNode();
            return true;
        }
        if (this.edgeWithSmoothedPolylineExposed != null) {
            if (this.mouseIsInsideOfCornerSite(e)) {
                e.preventDefault();
            }
            return true;
        }
        const obj = this.viewer.objectUnderMouseCursor;
        if (obj && !this.viewer.objectUnderMouseCursor.hasOwnProperty('edge')) {
            this.ActiveDraggedObject = obj;
            return true;
        }
        if (this.ActiveDraggedObject != null) {
            e.preventDefault();
            return true;
        }
        return false;
    }
    insertNode() {
        const id = this.findNodeID();
        const node = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Node(id);
        this._graph.addNode(node);
        new _drawingNode__WEBPACK_IMPORTED_MODULE_5__.DrawingNode(node); // it would create the default drawing attribute: TODO: keep a customizable attribute here
        const vn = this.viewer.createIViewerNodeN(node, this.mouseDownGraphPoint);
        this.viewer.addNode(vn, true);
    }
    findNodeID() {
        let i = 0;
        let id = 'node' + i.toString();
        while (this._graph.findNode(id)) {
            id = 'node' + ++i;
        }
        return id;
    }
    viewerMouseMove(sender, e) {
        if (!this.viewer.layoutEditingEnabled) {
            return;
        }
        if (LayoutEditor.LeftButtonIsPressed(e)) {
            if (this.ActiveDraggedObject != null || this.activeCornerSite != null) {
                this.drag(e);
            }
            else if (this.insertingEdge) {
                //e.preventDefault()
                //e.stopImmediatePropagation()
                this.mouseMoveInsertEdgeLeftButtonOn(e);
            }
            else {
                this.MouseMoveLiveSelectObjectsForDragging(e);
            }
        }
        else if (this.insertingEdge) {
            this.mouseMoveInsertEdgeNoButtons(e);
        }
    }
    setDraggingFlag(e) {
        if (!this.dragging && this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e)) {
            this.dragging = true;
        }
    }
    TrySetNodePort(e, nodeWrapper, portWr, loosePolylineWrapper) {
        if (this.graph == null)
            return;
        _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Assert.assert(this.insertingEdge);
        const mousePos = this.viewer.screenToSource(e);
        loosePolylineWrapper.loosePolyline = null;
        if (this.DraggingStraightLine()) {
            nodeWrapper.node = this.setPortWhenDraggingStraightLine(portWr, mousePos);
        }
        else {
            if (this.interactiveEdgeRouter == null) {
                this.PrepareForEdgeDragging();
            }
            loosePolylineWrapper.loosePolyline = this.interactiveEdgeRouter.GetHitLoosePolyline(mousePos);
            if (loosePolylineWrapper.loosePolyline != null) {
                this.SetPortUnderLoosePolyline(mousePos, loosePolylineWrapper.loosePolyline, nodeWrapper, portWr);
            }
            else {
                nodeWrapper.node = null;
                portWr.port = null;
            }
        }
        return portWr.port != null;
    }
    setPortWhenDraggingStraightLine(portWr, mousePos) {
        if (isIViewerNode(this.viewer.objectUnderMouseCursor)) {
            const viewerNode = this.viewer.objectUnderMouseCursor;
            const t = { portParameter: 0 };
            const geomNode = geomObjFromIViewerObj(viewerNode);
            if (this.NeedToCreateBoundaryPort(mousePos, viewerNode, t)) {
                portWr.port = this.CreateOrUpdateCurvePort(t.portParameter, geomNode, portWr.port);
            }
            else if (LayoutEditor.PointIsInside(mousePos, geomNode.boundaryCurve)) {
                portWr.port = this.CreateFloatingPort(geomNode, mousePos);
            }
            else {
                portWr.port = null;
            }
            return viewerNode;
        }
        portWr.port = null;
        return null;
    }
    CreateOrUpdateCurvePort(t, geomNode, port) {
        const isCp = port instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurvePort;
        if (!isCp) {
            return _msagl_core__WEBPACK_IMPORTED_MODULE_0__.CurvePort.mk(geomNode.boundaryCurve, t);
        }
        const cp = port;
        cp.parameter = t;
        cp.curve = geomNode.boundaryCurve;
        return port;
    }
    CreateFloatingPort(geomNode, location) {
        return new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.FloatingPort(geomNode.boundaryCurve, location);
    }
    SetPortUnderLoosePolyline(mousePos, loosePoly, nodeWr, portWrap) {
        let dist = Number.POSITIVE_INFINITY;
        let par = 0;
        for (const viewerNode of this.GetViewerNodesInsideOfLooseObstacle(loosePoly)) {
            const curve = viewerNode.entity.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.GeomObjectIndex).boundaryCurve;
            if (LayoutEditor.PointIsInside(mousePos, curve)) {
                nodeWr.node = viewerNode;
                this.SetPortForMousePositionInsideOfNode(mousePos, nodeWr.node, portWrap);
                return;
            }
            const p = curve.closestParameter(mousePos);
            const d = curve.value(p).sub(mousePos).length;
            if (d < dist) {
                par = p;
                dist = d;
                nodeWr.node = viewerNode;
            }
        }
        portWrap.port = this.CreateOrUpdateCurvePort(par, geomObjFromIViewerObj(nodeWr.node), portWrap.port);
    }
    GetViewerNodesInsideOfLooseObstacle(loosePoly) {
        if (this.looseObstaclesToTheirViewerNodes == null) {
            this.InitLooseObstaclesToViewerNodeMap();
        }
        const ret = this.looseObstaclesToTheirViewerNodes.get(loosePoly);
        return ret;
    }
    InitLooseObstaclesToViewerNodeMap() {
        this.looseObstaclesToTheirViewerNodes = new Map();
        for (const viewerNode of this.ViewerNodes()) {
            const loosePoly = this.interactiveEdgeRouter.GetHitLoosePolyline(geomObjFromIViewerObj(viewerNode).center);
            let loosePolyNodes = this.looseObstaclesToTheirViewerNodes.get(loosePoly);
            if (loosePolyNodes == undefined) {
                this.looseObstaclesToTheirViewerNodes.set(loosePoly, (loosePolyNodes = new Array()));
            }
            loosePolyNodes.push(viewerNode);
        }
    }
    SetPortForMousePositionInsideOfNode(mousePosition, node, port) {
        const geomNode = geomObjFromIViewerObj(node);
        const t = { portParameter: 0 };
        if (this.NeedToCreateBoundaryPort(mousePosition, node, t)) {
            port.port = this.CreateOrUpdateCurvePort(t.portParameter, geomNode, port.port);
        }
        else {
            port.port = this.CreateFloatingPort(geomNode, mousePosition);
        }
    }
    static PointIsInside(point, iCurve) {
        return _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Curve.PointRelativeToCurveLocation(point, iCurve) == _msagl_core__WEBPACK_IMPORTED_MODULE_0__.PointLocation.Inside;
    }
    NeedToCreateBoundaryPort(mousePoint, node, t) {
        const drawingNode = node.entity.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.DrawingObjectIndex);
        const curve = geomObjFromIViewerObj(node).boundaryCurve;
        t.portParameter = curve.closestParameter(mousePoint);
        const pointOnCurve = curve.value(t.portParameter);
        const length = mousePoint.sub(pointOnCurve).length;
        if (length <= this.viewer.smoothedPolylineCircleRadius * 2 + drawingNode.penwidth / 2) {
            this.TryToSnapToTheSegmentEnd(t, curve, pointOnCurve);
            return true;
        }
        return false;
    }
    TryToSnapToTheSegmentEnd(t, c, pointOnCurve) {
        if (c instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Curve) {
            const sipar = c.getSegIndexParam(t.portParameter);
            const segPar = sipar.par;
            const seg = c.segs[sipar.segIndex];
            if (segPar - seg.parStart < seg.parEnd - segPar) {
                if (seg.start.sub(pointOnCurve).length < this.viewer.smoothedPolylineCircleRadius * 2) {
                    t.portParameter -= segPar - seg.parStart;
                }
                else if (seg.end.sub(pointOnCurve).length < this.viewer.smoothedPolylineCircleRadius * 2) {
                    t.portParameter += +(seg.parEnd - segPar);
                }
            }
        }
    }
    drag(e) {
        if (!this.dragging) {
            if (this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e)) {
                this.prepareFirstTimeDragging();
            }
            else {
                // the mouse has not moved enough
                return;
            }
        }
        const currentDragPoint = this.viewer.screenToSource(e);
        this.handleTheMouseCursorOutOfTheBoundingBox(currentDragPoint);
        this.geomGraphEditor.drag(currentDragPoint.sub(this._lastDragPoint), this.GetDraggingMode(), this._lastDragPoint);
        for (const affectedObject of this.geomGraphEditor.entitiesToBeChangedByUndo()) {
            this.invalidate(affectedObject);
        }
        e.stopPropagation();
        this._lastDragPoint = currentDragPoint;
    }
    prepareFirstTimeDragging() {
        this.dragging = true;
        // first time we are in dragging
        if (this.activeCornerSite != null) {
            this.geomGraphEditor.prepareForGeomEdgeChange(this.edgeWithSmoothedPolylineExposed.edge.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.GeomObjectIndex));
        }
        else if (this.ActiveDraggedObject != null) {
            this.unselectEdge();
            if (!this.ActiveDraggedObject.markedForDragging) {
                this.unselectEverything();
            }
            this.prepareForDragging();
        }
        this._lastDragPoint = this.mouseDownGraphPoint;
    }
    handleTheMouseCursorOutOfTheBoundingBox(currentDragPoint) {
        const w = this.viewer.smoothedPolylineCircleRadius; // some rather small but still visible distance on the screen
        const mousePointerBox = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle.mkSizeCenter(new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Size(w, w), currentDragPoint);
        const g = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(this._graph);
        if (!g.boundingBox.containsRect(mousePointerBox)) {
            this.geomGraphEditor.registerForUndo(this._graph);
            g.boundingBox = g.boundingBox.addRec(mousePointerBox);
            this.invalidate(this._graph);
        }
    }
    prepareForDragging() {
        this.selectObjectForDragging(this.ActiveDraggedObject);
        this.geomGraphEditor.prepareForObjectDragging(this.DraggedGeomObjects(), this.GetDraggingMode());
        //  const currentUndoRedo = this.undoAction
        // for (const g of this.geomGraphEditor.objectsToDrag) {
        //   currentUndoRedo.AddAffectedObject(g.entity.getAttr(AttributeRegistry.ViewerIndex))
        //   currentUndoRedo.AddRestoreData(g.entity, getRestoreData(g.entity))
        // }
    }
    GetDraggingMode() {
        const incremental = (this.viewer.modifierKeys & _modifierKeys__WEBPACK_IMPORTED_MODULE_7__.ModifierKeysEnum.Shift) == _modifierKeys__WEBPACK_IMPORTED_MODULE_7__.ModifierKeysEnum.Shift || this.viewer.IncrementalDraggingModeAlways;
        return incremental ? _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__.DraggingMode.Incremental : _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__.DraggingMode.Default;
    }
    static RouteEdgesRectilinearly(viewer) {
        const geomGraph = viewer.graph.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.GeomObjectIndex);
        const settings = geomGraph.layoutSettings;
        _msagl_core__WEBPACK_IMPORTED_MODULE_0__.RectilinearInteractiveEditor.CreatePortsAndRouteEdges(settings.commonSettings.NodeSeparation / 3, 1, geomGraph.nodesBreadthFirst, geomGraph.deepEdges, settings.commonSettings.edgeRoutingSettings.EdgeRoutingMode);
        const labelPlacer = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.EdgeLabelPlacement.constructorG(geomGraph);
        labelPlacer.run();
    }
    *DraggedGeomObjects() {
        // restrict the dragged elements to be under the same cluster
        const activeObjCluster = LayoutEditor.GetActiveObjectCluster(this.ActiveDraggedObject);
        for (const draggObj of this.dragGroup) {
            if (LayoutEditor.GetActiveObjectCluster(draggObj) == activeObjCluster) {
                yield _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(draggObj.entity);
            }
        }
    }
    static GetActiveObjectCluster(viewerObject) {
        return viewerObject.entity.parent;
    }
    viewerMouseUp(sender, args) {
        if (args.defaultPrevented) {
            return;
        }
        if (!this.viewer.layoutEditingEnabled) {
            return;
        }
        this.handleMouseUpOnLayoutEnabled(args);
    }
    handleMouseUpOnLayoutEnabled(args) {
        const click = !this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(args);
        if (click && this.leftMouseButtonWasPressed) {
            if (this.viewer.objectUnderMouseCursor != null || this.edgeWithSmoothedPolylineExposed != null) {
                this.analyzeLeftMouseButtonClick(args);
                args.preventDefault();
            }
            else {
                this.unselectEverything();
            }
        }
        else if (this.dragging) {
            if (!this.insertingEdge) {
                this.geomGraphEditor.updateDeltaForDragUndo(this.mouseDownGraphPoint.sub(this._lastDragPoint));
                this.interactiveEdgeRouter = null;
                this.looseObstaclesToTheirViewerNodes = null;
            }
            else {
                this.InsertEdgeOnMouseUp();
            }
            const gg = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(this._graph);
            const newBox = gg.getPumpedGraphWithMarginsBox();
            if (!newBox.equal(gg.boundingBox)) {
                this.geomGraphEditor.registerForUndo(this._graph);
                gg.boundingBox = newBox;
                this.invalidate(this._graph);
                args.preventDefault();
            }
        }
        this.dragging = false;
        this.geomGraphEditor.ForgetDragging();
        this.activeCornerSite = null;
        this.ActiveDraggedObject = null;
        this.leftMouseButtonWasPressed = false;
        if (this.TargetPort != null) {
            this.viewer.RemoveTargetPortEdgeRouting();
        }
        if (this.SourcePort != null) {
            this.viewer.RemoveSourcePortEdgeRouting();
        }
        this.TargetOfInsertedEdge = null;
        this.SourceOfInsertedEdge = null;
        this.TargetPort = null;
        this.SourcePort = null;
    }
    InsertEdgeOnMouseUp() {
        this.viewer.stopDrawingRubberEdge();
        if (this.TargetPort != null) {
            const e = this.FinishRoutingEdge();
            this.addEdgeToTheViewer(e);
        }
        this.interactiveEdgeRouter.Clean();
    }
    addEdgeToTheViewer(e) {
        const vEdge = this.viewer.createEdgeWithGivenGeometry(e);
        this.viewer.addEdge(vEdge, true);
    }
    mkArrowhead() {
        const arr = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Arrowhead();
        arr.length = this.arrowheadLength;
        return arr;
    }
    FinishRoutingEdge() {
        const e = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Edge(this.sourceOfInsertedEdgeWrap.node.entity, this.targetOfInsertedEdgeWrap.node.entity);
        e.add();
        const edgeAttr = this.EdgeAttr.clone();
        edgeAttr.rebind(e);
        this.geomEdge.rebind(e);
        this.geomEdge.sourceArrowhead = edgeAttr.arrowtail == _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_3__.ArrowTypeEnum.none ? null : this.mkArrowhead();
        this.geomEdge.targetArrowhead = edgeAttr.arrowhead == _arrowTypeEnum__WEBPACK_IMPORTED_MODULE_3__.ArrowTypeEnum.none ? null : this.mkArrowhead();
        if (this.TargetOfInsertedEdge != this.SourceOfInsertedEdge) {
            if (!(this.geomEdge.curve instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.LineSegment)) {
                this.interactiveEdgeRouter.TryToRemoveInflectionsAndCollinearSegments(this.geomEdge.smoothedPolyline);
                this.interactiveEdgeRouter.SmoothenCorners(this.geomEdge.smoothedPolyline);
                this.geomEdge.curve = this.geomEdge.smoothedPolyline.createCurve();
            }
            _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Arrowhead.trimSplineAndCalculateArrowheads(this.geomEdge, this.geomEdge.curve, true);
        }
        else {
            this.geomEdge = LayoutEditor.CreateEdgeGeometryForSelfEdge(this.SourceOfInsertedEdge.entity);
        }
        this.viewer.RemoveSourcePortEdgeRouting();
        this.viewer.RemoveTargetPortEdgeRouting();
        return e;
    }
    static CreateEdgeGeometryForSelfEdge(node) {
        const edge = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Edge(node, node);
        const geomEdge = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge(edge);
        _msagl_core__WEBPACK_IMPORTED_MODULE_0__.StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(geomEdge);
        return geomEdge;
    }
    SelectEntitiesForDraggingWithRectangle(args) {
        /*
        const rect = Rectangle.mkPP(this.mouseDownGraphPoint, this.viewer.ScreenToSource(args))
        for (const node of this.ViewerNodes()) {
          if (rect.intersects(geomNodeOfIViewerNode(node).boundingBox)) {
            this.selectObjectForDragging(node)
          }
        }
        if (rect.width > 0) {
          args.stopImmediatePropagation()
        }*/
    }
    /** it also sets this.activeCornerSite */
    mouseIsInsideOfCornerSite(e) {
        const p = this.viewer.screenToSource(e);
        const lw = this.edgeWithSmoothedPolylineExposed.edge.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.DrawingObjectIndex).penwidth;
        this.activeCornerSite = _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__.GeometryGraphEditor.findClosestCornerForEdit(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).smoothedPolyline, p, this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner + lw);
        return this.activeCornerSite !== null;
    }
    MouseScreenPointIsCloseEnoughToVertex(point, radius) {
        return point.sub(this.mouseDownGraphPoint).length < radius;
    }
    invalidate(ent) {
        const vo = viewerObj(ent);
        if (!vo)
            return;
        if (vo.entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Label) {
            if (vo.markedForDragging) {
                const geomLabel = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(vo.entity);
                _geomGraphEditor__WEBPACK_IMPORTED_MODULE_1__.GeometryGraphEditor.calculateAttachmentSegment(geomLabel);
            }
        }
        else {
            if (vo.entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Edge) {
                if (vo.entity.label) {
                    this.viewer.invalidate(viewerObj(vo.entity.label));
                }
            }
        }
        this.viewer.invalidate(vo);
        if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Graph) {
            for (const n of ent.nodesBreadthFirst) {
                this.viewer.invalidate(viewerObj(n));
            }
            for (const e of ent.deepEdges) {
                this.viewer.invalidate(viewerObj(e));
                if (e.label)
                    this.viewer.invalidate(viewerObj(e.label));
            }
        }
    }
    /**   Undoes the editing*/
    undo() {
        if (this.geomGraphEditor.canUndo) {
            const objectsToInvalidate = new Set(this.geomGraphEditor.entitiesToBeChangedByUndo());
            this.geomGraphEditor.undo();
            for (const o of objectsToInvalidate) {
                const vo = viewerObj(o);
                if (vo.markedForDragging) {
                    this.dragGroup.add(vo);
                }
                else {
                    this.dragGroup.delete(vo);
                }
                this.invalidate(o);
            }
        }
    }
    /**   Redo the editing*/
    redo() {
        if (this.geomGraphEditor.canRedo) {
            const objectsToInvalidate = new Set(this.geomGraphEditor.entitiesToBeChangedByRedo());
            this.geomGraphEditor.redo();
            for (const o of objectsToInvalidate) {
                const vo = viewerObj(o);
                if (vo.markedForDragging) {
                    this.dragGroup.add(vo);
                }
                else {
                    this.dragGroup.delete(vo);
                }
                this.invalidate(o);
            }
        }
    }
    // //  Clear the editor
    //  Clear() {
    //     this.UnselectEverything();
    // }
    // //  Finds a corner to delete or insert
    // //  <returns>null if a corner is not found</returns>
    // // //  create a tight bounding box for the graph
    // //  FitGraphBoundingBox(graphToFit: IViewerObject) {
    // //     if ((graphToFit != null)) {
    // //         this.geomGraphEditor.FitGraphBoundingBox(graphToFit, (<GeometryGraph>(graphToFit.DrawingObject.GeomObject)));
    // //         this.invalidate();
    // //     }
    // // }
    // // //
    // //  RegisterNodeAdditionForUndo(node: IViewerNode) {
    // //     let undoAction = new AddNodeUndoAction(this.graph, this.viewer, node);
    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(undoAction);
    // // }
    // // //  registers the edge addition for undo
    // //  RegisterEdgeAdditionForUndo(edge: IViewerEdge) {
    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new AddEdgeUndoAction(this.viewer, edge));
    // // }
    // // //
    // //  RegisterEdgeRemovalForUndo(edge: IViewerEdge) {
    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new RemoveEdgeUndoAction(this.graph, this.viewer, edge));
    // // }
    // // //
    // //  RegisterNodeForRemoval(node: IViewerNode) {
    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new RemoveNodeUndoAction(this.viewer, node));
    // // }
    static RectRouting(mode) {
        return mode == _msagl_core__WEBPACK_IMPORTED_MODULE_0__.EdgeRoutingMode.Rectilinear || mode == _msagl_core__WEBPACK_IMPORTED_MODULE_0__.EdgeRoutingMode.RectilinearToCenter;
    }
    // // EnumerateNodeBoundaryCurves(): IterableIterator<ICurve> {
    // //     return from;
    // //     vn;
    // //     this.ViewerNodes();
    // //     let GeomNode: select;
    // //     vn.BoundaryCurve;
    // // }
    // //  ForgetEdgeDragging() {
    // //     if ((this.viewer.Graph == null)) {
    // //         return;
    // //     }
    // //     if (this.DraggingStraightLine()) {
    // //         return;
    // //     }
    // //     if (!LayoutEditor.RectRouting(this.viewer.Graph.LayoutAlgorithmSettings.EdgeRoutingSettings.EdgeRoutingMode)) {
    // //         InteractiveEdgeRouter = null;
    // //         this.looseObstaclesToTheirViewerNodes = null;
    // //     }
    // // }
    //  prepares for edge dragging
    PrepareForEdgeDragging() {
        if (this.viewer.graph == null) {
            return;
        }
        if (this.DraggingStraightLine()) {
            return;
        }
        const settings = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomGraph.getGeom(this.viewer.graph).layoutSettings;
        if (!LayoutEditor.RectRouting(settings.commonSettings.edgeRoutingSettings.EdgeRoutingMode)) {
            if (this.interactiveEdgeRouter == null) {
                const padding = settings.commonSettings.NodeSeparation / 3;
                const loosePadding = 0.65 * padding;
                this.interactiveEdgeRouter = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.InteractiveEdgeRouter.constructorANNN(Array.from(this._graph.nodesBreadthFirst).map((n) => _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomNode.getGeom(n).boundaryCurve), padding, loosePadding, 0);
            }
        }
    }
    // // //  insert a polyline corner at the point befor the prevCorner
    // //  InsertPolylineCorner(point: Point, previousCorner: CornerSite) {
    // //     this.geomGraphEditor.InsertSite(this.SelectedEdge.edge.GeometryEdge, point, previousCorner, this.SelectedEdge);
    // //     this.invalidate(this.SelectedEdge);
    // // }
    // // InsertPolylineCorner() {
    // //     this.geomGraphEditor.InsertSite(this.SelectedEdge.edge.GeometryEdge, this.mouseRightButtonDownPoint, this.cornerInfo.Item1, this.SelectedEdge);
    // //     this.invalidate(this.SelectedEdge);
    // // }
    // // //  delete the polyline corner, shortcut it.
    // //  DeleteCorner(corner: CornerSite) {
    // //     this.geomGraphEditor.DeleteSite(this.SelectedEdge.edge.GeometryEdge, corner, this.SelectedEdge);
    // //     this.invalidate(this.SelectedEdge);
    // //     this.viewer.OnDragEnd([
    // //                 this.SelectedEdge]);
    // // }
    // // DeleteCorner() {
    // //     this.geomGraphEditor.DeleteSite(this.SelectedEdge.edge.GeometryEdge, this.cornerInfo.Item1, this.SelectedEdge);
    // //     this.invalidate(this.SelectedEdge);
    // //     this.viewer.OnDragEnd([
    // //                 this.SelectedEdge]);
    // // }
    mouseMoveInsertEdgeNoButtons(e) {
        const oldNode = this.SourceOfInsertedEdge;
        if (this.TrySetNodePort(e, this.sourceOfInsertedEdgeWrap, this.sourcePortWrap, this.sourceLoosePolylineWrap)) {
            this.viewer.SetSourcePortForEdgeRouting(this.sourcePortWrap.port.Location);
        }
        else if (oldNode != null) {
            this.viewer.RemoveSourcePortEdgeRouting();
        }
    }
    mouseMoveInsertEdgeLeftButtonOn(e) {
        if (this.SourcePort != null) {
            this.setDraggingFlag(e);
            if (this.dragging) {
                const loosePolylineWr = { loosePolyline: null };
                if (this.TrySetNodePort(e, this.targetOfInsertedEdgeWrap, this.targetPortWrap, loosePolylineWr)) {
                    this.viewer.setTargetPortForEdgeRouting(this.targetPortWrap.port.Location);
                    this.drawEdgeInteractivelyToPort(loosePolylineWr.loosePolyline, this.DraggingStraightLine());
                }
                else {
                    this.viewer.RemoveTargetPortEdgeRouting();
                    this.DrawEdgeInteractivelyToLocation(e, this.DraggingStraightLine());
                }
            }
            e.preventDefault();
        }
    }
    MouseMoveLiveSelectObjectsForDragging(e) {
        this.unselectEverything();
        if (LeftMouseIsPressed(e) && (this.viewer.modifierKeys & _modifierKeys__WEBPACK_IMPORTED_MODULE_7__.ModifierKeysEnum.Shift) != _modifierKeys__WEBPACK_IMPORTED_MODULE_7__.ModifierKeysEnum.Shift) {
            this.SelectEntitiesForDraggingWithRectangle(e);
        }
    }
    DrawEdgeInteractivelyToLocation(e, straightLine) {
        this.DrawEdgeInteractivelyToLocationP(this.viewer.screenToSource(e), straightLine);
    }
    DrawEdgeInteractivelyToLocationP(point, straightLine) {
        this.geomEdge = straightLine ? this.getStraightLineEdge(point) : this.CalculateEdgeInteractivelyToLocation(point);
        this.viewer.drawRubberEdge(this.geomEdge);
    }
    getStraightLineEdge(point) {
        const g = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge(null);
        g.curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(this.SourcePort.Location, point);
        return g;
    }
    CalculateEdgeInteractivelyToLocation(location) {
        if (this.interactiveEdgeRouter.SourcePort == null) {
            this.interactiveEdgeRouter.SetSourcePortAndSourceLoosePolyline(this.SourcePort, this.sourceLoosePolylineWrap.loosePolyline);
        }
        return this.interactiveEdgeRouter.RouteEdgeToLocation(location);
    }
    drawEdgeInteractivelyToPort(portLoosePolyline, straightLine) {
        this.geomEdge = straightLine
            ? this.getStraightLineEdge(this.TargetPort.Location)
            : this.CalculateEdgeInteractively(this.TargetPort, portLoosePolyline);
        this.viewer.drawRubberEdge(this.geomEdge);
    }
    DraggingStraightLine() {
        if (this.viewer.graph == null) {
            return true;
        }
        return this.interactiveEdgeRouter != null && this.interactiveEdgeRouter.OverlapsDetected;
    }
    CalculateEdgeInteractively(targetPortParameter, portLoosePolyline) {
        if (this.interactiveEdgeRouter.SourcePort == null) {
            this.interactiveEdgeRouter.SetSourcePortAndSourceLoosePolyline(this.SourcePort, this.sourceLoosePolylineWrap.loosePolyline);
        }
        let curve;
        let smoothedPolyline = null;
        if (this.SourceOfInsertedEdge == this.TargetOfInsertedEdge) {
            curve = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.LineSegment.mkPP(this.SourcePort.Location, this.TargetPort.Location);
        }
        else {
            const boxedPolyline = { smoothedPolyline: null };
            curve = this.interactiveEdgeRouter.RouteEdgeToPort(targetPortParameter, portLoosePolyline, false, boxedPolyline);
            smoothedPolyline = boxedPolyline.smoothedPolyline;
        }
        const ret = new _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomEdge(null);
        ret.curve = curve;
        ret.smoothedPolyline = smoothedPolyline;
        return ret;
    }
}
// //  ScaleNodeAroundCenter(viewerNode: IViewerNode, scale: number) {
// //     let nodePosition = viewerNode.node.BoundingBox.Center;
// //     let scaleMatrix = new PlaneTransformation(scale, 0, 0, 0, scale, 0);
// //     let translateToOrigin = new PlaneTransformation(1, 0, (nodePosition.X * -1), 0, 1, (nodePosition.Y * -1));
// //     let translateToNode = new PlaneTransformation(1, 0, nodePosition.X, 0, 1, nodePosition.Y);
// //     let matrix = (translateToNode
// //                 * (scaleMatrix * translateToOrigin));
// //     viewerNode.node.GeomNode.BoundaryCurve = viewerNode.node.GeomNode.BoundaryCurve.Transform(matrix);
// //     this.invalidate(viewerNode);
// //     for (let edge of viewerNode.OutEdges.Concat(viewerNode.InEdges).Concat(viewerNode.SelfEdges)) {
// //         this.RecoverEdge(edge);
// //     }
// // }
// // RecoverEdge(edge: IViewerEdge) {
// //     let curve = edge.edge.GeometryEdge.UnderlyingPolyline.CreateCurve();
// //     Arrowheads.TrimSplineAndCalculateArrowheads(edge.edge.GeometryEdge, curve, true, this.Graph.LayoutAlgorithmSettings.EdgeRoutingSettings.KeepOriginalSpline);
// //     this.invalidate(edge);
// // }
// // //
// //  DetachNode(node: IViewerNode) {
// //     if ((node == null)) {
// //         return;
// //     }
// //     this.decoratorRemovalsDict.Remove(node);
// //     for (let edge of LayoutEditor.Edges(node)) {
// //         this.RemoveObjDraggingDecorations(edge);
// //     }
// // }
// }
function LeftMouseIsPressed(e) {
    return (e.buttons & 1) == 1;
}
//# sourceMappingURL=layoutEditor.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/modifierKeys.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModifierKeysEnum: () => (/* binding */ ModifierKeysEnum)
/* harmony export */ });
var ModifierKeysEnum;
(function (ModifierKeysEnum) {
    // No modifiers are pressed.
    ModifierKeysEnum[ModifierKeysEnum["None"] = 0] = "None";
    // THE alt key
    ModifierKeysEnum[ModifierKeysEnum["Alt"] = 1] = "Alt";
    // the control key
    ModifierKeysEnum[ModifierKeysEnum["Control"] = 2] = "Control";
    // the shift key
    ModifierKeysEnum[ModifierKeysEnum["Shift"] = 4] = "Shift";
    // the window logo key
    ModifierKeysEnum[ModifierKeysEnum["Windows"] = 8] = "Windows";
})(ModifierKeysEnum || (ModifierKeysEnum = {}));
//# sourceMappingURL=modifierKeys.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/undoRedoAction.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UndoRedoAction: () => (/* binding */ UndoRedoAction)
/* harmony export */ });
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _drawingObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/drawingObject.js");


/** support for undo/redo functionality */
class UndoRedoAction {
    constructor() {
        this._canUndo = true; // initially
    }
    updateDeltaForDragUndo(delta) {
        const data = this.data;
        data.delta = delta;
    }
    registerUndoDrag(entity) {
        if (this.data == null) {
            this.data = { draggedEnts: new Set(), delta: null, changeData: new Map() };
        }
        if ('draggedEnts' in this.data) {
            this.data.draggedEnts.add(entity);
        }
    }
    undo() {
        _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Assert.assert(this.canUndo);
        if (this.data instanceof Map) {
            for (const [e, v] of this.data) {
                for (const pair of v) {
                    // prepare for redo as well
                    pair.new = e.getAttr(registryIndexOfAttribue(pair.old)).clone();
                    pair.old.rebind(e);
                }
            }
        }
        else if (this.data && 'deletedEnts' in this.data) {
            for (const e of this.data.deletedEnts) {
                restoreDeletedEntity(e);
            }
        }
        else if ('insertedEnts' in this.data) {
            for (const ent of this.data.insertedEnts) {
                const graph = ent.parent;
                if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Node) {
                    graph.removeNode(ent);
                }
                else if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Edge) {
                    ent.remove();
                }
                else {
                    throw new Error('not implemented');
                }
            }
        }
        else if ('draggedEnts' in this.data) {
            for (const e of this.data.draggedEnts) {
                const geom = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(e);
                geom.translate(this.data.delta);
            }
            for (const [e, v] of this.data.changeData) {
                for (const pair of v) {
                    // prepare for redo as well
                    pair.new = e.getAttr(registryIndexOfAttribue(pair.old)).clone();
                    pair.old.rebind(e);
                }
            }
        }
        else {
            throw new Error('not implemented');
        }
        this.canUndo = false;
    }
    redo() {
        _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Assert.assert(this.canRedo);
        if (this.data instanceof Map) {
            for (const [e, v] of this.data) {
                for (const pair of v) {
                    const attr = pair.new;
                    attr.rebind(e);
                }
            }
        }
        else if ('deletedEnts' in this.data) {
            for (const ent of this.data.deletedEnts) {
                if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Graph) {
                    ent.removeSubgraph();
                }
                else if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Node) {
                    const graph = ent.parent;
                    graph.removeNode(ent);
                }
                else if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Edge) {
                    ent.remove();
                }
                else if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Label) {
                    const edge = ent.parent;
                    edge.label = null;
                }
                else {
                    throw new Error('unexpected type in redo');
                }
            }
        }
        else if ('draggedEnts' in this.data) {
            const del = this.data.delta.neg();
            for (const e of this.data.draggedEnts) {
                const geom = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomObject.getGeom(e);
                geom.translate(del);
            }
            for (const [e, v] of this.data.changeData) {
                for (const pair of v) {
                    const attr = pair.new;
                    attr.rebind(e);
                }
            }
        }
        else if ('insertedEnts' in this.data) {
            for (const ent of this.data.insertedEnts) {
                restoreDeletedEntity(ent);
            }
        }
        else {
            throw new Error('not implemented');
        }
        this.canUndo = true;
    }
    /** It adds an entry for the entity if the changes does not contain the entity as a key
     *  Also, only one pair is added for each index.
     *  'old' will be restored by undo  */
    addOldNewPair(entity, old) {
        if (!this.data) {
            this.data = new Map();
        }
        const changesInAttributes = 'draggedEnts' in this.data ? this.data.changeData : this.data;
        if (!changesInAttributes.has(entity)) {
            changesInAttributes.set(entity, []);
        }
        const index = registryIndexOfAttribue(old);
        const pairs = changesInAttributes.get(entity);
        if (pairs[index] != null)
            return;
        pairs[index] = { old: old.clone(), new: null };
    }
    registerDelete(entity) {
        if (!this.data)
            this.data = { deletedEnts: new Set() };
        const dd = this.data;
        dd.deletedEnts.add(entity);
    }
    registerAdd(entity) {
        if (!this.data)
            this.data = { insertedEnts: new Set() };
        const dd = this.data;
        dd.insertedEnts.add(entity);
    }
    get canRedo() {
        return !this._canUndo;
    }
    /** canUndo = true means that the relevant objects, the keys of restoreDataDictionary, have 'old' attributes set up: ready for undo
     *  canUndo = false means that the undo has been done already:
     */
    get canUndo() {
        return this._canUndo;
    }
    set canUndo(v) {
        this._canUndo = v;
    }
    /** iterates over the affected objects */
    *entities() {
        if (!this.data)
            return;
        if (this.data instanceof Map)
            yield* this.data.keys();
        else if ('draggedEnts' in this.data) {
            yield* this.data.changeData.keys();
            yield* this.data.draggedEnts;
        }
        else if ('deletedEnts' in this.data)
            yield* this.data.deletedEnts;
        else if ('insertedEnts' in this.data)
            yield* this.data.insertedEnts;
        else {
            throw new Error('not implemented');
        }
    }
}
function registryIndexOfAttribue(old) {
    let index;
    if (old instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.GeomObject)
        index = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.GeomObjectIndex;
    else if (old instanceof _drawingObject__WEBPACK_IMPORTED_MODULE_1__.DrawingObject)
        index = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.DrawingObjectIndex;
    else {
        // todo: enforce type here
        index = _msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.ViewerIndex;
    }
    return index;
}
function restoreDeletedEntity(ent) {
    if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Label) {
        const edge = ent.parent;
        edge.label = ent;
    }
    else if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Graph) {
        const graph = ent.parent;
        graph.addNode(ent);
        /** reattach all the edges, that might be removed.
         * attaching twice does not have an effect
         */
        for (const edge of ent.edges) {
            edge.add();
        }
        for (const n of ent.nodesBreadthFirst) {
            for (const e of n.outEdges)
                e.add();
            for (const e of n.inEdges)
                e.add();
        }
    }
    else if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Node) {
        const graph = ent.parent;
        graph.addNode(ent);
    }
    else if (ent instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Edge)
        ent.add();
}
//# sourceMappingURL=undoRedoAction.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/layoutEditing/undoRedoActionsList.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UndoList: () => (/* binding */ UndoList)
/* harmony export */ });
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _undoRedoAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/layoutEditing/undoRedoAction.js");


class UndoList {
    updateDeltaForDragUndo(delta) {
        this.currentBridge.updateDeltaForDragUndo(delta);
    }
    registerForUndoDrag(entity) {
        if (this.currentBridge == null) {
            this.currentBridge = new _undoRedoAction__WEBPACK_IMPORTED_MODULE_1__.UndoRedoAction();
        }
        this.currentBridge.registerUndoDrag(entity);
    }
    registerDelete(entity) {
        if (this.currentBridge == null) {
            this.currentBridge = new _undoRedoAction__WEBPACK_IMPORTED_MODULE_1__.UndoRedoAction();
        }
        this.currentBridge.registerDelete(entity);
    }
    registerAdd(entity) {
        this.createUndoPoint();
        this.currentBridge.registerAdd(entity);
    }
    *entitiesToBeChangedByRedo() {
        if (this.currentBridge == null)
            return;
        if (this.currentBridge.canRedo) {
            yield* this.currentBridge.entities();
        }
        else if (this.currentBridge.next != null && this.currentBridge.next.canRedo) {
            yield* this.currentBridge.next.entities();
        }
    }
    *entitiesToBeChangedByUndo() {
        if (this.currentBridge == null)
            return;
        if (this.currentBridge.canUndo) {
            yield* this.currentBridge.entities();
        }
        else if (this.currentBridge.prev != null && this.currentBridge.prev.canUndo) {
            yield* this.currentBridge.prev.entities();
        }
    }
    /** registers some attributes of the entity for undo */
    registerForUndo(e) {
        if (this.currentBridge == null) {
            this.currentBridge = new _undoRedoAction__WEBPACK_IMPORTED_MODULE_1__.UndoRedoAction();
        }
        this.currentBridge.addOldNewPair(e, e.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_0__.AttributeRegistry.GeomObjectIndex));
    }
    canUndo() {
        if (this.currentBridge == null)
            return false;
        if (this.currentBridge.canUndo)
            return true;
        if (this.currentBridge.prev != null && this.currentBridge.prev.canUndo)
            return true;
        return false;
    }
    canRedo() {
        if (this.currentBridge == null)
            return false;
        if (this.currentBridge.canRedo)
            return true;
        if (this.currentBridge.next != null && this.currentBridge.next.canRedo)
            return true;
        return false;
    }
    undo() {
        if (!this.canUndo)
            return;
        if (this.currentBridge.canUndo) {
            this.currentBridge.undo();
        }
        else {
            this.currentBridge.prev.undo();
        }
        if (this.currentBridge.prev)
            this.currentBridge = this.currentBridge.prev;
    }
    redo() {
        if (!this.canRedo)
            return;
        if (this.currentBridge.canRedo) {
            this.currentBridge.redo();
        }
        else {
            this.currentBridge.next.redo();
        }
        if (this.currentBridge.next) {
            this.currentBridge = this.currentBridge.next;
        }
    }
    /** If the current undo has not been undone, the adds the "action" after the currentUndo and sets currentUndo=action .
     * Otherwise, when the currentBridge is undone, the current undo is replaced by the action.
     * In both cases the tail of the current undo, which is reached through this.currentBridge.next, is lost.
     */
    createUndoPoint() {
        const action = new _undoRedoAction__WEBPACK_IMPORTED_MODULE_1__.UndoRedoAction();
        if (!this.currentBridge) {
            this.currentBridge = action;
        }
        else if (this.currentBridge.canUndo) {
            this.currentBridge.next = action;
            action.prev = this.currentBridge;
            this.currentBridge = action;
        }
        else {
            _msagl_core__WEBPACK_IMPORTED_MODULE_0__.Assert.assert(this.currentBridge.canRedo);
            // we need to discard this.currentBridge as it is undone already
            const prev = this.currentBridge.prev;
            if (prev) {
                action.prev = prev;
                prev.next = action;
            }
            this.currentBridge = action;
        }
    }
}
//# sourceMappingURL=undoRedoActionsList.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/orderingEnum.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrderingEnum: () => (/* binding */ OrderingEnum)
/* harmony export */ });
var OrderingEnum;
(function (OrderingEnum) {
    OrderingEnum[OrderingEnum["in"] = 0] = "in";
    OrderingEnum[OrderingEnum["out"] = 1] = "out";
})(OrderingEnum || (OrderingEnum = {}));
//# sourceMappingURL=orderingEnum.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/rankEnum.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RankEnum: () => (/* binding */ RankEnum)
/* harmony export */ });
var RankEnum;
(function (RankEnum) {
    RankEnum[RankEnum["same"] = 0] = "same";
    RankEnum[RankEnum["min"] = 1] = "min";
    RankEnum[RankEnum["source"] = 2] = "source";
    RankEnum[RankEnum["max"] = 3] = "max";
    RankEnum[RankEnum["sink"] = 4] = "sink";
})(RankEnum || (RankEnum = {}));
//# sourceMappingURL=rankEnum.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/shapeEnum.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapeEnum: () => (/* binding */ ShapeEnum)
/* harmony export */ });
var ShapeEnum;
(function (ShapeEnum) {
    ShapeEnum[ShapeEnum["diamond"] = 0] = "diamond";
    ShapeEnum[ShapeEnum["ellipse"] = 1] = "ellipse";
    ShapeEnum[ShapeEnum["box"] = 2] = "box";
    ShapeEnum[ShapeEnum["circle"] = 3] = "circle";
    ShapeEnum[ShapeEnum["record"] = 4] = "record";
    ShapeEnum[ShapeEnum["plaintext"] = 5] = "plaintext";
    ShapeEnum[ShapeEnum["point"] = 6] = "point";
    ShapeEnum[ShapeEnum["mdiamond"] = 7] = "mdiamond";
    ShapeEnum[ShapeEnum["msquare"] = 8] = "msquare";
    ShapeEnum[ShapeEnum["polygon"] = 9] = "polygon";
    ShapeEnum[ShapeEnum["doublecircle"] = 10] = "doublecircle";
    ShapeEnum[ShapeEnum["house"] = 11] = "house";
    ShapeEnum[ShapeEnum["invhouse"] = 12] = "invhouse";
    ShapeEnum[ShapeEnum["parallelogram"] = 13] = "parallelogram";
    ShapeEnum[ShapeEnum["octagon"] = 14] = "octagon";
    ShapeEnum[ShapeEnum["tripleoctagon"] = 15] = "tripleoctagon";
    ShapeEnum[ShapeEnum["triangle"] = 16] = "triangle";
    ShapeEnum[ShapeEnum["trapezium"] = 17] = "trapezium";
    ShapeEnum[ShapeEnum["drawFromGeometry"] = 18] = "drawFromGeometry";
    ShapeEnum[ShapeEnum["hexagon"] = 19] = "hexagon";
})(ShapeEnum || (ShapeEnum = {}));
//# sourceMappingURL=shapeEnum.js.map

/***/ }),

/***/ "./node_modules/@msagl/drawing/dist/styleEnum.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StyleEnum: () => (/* binding */ StyleEnum)
/* harmony export */ });
var StyleEnum;
(function (StyleEnum) {
    //The default style - solid.
    StyleEnum[StyleEnum["none"] = 0] = "none";
    StyleEnum[StyleEnum["dashed"] = 1] = "dashed";
    StyleEnum[StyleEnum["solid"] = 2] = "solid";
    StyleEnum[StyleEnum["invis"] = 3] = "invis";
    StyleEnum[StyleEnum["bold"] = 4] = "bold";
    StyleEnum[StyleEnum["filled"] = 5] = "filled";
    StyleEnum[StyleEnum["diagonals"] = 6] = "diagonals";
    StyleEnum[StyleEnum["dotted"] = 7] = "dotted";
    StyleEnum[StyleEnum["rounded"] = 8] = "rounded";
})(StyleEnum || (StyleEnum = {}));
//# sourceMappingURL=styleEnum.js.map

/***/ }),

/***/ "./node_modules/@msagl/parser/dist/dotparser.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   graphToJSON: () => (/* binding */ graphToJSON),
/* harmony export */   loadGraphFromFile: () => (/* binding */ loadGraphFromFile),
/* harmony export */   loadGraphFromUrl: () => (/* binding */ loadGraphFromUrl),
/* harmony export */   parseDot: () => (/* binding */ parseDot),
/* harmony export */   parseJSON: () => (/* binding */ parseJSON),
/* harmony export */   parseJSONGraph: () => (/* binding */ parseJSONGraph),
/* harmony export */   parseSimpleJSON: () => (/* binding */ parseSimpleJSON),
/* harmony export */   parseTXT: () => (/* binding */ parseTXT)
/* harmony export */ });
/* harmony import */ var dotparser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/dotparser/index.js");
/* harmony import */ var _msagl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/core/dist/index.js");
/* harmony import */ var _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@msagl/drawing/dist/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@msagl/parser/dist/utils.js");




function parseAttrOnDrawingObj(entity, drawingObj, o) {
    for (const attr of o.attr_list) {
        if (attr.type === 'attr') {
            const str = attr.eq;
            switch (attr.id) {
                // geometry attributes
                case 'edgeCurve':
                    {
                        const geom = getOrCreateGeomObj(entity);
                        const json = JSON.parse(str);
                        geom.curve = (0,_msagl_core__WEBPACK_IMPORTED_MODULE_1__.JSONToICurve)(json);
                    }
                    break;
                case 'graphBoundingBox':
                    {
                        const geom = getOrCreateGeomObj(entity);
                        const json = JSON.parse(str);
                        geom.boundingBox = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Rectangle(json);
                    }
                    break;
                case 'boundaryCurve':
                    {
                        const geom = getOrCreateGeomObj(entity);
                        const json = JSON.parse(str);
                        const curve = (0,_msagl_core__WEBPACK_IMPORTED_MODULE_1__.JSONToICurve)(json);
                        if (geom instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomGraph) {
                            geom.boundingBox = curve.boundingBox;
                        }
                        else {
                            geom.boundaryCurve = curve;
                        }
                    }
                    break;
                case 'geomEdge': {
                    const geom = getOrCreateGeomObj(entity);
                    break;
                }
                case 'sourceArrowhead': {
                    const geomEdge = getOrCreateGeomObj(entity);
                    if (geomEdge.sourceArrowhead == null) {
                        geomEdge.sourceArrowhead = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Arrowhead();
                    }
                    break;
                }
                case 'targetArrowhead': {
                    const geomEdge = getOrCreateGeomObj(entity);
                    if (geomEdge.targetArrowhead == null) {
                        geomEdge.targetArrowhead = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Arrowhead();
                    }
                    break;
                }
                case 'sourceArrowheadTip': {
                    const geomEdge = getOrCreateGeomObj(entity);
                    if (geomEdge.sourceArrowhead == null) {
                        geomEdge.sourceArrowhead = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Arrowhead();
                    }
                    if (str !== 'none') {
                        geomEdge.sourceArrowhead.tipPosition = _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Point.fromJSON(JSON.parse(str));
                    }
                    break;
                }
                case 'targetArrowheadTip': {
                    const geomEdge = getOrCreateGeomObj(entity);
                    if (geomEdge.targetArrowhead == null) {
                        geomEdge.targetArrowhead = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Arrowhead();
                    }
                    if (str !== 'none') {
                        geomEdge.targetArrowhead.tipPosition = _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Point.fromJSON(JSON.parse(str));
                    }
                    break;
                }
                case 'geomEdgeLabel': {
                    const json = JSON.parse(str);
                    const edge = entity;
                    createEdgeLabelIfNeeded(edge);
                    const geomLabel = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomLabel(edge.label, new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Rectangle(json));
                    geomLabel.setBoundingBox(new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Rectangle(json));
                    break;
                }
                // end of geometry attributes
                case 'color':
                    drawingObj.color = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.parseColor)(str);
                    break;
                case 'pencolor':
                    drawingObj.pencolor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.parseColor)(str);
                    break;
                case 'labelfontcolor':
                    drawingObj.labelfontcolor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.parseColor)(str);
                    break;
                case 'fontcolor':
                    drawingObj.fontColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.parseColor)(str);
                    break;
                case 'fillcolor':
                    drawingObj.fillColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.parseColor)(str);
                    break;
                case 'style':
                    for (const style of stylesEnumFromString(str)) {
                        drawingObj.styles.push(style);
                    }
                    break;
                case 'shape': {
                    const dn = drawingObj;
                    dn.shape = shapeEnumFromString(str);
                    break;
                }
                case 'peripheries':
                    drawingObj.peripheries = parseInt(str);
                    break;
                case 'headlabel':
                    drawingObj.headlabel = str;
                    break;
                case 'label':
                    // ignore html labels, for example
                    if (typeof str === 'string') {
                        // ignore html labels, for example
                        const find = '\\n';
                        let j = 0;
                        drawingObj.labelText = '';
                        do {
                            const i = str.indexOf(find, j);
                            if (i >= 0) {
                                drawingObj.labelText += str.substring(j, i) + '\n';
                                j = i + 2;
                            }
                            else {
                                drawingObj.labelText += str.substring(j);
                                break;
                            }
                        } while (true);
                    }
                    else if (typeof str === 'number') {
                        drawingObj.labelText = str.toString();
                    }
                    if (entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Edge) {
                        createEdgeLabelIfNeeded(entity);
                    }
                    break;
                case 'size':
                    drawingObj.size = parseFloatTuple(str);
                    break;
                case 'pos':
                    drawingObj.pos = parseFloatTuple(str);
                    break;
                case 'rankdir':
                    drawingObj.rankdir = rankDirEnumFromString(str);
                    break;
                case 'fontname':
                    drawingObj.fontname = str;
                    break;
                case 'fontsize':
                    drawingObj.fontsize = parseFloat(str);
                    break;
                case 'width':
                    drawingObj.width = parseFloat(str);
                    break;
                case 'penwidth':
                    drawingObj.penwidth = parseFloat(str);
                    break;
                case 'height':
                    drawingObj.height = parseFloat(str);
                    break;
                case 'margin':
                    drawingObj.margin = parseFloat(str);
                    break;
                case 'len':
                    drawingObj.len = parseFloat(str);
                    break;
                case 'minlen':
                    drawingObj.minlen = parseFloat(str);
                    break;
                case 'rank':
                    drawingObj.rank = rankEnumFromString(str);
                    break;
                case 'charset':
                    drawingObj.charset = str;
                    break;
                case 'orientation':
                    drawingObj.orientation = str;
                    break;
                case 'ratio':
                    drawingObj.ratio = str;
                    break;
                case 'weight':
                    drawingObj.weight = parseFloat(str);
                    break;
                case 'nodesep':
                    drawingObj.nodesep = parseFloat(str);
                    break;
                case 'layersep':
                    drawingObj.layersep = parseFloat(str);
                    break;
                case 'arrowsize':
                    drawingObj.arrowsize = parseFloat(str);
                    break;
                case 'rotate':
                    drawingObj.rotate = parseFloat(str);
                    break;
                case 'ranksep':
                    drawingObj.ranksep = parseFloat(str);
                    break;
                case 'splines':
                    drawingObj.splines = str === 'true';
                    break;
                case 'overlap':
                    drawingObj.overlap = str === 'true';
                    break;
                case 'arrowtail':
                    drawingObj.arrowtail = arrowTypeEnumFromString(str);
                    break;
                case 'taillabel':
                    drawingObj.taillabel = str;
                    break;
                case 'arrowhead':
                    drawingObj.arrowhead = arrowTypeEnumFromString(str);
                    break;
                case 'ordering':
                    drawingObj.ordering = orderingEnumFromString(str);
                    break;
                case 'URL':
                    drawingObj.URL = str;
                    break;
                case 'dir':
                    drawingObj.dir = dirTypeEnumFromString(str);
                    break;
                case 'concentrate':
                    drawingObj.concentrate = str === 'true';
                    break;
                case 'compound':
                    drawingObj.compound = str === 'true';
                    break;
                case 'lhead':
                    drawingObj.lhead = str;
                    break;
                case 'ltail':
                    drawingObj.ltail = str;
                    break;
                case 'bgcolor':
                    drawingObj.bgcolor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.parseColor)(str);
                    break;
                case 'center':
                    drawingObj.center = str === true || parseInt(str) === 1;
                    break;
                case 'colorscheme':
                    drawingObj.colorscheme = str;
                    break;
                case 'sides':
                    drawingObj.sides = parseInt(str);
                    break;
                case 'distortion':
                    drawingObj.distortion = parseFloat(str);
                    break;
                case 'skew':
                    drawingObj.skew = parseFloat(str);
                    break;
                case 'bb':
                    drawingObj.bb = parseFloatQuatriple(str);
                    break;
                case 'labelloc':
                    drawingObj.labelloc = str;
                    break;
                case 'decorate':
                    drawingObj.decorate = str === 'true';
                    break;
                case 'tailclip':
                    drawingObj.tailclip = str === 'true';
                    break;
                case 'headclip':
                    drawingObj.headclip = str === 'true';
                    break;
                case 'constraint':
                    drawingObj.constraint = str === 'true';
                    break;
                case 'gradientangle':
                    drawingObj.gradientangle = parseFloat(str);
                    break;
                case 'samehead':
                    drawingObj.samehead = str;
                    break;
                case 'href':
                    drawingObj.href = str;
                    break;
                case 'imagepath':
                    drawingObj.imagepath = str;
                    break;
                case 'image':
                    drawingObj.image = str;
                    break;
                case 'labeljust':
                    drawingObj.labejust = str;
                    break;
                case 'layers':
                    drawingObj.layers = str.split(',');
                    break;
                case 'layer':
                    drawingObj.layer = str;
                    break;
                case 'f':
                    drawingObj.f = parseFloat(str);
                    break;
                case 'nojustify':
                    drawingObj.nojustify = str === 'true';
                    break;
                case 'root':
                    drawingObj.root = str === 'true';
                    break;
                case 'page':
                    drawingObj.page = parseFloatTuple(str);
                    break;
                case 'pname':
                    drawingObj.pname = str;
                    break;
                case 'kind':
                    drawingObj.kind = str;
                    break;
                case 'fname':
                    drawingObj.fname = str;
                    break;
                case 'subkind':
                    drawingObj.subkind = str;
                    break;
                case 'area':
                    drawingObj.area = parseFloat(str);
                    break;
                case 'tailport':
                    drawingObj.tailport = str;
                    break;
                case 'headport':
                    drawingObj.headport = str;
                    break;
                case 'wt':
                    drawingObj.wt = str;
                    break;
                case 'id':
                    if (drawingObj instanceof _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingNode) {
                    }
                    else {
                        drawingObj.id = str;
                    }
                    break;
                case 'edgetooltip':
                    drawingObj.edgetooltip = str;
                    break;
                case 'headtooltip':
                    drawingObj.headtooltip = str;
                    break;
                case 'tailtooltip':
                    drawingObj.tailtooltip = str;
                    break;
                case 'headURL':
                    drawingObj.headURL = str;
                    break;
                case 'tailURL':
                    drawingObj.tailURL = str;
                    break;
                case 'labelURL':
                    drawingObj.labelURL = str;
                    break;
                case 'edgeurl':
                    drawingObj.edgeurl = str;
                    break;
                case 'shapefile':
                    drawingObj.shapefile = str;
                    break;
                case 'xlabel':
                    drawingObj.xlabel = str;
                    break;
                case 'sametail':
                    drawingObj.sametail = str;
                    break;
                case 'clusterrank':
                    drawingObj.clusterRank = str;
                    break;
                case 'measuredTextSize':
                    drawingObj.measuredTextSize = JSON.parse(str);
                    break;
                default:
                    break; // remove the comment below to catch unsupported attributes
                // throw new Error('not implemented for ' + attr.id)
            }
        }
        else {
            throw new Error('unexpected type ' + attr.type);
        }
    }
    function createEdgeLabelIfNeeded(edge) {
        if (edge.label == null) {
            edge.label = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Label(edge);
        }
    }
}
function parseAttrs(o, entity) {
    const drawingObj = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingObject.getDrawingObj(entity);
    if (o.attr_list == null)
        return;
    parseAttrOnDrawingObj(entity, drawingObj, o);
}
class DotParser {
    constructor(ast) {
        this.nodeMap = new Map();
        this.ast = ast;
    }
    parseEdge(so, to, graph, directed, o) {
        let sn;
        let tn;
        if (so.type === 'node_id') {
            const s = so.id.toString();
            sn = this.nodeMap.get(s);
            if (sn == null) {
                sn = this.newNode(s, graph, false);
            }
            else {
                this.tryToMoveToADeeperGraph(sn, graph);
            }
        }
        else {
            const drObjs = [];
            for (const ch of so.children) {
                if (ch.type === 'node_stmt') {
                    for (const e of this.parseEdge(ch.node_id, to, graph, directed, o))
                        drObjs.push(e);
                }
                else if (ch.type === 'attr_stmt') {
                }
                else {
                    throw new Error('not implemented');
                }
            }
            for (const ch of so.children) {
                if (ch.type === 'attr_stmt') {
                    for (const drObj of drObjs)
                        parseAttrs(ch, drObj);
                } // ignore anything else
            }
            return drObjs;
        }
        if (to.type === 'node_id') {
            const t = to.id.toString();
            tn = this.nodeMap.get(t);
            if (tn == null) {
                tn = this.newNode(t, graph, false);
            }
            else {
                this.tryToMoveToADeeperGraph(tn, graph);
            }
        }
        else if (to.type === 'subgraph') {
            const subgraphEdges = new Array();
            for (const ch of to.children) {
                if (ch.type === 'node_stmt') {
                    for (const e of this.parseEdge(so, ch.node_id, graph, directed, o))
                        subgraphEdges.push(e);
                }
                else if (ch.type === 'attr_stmt') {
                }
                else {
                    throw new Error('not implemented');
                }
            }
            for (const ch of to.children) {
                if (ch.type === 'attr_stmt') {
                    for (const drObj of subgraphEdges)
                        parseAttrs(ch, drObj);
                } // ignore anything else
            }
            return subgraphEdges;
        }
        const edge = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Edge(sn, tn);
        new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingEdge(edge, directed);
        parseAttrs(o, edge);
        return [edge];
    }
    tryToMoveToADeeperGraph(sn, graph) {
        _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Assert.assert(sn.parent != null);
        const snParent = sn.parent;
        if (snParent != graph && depth(snParent) < depth(graph)) {
            snParent.remove(sn);
            graph.addNode(sn);
        }
        function depth(a) {
            let d = 0;
            let p = a.parent;
            while (p) {
                d++;
                p = p.parent;
            }
            return d;
        }
    }
    newNode(id, g, underSubgraph) {
        let n = this.nodeMap.get(id);
        if (n == null) {
            n = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Node(id);
            this.nodeMap.set(id, n);
            g.addNode(n);
            const dn = new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingNode(n);
            dn.labelText = id;
            const drGr = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph.getDrawingObj(g);
            _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingObject.copyValidFields(drGr.defaultNodeObject, dn);
        }
        else if (underSubgraph) {
            // if the node is under a subgraph - change its parent to the subgraph
            (0,_msagl_core__WEBPACK_IMPORTED_MODULE_1__.setNewParent)(g, n);
        }
        return n;
    }
    parseNode(o, graph, underSubgraph) {
        const id = o.node_id.id.toString();
        const node = this.newNode(id, graph, underSubgraph);
        if (_msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingObject.getDrawingObj(node) == null) {
            new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingNode(node);
        }
        parseAttrs(o, node);
        return node;
    }
    parse() {
        if (this.ast == null)
            return null;
        this.graph = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Graph(this.ast[0].id ? this.ast[0].id.toString() : '__graph__');
        this.drawingGraph = new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph(this.graph);
        this.parseUnderGraph(this.ast[0].children, this.graph, this.ast[0].type === 'digraph', false);
        removeEmptySubgraphs(this.graph);
        createGeomForSubgraphs(this.graph);
        return this.graph;
    }
    parseGraphAttr(o, graph) {
        if (o.target === 'node') {
            const dg = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph.getDrawingObj(graph);
            if (dg.defaultNodeObject == null) {
                dg.defaultNodeObject = new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingNode(null);
            }
            // but also parse it for the default node attribute
            parseAttrOnDrawingObj(null, dg.defaultNodeObject, o);
        }
        else if (o.target === 'graph') {
            parseAttrs(o, graph);
        }
    }
    getEntitiesSubg(o, graph, directed) {
        let ret = [];
        for (const ch of o.children) {
            if (ch.type === 'edge_stmt') {
                for (let i = 0; i < ch.edge_list.length - 1; i++) {
                    for (const e of this.parseEdge(ch.edge_list[i], ch.edge_list[i + 1], graph, directed, ch))
                        ret.push(e);
                }
            }
            else if (ch.type === 'attr_stmt') {
            }
            else if (ch.type === 'node_stmt') {
                ret.push(this.parseNode(ch, graph, true));
            }
            else if (ch.type === 'subgraph') {
                if (ch.id != null) {
                    const subg = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Graph(ch.id.toString());
                    graph.addNode(subg);
                    this.nodeMap.set(subg.id, subg);
                    const sdg = new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph(subg);
                    this.parseUnderGraph(ch.children, subg, directed, true);
                    ret.push(sdg.graph);
                    if (subg.isEmpty) {
                        graph.removeNode(subg);
                        this.nodeMap.delete(subg.id);
                    }
                }
                else {
                    ret = ret.concat(this.getEntitiesSubg(ch, graph, directed));
                }
            }
            else {
                throw new Error('Function not implemented.');
            }
        }
        return ret;
    }
    parseUnderGraph(children, graph, directed, underSubgraph) {
        for (const o of children) {
            switch (o.type) {
                case 'node_stmt':
                    this.parseNode(o, graph, underSubgraph);
                    break;
                case 'edge_stmt':
                    {
                        const edgeList = o.edge_list;
                        for (let i = 0; i < edgeList.length - 1; i++)
                            this.parseEdge(edgeList[i], edgeList[i + 1], graph, directed, o);
                    }
                    break;
                case 'subgraph':
                    {
                        // is it really a subgraph?
                        if (this.process_same_rank(o, _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph.getDrawingGraph(graph))) {
                        }
                        else if (o.id == null) {
                            const entities = this.getEntitiesSubg(o, graph, directed);
                            applyAttributesToEntities(o, _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph.getDrawingGraph(graph), entities);
                        }
                        else {
                            const subg = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Graph(o.id.toString());
                            this.nodeMap.set(o.id.toString(), subg);
                            graph.addNode(subg);
                            new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph(subg);
                            this.parseUnderGraph(o.children, subg, directed, true);
                            if (subg.isEmpty()) {
                                graph.remove(subg);
                                this.nodeMap.delete(subg.id);
                            }
                        }
                    }
                    break;
                case 'attr_stmt':
                    this.parseGraphAttr(o, graph);
                    break;
                default:
                    throw new Error('not implemented');
            }
        }
    }
    process_same_rank(o, dg) {
        const attr = o.children[0];
        if (attr == null)
            return false;
        if (attr.type !== 'attr_stmt')
            return false;
        const attr_list = attr.attr_list;
        if (attr_list == null)
            return false;
        if (attr_list.length === 0)
            return false;
        const attr_0 = attr_list[0];
        if (attr_0.type !== 'attr')
            return false;
        if (attr_0.id !== 'rank')
            return false;
        switch (attr_0.eq) {
            case 'min':
                for (let i = 1; i < o.children.length; i++) {
                    const c = o.children[i];
                    if (c.type === 'node_stmt') {
                        dg.graphVisData.minRanks.push(c.node_id.id.toString());
                    }
                    else {
                        throw new Error();
                    }
                }
                return true;
            case 'max':
                for (let i = 1; i < o.children.length; i++) {
                    const c = o.children[i];
                    if (c.type === 'node_stmt') {
                        dg.graphVisData.minRanks.push(c.node_id.id.toString());
                    }
                    else {
                        throw new Error();
                    }
                }
                return true;
            case 'same': {
                const sameRank = [];
                for (let i = 1; i < o.children.length; i++) {
                    const c = o.children[i];
                    if (c.type === 'node_stmt') {
                        this.newNode(c.node_id.id.toString(), dg.graph, false);
                        sameRank.push(c.node_id.id.toString());
                    }
                    else if (c.type === 'attr_stmt') {
                        if (c.target === 'node') {
                            if (dg.defaultNodeObject == null) {
                                dg.defaultNodeObject = new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingNode(null);
                            }
                            parseAttrOnDrawingObj(null, dg.defaultNodeObject, c);
                        }
                    }
                }
                dg.graphVisData.sameRanks.push(sameRank);
                return true;
            }
            case 'source': {
                for (let i = 1; i < o.children.length; i++) {
                    const c = o.children[i];
                    if (c.type === 'node_stmt') {
                        dg.graphVisData.sourceRanks.push(c.node_id.id.toString());
                    }
                    else {
                        throw new Error();
                    }
                }
                return true;
            }
            case 'sink':
                {
                    for (let i = 1; i < o.children.length; i++) {
                        const c = o.children[i];
                        if (c.type === 'node_stmt') {
                            dg.graphVisData.sinkRanks.push(c.node_id.id.toString());
                        }
                        else {
                            throw new Error();
                        }
                    }
                }
                return true;
            default:
                throw new Error('incorrect rank');
                return false;
        }
    }
}
/** parses a string representing a Graph in DOT Format */
function parseDot(graphStr) {
    try {
        const dp = new DotParser(dotparser__WEBPACK_IMPORTED_MODULE_0__(graphStr));
        return dp.parse();
    }
    catch (peg$SyntaxError) {
        console.log('cannot parse the graph');
        console.log(peg$SyntaxError.message);
        console.log('start: line =', peg$SyntaxError.location.start.line, 'col=', peg$SyntaxError.location.start.column, 'offset=', peg$SyntaxError.location.start.offset);
        console.log('end: line =', peg$SyntaxError.location.end.line, 'col=', peg$SyntaxError.location.end.column, 'offset=', peg$SyntaxError.location.end.offset);
        console.log('expected=', peg$SyntaxError.expected);
        console.log('found=', peg$SyntaxError.found);
        return null;
    }
}
// /** parses a string representing a Graph in JSON Format, corresponding to JSONGraph type */
// export function parseJSON(graphStr: string): Graph {
//   try {
//     const ast: JSONGraph = JSON.parse(graphStr)
//     const dp = new DotParser([ast])
//     return dp.parse()
//   } catch (Error) {
//
//     return null
//   }
// }
/** parses JSONGraph type to a Graph */
function parseJSONGraph(jsonObj) {
    try {
        const dp = new DotParser([jsonObj]);
        const ret = dp.parse();
        return ret;
    }
    catch (Error) {
        console.log(Error.message);
        return null;
    }
}
function* stylesEnumFromString(str) {
    const styles = str.split(',');
    for (const t of styles) {
        const typedStyleString = t;
        const ret = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.StyleEnum[typedStyleString];
        if (ret) {
            yield ret;
        }
    }
}
function shapeEnumFromString(t) {
    const typedStyleString = t.toLowerCase();
    return _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.ShapeEnum[typedStyleString];
}
function parseFloatTuple(str) {
    const p = str.split(',');
    return [parseFloat(p[0]), parseFloat(p[1])];
}
function rankDirEnumFromString(t) {
    const typedStyleString = t;
    return _msagl_core__WEBPACK_IMPORTED_MODULE_1__.LayerDirectionEnum[typedStyleString];
}
function rankEnumFromString(t) {
    const typedStyleString = t;
    return _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.RankEnum[typedStyleString];
}
function arrowTypeEnumFromString(t) {
    const typedStyleString = t;
    return _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.ArrowTypeEnum[typedStyleString];
}
function orderingEnumFromString(t) {
    const typedStyleString = t;
    return _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.OrderingEnum[typedStyleString];
}
function dirTypeEnumFromString(t) {
    const typedStyleString = t;
    return _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DirTypeEnum[typedStyleString];
}
function parseFloatQuatriple(str) {
    const p = str.split(',');
    return [parseFloat(p[0]), parseFloat(p[1]), parseFloat(p[2]), parseFloat(p[3])];
}
function applyAttributesToEntities(o, dg, entities) {
    for (const ch of o.children) {
        if (ch.type === 'attr_stmt') {
            for (const ent of entities)
                parseAttrs(ch, ent);
        }
    }
}
function removeEmptySubgraphs(graph) {
    const emptySubgraphList = [];
    for (const sg of graph.subgraphsBreadthFirst()) {
        if (sg.isEmpty()) {
            emptySubgraphList.push(sg);
        }
    }
    for (const sg of emptySubgraphList) {
        const parent = sg.parent;
        if (parent) {
            parent.removeNode(sg);
        }
    }
}
function createGeomForSubgraphs(graph) {
    for (const sg of graph.subgraphsBreadthFirst()) {
        if (_msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomGraph.getGeom(sg) == null && sg.hasSomeAttrOnIndex(_msagl_core__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.GeomObjectIndex)) {
            new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomGraph(sg);
        }
    }
    if (_msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomGraph.getGeom(graph) == null && graph.hasSomeAttrOnIndex(_msagl_core__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.GeomObjectIndex)) {
        new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomGraph(graph);
    }
}
/** Exports the graph into a JSONGraph object for further serialization */
function graphToJSON(graph) {
    /** idToLevels are needed to figure out the edge membership efficiently:
     * Edge belongs to the first Graph which is a common ancestor of the edge source and the edge target.
     */
    const idToLevels = getNodeLevels(graph);
    const ret = { type: getGraphType(graph), id: graph.id, children: createChildren(graph, idToLevels) };
    return ret;
}
function edgeStmt(edge) {
    //create edge_list from one element
    return {
        type: 'edge_stmt',
        edge_list: [
            { type: 'node_id', id: edge.source.id },
            { type: 'node_id', id: edge.target.id },
        ],
        attr_list: Array.from(getEdgeAttrs(edge)),
    };
}
function createChildren(graph, nodeLevels) {
    const idToStmt = new Map();
    const children = [];
    const geomGraph = _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomGraph.getGeom(graph);
    if (geomGraph) {
        const attrs = Array.from(getGeomGraphAttrList(geomGraph));
        children.push({ type: 'attr_stmt', target: 'graph', attr_list: attrs });
    }
    addDefaultNodeStmt(children, graph);
    // fill the map of idToStmh
    for (const n of graph.nodesBreadthFirst) {
        idToStmt.set(n.id, getNodeStatement(n));
    }
    // attach node and subgraphs stmts to their parents
    for (const n of graph.nodesBreadthFirst) {
        if (n.parent === graph) {
            continue;
        }
        const subGraph = idToStmt.get(n.parent.id);
        subGraph.children.push(idToStmt.get(n.id));
    }
    // attach edge statements to their parents
    for (const e of graph.deepEdges) {
        const es = edgeStmt(e);
        const parent = edgeParent(e, nodeLevels);
        if (parent === graph) {
            children.push(es);
        }
        else {
            const subGraph = idToStmt.get(parent.id);
            subGraph.children.push(es);
        }
    }
    for (const n of graph.shallowNodes) {
        children.push(idToStmt.get(n.id));
    }
    return children;
}
function* getEdgeAttrs(edge) {
    const geomEdge = _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(edge);
    if (geomEdge) {
        yield { type: 'attr', id: 'geomEdge', eq: 'none' };
        if (geomEdge.curve)
            yield { type: 'attr', id: 'edgeCurve', eq: JSON.stringify((0,_msagl_core__WEBPACK_IMPORTED_MODULE_1__.iCurveToJSON)(geomEdge.curve)) };
        if (geomEdge.sourceArrowhead) {
            yield { type: 'attr', id: 'sourceArrowhead', eq: 'none' };
            if (geomEdge.sourceArrowhead.tipPosition) {
                yield { type: 'attr', id: 'sourceArrowheadTip', eq: JSON.stringify(geomEdge.sourceArrowhead.tipPosition.toJSON()) };
            }
        }
        if (geomEdge.targetArrowhead) {
            yield { type: 'attr', id: 'targetArrowhead', eq: 'none' };
            if (geomEdge.targetArrowhead.tipPosition) {
                yield { type: 'attr', id: 'targetArrowheadTip', eq: JSON.stringify(geomEdge.targetArrowhead.tipPosition.toJSON()) };
            }
        }
        if (edge.label) {
            const bb = edge.label.getAttr(_msagl_core__WEBPACK_IMPORTED_MODULE_1__.AttributeRegistry.GeomObjectIndex).boundingBox;
            const rJSON = { left: bb.left, right: bb.right, top: bb.top, bottom: bb.bottom };
            yield { type: 'attr', id: 'geomEdgeLabel', eq: JSON.stringify(rJSON) };
        }
    }
    yield* attrIter(_msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingObject.getDrawingObj(edge));
}
function getNodeStatement(node) {
    const isGraph = node instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Graph;
    if (!isGraph) {
        return {
            type: 'node_stmt',
            node_id: { type: 'node_id', id: node.id },
            attr_list: Array.from(getNodeAttrList(node)),
        };
    }
    else {
        const attr_list = Array.from(getGeomGraphAttrList(_msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomGraph.getGeom(node)));
        const children = [];
        const attr_stmt = { type: 'attr_stmt', target: 'graph', attr_list: attr_list };
        children.push(attr_stmt);
        return { type: 'subgraph', children: children, id: node.id };
    }
}
function getNodeBoundaryCurve(node) {
    const bc = _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomNode.getGeom(node).boundaryCurve;
    return { type: 'attr', id: 'boundaryCurve', eq: JSON.stringify((0,_msagl_core__WEBPACK_IMPORTED_MODULE_1__.iCurveToJSON)(bc)) };
}
function* getNodeAttrList(node) {
    const geomNode = _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(node);
    if (geomNode) {
        yield getNodeBoundaryCurve(node);
    }
    yield* attrIter(_msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingObject.getDrawingObj(node));
}
function* attrIter(drObj) {
    if (drObj.color) {
        yield { type: 'attr', id: 'color', eq: drObj.color.toString() };
    }
    if (drObj.fillColor) {
        yield { type: 'attr', id: 'fillColor', eq: drObj.fillColor.toString() };
    }
    if (drObj.labelfontcolor) {
        yield { type: 'attr', id: 'labelfontcolor', eq: drObj.labelfontcolor.toString() };
    }
    if (!(drObj.labelText == null || drObj.labelText === '') && drObj.entity && drObj.labelText !== drObj.id) {
        yield { type: 'attr', id: 'label', eq: drObj.labelText };
    }
    if (drObj.fontColor && drObj.fontColor.keyword.toLowerCase() !== 'black') {
        yield { type: 'attr', id: 'fontColor', eq: drObj.fontColor.toString() };
    }
    if (drObj.styles && drObj.styles.length) {
        const styleString = drObj.styles.map((s) => _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.StyleEnum[s]).reduce((a, b) => a.concat(',' + b));
        yield { type: 'attr', id: 'style', eq: styleString };
    }
    if (drObj.pencolor && drObj.pencolor.keyword !== 'black') {
        yield { type: 'attr', id: 'pencolor', eq: drObj.pencolor.toString() };
    }
    if (drObj.penwidth && drObj.penwidth !== 1) {
        yield { type: 'attr', id: 'penwidth', eq: drObj.penwidth.toString() };
    }
    if (drObj.rankdir) {
        yield { type: 'attr', id: 'rankdir', eq: drObj.rankdir.toString() };
    }
    if (drObj.fontname && drObj.fontname !== _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingObject.defaultLabelFontName) {
        yield { type: 'attr', id: 'fontname', eq: drObj.fontname };
    }
    if (drObj.margin) {
        yield { type: 'attr', id: 'margin', eq: drObj.margin.toString() };
    }
    if (drObj.fontsize && drObj.fontsize !== _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingObject.defaultLabelFontSize) {
        yield { type: 'attr', id: 'fontsize', eq: drObj.fontsize.toString() };
    }
    if (drObj.orientation) {
        yield { type: 'attr', id: 'orientation', eq: drObj.orientation.toString() };
    }
    if (drObj.ranksep) {
        yield { type: 'attr', id: 'ranksep', eq: drObj.ranksep.toString() };
    }
    if (drObj.arrowtail) {
        yield { type: 'attr', id: 'arrowtail', eq: _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.ArrowTypeEnum[drObj.arrowtail] };
    }
    if (drObj.arrowhead) {
        yield { type: 'attr', id: 'arrowhead', eq: _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.ArrowTypeEnum[drObj.arrowhead] };
    }
    if (drObj.ordering) {
        yield { type: 'attr', id: 'ordering', eq: drObj.ordering.toString() };
    }
    if (drObj.bgcolor) {
        yield { type: 'attr', id: 'bgcolor', eq: drObj.bgcolor.toString() };
    }
    if (drObj.pos) {
        yield { type: 'attr', id: 'pos', eq: drObj.pos.toString() };
    }
    if (drObj.nodesep) {
        yield { type: 'attr', id: 'nodesep', eq: drObj.nodesep.toString() };
    }
    if (drObj.arrowsize) {
        yield { type: 'attr', id: 'arrowsize', eq: drObj.arrowsize.toString() };
    }
    if (drObj.samehead) {
        yield { type: 'attr', id: 'samehead', eq: drObj.samehead.toString() };
    }
    if (drObj.layersep) {
        yield { type: 'attr', id: 'layersep', eq: drObj.layersep.toString() };
    }
    if (drObj.clusterRank) {
        yield { type: 'attr', id: 'clusterrank', eq: drObj.clusterRank.toString() };
    }
    if (drObj.measuredTextSize) {
        yield { type: 'attr', id: 'measuredTextSize', eq: JSON.stringify(drObj.measuredTextSize) };
    }
    if (drObj instanceof _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingNode) {
        if (drObj.shape && drObj.shape !== _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.ShapeEnum.box) {
            yield { type: 'attr', id: 'shape', eq: drObj.shape.toString() };
        }
        if (drObj.xRad && drObj.xRad !== 3) {
            yield { type: 'attr', id: 'xRad', eq: drObj.xRad.toString() };
        }
        if (drObj.yRad && drObj.yRad !== 3) {
            yield { type: 'attr', id: 'yRad', eq: drObj.yRad.toString() };
        }
        if (drObj.padding && drObj.padding !== 2) {
            yield { type: 'attr', id: 'padding', eq: drObj.padding.toString() };
        }
    }
}
function getGraphType(graph) {
    const drGr = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph.getDrawingGraph(graph);
    return drGr.hasDirectedEdge() ? 'digraph' : 'graph';
}
function edgeParent(e, nodeLevels) {
    // make the levels equal
    let s = e.source;
    let t = e.target;
    let sLevel = nodeLevels.get(s.id);
    let tLevel = nodeLevels.get(t.id);
    while (sLevel > tLevel) {
        s = s.parent;
        sLevel--;
    }
    while (sLevel < tLevel) {
        t = t.parent;
        tLevel--;
    }
    // Assert.assert(sLevel === tLevel)
    while (s.parent !== t.parent) {
        s = s.parent;
        t = t.parent;
    }
    return s.parent;
}
/** The nodes belonging to the root graph have levels 0,
 * In general, a node level is the distance, the number of hops,
 *  from its parent to the root in the
 * tree of graphs.
 */
function getNodeLevels(graph) {
    const levels = new Map();
    levels.set(graph.id, 0);
    getNodeLevelsOnMap(graph, levels);
    return levels;
}
function getNodeLevelsOnMap(graph, levels) {
    const graphLevel = levels.get(graph.id) + 1;
    for (const n of graph.shallowNodes) {
        levels.set(n.id, graphLevel);
        if (n instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Graph) {
            getNodeLevelsOnMap(n, levels);
        }
    }
}
function getOrCreateGeomObj(entity) {
    var _a;
    return (_a = _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomObject.getGeom(entity)) !== null && _a !== void 0 ? _a : createNewGeomObj(entity);
}
function createNewGeomObj(entity) {
    if (entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Graph) {
        return new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomGraph(entity);
    }
    if (entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Node) {
        return new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomNode(entity);
    }
    if (entity instanceof _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Edge) {
        return new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.GeomEdge(entity);
    }
    throw new Error('unsupported type ' + entity);
}
function addDefaultNodeStmt(children, graph) {
    const dg = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph.getDrawingObj(graph);
    if (dg == null)
        return;
    const defaultDrawingNode = dg.defaultNodeObject;
    if (defaultDrawingNode) {
        children.push({ type: 'attr_stmt', target: 'node', attr_list: Array.from(attrIter(defaultDrawingNode)) });
    }
}
function* getGeomGraphAttrList(geomGraph) {
    if (geomGraph == null)
        return;
    const bb = geomGraph.boundingBox;
    if (bb && bb.isEmpty() === false) {
        const rJSON = { left: bb.left, right: bb.right, top: bb.top, bottom: bb.bottom };
        yield { type: 'attr', id: 'graphBoundingBox', eq: JSON.stringify(rJSON) };
    }
    if (geomGraph.radX !== 10) {
        yield { type: 'attr', id: 'radX', eq: geomGraph.radX.toString() };
    }
    if (geomGraph.radY !== 10) {
        yield { type: 'attr', id: 'radY', eq: geomGraph.radY.toString() };
    }
}
/** Each line of the file is a string in Format sourceId\ttargetId. That is two words separated by a tabulation symbol.
 * The edges are considered directed.
 */
function parseTXT(content) {
    const graph = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Graph();
    try {
        const lines = content.split(/\r\n|\r|\n/);
        for (const l of lines) {
            if (l.length == 0)
                continue;
            if (l.charAt(0) == '#')
                continue;
            const st = l.split(/\t| |,/);
            if (st.length < 2) {
                console.log('cannot parse', l);
                return null;
            }
            const s = st[0];
            const t = st[1];
            const sn = addOrGetNodeWithDrawingAttr(graph, s);
            const tn = addOrGetNodeWithDrawingAttr(graph, t);
            const e = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Edge(sn, tn);
            new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingEdge(e, true); // true for directed
        }
    }
    catch (e) {
        console.log(e.message);
    }
    new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph(graph);
    return graph;
}
function addOrGetNodeWithDrawingAttr(graph, id) {
    let node = graph.findNode(id);
    if (node == null) {
        node = graph.addNode(new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Node(id));
        new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingNode(node);
    }
    return node;
}
async function loadGraphFromFile(file) {
    const content = await file.text();
    let graph;
    if (file.name.toLowerCase().endsWith('.json')) {
        graph = parseJSON(JSON.parse(content));
    }
    else if (file.name.toLowerCase().endsWith('.txt') ||
        file.name.toLowerCase().endsWith('.tsv') ||
        file.name.toLowerCase().endsWith('.csv')) {
        graph = parseTXT(content);
    }
    else {
        graph = parseDot(content);
    }
    if (graph) {
        graph.id = file.name;
    }
    return graph;
}
async function loadGraphFromUrl(url) {
    const fileName = url.slice(url.lastIndexOf('/') + 1);
    const resp = await fetch(url);
    let graph;
    if (fileName.endsWith('.json')) {
        const json = await resp.json();
        graph = parseJSON(json);
    }
    else if (fileName.endsWith('.txt')) {
        const content = await resp.text();
        graph = parseTXT(content);
    }
    else {
        const content = await resp.text();
        graph = parseDot(content);
    }
    if (graph)
        graph.id = fileName;
    return graph;
}
function parseJSON(json) {
    if ('nodes' in json) {
        return parseSimpleJSON(json);
    }
    return parseJSONGraph(json);
}
function parseSimpleJSON(json) {
    const g = new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Graph();
    for (const node of json.nodes) {
        const id = String(node.id);
        const n = g.addNode(new _msagl_core__WEBPACK_IMPORTED_MODULE_1__.Node(id));
        const dn = new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingNode(n);
        const { label = id, shape = 'box' } = node;
        dn.labelText = label;
        dn.ShapeEnum = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.ShapeEnum[shape];
        if ('weight' in node) {
            dn.weight = node.weight;
        }
        if ('color' in node) {
            dn.color = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.parseColor)(node.color);
        }
    }
    for (const edge of json.edges) {
        const e = g.setEdge(String(edge.source), String(edge.target));
        const de = new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingEdge(e, false);
        const { arrowhead = 'none', arrowtail = 'none', directed = true } = edge;
        de.arrowhead = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.ArrowTypeEnum[arrowhead];
        de.arrowtail = _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.ArrowTypeEnum[arrowtail];
        de.directed = directed;
        if ('weight' in edge) {
            de.weight = edge.weight;
        }
        if ('color' in edge) {
            de.color = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.parseColor)(edge.color);
        }
    }
    new _msagl_drawing__WEBPACK_IMPORTED_MODULE_2__.DrawingGraph(g); // create the DrawingAttribute on the graph
    return g;
}
//# sourceMappingURL=dotparser.js.map

/***/ }),

/***/ "./node_modules/@msagl/parser/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   graphToJSON: () => (/* reexport safe */ _dotparser__WEBPACK_IMPORTED_MODULE_0__.graphToJSON),
/* harmony export */   loadGraphFromFile: () => (/* reexport safe */ _dotparser__WEBPACK_IMPORTED_MODULE_0__.loadGraphFromFile),
/* harmony export */   loadGraphFromUrl: () => (/* reexport safe */ _dotparser__WEBPACK_IMPORTED_MODULE_0__.loadGraphFromUrl),
/* harmony export */   parseDot: () => (/* reexport safe */ _dotparser__WEBPACK_IMPORTED_MODULE_0__.parseDot),
/* harmony export */   parseJSON: () => (/* reexport safe */ _dotparser__WEBPACK_IMPORTED_MODULE_0__.parseJSON),
/* harmony export */   parseTXT: () => (/* reexport safe */ _dotparser__WEBPACK_IMPORTED_MODULE_0__.parseTXT)
/* harmony export */ });
/* harmony import */ var _dotparser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@msagl/parser/dist/dotparser.js");



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@msagl/parser/dist/utils.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseColor: () => (/* binding */ parseColor)
/* harmony export */ });
/* harmony import */ var parse_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/parse-color/index.js");
/* harmony import */ var _msagl_drawing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@msagl/drawing/dist/index.js");


function parseColor(s) {
    const p = parse_color__WEBPACK_IMPORTED_MODULE_0__(s);
    if (p.keyword != null) {
        return _msagl_drawing__WEBPACK_IMPORTED_MODULE_1__.Color.parse(p.keyword.toString());
    }
    if (p != null) {
        if (p.rgba != null) {
            return new _msagl_drawing__WEBPACK_IMPORTED_MODULE_1__.Color(p.rgba[3], p.rgba[0], p.rgba[1], p.rgba[2]);
        }
        if (p.rgb != null) {
            return _msagl_drawing__WEBPACK_IMPORTED_MODULE_1__.Color.mkRGB(p.rgb[0], p.rgb[1], p.rgb[2]);
        }
    }
    return _msagl_drawing__WEBPACK_IMPORTED_MODULE_1__.Color.Black;
}
//# sourceMappingURL=utils.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layeredLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/nodeGraph/layeredLayout.js");


// Separate from main implementation so it does not trip out tests
addEventListener('message', async (event) => {
  const { nodes, edges, config } = event.data;
  const [newNodes, newEdges] = (0,_layeredLayout__WEBPACK_IMPORTED_MODULE_0__.layout)(nodes, edges, config);
  postMessage({ nodes: newNodes, edges: newEdges });
});

})();

/******/ })()
;
//# sourceMappingURL=public_app_plugins_panel_nodeGraph_layeredLayout_worker_js.6e12814ef6652f701b62.js.map