{"version":3,"file":"nodeGraphPanel.46bb55ac2ecd7709749f.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/nodeGraph/Edge.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/EdgeArrowMarker.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/EdgeLabel.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/Legend.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/Marker.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/Node.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/NodeGraph.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/NodeGraphPanel.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/ViewControls.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/createLayoutWorker.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/editor/ArcOptionsEditor.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/layout.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/module.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/suggestions.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useCategorizeFrames.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useContextMenu.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/useFocusPositionOnLayout.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useHighlight.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useNodeLimit.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/usePanning.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useZoom.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/utils.ts"],"sourcesContent":["import React, { MouseEvent, memo } from 'react';\n\nimport { EdgeArrowMarker } from './EdgeArrowMarker';\nimport { computeNodeCircumferenceStrokeWidth, nodeR } from './Node';\nimport { EdgeDatumLayout, NodeDatum } from './types';\nimport { shortenLine } from './utils';\n\nexport const defaultHighlightedEdgeColor = '#a00';\nexport const defaultEdgeColor = '#999';\n\ninterface Props {\n  edge: EdgeDatumLayout;\n  hovering: boolean;\n  svgIdNamespace: string;\n  onClick: (event: MouseEvent<SVGElement>, link: EdgeDatumLayout) => void;\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n}\n\nexport const Edge = memo(function Edge(props: Props) {\n  const { edge, onClick, onMouseEnter, onMouseLeave, hovering, svgIdNamespace } = props;\n\n  // Not great typing but after we do layout these properties are full objects not just references\n  const { source, target, sourceNodeRadius, targetNodeRadius } = edge as {\n    source: NodeDatum;\n    target: NodeDatum;\n    sourceNodeRadius: number;\n    targetNodeRadius: number;\n  };\n  const arrowHeadHeight = 10 + edge.thickness * 2; // resized value, just to make the UI nicer\n\n  // As the nodes have some radius we want edges to end outside of the node circle.\n  const line = shortenLine(\n    {\n      x1: source.x!,\n      y1: source.y!,\n      x2: target.x!,\n      y2: target.y!,\n    },\n    sourceNodeRadius + computeNodeCircumferenceStrokeWidth(sourceNodeRadius) / 2 || nodeR,\n    targetNodeRadius + computeNodeCircumferenceStrokeWidth(targetNodeRadius) / 2 || nodeR,\n    arrowHeadHeight\n  );\n\n  const edgeColor = edge.color || defaultEdgeColor;\n\n  // @deprecated -- until 'highlighted' is removed we'll prioritize 'color'\n  // in case both are provided\n  const highlightedEdgeColor = edge.color || defaultHighlightedEdgeColor;\n\n  const markerId = `triangle-${svgIdNamespace}-${edge.id}`;\n  const coloredMarkerId = `triangle-colored-${svgIdNamespace}-${edge.id}`;\n\n  return (\n    <>\n      <EdgeArrowMarker id={markerId} fill={edgeColor} headHeight={arrowHeadHeight} />\n      <EdgeArrowMarker id={coloredMarkerId} fill={highlightedEdgeColor} headHeight={arrowHeadHeight} />\n      <g\n        onClick={(event) => onClick(event, edge)}\n        style={{ cursor: 'pointer' }}\n        aria-label={`Edge from: ${source.id} to: ${target.id}`}\n      >\n        <line\n          strokeWidth={(hovering ? 1 : 0) + (edge.highlighted ? 1 : 0) + edge.thickness}\n          stroke={edge.highlighted ? highlightedEdgeColor : edgeColor}\n          x1={line.x1}\n          y1={line.y1}\n          x2={line.x2}\n          y2={line.y2}\n          strokeDasharray={edge.strokeDasharray}\n          markerEnd={`url(#${edge.highlighted ? coloredMarkerId : markerId})`}\n        />\n        <line\n          stroke={'transparent'}\n          x1={line.x1}\n          y1={line.y1}\n          x2={line.x2}\n          y2={line.y2}\n          strokeWidth={20}\n          onMouseEnter={() => {\n            onMouseEnter(edge.id);\n          }}\n          onMouseLeave={() => {\n            onMouseLeave(edge.id);\n          }}\n        />\n      </g>\n    </>\n  );\n});\n","import React from 'react';\n\nimport { defaultEdgeColor } from './Edge';\n\n/**\n * In SVG you need to supply this kind of marker that can be then referenced from a line segment as an ending of the\n * line turning in into arrow. Needs to be included in the svg element and then referenced as markerEnd=\"url(#triangle)\"\n */\nexport function EdgeArrowMarker({\n  id = 'triangle',\n  fill = defaultEdgeColor,\n  headHeight = 10,\n}: {\n  id?: string;\n  fill?: string;\n  headHeight?: number;\n}) {\n  return (\n    <defs>\n      <marker\n        id={id}\n        viewBox=\"0 0 10 10\"\n        refX=\"1\" // shift the arrow head slightly closer to the center of the line it will be attached to, to ensure no empty space is shown between the line and the arrow head\n        refY=\"5\"\n        markerUnits=\"userSpaceOnUse\"\n        markerWidth={headHeight} // equal to the height just for simplicily\n        markerHeight={headHeight}\n        orient=\"auto\"\n      >\n        <path d=\"M 0 0 L 10 5 L 0 10 z\" fill={fill} />\n      </marker>\n    </defs>\n  );\n}\n","import { css } from '@emotion/css';\nimport React, { memo } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { useStyles2 } from '@grafana/ui';\n\nimport { nodeR } from './Node';\nimport { EdgeDatumLayout } from './types';\nimport { shortenLine } from './utils';\n\nconst getStyles = (theme: GrafanaTheme2) => {\n  return {\n    mainGroup: css`\n      pointer-events: none;\n      font-size: 8px;\n    `,\n\n    background: css`\n      fill: ${theme.components.tooltip.background};\n    `,\n\n    text: css`\n      fill: ${theme.components.tooltip.text};\n    `,\n  };\n};\n\ninterface Props {\n  edge: EdgeDatumLayout;\n}\nexport const EdgeLabel = memo(function EdgeLabel(props: Props) {\n  const { edge } = props;\n  // Not great typing, but after we do layout these properties are full objects not just references\n  const { source, target, sourceNodeRadius, targetNodeRadius } = edge;\n\n  // As the nodes have some radius we want edges to end outside the node circle.\n  const line = shortenLine(\n    {\n      x1: source.x!,\n      y1: source.y!,\n      x2: target.x!,\n      y2: target.y!,\n    },\n    sourceNodeRadius || nodeR,\n    targetNodeRadius || nodeR\n  );\n\n  const middle = {\n    x: line.x1 + (line.x2 - line.x1) / 2,\n    y: line.y1 + (line.y2 - line.y1) / 2,\n  };\n  const styles = useStyles2(getStyles);\n\n  const stats = [edge.mainStat, edge.secondaryStat].filter((x) => x);\n  const height = stats.length > 1 ? '30' : '15';\n  const middleOffset = stats.length > 1 ? 15 : 7.5;\n  let offset = stats.length > 1 ? -5 : 2.5;\n\n  const contents: JSX.Element[] = [];\n  stats.forEach((stat, index) => {\n    contents.push(\n      <text key={index} className={styles.text} x={middle.x} y={middle.y + offset} textAnchor={'middle'}>\n        {stat}\n      </text>\n    );\n    offset += 15;\n  });\n\n  return (\n    <g className={styles.mainGroup}>\n      <rect\n        className={styles.background}\n        x={middle.x - 40}\n        y={middle.y - middleOffset}\n        width=\"80\"\n        height={height}\n        rx=\"5\"\n      />\n      {contents}\n    </g>\n  );\n});\n","import { css } from '@emotion/css';\nimport React, { useCallback } from 'react';\n\nimport { Field, FieldColorModeId, GrafanaTheme2 } from '@grafana/data';\nimport { LegendDisplayMode } from '@grafana/schema';\nimport { Icon, useStyles2, useTheme2, VizLegend, VizLegendItem, VizLegendListItem } from '@grafana/ui';\n\nimport { Config } from './layout';\nimport { NodeDatum } from './types';\n\nfunction getStyles() {\n  return {\n    item: css`\n      label: LegendItem;\n      flex-grow: 0;\n    `,\n\n    legend: css`\n      label: Legend;\n      pointer-events: all;\n    `,\n  };\n}\n\ninterface Props {\n  nodes: NodeDatum[];\n  onSort: (sort: Config['sort']) => void;\n  sort?: Config['sort'];\n  sortable: boolean;\n}\n\nexport const Legend = function Legend(props: Props) {\n  const { nodes, onSort, sort, sortable } = props;\n\n  const theme = useTheme2();\n  const styles = useStyles2(getStyles);\n  const colorItems = getColorLegendItems(nodes, theme);\n\n  const onClick = useCallback(\n    (item: VizLegendItem<ItemData>) => {\n      onSort({\n        field: item.data!.field,\n        ascending: item.data!.field === sort?.field ? !sort?.ascending : false,\n      });\n    },\n    [sort, onSort]\n  );\n\n  return (\n    <VizLegend<ItemData>\n      className={styles.legend}\n      displayMode={LegendDisplayMode.List}\n      placement={'bottom'}\n      items={colorItems}\n      itemRenderer={(item) => {\n        return (\n          <>\n            <VizLegendListItem item={item} className={styles.item} onLabelClick={sortable ? onClick : undefined} />\n            {sortable &&\n              (sort?.field === item.data!.field ? <Icon name={sort!.ascending ? 'arrow-up' : 'arrow-down'} /> : '')}\n          </>\n        );\n      }}\n    />\n  );\n};\n\ninterface ItemData {\n  field: Field;\n}\n\nfunction getColorLegendItems(nodes: NodeDatum[], theme: GrafanaTheme2): Array<VizLegendItem<ItemData>> {\n  if (!nodes.length) {\n    return [];\n  }\n  const fields = [nodes[0].mainStat, nodes[0].secondaryStat].filter((item): item is NonNullable<typeof item> =>\n    Boolean(item)\n  );\n\n  const node = nodes.find((n) => n.arcSections.length > 0);\n  if (node) {\n    if (node.arcSections[0]!.config?.color?.mode === FieldColorModeId.Fixed) {\n      // We assume in this case we have a set of fixed colors which map neatly into a basic legend.\n\n      // Lets collect and deduplicate as there isn't a requirement for 0 size arc section to be defined\n      fields.push(...new Set(nodes.map((n) => n.arcSections).flat()));\n    }\n  }\n\n  if (nodes[0].color) {\n    fields.push(nodes[0].color);\n  }\n\n  return fields.map((f) => {\n    const item: VizLegendItem = {\n      label: f.config.displayName || f.name,\n      yAxis: 0,\n      data: { field: f },\n    };\n    if (f.config.color?.mode === FieldColorModeId.Fixed && f.config.color?.fixedColor) {\n      item.color = theme.visualization.getColorByName(f.config.color?.fixedColor || '');\n    } else if (f.config.color?.mode) {\n      item.gradient = f.config.color?.mode;\n    }\n\n    if (!(item.color || item.gradient)) {\n      // Defaults to gray color\n      item.color = theme.visualization.getColorByName('');\n    }\n\n    return item;\n  });\n}\n","import { css } from '@emotion/css';\nimport React, { MouseEvent, memo } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { useStyles2 } from '@grafana/ui';\n\nimport { NodesMarker } from './types';\n\nconst nodeR = 40;\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  mainGroup: css`\n    cursor: pointer;\n    font-size: 10px;\n  `,\n\n  mainCircle: css`\n    fill: ${theme.components.panel.background};\n    stroke: ${theme.colors.border.strong};\n  `,\n  text: css`\n    width: 50px;\n    height: 50px;\n    text-align: center;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  `,\n});\n\nexport const Marker = memo(function Marker(props: {\n  marker: NodesMarker;\n  onClick?: (event: MouseEvent<SVGElement>, marker: NodesMarker) => void;\n}) {\n  const { marker, onClick } = props;\n  const { node } = marker;\n  const styles = useStyles2(getStyles);\n\n  if (!(node.x !== undefined && node.y !== undefined)) {\n    return null;\n  }\n\n  return (\n    <g\n      data-node-id={node.id}\n      className={styles.mainGroup}\n      onClick={(event) => {\n        onClick?.(event, marker);\n      }}\n      aria-label={`Hidden nodes marker: ${node.id}`}\n    >\n      <circle className={styles.mainCircle} r={nodeR} cx={node.x} cy={node.y} />\n      <g>\n        <foreignObject x={node.x - 25} y={node.y - 25} width=\"50\" height=\"50\">\n          <div className={styles.text}>\n            {/* we limit the count to 101 so if we have more than 100 nodes we don't have exact count */}\n            <span>{marker.count > 100 ? '>100' : marker.count} nodes</span>\n          </div>\n        </foreignObject>\n      </g>\n    </g>\n  );\n});\n","import { css } from '@emotion/css';\nimport cx from 'classnames';\nimport React, { MouseEvent, memo } from 'react';\nimport tinycolor from 'tinycolor2';\n\nimport { Field, getFieldColorModeForField, GrafanaTheme2 } from '@grafana/data';\nimport { Icon, useTheme2 } from '@grafana/ui';\n\nimport { HoverState } from './NodeGraph';\nimport { NodeDatum } from './types';\nimport { statToString } from './utils';\n\nexport const nodeR = 40;\nexport const highlightedNodeColor = '#a00';\n\nconst getStyles = (theme: GrafanaTheme2, hovering: HoverState) => ({\n  mainGroup: css`\n    cursor: pointer;\n    font-size: 10px;\n    transition: opacity 300ms;\n    opacity: ${hovering === 'inactive' ? 0.5 : 1};\n  `,\n\n  mainCircle: css`\n    fill: ${theme.components.panel.background};\n  `,\n\n  filledCircle: css`\n    fill: ${highlightedNodeColor};\n  `,\n\n  hoverCircle: css`\n    opacity: 0.5;\n    fill: transparent;\n    stroke: ${theme.colors.primary.text};\n  `,\n\n  text: css`\n    fill: ${theme.colors.text.primary};\n    pointer-events: none;\n  `,\n\n  titleText: css`\n    text-align: center;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    background-color: ${tinycolor(theme.colors.background.primary).setAlpha(0.6).toHex8String()};\n    width: 140px;\n  `,\n\n  statsText: css`\n    text-align: center;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    width: 70px;\n  `,\n\n  textHovering: css`\n    width: 200px;\n    & span {\n      background-color: ${tinycolor(theme.colors.background.primary).setAlpha(0.8).toHex8String()};\n    }\n  `,\n\n  clickTarget: css`\n    fill: none;\n    stroke: none;\n    pointer-events: fill;\n  `,\n});\n\nexport const computeNodeCircumferenceStrokeWidth = (nodeRadius: number) => Math.ceil(nodeRadius * 0.075);\n\nexport const Node = memo(function Node(props: {\n  node: NodeDatum;\n  hovering: HoverState;\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n  onClick: (event: MouseEvent<SVGElement>, node: NodeDatum) => void;\n}) {\n  const { node, onMouseEnter, onMouseLeave, onClick, hovering } = props;\n  const theme = useTheme2();\n  const styles = getStyles(theme, hovering);\n  const isHovered = hovering === 'active';\n  const nodeRadius = node.nodeRadius?.values[node.dataFrameRowIndex] || nodeR;\n  const strokeWidth = computeNodeCircumferenceStrokeWidth(nodeRadius);\n\n  if (!(node.x !== undefined && node.y !== undefined)) {\n    return null;\n  }\n\n  return (\n    <g data-node-id={node.id} className={styles.mainGroup} aria-label={`Node: ${node.title}`}>\n      <circle\n        data-testid={`node-circle-${node.id}`}\n        className={node.highlighted ? styles.filledCircle : styles.mainCircle}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n      {isHovered && (\n        <circle className={styles.hoverCircle} r={nodeRadius - 3} cx={node.x} cy={node.y} strokeWidth={strokeWidth} />\n      )}\n      <ColorCircle node={node} />\n      <g className={styles.text} style={{ pointerEvents: 'none' }}>\n        <NodeContents node={node} hovering={hovering} />\n        <foreignObject\n          x={node.x - (isHovered ? 100 : 70)}\n          y={node.y + nodeRadius + 5}\n          width={isHovered ? '200' : '140'}\n          height=\"40\"\n        >\n          <div className={cx(styles.titleText, isHovered && styles.textHovering)}>\n            <span>{node.title}</span>\n            <br />\n            <span>{node.subTitle}</span>\n          </div>\n        </foreignObject>\n      </g>\n      <rect\n        data-testid={`node-click-rect-${node.id}`}\n        onMouseEnter={() => {\n          onMouseEnter(node.id);\n        }}\n        onMouseLeave={() => {\n          onMouseLeave(node.id);\n        }}\n        onClick={(event) => {\n          onClick(event, node);\n        }}\n        className={styles.clickTarget}\n        x={node.x - nodeRadius - 5}\n        y={node.y - nodeRadius - 5}\n        width={nodeRadius * 2 + 10}\n        height={nodeRadius * 2 + 50}\n      />\n    </g>\n  );\n});\n\n/**\n * Shows contents of the node which can be either an Icon or a main and secondary stat values.\n */\nfunction NodeContents({ node, hovering }: { node: NodeDatum; hovering: HoverState }) {\n  const theme = useTheme2();\n  const styles = getStyles(theme, hovering);\n  const isHovered = hovering === 'active';\n\n  if (!(node.x !== undefined && node.y !== undefined)) {\n    return null;\n  }\n\n  return node.icon ? (\n    <foreignObject x={node.x - 35} y={node.y - 20} width=\"70\" height=\"40\">\n      <div style={{ width: 70, overflow: 'hidden', display: 'flex', justifyContent: 'center', marginTop: -4 }}>\n        <Icon data-testid={`node-icon-${node.icon}`} name={node.icon} size={'xxxl'} />\n      </div>\n    </foreignObject>\n  ) : (\n    <foreignObject x={node.x - (isHovered ? 100 : 35)} y={node.y - 15} width={isHovered ? '200' : '70'} height=\"40\">\n      <div className={cx(styles.statsText, isHovered && styles.textHovering)}>\n        <span>{node.mainStat && statToString(node.mainStat.config, node.mainStat.values[node.dataFrameRowIndex])}</span>\n        <br />\n        <span>\n          {node.secondaryStat &&\n            statToString(node.secondaryStat.config, node.secondaryStat.values[node.dataFrameRowIndex])}\n        </span>\n      </div>\n    </foreignObject>\n  );\n}\n\n/**\n * Shows the outer segmented circle with different colors based on the supplied data.\n */\nfunction ColorCircle(props: { node: NodeDatum }) {\n  const { node } = props;\n  const fullStat = node.arcSections.find((s) => s.values[node.dataFrameRowIndex] >= 1);\n  const theme = useTheme2();\n  const nodeRadius = node.nodeRadius?.values[node.dataFrameRowIndex] || nodeR;\n  const strokeWidth = computeNodeCircumferenceStrokeWidth(nodeRadius);\n\n  if (fullStat) {\n    // Drawing a full circle with a `path` tag does not work well, it's better to use a `circle` tag in that case\n    return (\n      <circle\n        fill=\"none\"\n        stroke={theme.visualization.getColorByName(fullStat.config.color?.fixedColor || '')}\n        strokeWidth={strokeWidth}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n    );\n  }\n\n  const nonZero = node.arcSections.filter((s) => s.values[node.dataFrameRowIndex] !== 0);\n  if (nonZero.length === 0) {\n    // Fallback if no arc is defined\n    return (\n      <circle\n        fill=\"none\"\n        stroke={node.color ? getColor(node.color, node.dataFrameRowIndex, theme) : 'gray'}\n        strokeWidth={strokeWidth}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n    );\n  }\n\n  const { elements } = nonZero.reduce<{\n    elements: React.ReactNode[];\n    percent: number;\n  }>(\n    (acc, section, index) => {\n      const color = section.config.color?.fixedColor || '';\n      const value = section.values[node.dataFrameRowIndex];\n\n      const el = (\n        <ArcSection\n          key={index}\n          r={nodeRadius}\n          x={node.x!}\n          y={node.y!}\n          startPercent={acc.percent}\n          percent={\n            value + acc.percent > 1\n              ? // If the values aren't correct and add up to more than 100% lets still render correctly the amounts we\n                // already have and cap it at 100%\n                1 - acc.percent\n              : value\n          }\n          color={theme.visualization.getColorByName(color)}\n          strokeWidth={strokeWidth}\n        />\n      );\n      acc.elements.push(el);\n      acc.percent = acc.percent + value;\n      return acc;\n    },\n    { elements: [], percent: 0 }\n  );\n\n  return <>{elements}</>;\n}\n\nfunction ArcSection({\n  r,\n  x,\n  y,\n  startPercent,\n  percent,\n  color,\n  strokeWidth = 2,\n}: {\n  r: number;\n  x: number;\n  y: number;\n  startPercent: number;\n  percent: number;\n  color: string;\n  strokeWidth?: number;\n}) {\n  const endPercent = startPercent + percent;\n  const startXPos = x + Math.sin(2 * Math.PI * startPercent) * r;\n  const startYPos = y - Math.cos(2 * Math.PI * startPercent) * r;\n  const endXPos = x + Math.sin(2 * Math.PI * endPercent) * r;\n  const endYPos = y - Math.cos(2 * Math.PI * endPercent) * r;\n  const largeArc = percent > 0.5 ? '1' : '0';\n  return (\n    <path\n      fill=\"none\"\n      d={`M ${startXPos} ${startYPos} A ${r} ${r} 0 ${largeArc} 1 ${endXPos} ${endYPos}`}\n      stroke={color}\n      strokeWidth={strokeWidth}\n    />\n  );\n}\n\nfunction getColor(field: Field, index: number, theme: GrafanaTheme2): string {\n  if (!field.config.color) {\n    return field.values[index];\n  }\n\n  return getFieldColorModeForField(field).getCalculator(field, theme)(0, field.values[index]);\n}\n","import { css } from '@emotion/css';\nimport cx from 'classnames';\nimport React, { memo, MouseEvent, useCallback, useEffect, useMemo, useState } from 'react';\nimport useMeasure from 'react-use/lib/useMeasure';\n\nimport { DataFrame, GrafanaTheme2, LinkModel } from '@grafana/data';\nimport { Icon, Spinner, useStyles2 } from '@grafana/ui';\n\nimport { Edge } from './Edge';\nimport { EdgeLabel } from './EdgeLabel';\nimport { Legend } from './Legend';\nimport { Marker } from './Marker';\nimport { Node } from './Node';\nimport { ViewControls } from './ViewControls';\nimport { Config, defaultConfig, useLayout } from './layout';\nimport { EdgeDatumLayout, NodeDatum, NodesMarker } from './types';\nimport { useCategorizeFrames } from './useCategorizeFrames';\nimport { useContextMenu } from './useContextMenu';\nimport { useFocusPositionOnLayout } from './useFocusPositionOnLayout';\nimport { useHighlight } from './useHighlight';\nimport { usePanning } from './usePanning';\nimport { useZoom } from './useZoom';\nimport { processNodes, Bounds, findConnectedNodesForEdge, findConnectedNodesForNode } from './utils';\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css`\n    label: wrapper;\n    height: 100%;\n    width: 100%;\n    overflow: hidden;\n    position: relative;\n  `,\n\n  svg: css`\n    label: svg;\n    height: 100%;\n    width: 100%;\n    overflow: visible;\n    font-size: 10px;\n    cursor: move;\n  `,\n\n  svgPanning: css`\n    label: svgPanning;\n    user-select: none;\n  `,\n\n  noDataMsg: css`\n    height: 100%;\n    width: 100%;\n    display: grid;\n    place-items: center;\n    font-size: ${theme.typography.h4.fontSize};\n    color: ${theme.colors.text.secondary};\n  `,\n\n  mainGroup: css`\n    label: mainGroup;\n    will-change: transform;\n  `,\n\n  viewControls: css`\n    label: viewControls;\n    position: absolute;\n    left: 2px;\n    bottom: 3px;\n    right: 0;\n    display: flex;\n    align-items: flex-end;\n    justify-content: space-between;\n    pointer-events: none;\n  `,\n  legend: css`\n    label: legend;\n    background: ${theme.colors.background.secondary};\n    box-shadow: ${theme.shadows.z1};\n    padding-bottom: 5px;\n    margin-right: 10px;\n  `,\n  viewControlsWrapper: css`\n    margin-left: auto;\n  `,\n  alert: css`\n    label: alert;\n    padding: 5px 8px;\n    font-size: 10px;\n    text-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);\n    border-radius: ${theme.shape.radius.default};\n    align-items: center;\n    position: absolute;\n    top: 0;\n    right: 0;\n    background: ${theme.colors.warning.main};\n    color: ${theme.colors.warning.contrastText};\n  `,\n  loadingWrapper: css`\n    label: loadingWrapper;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  `,\n});\n\n// Limits the number of visible nodes, mainly for performance reasons. Nodes above the limit are accessible by expanding\n// parts of the graph. The specific number is arbitrary but should be a number of nodes where panning, zooming and other\n// interactions will be without any lag for most users.\nconst defaultNodeCountLimit = 200;\n\ninterface Props {\n  dataFrames: DataFrame[];\n  getLinks: (dataFrame: DataFrame, rowIndex: number) => LinkModel[];\n  nodeLimit?: number;\n  panelId?: string;\n}\nexport function NodeGraph({ getLinks, dataFrames, nodeLimit, panelId }: Props) {\n  const nodeCountLimit = nodeLimit || defaultNodeCountLimit;\n  const { edges: edgesDataFrames, nodes: nodesDataFrames } = useCategorizeFrames(dataFrames);\n\n  const [measureRef, { width, height }] = useMeasure();\n  const [config, setConfig] = useState<Config>(defaultConfig);\n\n  const firstNodesDataFrame = nodesDataFrames[0];\n  const firstEdgesDataFrame = edgesDataFrames[0];\n\n  // Ensure we use unique IDs for the marker tip elements, since IDs are global\n  // in the entire HTML document. This prevents hidden tips when an earlier\n  // occurence is hidden (editor is open in front of an existing node graph\n  // panel) or when the earlier tips have different properties (color, size, or\n  // shape for example).\n  const svgIdNamespace = panelId || 'nodegraphpanel';\n\n  // TODO we should be able to allow multiple dataframes for both edges and nodes, could be issue with node ids which in\n  //  that case should be unique or figure a way to link edges and nodes dataframes together.\n  const processed = useMemo(\n    () => processNodes(firstNodesDataFrame, firstEdgesDataFrame),\n    [firstEdgesDataFrame, firstNodesDataFrame]\n  );\n\n  // We need hover state here because for nodes we also highlight edges and for edges have labels separate to make\n  // sure they are visible on top of everything else\n  const { nodeHover, setNodeHover, clearNodeHover, edgeHover, setEdgeHover, clearEdgeHover } = useHover();\n  const [hoveringIds, setHoveringIds] = useState<string[]>([]);\n  useEffect(() => {\n    let linked: string[] = [];\n    if (nodeHover) {\n      linked = findConnectedNodesForNode(processed.nodes, processed.edges, nodeHover);\n    } else if (edgeHover) {\n      linked = findConnectedNodesForEdge(processed.nodes, processed.edges, edgeHover);\n    }\n    setHoveringIds(linked);\n  }, [nodeHover, edgeHover, processed]);\n\n  // This is used for navigation from grid to graph view. This node will be centered and briefly highlighted.\n  const [focusedNodeId, setFocusedNodeId] = useState<string>();\n  const setFocused = useCallback((e: MouseEvent, m: NodesMarker) => setFocusedNodeId(m.node.id), [setFocusedNodeId]);\n\n  // May seem weird that we do layout first and then limit the nodes shown but the problem is we want to keep the node\n  // position stable which means we need the full layout first and then just visually hide the nodes. As hiding/showing\n  // nodes should not have effect on layout it should not be recalculated.\n  const { nodes, edges, markers, bounds, hiddenNodesCount, loading } = useLayout(\n    processed.nodes,\n    processed.edges,\n    config,\n    nodeCountLimit,\n    width,\n    focusedNodeId,\n    processed.hasFixedPositions\n  );\n\n  // If we move from grid to graph layout, and we have focused node lets get its position to center there. We want to\n  // do it specifically only in that case.\n  const focusPosition = useFocusPositionOnLayout(config, nodes, focusedNodeId);\n  const { panRef, zoomRef, onStepUp, onStepDown, isPanning, position, scale, isMaxZoom, isMinZoom } = usePanAndZoom(\n    bounds,\n    focusPosition\n  );\n\n  const { onEdgeOpen, onNodeOpen, MenuComponent } = useContextMenu(\n    getLinks,\n    firstNodesDataFrame,\n    firstEdgesDataFrame,\n    config,\n    setConfig,\n    setFocusedNodeId\n  );\n  const styles = useStyles2(getStyles);\n\n  // This cannot be inline func, or it will create infinite render cycle.\n  const topLevelRef = useCallback(\n    (r: HTMLDivElement) => {\n      measureRef(r);\n      zoomRef.current = r;\n    },\n    [measureRef, zoomRef]\n  );\n\n  const highlightId = useHighlight(focusedNodeId);\n\n  return (\n    <div ref={topLevelRef} className={styles.wrapper}>\n      {loading ? (\n        <div className={styles.loadingWrapper}>\n          Computing layout&nbsp;\n          <Spinner />\n        </div>\n      ) : null}\n\n      {dataFrames.length && processed.nodes.length ? (\n        <svg\n          ref={panRef}\n          viewBox={`${-(width / 2)} ${-(height / 2)} ${width} ${height}`}\n          className={cx(styles.svg, isPanning && styles.svgPanning)}\n        >\n          <g\n            className={styles.mainGroup}\n            style={{ transform: `scale(${scale}) translate(${Math.floor(position.x)}px, ${Math.floor(position.y)}px)` }}\n          >\n            {!config.gridLayout && (\n              <Edges\n                edges={edges}\n                nodeHoveringId={nodeHover}\n                edgeHoveringId={edgeHover}\n                onClick={onEdgeOpen}\n                onMouseEnter={setEdgeHover}\n                onMouseLeave={clearEdgeHover}\n                svgIdNamespace={svgIdNamespace}\n              />\n            )}\n            <Nodes\n              nodes={nodes}\n              onMouseEnter={setNodeHover}\n              onMouseLeave={clearNodeHover}\n              onClick={onNodeOpen}\n              hoveringIds={hoveringIds || [highlightId]}\n            />\n\n            <Markers markers={markers || []} onClick={setFocused} />\n            {/*We split the labels from edges so that they are shown on top of everything else*/}\n            {!config.gridLayout && <EdgeLabels edges={edges} nodeHoveringId={nodeHover} edgeHoveringId={edgeHover} />}\n          </g>\n        </svg>\n      ) : (\n        <div className={styles.noDataMsg}>No data</div>\n      )}\n\n      <div className={styles.viewControls}>\n        {nodes.length ? (\n          <div className={styles.legend}>\n            <Legend\n              sortable={config.gridLayout}\n              nodes={nodes}\n              sort={config.sort}\n              onSort={(sort) => {\n                setConfig({\n                  ...config,\n                  sort: sort,\n                });\n              }}\n            />\n          </div>\n        ) : null}\n\n        <div className={styles.viewControlsWrapper}>\n          <ViewControls<Config>\n            config={config}\n            onConfigChange={(cfg) => {\n              if (cfg.gridLayout !== config.gridLayout) {\n                setFocusedNodeId(undefined);\n              }\n              setConfig(cfg);\n            }}\n            onMinus={onStepDown}\n            onPlus={onStepUp}\n            scale={scale}\n            disableZoomIn={isMaxZoom}\n            disableZoomOut={isMinZoom}\n          />\n        </div>\n      </div>\n\n      {hiddenNodesCount > 0 && (\n        <div className={styles.alert} aria-label={'Nodes hidden warning'}>\n          <Icon size=\"sm\" name={'info-circle'} /> {hiddenNodesCount} nodes are hidden for performance reasons.\n        </div>\n      )}\n\n      {MenuComponent}\n    </div>\n  );\n}\n\n// Active -> emphasized, inactive -> de-emphasized, and default -> normal styling\nexport type HoverState = 'active' | 'inactive' | 'default';\n\n// These components are here as a perf optimisation to prevent going through all nodes and edges on every pan/zoom.\ninterface NodesProps {\n  nodes: NodeDatum[];\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n  onClick: (event: MouseEvent<SVGElement>, node: NodeDatum) => void;\n  hoveringIds?: string[];\n}\nconst Nodes = memo(function Nodes(props: NodesProps) {\n  return (\n    <>\n      {props.nodes.map((n) => (\n        <Node\n          key={n.id}\n          node={n}\n          onMouseEnter={props.onMouseEnter}\n          onMouseLeave={props.onMouseLeave}\n          onClick={props.onClick}\n          hovering={\n            !props.hoveringIds || props.hoveringIds.length === 0\n              ? 'default'\n              : props.hoveringIds?.includes(n.id)\n                ? 'active'\n                : 'inactive'\n          }\n        />\n      ))}\n    </>\n  );\n});\n\ninterface MarkersProps {\n  markers: NodesMarker[];\n  onClick: (event: MouseEvent<SVGElement>, marker: NodesMarker) => void;\n}\nconst Markers = memo(function Nodes(props: MarkersProps) {\n  return (\n    <>\n      {props.markers.map((m) => (\n        <Marker key={'marker-' + m.node.id} marker={m} onClick={props.onClick} />\n      ))}\n    </>\n  );\n});\n\ninterface EdgesProps {\n  edges: EdgeDatumLayout[];\n  nodeHoveringId?: string;\n  edgeHoveringId?: string;\n  svgIdNamespace: string;\n  onClick: (event: MouseEvent<SVGElement>, link: EdgeDatumLayout) => void;\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n}\nconst Edges = memo(function Edges(props: EdgesProps) {\n  return (\n    <>\n      {props.edges.map((e) => (\n        <Edge\n          key={e.id}\n          edge={e}\n          hovering={\n            (e.source as NodeDatum).id === props.nodeHoveringId ||\n            (e.target as NodeDatum).id === props.nodeHoveringId ||\n            props.edgeHoveringId === e.id\n          }\n          onClick={props.onClick}\n          onMouseEnter={props.onMouseEnter}\n          onMouseLeave={props.onMouseLeave}\n          svgIdNamespace={props.svgIdNamespace}\n        />\n      ))}\n    </>\n  );\n});\n\ninterface EdgeLabelsProps {\n  edges: EdgeDatumLayout[];\n  nodeHoveringId?: string;\n  edgeHoveringId?: string;\n}\nconst EdgeLabels = memo(function EdgeLabels(props: EdgeLabelsProps) {\n  return (\n    <>\n      {props.edges.map((e, index) => {\n        // We show the edge label in case user hovers over the edge directly or if they hover over node edge is\n        // connected to.\n        const shouldShow =\n          (e.source as NodeDatum).id === props.nodeHoveringId ||\n          (e.target as NodeDatum).id === props.nodeHoveringId ||\n          props.edgeHoveringId === e.id;\n\n        const hasStats = e.mainStat || e.secondaryStat;\n        return shouldShow && hasStats && <EdgeLabel key={e.id} edge={e} />;\n      })}\n    </>\n  );\n});\n\nfunction usePanAndZoom(bounds: Bounds, focus?: { x: number; y: number }) {\n  const { scale, onStepDown, onStepUp, ref, isMax, isMin } = useZoom();\n  const { state: panningState, ref: panRef } = usePanning<SVGSVGElement>({\n    scale,\n    bounds,\n    focus,\n  });\n  const { position, isPanning } = panningState;\n  return { zoomRef: ref, panRef, position, isPanning, scale, onStepDown, onStepUp, isMaxZoom: isMax, isMinZoom: isMin };\n}\n\nfunction useHover() {\n  const [nodeHover, setNodeHover] = useState<string | undefined>(undefined);\n  const clearNodeHover = useCallback(() => setNodeHover(undefined), [setNodeHover]);\n  const [edgeHover, setEdgeHover] = useState<string | undefined>(undefined);\n  const clearEdgeHover = useCallback(() => setEdgeHover(undefined), [setEdgeHover]);\n\n  return { nodeHover, setNodeHover, clearNodeHover, edgeHover, setEdgeHover, clearEdgeHover };\n}\n","import memoizeOne from 'memoize-one';\nimport React, { useId } from 'react';\n\nimport { PanelProps } from '@grafana/data';\n\nimport { useLinks } from '../../../features/explore/utils/links';\n\nimport { NodeGraph } from './NodeGraph';\nimport { NodeGraphOptions } from './types';\nimport { getNodeGraphDataFrames } from './utils';\n\nexport const NodeGraphPanel = ({ width, height, data, options }: PanelProps<NodeGraphOptions>) => {\n  const getLinks = useLinks(data.timeRange);\n  const panelId = useId();\n\n  if (!data || !data.series.length) {\n    return (\n      <div className=\"panel-empty\">\n        <p>No data found in response</p>\n      </div>\n    );\n  }\n\n  const memoizedGetNodeGraphDataFrames = memoizeOne(getNodeGraphDataFrames);\n  return (\n    <div style={{ width, height }}>\n      <NodeGraph\n        dataFrames={memoizedGetNodeGraphDataFrames(data.series, options)}\n        getLinks={getLinks}\n        panelId={panelId}\n      />\n    </div>\n  );\n};\n","import { css } from '@emotion/css';\nimport React, { useState } from 'react';\n\nimport { Button, HorizontalGroup, useStyles2, VerticalGroup } from '@grafana/ui';\n\nfunction getStyles() {\n  return {\n    wrapper: css`\n      label: wrapper;\n      pointer-events: all;\n    `,\n  };\n}\n\ninterface Props<Config> {\n  config: Config;\n  onConfigChange: (config: Config) => void;\n  onPlus: () => void;\n  onMinus: () => void;\n  scale: number;\n  disableZoomOut?: boolean;\n  disableZoomIn?: boolean;\n}\n\n/**\n * Control buttons for zoom but also some layout config inputs mainly for debugging.\n */\nexport function ViewControls<Config extends Record<string, any>>(props: Props<Config>) {\n  const { config, onConfigChange, onPlus, onMinus, disableZoomOut, disableZoomIn } = props;\n  const [showConfig, setShowConfig] = useState(false);\n\n  // For debugging the layout, should be removed here and maybe moved to panel config later on\n  const allowConfiguration = false;\n  const styles = useStyles2(getStyles);\n\n  return (\n    <div className={styles.wrapper}>\n      <VerticalGroup spacing=\"sm\">\n        <HorizontalGroup spacing=\"xs\">\n          <Button\n            icon={'plus-circle'}\n            onClick={onPlus}\n            size={'md'}\n            title={'Zoom in'}\n            variant=\"secondary\"\n            disabled={disableZoomIn}\n          />\n          <Button\n            icon={'minus-circle'}\n            onClick={onMinus}\n            size={'md'}\n            title={'Zoom out'}\n            variant=\"secondary\"\n            disabled={disableZoomOut}\n          />\n        </HorizontalGroup>\n        <HorizontalGroup spacing=\"xs\">\n          <Button\n            icon={'code-branch'}\n            onClick={() => onConfigChange({ ...config, gridLayout: false })}\n            size={'md'}\n            title={'Default layout'}\n            variant=\"secondary\"\n            disabled={!config.gridLayout}\n          />\n          <Button\n            icon={'apps'}\n            onClick={() => onConfigChange({ ...config, gridLayout: true })}\n            size={'md'}\n            title={'Grid layout'}\n            variant=\"secondary\"\n            disabled={config.gridLayout}\n          />\n        </HorizontalGroup>\n      </VerticalGroup>\n\n      {allowConfiguration && (\n        <Button size={'xs'} fill=\"text\" onClick={() => setShowConfig((showConfig) => !showConfig)}>\n          {showConfig ? 'Hide config' : 'Show config'}\n        </Button>\n      )}\n\n      {allowConfiguration &&\n        showConfig &&\n        Object.keys(config)\n          .filter((k) => k !== 'show')\n          .map((k) => (\n            <div key={k}>\n              {k}\n              <input\n                style={{ width: 50 }}\n                type={'number'}\n                value={config[k]}\n                onChange={(e) => {\n                  onConfigChange({ ...config, [k]: parseFloat(e.target.value) });\n                }}\n              />\n            </div>\n          ))}\n    </div>\n  );\n}\n","import { CorsWorker as Worker } from '../../../core/utils/CorsWorker';\n\nexport const createWorker = () => new Worker(new URL('./layout.worker.js', import.meta.url));\nexport const createMsaglWorker = () => new Worker(new URL('./layeredLayout.worker.js', import.meta.url));\n","import { css } from '@emotion/css';\nimport React from 'react';\n\nimport { Field, StandardEditorProps } from '@grafana/data';\nimport { Button, ColorPicker, useStyles2 } from '@grafana/ui';\nimport { FieldNamePicker } from '@grafana/ui/src/components/MatchersUI/FieldNamePicker';\n\nimport { ArcOption, NodeGraphOptions } from '../types';\n\ntype Settings = { filter: (field: Field) => boolean };\ntype ArcOptionsEditorProps = StandardEditorProps<ArcOption[], Settings, NodeGraphOptions, undefined>;\n\nexport const ArcOptionsEditor = ({ value, onChange, context }: ArcOptionsEditorProps) => {\n  const styles = useStyles2(getStyles);\n\n  const addArc = () => {\n    const newArc = { field: '', color: '' };\n    onChange(value ? [...value, newArc] : [newArc]);\n  };\n\n  const removeArc = (idx: number) => {\n    const copy = value?.slice();\n    copy.splice(idx, 1);\n    onChange(copy);\n  };\n\n  const updateField = <K extends keyof ArcOption>(idx: number, field: K, newValue: ArcOption[K]) => {\n    let arcs = value?.slice() ?? [];\n    arcs[idx][field] = newValue;\n    onChange(arcs);\n  };\n\n  return (\n    <>\n      {value?.map((arc, i) => {\n        return (\n          <div className={styles.section} key={i}>\n            <FieldNamePicker\n              context={context}\n              value={arc.field ?? ''}\n              onChange={(val) => {\n                updateField(i, 'field', val);\n              }}\n              item={{\n                settings: {\n                  filter: (field: Field) => field.name.includes('arc__'),\n                },\n                id: `arc-field-${i}`,\n                name: `arc-field-${i}`,\n              }}\n            />\n            <ColorPicker\n              color={arc.color || '#808080'}\n              onChange={(val) => {\n                updateField(i, 'color', val);\n              }}\n            />\n            <Button size=\"sm\" icon=\"minus\" variant=\"secondary\" onClick={() => removeArc(i)} title=\"Remove arc\" />\n          </div>\n        );\n      })}\n      <Button size={'sm'} icon=\"plus\" onClick={addArc} variant=\"secondary\">\n        Add arc\n      </Button>\n    </>\n  );\n};\n\nconst getStyles = () => {\n  return {\n    section: css`\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      gap: 0 8px;\n      margin-bottom: 8px;\n    `,\n  };\n};\n","import { fromPairs } from 'lodash';\nimport { useEffect, useMemo, useRef, useState } from 'react';\nimport { useUnmount } from 'react-use';\nimport useMountedState from 'react-use/lib/useMountedState';\n\nimport { Field } from '@grafana/data';\nimport { config as grafanaConfig } from '@grafana/runtime';\n\nimport { createWorker, createMsaglWorker } from './createLayoutWorker';\nimport { EdgeDatum, EdgeDatumLayout, NodeDatum } from './types';\nimport { useNodeLimit } from './useNodeLimit';\nimport { graphBounds } from './utils';\n\nexport interface Config {\n  linkDistance: number;\n  linkStrength: number;\n  forceX: number;\n  forceXStrength: number;\n  forceCollide: number;\n  tick: number;\n  gridLayout: boolean;\n  sort?: {\n    // Either a arc field or stats field\n    field: Field;\n    ascending: boolean;\n  };\n}\n\n// Config mainly for the layout but also some other parts like current layout. The layout variables can be changed only\n// if you programmatically enable the config editor (for development only) see ViewControls. These could be moved to\n// panel configuration at some point (apart from gridLayout as that can be switched be user right now.).\nexport const defaultConfig: Config = {\n  linkDistance: 150,\n  linkStrength: 0.5,\n  forceX: 2000,\n  forceXStrength: 0.02,\n  forceCollide: 100,\n  tick: 300,\n  gridLayout: false,\n};\n\n/**\n * This will return copy of the nods and edges with x,y positions filled in. Also the layout changes source/target props\n * in edges from string ids to actual nodes.\n */\nexport function useLayout(\n  rawNodes: NodeDatum[],\n  rawEdges: EdgeDatum[],\n  config: Config = defaultConfig,\n  nodeCountLimit: number,\n  width: number,\n  rootNodeId?: string,\n  hasFixedPositions?: boolean\n) {\n  const [nodesGraph, setNodesGraph] = useState<NodeDatum[]>([]);\n  const [edgesGraph, setEdgesGraph] = useState<EdgeDatumLayout[]>([]);\n\n  const [loading, setLoading] = useState(false);\n\n  const isMounted = useMountedState();\n  const layoutWorkerCancelRef = useRef<(() => void) | undefined>();\n\n  useUnmount(() => {\n    if (layoutWorkerCancelRef.current) {\n      layoutWorkerCancelRef.current();\n    }\n  });\n\n  // Also we compute both layouts here. Grid layout should not add much time and we can more easily just cache both\n  // so this should happen only once for a given response data.\n  //\n  // Also important note is that right now this works on all the nodes even if they are not visible. This means that\n  // the node position is stable even when expanding different parts of graph. It seems like a reasonable thing but\n  // implications are that:\n  // - limiting visible nodes count does not have a positive perf effect\n  // - graphs with high node count can seem weird (very sparse or spread out) when we show only some nodes but layout\n  //   is done for thousands of nodes but we also do this only once in the graph lifecycle.\n  // We could re-layout this on visible nodes change but this may need smaller visible node limit to keep the perf\n  // (as we would run layout on every click) and also would be very weird without any animation to understand what is\n  // happening as already visible nodes would change positions.\n  useEffect(() => {\n    if (rawNodes.length === 0) {\n      setNodesGraph([]);\n      setEdgesGraph([]);\n      setLoading(false);\n      return;\n    }\n\n    if (hasFixedPositions) {\n      setNodesGraph(rawNodes);\n      // The layout function turns source and target fields from string to NodeDatum, so we do that here as well.\n      const nodesMap = fromPairs(rawNodes.map((node) => [node.id, node]));\n      setEdgesGraph(\n        rawEdges.map(\n          (e): EdgeDatumLayout => ({\n            ...e,\n            source: nodesMap[e.source],\n            target: nodesMap[e.target],\n          })\n        )\n      );\n      setLoading(false);\n      return;\n    }\n\n    // Layered layout is better but also more expensive, so we switch to default force based layout for bigger graphs.\n    const layoutType =\n      grafanaConfig.featureToggles.nodeGraphDotLayout && rawNodes.length <= 500 ? 'layered' : 'default';\n\n    setLoading(true);\n    // This is async but as I wanted to still run the sync grid layout, and you cannot return promise from effect so\n    // having callback seems ok here.\n    const cancel = layout(rawNodes, rawEdges, layoutType, ({ nodes, edges }) => {\n      if (isMounted()) {\n        setNodesGraph(nodes);\n        setEdgesGraph(edges);\n        setLoading(false);\n      }\n    });\n    layoutWorkerCancelRef.current = cancel;\n    return cancel;\n  }, [hasFixedPositions, rawNodes, rawEdges, isMounted]);\n\n  // Compute grid separately as it is sync and do not need to be inside effect. Also it is dependant on width while\n  // default layout does not care and we don't want to recalculate that on panel resize.\n  const [nodesGrid, edgesGrid] = useMemo(() => {\n    if (rawNodes.length === 0) {\n      return [[], []];\n    }\n\n    const rawNodesCopy = rawNodes.map((n) => ({ ...n }));\n    const rawEdgesCopy = rawEdges.map((e) => ({ ...e }));\n    gridLayout(rawNodesCopy, width, config.sort);\n\n    return [rawNodesCopy, rawEdgesCopy as EdgeDatumLayout[]];\n  }, [config.sort, rawNodes, rawEdges, width]);\n\n  // Limit the nodes so we don't show all for performance reasons. Here we don't compute both at the same time so\n  // changing the layout can trash internal memoization at the moment.\n  const {\n    nodes: nodesWithLimit,\n    edges: edgesWithLimit,\n    markers,\n  } = useNodeLimit(\n    config.gridLayout ? nodesGrid : nodesGraph,\n    config.gridLayout ? edgesGrid : edgesGraph,\n    nodeCountLimit,\n    config,\n    rootNodeId\n  );\n\n  // Get bounds based on current limited number of nodes.\n  const bounds = useMemo(\n    () => graphBounds([...nodesWithLimit, ...(markers || []).map((m) => m.node)]),\n    [nodesWithLimit, markers]\n  );\n\n  return {\n    nodes: nodesWithLimit,\n    edges: edgesWithLimit,\n    markers,\n    bounds,\n    hiddenNodesCount: rawNodes.length - nodesWithLimit.length,\n    loading,\n  };\n}\n\n/**\n * Wraps the layout code in a worker as it can take long and we don't want to block the main thread.\n * Returns a cancel function to terminate the worker.\n */\nfunction layout(\n  nodes: NodeDatum[],\n  edges: EdgeDatum[],\n  engine: 'default' | 'layered',\n  done: (data: { nodes: NodeDatum[]; edges: EdgeDatumLayout[] }) => void\n) {\n  const worker = engine === 'default' ? createWorker() : createMsaglWorker();\n\n  worker.onmessage = (event: MessageEvent<{ nodes: NodeDatum[]; edges: EdgeDatumLayout[] }>) => {\n    const nodesMap = fromPairs(nodes.map((node) => [node.id, node]));\n\n    // Add the x,y coordinates from the layout algorithm to the original nodes.\n    event.data.nodes = event.data.nodes.map((node) => {\n      return {\n        ...nodesMap[node.id],\n        ...node,\n      };\n    });\n\n    done(event.data);\n  };\n\n  worker.postMessage({\n    nodes: nodes.map((n) => ({\n      id: n.id,\n      incoming: n.incoming,\n    })),\n    edges,\n    config: defaultConfig,\n  });\n\n  return () => {\n    worker.terminate();\n  };\n}\n\n/**\n * Set the nodes in simple grid layout sorted by some stat.\n */\nfunction gridLayout(\n  nodes: NodeDatum[],\n  width: number,\n  sort?: {\n    field: Field;\n    ascending: boolean;\n  }\n) {\n  const spacingVertical = 140;\n  const spacingHorizontal = 120;\n  const padding = spacingHorizontal / 2;\n  const perRow = Math.min(Math.floor((width - padding * 2) / spacingVertical), nodes.length);\n  const midPoint = Math.floor(((perRow - 1) * spacingHorizontal) / 2);\n\n  if (sort) {\n    nodes.sort((node1, node2) => {\n      const val1 = sort!.field.values[node1.dataFrameRowIndex];\n      const val2 = sort!.field.values[node2.dataFrameRowIndex];\n\n      // Let's pretend we don't care about type of the stats for a while (they can be strings)\n      return sort!.ascending ? val1 - val2 : val2 - val1;\n    });\n  }\n\n  for (const [index, node] of nodes.entries()) {\n    const row = Math.floor(index / perRow);\n    const column = index % perRow;\n    node.x = column * spacingHorizontal - midPoint;\n    node.y = -60 + row * spacingVertical;\n  }\n}\n","import { PanelPlugin } from '@grafana/data';\n\nimport { NodeGraphPanel } from './NodeGraphPanel';\nimport { ArcOptionsEditor } from './editor/ArcOptionsEditor';\nimport { NodeGraphSuggestionsSupplier } from './suggestions';\nimport { NodeGraphOptions } from './types';\n\nexport const plugin = new PanelPlugin<NodeGraphOptions>(NodeGraphPanel)\n  .setPanelOptions((builder, context) => {\n    builder.addNestedOptions({\n      category: ['Nodes'],\n      path: 'nodes',\n      build: (builder) => {\n        builder.addUnitPicker({\n          name: 'Main stat unit',\n          path: 'mainStatUnit',\n        });\n        builder.addUnitPicker({\n          name: 'Secondary stat unit',\n          path: 'secondaryStatUnit',\n        });\n        builder.addCustomEditor({\n          name: 'Arc sections',\n          path: 'arcs',\n          id: 'arcs',\n          editor: ArcOptionsEditor,\n        });\n      },\n    });\n    builder.addNestedOptions({\n      category: ['Edges'],\n      path: 'edges',\n      build: (builder) => {\n        builder.addUnitPicker({\n          name: 'Main stat unit',\n          path: 'mainStatUnit',\n        });\n        builder.addUnitPicker({\n          name: 'Secondary stat unit',\n          path: 'secondaryStatUnit',\n        });\n      },\n    });\n  })\n  .setSuggestionsSupplier(new NodeGraphSuggestionsSupplier());\n","import { DataFrame, FieldType, VisualizationSuggestionsBuilder, VisualizationSuggestionScore } from '@grafana/data';\nimport { SuggestionName } from '../../../types/suggestions';\n\nexport class NodeGraphSuggestionsSupplier {\n  getListWithDefaults(builder: VisualizationSuggestionsBuilder) {\n    return builder.getListAppender<{}, {}>({\n      name: SuggestionName.NodeGraph,\n      pluginId: 'nodeGraph',\n    });\n  }\n\n  hasCorrectFields(frames: DataFrame[]): boolean {\n    let hasNodesFrame = false;\n    let hasEdgesFrame = false;\n\n    const nodeFields: Array<[string, FieldType]> = [\n      ['id', FieldType.string],\n      ['title', FieldType.string],\n      ['mainstat', FieldType.number],\n    ];\n    const edgeFields: Array<[string, FieldType]> = [\n      ['id', FieldType.string],\n      ['source', FieldType.string],\n      ['target', FieldType.string],\n    ];\n\n    for (const frame of frames) {\n      if (this.checkFields(nodeFields, frame)) {\n        hasNodesFrame = true;\n      }\n      if (this.checkFields(edgeFields, frame)) {\n        hasEdgesFrame = true;\n      }\n    }\n\n    return hasNodesFrame && hasEdgesFrame;\n  }\n\n  checkFields(fields: Array<[string, FieldType]>, frame: DataFrame): boolean {\n    let hasCorrectFields = true;\n\n    for (const field of fields) {\n      const [name, type] = field;\n      const frameField = frame.fields.find((f) => f.name === name);\n      if (!frameField || type !== frameField.type) {\n        hasCorrectFields = false;\n        break;\n      }\n    }\n\n    return hasCorrectFields;\n  }\n\n  getSuggestionsForData(builder: VisualizationSuggestionsBuilder) {\n    if (!builder.data) {\n      return;\n    }\n\n    const hasCorrectFields = this.hasCorrectFields(builder.data.series);\n    const nodeGraphFrames = builder.data.series.filter(\n      (df) => df.meta && df.meta.preferredVisualisationType === 'nodeGraph'\n    );\n\n    if (hasCorrectFields || nodeGraphFrames.length === 2) {\n      this.getListWithDefaults(builder).append({\n        name: SuggestionName.NodeGraph,\n        score: VisualizationSuggestionScore.Best,\n      });\n    }\n  }\n}\n","import { useMemo } from 'react';\n\nimport { DataFrame } from '@grafana/data';\n\nimport { getGraphFrame } from './utils';\n\n/**\n * As we need 2 dataframes for the service map, one with nodes and one with edges we have to figure out which is which.\n * Right now we do not have any metadata for it so we just check preferredVisualisationType and then column names.\n * TODO: maybe we could use column labels to have a better way to do this\n */\nexport function useCategorizeFrames(series: DataFrame[]) {\n  return useMemo(() => {\n    return getGraphFrame(series);\n  }, [series]);\n}\n","import { css } from '@emotion/css';\nimport React, { MouseEvent, useCallback, useState } from 'react';\n\nimport { DataFrame, Field, GrafanaTheme2, LinkModel } from '@grafana/data';\nimport { ContextMenu, MenuGroup, MenuItem, useStyles2 } from '@grafana/ui';\n\nimport { Config } from './layout';\nimport { EdgeDatumLayout, NodeDatum } from './types';\nimport { getEdgeFields, getNodeFields, statToString } from './utils';\n\n/**\n * Hook that contains state of the context menu, both for edges and nodes and provides appropriate component when\n * opened context menu should be opened.\n */\nexport function useContextMenu(\n  getLinks: (dataFrame: DataFrame, rowIndex: number) => LinkModel[],\n  // This can be undefined if we only use edge dataframe\n  nodes: DataFrame | undefined,\n  // This can be undefined if we have only single node\n  edges: DataFrame | undefined,\n  config: Config,\n  setConfig: (config: Config) => void,\n  setFocusedNodeId: (id: string) => void\n): {\n  onEdgeOpen: (event: MouseEvent<SVGElement>, edge: EdgeDatumLayout) => void;\n  onNodeOpen: (event: MouseEvent<SVGElement>, node: NodeDatum) => void;\n  MenuComponent: React.ReactNode;\n} {\n  const [menu, setMenu] = useState<JSX.Element | undefined>(undefined);\n\n  const onNodeOpen = useCallback(\n    (event: MouseEvent<SVGElement>, node: NodeDatum) => {\n      const [label, showGridLayout] = config.gridLayout\n        ? ['Show in Graph layout', false]\n        : ['Show in Grid layout', true];\n\n      const extraNodeItem = [\n        {\n          label: label,\n          onClick: (node: NodeDatum) => {\n            setFocusedNodeId(node.id);\n            setConfig({ ...config, gridLayout: showGridLayout });\n            setMenu(undefined);\n          },\n        },\n      ];\n\n      const links = nodes ? getLinks(nodes, node.dataFrameRowIndex) : [];\n      const renderer = getItemsRenderer(links, node, extraNodeItem);\n      setMenu(makeContextMenu(<NodeHeader node={node} nodes={nodes} />, event, setMenu, renderer));\n    },\n    [config, nodes, getLinks, setMenu, setConfig, setFocusedNodeId]\n  );\n\n  const onEdgeOpen = useCallback(\n    (event: MouseEvent<SVGElement>, edge: EdgeDatumLayout) => {\n      if (!edges) {\n        // This could happen if we have only one node and no edges, in which case this is not needed as there is no edge\n        // to click on.\n        return;\n      }\n      const links = getLinks(edges, edge.dataFrameRowIndex);\n      const renderer = getItemsRenderer(links, edge);\n      setMenu(makeContextMenu(<EdgeHeader edge={edge} edges={edges} />, event, setMenu, renderer));\n    },\n    [edges, getLinks, setMenu]\n  );\n\n  return { onEdgeOpen, onNodeOpen, MenuComponent: menu };\n}\n\nfunction makeContextMenu(\n  header: JSX.Element,\n  event: MouseEvent<SVGElement>,\n  setMenu: (el: JSX.Element | undefined) => void,\n  renderer?: () => React.ReactNode\n) {\n  return (\n    <ContextMenu\n      renderHeader={() => header}\n      renderMenuItems={renderer}\n      onClose={() => setMenu(undefined)}\n      x={event.pageX}\n      y={event.pageY}\n    />\n  );\n}\n\nfunction getItemsRenderer<T extends NodeDatum | EdgeDatumLayout>(\n  links: LinkModel[],\n  item: T,\n  extraItems?: Array<LinkData<T>> | undefined\n) {\n  if (!(links.length || extraItems?.length)) {\n    return undefined;\n  }\n  const items = getItems(links);\n  return () => {\n    let groups = items?.map((group, index) => (\n      <MenuGroup key={`${group.label}${index}`} label={group.label}>\n        {(group.items || []).map(mapMenuItem(item))}\n      </MenuGroup>\n    ));\n\n    if (extraItems) {\n      groups = [...extraItems.map(mapMenuItem(item)), ...groups];\n    }\n    return groups;\n  };\n}\n\nfunction mapMenuItem<T extends NodeDatum | EdgeDatumLayout>(item: T) {\n  return function NodeGraphMenuItem(link: LinkData<T>) {\n    return (\n      <MenuItem\n        key={link.label}\n        url={link.url}\n        label={link.label}\n        ariaLabel={link.ariaLabel}\n        onClick={\n          link.onClick\n            ? (event) => {\n                if (!(event?.ctrlKey || event?.metaKey || event?.shiftKey)) {\n                  event?.preventDefault();\n                  event?.stopPropagation();\n                  link.onClick?.(item);\n                }\n              }\n            : undefined\n        }\n        target={'_self'}\n      />\n    );\n  };\n}\n\ntype LinkData<T extends NodeDatum | EdgeDatumLayout> = {\n  label: string;\n  ariaLabel?: string;\n  url?: string;\n  onClick?: (item: T) => void;\n};\n\nfunction getItems(links: LinkModel[]) {\n  const defaultGroup = 'Open in Explore';\n  const groups = links.reduce<{ [group: string]: Array<{ l: LinkModel; newTitle?: string }> }>((acc, l) => {\n    let group;\n    let title;\n    if (l.title.indexOf('/') !== -1) {\n      group = l.title.split('/')[0];\n      title = l.title.split('/')[1];\n      acc[group] = acc[group] || [];\n      acc[group].push({ l, newTitle: title });\n    } else {\n      acc[defaultGroup] = acc[defaultGroup] || [];\n      acc[defaultGroup].push({ l });\n    }\n\n    return acc;\n  }, {});\n\n  return Object.keys(groups).map((key) => {\n    return {\n      label: key,\n      ariaLabel: key,\n      items: groups[key].map((link) => ({\n        label: link.newTitle || link.l.title,\n        ariaLabel: link.newTitle || link.l.title,\n        url: link.l.href,\n        onClick: link.l.onClick,\n      })),\n    };\n  });\n}\n\nfunction FieldRow({ field, index }: { field: Field; index: number }) {\n  return (\n    <HeaderRow\n      label={field.config?.displayName || field.name}\n      value={statToString(field.config, field.values[index] || '')}\n    />\n  );\n}\n\nfunction HeaderRow({ label, value }: { label: string; value: string }) {\n  const styles = useStyles2(getLabelStyles);\n  return (\n    <tr>\n      <td className={styles.label}>{label}: </td>\n      <td className={styles.value}>{value}</td>\n    </tr>\n  );\n}\n\n/**\n * Shows some field values in a table on top of the context menu.\n */\nfunction NodeHeader({ node, nodes }: { node: NodeDatum; nodes?: DataFrame }) {\n  const rows = [];\n  if (nodes) {\n    const fields = getNodeFields(nodes);\n    for (const f of [fields.title, fields.subTitle, fields.mainStat, fields.secondaryStat, ...fields.details]) {\n      if (f && f.values[node.dataFrameRowIndex]) {\n        rows.push(<FieldRow key={f.name} field={f} index={node.dataFrameRowIndex} />);\n      }\n    }\n  } else {\n    // Fallback if we don't have nodes dataFrame. Can happen if we use just the edges frame to construct this.\n    if (node.title) {\n      rows.push(<HeaderRow key=\"title\" label={'Title'} value={node.title} />);\n    }\n    if (node.subTitle) {\n      rows.push(<HeaderRow key=\"subtitle\" label={'Subtitle'} value={node.subTitle} />);\n    }\n  }\n\n  return (\n    <table style={{ width: '100%' }}>\n      <tbody>{rows}</tbody>\n    </table>\n  );\n}\n\n/**\n * Shows some of the field values in a table on top of the context menu.\n */\nfunction EdgeHeader(props: { edge: EdgeDatumLayout; edges: DataFrame }) {\n  const index = props.edge.dataFrameRowIndex;\n  const fields = getEdgeFields(props.edges);\n  const valueSource = fields.source?.values[index] || '';\n  const valueTarget = fields.target?.values[index] || '';\n\n  const rows = [];\n  if (valueSource && valueTarget) {\n    rows.push(<HeaderRow key={'header-row'} label={'Source → Target'} value={`${valueSource} → ${valueTarget}`} />);\n  }\n\n  for (const f of [fields.mainStat, fields.secondaryStat, ...fields.details]) {\n    if (f && f.values[index]) {\n      rows.push(<FieldRow key={`field-row-${index}`} field={f} index={index} />);\n    }\n  }\n\n  return (\n    <table style={{ width: '100%' }}>\n      <tbody>{rows}</tbody>\n    </table>\n  );\n}\n\nexport const getLabelStyles = (theme: GrafanaTheme2) => {\n  return {\n    label: css`\n      label: Label;\n      line-height: 1.25;\n      color: ${theme.colors.text.disabled};\n      font-size: ${theme.typography.size.sm};\n      font-weight: ${theme.typography.fontWeightMedium};\n      padding-right: ${theme.spacing(1)};\n    `,\n    value: css`\n      label: Value;\n      font-size: ${theme.typography.size.sm};\n      font-weight: ${theme.typography.fontWeightMedium};\n      color: ${theme.colors.text.primary};\n    `,\n  };\n};\n","import usePrevious from 'react-use/lib/usePrevious';\n\nimport { Config } from './layout';\nimport { NodeDatum } from './types';\n\nexport function useFocusPositionOnLayout(config: Config, nodes: NodeDatum[], focusedNodeId: string | undefined) {\n  const prevLayoutGrid = usePrevious(config.gridLayout);\n  let focusPosition;\n  if (prevLayoutGrid === true && !config.gridLayout && focusedNodeId) {\n    const node = nodes.find((n) => n.id === focusedNodeId);\n    if (node) {\n      focusPosition = {\n        x: -node.x!,\n        y: -node.y!,\n      };\n    }\n  }\n\n  return focusPosition;\n}\n","import { useEffect, useState } from 'react';\nimport useMountedState from 'react-use/lib/useMountedState';\n\nexport function useHighlight(focusedNodeId?: string) {\n  const [highlightId, setHighlightId] = useState<string>();\n  const mounted = useMountedState();\n  useEffect(() => {\n    if (focusedNodeId) {\n      setHighlightId(focusedNodeId);\n      setTimeout(() => {\n        if (mounted()) {\n          setHighlightId(undefined);\n        }\n      }, 500);\n    }\n  }, [focusedNodeId, mounted]);\n\n  return highlightId;\n}\n","import { fromPairs, uniq } from 'lodash';\nimport { useMemo } from 'react';\n\nimport { Config } from './layout';\nimport { EdgeDatumLayout, NodeDatum, NodesMarker } from './types';\n\ntype NodesMap = Record<string, NodeDatum>;\ntype EdgesMap = Record<string, EdgeDatumLayout[]>;\n\n/**\n * Limits the number of nodes by going from the roots breadth first until we have desired number of nodes.\n */\nexport function useNodeLimit(\n  nodes: NodeDatum[],\n  edges: EdgeDatumLayout[],\n  limit: number,\n  config: Config,\n  rootId?: string\n): { nodes: NodeDatum[]; edges: EdgeDatumLayout[]; markers?: NodesMarker[] } {\n  // This is pretty expensive also this happens once in the layout code when initializing position but it's a bit\n  // tricky to do it only once and reuse the results because layout directly modifies the nodes.\n  const [edgesMap, nodesMap] = useMemo(() => {\n    // Make sure we don't compute this until we have all the data.\n    if (!(nodes.length && edges.length)) {\n      return [{}, {}];\n    }\n\n    const edgesMap = edges.reduce<EdgesMap>((acc, e) => {\n      acc[e.source.id] = [...(acc[e.source.id] ?? []), e];\n      acc[e.target.id] = [...(acc[e.target.id] ?? []), e];\n      return acc;\n    }, {});\n\n    const nodesMap = nodes.reduce<NodesMap>((acc, node) => {\n      acc[node.id] = node;\n      return acc;\n    }, {});\n    return [edgesMap, nodesMap];\n  }, [edges, nodes]);\n\n  return useMemo(() => {\n    if (nodes.length <= limit) {\n      return { nodes, edges };\n    }\n\n    if (config.gridLayout) {\n      return limitGridLayout(nodes, limit, rootId);\n    }\n\n    return limitGraphLayout(nodes, edges, nodesMap, edgesMap, limit, rootId);\n  }, [edges, edgesMap, limit, nodes, nodesMap, rootId, config.gridLayout]);\n}\n\nexport function limitGraphLayout(\n  nodes: NodeDatum[],\n  edges: EdgeDatumLayout[],\n  nodesMap: NodesMap,\n  edgesMap: EdgesMap,\n  limit: number,\n  rootId?: string\n) {\n  let roots;\n  if (rootId) {\n    roots = [nodesMap[rootId]];\n  } else {\n    roots = nodes.filter((n) => n.incoming === 0);\n    // TODO: same code as layout\n    if (!roots.length) {\n      roots = [nodes[0]];\n    }\n  }\n\n  const { visibleNodes, markers } = collectVisibleNodes(limit, roots, nodesMap, edgesMap);\n\n  const markersWithStats = collectMarkerStats(markers, visibleNodes, nodesMap, edgesMap);\n  const markersMap = fromPairs(markersWithStats.map((m) => [m.node.id, m]));\n\n  for (const marker of markersWithStats) {\n    if (marker.count === 1) {\n      delete markersMap[marker.node.id];\n      visibleNodes[marker.node.id] = marker.node;\n    }\n  }\n\n  // Show all edges between visible nodes or placeholder markers\n  const visibleEdges = edges.filter(\n    (e) =>\n      (visibleNodes[e.source.id] || markersMap[e.source.id]) && (visibleNodes[e.target.id] || markersMap[e.target.id])\n  );\n\n  return {\n    nodes: Object.values(visibleNodes),\n    edges: visibleEdges,\n    markers: Object.values(markersMap),\n  };\n}\n\nexport function limitGridLayout(nodes: NodeDatum[], limit: number, rootId?: string) {\n  let start = 0;\n  let stop = limit;\n  let markers: NodesMarker[] = [];\n\n  if (rootId) {\n    const index = nodes.findIndex((node) => node.id === rootId);\n    const prevLimit = Math.floor(limit / 2);\n    let afterLimit = prevLimit;\n    start = index - prevLimit;\n    if (start < 0) {\n      afterLimit += Math.abs(start);\n      start = 0;\n    }\n    stop = index + afterLimit + 1;\n\n    if (stop > nodes.length) {\n      if (start > 0) {\n        start = Math.max(0, start - (stop - nodes.length));\n      }\n      stop = nodes.length;\n    }\n\n    if (start > 1) {\n      markers.push({ node: nodes[start - 1], count: start });\n    }\n\n    if (nodes.length - stop > 1) {\n      markers.push({ node: nodes[stop], count: nodes.length - stop });\n    }\n  } else {\n    if (nodes.length - limit > 1) {\n      markers = [{ node: nodes[limit], count: nodes.length - limit }];\n    }\n  }\n\n  return {\n    nodes: nodes.slice(start, stop),\n    edges: [],\n    markers,\n  };\n}\n\n/**\n * Breath first traverse of the graph collecting all the nodes until we reach the limit. It also returns markers which\n * are nodes on the edges which did not make it into the limit but can be used as clickable markers for manually\n * expanding the graph.\n * @param limit\n * @param roots - Nodes where to start the traversal. In case of exploration this can be any node that user clicked on.\n * @param nodesMap - Node id to node\n * @param edgesMap - This is a map of node id to a list of edges (both ingoing and outgoing)\n */\nfunction collectVisibleNodes(\n  limit: number,\n  roots: NodeDatum[],\n  nodesMap: Record<string, NodeDatum>,\n  edgesMap: Record<string, EdgeDatumLayout[]>\n): { visibleNodes: Record<string, NodeDatum>; markers: NodeDatum[] } {\n  const visibleNodes: Record<string, NodeDatum> = {};\n  let stack = [...roots];\n\n  while (Object.keys(visibleNodes).length < limit && stack.length > 0) {\n    let current = stack.shift()!;\n\n    // We are already showing this node. This can happen because graphs can be cyclic\n    if (visibleNodes[current!.id]) {\n      continue;\n    }\n\n    // Show this node\n    visibleNodes[current.id] = current;\n    const edges = edgesMap[current.id] || [];\n\n    // Add any nodes that are connected to it on top of the stack to be considered in the next pass\n    const connectedNodes = edges.map((e) => {\n      // We don't care about direction here. Should not make much difference but argument could be made that with\n      // directed graphs it should walk the graph directionally. Problem is when we focus on a node in the middle of\n      // graph (not going from the \"natural\" root) we also want to show what was \"before\".\n      const id = e.source.id === current.id ? e.target.id : e.source.id;\n      return nodesMap[id];\n    });\n    stack = stack.concat(connectedNodes);\n  }\n\n  // Right now our stack contains all the nodes which are directly connected to the graph but did not make the cut.\n  // Some of them though can be nodes we already are showing so we have to filter them and then use them as markers.\n  const markers = uniq(stack.filter((n) => !visibleNodes[n.id]));\n\n  return { visibleNodes, markers };\n}\n\nfunction collectMarkerStats(\n  markers: NodeDatum[],\n  visibleNodes: Record<string, NodeDatum>,\n  nodesMap: Record<string, NodeDatum>,\n  edgesMap: Record<string, EdgeDatumLayout[]>\n): NodesMarker[] {\n  return markers.map((marker) => {\n    const nodesToCount: Record<string, NodeDatum> = {};\n    let count = 0;\n    let stack = [marker];\n    while (stack.length > 0 && count <= 101) {\n      let current = stack.shift()!;\n\n      // We are showing this node so not going to count it as hidden.\n      if (visibleNodes[current.id] || nodesToCount[current.id]) {\n        continue;\n      }\n\n      if (!nodesToCount[current.id]) {\n        count++;\n      }\n      nodesToCount[current.id] = current;\n\n      const edges = edgesMap[current.id] || [];\n\n      const connectedNodes = edges.map((e) => {\n        const id = e.source.id === current.id ? e.target.id : e.source.id;\n        return nodesMap[id];\n      });\n      stack = stack.concat(connectedNodes);\n    }\n\n    return {\n      node: marker,\n      count: count,\n    };\n  });\n}\n","import { useEffect, useRef, RefObject, useState, useMemo } from 'react';\nimport useMountedState from 'react-use/lib/useMountedState';\nimport usePrevious from 'react-use/lib/usePrevious';\n\nimport { Bounds } from './utils';\n\nexport interface State {\n  isPanning: boolean;\n  position: {\n    x: number;\n    y: number;\n  };\n}\n\ninterface Options {\n  scale?: number;\n  bounds?: Bounds;\n  focus?: {\n    x: number;\n    y: number;\n  };\n}\n\n/**\n * Based on https://github.com/streamich/react-use/blob/master/src/useSlider.ts\n * Returns position x/y coordinates which can be directly used in transform: translate().\n * @param scale - Can be used when we want to scale the movement if we are moving a scaled element. We need to do it\n *   here because we don't want to change the pos when scale changes.\n * @param bounds - If set the panning cannot go outside of those bounds.\n * @param focus - Position to focus on.\n */\nexport function usePanning<T extends Element>({ scale = 1, bounds, focus }: Options = {}): {\n  state: State;\n  ref: RefObject<T>;\n} {\n  const isMounted = useMountedState();\n  const isPanning = useRef(false);\n  const frame = useRef(0);\n  const panRef = useRef<T>(null);\n\n  const initial = { x: 0, y: 0 };\n  // As we return a diff of the view port to be applied we need as translate coordinates we have to invert the\n  // bounds of the content to get the bounds of the view port diff.\n  const viewBounds = useMemo(\n    () => ({\n      right: bounds ? -bounds.left : Infinity,\n      left: bounds ? -bounds.right : -Infinity,\n      bottom: bounds ? -bounds.top : -Infinity,\n      top: bounds ? -bounds.bottom : Infinity,\n    }),\n    [bounds]\n  );\n\n  // We need to keep some state so we can compute the position diff and add that to the previous position.\n  const startMousePosition = useRef(initial);\n  const prevPosition = useRef(initial);\n  // We cannot use the state as that would rerun the effect on each state change which we don't want so we have to keep\n  // separate variable for the state that won't cause useEffect eval\n  const currentPosition = useRef(initial);\n\n  const [state, setState] = useState<State>({\n    isPanning: false,\n    position: initial,\n  });\n\n  useEffect(() => {\n    const startPanning = (event: Event) => {\n      if (!isPanning.current && isMounted()) {\n        isPanning.current = true;\n        // Snapshot the current position of both mouse pointer and the element\n        startMousePosition.current = getEventXY(event);\n        prevPosition.current = { ...currentPosition.current };\n        setState((state) => ({ ...state, isPanning: true }));\n        bindEvents();\n      }\n    };\n\n    const stopPanning = () => {\n      if (isPanning.current && isMounted()) {\n        isPanning.current = false;\n        setState((state) => ({ ...state, isPanning: false }));\n        unbindEvents();\n      }\n    };\n\n    const onPanStart = (event: Event) => {\n      startPanning(event);\n      onPan(event);\n    };\n\n    const bindEvents = () => {\n      document.addEventListener('mousemove', onPan);\n      document.addEventListener('mouseup', stopPanning);\n      document.addEventListener('touchmove', onPan);\n      document.addEventListener('touchend', stopPanning);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener('mousemove', onPan);\n      document.removeEventListener('mouseup', stopPanning);\n      document.removeEventListener('touchmove', onPan);\n      document.removeEventListener('touchend', stopPanning);\n    };\n\n    const onPan = (event: Event) => {\n      cancelAnimationFrame(frame.current);\n      const pos = getEventXY(event);\n\n      frame.current = requestAnimationFrame(() => {\n        if (isMounted() && panRef.current) {\n          // Get the diff by which we moved the mouse.\n          let xDiff = pos.x - startMousePosition.current.x;\n          let yDiff = pos.y - startMousePosition.current.y;\n\n          // Add the diff to the position from the moment we started panning.\n          currentPosition.current = {\n            x: inBounds(prevPosition.current.x + xDiff / scale, viewBounds.left, viewBounds.right),\n            y: inBounds(prevPosition.current.y + yDiff / scale, viewBounds.top, viewBounds.bottom),\n          };\n          setState((state) => ({\n            ...state,\n            position: {\n              ...currentPosition.current,\n            },\n          }));\n        }\n      });\n    };\n\n    const ref = panRef.current;\n    if (ref) {\n      ref.addEventListener('mousedown', onPanStart);\n      ref.addEventListener('touchstart', onPanStart);\n    }\n    return () => {\n      if (ref) {\n        ref.removeEventListener('mousedown', onPanStart);\n        ref.removeEventListener('touchstart', onPanStart);\n      }\n    };\n  }, [scale, viewBounds, isMounted]);\n\n  const previousFocus = usePrevious(focus);\n\n  // We need to update the state in case need to focus on something but we want to do it only once when the focus\n  // changes to something new.\n  useEffect(() => {\n    if (focus && previousFocus?.x !== focus.x && previousFocus?.y !== focus.y) {\n      const position = {\n        x: inBounds(focus.x, viewBounds.left, viewBounds.right),\n        y: inBounds(focus.y, viewBounds.top, viewBounds.bottom),\n      };\n      setState({\n        position,\n        isPanning: false,\n      });\n\n      currentPosition.current = position;\n      prevPosition.current = position;\n    }\n  }, [focus, previousFocus, viewBounds, currentPosition, prevPosition]);\n\n  let position = state.position;\n  // This part prevents an ugly jump from initial position to the focused one as the set state in the effects is after\n  // initial render.\n  if (focus && previousFocus?.x !== focus.x && previousFocus?.y !== focus.y) {\n    position = focus;\n  }\n\n  return {\n    state: {\n      ...state,\n      position: {\n        x: inBounds(position.x, viewBounds.left, viewBounds.right),\n        y: inBounds(position.y, viewBounds.top, viewBounds.bottom),\n      },\n    },\n    ref: panRef,\n  };\n}\n\nfunction inBounds(value: number, min: number | undefined, max: number | undefined) {\n  return Math.min(Math.max(value, min ?? -Infinity), max ?? Infinity);\n}\n\n// The issue here is that TouchEvent is undefined while using instanceof in Firefox and Safari\n// which will throw an exception but if it's event.changedTouches it will be undefined\n// and the if check will fail so it will go to the else but will not throw an exception\nfunction getEventXY(event: Event): { x: number; y: number } {\n  if ('changedTouches' in event && event instanceof TouchEvent) {\n    return { x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY };\n  } else if (event instanceof MouseEvent) {\n    return { x: event.clientX, y: event.clientY };\n  }\n  return { x: 0, y: 0 };\n}\n","import { useCallback, useEffect, useRef, useState } from 'react';\n\nconst defaultOptions: Options = {\n  stepDown: (s) => s / 1.5,\n  stepUp: (s) => s * 1.5,\n  min: 0.13,\n  max: 2.25,\n};\n\ninterface Options {\n  /**\n   * Allows you to specify how the step up will be handled so you can do fractional steps based on previous value.\n   */\n  stepUp: (scale: number) => number;\n  stepDown: (scale: number) => number;\n\n  /**\n   * Set max and min values. If stepUp/down overshoots these bounds this will return min or max but internal scale value\n   * will still be what ever the step functions returned last.\n   */\n  min?: number;\n  max?: number;\n}\n\n/**\n * Keeps state and returns handlers that can be used to implement zooming functionality ideally by using it with\n * 'transform: scale'. It returns handler for manual buttons with zoom in/zoom out function and a ref that can be\n * used to zoom in/out with mouse wheel.\n */\nexport function useZoom({ stepUp, stepDown, min, max } = defaultOptions) {\n  const ref = useRef<HTMLElement | null>(null);\n  const [scale, setScale] = useState(1);\n\n  const onStepUp = useCallback(() => {\n    if (scale < (max ?? Infinity)) {\n      setScale(stepUp(scale));\n    }\n  }, [scale, stepUp, max]);\n\n  const onStepDown = useCallback(() => {\n    if (scale > (min ?? -Infinity)) {\n      setScale(stepDown(scale));\n    }\n  }, [scale, stepDown, min]);\n\n  const onWheel = useCallback(\n    function (wheelEvent: WheelEvent) {\n      // Seems like typing for the addEventListener is lacking a bit\n\n      // Only do this with special key pressed similar to how google maps work.\n      // TODO: I would guess this won't work very well with touch right now\n      if (wheelEvent.ctrlKey || wheelEvent.metaKey) {\n        wheelEvent.preventDefault();\n\n        setScale(Math.min(Math.max(min ?? -Infinity, scale + Math.min(wheelEvent.deltaY, 2) * -0.01), max ?? Infinity));\n\n        if (wheelEvent.deltaY < 0) {\n          const newScale = scale + Math.max(wheelEvent.deltaY, -4) * -0.015;\n          setScale(Math.max(min ?? -Infinity, newScale));\n        } else if (wheelEvent.deltaY > 0) {\n          const newScale = scale + Math.min(wheelEvent.deltaY, 4) * -0.015;\n          setScale(Math.min(max ?? Infinity, newScale));\n        }\n      }\n    },\n    [min, max, scale]\n  );\n\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n\n    const zoomRef = ref.current;\n\n    // Adds listener for wheel event, we need the passive: false to be able to prevent default otherwise that\n    // cannot be used with passive listeners.\n    zoomRef.addEventListener('wheel', onWheel, { passive: false });\n    return () => {\n      if (zoomRef) {\n        zoomRef.removeEventListener('wheel', onWheel);\n      }\n    };\n  }, [onWheel]);\n\n  return {\n    onStepUp,\n    onStepDown,\n    scale: Math.max(Math.min(scale, max ?? Infinity), min ?? -Infinity),\n    isMax: scale >= (max ?? Infinity),\n    isMin: scale <= (min ?? -Infinity),\n    ref,\n  };\n}\n","import {\n  DataFrame,\n  Field,\n  FieldCache,\n  FieldColorModeId,\n  FieldConfig,\n  FieldType,\n  MutableDataFrame,\n  NodeGraphDataFrameFieldNames,\n} from '@grafana/data';\n\nimport { nodeR } from './Node';\nimport { EdgeDatum, GraphFrame, NodeDatum, NodeDatumFromEdge, NodeGraphOptions } from './types';\n\ntype Line = { x1: number; y1: number; x2: number; y2: number };\n\n/**\n * Makes line shorter while keeping its middle in the same place.\n * This is manly used to add some empty space between an edge line and its source and target nodes, to make it nicer.\n *\n * @param line a line, where x1 and y1 are the coordinates of the source node center, and x2 and y2 are the coordinates of the target node center\n * @param sourceNodeRadius radius of the source node (possibly taking into account the thickness of the node circumference line, etc.)\n * @param targetNodeRadius radius of the target node (possibly taking into account the thickness of the node circumference line, etc.)\n * @param arrowHeadHeight height of the arrow head (in pixels)\n */\nexport function shortenLine(line: Line, sourceNodeRadius: number, targetNodeRadius: number, arrowHeadHeight = 1): Line {\n  const vx = line.x2 - line.x1;\n  const vy = line.y2 - line.y1;\n  const mag = Math.sqrt(vx * vx + vy * vy);\n  const cosine = (line.x2 - line.x1) / mag;\n  const sine = (line.y2 - line.y1) / mag;\n  const scaledThickness = arrowHeadHeight - arrowHeadHeight / 10;\n\n  // Reduce the line length (along its main direction) by:\n  // - the radius of the source node\n  // - the radius of the target node,\n  // - a constant value, just to add some empty space\n  // - the height of the arrow head; the bigger the arrow head, the better is to add even more empty space\n  return {\n    x1: line.x1 + cosine * (sourceNodeRadius + 5),\n    y1: line.y1 + sine * (sourceNodeRadius + 5),\n    x2: line.x2 - cosine * (targetNodeRadius + 3 + scaledThickness),\n    y2: line.y2 - sine * (targetNodeRadius + 3 + scaledThickness),\n  };\n}\n\nexport type NodeFields = {\n  fixedX?: Field;\n  fixedY?: Field;\n  id?: Field;\n  title?: Field;\n  subTitle?: Field;\n  mainStat?: Field;\n  secondaryStat?: Field;\n  arc: Field[];\n  details: Field[];\n  color?: Field;\n  icon?: Field;\n  nodeRadius?: Field;\n  highlighted?: Field;\n};\n\nexport function getNodeFields(nodes: DataFrame): NodeFields {\n  const normalizedFrames = {\n    ...nodes,\n    fields: nodes.fields.map((field) => ({ ...field, name: field.name.toLowerCase() })),\n  };\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    title: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.title.toLowerCase()),\n    subTitle: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.subTitle.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    arc: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.arc),\n    details: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.detail),\n    color: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.color),\n    icon: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.icon),\n    nodeRadius: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.nodeRadius.toLowerCase()),\n    highlighted: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.highlighted.toLowerCase()),\n    fixedX: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.fixedX.toLowerCase()),\n    fixedY: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.fixedY.toLowerCase()),\n  };\n}\n\nexport type EdgeFields = {\n  id?: Field;\n  source?: Field;\n  target?: Field;\n  mainStat?: Field;\n  secondaryStat?: Field;\n  details: Field[];\n  /**\n   * @deprecated use `color` instead\n   */\n  highlighted?: Field;\n  thickness?: Field;\n  color?: Field;\n  strokeDasharray?: Field;\n};\n\nexport function getEdgeFields(edges: DataFrame): EdgeFields {\n  const normalizedFrames = {\n    ...edges,\n    fields: edges.fields.map((field) => ({ ...field, name: field.name.toLowerCase() })),\n  };\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    source: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase()),\n    target: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.target.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    details: findFieldsByPrefix(edges, NodeGraphDataFrameFieldNames.detail.toLowerCase()),\n    // @deprecated -- for edges use color instead\n    highlighted: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.highlighted.toLowerCase()),\n    thickness: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.thickness.toLowerCase()),\n    color: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.color.toLowerCase()),\n    strokeDasharray: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.strokeDasharray.toLowerCase()),\n  };\n}\n\nfunction findFieldsByPrefix(frame: DataFrame, prefix: string): Field[] {\n  return frame.fields.filter((f) => f.name.match(new RegExp('^' + prefix)));\n}\n\n/**\n * Transform nodes and edges dataframes into array of objects that the layout code can then work with.\n */\nexport function processNodes(\n  nodes: DataFrame | undefined,\n  edges: DataFrame | undefined\n): {\n  nodes: NodeDatum[];\n  edges: EdgeDatum[];\n  hasFixedPositions?: boolean;\n  legend?: Array<{\n    color: string;\n    name: string;\n  }>;\n} {\n  if (!(edges || nodes)) {\n    return { nodes: [], edges: [] };\n  }\n\n  if (nodes) {\n    const nodeFields = getNodeFields(nodes);\n    if (!nodeFields.id) {\n      throw new Error('id field is required for nodes data frame.');\n    }\n\n    const hasFixedPositions =\n      nodeFields.fixedX &&\n      nodeFields.fixedX.values.every((v) => Number.isFinite(v)) &&\n      nodeFields.fixedY &&\n      nodeFields.fixedY.values.every((v) => Number.isFinite(v));\n\n    // Throw an error if somebody is using fixedX and fixedY fields incorrectly. Other option is to ignore this but we\n    // are not able to easily combine fixed and non-fixed position in layout so that behaviour would be undefined\n    // and silent.\n    if (!hasFixedPositions) {\n      const somePosFilled =\n        (nodeFields.fixedX && nodeFields.fixedX.values.some((v) => Number.isFinite(v))) ||\n        (nodeFields.fixedY && nodeFields.fixedY.values.some((v) => Number.isFinite(v)));\n      if (somePosFilled) {\n        throw new Error('If fixedX and fixedY fields are present, the values have to be all filled and valid');\n      }\n    }\n\n    // Create the nodes here\n    const nodesMap: { [id: string]: NodeDatum } = {};\n    for (let i = 0; i < nodeFields.id.values.length; i++) {\n      const id = nodeFields.id.values[i];\n      nodesMap[id] = makeNodeDatum(id, nodeFields, i);\n    }\n\n    // We may not have edges in case of single node\n    let edgeDatums: EdgeDatum[] = edges ? processEdges(edges, getEdgeFields(edges), nodesMap) : [];\n\n    for (const e of edgeDatums) {\n      // We are adding incoming edges count, so we can later on find out which nodes are the roots\n      nodesMap[e.target].incoming++;\n    }\n\n    return {\n      nodes: Object.values(nodesMap),\n      edges: edgeDatums,\n      hasFixedPositions,\n      legend: nodeFields.arc.map((f) => {\n        return {\n          color: f.config.color?.fixedColor ?? '',\n          name: f.config.displayName || f.name,\n        };\n      }),\n    };\n  } else {\n    // We have only edges here, so we have to construct also nodes out of them\n\n    // We checked that either node || edges has to be defined and if nodes aren't edges has to be defined\n    edges = edges!;\n\n    const nodesMap: { [id: string]: NodeDatumFromEdge } = {};\n\n    const edgeFields = getEdgeFields(edges);\n\n    // Turn edges into reasonable filled in nodes\n    for (let i = 0; i < edges.length; i++) {\n      const { source, target } = makeNodeDatumsFromEdge(edgeFields, i);\n\n      nodesMap[target.id] = nodesMap[target.id] || target;\n      nodesMap[source.id] = nodesMap[source.id] || source;\n\n      // Check the stats fields. They can be also strings which we cannot really aggregate so only aggregate in case\n      // they are numbers. Here we just sum all incoming edges to get the final value for node.\n      if (computableField(edgeFields.mainStat)) {\n        nodesMap[target.id].mainStatNumeric =\n          (nodesMap[target.id].mainStatNumeric ?? 0) + edgeFields.mainStat!.values[i];\n      }\n\n      if (computableField(edgeFields.secondaryStat)) {\n        nodesMap[target.id].secondaryStatNumeric =\n          (nodesMap[target.id].secondaryStatNumeric ?? 0) + edgeFields.secondaryStat!.values[i];\n      }\n\n      // We are adding incoming edges count, so we can later on find out which nodes are the roots\n      nodesMap[target.id].incoming++;\n    }\n\n    let edgeDatums = processEdges(edges, edgeFields, nodesMap);\n\n    // It is expected for stats to be Field, so we have to create them.\n    const nodes = normalizeStatsForNodes(nodesMap, edgeFields);\n\n    return {\n      nodes,\n      edges: edgeDatums,\n      // Edge-only datasets never have fixedX/fixedY\n      hasFixedPositions: false,\n    };\n  }\n}\n\n/**\n * Turn data frame data into EdgeDatum that node graph understands\n * @param edges\n * @param edgeFields\n */\nfunction processEdges(edges: DataFrame, edgeFields: EdgeFields, nodesMap: { [id: string]: NodeDatum }): EdgeDatum[] {\n  if (!edgeFields.id) {\n    throw new Error('id field is required for edges data frame.');\n  }\n\n  return edgeFields.id.values.map((id, index) => {\n    const target = edgeFields.target?.values[index];\n    const source = edgeFields.source?.values[index];\n\n    const sourceNode = nodesMap[source];\n    const targetNode = nodesMap[target];\n\n    return {\n      id,\n      dataFrameRowIndex: index,\n      source,\n      target,\n      sourceNodeRadius: !sourceNode.nodeRadius ? nodeR : sourceNode.nodeRadius.values[sourceNode.dataFrameRowIndex],\n      targetNodeRadius: !targetNode.nodeRadius ? nodeR : targetNode.nodeRadius.values[targetNode.dataFrameRowIndex],\n      mainStat: edgeFields.mainStat ? statToString(edgeFields.mainStat.config, edgeFields.mainStat.values[index]) : '',\n      secondaryStat: edgeFields.secondaryStat\n        ? statToString(edgeFields.secondaryStat.config, edgeFields.secondaryStat.values[index])\n        : '',\n      // @deprecated -- for edges use color instead\n      highlighted: edgeFields.highlighted?.values[index] || false,\n      thickness: edgeFields.thickness?.values[index] || 1,\n      color: edgeFields.color?.values[index],\n      strokeDasharray: edgeFields.strokeDasharray?.values[index],\n    };\n  });\n}\n\nfunction computableField(field?: Field) {\n  return field && field.type === FieldType.number;\n}\n\n/**\n * Instead of just simple numbers node graph requires to have Field in NodeDatum (probably for some formatting info in\n * config). So we create them here and fill with correct data.\n * @param nodesMap\n * @param edgeFields\n */\nfunction normalizeStatsForNodes(nodesMap: { [id: string]: NodeDatumFromEdge }, edgeFields: EdgeFields): NodeDatum[] {\n  const secondaryStatValues: Array<number | undefined> = [];\n  const mainStatValues: Array<number | undefined> = [];\n  const secondaryStatField = computableField(edgeFields.secondaryStat)\n    ? {\n        ...edgeFields.secondaryStat!,\n        values: secondaryStatValues,\n      }\n    : undefined;\n\n  const mainStatField = computableField(edgeFields.mainStat)\n    ? {\n        ...edgeFields.mainStat!,\n        values: mainStatValues,\n      }\n    : undefined;\n\n  return Object.values(nodesMap).map((node, index) => {\n    if (mainStatField || secondaryStatField) {\n      const newNode = {\n        ...node,\n      };\n\n      if (mainStatField) {\n        newNode.mainStat = mainStatField;\n        mainStatValues.push(node.mainStatNumeric);\n        newNode.dataFrameRowIndex = index;\n      }\n\n      if (secondaryStatField) {\n        newNode.secondaryStat = secondaryStatField;\n        secondaryStatValues.push(node.secondaryStatNumeric);\n        newNode.dataFrameRowIndex = index;\n      }\n      return newNode;\n    }\n    return node;\n  });\n}\n\nfunction makeNodeDatumsFromEdge(edgeFields: EdgeFields, index: number) {\n  const targetId = edgeFields.target?.values[index];\n  const sourceId = edgeFields.source?.values[index];\n  return {\n    target: makeSimpleNodeDatum(targetId, index),\n    source: makeSimpleNodeDatum(sourceId, index),\n  };\n}\n\nfunction makeSimpleNodeDatum(name: string, index: number): NodeDatumFromEdge {\n  return {\n    id: name,\n    title: name,\n    subTitle: '',\n    dataFrameRowIndex: index,\n    incoming: 0,\n    arcSections: [],\n    highlighted: false,\n  };\n}\n\nfunction makeNodeDatum(id: string, nodeFields: NodeFields, index: number): NodeDatum {\n  return {\n    id: id,\n    title: nodeFields.title?.values[index] || '',\n    subTitle: nodeFields.subTitle?.values[index] || '',\n    dataFrameRowIndex: index,\n    incoming: 0,\n    mainStat: nodeFields.mainStat,\n    secondaryStat: nodeFields.secondaryStat,\n    arcSections: nodeFields.arc,\n    color: nodeFields.color,\n    icon: nodeFields.icon?.values[index] || '',\n    nodeRadius: nodeFields.nodeRadius,\n    highlighted: nodeFields.highlighted?.values[index] || false,\n    x: nodeFields.fixedX?.values[index] ?? undefined,\n    y: nodeFields.fixedY?.values[index] ?? undefined,\n  };\n}\n\nexport function statToString(config: FieldConfig, value: number | string): string {\n  if (typeof value === 'string') {\n    return value;\n  } else {\n    const decimals = config.decimals || 2;\n    if (Number.isFinite(value)) {\n      return value.toFixed(decimals) + (config.unit ? ' ' + config.unit : '');\n    } else {\n      return '';\n    }\n  }\n}\n\n/**\n * Utilities mainly for testing\n */\n\nexport function makeNodesDataFrame(count: number) {\n  const frame = nodesFrame();\n  for (let i = 0; i < count; i++) {\n    frame.add(makeNode(i));\n  }\n\n  return frame;\n}\n\nfunction makeNode(index: number) {\n  return {\n    id: index.toString(),\n    title: `service:${index}`,\n    subtitle: 'service',\n    arc__success: 0.5,\n    arc__errors: 0.5,\n    mainstat: 0.1,\n    secondarystat: 2,\n    color: 0.5,\n    icon: 'database',\n    noderadius: 40,\n  };\n}\n\nfunction nodesFrame() {\n  const fields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.title]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.subTitle]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'success']: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.Fixed, fixedColor: 'green' } },\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'errors']: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.Fixed, fixedColor: 'red' } },\n    },\n    [NodeGraphDataFrameFieldNames.color]: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.ContinuousGrYlRd } },\n    },\n    [NodeGraphDataFrameFieldNames.icon]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.nodeRadius]: {\n      values: [],\n      type: FieldType.number,\n    },\n  };\n\n  return new MutableDataFrame({\n    name: 'nodes',\n    fields: Object.entries(fields).map(([key, value]) => ({\n      ...value,\n      name: key,\n    })),\n  });\n}\n\nexport function makeEdgesDataFrame(\n  edges: Array<Partial<{ source: string; target: string; mainstat: number; secondarystat: number }>>\n) {\n  const frame = edgesFrame();\n  for (const edge of edges) {\n    frame.add({\n      id: edge.source + '--' + edge.target,\n      ...edge,\n    });\n  }\n\n  return frame;\n}\n\nfunction edgesFrame() {\n  const fields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.source]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.target]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n  };\n\n  return new MutableDataFrame({\n    name: 'edges',\n    fields: Object.entries(fields).map(([key, value]) => ({\n      ...value,\n      name: key,\n    })),\n  });\n}\n\nexport interface Bounds {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n  center: {\n    x: number;\n    y: number;\n  };\n}\n\n/**\n * Get bounds of the graph meaning the extent of the nodes in all directions.\n */\nexport function graphBounds(nodes: NodeDatum[]): Bounds {\n  if (nodes.length === 0) {\n    return { top: 0, right: 0, bottom: 0, left: 0, center: { x: 0, y: 0 } };\n  }\n\n  const bounds = nodes.reduce(\n    (acc, node) => {\n      if (node.x! > acc.right) {\n        acc.right = node.x!;\n      }\n      if (node.x! < acc.left) {\n        acc.left = node.x!;\n      }\n      if (node.y! > acc.bottom) {\n        acc.bottom = node.y!;\n      }\n      if (node.y! < acc.top) {\n        acc.top = node.y!;\n      }\n      return acc;\n    },\n    { top: Infinity, right: -Infinity, bottom: -Infinity, left: Infinity }\n  );\n\n  const y = bounds.top + (bounds.bottom - bounds.top) / 2;\n  const x = bounds.left + (bounds.right - bounds.left) / 2;\n\n  return {\n    ...bounds,\n    center: {\n      x,\n      y,\n    },\n  };\n}\n\nexport function getNodeGraphDataFrames(frames: DataFrame[], options?: NodeGraphOptions) {\n  // TODO: this not in sync with how other types of responses are handled. Other types have a query response\n  //  processing pipeline which ends up populating redux state with proper data. As we move towards more dataFrame\n  //  oriented API it seems like a better direction to move such processing into to visualisations and do minimal\n  //  and lazy processing here. Needs bigger refactor so keeping nodeGraph and Traces as they are for now.\n  let nodeGraphFrames = frames.filter((frame) => {\n    if (frame.meta?.preferredVisualisationType === 'nodeGraph') {\n      return true;\n    }\n\n    if (frame.name === 'nodes' || frame.name === 'edges' || frame.refId === 'nodes' || frame.refId === 'edges') {\n      return true;\n    }\n\n    const fieldsCache = new FieldCache(frame);\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id)) {\n      return true;\n    }\n\n    return false;\n  });\n\n  // If panel options are provided, interpolate their values in to the data frames\n  if (options) {\n    nodeGraphFrames = applyOptionsToFrames(nodeGraphFrames, options);\n  }\n  return nodeGraphFrames;\n}\n\nexport const applyOptionsToFrames = (frames: DataFrame[], options: NodeGraphOptions): DataFrame[] => {\n  return frames.map((frame) => {\n    const fieldsCache = new FieldCache(frame);\n\n    // Edges frame has source which can be used to identify nodes vs edges frames\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase())) {\n      if (options?.edges?.mainStatUnit) {\n        const field = frame.fields.find((field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n        if (field) {\n          field.config = { ...field.config, unit: options.edges.mainStatUnit };\n        }\n      }\n      if (options?.edges?.secondaryStatUnit) {\n        const field = frame.fields.find(\n          (field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat\n        );\n        if (field) {\n          field.config = { ...field.config, unit: options.edges.secondaryStatUnit };\n        }\n      }\n    } else {\n      if (options?.nodes?.mainStatUnit) {\n        const field = frame.fields.find((field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n        if (field) {\n          field.config = { ...field.config, unit: options.nodes.mainStatUnit };\n        }\n      }\n      if (options?.nodes?.secondaryStatUnit) {\n        const field = frame.fields.find(\n          (field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat\n        );\n        if (field) {\n          field.config = { ...field.config, unit: options.nodes.secondaryStatUnit };\n        }\n      }\n      if (options?.nodes?.arcs?.length) {\n        for (const arc of options.nodes.arcs) {\n          // As the arc__ field suffixes can be custom we compare them case insensitively to be safe.\n          const field = frame.fields.find((field) => field.name.toLowerCase() === arc.field?.toLowerCase());\n          if (field && arc.color) {\n            field.config = { ...field.config, color: { fixedColor: arc.color, mode: FieldColorModeId.Fixed } };\n          }\n        }\n      }\n    }\n    return frame;\n  });\n};\n\n// Returns an array of node ids which are connected to a given edge\nexport const findConnectedNodesForEdge = (nodes: NodeDatum[], edges: EdgeDatum[], edgeId: string): string[] => {\n  const edge = edges.find((edge) => edge.id === edgeId);\n  if (edge) {\n    return [\n      ...new Set(nodes.filter((node) => edge.source === node.id || edge.target === node.id).map((node) => node.id)),\n    ];\n  }\n  return [];\n};\n\n// Returns an array of node ids which are connected to a given node\nexport const findConnectedNodesForNode = (nodes: NodeDatum[], edges: EdgeDatum[], nodeId: string): string[] => {\n  const node = nodes.find((node) => node.id === nodeId);\n  if (node) {\n    const linkedEdges = edges.filter((edge) => edge.source === node.id || edge.target === node.id);\n    return [\n      ...new Set(\n        linkedEdges.flatMap((edge) =>\n          nodes.filter((n) => edge.source === n.id || edge.target === n.id).map((n) => n.id)\n        )\n      ),\n    ];\n  }\n  return [];\n};\n\nexport const getGraphFrame = (frames: DataFrame[]) => {\n  return frames.reduce<GraphFrame>(\n    (acc, frame) => {\n      const sourceField = frame.fields.filter((f) => f.name === 'source');\n      if (frame.name === 'edges' || sourceField.length) {\n        acc.edges.push(frame);\n      } else {\n        acc.nodes.push(frame);\n      }\n      return acc;\n    },\n    { edges: [], nodes: [] }\n  );\n};\n"],"names":["Edge","EdgeLabel","Legend","_a","_b","Marker","Node","Nodes","Edges","EdgeLabels","showConfig","builder","node","edgesMap","nodesMap","state","position","nodes","field","edge"],"sourceRoot":""}