(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["geomapPanel"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/ol-ext/dist/ol-ext.css":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAACE1BMVEX///8A//8AgICA//8AVVVAQID///8rVVVJtttgv98nTmJ2xNgkW1ttyNsmWWZmzNZYxM4gWGgeU2JmzNNr0N1Rwc0eU2VXxdEhV2JqytQeVmMhVmNoydUfVGUgVGQfVGQfVmVqy9hqy9dWw9AfVWRpydVry9YhVmMgVGNUw9BrytchVWRexdGw294gVWQgVmUhVWPd4N6HoaZsy9cfVmQgVGRrytZsy9cgVWQgVWMgVWRsy9YfVWNsy9YgVWVty9YgVWVry9UgVWRsy9Zsy9UfVWRsy9YgVWVty9YgVWRty9Vsy9aM09sgVWRTws/AzM0gVWRtzNYgVWRuy9Zsy9cgVWRGcHxty9bb5ORbxdEgVWRty9bn6OZTws9mydRfxtLX3Nva5eRix9NFcXxOd4JPeINQeIMiVmVUws9Vws9Vw9BXw9BYxNBaxNBbxNBcxdJexdElWWgmWmhjyNRlx9IqXGtoipNpytVqytVryNNrytZsjZUuX210k5t1y9R2zNR3y9V4lp57zth9zdaAnKOGoaeK0NiNpquV09mesrag1tuitbmj1tuj19uktrqr2d2svcCu2d2xwMO63N+7x8nA3uDC3uDFz9DK4eHL4eLN4eIyYnDX5OM5Z3Tb397e4uDf4uHf5uXi5ePi5+Xj5+Xk5+Xm5+Xm6OY6aHXQ19fT4+NfhI1Ww89gx9Nhx9Nsy9ZWw9Dpj2abAAAAWnRSTlMAAQICAwQEBgcIDQ0ODhQZGiAiIyYpKywvNTs+QklPUlNUWWJjaGt0dnd+hIWFh4mNjZCSm6CpsbW2t7nDzNDT1dje5efr7PHy9PT29/j4+Pn5+vr8/f39/f6DPtKwAAABTklEQVR4Xr3QVWPbMBSAUTVFZmZmhhSXMjNvkhwqMzMzMzPDeD+xASvObKePPa+ffHVl8PlsnE0+qPpBuQjVJjno6pZpSKXYl7/bZyFaQxhf98hHDKEppwdWIW1frFnrxSOWHFfWesSEWC6R/P4zOFrix3TzDFLlXRTR8c0fEEJ1/itpo7SVO9Jdr1DVxZ0USyjZsEY5vZfiiAC0UoTGOrm9PZLuRl8X+Dq1HQtoFbJZbv61i+Poblh/97TC7n0neCcK0ETNUrz1/xPHf+DNAW9Ac6t8O8WH3Vp98f5lCaYKAOFZMLyHL4Y0fe319idMNgMMp+zWVSybUed/+/h7I4wRAG1W6XDy4XmjR9HnzvDRZXUAYDFOhC1S/Hh+fIXxen+eO+AKqbs+wAo30zDTDvDxKoJN88sjUzDFAvBzEUGFsnADoIvAJzoh2BZ8sner+Ke/vwECuQAAAABJRU5ErkJggg=="), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.ol-control i {
  cursor: default;
}

/* Bar style */
.ol-control.ol-bar {
  left: 50%;
  min-height: 1em;
  min-width: 1em;
  position: absolute;
  top: 0.5em;
  transform: translate(-50%,0);
  -webkit-transform: translate(-50%,0);
  white-space: nowrap;
}

/* Hide subbar when not inserted in a parent bar */
.ol-control.ol-toggle .ol-option-bar {
  display: none;
}

/* Default position for controls */
.ol-control.ol-bar .ol-bar {
  position: static;
}
.ol-control.ol-bar .ol-control {
  position: relative;
  top: auto;
  left:auto;
  right:auto;
  bottom: auto;
  display: inline-block;
  vertical-align: middle;
  background-color: transparent;
  padding: 0;
  margin: 0;
  transform: none;
  -webkit-transform: none;
}
.ol-control.ol-bar .ol-bar {
  position: static;
}
.ol-control.ol-bar .ol-control button {
  margin:2px 1px;
  outline: none;
}

/* Positionning */
.ol-control.ol-bar.ol-left {
  left: 0.5em;
  top: 50%;
  -webkit-transform: translate(0px, -50%);
          transform: translate(0px, -50%);
}
.ol-control.ol-bar.ol-left .ol-control {
  display: block;
}

.ol-control.ol-bar.ol-right {
  left: auto;
  right: 0.5em;
  top: 50%;
  -webkit-transform: translate(0px, -50%);
          transform: translate(0px, -50%);
}
.ol-control.ol-bar.ol-right .ol-control {
  display: block;
}

.ol-control.ol-bar.ol-bottom {
  top: auto;
  bottom: 0.5em;
}

.ol-control.ol-bar.ol-top.ol-left,
.ol-control.ol-bar.ol-top.ol-right {
  top: 4.5em;
  -webkit-transform:none;
          transform:none;
}
.ol-touch .ol-control.ol-bar.ol-top.ol-left,
.ol-touch .ol-control.ol-bar.ol-top.ol-right {
  top: 5.5em;
}
.ol-control.ol-bar.ol-bottom.ol-left,
.ol-control.ol-bar.ol-bottom.ol-right {
  top: auto;
  bottom: 0.5em;
  -webkit-transform:none;
          transform:none;
}

/* Group buttons */
.ol-control.ol-bar.ol-group {
  margin: 1px 1px 1px 0;
}
.ol-control.ol-bar.ol-right .ol-group,
.ol-control.ol-bar.ol-left .ol-group {
  margin: 1px 1px 0 1px;
}

.ol-control.ol-bar.ol-group button {
  border-radius:0;
  margin: 0 0 0 1px;
}
.ol-control.ol-bar.ol-right.ol-group button,
.ol-control.ol-bar.ol-left.ol-group button,
.ol-control.ol-bar.ol-right .ol-group button,
.ol-control.ol-bar.ol-left .ol-group button {
  margin: 0 0 1px 0;
}
.ol-control.ol-bar.ol-group .ol-control:first-child > button {
  border-radius: 5px 0 0 5px;
}
.ol-control.ol-bar.ol-group .ol-control:last-child > button {
  border-radius: 0 5px 5px 0;
}
.ol-control.ol-bar.ol-left.ol-group .ol-control:first-child > button,
.ol-control.ol-bar.ol-right.ol-group .ol-control:first-child > button,
.ol-control.ol-bar.ol-left .ol-group .ol-control:first-child > button,
.ol-control.ol-bar.ol-right .ol-group .ol-control:first-child > button {
  border-radius: 5px 5px 0 0;
}
.ol-control.ol-bar.ol-left.ol-group .ol-control:last-child > button,
.ol-control.ol-bar.ol-right.ol-group .ol-control:last-child > button,
.ol-control.ol-bar.ol-left .ol-group .ol-control:last-child > button,
.ol-control.ol-bar.ol-right .ol-group .ol-control:last-child > button {
  border-radius: 0 0 5px 5px;
}

/* */
.ol-control.ol-bar .ol-rotate {
  opacity:1;
  visibility: visible;
}
.ol-control.ol-bar .ol-rotate button {
  display: block
}

/* Active buttons */
.ol-control.ol-bar .ol-toggle.ol-active > button,
.ol-control.ol-bar .ol-toggle.ol-active button:hover {
  background-color: #00AAFF;
  color: #fff;
}
.ol-control.ol-toggle button:disabled {
  background-color: #ccc;
}

/* Subbar toolbar */
.ol-control.ol-bar .ol-control.ol-option-bar {
  display: none;
  position:absolute;
  top:100%;
  left:0;
  margin: 5px 0;
  border-radius: 0;
  background-color: rgba(255,255,255, 0.8);
  /* border: 1px solid rgba(0, 60, 136, 0.5); */
  -webkit-box-shadow: 0 0 0 1px rgba(0, 60, 136, 0.5), 1px 1px 2px rgba(0, 0, 0, 0.5);
          box-shadow: 0 0 0 1px rgba(0, 60, 136, 0.5), 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.ol-control.ol-bar .ol-option-bar:before {
  content: "";
  border: 0.5em solid transparent;
  border-color: transparent transparent rgba(0, 60, 136, 0.5);
  position: absolute;
  bottom: 100%;
  left: 0.3em;
  pointer-events: none;
}

.ol-control.ol-bar .ol-option-bar .ol-control {
  display: table-cell;
}
.ol-control.ol-bar .ol-control .ol-bar
{	display: none;
}
.ol-control.ol-bar .ol-control.ol-active > .ol-option-bar {
  display: block;
}

.ol-control.ol-bar .ol-control.ol-collapsed ul {
  display: none;
}

.ol-control.ol-bar .ol-control.ol-text-button > div:hover,
.ol-control.ol-bar .ol-control.ol-text-button > div {
  background-color: transparent;
  color: rgba(0, 60, 136, 0.5);
  width: auto;
  min-width: 1.375em;
  margin: 0;
}

.ol-control.ol-bar .ol-control.ol-text-button {
  font-size:0.9em;
  border-left: 1px solid rgba(0, 60, 136, 0.8);
  border-radius: 0;
}
.ol-control.ol-bar .ol-control.ol-text-button:first-child {
  border-left:0;
}
.ol-control.ol-bar .ol-control.ol-text-button > div {
  padding: .11em 0.3em;
  font-weight: normal;
  font-size: 1.14em;
  font-family: Arial,Helvetica,sans-serif;
}
.ol-control.ol-bar .ol-control.ol-text-button div:hover {
  color: rgba(0, 60, 136, 1);
}

.ol-control.ol-bar.ol-bottom .ol-option-bar {
  top: auto;
  bottom: 100%;
}
.ol-control.ol-bar.ol-bottom .ol-option-bar:before {
  border-color: rgba(0, 60, 136, 0.5) transparent transparent ;
  bottom: auto;
  top: 100%;
}

.ol-control.ol-bar.ol-left .ol-option-bar {
  left:100%;
  top: 0;
  bottom: auto;
  margin: 0 5px;
}
.ol-control.ol-bar.ol-left .ol-option-bar:before {
  border-color: transparent rgba(0, 60, 136, 0.5) transparent transparent;
  bottom: auto;
  right: 100%;
  left: auto;
  top: 0.3em;
}
.ol-control.ol-bar.ol-right .ol-option-bar {
  right:100%;
  left:auto;
  top: 0;
  bottom: auto;
  margin: 0 5px;
}
.ol-control.ol-bar.ol-right .ol-option-bar:before {
  border-color: transparent transparent transparent rgba(0, 60, 136, 0.5);
  bottom: auto;
  left: 100%;
  top: 0.3em;
}

.ol-control.ol-bar.ol-left .ol-option-bar .ol-option-bar,
.ol-control.ol-bar.ol-right .ol-option-bar .ol-option-bar {
  top: 100%;
  bottom: auto;
  left: 0.3em;
  right: auto;
  margin: 5px 0;
}
.ol-control.ol-bar.ol-right .ol-option-bar .ol-option-bar {
  right: 0.3em;
  left: auto;
}
.ol-control.ol-bar.ol-left .ol-option-bar .ol-option-bar:before,
.ol-control.ol-bar.ol-right .ol-option-bar .ol-option-bar:before {
  border-color: transparent transparent rgba(0, 60, 136, 0.5);
  bottom: 100%;
  top: auto;
  left: 0.3em;
  right: auto;
}
.ol-control.ol-bar.ol-right .ol-option-bar .ol-option-bar:before {
  right: 0.3em;
  left: auto;
}

.ol-control-title {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

.ol-center-position {
  position: absolute;
  bottom: 0;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  background-color: rgba(255,255,255,.8);
  padding: .1em 1em;
}

.ol-compassctrl {
  display: none;
  top: 1em;
  left: auto;
  right: 1em;
}
.ol-compassctrl.ol-visible {
  display: block!important;
}
.ol-ext-dialog {
  position: fixed;
  top: -100%;
  left: 0;
  width: 150%;
  height: 100%;
  opacity: 0;
  background-color: rgba(0,0,0,.5);
  z-index: 1000;
  pointer-events: none!important;
  -webkit-transition: opacity .2s, top 0s .2s;
  transition: opacity .2s, top 0s .2s;
}
.ol-ext-dialog.ol-visible {
  opacity: 1;
  top: 0;
  pointer-events: all!important;
  -webkit-transition: opacity .2s, top 0s;
  transition: opacity .2s, top 0s;
}

.ol-viewport .ol-ext-dialog {
  position: absolute;
}
.ol-ext-dialog > form > h2 {
  margin: 0 .5em .5em 0;
  display: none;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.ol-ext-dialog > form.ol-title > h2 {
  display: block;
}
.ol-ext-dialog > form {
  position: absolute;
  top: 0;
  left: 33.33%;
  min-width: 5em;
  max-width: 60%;
  min-height: 3em;
  max-height: 100%;
  background-color: #fff;
  border: 1px solid #333;
  -webkit-box-shadow: 3px 3px 4px rgba(0,0,0, 0.5);
          box-shadow: 3px 3px 4px rgba(0,0,0, 0.5);
  -webkit-transform: translate(-50%, -30%);
          transform: translate(-50%, -30%);
  -webkit-transition: top .2s, -webkit-transform .2s;
  transition: top .2s, -webkit-transform .2s;
  transition: top .2s, transform .2s;
  transition: top .2s, transform .2s, -webkit-transform .2s;
  padding: 1em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  overflow-x: hidden;
  overflow-y: auto;
}
.ol-ext-dialog > form.ol-closebox {
  padding-top: 1.5em;
}
.ol-ext-dialog > form.ol-title {
  padding-top: 1em;
}
.ol-ext-dialog > form.ol-button {
  padding-bottom: .5em;
}

.ol-ext-dialog.ol-zoom > form {
  top: 30%;
  -webkit-transform: translate(-50%, -30%) scale(0);
          transform: translate(-50%, -30%) scale(0);
}
.ol-ext-dialog.ol-visible > form {
  top: 30%;
}
.ol-ext-dialog.ol-zoom.ol-visible > form {
  -webkit-transform: translate(-50%, -30%) scale(1);
          transform: translate(-50%, -30%) scale(1);
}

.ol-ext-dialog > form .ol-content {
  overflow-x: hidden;
  overflow-y: auto;
}

.ol-ext-dialog > form .ol-closebox {
  position: absolute;
  top: .5em;
  right: .5em;
  width: 1em;
  height: 1em;
  cursor: pointer;
  display: none;
}
.ol-ext-dialog > form.ol-closebox .ol-closebox {
  display: block;
}
.ol-ext-dialog > form .ol-closebox:before,
.ol-ext-dialog > form .ol-closebox:after {
  content: "";
  position: absolute;
  background-color: currentColor;
  top: 50%;
  left: 50%;
  width: 1em;
  height: .1em;
  border-radius: .1em;
  -webkit-transform: translate(-50%, -50%) rotate(45deg);
          transform: translate(-50%, -50%) rotate(45deg);
}
.ol-ext-dialog > form .ol-closebox:before {
  -webkit-transform: translate(-50%, -50%) rotate(-45deg);
          transform: translate(-50%, -50%) rotate(-45deg);
}

.ol-ext-dialog > form .ol-buttons {
  text-align: right;
  overflow-x: hidden;
}
.ol-ext-dialog > form .ol-buttons input {
  margin-top: .5em;
  padding: .5em;
  background: none;
  border: 0;
  font-size: 1em;
  color: rgba(0,60,136,1);
  cursor: pointer;
  border-radius: .25em;
  outline-width: 0;
}
.ol-ext-dialog > form .ol-buttons input:hover {
  background-color:  rgba(0,60,136,.1);
}
.ol-ext-dialog > form .ol-buttons input[type=submit] {
  font-weight: bold;
}

.ol-ext-dialog .ol-progress-message {
  font-size: .9em;
  text-align: center;
  padding-bottom: .5em;
}
.ol-ext-dialog .ol-progress-bar {
  border: 1px solid #369;
  width: 20em;
  height: 1em;
  max-width: 100%;
  padding: 2px;
  margin: .5em auto 0;
  overflow: hidden;
}
.ol-ext-dialog .ol-progress-bar > div {
  background: #369;
  height: 100%;
  width: 50%;
  -webkit-transition: width .3s;
  transition: width .3s;
}
.ol-ext-dialog .ol-progress-bar > div.notransition {
  -webkit-transition: unset;
  transition: unset;
}

/* full screen */
.ol-ext-dialog.ol-fullscreen-dialog form {
  top: 1em;
  -webkit-transform: none;
          transform: none;
  left: 1em;
  bottom: 1em;
  right: 1em;
  max-width: calc(66.6% - 2em);
  text-align: center;
  background: transparent;
  -webkit-box-shadow: none;
          box-shadow: none;
  border: none;
  color: #fff;
}
.ol-ext-dialog.ol-fullscreen-dialog form .ol-closebox {
  top: 0;
  right: 0;
  font-size: 2em;
}
.ol-ext-dialog.ol-fullscreen-dialog .ol-closebox:before,
.ol-ext-dialog.ol-fullscreen-dialog .ol-closebox:after {
  border: .1em solid currentColor;
}
.ol-ext-dialog.ol-fullscreen-dialog img,
.ol-ext-dialog.ol-fullscreen-dialog video {
  max-width: 100%;
}

/* Fullscreen dialog */
body > .ol-ext-dialog .ol-content {
  max-height: calc(100vh - 10em);
}

body > .ol-ext-dialog > form {
  overflow: visible;
}
.ol-editbar .ol-button button {
  position: relative;
  display: inline-block;
  font-style: normal;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  vertical-align: middle;
}
.ol-editbar .ol-button button:before, 
.ol-editbar .ol-button button:after {
  content: "";
  border-width: 0;
  position: absolute;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  background-color: currentColor;
}
.ol-editbar .ol-button button:focus {
  outline: none;
}

.ol-editbar .ol-selection > button:before {
  width: .6em;
  height: 1em;
  background-color: transparent;
  border: .5em solid currentColor;
  border-width: 0 .25em .65em;
  border-color: currentColor transparent;
  -webkit-box-shadow:0 0.6em 0 -0.23em;
          box-shadow:0 0.6em 0 -0.23em;
  top: .35em;
  left: .5em;
  -webkit-transform: translate(-50%, -50%) rotate(-30deg);
          transform: translate(-50%, -50%) rotate(-30deg);
}
.ol-editbar .ol-selection0 > button:after {
  width: .28em;
  height: .6em;
  background-color: transparent;
  border: .5em solid currentColor;
  border-width: 0 .05em .7em;
  border-color: currentColor transparent;
  top: .5em;
  left: .7em;
  -webkit-transform: rotate(-45deg);
          transform: rotate(-45deg);
}

.ol-editbar .ol-delete button:after,
.ol-editbar .ol-delete button:before {
  width: 1em;
  height: .2em;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) rotate(45deg);
          transform: translate(-50%, -50%) rotate(45deg);
}
.ol-editbar .ol-delete button:after {
  -webkit-transform: translate(-50%, -50%) rotate(-45deg);
          transform: translate(-50%, -50%) rotate(-45deg);
}

.ol-editbar .ol-info button:before {
  width: .25em;
  height: .6em;
  border-radius: .03em;
  top: .47em;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
}
.ol-editbar .ol-info button:after {
  width: .25em;
  height: .2em;
  border-radius: .03em;
  -webkit-box-shadow: -0.1em 0.35em, -0.1em 0.82em, 0.1em 0.82em;
          box-shadow: -0.1em 0.35em, -0.1em 0.82em, 0.1em 0.82em;
  top: .12em;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
}

.ol-editbar .ol-drawpoint button:before {
  width: .7em;
  height: .7em;
  border-radius: 50%;
  border: .15em solid currentColor;
  background-color: transparent;
  top: .2em;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
}
.ol-editbar .ol-drawpoint button:after {
  width: .4em;
  height: .4em;
  border: .15em solid currentColor;
  border-color: currentColor transparent;
  border-width: .4em .2em 0;
  background-color: transparent;
  top: .8em;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
}

.ol-editbar .ol-drawline > button:before,
.ol-editbar .ol-drawpolygon > button:before,
.ol-editbar .ol-drawhole > button:before {
  width: .8em;
  height: .8em;
  border: .13em solid currentColor;
  background-color: transparent;
  border-width: .2em .13em .09em;
  top: .2em;
  left: .25em;
  -webkit-transform: rotate(10deg) perspective(1em) rotateX(40deg);
          transform: rotate(10deg) perspective(1em) rotateX(40deg);
}
.ol-editbar .ol-drawline > button:before {
  border-bottom: 0;
}
.ol-editbar .ol-drawline > button:after,
.ol-editbar .ol-drawhole > button:after,
.ol-editbar .ol-drawpolygon > button:after {
  width: .3em;
  height: .3em;
  top: 0.2em;
  left: .25em;
  -webkit-box-shadow: -0.2em 0.55em, 0.6em 0.1em, 0.65em 0.7em;
          box-shadow: -0.2em 0.55em, 0.6em 0.1em, 0.65em 0.7em;
}
.ol-editbar .ol-drawhole > button:after {
  -webkit-box-shadow: -0.2em 0.55em, 0.6em 0.1em, 0.65em 0.7em, 0.25em 0.35em;
          box-shadow: -0.2em 0.55em, 0.6em 0.1em, 0.65em 0.7em, 0.25em 0.35em;
}


.ol-editbar .ol-offset > button i,
.ol-editbar .ol-transform > button i {
  position: absolute;
  width: .9em;
  height: .9em;
  overflow: hidden;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-editbar .ol-offset > button i{
  width: .8em;
  height: .8em;
}

.ol-editbar .ol-offset > button i:before,
.ol-editbar .ol-transform > button i:before,
.ol-editbar .ol-transform > button i:after {
  content: "";
  height: 1em;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) rotate(45deg);
          transform: translate(-50%, -50%) rotate(45deg);
  -webkit-box-shadow: 0.5em 0 0 0.1em, -0.5em 0 0 0.1em;
          box-shadow: 0.5em 0 0 0.1em, -0.5em 0 0 0.1em;
  width: .1em;
  position: absolute;
  background-color: currentColor;
}
.ol-editbar .ol-offset > button i:before{
  -webkit-box-shadow: 0.45em 0 0 0.1em, -0.45em 0 0 0.1em;
          box-shadow: 0.45em 0 0 0.1em, -0.45em 0 0 0.1em;
}
.ol-editbar .ol-transform > button i:after {
  -webkit-transform: translate(-50%, -50%) rotate(-45deg);
          transform: translate(-50%, -50%) rotate(-45deg);
}

.ol-editbar .ol-split > button:before {
  width: .3em;
  height: .3em;
  top: .81em;
  left: .75em;
  border-radius: 50%;
  -webkit-box-shadow: 0.1em -0.4em, -0.15em -0.25em;
          box-shadow: 0.1em -0.4em, -0.15em -0.25em;
}
.ol-editbar .ol-split > button:after {
  width: .8em;
  height: .8em;
  top: .15em;
  left: -.1em;
  border: .1em solid currentColor;
  border-width: 0 .2em .2em 0;
  background-color: transparent;
  border-radius: .1em;
  -webkit-transform: rotate(20deg) scaleY(.6) rotate(-45deg);
          transform: rotate(20deg) scaleY(.6) rotate(-45deg);
}

.ol-editbar .ol-drawregular > button:before {
  width: .9em;
  height: .9em;
  top: 50%;
  left: 50%;
  border: .1em solid currentColor;
  background-color: transparent;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-editbar .ol-drawregular .ol-bar .ol-text-button > div > div > div {
  border: .5em solid currentColor;
  border-color: transparent currentColor;
  display: inline-block;
  cursor: pointer;
  vertical-align: text-bottom;
}
.ol-editbar .ol-drawregular .ol-bar:before,
.ol-control.ol-bar.ol-editbar .ol-drawregular .ol-bar {
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
}
.ol-editbar .ol-drawregular .ol-bar .ol-text-button {
  min-width: 6em;
  text-align: center;
}
.ol-editbar .ol-drawregular .ol-bar .ol-text-button > div > div > div:first-child {
  border-width: .5em .5em .5em 0;
  margin: 0 .5em 0 0;
}
.ol-editbar .ol-drawregular .ol-bar .ol-text-button > div > div > div:last-child {
  border-width: .5em 0 .5em .5em;
  margin: 0 0 0 .5em;
}

.ol-feature-list {
  position: relative;
}
.ol-control.ol-feature-list {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
}
.ol-control.ol-feature-list > button:before {
  content: "";
  position: absolute;
  width: 60%;
  height: 50%;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-box-shadow: inset 0 2.5px;
          box-shadow: inset 0 2.5px;  
  background-image: -webkit-gradient(linear, left top, right top, from(currentColor), to(transparent));  
  background-image: linear-gradient(90deg, currentColor, transparent);
}

.ol-control.ol-feature-list.ol-collapsed {
  bottom: .5em;
  left: .5em;
  width: auto;
}
.ol-feature-list .ol-content {
  background-color: #f4f6f8;
  clear: both;
}
.ol-feature-list.ol-collapsed .ol-content > * {
  display: none;
}
.ol-feature-list .ol-header {
  position: relative;
  overflow: hidden;
}
.ol-feature-list.ol-collapsed .ol-header {
  display: block;
}

.ol-control.ol-feature-list > button,
.ol-control.ol-feature-list.ol-collapsed .ol-content {
  display: none;
}
.ol-control.ol-feature-list.ol-collapsed > button {
  display: block;
}

.ol-feature-list .ol-sizer {
  width: 100%;
  height: 1px;
  cursor: row-resize;
  background-color: #ccc;
  position: relative;
  border: 1px solid #f4f6f8;
  border-width: 1px 0;
}
.ol-feature-list.ol-bottom .ol-sizer {
  position: absolute;
  bottom: 0;
}
.ol-feature-list .ol-sizer:before {
  content: "";
  width: 1.5em;
  height: 4px;
  background-color: #ddd;
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  z-index: 1;
  border: 3px solid transparent;
  border-width: 3px 1.5em;
  -webkit-box-shadow: inset 0 -1px #aaa, inset 0 1px #aaa;
          box-shadow: inset 0 -1px #aaa, inset 0 1px #aaa;
  border-radius: 2px;
}
.ol-feature-list .ol-sizer:hover:before {
  background-color: #ccc;
}

.ol-feature-list .ol-content .ol-header p {
  display: inline-block;
  margin: 0.1em .25em;
  vertical-align: middle;
  white-space: nowrap;
  width: calc(100% - 2em);
  text-overflow: ellipsis;
  overflow: hidden;
}
.ol-feature-list .ol-content .ol-header .ol-buttons {
  position: absolute;
  right: 0;
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
}

.ol-feature-list .ol-content .ol-header button {
  position: relative;
  border: 0;
  background: transparent;
  vertical-align: middle;
  width: 1em;
  height: 1em;
  margin: 0 .2em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-feature-list .ol-content .ol-header button.ol-closebox:before,
.ol-feature-list .ol-content .ol-header button.ol-closebox:after {
  content: "";
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%) rotate(45deg);
          transform: translate(-50%, -50%) rotate(45deg);
  background: currentColor;
  width: .1em;
  height: 1em;
  display: block;
  font-style: normal;
}
.ol-feature-list .ol-content .ol-header button.ol-closebox:after {
  -webkit-transform: translate(-50%, -50%) rotate(-45deg);
          transform: translate(-50%, -50%) rotate(-45deg);
}

.ol-feature-list.ol-collapsed .ol-content .ol-header button.ol-closebox {
  border: 1px solid currentColor;
}
.ol-feature-list.ol-collapsed .ol-content .ol-header button.ol-closebox:before {
  -webkit-transform: translate(-50%, -50%) rotate(90deg);
          transform: translate(-50%, -50%) rotate(90deg);
}
.ol-feature-list.ol-collapsed .ol-content .ol-header button.ol-closebox:after {
  display: none;
}

.ol-feature-list .ol-scroll-container {
  overflow: auto;
  height: 10em;
  min-height: 3em;
}
.ol-feature-list .ol-scroll-container:focus {
  outline: unset;
}

.ol-feature-list table {
  background-color: #fff;
  border-collapse: collapse;
  white-space: nowrap;
  position: relative;
}
.ol-feature-list table thead {
  background-color: #f4f6f8;
  position: -webkit-sticky;
  position: sticky;
  top: 0;
  overflow: hidden;
}
/* Fixed height */
.ol-feature-list table tr {
  height: 1.4em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-feature-list table tbody tr:hover {
  background-color: #eee;
  cursor: pointer;
}

.ol-feature-list table tbody tr.ol-selected {
  background-color: #eee;
}

.ol-feature-list table td {
  border: 0 solid #ddd;
  border-width: 0 0 1px 1px;
  overflow: hidden;
  width: 100px;
}
.ol-feature-list table td.number {
  text-align: right;
}
.ol-feature-list table td.undefined {
  text-align: center;
  background-color: #fafafa;
}
.ol-feature-list table tr:hover td,
.ol-feature-list table .ol-selected td {
  background-color: transparent;
}
.ol-feature-list thead td {
  position: relative;
}
.ol-feature-list thead td.sort {
  padding-right: 1.5em;
}

.ol-feature-list thead td p {
  margin: 0;
  display: inline-block;
}
.ol-feature-list table td button {
  position: absolute;
  width: 1.2em;
  height: 1.4em;
  top: 0;
  right: 0;
  margin: .1em 0;
  padding: 0;
  background-color: transparent;
  border: 0;
}
.ol-feature-list thead td button.sort:before {
  content: '⇅';
  font-style: normal;
  font-weight: normal;
  cursor: pointer;
  font-size: 1em;
  line-height: 1em;
}
.ol-feature-list thead td button.sortup:before {
  content: '↧';
}
.ol-feature-list thead td button.sortdown:before {
  content: '↥';
}

.ol-gauge {
  top: 0.5em;
  left: 50%;
  -webkit-transform: translateX(-50%);
  transform: translateX(-50%);
  background-color: rgba(255,255,255,.5);
  padding: 0.1em 0.5em;
}

.ol-gauge > * {
  display: inline-block;
  vertical-align: middle;
}
.ol-gauge > span {
  margin: 0 0.5em 0 0;
}
.ol-gauge > div {
  display: inline-block;
  width: 200px;
  border: 1px solid rgba(0,60,136,.5);
  border-radius: 3px;
  padding:1px;
}
.ol-gauge button {
  height: 0.8em;
  margin:0;
  max-width:100%;
}

.ol-control.ol-bookmark {
  top: 0.5em;
  left: 3em;
  background-color: rgba(255,255,255,.5);
}
.ol-control.ol-bookmark button {
  position: relative;
}
.ol-control.ol-bookmark > button::before {
  content: "";
  position: absolute;
  border-width: 10px 5px 4px;
  border-style: solid;
  border-color: currentColor;
  border-bottom-color: transparent;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
  height: 0;
}


.ol-control.ol-bookmark > div {
  display: block;
  min-width: 5em;
}
.ol-control.ol-bookmark.ol-collapsed > div {
  display: none;
}
.ol-control.ol-bookmark input {
  font-size: 0.9em;
  margin: 0 0.5em 0.5em;
  padding: 0 0.5em;
}
.ol-control.ol-bookmark ul {
  margin: 0 0 0.5em;
  padding: 0;
  list-style: none;
  min-width: 10em;
}
.ol-control.ol-bookmark li {
  color: rgba(0,60,136,0.8);
  font-size: 0.9em;
  padding: 0 0.2em 0 0.5em;
  cursor: default;
  clear:both;
}

.ol-control.ol-bookmark li:hover {
  background-color: rgba(0,60,136,.5);
  color: #fff;
}

.ol-control.ol-bookmark > div button {
  width: 1em;
  height: 0.8em;
  float: right;
  background-color: transparent;
  cursor: pointer;
  border-radius: 0;
}
.ol-control.ol-bookmark > div button:before {
  content: "\\2A2F";
  color: #936;
  font-size: 1.2em;
  line-height: 1em;
  border-radius: 0;
    position: absolute;
    top: 50%;
    left: 50%;
    -webkit-transform: translate(-50%, -50%);
    transform: translate(-50%, -50%);
}

.ol-bookmark ul li button,
.ol-bookmark input {
  display: none;
}
.ol-bookmark.ol-editable ul li button,
.ol-bookmark.ol-editable input {
  display: block;
}


.ol-control.ol-geobt {
  top: auto;
  left: auto;
  right: .5em;
  bottom: 3em;
}
.ol-touch .ol-control.ol-geobt {
  bottom: 3.5em;
}
.ol-control.ol-geobt button:before {
  content: "";
  position: absolute;
  background: transparent;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  border: .16em solid currentColor;
  width: .4em;
  height: .4em;
  border-radius: 50%;
}
.ol-control.ol-geobt button:after {
  content: "";
  position: absolute;
  width: .2em;
  height: .2em;
  background: transparent;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-box-shadow: .42em 0, -.42em 0, 0 .42em, 0 -.42em;
          box-shadow: .42em 0, -.42em 0, 0 .42em, 0 -.42em;
}

.ol-control.ol-bar.ol-geobar .ol-control {
	display: inline-block;
	vertical-align: middle;
}

.ol-control.ol-bar.ol-geobar .ol-bar {
  display: none;
}
.ol-bar.ol-geobar.ol-active .ol-bar {
  display: inline-block;
}

.ol-bar.ol-geobar .geolocBt button:before,
.ol-bar.ol-geobar .geolocBt button:after {
  content: "";
  display: block;
  position: absolute;
  border: 1px solid transparent;
  border-width: 0.3em 0.8em 0 0.2em;
  border-color: currentColor transparent transparent;
  -webkit-transform: rotate(-30deg);
  transform: rotate(-30deg);
  top: .45em;
  left: 0.15em;
  font-size: 1.2em;
}
.ol-bar.ol-geobar .geolocBt button:after {
  border-width: 0 0.8em .3em 0.2em;
  border-color: transparent transparent currentColor;
	-webkit-transform: rotate(-61deg);
	transform: rotate(-61deg);
}

.ol-bar.ol-geobar .startBt button:before {
  content: "";
  display: block;
  position: absolute;
  width: 1em;
  height: 1em;
  background-color: #800;
  border-radius: 50%;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%,-50%);
  transform: translate(-50%,-50%);
}
.ol-bar.ol-geobar .pauseBt button:before,
.ol-bar.ol-geobar .pauseBt button:after {
  content: "";
  display: block;
  position: absolute;
  width: .25em;
  height: 1em;
  background-color: currentColor;
  top: 50%;
  left: 35%;
  -webkit-transform: translate(-50%,-50%);
  transform: translate(-50%,-50%);
}
.ol-bar.ol-geobar .pauseBt button:after {
  left: 65%;
}

.ol-control.ol-bar.ol-geobar .centerBt,
.ol-control.ol-bar.ol-geobar .pauseBt,
.ol-bar.ol-geobar.pauseTrack .startBt,
.ol-bar.ol-geobar.centerTrack .startBt,
.ol-bar.ol-geobar.centerTrack.pauseTrack .pauseBt,
.ol-bar.ol-geobar.centerTrack .pauseBt {
  display: none;
}
.ol-bar.ol-geobar.pauseTrack .pauseBt,
.ol-bar.ol-geobar.centerTrack .centerBt{
  display: inline-block;
}

.ol-control.ol-globe
{	position: absolute;
	left: 0.5em;
	bottom: 0.5em;
	border-radius: 50%;
	opacity: 0.7;
	transform: scale(0.5);
	transform-origin: 0 100%;
	-webkit-transform: scale(0.5);
	-webkit-transform-origin: 0 100%;
}
.ol-control.ol-globe:hover
{	opacity: 0.9;
}

.ol-control.ol-globe .panel
{	display:block;
	width:170px;
	height:170px;
	background-color:#fff;
	cursor: pointer;
	border-radius: 50%;
	overflow: hidden;
	-webkit-box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.5);
	        box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.5);
}
.ol-control.ol-globe .panel .ol-viewport
{	border-radius: 50%;
}

.ol-control.ol-globe .ol-pointer
{	display: block;
	background-color: #fff;
	width:10px;
	height: 10px;
	border:10px solid red;
	position: absolute;
	top: 50%;
	left:50%;
	transform: translate(-15px, -40px);
	-webkit-transform: translate(-15px, -40px);
	border-radius: 50%;
	z-index:1;
	transition: opacity 0.15s, top 0s, left 0s;
	-webkit-transition: opacity 0.15s, top 0s, left 0s;
}
.ol-control.ol-globe .ol-pointer.hidden
{	opacity:0;
	transition: opacity 0.15s, top 3s, left 5s;
	-webkit-transition: opacity 0.15s, top 3s, left 5s;
}

.ol-control.ol-globe .ol-pointer::before
{	border-radius: 50%;
	-webkit-box-shadow: 6px 6px 10px 5px #000;
	        box-shadow: 6px 6px 10px 5px #000;
	content: "";
	display: block;
	height: 0;
	left: 0;
	position: absolute;
	top: 23px;
	width: 0;
}
.ol-control.ol-globe .ol-pointer::after
{	content:"";
	width:0;
	height:0;
	display: block;
	position: absolute;
	border-width: 20px 10px 0;
	border-color: red transparent;
	border-style: solid;
	left: -50%;
	top: 100%;
}

.ol-control.ol-globe .panel::before {
  border-radius: 50%;
  -webkit-box-shadow: -20px -20px 80px 2px rgba(0, 0, 0, 0.7) inset;
          box-shadow: -20px -20px 80px 2px rgba(0, 0, 0, 0.7) inset;
  content: "";
  display: block;
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
  z-index: 1;
}
.ol-control.ol-globe .panel::after {
  border-radius: 50%;
  -webkit-box-shadow: 0 0 20px 7px rgba(255, 255, 255, 1);
          box-shadow: 0 0 20px 7px rgba(255, 255, 255, 1);
  content: "";
  display: block;
  height: 0;
  left: 23%;
  position: absolute;
  top: 20%;
  -webkit-transform: rotate(-40deg);
          transform: rotate(-40deg);
  width: 20%;
  z-index: 1;
}


.ol-control.ol-globe.ol-collapsed .panel
{	display:none;
}

.ol-control-top.ol-globe
{	bottom: auto;
	top: 5em;
	transform-origin: 0 0;
	-webkit-transform-origin: 0 0;
}
.ol-control-right.ol-globe
{	left: auto;
	right: 0.5em;
	transform-origin: 100% 100%;
	-webkit-transform-origin: 100% 100%;
}
.ol-control-right.ol-control-top.ol-globe
{	left: auto;
	right: 0.5em;
	transform-origin: 100% 0;
	-webkit-transform-origin: 100% 0;
}

.ol-gridreference
{	background: #fff;
	border: 1px solid #000;
	overflow: auto;
	max-height: 100%;
	top:0;
	right:0;
}
.ol-gridreference input
{	width:100%;
}
.ol-gridreference ul
{	margin:0;
	padding:0;
	list-style: none;
} 
.ol-gridreference li
{	padding: 0 0.5em;
	cursor: pointer;
}
.ol-gridreference ul li:hover 
{	background-color: #ccc;
}
.ol-gridreference li.ol-title,
.ol-gridreference li.ol-title:hover
{	background:rgba(0,60,136,.5);
	color:#fff;
	cursor:default;
}
.ol-gridreference ul li .ol-ref
{	margin-left: 0.5em;
}
.ol-gridreference ul li .ol-ref:before
{	content:"(";
}
.ol-gridreference ul li .ol-ref:after
{	content:")";
}

.ol-control.ol-imageline {
  bottom:0;
  left: 0;
  right: 0;
  padding: 0;
  overflow: visible;
  -webkit-transition: .3s;
  transition: .3s;
  border-radius: 0;
}
.ol-control.ol-imageline.ol-collapsed {
  -webkit-transform: translateY(100%);
          transform: translateY(100%);
}
.ol-imageline > div {
  height: 4em;
  position: relative;
  white-space: nowrap;
  scroll-behavior: smooth;
  overflow: hidden;
  width: 100%;
}
.ol-imageline > div.ol-move {
  scroll-behavior: unset;
}

.ol-control.ol-imageline button {
  position: absolute;
  top: -1em;
  -webkit-transform: translateY(-100%);
          transform: translateY(-100%);
  margin: .65em;
  -webkit-box-shadow: 0 0 0 0.15em rgba(255,255,255,.4);
          box-shadow: 0 0 0 0.15em rgba(255,255,255,.4);
}
.ol-control.ol-imageline button:before {
  content: '';
  position: absolute;
  -webkit-transform: translate(-50%, -50%) rotate(135deg);
          transform: translate(-50%, -50%) rotate(135deg);
  top: 40%;
  left: 50%;
  width: .4em;
  height: .4em;
  border: .1em solid currentColor;
  border-width: .15em .15em 0 0;
}
.ol-control.ol-imageline.ol-collapsed button:before {
  top: 60%;
  -webkit-transform: translate(-50%, -50%) rotate(-45deg);
          transform: translate(-50%, -50%) rotate(-45deg);
}

.ol-imageline,
.ol-imageline:hover {
  background-color: rgba(0,0,0,.75);
}

.ol-imageline.ol-arrow:after,
.ol-imageline.ol-arrow:before {
  content: "";
  position: absolute;
  top: 50%;
  left: .2em;
  border-color: #fff #000;
  border-width: 1em .6em 1em 0;
  border-style: solid;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
  z-index: 1;
  opacity: .8;
  pointer-events: none;
  -webkit-box-shadow: -0.6em 0 0 1em #fff;
          box-shadow: -0.6em 0 0 1em #fff;
}
.ol-imageline.ol-arrow:after {
  border-width: 1em 0 1em .6em;
  left: auto;
  right: .2em;
  -webkit-box-shadow: 0.6em 0 0 1em #fff;
          box-shadow: 0.6em 0 0 1em #fff;
}
.ol-imageline.ol-scroll0.ol-arrow:before {
  display: none;
}
.ol-imageline.ol-scroll1.ol-arrow:after {
  display: none;
}


.ol-imageline .ol-image {
  position: relative;
  height: 100%;
  display: inline-block;
  cursor: pointer;
}
.ol-imageline img {
  max-height: 100%;
  border: .25em solid transparent;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  opacity: 0;
  -webkit-transition: 1s;
  transition: 1s;
}
.ol-imageline img.ol-loaded {
  opacity:1;
}

.ol-imageline .ol-image.select {
  background-color: #fff;
}
.ol-imageline .ol-image span {
  position: absolute;
  width: 125%;
  max-height: 2.4em;
  left: 50%;
  bottom: 0;
  display: none;
  color: #fff;
  background-color: rgba(0,0,0,.5);
  font-size: .8em;
  overflow: hidden;
  white-space: normal;
  text-align: center;
  line-height: 1.2em;
  -webkit-transform: translateX(-50%) scaleX(.8);
          transform: translateX(-50%) scaleX(.8);
}
/*
.ol-imageline .ol-image.select span,
*/
.ol-imageline .ol-image:hover span {
  display: block;
}

.ol-control.ol-routing.ol-isochrone .ol-method-time,
.ol-control.ol-routing.ol-isochrone .ol-method-distance,
.ol-control.ol-routing.ol-isochrone > button {
  position: relative;
}
.ol-control.ol-routing.ol-isochrone .ol-method-time:before,
.ol-control.ol-routing.ol-isochrone > button:before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  border: .1em solid currentColor;
  width: .8em;
  height: .8em;
  border-radius: 50%;
  -webkit-box-shadow: 0 -0.5em 0 -0.35em, 0.4em -0.35em 0 -0.35em;
          box-shadow: 0 -0.5em 0 -0.35em, 0.4em -0.35em 0 -0.35em;
  clip: unset;
}
.ol-control.ol-routing.ol-isochrone .ol-method-time:after,
.ol-control.ol-routing.ol-isochrone > button:after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) rotate(-60deg);
          transform: translate(-50%, -50%) rotate(-60deg);
  border-radius: 50%;
  border: .3em solid transparent;
  border-right-color: currentColor;
  -webkit-box-shadow: none;
          box-shadow: none;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  clip: unset;
}

.ol-control.ol-routing.ol-isochrone .ol-method-distance:before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) rotate(-30deg);
          transform: translate(-50%, -50%) rotate(-30deg);
  width: 1em;
  height: .5em;
  border: .1em solid currentColor;
  -webkit-box-sizing: border-box;
          box-sizing: border-box
}
.ol-control.ol-routing.ol-isochrone .ol-method-distance:after {
  content: '';
  position: absolute;
  width: .1em;
  height: .15em;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) rotate(-30deg);
          transform: translate(-50%, -50%) rotate(-30deg);
  -webkit-box-shadow: inset 0 -0.15em, 0 0.1em, 0.25em 0.1em, -0.25em 0.1em;
          box-shadow: inset 0 -0.15em, 0 0.1em, 0.25em 0.1em, -0.25em 0.1em;
}

.ol-control.ol-routing.ol-isochrone .ol-direction-direct:before,
.ol-control.ol-routing.ol-isochrone .ol-direction-reverse:before {
  content: '';
  position: absolute;
  top: 50%;
  left: 30%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  width: .3em;
  height: .3em;
  border-radius: 50%;
  border: .1em solid currentColor;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  -webkit-box-shadow: 0.25em 0 0 -0.05em;
          box-shadow: 0.25em 0 0 -0.05em;
}
.ol-control.ol-routing.ol-isochrone .ol-direction-direct:after,
.ol-control.ol-routing.ol-isochrone .ol-direction-reverse:after {
  content: '';
  position: absolute;
  top: 50%;
  left: 70%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  border: .4em solid transparent;
  border-width: .4em 0 .4em .4em;
  border-color: transparent currentColor;
}
.ol-control.ol-routing.ol-isochrone .ol-direction-reverse:after {
  border-width: .4em .4em .4em 0;
}

.ol-control.ol-isochrone.ol-collapsed .content {
  display: none;
}
.ol-control.ol-isochrone input[type="number"] {
  width: 3em;
  text-align: right;
  margin: 0 .1em;
}
.ol-control.ol-isochrone .ol-distance input[type="number"] {
  width: 5em;
}

.ol-isochrone .ol-time,
.ol-isochrone .ol-distance {
  display: none;
}
.ol-isochrone .ol-time.selected,
.ol-isochrone .ol-distance.selected {
  display: block;
}

.ol-control.ol-layerswitcher-popup {
  position: absolute;
  right: 0.5em;
  text-align: left;
  top: 3em;
}
.ol-control.ol-layerswitcher-popup .panel {
  clear:both;
  background:#fff;
}

.ol-layerswitcher-popup .panel {
  list-style: none;
  padding: 0.25em;
  margin:0;
  overflow: hidden;
}

.ol-layerswitcher-popup .panel ul {
  list-style: none;
  padding: 0 0 0 20px;
  overflow: hidden;
}

.ol-layerswitcher-popup.ol-collapsed .panel {
  display:none;
}
.ol-layerswitcher-popup.ol-forceopen .panel {
  display:block;
}

.ol-layerswitcher-popup button  {
  background-color: white;
  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
  background-position: center;
  background-repeat: no-repeat;
  float: right;
  height: 38px;
  width: 38px;
}

.ol-layerswitcher-popup li {
  color:#369;
  padding:0.25em 1em;
  font-family:"Trebuchet MS",Helvetica,sans-serif;
  cursor:pointer;
}
.ol-layerswitcher-popup li.ol-header {
  display: none;
}
.ol-layerswitcher-popup li.select,
.ol-layerswitcher-popup li.ol-visible {
  background:rgba(0, 60, 136, 0.7);
  color:#fff;
}
.ol-layerswitcher-popup li:hover {
  background:rgba(0, 60, 136, 0.9);
  color:#fff;
}

.ol-control.ol-layerswitcher.ol-layer-shop {
  height: calc(100% - 4em);
  max-height: unset;
  max-width: 16em;
  background-color: transparent;
  pointer-events: none!important;
  overflow: visible;
}
.ol-control.ol-layerswitcher > * {
  pointer-events: auto;
}

.ol-control.ol-layer-shop > button,
.ol-control.ol-layer-shop .panel-container {
  -webkit-box-shadow: 0 0 0 3px rgba(255,255,255,.5);
          box-shadow: 0 0 0 3px rgba(255,255,255,.5);
}
.ol-control.ol-layerswitcher.ol-layer-shop .panel-container {
  overflow-y: scroll;
  max-height: calc(100% - 6.5em);
  border: 2px solid #369;
  border-width: 2px 0;
  padding: 0;
}
.ol-control.ol-layer-shop .panel {
  padding: 0;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  margin: .25em .5em;
}
.ol-control.ol-layerswitcher.ol-layer-shop .panel-container.ol-scrolldiv {
  overflow: hidden;
}
.ol-control.ol-layer-shop .ol-scroll {
  background-color: rgba(0,0,0,.3);
  opacity: .5;
}
.ol-layerswitcher.ol-layer-shop ul.panel li.ol-header {
  display: none;
}
.ol-layerswitcher.ol-layer-shop ul.panel li {
  margin-right: 0;
  padding-right: 0;
}
.ol-layerswitcher.ol-layer-shop .layerup {
  height: 1.5em;
  width: 1.4em;
  margin: 0;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  border-radius: 3px;
  background-color: transparent;
  color: rgba(0,60,136,1);
}
.ol-layerswitcher.ol-layer-shop .layerup:hover {
  background-color: rgba(0,60,136,.3);
}
.ol-layerswitcher.ol-layer-shop .layerup:before {
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  border: 0;
  background-color: currentColor;
  width: 1em;
  height: 2px;
  -webkit-box-shadow: 0 -4px, 0 4px;
          box-shadow: 0 -4px, 0 4px;
}
.ol-layerswitcher.ol-layer-shop .layerup:after {
  content: unset;
}

.ol-control.ol-layer-shop .ol-title-bar {
  background-color: rgba(255,255,255,.5);
  font-size: .9em;
  height: calc(2.8em - 4px);
  max-width: 14.6em;
  padding: .7em .5em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  text-align: right;
  -webkit-transform: scaleY(1.1);
          transform: scaleY(1.1);
  -webkit-transition: width 0s, -webkit-transform .1s;
  transition: width 0s, -webkit-transform .1s;
  transition: transform .1s, width 0s;
  transition: transform .1s, width 0s, -webkit-transform .1s;
  -webkit-transform-origin: 100% 0;
          transform-origin: 100% 0;
}
.ol-control.ol-layer-shop:hover .ol-title-bar {
  background-color: rgba(255,255,255,.7);
}
.ol-control.ol-layer-shop.ol-collapsed .ol-title-bar {
  max-width: 10em;
  -webkit-transform: scale(.9, 1.1);
          transform: scale(.9, 1.1);
}
.ol-control.ol-layer-shop.ol-forceopen .ol-title-bar {
  max-width: 14.6em;
  -webkit-transform: scaleY(1.1);
          transform: scaleY(1.1);
}

.ol-control.ol-layer-shop .ol-bar {
  position: relative;
  height: 1.75em;
  clear: both;
  -webkit-box-shadow: 0 0 0 3px rgba(255,255,255,.5);
          box-shadow: 0 0 0 3px rgba(255,255,255,.5);
  background-color: #fff;
  text-align: right;
  z-index: 10;
}
.ol-control.ol-layer-shop.ol-collapsed .ol-scroll,
.ol-control.ol-layer-shop.ol-collapsed .ol-bar {
  border-width: 2px 0 0;
  display: none;
}
.ol-control.ol-layer-shop.ol-forceopen .ol-scroll,
.ol-control.ol-layer-shop.ol-forceopen .ol-bar  {
  display: block;
}
.ol-control.ol-layer-shop .ol-bar > * {
  font-size: .9em;
  display: inline-block;
  vertical-align: middle;
  margin-top: .25em;
  background-color: transparent;
}

.ol-layer-shop .ol-bar .ol-button,
.ol-touch .ol-layer-shop .ol-bar .ol-button {
  position: relative;
  top: unset;
  left: unset;
  bottom: unset;
  right: unset;
  margin: 0;
}
.ol-layer-shop .ol-bar button {
  background-color: #fff;
  color: rgba(0,60,136,1)
}
.ol-layer-shop .ol-bar button:hover {
  background-color: rgba(0,60,136,.2);
}

/* Touch device */
.ol-touch .ol-layerswitcher.ol-layer-shop > button {
  font-size: 1.7em;
}
.ol-touch .ol-layer-shop .ol-bar {
  height: 2em;
}
.ol-touch .ol-layer-shop .ol-control button {
  font-size: 1.4em;
}
.ol-touch .ol-control.ol-layer-shop .panel {
  max-height: calc(100% - 7em);
}
.ol-touch .ol-control.ol-layer-shop .panel label {
  height: 1.8em;
}
.ol-touch .ol-control.ol-layer-shop .panel label span {
  margin-left: .5em;
  padding-top: .25em;
}
.ol-touch .ol-control.ol-layer-shop .panel label:before,
.ol-touch .ol-control.ol-layer-shop .panel label:after {
  font-size: 1.3em;
  z-index: 1;
}

.ol-control.ol-layerswitcher {
  position: absolute;
  right: 0.5em;
  text-align: left;
  top: 3em;
  max-height: calc(100% - 6em);
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  overflow: hidden;
}
.ol-control.ol-layerswitcher .ol-switchertopdiv,
.ol-control.ol-layerswitcher .ol-switcherbottomdiv {
  display: block
}
.ol-control.ol-layerswitcher.ol-collapsed .ol-switchertopdiv,
.ol-control.ol-layerswitcher.ol-collapsed .ol-switcherbottomdiv {
  display: none;
}
.ol-layerswitcher.ol-forceopen.ol-collapsed .ol-switchertopdiv,
.ol-layerswitcher.ol-forceopen.ol-collapsed .ol-switcherbottomdiv {
  display: block;
}

.ol-control.ol-layerswitcher .ol-switchertopdiv,
.ol-control.ol-layerswitcher .ol-switcherbottomdiv {
  position: absolute;
  top:0;
  left:0;
  right:0;
  height: 45px;
  background: #fff; 
  z-index:2;
  opacity:1;
  cursor: pointer;
  border-top:2px solid transparent;
  border-bottom:2px solid #369;
  margin:0 2px;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-control.ol-layerswitcher .ol-switcherbottomdiv {
  top: auto;
  bottom: 0;
  height: 2em;
  border-top:2px solid #369;
  border-bottom:2px solid transparent;
}
.ol-control.ol-layerswitcher .ol-switchertopdiv:before,
.ol-control.ol-layerswitcher .ol-switcherbottomdiv:before {
  content:"";
  position: absolute;
  left:50%;
  top:50%;
  border:10px solid transparent;
  width:0;
  height:0;
  transform: translate(-50%, -50%);
  -webkit-transform: translate(-50%, -50%);
  opacity:0.8;
}

.ol-control.ol-layerswitcher .ol-switchertopdiv:hover:before,
.ol-control.ol-layerswitcher .ol-switcherbottomdiv:hover:before {
  opacity:1;
}
.ol-control.ol-layerswitcher .ol-switchertopdiv:before {
  border-bottom-color: #369;
  border-top: 0;
}
.ol-control.ol-layerswitcher .ol-switcherbottomdiv:before {
  border-top-color: #369;
  border-bottom: 0;
}

.ol-control.ol-layerswitcher .panel-container {
  background-color: #fff;
  border-radius: 0 0 2px 2px;
  clear: both;
  display: block; /* display:block to show panel on over */
  padding: 0.5em 0.5em 0;
}

.ol-layerswitcher .panel {
  list-style: none;
  padding: 0;
  margin: 0;
  overflow: hidden;
  font-family: Tahoma,Geneva,sans-serif;
  font-size:0.9em;
  -webkit-transition: top 0.3s;
  transition: top 0.3s;
  position: relative;
  top:0;
}

.ol-layerswitcher .panel ul {
  list-style: none;
  padding: 0 0 0 20px;
  overflow: hidden;
  clear: both;
}

/** Customize checkbox
*/
.ol-layerswitcher input[type="radio"],
.ol-layerswitcher input[type="checkbox"] {
  display:none;
}

.ol-layerswitcher .panel li {
  -weblit-transition: -webkit-transform 0.2s linear;
  -webkit-transition: -webkit-transform 0.2s linear;
  transition: -webkit-transform 0.2s linear;
  transition: transform 0.2s linear;
  transition: transform 0.2s linear, -webkit-transform 0.2s linear;
  clear: both;
  display: block;
  border:1px solid transparent;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-layerswitcher .panel li.ol-layer-select {
  background-color: rgba(0,60,136,.2);
  margin: 0 -.5em;
  padding: 0 .5em
}
/* drag and drop */
.ol-layerswitcher .panel li.drag {
  opacity: 0.5;
  transform:scale(0.8);
  -webkit-transform:scale(0.8);
}
.ol-dragover {
  background:rgba(51,102,153,0.5);
  opacity:0.8;
}
.ol-layerswitcher .panel li.forbidden,
.forbidden .ol-layerswitcher-buttons div,
.forbidden .layerswitcher-opacity div {
  background:rgba(255,0,0,0.5);
  color:#f00!important;
}

/* cursor management */
.ol-layerswitcher.drag,
.ol-layerswitcher.drag * {
  cursor:not-allowed!important;
  cursor:no-drop!important;
}
.ol-layerswitcher.drag .panel li.dropover,
.ol-layerswitcher.drag .panel li.dropover * {
  cursor: pointer!important;
  cursor: n-resize!important;
  cursor: ns-resize!important;
  cursor: -webkit-grab!important;
  cursor: grab!important;
  cursor: -webkit-grabbing!important;
  cursor: grabbing!important;
}

.ol-layerswitcher .panel li.dropover {
  background: rgba(51, 102, 153, 0.5);
}

.ol-layerswitcher .panel li label {
  display: inline-block;
  height: 1.4em;
  max-width: 12em;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  padding: 0 0 0 1.7em;
  position: relative;
}

.ol-layerswitcher .panel li label span {
  display: inline-block;
  width: 100%;
  height: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  padding-right: .2em;
}
.ol-layerswitcher [type="radio"] + label:before,
.ol-layerswitcher [type="checkbox"] + label:before,
.ol-layerswitcher [type="radio"]:checked + label:after,
.ol-layerswitcher [type="checkbox"]:checked + label:after {
  content: '';
  position: absolute;
  left: 0.1em; top: 0.1em;
  width: 1.2em; height: 1.2em; 
  border: 2px solid #369;
  background: #fff;
  -webkit-box-sizing:border-box;
          box-sizing:border-box;
}

.ol-layerswitcher [type="radio"] + label:before,
.ol-layerswitcher [type="radio"] + label:after {
  border-radius: 50%;
}

.ol-layerswitcher [type="radio"]:checked + label:after {
  background: #369 none repeat scroll 0 0;
  margin: 0.3em;
  width: 0.6em;
  height: 0.6em;
}

.ol-layerswitcher [type="checkbox"]:checked + label:after {
  background: transparent;
  border-width: 0 3px 3px 0;
  border-style: solid;
  border-color: #369;
    width: 0.7em;
    height: 1em;
    -webkit-transform: rotate(45deg);
    transform: rotate(45deg);
    left: 0.55em;
    top: -0.05em;
    -webkit-box-shadow: 1px 0px 1px 1px #fff;
            box-shadow: 1px 0px 1px 1px #fff;
}

.ol-layerswitcher .panel li.ol-layer-hidden {
  opacity: 0.6;
}

.ol-layerswitcher.ol-collapsed .panel-container {
  display:none;
}
.ol-layerswitcher.ol-forceopen .panel-container {
  display:block;
}

.ol-layerswitcher-image > button,
.ol-layerswitcher > button {
  background-color: white;
  float: right;
  z-index: 10;
  position: relative;
  font-size: 1.7em;
}
.ol-touch .ol-layerswitcher-image > button,
.ol-touch .ol-layerswitcher > button {
  font-size: 2.5em;
}
.ol-layerswitcher-image > button:before,
.ol-layerswitcher-image > button:after,
.ol-layerswitcher > button:before,
.ol-layerswitcher > button:after {
  content: "";
  position:absolute;
  width: .75em;
  height: .75em;
  border-radius: 0.15em;
  -webkit-transform: scaleY(.8) rotate(45deg);
  transform: scaleY(.8) rotate(45deg);
}
.ol-layerswitcher-image > button:before,
.ol-layerswitcher > button:before {
  background: #e2e4e1;
  top: .32em;
  left: .34em;
  -webkit-box-shadow: 0.1em 0.1em #325158;
  box-shadow: 0.1em 0.1em #325158;
}
.ol-layerswitcher-image > button:after,
.ol-layerswitcher > button:after {
  top: .22em;
  left: .34em;
  background: #83bcc5;
  background-image: radial-gradient( circle at .85em .6em, #70b3be 0, #70b3be .65em, #83bcc5 .65em);
}
.ol-layerswitcher-buttons {
  display:block;
  float: right;
  text-align:right;
}
.ol-layerswitcher-buttons > div {
  display: inline-block;
  position: relative;
  cursor: pointer;
  height:1em;
  width:1em;
  margin:2px;
  line-height: 1em;
    text-align: center;
    background: #369;
    vertical-align: middle;
    color: #fff;
}

.ol-layerswitcher .panel li > div {
  display: inline-block;
  position: relative;
}

/* line break */
.ol-layerswitcher .ol-separator {
  display:block;
  width:0;
  height:0;
  padding:0;
  margin:0;
}

.ol-layerswitcher .layerup {
  float: right;
  height:2.5em;
  background-color: #369;
  opacity: 0.5;
  cursor: move;
  cursor: ns-resize;
}

.ol-layerswitcher .layerup:before,
.ol-layerswitcher .layerup:after {
  border-color: #fff transparent;
  border-style: solid;
  border-width: 0.4em 0.4em 0;
  content: "";
  height: 0;
  position: absolute;
  bottom: 3px;
  left: 0.1em;
  width: 0;
}
.ol-layerswitcher .layerup:after {
  border-width: 0 0.4em 0.4em;
  top:3px;
  bottom: auto;
}

.ol-layerswitcher .layerInfo {
  background: #369;
  border-radius: 100%;
}
.ol-layerswitcher .layerInfo:before {
  color: #fff;
  content: "i";
  display: block;
  font-size: 0.8em;
  font-weight: bold;
  text-align: center;
  width: 1.25em;
  position:absolute;
  left: 0;
  top: 0;
}

.ol-layerswitcher .layerTrash {
  background: #369;
}
.ol-layerswitcher .layerTrash:before {
  color: #fff;
  content: "\\00d7";
  font-size:1em;
  top: 50%;
  left: 0;
  right: 0;
  text-align: center;
  line-height: 1em;
  margin: -0.5em 0;
  position: absolute;
}

.ol-layerswitcher .layerExtent {
  background: #369;
}
.ol-layerswitcher .layerExtent:before {
  border-right: 1px solid #fff;
  border-bottom: 1px solid #fff;
  content: "";
  display: block;
  position: absolute;
  left: 6px;
  right: 2px;
  top: 6px;
  bottom: 3px;
}
.ol-layerswitcher .layerExtent:after {
  border-left: 1px solid #fff;
  border-top: 1px solid #fff;
  content: "";
  display: block;
  position: absolute;
  bottom: 6px;
  left: 2px;
  right: 6px;
  top: 3px;
}

.ol-layerswitcher .expend-layers,
.ol-layerswitcher .collapse-layers {
  margin: 0 2px;
  background-color: transparent;
}
.ol-layerswitcher .expend-layers:before,
.ol-layerswitcher .collapse-layers:before {
  content:"";
  position:absolute;
  top:50%;
  left:0;
  margin-top:-2px;
  height:4px;
  width:100%;
  background:#369;
}
.ol-layerswitcher .expend-layers:after {
  content:"";
  position:absolute;
  left:50%;
  top:0;
  margin-left:-2px;
  width:4px;
  height:100%;
  background:#369;
}
/*
.ol-layerswitcher .collapse-layers:before {
  content:"";
  position:absolute;
  border:0.5em solid #369;
  border-color: #369 transparent transparent;
  margin-top:0.25em;
}
.ol-layerswitcher .expend-layers:before {
  content:"";
  position:absolute;
  border:0.5em solid #369;
  border-color: transparent transparent transparent #369 ;
  margin-left:0.25em;
}
*/

.ol-layerswitcher .layerswitcher-opacity {
  position:relative;
  border: 1px solid #369;
  height: 3px;
  width: 120px;
  margin:5px 1em 10px 7px;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  border-radius: 3px;
  background: #69c;
  background: -webkit-gradient(linear, left top, right top, from(rgba(0,60,136,0)), to(rgba(0,60,136,0.6)));
  background: linear-gradient(to right, rgba(0,60,136,0), rgba(0,60,136,0.6));
  cursor: pointer;
  -webkit-box-shadow: 1px 1px 1px rgba(0,0,0,0.5);
          box-shadow: 1px 1px 1px rgba(0,0,0,0.5);
}

.ol-layerswitcher .layerswitcher-opacity .layerswitcher-opacity-cursor,
.ol-layerswitcher .layerswitcher-opacity .layerswitcher-opacity-cursor:before {
  position: absolute;
  width: 20px;
  height: 20px;
  top: 50%;
  left: 50%;
  background: rgba(0,60,136,0.5);
  border-radius: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
  z-index: 1;
}
.ol-layerswitcher .layerswitcher-opacity .layerswitcher-opacity-cursor:before {
  content: "";
  position: absolute;
  width: 50%;
  height: 50%;
}
.ol-touch .ol-layerswitcher .layerswitcher-opacity .layerswitcher-opacity-cursor {
  width: 26px;
  height: 26px;
}

.ol-layerswitcher .layerswitcher-opacity-label { 
  display:none;
  position: absolute;
  right: -2.5em;
  bottom: 5px;
  font-size: 0.8em;
}
.ol-layerswitcher .layerswitcher-opacity-label::after {
  content:"%";
}

.ol-layerswitcher .layerswitcher-progress {
  display:block;
  margin:-4px 1em 2px 7px;
  width: 120px;
}
.ol-layerswitcher .layerswitcher-progress div {
  background-color: #369;
  height:2px;
  display:block;
  width:0;
}

.ol-control.ol-layerswitcher-image {
  position: absolute;
  right: 0.5em;
  text-align: left;
  top: 1em;
  transition: all 0.2s ease 0s;
  -webkit-transition: all 0.2s ease 0s;
}
.ol-control.ol-layerswitcher-image.ol-collapsed {
  top:3em;
  -webkit-transition: none;
  transition: none;
}

.ol-layerswitcher-image .panel {
  list-style: none;
  padding: 0.25em;
  margin:0;
  overflow: hidden;
}

.ol-layerswitcher-image .panel ul {
  list-style: none;
  padding: 0 0 0 20px;
  overflow: hidden;
}

.ol-layerswitcher-image.ol-collapsed .panel {
  display:none;
}
.ol-layerswitcher-image.ol-forceopen .panel {
  display:block;
  clear:both;
}

.ol-layerswitcher-image button {
  float: right;
  display:none;
}

.ol-layerswitcher-image.ol-collapsed button {
  display:block;
  position:relative;
}

.ol-layerswitcher-image li {
  border-radius: 4px;
  border: 3px solid transparent;
  -webkit-box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);
          box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);
  display: inline-block;
  width: 64px;
  height: 64px;
  margin:2px;
  position: relative;
  background-color: #fff;
  overflow: hidden;
  vertical-align: middle;
  cursor:pointer;
}
.ol-layerswitcher-image li.ol-layer-hidden {
  opacity: 0.5;
  border-color:#555;
}
.ol-layerswitcher-image li.ol-header {
  display: none;
}

.ol-layerswitcher-image li img {
  position:absolute;
  max-width:100%;
}
.ol-layerswitcher-image li.select,
.ol-layerswitcher-image li.ol-visible {
  border: 3px solid red;
}

.ol-layerswitcher-image li p {
  display:none;
}
.ol-layerswitcher-image li:hover p {
  background-color: rgba(0, 0, 0, 0.5);
  color: #fff;
  bottom: 0;
  display: block;
  left: 0;
  margin: 0;
  overflow: hidden;
  position: absolute;
  right: 0;
  text-align: center;
  height:1.2em;
  font-family:Verdana, Geneva, sans-serif;
  font-size:0.8em;
}
.ol-control.ol-legend {
  bottom: .5em;
  left: .5em;
  z-index: 1;
  max-height: 90%;
  max-width: 90%;
  overflow-x: hidden;
  overflow-y: auto;
  background-color: rgba(255,255,255,.6);
}
.ol-control.ol-legend:hover {
  background-color: rgba(255,255,255,.8);
}
.ol-control.ol-legend.ol-empty,
.ol-control.ol-legend.ol-collapsed {
  overflow: hidden;
}
.ol-control.ol-legend button {
  position: relative;
  display: none;
}
.ol-control.ol-legend.ol-empty button,
.ol-control.ol-legend.ol-collapsed button {
  display: block;
}
.ol-control.ol-legend.ol-uncollapsible button {
  display: none;
}

.ol-control.ol-legend > ul,
.ol-control.ol-legend > canvas {
  margin: 2px;
}

.ol-control.ol-legend button.ol-closebox {
  display: block;
  position: absolute;
  top: 0;
  right: 0;
  background: none;
  cursor: pointer;
  z-index: 1;
}
.ol-control.ol-legend.ol-empty button.ol-closebox,
.ol-control.ol-legend.ol-uncollapsible button.ol-closebox,
.ol-control.ol-legend.ol-collapsed button.ol-closebox {
  display: none;
}
.ol-control.ol-legend button.ol-closebox:before {
  content: "\\D7";
  background: none;
  color: rgba(0,60,136,.5);
  font-size: 1.3em;
}
.ol-control.ol-legend button.ol-closebox:hover:before {
  color: rgba(0,60,136,1);
}
.ol-control.ol-legend .ol-legendImg {
  display: block;
}
.ol-control.ol-legend.ol-empty .ol-legendImg,
.ol-control.ol-legend.ol-collapsed .ol-legendImg {
  display: none;
}
.ol-control.ol-legend.ol-uncollapsible .ol-legendImg {
  display: block;
}

.ol-control.ol-legend > button:first-child:before,
.ol-control.ol-legend > button:first-child:after {
  content: "";
  position: absolute;
  top: .25em;
  left: .2em;
  width: .2em;
  height: .2em;
  background-color: currentColor;
  -webkit-box-shadow: 0 0.35em, 0 0.7em;
          box-shadow: 0 0.35em, 0 0.7em;
}
.ol-control.ol-legend button:first-child:after {
  top: .27em;
  left: .55em;
  height: .15em;
  width: .6em;
}

ul.ol-legend {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  margin: 0;
  padding: 0;
  list-style: none;
}
.ol-control.ol-legend.ol-empty ul,
.ol-control.ol-legend.ol-collapsed ul {
  display: none;
}
.ol-control.ol-legend.ol-uncollapsible ul {
  display: block;
}
ul.ol-legend li.ol-title {
  text-align: center;
  font-weight: bold;
}
ul.ol-legend li.ol-title > div:first-child {
  width: 0!important;
}
ul.ol-legend li {
  overflow: hidden;
  padding: 0;
  white-space: nowrap;
}
ul.ol-legend li div {
  display: inline-block;
  vertical-align: top;
}

.ol-control.ol-legend .ol-legend {
  display: inline-block;
}
.ol-control.ol-legend.ol-empty .ol-legend,
.ol-control.ol-legend.ol-collapsed .ol-legend {
  display: none;
}
.ol-control.ol-legend.ol-empty button {
  opacity: .4;
}
.ol-control.ol-mapzone {
  position: absolute;
  right: 0.5em;
  text-align: left;
  top: .5em;
  max-height: calc(100% - 6em);
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  overflow: hidden;
}

.ol-control.ol-mapzone.ol-collapsed {
  top: 3em;
}

.ol-control.ol-mapzone button {
  position: relative;
  float: right;
  margin-top: 2.5em;
}
.ol-touch .ol-control.ol-mapzone button {
  margin-top: 1.67em;
}
.ol-control.ol-mapzone.ol-collapsed button {
  margin-top: 0;
}

.ol-control.ol-mapzone button i {
  border: .1em solid currentColor;
  border-radius: 50%;
  width: .9em;
  height: .9em; 
  overflow: hidden;
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-control.ol-mapzone button i:before {
  content: "";
  background-color: currentColor;
  width: 0.4em;
  height: .4em;
  position: absolute;
  left: .5em;
  top: 0.3em;
  border-radius: 50%;
  -webkit-box-shadow: .05em .3em 0 -.051em currentColor,
  	-.05em -.35em 0 -.1em currentColor,
  	-.5em -.35em 0 0em currentColor,
  	-.65em .1em 0 -.03em currentColor,
  	-.65em -.05em 0 -.05em currentColor;
          box-shadow: .05em .3em 0 -.051em currentColor,
  	-.05em -.35em 0 -.1em currentColor,
  	-.5em -.35em 0 0em currentColor,
  	-.65em .1em 0 -.03em currentColor,
  	-.65em -.05em 0 -.05em currentColor
}

.ol-mapzone > div {
  position: relative;
  display: inline-block;
  width: 5em;
  height: 5em;
  margin: 0 .2em 0 0;
}
.ol-control.ol-mapzone.ol-collapsed > div {
  display: none;
}
.ol-mapzone > div p {
  margin: 0;
  position: absolute;
  bottom: 0;
  /* background: rgba(255,255,255,.5); */
  color: #fff;
  font-weight: bold;
  text-align: center;
  width: 160%;
  overflow: hidden;
  font-family: 'Lucida Grande',Verdana,Geneva,Lucida,Arial,Helvetica,sans-serif;
  -webkit-transform: scaleX(.625);
          transform: scaleX(.625);
  -webkit-transform-origin: 0 0;
          transform-origin: 0 0;
  cursor: default;
}

.ol-notification {
  width: 150%;
  bottom: 0;
  border: 0;
  background: none;
  margin: 0;
  padding: 0;
}
.ol-notification > div,
.ol-notification > div:hover {
  position: absolute;
  background-color: rgba(0,0,0,.8);
  color: #fff;
  bottom: 0;
  left: 33.33%;
  max-width: calc(66% - 4em);
  min-width: 5em;
  max-height: 5em;
  min-height: 1em;
  border-radius: 4px 4px 0 0;
  padding: .2em .5em;
  text-align: center;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  -webkit-transition: .3s;
  transition: .3s;
  opacity: 1;
}
.ol-notification.ol-collapsed > div {
  bottom: -5em;
  opacity: 0;
}

.ol-notification a {
  color: #9cf;
  cursor: pointer;
}

.ol-notification .ol-close,
.ol-notification .ol-close:hover {
  padding-right: 1.5em;
}

.ol-notification .closeBox {
  position: absolute;
  top: 0;
  right: 0.3em;
}
.ol-notification .closeBox:before {
  content: '\\00d7';
}
.ol-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width:100%;
  height: 100%;
  background-color: rgba(0,0,0,0.4);
  padding: 1em;
  color: #fff;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  z-index: 1;
  opacity: 0;
  display: none;
  cursor: default;
  overflow: hidden;
  -webkit-transition: all 0.5s;
  transition: all 0.5s;
  pointer-events: none;
  z-index: 9;
}

.ol-overlay.slide-up {
  transform: translateY(100%);
  -webkit-transform: translateY(100%);
}
.ol-overlay.slide-down {
  -webkit-transform: translateY(-100%);
  transform: translateY(-100%);
}
.ol-overlay.slide-left
{	-webkit-transform: translateX(-100%);
  transform: translateX(-100%);
}
.ol-overlay.slide-right {
  -webkit-transform: translateX(100%);
  transform: translateX(100%);
}
.ol-overlay.zoom {
  top: 50%;
  left: 50%;
  opacity:0.5;
  -webkit-transform: translate(-50%,-50%) scale(0);
  transform: translate(-50%,-50%) scale(0);
}
.ol-overlay.zoomout {
  -webkit-transform: scale(3);
  transform: scale(3);
}
.ol-overlay.zoomrotate {
  top: 50%;
  left: 50%;
  opacity:0.5;
  -webkit-transform: translate(-50%,-50%) scale(0) rotate(360deg);
  transform: translate(-50%,-50%) scale(0) rotate(360deg);
}
.ol-overlay.stretch {
  top: 50%;
  left: 50%;
  opacity:0.5;
  -webkit-transform: translate(-50%,-50%) scaleX(0);
  transform: translate(-50%,-50%) scaleX(0) ;
}
.ol-overlay.stretchy {
  top: 50%;
  left: 50%;
  opacity:0.5;
  -webkit-transform: translate(-50%,-50%) scaleY(0);
  transform: translate(-50%,-50%) scaleY(0) ;
}
.ol-overlay.wipe {
  opacity: 1;
  /* clip: must be set programmatically */
  /* clip-path: use % but not crossplatform (IE) */
}
.ol-overlay.flip {
  -webkit-transform: perspective(600px) rotateY(180deg);
  transform: perspective(600px) rotateY(180deg);
}
.ol-overlay.card {
  opacity: 0.5;
  -webkit-transform: translate(-80%, 100%) rotate(-0.5turn);
  transform: translate(-80%, 100%) rotate(-0.5turn);
}
.ol-overlay.book {
  -webkit-transform: perspective(600px) rotateY(-180deg) scaleX(0.6);
  transform: perspective(600px) rotateY(-180deg) scaleX(0.6) ;
  -webkit-transform-origin: 10% 50%;
  transform-origin: 10% 50%;
}
.ol-overlay.book.visible {
  -webkit-transform-origin: 10% 50%;
  transform-origin: 10% 50%;
}

.ol-overlay.ol-visible {
  opacity:1;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  -webkit-transform: none;
  transform: none;
  pointer-events: all;  
}

.ol-overlay .ol-closebox {
  position: absolute;
  top: 1em;
  right: 1em;
  width: 1em;
  height: 1em;
  cursor: pointer;
  z-index:1;
}
.ol-overlay .ol-closebox:before {
  content: "\\274c";
  display: block;
  text-align: center;
  vertical-align: middle;
}

.ol-overlay .ol-fullscreen-image {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}
.ol-overlay .ol-fullscreen-image img {
  position: absolute;
  max-width: 100%;
  max-height: 100%;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  padding: 1em;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
}
.ol-overlay .ol-fullscreen-image.ol-has-title img {
  padding-bottom: 3em;
}
.ol-overlay .ol-fullscreen-image p {
  background-color: rgba(0,0,0,.5);
  padding: .5em;
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  margin: 0;
  text-align: center;
}
.ol-control.ol-overview
{	position: absolute;
	left: 0.5em;
	text-align: left;
	bottom: 0.5em;
}

.ol-control.ol-overview .panel
{	display:block;
	width:150px;
	height:150px;
	margin:2px;
	background-color:#fff;
	border:1px solid #369;
	cursor: pointer;
}

.ol-overview:not(.ol-collapsed) button
{	position:absolute;
	bottom:2px;
	left:2px;
	z-index:2;
}

.ol-control.ol-overview.ol-collapsed .panel
{	display:none;
}

.ol-overview.ol-collapsed button:before
{	content:'\\00bb';
}
.ol-overview button:before
{	content:'\\00ab';
}


.ol-control-right.ol-overview
{	left: auto;
	right: 0.5em;
}
.ol-control-right.ol-overview:not(.ol-collapsed) button
{	left:auto;
	right:2px;
}
.ol-control-right.ol-overview.ol-collapsed button:before
{	content:'\\00ab';
}
.ol-control-right.ol-overview button:before
{	content:'\\00bb';
}

.ol-control-top.ol-overview
{	bottom: auto;
	top: 5em;
}
.ol-control-top.ol-overview:not(.ol-collapsed) button
{	bottom:auto;
	top:2px;
}

.ol-permalink {
  position: absolute;
  top:0.5em;
  right: 2.5em;
}
.ol-touch .ol-permalink {
  right: 3em;
}

.ol-permalink button i {
  position: absolute;
  width: 1em;
  height: 1em;
  display: block;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-permalink button i:before {
  content: '\\2197';
  position: absolute;
  border: 1px solid currentColor;
  left: 0;
  top: 0;
  width: 0.3em;
  height: 1em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  border-width: 1px 0 0 1px;
  padding: 0 0.2em;
}
.ol-permalink button i:after {
  content: '';
  position: absolute;
  border: 1px solid currentColor;
  right: 0;
  bottom: 0;
  width: 1em;
  height: 0.3em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  border-width: 0 1px 1px 0;
  padding: 0.2em;
}
.ol-control.ol-print {
  top:.5em;
  left: 3em;
}
.ol-control.ol-print button:before {
  content: "";
  width: .9em;
  height: .35em;
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  -webkit-box-shadow: inset 0 0 0 0.1em, inset 0.55em 0, 0 0.2em 0 -0.1em;
          box-shadow: inset 0 0 0 0.1em, inset 0.55em 0, 0 0.2em 0 -0.1em;
}
.ol-control.ol-print button:after {
  content: "";
  width: .7em;
  height: .6em;
  position: absolute;
  left: 50%;
  top: 25%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  -webkit-box-shadow: inset 0 0 0 0.15em;
          box-shadow: inset 0 0 0 0.15em;
}
.ol-ext-print-dialog {
  width: 100%;
  height: 100%;
}
.ol-ext-print-dialog > form .ol-closebox {
  right: auto;
  left: 16.5em;
  z-index: 1;
  color: #999;
}
.ol-ext-print-dialog .ol-content[data-status="printing"] {
  opacity: .5;
}
.ol-ext-print-dialog .ol-content .ol-error {
  display: none;
  background: #b00;
  color: yellow;
  text-align: center;
  padding: 1em .5em;
  font-weight: bold;
  margin: 0 -1em;
}
.ol-ext-print-dialog .ol-content[data-status="error"] .ol-error {
  display: block;
}


.ol-ext-print-dialog > form,
.ol-ext-print-dialog.ol-visible > form {
  -webkit-transition: none;
  transition: none;
  top: 1em;
  left: 1em;
  bottom: 1em;
  right: 1em;
  -webkit-transform: none;
          transform: none;
  max-width: 100%;
  max-height: 100%;
  background-color: #eee;
  padding: 0;
}
.ol-ext-print-dialog .ol-print-map {
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: calc(100% - 18em);
  overflow: hidden;
}
.ol-ext-print-dialog .ol-print-map .ol-page {
  position: absolute;
  left: 50%;
  top: 50%;
  background: #fff;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-ext-print-dialog .ol-print-map .ol-page.margin {
  -webkit-box-sizing: content-box;
          box-sizing: content-box;
}
.ol-ext-print-dialog .ol-map {
  width: 100%;
  height: 100%;
}
.ol-ext-print-dialog .ol-print-map .ol-control {
  display: none!important;
}

.ol-ext-print-dialog .ol-print-param {
  position: absolute;
  overflow-x: hidden;
  top: 0;
  bottom: 0;
  left: 0;
  width: 18em;
  background-color: #fff;
  padding: 1em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}

.ol-ext-print-dialog .ol-print-param h2 {
  display: block;
  color: rgba(0,60,136,.7);
  font-size: 1.1em;
}
.ol-ext-print-dialog .ol-print-param ul {
  padding: 0;
  list-style: none;
}
.ol-ext-print-dialog .ol-print-param li {
  position: relative;
  margin: .5em 0;
  font-size: .9em;
}
.ol-ext-print-dialog .ol-print-param li.hidden {
  display: none;
}
.ol-ext-print-dialog .ol-print-param label {
  width: 8em;
  display: inline-block;
  vertical-align: middle;
}

.ol-ext-print-dialog select {
  outline: none;
  vertical-align: middle;
}

.ol-ext-print-dialog .ol-orientation {
  text-align: center;
}
.ol-ext-print-dialog .ol-orientation label {
  position: relative;
  width: 7em;
  cursor: pointer;
}
.ol-ext-print-dialog .ol-orientation input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}
.ol-ext-print-dialog .ol-orientation span {
  position: relative;
  width: 80%;
  display: block;
  padding: 3.5em 0 .2em;
}
.ol-ext-print-dialog .ol-orientation span:before {
  content: "";
  position: absolute;
  width: 2em;
  height: 2.6em;
  bottom: 1.5em;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  color: #333;
  background-color: currentColor;
  border: 1px solid currentColor;
  border-radius: 0 1em 0 0;
  opacity: .5;
  overflow: hidden;
  -webkit-box-shadow: inset 1.3em -1.91em #ddd;
          box-shadow: inset 1.3em -1.91em #ddd;
}

.ol-ext-print-dialog .ol-orientation .landscape span:before {
  width: 2.6em;
  height: 2em;
  margin: .2em 0;
  -webkit-box-shadow: inset 1.91em -1.3em #ddd;
          box-shadow: inset 1.91em -1.3em #ddd;
}
.ol-ext-print-dialog .ol-orientation input:checked + span {
  opacity: 1;
  -webkit-box-shadow: 0 0 .2em rgba(0,0,0,.5);
          box-shadow: 0 0 .2em rgba(0,0,0,.5);
}

.ol-ext-print-dialog .ol-ext-toggle-switch span {
  position: absolute;
  right: -2em;
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
}

.ol-print-title input[type=text] {
  margin-top: .5em;
  width: calc(100% - 6em);
  margin-left: 6em;
}

.ol-ext-print-dialog .ol-size option:first-child {
  font-style: italic;
}

.ol-ext-print-dialog .ol-saveas,
.ol-ext-print-dialog .ol-savelegend {
  text-align: center;
}
.ol-ext-print-dialog .ol-saveas select,
.ol-ext-print-dialog .ol-savelegend select {
  background-color: rgba(0,60,136,.7);
  color: #fff;
  padding: .5em;
  margin: 1em 0 0;
  font-size: 1em;
  border: 0;
  font-weight: bold;
  max-width: 12em;
}
.ol-ext-print-dialog .ol-saveas select option,
.ol-ext-print-dialog .ol-savelegend select option {
  background-color: #fff;
  color: #666;
}
.ol-ext-print-dialog .ol-savelegend select {
  margin-top: 0;
}

.ol-ext-print-dialog .ol-ext-buttons {
  text-align: right;
  border-top: 1px solid #ccc;
  padding: .8em .5em;
  margin: 0 -1em;
}
.ol-ext-print-dialog button {
  font-size: 1em;
  margin: 0 .2em;
  border: 1px solid #999;
  background: none;
  padding: .3em 1em;
  color: #333;
}
.ol-ext-print-dialog button[type="submit"] {
  background-color: rgba(0,60,136,.7);
  color: #fff;
  font-weight: bold;
}

.ol-ext-print-dialog .ol-clipboard-copy {
  position: absolute;
  pointer-events: none;
  top: 0;
  background-color: rgba(0,0,0,.5);
  color: #fff;
  padding: .5em 1em;
  border-radius: 1em;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  width: -webkit-fit-content;
  width: -moz-fit-content;
  width: fit-content;
  -webkit-transition: 0s;
  transition: 0s;
  opacity: 0;
}
.ol-ext-print-dialog .ol-clipboard-copy.visible {
  -webkit-animation: 1s ol-clipboard-copy;
          animation: 1s ol-clipboard-copy;
}
.ol-ext-print-dialog .ol-print-map .ol-control.ol-canvas-control {
  display: block!important;
}
.ol-ext-print-dialog .ol-print-map .ol-control.ol-print-compass {
  display: block!important;
}
.ol-ext-print-dialog .ol-print-map .ol-control.olext-print-compass {
  top: 0;
  right: 0;
  width: 60px;
  height: 60px;
  margin: 20px;
}

@-webkit-keyframes ol-clipboard-copy { 
  0% { opacity: 0; top: 0; }
  80% { opacity: 1; top: -3em; }
  100% { opacity: 0; top: -3em; }  
}

@keyframes ol-clipboard-copy { 
  0% { opacity: 0; top: 0; }
  80% { opacity: 1; top: -3em; }
  100% { opacity: 0; top: -3em; }  
}

@media print {
  body.ol-print-document {
    margin: 0!important;
    padding: 0!important;
  }
  body.ol-print-document > * {
    display: none!important;
  }
  body.ol-print-document > .ol-ext-print-dialog {
    display: block!important;
  }
  body.ol-print-document > .ol-ext-print-dialog .ol-content {
    max-height: unset!important;
    max-width: unset!important;
    width: unset!important;
    height: unset!important;
  }
  .ol-ext-print-dialog > form,
  .ol-ext-print-dialog {
    position: unset;
    -webkit-box-shadow: none;
            box-shadow: none;
    background: none!important;
    border: 0;
  }
  .ol-ext-print-dialog > form > *,
  .ol-ext-print-dialog .ol-print-param {
    display: none!important;
    background: none;
  } 
  .ol-ext-print-dialog .ol-content {
    display: block!important;
    border: 0;
    background: none;
  }
  .ol-ext-print-dialog .ol-print-map {
    position: unset; 
    background: none;
    width: auto;
    overflow: visible;
  }
  .ol-ext-print-dialog .ol-print-map .ol-page {
    -webkit-transform: none!important;
            transform: none!important;
    -webkit-box-shadow: none!important;
            box-shadow: none!important;
    position: unset;
  }
}

@media (max-width: 25em) {
  .ol-ext-print-dialog .ol-print-param {
    width: 13em;
  }
  .ol-ext-print-dialog .ol-print-map {
    width: calc(100% - 13em);
  }
  .ol-ext-print-dialog .ol-print-param .ol-print-title input[type="text"] {
    width: 100%;
    margin: 0;
  }
}
.ol-ext-print-dialog2x .ol-map,
.ol-ext-print-dialog2x .ol-map2 {
  width: 100%;
  height: 50%;
}
.ol-ext-print-dialog2x[data-orientation="landscape"] .ol-map,
.ol-ext-print-dialog2x[data-orientation="landscape"] .ol-map2 {
  display: inline-block;
  width: 50%;
  height: 100%;
}

.ol-ext-print-dialog2x[data-clip-map] .ol-map,
.ol-ext-print-dialog2x[data-swipe-orientation] .ol-map {
  width: 100%!important;
  height: 100%!important;
}
.ol-ext-print-dialog2x[data-clip-map] .ol-map2,
.ol-ext-print-dialog2x[data-swipe-orientation] .ol-map2 {
  width: 100%!important;
  height: 100%!important;
  position: relative!important;
  left: 0;
  top: -100%;
}
.ol-profile {
  position: relative;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}
.ol-control.ol-profile {
  position: absolute;
  top: 0.5em;
  right: 3em;
  text-align: right;
  overflow: hidden;
}
.ol-profile .ol-zoom-out {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 1em;
  height: 1em;
  padding: 0;
  border: 1px solid #000;
  border-radius: 2px;
  cursor: pointer;
}
.ol-profile .ol-zoom-out:before {
  content: '';
  height: 2px;
  width: 60%;
  background: currentColor;
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}

.ol-profile .ol-inner  {
  position: relative;
  padding: 0.5em;
  font-size: 0.8em;
}
.ol-control.ol-profile .ol-inner {
  display: block;
  background-color: rgba(255,255,255,0.7);
  margin: 2.3em 2px 2px;
}
.ol-control.ol-profile.ol-collapsed .ol-inner {
  display: none;
}

.ol-profile canvas {
  display: block;
}
.ol-profile button {
  display: block;
  position: absolute;
  right: 0;
  overflow: hidden;
}
.ol-profile button i {
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  width: 1em;
  height: 1em;
  overflow: hidden;
}
.ol-profile button i:before,
.ol-profile button i:after {
  content: "";
  position: absolute;
  display: block;
  background-color: currentColor;
  width: 1em;
  height: .9em;
  -webkit-transform: scaleX(.8) translate(-.25em, .5em) rotate(45deg);
          transform: scaleX(.8) translate(-.25em, .5em) rotate(45deg);
}
.ol-profile button i:after {
  -webkit-transform: scaleX(.8) translate(.35em, .7em) rotate(45deg);
          transform: scaleX(.8) translate(.35em, .7em) rotate(45deg);
}

.ol-profile.ol-collapsed button {
  position: static;
}

.ol-profile .ol-profilebar,
.ol-profile .ol-profilecursor {
  position:absolute;
  pointer-events: none;
  width: 1px;
  display: none;
}
.ol-profile .ol-profilecursor {
  width: 0;
  height: 0;
}
.ol-profile .ol-profilecursor:before {
  content:"";
  pointer-events: none;
  display: block;
  margin: -2px;
  width:5px;
  height:5px;
}
.ol-profile .ol-profilebar,
.ol-profile .ol-profilecursor:before {
  background: red;
}

.ol-profile table {
  text-align: center;
  width: 100%;
}

.ol-profile table span {
  display: block;
}

.ol-profilepopup {
  background-color: rgba(255, 255, 255, 0.5);
  margin: 0.5em;
  padding: 0 0.5em;
  position: absolute;
  top:-1em;
  white-space: nowrap;
}
.ol-profilepopup.ol-left {
  right:0;
}


.ol-profile table td {
  padding: 0 2px;
}

.ol-profile table .track-info {
  display: table-row;
}
.ol-profile table .point-info {
  display: none;
}
.ol-profile .over table .track-info {
  display: none;
}
.ol-profile .over table .point-info {
  display: table-row;
}

.ol-profile p {
  text-align: center;
  margin:0;
}

.ol-control.ol-progress-bar {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 0;
  pointer-events: none!important;
  background-color: transparent;
}

.ol-control.ol-progress-bar > .ol-bar {
  position: absolute;
  background-color: rgba(0,60,136,.5);
  left: 0;
  bottom: 0;
  height: .5em;
  width: 0;
  -webkit-transition: width .2s;
  transition: width .2s;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}

.ol-progress-bar > .ol-waiting {
  display: none;
}

.ol-viewport .ol-control.ol-progress-bar > .ol-waiting {
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  color: #fff;
  font-size: 2em;
  display: block;
  -webkit-animation: 1s linear infinite ol-progress-bar-blink;
          animation: 1s linear infinite ol-progress-bar-blink;
}

@-webkit-keyframes ol-progress-bar-blink {
  0%, 30% {
    visibility: hidden;
  }
  100% {
    visibility: visible;
  }
}

@keyframes ol-progress-bar-blink {
  0%, 30% {
    visibility: hidden;
  }
  100% {
    visibility: visible;
  }
}

.ol-control.ol-routing {
  top: 0.5em;
  left: 3em;
  max-height: 90%;
  overflow-y: auto;
}
.ol-touch .ol-control.ol-routing {
  left: 3.5em;
}
.ol-control.ol-routing.ol-searching {
  opacity: .5;
}

.ol-control.ol-routing .ol-car,
.ol-control.ol-routing > button {
  position: relative;
}
.ol-control.ol-routing .ol-car:after,
.ol-control.ol-routing > button:after {
  content: "";
  position: absolute;
  width: .78em;
  height: 0.6em;
  border-radius: 40% 50% 0 0 / 50% 70% 0 0;
  -webkit-box-shadow: inset 0 0 0 0.065em, -0.35em 0.14em 0 -0.09em, inset 0 -0.37em, inset -0.14em 0.005em;
          box-shadow: inset 0 0 0 0.065em, -0.35em 0.14em 0 -0.09em, inset 0 -0.37em, inset -0.14em 0.005em;
  clip: rect(0 1em .5em -1em);
  top: .35em;
  left: .4em;
}
.ol-control.ol-routing .ol-car:before,
.ol-control.ol-routing > button:before {
  content: "";
  position: absolute;
  width: .28em;
  height: .28em;
  border-radius: 50%;
  -webkit-box-shadow: inset 0 0 0 1em, 0.65em 0;
          box-shadow: inset 0 0 0 1em, 0.65em 0;
  top: 0.73em;
  left: .20em;
}
.ol-control.ol-routing .ol-pedestrian:after {
  content: "";
  position: absolute;
  width: .3em;
  height: .4em;
  top: .25em;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  -webkit-box-shadow: inset 0.3em 0, 0.1em 0.5em 0 -0.1em, -0.1em 0.5em 0 -0.1em, 0.25em 0.1em 0 -0.1em, -0.25em 0.1em 0 -0.1em;
          box-shadow: inset 0.3em 0, 0.1em 0.5em 0 -0.1em, -0.1em 0.5em 0 -0.1em, 0.25em 0.1em 0 -0.1em, -0.25em 0.1em 0 -0.1em;
  border-top: .2em solid transparent;
}
.ol-control.ol-routing .ol-pedestrian:before {
  content: "";
  position: absolute;
  width: .3em;
  height: .3em;
  top: .1em;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  border-radius: 50%;
  background-color: currentColor;
}

.ol-control.ol-routing .content {
  margin: .5em;
}

.ol-control.ol-routing.ol-collapsed .content {
  display: none;
}

.ol-routing .ol-search.ol-collapsed ul {
	display: none;
}
.ol-routing .ol-search ul .copy {
  display: none;
}
.ol-routing .ol-search ul.history {
  /* display: none; */
}
.ol-routing .content .search-input > div > * {
  display: inline-block;
  vertical-align: top;
}
.ol-routing .ol-result ul {
  list-style: none;
  display: block;
}
.ol-routing .ol-result li {
  position: relative;
  min-height: 1.65em;
}
.ol-routing .ol-result li i {
  display: block;
  font-size: .8em;
  font-weight: bold;
}

.ol-routing .ol-result li:before {
  content: "";
  border: 5px solid transparent;
  position: absolute;
  left: -1.75em;
  border-bottom-color: #369;
  border-width: .6em .4em .6em;
  -webkit-transform-origin: 50% 125%;
          transform-origin: 50% 125%;
  -webkit-box-shadow: 0 0.65em 0 -0.25em #369;
          box-shadow: 0 0.65em 0 -0.25em #369;
  top: -.8em;
}
.ol-routing .ol-result li:after {
  content: "";
  position: absolute;
  width: 0.25em;
  height: .6em;
  left: -1.5em;
  background: #369;
  top: .6em;
  border-radius: 0.1em;
}
.ol-routing .ol-result li.R:before {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}
.ol-routing .ol-result li.FR:before {
  -webkit-transform: rotate(45deg);
          transform: rotate(45deg);
}
.ol-routing .ol-result li.L:before {
  -webkit-transform: rotate(-90deg);
          transform: rotate(-90deg);
}
.ol-routing .ol-result li.FL:before {
  -webkit-transform: rotate(-45deg);
          transform: rotate(-45deg);
}

.ol-routing .content > i {
  vertical-align: middle;
  margin: 0 .3em 0 .1em;
  font-style: normal;
}
.ol-routing .ol-button,
.ol-routing .ol-button:focus,
.ol-routing .ol-pedestrian,
.ol-routing .ol-car {
  font-size: 1.1em;
  position: relative;
  display: inline-block;
  width: 1.4em;
  height: 1.4em;
  color: rgba(0,60,136,1);
  background-color: transparent;
  margin: 0 .1em;
  opacity: .5;
  vertical-align: middle;
  outline: none;
  cursor: pointer;
}
.ol-routing .ol-button:hover,
.ol-routing .ol-button.selected,
.ol-routing i.selected {
  opacity: 1;
  background: transparent;
}

.ol-control.ol-routing {
  background-color: rgba(255,255,255,.25);
}
.ol-control.ol-routing:hover {
  background-color: rgba(255,255,255,.75);
}

.search-input > div > button:before {
  content: '\\00b1';
}
.ol-viewport .ol-scale {
	left: .5em;
	bottom: 2.5em;
	text-align: center;
	-webkit-transform: scaleX(.8);
	-webkit-transform-origin: 0 0;
	transform: scaleX(.8);
	transform-origin: 0 0;
	background-color: rgba(255, 255, 255, 0.75);
}
.ol-viewport .ol-scale input {
	background: none;
    border: 0;
    width: 8em;
    text-align: center;
}

.ol-search{
  top: 0.5em;
  left: 3em;
}
.ol-touch .ol-search {
  left: 3.5em;
}
.ol-search button {
  top: 2px;
  left: 2px;
  float: left;
}
.ol-control.ol-search > button:before {
  content: "";
  position: absolute;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  width: .7em;
  height: .7em;
  background-color: transparent;
  border: .12em solid currentColor;
  border-radius: 100%;
  top: .35em;
  left: .35em;
}
.ol-control.ol-search > button:after {
  content: "";
  position: absolute;
  top: 1.1em;
  left: .95em;
  width: .45em;
  height: .15em;
  background-color: currentColor;
  border-radius: .05em;
  -webkit-transform: rotate(45deg);
          transform: rotate(45deg);
  -webkit-box-shadow: -0.18em 0 0 -0.03em;
          box-shadow: -0.18em 0 0 -0.03em;
}

.ol-search button.ol-revers {
  float: none;
  background-image: none;
  display: inline-block;
  vertical-align: bottom;
  position: relative;
  top: 0;
  left: 0;
}
.ol-search.ol-revers button.ol-revers {
  background-color: rgba(0,136,60,.5)
}

.ol-control.ol-search.ol-collapsed button.ol-revers {
  display: none;
}
.ol-search button.ol-revers:before {
  content: "";
  border: .1em solid currentColor;
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%,-50%);
          transform: translate(-50%,-50%);
  border-radius: 50%;
  width: .55em;
  height: .55em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-search button.ol-revers:after {
  content: "";
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%,-50%);
          transform: translate(-50%,-50%);
  width: .2em;
  height: .2em;
  background-color: transparent;
  -webkit-box-shadow: .35em 0 currentColor, 0 .35em currentColor, -.35em 0 currentColor, 0 -.35em currentColor;
          box-shadow: .35em 0 currentColor, 0 .35em currentColor, -.35em 0 currentColor, 0 -.35em currentColor;
}

.ol-search input {
  display: inline-block;
  border: 0;
  margin: 1px 1px 1px 2px;
  font-size: 1.14em;
  padding-left: 0.3em;
  height: 1.375em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  -webkit-transition: all 0.1s;
  transition: all 0.1s;
}
.ol-touch .ol-search input,
.ol-touch .ol-search ul {
  font-size: 1.5em;
}
.ol-search.ol-revers > ul,
.ol-control.ol-search.ol-collapsed > * {
  display: none;
}
.ol-control.ol-search.ol-collapsed > button {
  display: block;
}

.ol-search ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: block;
  clear: both;
  cursor: pointer;
  max-width: 17em;
  overflow-x: hidden;
  z-index: 1;
  background: #fff;
}
/*
.ol-control.ol-search ul {
  position: absolute;
  box-shadow: 5px 5px 5px rgba(0,0,0,0.5);
}
*/
.ol-search ul li {
  padding: 0.1em 0.5em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.ol-search ul li.select,
.ol-search ul li:hover {
  background-color: rgba(0,60,136,.5);
  color: #fff;
}
.ol-search ul li img {
  float: left;
  max-height: 2em;
}
.ol-search li.copy {
    background: rgba(0,0,0,.5);
  color: #fff;
}
.ol-search li.copy a {
  color: #fff;
  text-decoration: none;
}

.ol-search.searching:before {
  content: '';
  position: absolute;
  height: 3px;
  left: 0;
  top: 1.6em;
  -webkit-animation: pulse .5s infinite alternate linear;
          animation: pulse .5s infinite alternate linear;
  background: red;
  z-index: 2;
}

@-webkit-keyframes pulse {
  0% { left:0; right: 95%; }
  50% {	left: 30%; right: 30%; }
  100% {	left: 95%; right: 0; }
}

@keyframes pulse {
  0% { left:0; right: 95%; }
  50% {	left: 30%; right: 30%; }
  100% {	left: 95%; right: 0; }
}


.ol-control.ol-search.IGNF-parcelle {
  background-color: rgba(255,255,255,.7);
  padding-bottom: .2em;
}
.ol-search.IGNF-parcelle input {
  width: 14.5em;
}
.ol-search.IGNF-parcelle input:-moz-read-only {
  background: #ccc;
  opacity: .8;
}
.ol-search.IGNF-parcelle input:read-only {
  background: #ccc;
  opacity: .8;
}
.ol-search.IGNF-parcelle.ol-collapsed-list > ul.autocomplete {
  display: none;
}

.ol-search.IGNF-parcelle label {
  display: block;
  clear: both;
}

.ol-search.IGNF-parcelle > div input {
  text-align: right;
}
.ol-search.IGNF-parcelle > div input,
.ol-search.IGNF-parcelle > div label {
  width: 4em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  display: inline-block;
  margin: .1em;
  font-size: 1em;
  overflow: hidden;
  text-overflow: ellipsis;
}
.ol-search.IGNF-parcelle > div label {
  letter-spacing: -0.04em;
}
.ol-search.IGNF-parcelle ul.autocomplete-page {
  margin-top:.5em;
  width:100%;
  text-align: center;
  display: none;
}
.ol-search.IGNF-parcelle.ol-collapsed-list ul.autocomplete-parcelle,
.ol-search.IGNF-parcelle.ol-collapsed-list ul.autocomplete-page {
  display: block;
}
.ol-search.IGNF-parcelle.ol-collapsed ul.autocomplete-page,
.ol-search.IGNF-parcelle.ol-collapsed ul.autocomplete-parcelle,
.ol-search.IGNF-parcelle ul.autocomplete-parcelle {
  display: none;
}
.ol-search.IGNF-parcelle ul.autocomplete-page li {
  display: inline-block;
  color: #fff;
  background: rgba(0,60,136,.5);
  border-radius: 50%;
  width: 1.3em;
  height: 1.3em;
  padding: .1em;
  margin: 0 .1em;
}
.ol-search.IGNF-parcelle ul.autocomplete-page li.selected {
  background: rgba(0,60,136,1);
}

/* GPS */
.ol-searchgps input.search {
  display: none;
}
.ol-control.ol-searchgps > button:first-child {
  background-image: none;
}
.ol-control.ol-searchgps > button:first-child:before {
  content: "x/y";
  position: unset;
  display: block;
  -webkit-transform: scaleX(.8);
          transform: scaleX(.8);
  border: unset;
  border-radius: 0;
  width: auto;
  height: auto;
}
.ol-control.ol-searchgps > button:first-child:after {
  content: unset;
}
.ol-control.ol-searchgps .ol-latitude,
.ol-control.ol-searchgps .ol-longitude {
  clear: both;
}
.ol-control.ol-searchgps .ol-latitude label,
.ol-control.ol-searchgps .ol-longitude label {
  width: 5.5em;
  display: inline-block;
  text-align: right;
  -webkit-transform: scaleX(.8);
          transform: scaleX(.8);
  margin: 0 -.8em 0 0;
  -webkit-transform-origin: 0 0;
          transform-origin: 0 0;
}
.ol-control.ol-searchgps .ol-latitude input,
.ol-control.ol-searchgps .ol-longitude input {
  max-width: 10em;
}

.ol-control.ol-searchgps .ol-ext-toggle-switch {
  cursor: pointer;
  float: right;
  margin: .5em;
  font-size: .9em;
}

.ol-searchgps .ol-decimal{
  display: inline-block;
  margin-right: .7em;
}
.ol-searchgps .ol-dms,
.ol-searchgps.ol-dms .ol-decimal {
  display: none;
  width: 3em;
  text-align: right;
}
.ol-searchgps.ol-dms .ol-dms {
  display: inline-block;
}

.ol-searchgps span.ol-dms {
  width: .5em;
  text-align: left;
}
.ol-searchgps.ol-control.ol-collapsed button.ol-geoloc {
  display: none;
}
.ol-searchgps button.ol-geoloc {
  top: 0;
  float: right;
  margin-right: 3px;
  background-image: none;
  position: relative;
}
.ol-searchgps button.ol-geoloc:before {
  content:"";
  position: absolute;
  left: 50%;
  top: 50%;
  width: .6em;
  height: .6em;
  border: .1em solid currentColor;
  border-radius: 50%;
  -webkit-transform: translate(-50%,-50%);
          transform: translate(-50%,-50%);
}
.ol-searchgps button.ol-geoloc:after {
  content:"";
  position: absolute;
  left: 50%;
  top: 50%;
  width: .2em;
  height: .2em;
  background-color: transparent;
  -webkit-transform: translate(-50%,-50%);
          transform: translate(-50%,-50%);
  -webkit-box-shadow: 
    .45em 0 currentColor, -.45em 0 currentColor, 0 -.45em currentColor, 0 .45em currentColor,
    .25em 0 currentColor, -.25em 0 currentColor, 0 -.25em currentColor, 0 .25em currentColor;
          box-shadow: 
    .45em 0 currentColor, -.45em 0 currentColor, 0 -.45em currentColor, 0 .45em currentColor,
    .25em 0 currentColor, -.25em 0 currentColor, 0 -.25em currentColor, 0 .25em currentColor;
}
.ol-control.ol-select {
  top: .5em;
  left: 3em;
  background-color: rgba(255,255,255,.5);
}
.ol-control.ol-select:hover {
  background-color: rgba(255,255,255,.7);
}
.ol-touch .ol-control.ol-select {
  left: 3.5em;
}
.ol-control.ol-select > button:before {
  content: "A";
  font-size: .6em;
  font-weight: normal;
  position: absolute;
  -webkit-box-sizing: content-box;
          box-sizing: content-box;
  width: 1em;
  height: 1em;
  background-color: transparent;
  border: .2em solid currentColor;
  border-radius: 100%;
  top: .5em;
  left: .5em;
  line-height: 1em;
  text-align: center;
}
.ol-control.ol-select > button:after {
  content: "";
  position: absolute;
  top: 1.15em;
  left: 1em;
  width: .45em;
  height: .15em;
  background-color: currentColor;
  border-radius: .05em;
  -webkit-transform: rotate(45deg);
          transform: rotate(45deg);
  -webkit-box-shadow: -0.18em 0 0 -0.03em;
          box-shadow: -0.18em 0 0 -0.03em;
}
.ol-select > div button {
  width: auto;
  padding: 0 .5em;
  float: right;
  font-weight: normal;
  height: 1.2em;
  line-height: 1.2em;
}
.ol-select .ol-delete {
    width: 1.5em;
  height: 1em;
  vertical-align: middle;
  display: inline-block;
  position: relative;
  cursor: pointer;
}
.ol-select .ol-delete:before {
  content:'\\00d7';
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  width: 100%;
  text-align: center;
  font-weight: bold;
}
.ol-control.ol-select input {
  font-size: 1em;
}
.ol-control.ol-select select {
  font-size: 1em;
  max-width: 10em;
}
.ol-control.ol-select select option.ol-default {
  color: #999;
  font-style: italic;
}
.ol-control.ol-select > div {
  display: block;
  margin: .25em;
}
.ol-control.ol-select.ol-collapsed > div {
  display: none;
}

.ol-control.ol-select.ol-select-check {
  max-width: 20em;
}
.ol-control.ol-select label.ol-ext-check {
  margin-right: 1em;
}
.ol-control.ol-select label.ol-ext-toggle-switch span {
  font-size: 1.1em;
}

.ol-select ul {
  list-style: none;
  margin: 0;
  padding: 0;
}
.ol-control.ol-select input[type="search"],
.ol-control.ol-select input[type="text"]  {
  width: 8em;
}

.ol-select .ol-autocomplete {
  display: inline;
}
.ol-select .ol-autocomplete ul {
  position: absolute;
  display: block;
  background: #fff;
  border: 1px solid #999;
  min-width: 10em;
  font-size: .85em;
}
.ol-select .ol-autocomplete ul li {
  padding: 0 .5em;
}
.ol-select .ol-autocomplete ul li:hover {
  color: #fff;
  background: rgba(0,60,136,.5);
}
.ol-select ul.ol-hidden {
  display: none;
}

.ol-select-multi li > div:hover,
.ol-select-multi li > div.ol-control.ol-select {
  position: relative;
  top: unset;
  left: unset;
  background: transparent;
}
.ol-select-multi li > div  > button,
.ol-select-multi li > div  .ol-ok {
  display: none;
}
.ol-select-multi li .ol-control.ol-select.ol-collapsed > div,
.ol-select-multi li > div  > div {
  display: block;
}

.ol-control.ol-status {
  top: 0;
  left: 0;
  background: rgba(0,0,0,.2);
  color: #fff;
  font-size: .9em;
  padding: .3em 3em;
  border-radius: 0;
  width: 100%;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  pointer-events: none!important;
  display: none;
}
.ol-control.ol-status.ol-visible {
  display: initial;
}
.ol-control.ol-status.ol-bottom {
  top: auto;
  bottom: 0;
}
.ol-control.ol-status.ol-left {
  top: 0;
  bottom: 0;
  padding: .3em .5em .3em 3em;
  width: auto;
}
.ol-control.ol-status.ol-right {
  top: 0;
  bottom: 0;
  left: auto;
  right: 0;
  padding: .3em 3em .3em .5em;
  width: auto;
}
.ol-control.ol-status.ol-center {
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
}

.ol-control.ol-storymap {
  top: .5em;
  left: .5em;
  bottom: .5em;
  max-width: 35%;
  border-radius: .5em;
  position: absolute;
  height: auto;
  background-color: rgba(255,255,255,.5);
}
.ol-storymap {
  overflow: hidden;
  padding: 0;
  height: 100%;
  position: relative;
}
.ol-storymap > div {
  overflow: hidden;
  padding: 0;
  height: 100%;
  position: relative;
  scroll-behavior: smooth;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}
.ol-storymap >div.ol-move {
  scroll-behavior: unset;
}

.ol-control.ol-storymap .chapter {
  position: relative;
  padding: .5em;
  overflow: hidden;
}
.ol-control.ol-storymap .chapter:last-child {
  margin-bottom: 100%;
}
.ol-storymap .chapter {
  cursor: pointer;
  opacity: .4;
}
.ol-storymap .chapter.ol-select {
  cursor: default;
  opacity: 1;
  background-color: rgba(255,255,255,.8);
}

.ol-storymap .ol-scroll-top,
.ol-storymap .ol-scroll-next {
  position: relative;
  min-height: 1.7em;
  color: rgba(0,60,136,.5);
  text-align: center;
  cursor: pointer;
}
.ol-storymap .ol-scroll-next span {
  padding-bottom: 1.4em;
  display: block;
}
.ol-storymap .ol-scroll-top span {
  padding-top: 1.4em;
  display: block;
}

.ol-storymap .ol-scroll-top:before,
.ol-storymap .ol-scroll-next:before {
  content: "";
  border: .3em solid currentColor;
  border-radius: .3em;
  border-color: transparent currentColor currentColor transparent;
  width: .8em;
  height: .8em;
  display: block;
  position: absolute;
  left: 50%;
  -webkit-transform: translateX(-50%) rotate(45deg);
          transform: translateX(-50%) rotate(45deg);
  -webkit-animation: ol-bounce-bottom 0.35s linear infinite alternate;
          animation: ol-bounce-bottom 0.35s linear infinite alternate;
  pointer-events: none;
}
.ol-storymap .ol-scroll-top:before {
  border-color: currentColor transparent transparent currentColor;
  -webkit-animation: ol-bounce-top 0.35s linear infinite alternate;
          animation: ol-bounce-top 0.35s linear infinite alternate;
}

@-webkit-keyframes ol-bounce-top{
  from {top: -.2em;}
  to   {top: .5em;}
}

@keyframes ol-bounce-top{
  from {top: -.2em;}
  to   {top: .5em;}
}
@-webkit-keyframes ol-bounce-bottom{
  from {bottom: -.2em;}
  to   {bottom: .5em;}
}
@keyframes ol-bounce-bottom{
  from {bottom: -.2em;}
  to   {bottom: .5em;}
}

.ol-storymap img[data-title] {
  cursor: pointer;
}

/* scrollLine / scrollbox */
.ol-storymap.scrollLine,
.ol-storymap.scrollBox {
  top: 0;
  bottom: 0;
  background-color: transparent;
  border-radius: 0;
  max-width: 40%;
}
.ol-storymap.scrollLine .chapter,
.ol-storymap.scrollBox .chapter {
  background-color: #fff;
  margin: 100% 0;
}
.ol-storymap.scrollLine .chapter:first-child,
.ol-storymap.scrollBox .chapter:first-child {
  margin-top: 3em;
}
.ol-storymap.scrollLine .chapter.ol-select,
.ol-storymap.scrollLine .chapter,
.ol-storymap.scrollBox .chapter.ol-select,
.ol-storymap.scrollBox .chapter {
  opacity: 1;
}

.ol-storymap.scrollLine .ol-scrolldiv,
.ol-storymap.scrollBox .ol-scrolldiv {
  padding-right: 30px;
}
.ol-storymap.scrollLine:before,
.ol-storymap.scrollBox:before {
  content: "";
  position: absolute;
  width: 2px;
  height: 100%;
  top: 0;
  bottom: 0;
  right: 14px;
  background-color: #fff;
}

.ol-storymap.scrollLine .ol-scroll,
.ol-storymap.scrollBox .ol-scroll {
  display: block!important;
  padding: 0;
  width: 1px;
  opacity: 1!important;
  right: 15px;
  overflow: visible;
  -webkit-transition: none;
  transition: none;
}
.ol-storymap.scrollLine .ol-scroll > div {
  background-color: transparent;
  overflow: visible;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  -webkit-box-shadow: unset;
          box-shadow: unset;
}
.ol-storymap.scrollLine .ol-scroll > div:before {
  content: "";
  position: absolute;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: #0af;
  border: 2px solid #fff;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}

.ol-storymap.scrollBox .ol-scroll > div {
  display: none;
}
.ol-storymap.scrollBox .chapter:after {
  content: "";
  width: 20px;
  height: 20px;
  position: absolute;
  top: Min(30%, 5em);
  right: -24.5px;
  -webkit-box-shadow: 0 0 0 2px #fff, inset 0 0 0 15px #0af;
          box-shadow: 0 0 0 2px #fff, inset 0 0 0 15px #0af; 
  border-radius: 50%;
  border: 5px solid transparent;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  z-index: 1;
}

.ol-swipe {
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -ms-touch-action: none;
      touch-action: none;
}

.ol-swipe:before {
  content: "";
  position: absolute;
  top: -5000px;
  bottom: -5000px;
  left: 50%;
  width: 4px;
  background: #fff;
  z-index:-1;
  -webkit-transform: translate(-2px, 0);
          transform: translate(-2px, 0);
}
.ol-swipe.horizontal:before {
  left: -5000px;
  right: -5000px;
  top: 50%;
  bottom: auto;
  width: auto;
  height: 4px;
}

.ol-swipe,
.ol-swipe button {
  cursor: ew-resize;
}
.ol-swipe.horizontal,
.ol-swipe.horizontal button {
  cursor: ns-resize;
}

.ol-swipe:after,
.ol-swipe button:before,
.ol-swipe button:after {
  content: "";
  position: absolute;
  top: 25%;
  bottom: 25%;
  left: 50%;
  width: 2px;
  background: currentColor;
  transform: translate(-1px, 0);
  -webkit-transform: translate(-1px, 0);
}
.ol-swipe button:after {
  -webkit-transform: translateX(4px);
          transform: translateX(4px);
}
.ol-swipe button:before {
  -webkit-transform: translateX(-6px);
          transform: translateX(-6px);
}

.ol-control.ol-timeline {
  bottom: 0;
  left: 0;
  right: 0;
  -webkit-transition: .3s;
  transition: .3s;
  background-color: rgba(255,255,255,.4);
}
.ol-control.ol-timeline.ol-collapsed {
  -webkit-transform: translateY(100%);
          transform: translateY(100%);
}
.ol-timeline {
  overflow: hidden;
  padding: 2px 0 0;
}
.ol-timeline .ol-scroll {
  overflow: hidden;
  padding: 0;
  scroll-behavior: smooth;
  line-height: 1em;
  height: 6em;
  padding: 0 50%;
}
.ol-timeline .ol-scroll.ol-move {
  scroll-behavior: unset;
}

.ol-timeline.ol-hasbutton .ol-scroll {
  margin-left: 1.5em;
  padding: 0 calc(50% - .75em);
}
.ol-timeline .ol-buttons {
  display: none;
  position: absolute;
  top: 0;
  background: rgba(255,255,255,.5);
  width: 1.5em;
  bottom: 0;
  left: 0;
  z-index: 10;
}
.ol-timeline.ol-hasbutton .ol-buttons {
  display: block;
}
.ol-timeline .ol-buttons button {
  font-size: 1em;
  margin: 1px;
  position: relative;
}
.ol-timeline .ol-buttons .ol-zoom-in:before,
.ol-timeline .ol-buttons .ol-zoom-out:before {
  content: "+";
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-timeline .ol-buttons .ol-zoom-out:before{
  content: '−';
}

.ol-timeline .ol-scroll > div {
  height: 100%;
  position: relative;
}

.ol-timeline .ol-scroll .ol-times {
  background: rgba(255,255,255,.5);
  height: 1em;
  bottom: 0;
  position: absolute;
  left: -1000px;
  right: -1000px;
}
.ol-timeline .ol-scroll .ol-time {
  position: absolute;
  font-size: .7em;
  color: #999;
  bottom: 0;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
}
.ol-timeline .ol-scroll .ol-time.ol-year {
  color: #666;
  z-index: 1;
}
.ol-timeline .ol-scroll .ol-time:before {
  content: "";
  position: absolute;
  bottom: 1.2em;
  left: 50%;
  height: 500px;
  border-left: 1px solid currentColor;
}

.ol-timeline .ol-scroll .ol-features {
  position: absolute;
  top: 0;
  bottom: 1em;
  left: -200px;
  right: -1000px;
  margin: 0 0 0 200px;
  overflow: hidden;
}

.ol-timeline .ol-scroll .ol-feature {
  position: absolute;
  font-size: .7em;
  color: #999;
  top: 0;
  background: #fff;
  max-width: 3em;
  max-height: 2.4em;
  min-height: 1em;
  line-height: 1.2em;
  border: 1px solid #ccc;
  overflow: hidden;
  padding: 0 .5em 0 0;
  -webkit-transition: all .3s;
  transition: all .3s;
  cursor: pointer;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}

.ol-timeline.ol-zoomhover .ol-scroll .ol-feature:hover,
.ol-timeline.ol-zoomhover .ol-scroll .ol-feature.ol-select {
  z-index: 1;
  -webkit-transform: scale(1.2);
          transform: scale(1.2);
  background: #eee;
  /* max-width: 14em!important; */
}

/* Center */
.ol-timeline .ol-center-date {
  display: none;
  position: absolute;
  left: 50%;
  height: 100%;
  width: 2px;
  bottom: 0;
  z-index: 2;
  pointer-events: none;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  background-color: #f00;
  opacity: .4;
}
.ol-timeline.ol-hasbutton .ol-center-date {
  left: calc(50% + .75em);
}

/* Show center */ 
.ol-timeline.ol-pointer .ol-center-date {
  display: block;
}
.ol-timeline.ol-pointer .ol-center-date:before, 
.ol-timeline.ol-pointer .ol-center-date:after {
  content: '';
  border: 0.3em solid transparent;
  border-width: .3em .25em;
  position: absolute;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
}
.ol-timeline.ol-pointer .ol-center-date:before {
  border-top-color: #f00;
  top: 0;
}
.ol-timeline.ol-pointer .ol-center-date:after {
  border-bottom-color: #f00;
  bottom: 0
}

/* show interval */
.ol-timeline.ol-interval .ol-center-date {
  display: block;
  background-color: transparent;
  border: 0 solid #000;
  border-width: 0 10000px;
  -webkit-box-sizing: content-box;
          box-sizing: content-box;
  opacity: .2;
}
.ol-control.ol-videorec {
  top: 0;
  left: 50%;
  -webkit-transform: translateX(-50%);
          transform: translateX(-50%);
  white-space: nowrap;
}

.ol-control.ol-videorec button {
  position: relative;
  display: inline-block;
  vertical-align: middle;
}

.ol-control.ol-videorec button:before {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: .8em;
  height: .8em;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  background-color: currentColor;
}
.ol-control.ol-videorec button.ol-start:before {
  width: .9em;
  height: .9em;
  border-radius: 50%;
  background-color: #c00;
}
.ol-control.ol-videorec button.ol-pause:before {
  width: .2em;
  background-color: transparent;
  -webkit-box-shadow: -.2em 0, .2em 0;
          box-shadow: -.2em 0, .2em 0;
}
.ol-control.ol-videorec button.ol-resume:before {
  border-style: solid;
  background: transparent;
  width: auto;
  border-width: .4em 0 .4em .6em;
  border-color: transparent transparent transparent currentColor;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}

.ol-control.ol-videorec button.ol-stop,
.ol-control.ol-videorec button.ol-pause,
.ol-control.ol-videorec button.ol-resume,
.ol-control.ol-videorec[data-state="rec"] .ol-start,
.ol-control.ol-videorec[data-state="pause"] .ol-start {
  display: none;
}
.ol-control.ol-videorec[data-state="rec"] .ol-stop,
.ol-control.ol-videorec[data-state="pause"] .ol-stop,
.ol-control.ol-videorec[data-state="rec"] .ol-pause,
.ol-control.ol-videorec[data-state="pause"] .ol-resume {
  display: inline-block;
}

.ol-control.ol-wmscapabilities {
  top: .5em;
  right: 2.5em;
}
.ol-touch .ol-control.ol-wmscapabilities {
  right: 3em;
}
.ol-control.ol-wmscapabilities.ol-hidden {
  display: none;
}
.ol-control.ol-wmscapabilities button:before {
  content: "+";
  position: absolute;
  top: calc(50% - .35em);
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-control.ol-wmscapabilities button:after {
  content: "";
  width: .75em;
  height: .75em;
  position: absolute;
  background: transparent;
  top: calc(50% - .05em);
  left: 50%;
  -webkit-transform: scaleY(.6) translate(-50%, -50%) rotate(45deg);
          transform: scaleY(.6) translate(-50%, -50%) rotate(45deg);
  -webkit-box-shadow: inset -.18em -.18em currentColor, -.4em .1em 0 -.25em currentColor, .1em -.35em 0 -.25em currentColor, .15em .15em currentColor;
          box-shadow: inset -.18em -.18em currentColor, -.4em .1em 0 -.25em currentColor, .1em -.35em 0 -.25em currentColor, .15em .15em currentColor;
  border-radius: .1em 0;
  border: .15em solid transparent;
  border-width: 0 .15em .15em 0;
}

.ol-wmscapabilities .ol-searching {
  opacity: .5;
}
.ol-wmscapabilities .ol-searching .ol-url:after{
  content: "";
  width: .7em;
  height: .7em;
  background-color: currentColor;
  position: absolute;
  top: 6em;
  border-radius: 50%;
  display: block;
  left: calc(50% - .35em);
  -webkit-box-shadow: 0 1em currentColor, 0 -1em currentColor, 1em 0 currentColor, -1em 0 currentColor;
          box-shadow: 0 1em currentColor, 0 -1em currentColor, 1em 0 currentColor, -1em 0 currentColor;
  -webkit-animation:ol-wmscapabilities-rotate 2s linear infinite;
          animation:ol-wmscapabilities-rotate 2s linear infinite;
}
@-webkit-keyframes ol-wmscapabilities-rotate { 
  100% { -webkit-transform:rotate(360deg); transform:rotate(360deg); } 
}
@keyframes ol-wmscapabilities-rotate { 
  100% { -webkit-transform:rotate(360deg); transform:rotate(360deg); } 
}

.ol-wmscapabilities .ol-url input {
  width: calc(100% - 10em);
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  min-width: Min(100%, 20em);
}
.ol-wmscapabilities .ol-url select {
  width: 2em;
  height: 100%;
  padding: 1px;
}
.ol-wmscapabilities .ol-url button {
  width: 7.5em;
  margin-left: .5em;
}
.ol-wmscapabilities .ol-result {
  display: none;
  margin-top: .5em;
}
.ol-wmscapabilities .ol-result.ol-visible {
  display: block;
}

.ol-wmscapabilities .ol-select-list {
  position: relative;
  border: 1px solid #369;
  overflow-x: hidden;
  width: calc(100% - 120px);
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  max-height: 14.5em;
}
.ol-wmscapabilities .ol-select-list div {
  padding: 0 .5em;
  cursor: pointer;
  width: 100%;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  text-overflow: ellipsis;
  overflow: hidden;
}
.ol-wmscapabilities .ol-select-list .level-1 {
  padding-left: 1em;
}
.ol-wmscapabilities .ol-select-list .level-2 {
  padding-left: 1.5em;
}
.ol-wmscapabilities .ol-select-list .level-3 {
  padding-left: 2em;
}
.ol-wmscapabilities .ol-select-list .level-4 {
  padding-left: 2.5em;
}
.ol-wmscapabilities .ol-select-list .level-5 {
  padding-left: 3em;
}

.ol-wmscapabilities .ol-select-list .ol-info {
  font-style: italic;
}
.ol-wmscapabilities .ol-select-list .ol-title {
  background-color: rgba(0,60,136,.1);
}
.ol-wmscapabilities .ol-select-list div:hover {
  background-color: rgba(0,60,136,.5);
  color: #fff;
}
.ol-wmscapabilities .ol-select-list div.selected {
  background-color: rgba(0,60,136,.7);
  color: #fff;
}

.ol-wmscapabilities .ol-preview {
  width: 100px;
  float: right;
  background: rgba(0,60,136,.1);
  color: #666;
  padding: 0 5px 5px;
  text-align: center;
  margin-left: 10px;
}
.ol-wmscapabilities .ol-preview.tainted {
  width: 100px;
  float: right;
  background: rgba(136,0,60,.1);
  color: #666;
  padding: 0 5px 5px;
  text-align: center;
  margin-left: 10px;
}
.ol-wmscapabilities .ol-preview img {
  width: 100%;
  display: block;
  background: #fff;
}
.ol-wmscapabilities .ol-legend {
  max-width: 100%;
  display: none;
}
.ol-wmscapabilities .ol-legend.visible {
  display: block;
}
.ol-wmscapabilities .ol-buttons {
  clear: both;
  text-align: right;
}
.ol-wmscapabilities .ol-data p {
  margin: 0;
}
.ol-wmscapabilities .ol-data p.ol-title {
  font-weight: bold;
  margin: 1em 0 .5em;
}
.ol-wmscapabilities .ol-error {
  color: #800;
}

.ol-wmscapabilities ul.ol-wmsform {
  display: none;
  list-style: none;
  padding: 0;
}
.ol-wmscapabilities ul.ol-wmsform.visible {
  display: block;
}
.ol-wmscapabilities .ol-wmsform label {
  display: inline-block;
  text-align: right;
  width: calc(40% - .5em);
  margin-right: .5em;
}
.ol-wmscapabilities .ol-wmsform input {
  display: inline-block;
  width: 60%;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-wmscapabilities .ol-wmsform input[type="checkbox"] {
  width: auto;
}
.ol-wmscapabilities .ol-wmsform button {
  float: right;
  margin: 1em 0;
}

.ol-wmscapabilities ul.ol-wmsform li[data-param="extent"] input {
  width: calc(60% - 2em);
}
.ol-wmscapabilities ul.ol-wmsform li[data-param="extent"] button {
  position: relative;
  width: 2em;
  height: 1.6em;
  margin: 0;
  vertical-align: middle;
  color: #444;
}
.ol-wmscapabilities ul.ol-wmsform li[data-param="extent"] button:before,
.ol-wmscapabilities ul.ol-wmsform li[data-param="extent"] button:after {
  content: "";
  position: absolute;
  width: .25em;
  height: .9em;
  border: .1em solid currentColor;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) skewY(-15deg);
          transform: translate(-50%, -50%) skewY(-15deg);
}
.ol-wmscapabilities ul.ol-wmsform li[data-param="extent"] button:after {
  -webkit-transform: translateX(.4em) translate(-50%, -50%) skewY(15deg);
          transform: translateX(.4em) translate(-50%, -50%) skewY(15deg);
  -webkit-box-shadow: -0.8em 0.25em;
          box-shadow: -0.8em 0.25em;
}

.ol-ext-dialog.ol-wmscapabilities form {
  width: 600px;
  min-height: 15em;
  top: 15%;
  -webkit-transform: translate(-50%, -15%);
          transform: translate(-50%, -15%);
}
.ol-ext-dialog.ol-wmscapabilities .ol-content {
  max-height: calc(100vh - 6em);
}

.ol-ext-dialog.ol-wmtscapabilities [data-param="map"] {
  display: none;
}
.ol-ext-dialog [data-param="style"] {
  display: none;
}
.ol-ext-dialog.ol-wmtscapabilities [data-param="style"] {
  display: list-item;
}
.ol-ext-dialog.ol-wmtscapabilities [data-param="proj"],
.ol-ext-dialog.ol-wmtscapabilities [data-param="version"] {
  opacity: .6;
  pointer-events: none;
}

.ol-ext-dialog.ol-wmscapabilities button.ol-wmsform {
  width: 1.8em;
  text-align: center;
}
.ol-ext-dialog.ol-wmscapabilities button.ol-wmsform:before {
  content: "+";
}
.ol-ext-dialog.ol-wmscapabilities .ol-form button.ol-wmsform:before {
  content: "-";
}

.ol-ext-dialog.ol-wmscapabilities .ol-form button.ol-load,
.ol-ext-dialog.ol-wmscapabilities .ol-form .ol-legend {
  display: none;
}
.ol-ext-dialog.ol-wmscapabilities .ol-form ul.ol-wmsform {
  display: block;
  clear: both;
}
.ol-target-overlay .ol-target 
{	border: 1px solid transparent;
	-webkit-box-shadow: 0 0 1px 1px #fff;
	        box-shadow: 0 0 1px 1px #fff;
	display: block;
	height: 20px;
	width: 0;
}

.ol-target-overlay .ol-target:after,
.ol-target-overlay .ol-target:before
{	content:"";
	border: 1px solid #369;
	-webkit-box-shadow: 0 0 1px 1px #fff;
	        box-shadow: 0 0 1px 1px #fff;
	display: block;
	width: 20px;
	height: 0;
	position:absolute;
	top:10px;
	left:-10px;
}
.ol-target-overlay .ol-target:after
{	-webkit-box-shadow: none;	box-shadow: none;
	height: 20px;
	width: 0;
	top:0px;
	left:0px;
}

.ol-overlaycontainer .ol-touch-cursor {
  /* human fingertips are typically 16x20 mm = 45x57 pixels
    source: http://touchlab.mit.edu/publications/2003_009.pdf
  */
  width: 56px;
  height: 56px;
  margin: 6px;
  border-radius: 50%;
  cursor: pointer;
  background: rgba(255,255,255,.4);
  -webkit-box-shadow: inset 0 0 0 5px #369;
          box-shadow: inset 0 0 0 5px #369;
}

.ol-overlaycontainer .ol-touch-cursor:after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 50%;
  height: 50%;
  background: radial-gradient(circle at 100% 100%, transparent, transparent 70%, #369 70%, #369)
}

.ol-overlaycontainer .ol-touch-cursor .ol-button {
  position: absolute;
  color: #369;
  height: 55%;
  width: 55%;
  border-radius: 50%;
  cursor: pointer;
  background: rgba(255,255,255,.4);
  -webkit-box-shadow: inset 0 0 0 3px currentColor;
          box-shadow: inset 0 0 0 3px currentColor;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) scale(0);
          transform: translate(-50%, -50%) scale(0);
  -webkit-transition: all .5s, opacity 0s, background 0s;
  transition: all .5s, opacity 0s, background 0s;
  overflow: hidden;
}
.ol-overlaycontainer .ol-touch-cursor.active.disable .ol-button {
  opacity: .8;
  background: rgba(51, 102, 153, .2);
}
.ol-overlaycontainer .ol-touch-cursor.active .ol-button {
  -webkit-transform: translate(-50%, -50%) scale(1);
          transform: translate(-50%, -50%) scale(1);
}
.ol-overlaycontainer .ol-touch-cursor.active .ol-button-0 {
  top: -18%;
  left: 118%;
}
.ol-overlaycontainer .ol-touch-cursor.active .ol-button-1 {
  top: 50%;
  left: 140%;
}
.ol-overlaycontainer .ol-touch-cursor.active .ol-button-2 {
  top: 120%;
  left: 120%;
}
.ol-overlaycontainer .ol-touch-cursor.active .ol-button-3 {
  top: 140%;
  left: 50%;
}
.ol-overlaycontainer .ol-touch-cursor.active .ol-button-4 {
  top: 118%;
  left: -18%;
}
/* extra buttons */
.ol-overlaycontainer .ol-touch-cursor.active .ol-button-5 {
  top: 50%;
  left: -40%;
}
.ol-overlaycontainer .ol-touch-cursor.active .ol-button-6 {
  top: -18%;
  left: -18%;
}
.ol-overlaycontainer .ol-touch-cursor.active .ol-button-7 {
  top: -40%;
  left: 50%;
}

.ol-overlaycontainer .ol-touch-cursor .ol-button:before {
  content: "";
  width: 1.5em;
  height: 1em;
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  line-height: 1em;
  text-align: center;
}
.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-add:before,
.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-remove:before {
  content: "−";
  line-height: .95em;
  font-size: 1.375em;
  font-weight: bold;
}
.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-add:before {
  content: "+";
}
.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-x:before {
  content: "\\00D7";
  font-size: 1.2em;
  font-weight: bold;
}
.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-move:before {
  content: "\\2725";
  font-size: 1.2em;
}
.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-check:before {
  content: "\\2713";
  font-weight: bold;
}

.ol-overlaycontainer .ol-touch-cursor.nodrawing .ol-button.ol-button-x,
.ol-overlaycontainer .ol-touch-cursor.nodrawing .ol-button.ol-button-remove,
.ol-overlaycontainer .ol-touch-cursor.nodrawing .ol-button.ol-button-check {
  opacity: .8;
  background: rgba(51, 102, 153, .2);
}

.ol-overlaycontainer .ol-touch-cursor .ol-button > div {
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}

.ol-overlaycontainer .ol-touch-cursor .ol-button-type:before {
  content: "\\21CE";
  font-weight: bold;
}



/* remove outline on focus */
.mapboxgl-canvas:focus {
  outline: none;
}
.ol-perspective-map {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 200%;
  height: 200%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-perspective-map .ol-layer {
  z-index: -1!important; /* bug using Chrome ? */
}
.ol-perspective-map .ol-layers {
  -webkit-transform: translateY(0) perspective(200px) rotateX(0deg) scaleY(1);
          transform: translateY(0) perspective(200px) rotateX(0deg) scaleY(1);
}

.ol-perspective-map .ol-overlaycontainer,
.ol-perspective-map .ol-overlaycontainer-stopevent {
  width: 50%!important;
  height: 50%!important;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}

.ol-overlay-container .ol-magnify 
{	background: rgba(0,0,0, 0.5);
	border:3px solid #369;
	border-radius: 50%;
	height: 150px;
	width: 150px;
	overflow: hidden;
	-webkit-box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5);
	        box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5);
	position:relative;
	z-index:0;
}

.ol-overlay-container .ol-magnify:before 
{	border-radius: 50%;
	-webkit-box-shadow: 0 0 40px 2px rgba(0, 0, 0, 0.25) inset;
	        box-shadow: 0 0 40px 2px rgba(0, 0, 0, 0.25) inset;
	content: "";
	display: block;
	height: 100%;
	left: 0;
	position: absolute;
	top: 0;
	width: 100%;
	z-index: 1;
}

.ol-overlay-container .ol-magnify:after 
{
	border-radius: 50%;
	-webkit-box-shadow: 0 0 20px 7px rgba(255, 255, 255, 1);
	        box-shadow: 0 0 20px 7px rgba(255, 255, 255, 1);
	content: "";
	display: block;
	height: 0;
	left: 23%;
	position: absolute;
	top: 20%;
	width: 20%;
	z-index: 1;
	transform: rotate(-40deg);
	-webkit-transform: rotate(-40deg);
}
/** popup animation using visible class
*/
.ol-popup.anim {
  visibility: hidden;
}

.ol-popup.anim.visible {
  visibility: visible;
}
/** No transform when visible 
*/
.ol-popup.anim.visible > div {
  visibility: visible;
  -webkit-transform: none;
          transform: none;
  -webkit-animation: ol-popup_bounce 0.4s ease 1;
          animation: ol-popup_bounce 0.4s ease 1;
}

@-webkit-keyframes ol-popup_bounce {
  from { -webkit-transform: scale(0); transform: scale(0); }
  50%  { -webkit-transform: scale(1.1); transform: scale(1.1) }
  80%  { -webkit-transform: scale(0.95); transform: scale(0.95) }
  to   { -webkit-transform: scale(1); transform: scale(1); }
}

@keyframes ol-popup_bounce {
  from { -webkit-transform: scale(0); transform: scale(0); }
  50%  { -webkit-transform: scale(1.1); transform: scale(1.1) }
  80%  { -webkit-transform: scale(0.95); transform: scale(0.95) }
  to   { -webkit-transform: scale(1); transform: scale(1); }
}

/** Transform Origin */
.ol-popup.anim.ol-popup-bottom.ol-popup-left > div  {
  -webkit-transform-origin:0 100%;
          transform-origin:0 100%;
}
.ol-popup.anim.ol-popup-bottom.ol-popup-right > div {
  -webkit-transform-origin:100% 100%;
          transform-origin:100% 100%;
}
.ol-popup.anim.ol-popup-bottom.ol-popup-center > div {
  -webkit-transform-origin:50% 100%;
          transform-origin:50% 100%;
}
.ol-popup.anim.ol-popup-top.ol-popup-left > div {
  -webkit-transform-origin:0 0;
          transform-origin:0 0;
}
.ol-popup.anim.ol-popup-top.ol-popup-right > div {
  -webkit-transform-origin:100% 0;
          transform-origin:100% 0;
}
.ol-popup.anim.ol-popup-top.ol-popup-center > div {
  -webkit-transform-origin:50% 0;
          transform-origin:50% 0;
}
.ol-popup.anim.ol-popup-middle.ol-popup-left > div {
  -webkit-transform-origin:0 50%;
          transform-origin:0 50%;
}
.ol-popup.anim.ol-popup-middle.ol-popup-right > div {
  -webkit-transform-origin:100% 50%;
          transform-origin:100% 50%;
}

.ol-overlaycontainer-stopevent {
  /* BOUG ol6.1 to enable DragOverlay interaction 
  position: initial!important;
  */
}

/** ol.popup */
.ol-popup {
  font-size:0.9em;
  -webkit-user-select: none;  
  -moz-user-select: none;    
  -ms-user-select: none;      
  user-select: none;
}
.ol-popup .ol-popup-content {
  overflow:hidden;
  cursor: default;
  padding: 0.25em 0.5em;
}
.ol-popup.hasclosebox .ol-popup-content {
  margin-right: 1.7em;
}
.ol-popup .ol-popup-content:after {
  clear: both;
  content: "";
  display: block;
  font-size: 0;
  height: 0;
}

/** Anchor position */
.ol-popup .anchor {
  display: block;
  width: 0px;
  height: 0px;
  background:red;
  position: absolute;
  margin: -11px 22px;
  pointer-events: none;
}
.ol-popup .anchor:after,
.ol-popup .anchor:before {
  position:absolute;
}
.ol-popup-right .anchor:after,
.ol-popup-right .anchor:before {
  right:0;
}
.ol-popup-top .anchor { top:0; }
.ol-popup-bottom .anchor { bottom:0; }
.ol-popup-right .anchor { right:0; }
.ol-popup-left .anchor { left:0; }
.ol-popup-center .anchor { 
  left:50%; 
  margin-left: 0!important;
}
.ol-popup-middle .anchor { 
  top:50%; 
  margin-top: 0!important;
}
.ol-popup-center.ol-popup-middle .anchor { 
  display:none; 
}

/** Fixed popup */
.ol-popup.ol-fixed {
  margin: 0!important;
  top: .5em!important;
  right: .5em!important;
  left: auto!important;
  bottom: auto!important;
  -webkit-transform: none!important;
          transform: none!important;
}
.ol-popup.ol-fixed .anchor {
  display: none;
}
.ol-popup.ol-fixed.anim > div {
  -webkit-animation: none;
          animation: none;
}

.ol-popup .ol-fix {
  width: 1em;
  height: .9em;
  background: #fff;
  position: relative;
  float: right;
  margin: .2em;
  cursor: pointer;
}
.ol-popup .ol-fix:before {
  content: "";
  width: .8em;
  height: .7em;
  display: block;
  border: .1em solid #666;
      border-right-width: 0.1em;
  border-right-width: .3em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  margin: .1em;
}

/** Add a shadow to the popup */
.ol-popup.shadow {
  -webkit-box-shadow: 2px 2px 2px 2px rgba(0,0,0,0.5);
          box-shadow: 2px 2px 2px 2px rgba(0,0,0,0.5);
}

/** Close box */
.ol-popup .closeBox {
  background-color: rgba(0, 60, 136, 0.5);
  color: #fff;
  border: 0;
  border-radius: 2px;
  cursor: pointer;
  float: right;
  font-size: 0.9em;
  font-weight: 700;
  width: 1.4em;
  height: 1.4em;
  margin: 5px 5px 0 0;
  padding: 0;
  position: relative;
  display:none;
}
.ol-popup.hasclosebox .closeBox {
  display:block;
}

.ol-popup .closeBox:hover {
  background-color: rgba(0, 60, 136, 0.7);
}
/* the X */
.ol-popup .closeBox:after {
  content: "\\00d7";
  font-size:1.5em;
  top: 50%;
  left: 0;
  right: 0;
  width: 100%;
  text-align: center;
  line-height: 1em;
  margin: -0.5em 0;
  position: absolute;
}

/** Modify touch poup */
.ol-popup.modifytouch {
  background-color: #eee;
}
.ol-popup.modifytouch .ol-popup-content {	
  padding: 0 0.25em;
  font-size: 0.85em;
  white-space: nowrap;
}
.ol-popup.modifytouch .ol-popup-content a {
  text-decoration: none;
}

/** Tool tips popup*/
.ol-popup.tooltips {
  background-color: #ffa;
}
.ol-popup.tooltips .ol-popup-content{
  padding: 0 0.25em;
  font-size: 0.85em;
  white-space: nowrap;
}

/** Default popup */
.ol-popup.default > div {
  background-color: #fff;
  border:1px solid #69f;
  border-radius: 5px;
}
.ol-popup.default {
  margin: -11px 0;
  -webkit-transform: translate(0, -22px);
          transform: translate(0, -22px);
}
.ol-popup-top.ol-popup.default {
  margin: 11px 0;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-left.default {
  margin: -11px -22px;
  -webkit-transform: translate(0, -22px);
          transform: translate(0, -22px);
}
.ol-popup-top.ol-popup-left.default {
  margin: 11px -22px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-right.default {
  margin: -11px 22px;
  -webkit-transform: translate(44px, -22px);
          transform: translate(44px, -22px);
}
.ol-popup-top.ol-popup-right.default {
  margin: 11px 22px;
  -webkit-transform: translate(44px, 0);
          transform: translate(44px, 0);
}
.ol-popup-middle.default {
  margin:0 10px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-middle.ol-popup-right.default {
  margin:0 -10px;
  -webkit-transform: translate(-20px, 0);
          transform: translate(-20px, 0);
}

.ol-popup.default .anchor {
  color: #69f;
}
.ol-popup.default .anchor:after,
.ol-popup.default .anchor:before {
  content:"";
  border-color: currentColor transparent;
  border-style: solid;
  border-width: 11px;
  margin: 0 -11px;
}
.ol-popup.default .anchor:after {
  border-color: #fff transparent;
  border-width: 11px;
  margin: 2px -11px;
}

.ol-popup-top.default .anchor:before,
.ol-popup-top.default .anchor:after {
  border-top:0;
  top:0;
}

.ol-popup-bottom.default .anchor:before,
.ol-popup-bottom.default .anchor:after {
  border-bottom:0;
  bottom:0;
}

.ol-popup-middle.default .anchor:before {
  margin: -11px -33px;
  border-color: transparent currentColor;
}
.ol-popup-middle.default .anchor:after {
  margin: -11px -31px;
  border-color: transparent #fff;
}
.ol-popup-middle.ol-popup-left.default .anchor:before,
.ol-popup-middle.ol-popup-left.default .anchor:after {
  border-left:0;
}
.ol-popup-middle.ol-popup-right.default .anchor:before,
.ol-popup-middle.ol-popup-right.default .anchor:after {
  border-right:0;
}

/** Placemark popup */
.ol-popup.placemark {
  color: #c00;
  margin: -.65em 0;
  -webkit-transform: translate(0, -1.3em);
          transform: translate(0, -1.3em);
}
.ol-popup.placemark > div {
  position: relative;
  font-size: 15px;	
  background-color: #fff;
  border: 0;
  -webkit-box-shadow: inset 0 0 0 0.45em;
          box-shadow: inset 0 0 0 0.45em;
  width: 2em;
  height: 2em;
  border-radius: 50%;
  min-width: unset;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-popup.placemark .ol-popup-content {
  overflow: hidden;
  cursor: default;
  text-align: center;
  padding: .25em 0;
  width: 1em;
  height: 1em;
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  line-height: 1em;
}
.ol-popup.placemark .anchor {
  margin: 0;
}

.ol-popup.placemark .anchor:before {
  content: "";
  margin: -.5em -.5em;
  background: transparent;
  width: 1em;
  height: .5em;
  border-radius: 50%;
  -webkit-box-shadow: 0 1em 0.5em rgba(0,0,0,.5);
          box-shadow: 0 1em 0.5em rgba(0,0,0,.5);
}
.ol-popup.placemark .anchor:after {
  content: "";
  border-color: currentColor transparent;
  border-style: solid;
  border-width: 1em .7em 0;
  margin: -.75em -.7em;
  bottom:0;
}

/** Placemark Shield */
.ol-popup.placemark.shield > div {
  border-radius: .2em;
}

.ol-popup.placemark.shield .anchor:after {
    border-width: .8em 1em 0;
    margin: -.7em -1em;
}

/** Placemark Blazon */
.ol-popup.placemark.blazon > div {
  border-radius: .2em;
}

/** Placemark Needle/Pushpin */
.ol-popup.placemark.pushpin {	
  margin: -2.2em 0;
  -webkit-transform: translate(0, -4em);
          transform: translate(0, -4em);
}
.ol-popup.placemark.pushpin > div {	
  border-radius: 0;
  background: transparent!important;
  -webkit-box-shadow: inset 2em 0 currentColor;
          box-shadow: inset 2em 0 currentColor;
  width: 1.1em;
}
.ol-popup.placemark.pushpin > div:before {
  content: "";
  width: 1.3em;
  height: 1.5em;
  border-style: solid;
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%,-50%);
          transform: translate(-50%,-50%);
  border-color: currentColor transparent;
  border-width: .3em .5em .5em;
  pointer-events: none;
}

.ol-popup.placemark.needle {	
  margin: -2em 0;
  -webkit-transform: translate(0, -4em);
          transform: translate(0, -4em);
}
.ol-popup.placemark.pushpin .anchor,
.ol-popup.placemark.needle .anchor {
  margin: -1.2em;
}
.ol-popup.placemark.pushpin .anchor:after,
.ol-popup.placemark.needle .anchor:after {
  border-style: solid;
    border-width: 2em .15em 0;
    margin: -.55em -0.2em;
    width: .1em;
}
.ol-popup.placemark.pushpin .anchor:before,
.ol-popup.placemark.needle .anchor:before {
    margin: -.75em -.5em;
}

/** Placemark Flag */
.ol-popup.placemark.flagv {
  margin: -2em 1em;
  -webkit-transform: translate(0, -4em);
          transform: translate(0, -4em);
}
.ol-popup.placemark.flagv > div {
  border-radius: 0;
  -webkit-box-shadow: none;
          box-shadow: none;
  background-color: transparent;
}
.ol-popup.placemark.flagv > div:before {
  content: "";
  border: 1em solid transparent;
  position: absolute;
  border-left: 2em solid currentColor;
  pointer-events: none;
}
.ol-popup.placemark.flagv .anchor {
  margin: -1.4em;
}

.ol-popup.placemark.flag {	
  margin: -2em 1em;
  -webkit-transform: translate(0, -4em);
          transform: translate(0, -4em);
}
.ol-popup.placemark.flag > div {	
  border-radius: 0;
  -webkit-transform-origin: 0% 150%!important;
          transform-origin: 0% 150%!important;
}
.ol-popup.placemark.flag .anchor {
  margin: -1.4em;
}
.ol-popup.placemark.flagv .anchor:after, 
.ol-popup.placemark.flag .anchor:after {
  border-style: solid;
  border-width: 2em .15em 0;
  margin: -.55em -1em;
  width: .1em;
}
.ol-popup.placemark.flagv .anchor:before,
.ol-popup.placemark.flag .anchor:before {
  margin: -.75em -1.25em;
}

.ol-popup.placemark.flag.finish {
  margin: -2em 1em;
}
.ol-popup.placemark.flag.finish > div {
  background-image: 
    linear-gradient(45deg, currentColor 25%, transparent 25%, transparent 75%, currentColor 75%, currentColor), 
    linear-gradient(45deg, currentColor 25%, transparent 25%, transparent 75%, currentColor 75%, currentColor);
  background-size: 1em 1em;
  background-position: .5em 0, 0 .5em;
  -webkit-box-shadow: inset 0 0 0 .25em;
          box-shadow: inset 0 0 0 .25em;
}

/** Black popup */
.ol-popup.black .closeBox {
  background-color: rgba(0,0,0, 0.5);
  border-radius: 5px;
  color: #f80;
}
.ol-popup.black .closeBox:hover {
  background-color: rgba(0,0,0, 0.7);
  color:#da2;
}

.ol-popup.black {
  margin: -20px 0;
  -webkit-transform: translate(0, -40px);
          transform: translate(0, -40px);
}
.ol-popup.black > div{
  background-color: rgba(0,0,0,0.6);
  border-radius: 5px;
  color:#fff;
}
.ol-popup-top.ol-popup.black {
  margin: 20px 0;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-left.black {
  margin: -20px -22px;
  -webkit-transform: translate(0, -40px);
          transform: translate(0, -40px);
}
.ol-popup-top.ol-popup-left.black {
  margin: 20px -22px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-right.black {
  margin: -20px 22px;
  -webkit-transform: translate(44px, -40px);
          transform: translate(44px, -40px);
}
.ol-popup-top.ol-popup-right.black {
  margin: 20px 22px;
  -webkit-transform: translate(44px, 0);
          transform: translate(44px, 0);
}
.ol-popup-middle.black {
  margin: 0 11px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-left.ol-popup-middle.black {
  -webkit-transform: none;
          transform: none;
}
.ol-popup-right.ol-popup-middle.black {
  margin:0 -11px;
  -webkit-transform: translate(-22px, 0);
          transform: translate(-22px, 0);
}

.ol-popup.black .anchor {
  margin: -20px 11px;
  color: rgba(0,0,0,0.6);
} 
.ol-popup.black .anchor:before {
  content:"";
  border-color: currentColor transparent;
  border-style: solid;
  border-width: 20px 11px;
}

.ol-popup-top.black .anchor:before {
  border-top:0;
  top:0;
}

.ol-popup-bottom.black .anchor:before {
  border-bottom:0;
  bottom:0;
}

.ol-popup-middle.black .anchor:before {
  margin: -20px -22px;
  border-color: transparent currentColor;
}
.ol-popup-middle.ol-popup-left.black .anchor:before {
  border-left:0;
}
.ol-popup-middle.ol-popup-right.black .anchor:before {
  border-right:0;
}

.ol-popup-center.black .anchor:before {
  margin: 0 -10px;
}


/** Green tips popup */
.ol-popup.tips .closeBox {
  background-color: #f00;
  border-radius: 50%;
  color: #fff;
  width:1.2em;
  height:1.2em;
}
.ol-popup.tips .closeBox:hover {
  background-color: #f40;
}

.ol-popup.tips {
  margin: -20px 0;
  -webkit-transform: translate(0,-40px);
          transform: translate(0,-40px);
}
.ol-popup.tips > div {
  background-color: #cea;
  border: 5px solid #ad7;
  border-radius: 5px;
  color:#333;
}
.ol-popup-top.ol-popup.tips {
  margin: 20px 0;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-left.tips {
  margin: -20px -22px;
  -webkit-transform: translate(0,-40px);
          transform: translate(0,-40px);
}
.ol-popup-top.ol-popup-left.tips {
  margin: 20px -22px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-right.tips {
  margin: -20px 22px;
  -webkit-transform: translate(44px,-40px);
          transform: translate(44px,-40px);
}
.ol-popup-top.ol-popup-right.tips {
  margin: 20px 22px;
  -webkit-transform: translate(44px,0);
          transform: translate(44px,0);
}
.ol-popup-middle.tips {
  margin:0;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-left.ol-popup-middle.tips {
  margin: 0 22px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-right.ol-popup-middle.tips {
  margin: 0 -22px;
  -webkit-transform: translate(-44px,0);
          transform: translate(-44px,0);
}

.ol-popup.tips .anchor {
  margin: -18px 22px;
  color: #ad7;
} 
.ol-popup.tips .anchor:before {
  content:"";
  border-color: currentColor transparent;
  border-style: solid;
  border-width: 20px 11px;
}

.ol-popup-top.tips .anchor:before {
  border-top:0;
  top:0;
}
.ol-popup-bottom.tips .anchor:before {
  border-bottom:0;
  bottom:0;
}
.ol-popup-center.tips .anchor:before {
  border-width: 20px 6px;
  margin: 0 -6px;
}
.ol-popup-left.tips .anchor:before {
  border-left:0;
  margin-left:0;
}
.ol-popup-right.tips .anchor:before {
  border-right:0;
  margin-right:0;
}

.ol-popup-middle.tips .anchor:before {
  margin: -6px -41px;
  border-color: transparent currentColor;
  border-width:6px 20px;
}
.ol-popup-middle.ol-popup-left.tips .anchor:before {
  border-left:0;
}
.ol-popup-middle.ol-popup-right.tips .anchor:before {
  border-right:0;
}

/** Warning popup */
.ol-popup.warning .closeBox {
  background-color: #f00;
  border-radius: 50%;
  color: #fff;
  font-size: 0.83em;
}
.ol-popup.warning .closeBox:hover {
  background-color: #f40;
}

.ol-popup.warning {
  background-color: #fd0;
  border-radius: 3px;
  border:4px dashed #f00;
  margin:20px 0;
  color:#900;
  margin: -28px 10px;
  -webkit-transform: translate(0, -56px);
          transform: translate(0, -56px);
}
.ol-popup-top.ol-popup.warning {
  margin: 28px 10px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-left.warning {
  margin: -28px -22px;
  -webkit-transform: translate(0, -56px);
          transform: translate(0, -56px);
}
.ol-popup-top.ol-popup-left.warning {
  margin: 28px -22px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-right.warning {
  margin: -28px 22px;
  -webkit-transform: translate(44px, -56px);
          transform: translate(44px, -56px);
}
.ol-popup-top.ol-popup-right.warning {
  margin: 28px 22px;
  -webkit-transform: translate(44px, 0);
          transform: translate(44px, 0);
}
.ol-popup-middle.warning {
  margin:0;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-left.ol-popup-middle.warning {
  margin:0 22px;
  -webkit-transform: none;
          transform: none;
}
.ol-popup-right.ol-popup-middle.warning {
  margin:0 -22px;
  -webkit-transform: translate(-44px, 0);
          transform: translate(-44px, 0);
}

.ol-popup.warning .anchor {
  margin: -33px 7px;
} 
.ol-popup.warning .anchor:before {
  content:"";
  border-color: #f00 transparent;
  border-style: solid;
  border-width: 30px 11px;
}

.ol-popup-top.warning .anchor:before {
  border-top:0;
  top:0;
}
.ol-popup-bottom.warning .anchor:before {
  border-bottom:0;
  bottom:0;
}

.ol-popup-center.warning .anchor:before {
  margin: 0 -21px;
}
.ol-popup-middle.warning .anchor:before {
  margin: -10px -33px;
  border-color: transparent #f00;
  border-width:10px 22px;
}
.ol-popup-middle.ol-popup-left.warning .anchor:before {
  border-left:0;
}
.ol-popup-middle.ol-popup-right.warning .anchor:before {
  border-right:0;
}

.ol-popup .ol-popupfeature table {
  width: 100%;
}
.ol-popup .ol-popupfeature table td {
  max-width: 25em;
  overflow: hidden;
  text-overflow: ellipsis;
}
.ol-popup .ol-popupfeature table td img {
  max-width: 100px;
  max-height: 100px;
}
.ol-popup .ol-popupfeature tr:nth-child(2n+1) {
  background-color: #eee;
}
.ol-popup .ol-popupfeature .ol-zoombt {
  border: 0;
  width: 2em;
  height: 2em;
  display: inline-block;
  color: rgba(0,60,136,.5);
  position: relative;
  background: transparent;
  outline: none;
}
.ol-popup .ol-popupfeature .ol-zoombt:before {
  content: "";
  position: absolute;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  width: 1em;
  height: 1em;
  background-color: transparent;
  border: .17em solid currentColor;
  border-radius: 100%;
  top: .3em;
  left: .3em;
}
.ol-popup .ol-popupfeature .ol-zoombt:after {
  content: "";
  position: absolute;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  top: 1.35em;
  left: 1.15em;
  border-width: .1em .3em;
  border-style: solid;
  border-radius: .03em;
  -webkit-transform: rotate(45deg);
          transform: rotate(45deg);
  -webkit-box-shadow: -0.2em 0 0 -0.04em;
          box-shadow: -0.2em 0 0 -0.04em;
}

.ol-popup .ol-popupfeature .ol-count{
  float: right;
  margin: .25em 0;
}
.ol-popup .ol-popupfeature .ol-prev,
.ol-popup .ol-popupfeature .ol-next {
  border-style: solid;
  border-color: transparent rgba(0,60,136,.5);
  border-width: .5em 0 .5em .5em;
  display: inline-block;
  vertical-align: bottom;
  margin: 0 .5em;
  cursor: pointer;
}
.ol-popup .ol-popupfeature .ol-prev{
  border-width: .5em .5em .5em 0;
}

.ol-popup.tooltips.black {
  background-color: transparent;
}
.ol-popup.tooltips.black > div {
  -webkit-transform: scaleY(1.3);
          transform: scaleY(1.3);
  padding: .2em .5em;
  background-color: rgba(0,0,0, 0.5);
}
.ol-popup-middle.tooltips.black .anchor:before {
  border-width: 5px 10px;
  margin: -5px -21px;
}

.ol-popup-center.ol-popup-middle { 
  margin: 0;
}

.ol-popup-top.ol-popup-left.ol-fixPopup,
.ol-popup-top.ol-popup-right.ol-fixPopup,
.ol-popup.ol-fixPopup {
  margin: 0;
}

.ol-miniscroll {
  position: relative;
}
.ol-miniscroll:hover .ol-scroll {
  opacity: .5;
  -webkit-transition: opacity 1s;
  transition: opacity 1s;
}
.ol-miniscroll .ol-scroll {
  -ms-touch-action: none;
      touch-action: none;
  position: absolute;
  right: 0px;
  width: 9px;
  height: auto;
  max-height: 100%;
  opacity: 0;
  border-radius: 9px;
  -webkit-transition: opacity 1s .5s;
  transition: opacity 1s .5s;
  overflow: hidden;
  z-index: 1;
}
.ol-miniscroll .ol-scroll > div {
  -ms-touch-action: none;
      touch-action: none;
  position: absolute;
  top: 0;
  right: 0px;
  width: 9px;
  height: 9px;
  -webkit-box-shadow: inset 10px 0 currentColor;
          box-shadow: inset 10px 0 currentColor;
  border-radius: 9px / 12px;
  border: 2px solid transparent;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  cursor: pointer;
}
.ol-miniscroll .ol-scroll.ol-100pc {
  opacity: 0;
}

.ol-viewport canvas.ol-fixedoverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
/* Toggle Switch */
.ol-ext-toggle-switch {
  cursor: pointer;
  position: relative;
}
.ol-ext-toggle-switch input[type="radio"],
.ol-ext-toggle-switch input[type="checkbox"] {
  display: none;
}
.ol-ext-toggle-switch span {
  color: rgba(0,60,136,.5);
  position: relative;
  cursor: pointer;
  background-color: #ccc;
  -webkit-transition: .4s, background-color 0s, border-color 0s;
  transition: .4s, background-color 0s, border-color 0s;
  width: 1.6em;
  height: 1em;
  display: inline-block;
  border-radius: 1em;
  font-size: 1.3em;
  vertical-align: middle;
  margin: -.15em .2em .15em;
}
.ol-ext-toggle-switch span:before {
  position: absolute;
  content: "";
  height: 1em;
  width: 1em;
  left: 0;
  top: 50%;
  background-color: #fff;
  -webkit-transition: .4s;
  transition: .4s;
  border-radius: 1em;
  display: block;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
  border: 2px solid #ccc;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-ext-toggle-switch:hover span {
  background-color: #999;
}
.ol-ext-toggle-switch:hover span:before {
  border-color: #999;
}

.ol-ext-toggle-switch input:checked + span {
  background-color: currentColor;
}
.ol-ext-toggle-switch input:checked + span:before {
  -webkit-transform: translate(.6em,-50%);
          transform: translate(.6em,-50%);
  border-color: currentColor;
}

/* Check/radio buttons */
.ol-ext-check {
  position: relative;
  display: inline-block;
}
.ol-ext-check input {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}
.ol-ext-check span {
  color: rgba(0,60,136,.5);
  position: relative;
  display: inline-block;
  width: 1em;
  height: 1em;
  margin: -.1em .5em .1em;
  background-color: #ccc;
  vertical-align: middle;
}
.ol-ext-check:hover span {
  background-color: #999;
}
.ol-ext-checkbox input:checked ~ span {
  background-color: currentColor;
}
.ol-ext-checkbox input:checked ~ span:before {
  content: "";
  position: absolute;
  width: .5em;
  height: .8em;
  top: 50%;
  left: 50%;
  -webkit-transform: translateY(-.1em) translate(-50%, -50%) rotate(45deg);
          transform: translateY(-.1em) translate(-50%, -50%) rotate(45deg);
  -webkit-box-shadow: inset -0.2em -0.2em #fff;
          box-shadow: inset -0.2em -0.2em #fff;
}

.ol-ext-radio span {
  width: 1.1em;
  height: 1.1em;
  border-radius: 50%;
}
.ol-ext-radio:hover input:checked ~ span {
  background-color: #ccc;
}
.ol-ext-radio input:checked ~ span:before {
  content: "";
  position: absolute;
  width: 50%;
  height: 50%;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  border-radius: 50%;
  background-color: currentColor;
}

.ol-collection-list {
  margin: 0;
  padding: 0;
  list-style: none;
}
.ol-collection-list li {
  position: relative;
  padding: 0 2em 0 1em;
}
.ol-collection-list li:hover {
  background-color: rgba(0,60,136,.2);
}
.ol-collection-list li.ol-select {
  background-color: rgba(0,60,136,.5);
  color: #fff;
}

.ol-collection-list li .ol-order {
  position: absolute;
  -ms-touch-action: none;
      touch-action: none;
  right: 0;
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
  width: 2em;
  height: 100%;
  cursor: n-resize;
}
.ol-collection-list li .ol-order:before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  width: 18px;
  height: 2px;
  background-color: currentColor;
  -webkit-box-shadow: 0 5px, 0 -5px;
          box-shadow: 0 5px, 0 -5px;
  border-radius: 2px;
}

.ol-ext-colorpicker.ol-popup {
  width: 2em;
  height: 1.5em;
  background-color: transparent;
  background-image: 
    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%), 
    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);
  background-size: 10px 10px;
  background-position: 0 -1px, 5px 4px;
}

.ol-ext-colorpicker .ol-tabbar {
  background-color: #eee;
  border-bottom: 1px solid #999;
  display: none;
}
.ol-ext-colorpicker.ol-tab .ol-tabbar {
  display: block;
}

.ol-ext-colorpicker .ol-tabbar > div {
  display: inline-block;
  background-color: #fff;
  padding: 0 .5em;
  border: 1px solid #999;
  border-radius: 2px 2px 0 0;
  position: relative;
  top: 1px;
  cursor: pointer;
}
.ol-ext-colorpicker .ol-tabbar > div:nth-child(1) {
  border-bottom-color: #fff;
}
.ol-ext-colorpicker.ol-picker-tab .ol-tabbar > div:nth-child(1) {
  border-bottom-color: #999;
}
.ol-ext-colorpicker.ol-picker-tab .ol-tabbar > div:nth-child(2) {
  border-bottom-color: #fff;
}

.ol-ext-colorpicker.ol-popup.ol-tab .ol-popup {
  width: 180px;
}
.ol-ext-colorpicker.ol-tab .ol-palette {
  margin: 0 10px;
}
.ol-ext-colorpicker.ol-tab .ol-container {
  display: none;
}
.ol-ext-colorpicker.ol-tab.ol-picker-tab .ol-container {
  display: block;
}
.ol-ext-colorpicker.ol-tab.ol-picker-tab .ol-palette {
  display: none;
}

.ol-ext-colorpicker.ol-popup .ol-popup {
  width: 340px;
}

.ol-ext-colorpicker.ol-popup .ol-vignet {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  border: 0;
  background-color: currentColor;
  pointer-events: none;
}

.ol-ext-colorpicker .ol-container {
  position: relative;
  display: inline-block;
  vertical-align: top;
}
.ol-ext-colorpicker .ol-cursor {
  pointer-events: none;
}

.ol-ext-colorpicker .ol-picker {
  position: relative;
  cursor: crosshair;
  width: 150px;
  height: 150px;
  border: 5px solid #fff;
  background-color: currentColor;
  background-image: -webkit-gradient(linear, left top, left bottom, from(0), color-stop(#000), to(transparent)),
    -webkit-gradient(linear, left top, right top, from(#fff), to(transparent));
  background-image: linear-gradient(0, #000, transparent),
    linear-gradient(90deg, #fff, transparent);
}
.ol-ext-colorpicker .ol-picker .ol-cursor {
  position: absolute;
  left: 50%;
  top: 50%;
  border: 1px solid rgba(0,0,0,.7);
  -webkit-box-shadow: 0 0 0 1px rgba(255,255,255,.7);
          box-shadow: 0 0 0 1px rgba(255,255,255,.7);
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  width: 10px;
  height: 10px;
  border-radius: 50%;
}

.ol-ext-colorpicker .ol-slider {
  position: relative;
  cursor: crosshair;
  background-color: #fff;
  height: 10px;
  width: 150px;
  margin: 5px 0 10px;
  border: 5px solid #fff;
  border-width: 0 5px;
  background-image: 
    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%), 
    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);
  background-size: 10px 10px;
  background-position: 0 -1px, 5px 4px;
}
.ol-ext-colorpicker .ol-slider > div {
  width: 100%;
  height: 100%;
  background-image: linear-gradient(45deg, transparent, #fff);
  pointer-events: none;
}
.ol-ext-colorpicker .ol-slider .ol-cursor {
  position: absolute;
  width: 4px;
  height: 12px;
  border: 1px solid #000;
  top: 50%;
  left: 0;
  background: transparent;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-ext-colorpicker .ol-tint {
  position: absolute;
  cursor: crosshair;
  width: 10px;
  height: 150px;
  border: 5px solid #fff;
  border-width: 5px 0;
  -webkit-box-sizing: border;
          box-sizing: border;
  top: 0;
  right: 5px;
  background-image: -webkit-gradient(linear, left top, left bottom, from(0), color-stop(#f00), color-stop(#f0f), color-stop(#00f), color-stop(#0ff), color-stop(#0f0), color-stop(#ff0), to(#f00));
  background-image: linear-gradient(0, #f00, #f0f, #00f, #0ff, #0f0, #ff0, #f00)
}
.ol-ext-colorpicker .ol-tint .ol-cursor {
  position: absolute;
  top: 0;
  left: 50%;
  border: 1px solid #000;
  height: 4px;
  width: 12px;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}

.ol-ext-colorpicker .ol-clear {
  position: absolute;
  border: 2px solid #999;
  right: 4px;
  top: 163px;
  width: 10px;
  height: 10px;
}
.ol-ext-colorpicker .ol-clear:before,
.ol-ext-colorpicker .ol-clear:after {
  content: "";
  position: absolute;
  width: 15px;
  height: 2px;
  background-color: #999;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) rotate(45deg);
          transform: translate(-50%, -50%) rotate(45deg);
}
.ol-ext-colorpicker .ol-clear:after {
  -webkit-transform: translate(-50%, -50%) rotate(-45deg);
          transform: translate(-50%, -50%) rotate(-45deg);
}

.ol-ext-colorpicker.ol-nopacity .ol-slider,
.ol-ext-colorpicker.ol-nopacity .ol-clear {
  display: none;
}
.ol-ext-colorpicker.ol-nopacity .ol-alpha {
  display: none;
}

.ol-ext-colorpicker .ol-rgb {
  position: relative;
  padding: 5px;
  width: 170px;
  display: none;
}
.ol-ext-colorpicker .ol-rgb input {
  width: 25%;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  padding: 0 0 0 2px;
  border: 1px solid #999;
  border-radius: 2px;
  font-size: 13px;
}
.ol-ext-colorpicker .ol-rgb input:nth-child(1) {
	background-color: rgba(255,0,0,.1);
}
.ol-ext-colorpicker .ol-rgb input:nth-child(2) {
	background-color: rgba(0,255,0,.1);
}
.ol-ext-colorpicker .ol-rgb input:nth-child(3) {
	background-color: rgba(0,0,255,.12);
}

.ol-ext-colorpicker button,
.ol-ext-colorpicker .ol-txt-color {
  font-size: 13px;
  margin: 0 5px 5px;
  text-align: center;
  width: 170px;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  padding: 0;
  border: 1px solid #999;
  border-radius: 2px;
  display: block;
}
.ol-ext-colorpicker button {
  background-color: #eee;
}
.ol-ext-colorpicker button:hover {
  background-color: #e9e9e9;
}

.ol-ext-colorpicker .ol-txt-color.ol-error {
  background-color: rgba(255,0,0,.2);
}

.ol-ext-colorpicker .ol-palette {
  padding: 2px;
  display: inline-block;
  width: 152px;
}
.ol-ext-colorpicker .ol-palette > div {
  width: 15px;
  height: 15px;
  display: inline-block;
  background-image: 
    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%), 
    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);
  background-size: 10px 10px;
  background-position: 0 0, 5px 5px;
  margin: 2px;
  -webkit-box-shadow: 0 0 2px 0px #666;
          box-shadow: 0 0 2px 0px #666;
  border-radius: 1px;
  cursor: pointer;
  position: relative;
}
.ol-ext-colorpicker .ol-palette > div:before {
  content: "";
  position: absolute;
  background-color: currentColor;
  width: 100%;
  height: 100%;
}
.ol-ext-colorpicker .ol-palette > div.ol-select:after {
  content: "";
  position: absolute;
  width: 6px;
  height: 12px;
  -webkit-box-shadow: 1px 1px #fff, 2px 2px #000;
          box-shadow: 1px 1px #fff, 2px 2px #000;
  top: 30%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%) rotate(45deg);
          transform: translate(-50%, -50%) rotate(45deg);
}
.ol-ext-colorpicker .ol-palette > div:hover {
  -webkit-box-shadow: 0 0 2px 1px #d90;
          box-shadow: 0 0 2px 1px #d90;
}
.ol-ext-colorpicker .ol-palette hr {
  margin: 0;
}

.ol-input-popup {
  display: inline-block;
  position: relative;
}
.ol-input-popup .ol-popup {
  position: absolute;
  -webkit-box-shadow: 1px 1px 3px 1px #999;
          box-shadow: 1px 1px 3px 1px #999;
  background-color: #fff;
  z-index: 1;
  display: none;
  left: -5px;
  padding: 0;
  margin: 0;
  list-style: none;
  white-space: nowrap;
}
.ol-input-popup.ol-hover:hover .ol-popup,
.ol-input-popup.ol-focus .ol-popup {
  display: block;
}
.ol-input-popup.ol-right .ol-popup {
  left: auto;
  right: -5px;
}
.ol-input-popup.ol-middle .ol-popup {
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
}


.ol-input-popup .ol-popup li {
  position: relative;
  padding: 10px 5px;
}

.ol-input-popup li:hover {
  background-color: #ccc;
}
.ol-input-popup li.ol-selected {
  background-color: #ccc;
}

.ol-input-popup.ol-fixed:hover .ol-popup,
.ol-input-popup.ol-fixed .ol-popup {
  position: relative;
  left: 0;
  -webkit-box-shadow: unset;
          box-shadow: unset;
  background-color: transparent;
  display: inline-block;
  vertical-align: middle;
}
.ol-input-popup.ol-fixed.ol-left .ol-popup {
  float: left;
}

.ol-input-popup > div {
  position: relative;
  display: inline-block;
  vertical-align: middle;
  border-radius: 2px;
  border: 1px solid #999;
  padding: 3px 20px 3px 10px
}
.ol-input-popup > div:before {
  position: absolute;
  content: "";
  right: 5px;
  top: 50%;
  border: 5px solid transparent;
  border-top: 5px solid #999;
}

.ol-ext-popup-input {
  display: inline-block;
  vertical-align: top;
}
.ol-ext-popup-input.ol-popup {
  position: relative;
  width: 2em;
  height: 1.5em;
  display: inline-block;
  border: 3px solid #fff;
  border-right-width: 1em;
  -webkit-box-shadow: 0 0 2px 1px #666;
          box-shadow: 0 0 2px 1px #666;
  border-radius: 2px;
  -webkit-box-sizing: content-box;
          box-sizing: content-box;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  vertical-align: middle;
}
.ol-ext-popup-input.ol-popup:after {
  content: "";
  position: absolute;
  border: .5em solid #aaa;
  border-width: .5em .3em 0;
  border-color: #999 transparent;
  right: -.8em;
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
  pointer-events: none;
}

.ol-ext-popup-input * {
  -webkit-box-sizing: content-box;
          box-sizing: content-box;
}

.ol-ext-popup-input.ol-popup .ol-popup {
  position: absolute;
  top: 100%;
  min-width: 3em;
  min-height: 3em;
  left: 0;
  -webkit-box-shadow: 1px 1px 3px 1px #999;
          box-shadow: 1px 1px 3px 1px #999;
  display: block;
  background-color: #fff;
  display: none;
  z-index: 1;
}
.ol-ext-popup-input.ol-popup .ol-popup.ol-visible {
  display: block;
}

.ol-ext-popup-input.ol-popup-fixed .ol-popup {
  position: fixed;
  top: auto;
  left: auto;
}

.ol-input-popup.ol-size li {
  display: table-cell;
  height: 100%;
  padding: 5px;
  vertical-align: middle;
}

.ol-input-popup.ol-size li > * {
  background-color: #369;
  border-radius: 50%;
  vertical-align: middle;
  width: 1em;
  height: 1em;
}

.ol-input-popup.ol-size li > .ol-option-0 {
  position: relative;
  width: 1em;
  height: 1em;
  border: 2px solid currentColor;
  color: #aaa;
  background-color: transparent;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.ol-input-popup.ol-size li > *:before {
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
}
.ol-input-popup.ol-size li > .ol-option-0:before {
  content: "";
  width: 1em;
  height: 2px;
  background-color: #aaa;
  -webkit-transform: translate(-50%, -50%) rotate(-45deg);
          transform: translate(-50%, -50%) rotate(-45deg);
}

.ol-input-slider {
  display: inline-block;
  position: relative;
}
.ol-input-slider .ol-popup {
  position: absolute;
  -webkit-box-shadow: 1px 1px 3px 1px #999;
          box-shadow: 1px 1px 3px 1px #999;
  background-color: #fff;
  z-index: 1;
  display: none;
  left: -5px;
}
.ol-input-slider.ol-right .ol-popup {
  left: auto;
  right: -5px;
}
.ol-input-slider.ol-hover:hover .ol-popup,
.ol-input-slider.ol-focus .ol-popup {
  display: block;
  white-space: nowrap;
}
.ol-input-slider.ol-hover:hover .ol-popup > *,
.ol-input-slider.ol-focus .ol-popup > * {
  display: inline-block;
  vertical-align: middle;
}
.ol-input-slider.ol-hover:hover .ol-popup > .ol-before,
.ol-input-slider.ol-focus .ol-popup > .ol-before {
  margin-left: 10px;
}
.ol-input-slider.ol-hover:hover .ol-popup > .ol-after,
.ol-input-slider.ol-focus .ol-popup > .ol-after {
  margin-right: 10px;
}
.ol-input-slider .ol-slider {
  display: inline-block;
  vertical-align: middle;
  position: relative;
  width: 100px;
  height: 3px;
  border: 0 solid transparent;
  border-width: 10px 15px;
  -webkit-box-shadow: inset 0 0 0 1px #999;
          box-shadow: inset 0 0 0 1px #999;
  -webkit-box-sizing: content-box;
          box-sizing: content-box;
  cursor: pointer;
}

.ol-input-slider .ol-slider > .ol-cursor {
  position: absolute;
  width: 5px;
  height: 10px;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  background-color: #999;
  pointer-events: none;
}
.ol-input-range .ol-slider {
  cursor: default;
  width: 150px;
}
.ol-input-range .ol-slider > .ol-cursor {
  pointer-events: all;
  cursor: pointer;
  width: 10px;
  border-radius: 50%;
  background-color: rgb(0,60,136);
}
.ol-input-range.ol-moving .ol-slider > .ol-cursor {
  pointer-events: none;
}
.ol-input-range .ol-slider > .ol-back {
  position: absolute;
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
  left: 30%;
  right: 20%;
  height: 100%;
  background-color: rgb(0,60,136);
  pointer-events: none;
}

.ol-input-slider.ol-fixed:hover .ol-popup,
.ol-input-slider.ol-fixed .ol-popup {
  position: relative;
  left: 0;
  -webkit-box-shadow: unset;
          box-shadow: unset;
  background-color: transparent;
  display: inline-block;
  vertical-align: middle;
}
.ol-input-slider.ol-fixed.ol-left .ol-popup {
  float: left;
}

/* Grow */
.ol-input-slider.ol-size .ol-slider {
  height: auto;
  -webkit-box-shadow: none;
          box-shadow: none;
}
.ol-input-slider.ol-size .ol-slider .ol-back {
  width: 0;
  color: #aaa;
  border: 0 solid transparent;
  border-width: 0 0 20px 100px;
  border-color: currentColor transparent;
  pointer-events: none;
}

.ol-input-slider.ol-size .ol-slider > .ol-cursor {
  width: 2px;
  height: calc(100% + 4px);
  border-width: 5px 3px;
  border-style: solid;
  border-color: #f00 transparent;
  -o-border-image: initial;
     border-image: initial;
  background-color: transparent;
  -webkit-box-shadow: inset 3px 0px #f00;
          box-shadow: inset 3px 0px #f00;
}

.ol-input-popup.ol-width li {
  padding: 5px;
}


.ol-input-popup.ol-width li > * {
  background-color: #369;
  width: 100px;
  height: 1em;
}

.ol-input-popup.ol-width li > .ol-option-0 {
  position: relative;
  height: 1px;
  background-image: linear-gradient(90deg,#aaa 2px, transparent 2px);
  background-color: transparent;
  background-size: 4px;
}
`, "",{"version":3,"sources":["webpack://./node_modules/ol-ext/dist/ol-ext.css"],"names":[],"mappings":"AAAA;EACE,eAAe;AACjB;;AAEA,cAAc;AACd;EACE,SAAS;EACT,eAAe;EACf,cAAc;EACd,kBAAkB;EAClB,UAAU;EACV,4BAA4B;EAC5B,oCAAoC;EACpC,mBAAmB;AACrB;;AAEA,kDAAkD;AAClD;EACE,aAAa;AACf;;AAEA,kCAAkC;AAClC;EACE,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,SAAS;EACT,UAAU;EACV,YAAY;EACZ,qBAAqB;EACrB,sBAAsB;EACtB,6BAA6B;EAC7B,UAAU;EACV,SAAS;EACT,eAAe;EACf,uBAAuB;AACzB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,cAAc;EACd,aAAa;AACf;;AAEA,iBAAiB;AACjB;EACE,WAAW;EACX,QAAQ;EACR,uCAAuC;UAC/B,+BAA+B;AACzC;AACA;EACE,cAAc;AAChB;;AAEA;EACE,UAAU;EACV,YAAY;EACZ,QAAQ;EACR,uCAAuC;UAC/B,+BAA+B;AACzC;AACA;EACE,cAAc;AAChB;;AAEA;EACE,SAAS;EACT,aAAa;AACf;;AAEA;;EAEE,UAAU;EACV,sBAAsB;UACd,cAAc;AACxB;AACA;;EAEE,UAAU;AACZ;AACA;;EAEE,SAAS;EACT,aAAa;EACb,sBAAsB;UACd,cAAc;AACxB;;AAEA,kBAAkB;AAClB;EACE,qBAAqB;AACvB;AACA;;EAEE,qBAAqB;AACvB;;AAEA;EACE,eAAe;EACf,iBAAiB;AACnB;AACA;;;;EAIE,iBAAiB;AACnB;AACA;EACE,0BAA0B;AAC5B;AACA;EACE,0BAA0B;AAC5B;AACA;;;;EAIE,0BAA0B;AAC5B;AACA;;;;EAIE,0BAA0B;AAC5B;;AAEA,IAAI;AACJ;EACE,SAAS;EACT,mBAAmB;AACrB;AACA;EACE;AACF;;AAEA,mBAAmB;AACnB;;EAEE,yBAAyB;EACzB,WAAW;AACb;AACA;EACE,sBAAsB;AACxB;;AAEA,mBAAmB;AACnB;EACE,aAAa;EACb,iBAAiB;EACjB,QAAQ;EACR,MAAM;EACN,aAAa;EACb,gBAAgB;EAChB,wCAAwC;EACxC,6CAA6C;EAC7C,mFAAmF;UAC3E,2EAA2E;AACrF;;AAEA;EACE,WAAW;EACX,+BAA+B;EAC/B,2DAA2D;EAC3D,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,oBAAoB;AACtB;;AAEA;EACE,mBAAmB;AACrB;AACA;EACE,aAAa;AACf;AACA;EACE,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;;EAEE,6BAA6B;EAC7B,4BAA4B;EAC5B,WAAW;EACX,kBAAkB;EAClB,SAAS;AACX;;AAEA;EACE,eAAe;EACf,4CAA4C;EAC5C,gBAAgB;AAClB;AACA;EACE,aAAa;AACf;AACA;EACE,oBAAoB;EACpB,mBAAmB;EACnB,iBAAiB;EACjB,uCAAuC;AACzC;AACA;EACE,0BAA0B;AAC5B;;AAEA;EACE,SAAS;EACT,YAAY;AACd;AACA;EACE,4DAA4D;EAC5D,YAAY;EACZ,SAAS;AACX;;AAEA;EACE,SAAS;EACT,MAAM;EACN,YAAY;EACZ,aAAa;AACf;AACA;EACE,uEAAuE;EACvE,YAAY;EACZ,WAAW;EACX,UAAU;EACV,UAAU;AACZ;AACA;EACE,UAAU;EACV,SAAS;EACT,MAAM;EACN,YAAY;EACZ,aAAa;AACf;AACA;EACE,uEAAuE;EACvE,YAAY;EACZ,UAAU;EACV,UAAU;AACZ;;AAEA;;EAEE,SAAS;EACT,YAAY;EACZ,WAAW;EACX,WAAW;EACX,aAAa;AACf;AACA;EACE,YAAY;EACZ,UAAU;AACZ;AACA;;EAEE,2DAA2D;EAC3D,YAAY;EACZ,SAAS;EACT,WAAW;EACX,WAAW;AACb;AACA;EACE,YAAY;EACZ,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,QAAQ;AACV;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;EACnC,sCAAsC;EACtC,iBAAiB;AACnB;;AAEA;EACE,aAAa;EACb,QAAQ;EACR,UAAU;EACV,UAAU;AACZ;AACA;EACE,wBAAwB;AAC1B;AACA;EACE,eAAe;EACf,UAAU;EACV,OAAO;EACP,WAAW;EACX,YAAY;EACZ,UAAU;EACV,gCAAgC;EAChC,aAAa;EACb,8BAA8B;EAC9B,2CAA2C;EAC3C,mCAAmC;AACrC;AACA;EACE,UAAU;EACV,MAAM;EACN,6BAA6B;EAC7B,uCAAuC;EACvC,+BAA+B;AACjC;;AAEA;EACE,kBAAkB;AACpB;AACA;EACE,qBAAqB;EACrB,aAAa;EACb,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;AACrB;AACA;EACE,cAAc;AAChB;AACA;EACE,kBAAkB;EAClB,MAAM;EACN,YAAY;EACZ,cAAc;EACd,cAAc;EACd,eAAe;EACf,gBAAgB;EAChB,sBAAsB;EACtB,sBAAsB;EACtB,gDAAgD;UACxC,wCAAwC;EAChD,wCAAwC;UAChC,gCAAgC;EACxC,kDAAkD;EAClD,0CAA0C;EAC1C,kCAAkC;EAClC,yDAAyD;EACzD,YAAY;EACZ,8BAA8B;UACtB,sBAAsB;EAC9B,kBAAkB;EAClB,gBAAgB;AAClB;AACA;EACE,kBAAkB;AACpB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,oBAAoB;AACtB;;AAEA;EACE,QAAQ;EACR,iDAAiD;UACzC,yCAAyC;AACnD;AACA;EACE,QAAQ;AACV;AACA;EACE,iDAAiD;UACzC,yCAAyC;AACnD;;AAEA;EACE,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,WAAW;EACX,UAAU;EACV,WAAW;EACX,eAAe;EACf,aAAa;AACf;AACA;EACE,cAAc;AAChB;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,8BAA8B;EAC9B,QAAQ;EACR,SAAS;EACT,UAAU;EACV,YAAY;EACZ,mBAAmB;EACnB,sDAAsD;UAC9C,8CAA8C;AACxD;AACA;EACE,uDAAuD;UAC/C,+CAA+C;AACzD;;AAEA;EACE,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,SAAS;EACT,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,oBAAoB;EACpB,gBAAgB;AAClB;AACA;EACE,oCAAoC;AACtC;AACA;EACE,iBAAiB;AACnB;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,oBAAoB;AACtB;AACA;EACE,sBAAsB;EACtB,WAAW;EACX,WAAW;EACX,eAAe;EACf,YAAY;EACZ,mBAAmB;EACnB,gBAAgB;AAClB;AACA;EACE,gBAAgB;EAChB,YAAY;EACZ,UAAU;EACV,6BAA6B;EAC7B,qBAAqB;AACvB;AACA;EACE,yBAAyB;EACzB,iBAAiB;AACnB;;AAEA,gBAAgB;AAChB;EACE,QAAQ;EACR,uBAAuB;UACf,eAAe;EACvB,SAAS;EACT,WAAW;EACX,UAAU;EACV,4BAA4B;EAC5B,kBAAkB;EAClB,uBAAuB;EACvB,wBAAwB;UAChB,gBAAgB;EACxB,YAAY;EACZ,WAAW;AACb;AACA;EACE,MAAM;EACN,QAAQ;EACR,cAAc;AAChB;AACA;;EAEE,+BAA+B;AACjC;AACA;;EAEE,eAAe;AACjB;;AAEA,sBAAsB;AACtB;EACE,8BAA8B;AAChC;;AAEA;EACE,iBAAiB;AACnB;AACA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,kBAAkB;EAClB,8BAA8B;UACtB,sBAAsB;EAC9B,sBAAsB;AACxB;AACA;;EAEE,WAAW;EACX,eAAe;EACf,kBAAkB;EAClB,8BAA8B;UACtB,sBAAsB;EAC9B,8BAA8B;AAChC;AACA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;EACX,WAAW;EACX,6BAA6B;EAC7B,+BAA+B;EAC/B,2BAA2B;EAC3B,sCAAsC;EACtC,oCAAoC;UAC5B,4BAA4B;EACpC,UAAU;EACV,UAAU;EACV,uDAAuD;UAC/C,+CAA+C;AACzD;AACA;EACE,YAAY;EACZ,YAAY;EACZ,6BAA6B;EAC7B,+BAA+B;EAC/B,0BAA0B;EAC1B,sCAAsC;EACtC,SAAS;EACT,UAAU;EACV,iCAAiC;UACzB,yBAAyB;AACnC;;AAEA;;EAEE,UAAU;EACV,YAAY;EACZ,QAAQ;EACR,SAAS;EACT,sDAAsD;UAC9C,8CAA8C;AACxD;AACA;EACE,uDAAuD;UAC/C,+CAA+C;AACzD;;AAEA;EACE,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,UAAU;EACV,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;AACrC;AACA;EACE,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,8DAA8D;UACtD,sDAAsD;EAC9D,UAAU;EACV,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;AACrC;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,gCAAgC;EAChC,6BAA6B;EAC7B,SAAS;EACT,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;AACrC;AACA;EACE,WAAW;EACX,YAAY;EACZ,gCAAgC;EAChC,sCAAsC;EACtC,yBAAyB;EACzB,6BAA6B;EAC7B,SAAS;EACT,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;AACrC;;AAEA;;;EAGE,WAAW;EACX,YAAY;EACZ,gCAAgC;EAChC,6BAA6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,WAAW;EACX,gEAAgE;UACxD,wDAAwD;AAClE;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,WAAW;EACX,YAAY;EACZ,UAAU;EACV,WAAW;EACX,4DAA4D;UACpD,oDAAoD;AAC9D;AACA;EACE,2EAA2E;UACnE,mEAAmE;AAC7E;;;AAGA;;EAEE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,gBAAgB;EAChB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,WAAW;EACX,YAAY;AACd;;AAEA;;;EAGE,WAAW;EACX,WAAW;EACX,QAAQ;EACR,SAAS;EACT,sDAAsD;UAC9C,8CAA8C;EACtD,qDAAqD;UAC7C,6CAA6C;EACrD,WAAW;EACX,kBAAkB;EAClB,8BAA8B;AAChC;AACA;EACE,uDAAuD;UAC/C,+CAA+C;AACzD;AACA;EACE,uDAAuD;UAC/C,+CAA+C;AACzD;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,UAAU;EACV,WAAW;EACX,kBAAkB;EAClB,iDAAiD;UACzC,yCAAyC;AACnD;AACA;EACE,WAAW;EACX,YAAY;EACZ,UAAU;EACV,WAAW;EACX,+BAA+B;EAC/B,2BAA2B;EAC3B,6BAA6B;EAC7B,mBAAmB;EACnB,0DAA0D;UAClD,kDAAkD;AAC5D;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;EACT,+BAA+B;EAC/B,6BAA6B;EAC7B,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,+BAA+B;EAC/B,sCAAsC;EACtC,qBAAqB;EACrB,eAAe;EACf,2BAA2B;AAC7B;AACA;;EAEE,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;AACrC;AACA;EACE,cAAc;EACd,kBAAkB;AACpB;AACA;EACE,8BAA8B;EAC9B,kBAAkB;AACpB;AACA;EACE,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,OAAO;EACP,WAAW;AACb;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,iCAAiC;UACzB,yBAAyB;EACjC,oGAAoG;EACpG,mEAAmE;AACrE;;AAEA;EACE,YAAY;EACZ,UAAU;EACV,WAAW;AACb;AACA;EACE,yBAAyB;EACzB,WAAW;AACb;AACA;EACE,aAAa;AACf;AACA;EACE,kBAAkB;EAClB,gBAAgB;AAClB;AACA;EACE,cAAc;AAChB;;AAEA;;EAEE,aAAa;AACf;AACA;EACE,cAAc;AAChB;;AAEA;EACE,WAAW;EACX,WAAW;EACX,kBAAkB;EAClB,sBAAsB;EACtB,kBAAkB;EAClB,yBAAyB;EACzB,mBAAmB;AACrB;AACA;EACE,kBAAkB;EAClB,SAAS;AACX;AACA;EACE,WAAW;EACX,YAAY;EACZ,WAAW;EACX,sBAAsB;EACtB,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,UAAU;EACV,6BAA6B;EAC7B,uBAAuB;EACvB,uDAAuD;UAC/C,+CAA+C;EACvD,kBAAkB;AACpB;AACA;EACE,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;EACnB,sBAAsB;EACtB,mBAAmB;EACnB,uBAAuB;EACvB,uBAAuB;EACvB,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;AACrC;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,uBAAuB;EACvB,sBAAsB;EACtB,UAAU;EACV,WAAW;EACX,cAAc;EACd,8BAA8B;UACtB,sBAAsB;AAChC;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,sDAAsD;UAC9C,8CAA8C;EACtD,wBAAwB;EACxB,WAAW;EACX,WAAW;EACX,cAAc;EACd,kBAAkB;AACpB;AACA;EACE,uDAAuD;UAC/C,+CAA+C;AACzD;;AAEA;EACE,8BAA8B;AAChC;AACA;EACE,sDAAsD;UAC9C,8CAA8C;AACxD;AACA;EACE,aAAa;AACf;;AAEA;EACE,cAAc;EACd,YAAY;EACZ,eAAe;AACjB;AACA;EACE,cAAc;AAChB;;AAEA;EACE,sBAAsB;EACtB,yBAAyB;EACzB,mBAAmB;EACnB,kBAAkB;AACpB;AACA;EACE,yBAAyB;EACzB,wBAAwB;EACxB,gBAAgB;EAChB,MAAM;EACN,gBAAgB;AAClB;AACA,iBAAiB;AACjB;EACE,aAAa;EACb,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,sBAAsB;EACtB,eAAe;AACjB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE,oBAAoB;EACpB,yBAAyB;EACzB,gBAAgB;EAChB,YAAY;AACd;AACA;EACE,iBAAiB;AACnB;AACA;EACE,kBAAkB;EAClB,yBAAyB;AAC3B;AACA;;EAEE,6BAA6B;AAC/B;AACA;EACE,kBAAkB;AACpB;AACA;EACE,oBAAoB;AACtB;;AAEA;EACE,SAAS;EACT,qBAAqB;AACvB;AACA;EACE,kBAAkB;EAClB,YAAY;EACZ,aAAa;EACb,MAAM;EACN,QAAQ;EACR,cAAc;EACd,UAAU;EACV,6BAA6B;EAC7B,SAAS;AACX;AACA;EACE,YAAY;EACZ,kBAAkB;EAClB,mBAAmB;EACnB,eAAe;EACf,cAAc;EACd,gBAAgB;AAClB;AACA;EACE,YAAY;AACd;AACA;EACE,YAAY;AACd;;AAEA;EACE,UAAU;EACV,SAAS;EACT,mCAAmC;EACnC,2BAA2B;EAC3B,sCAAsC;EACtC,oBAAoB;AACtB;;AAEA;EACE,qBAAqB;EACrB,sBAAsB;AACxB;AACA;EACE,mBAAmB;AACrB;AACA;EACE,qBAAqB;EACrB,YAAY;EACZ,mCAAmC;EACnC,kBAAkB;EAClB,WAAW;AACb;AACA;EACE,aAAa;EACb,QAAQ;EACR,cAAc;AAChB;;AAEA;EACE,UAAU;EACV,SAAS;EACT,sCAAsC;AACxC;AACA;EACE,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,0BAA0B;EAC1B,mBAAmB;EACnB,0BAA0B;EAC1B,gCAAgC;EAChC,QAAQ;EACR,SAAS;EACT,wCAAwC;EACxC,gCAAgC;EAChC,SAAS;AACX;;;AAGA;EACE,cAAc;EACd,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,gBAAgB;EAChB,qBAAqB;EACrB,gBAAgB;AAClB;AACA;EACE,iBAAiB;EACjB,UAAU;EACV,gBAAgB;EAChB,eAAe;AACjB;AACA;EACE,yBAAyB;EACzB,gBAAgB;EAChB,wBAAwB;EACxB,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,mCAAmC;EACnC,WAAW;AACb;;AAEA;EACE,UAAU;EACV,aAAa;EACb,YAAY;EACZ,6BAA6B;EAC7B,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,gBAAgB;EAChB,WAAW;EACX,gBAAgB;EAChB,gBAAgB;EAChB,gBAAgB;IACd,kBAAkB;IAClB,QAAQ;IACR,SAAS;IACT,wCAAwC;IACxC,gCAAgC;AACpC;;AAEA;;EAEE,aAAa;AACf;AACA;;EAEE,cAAc;AAChB;;;AAGA;EACE,SAAS;EACT,UAAU;EACV,WAAW;EACX,WAAW;AACb;AACA;EACE,aAAa;AACf;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,uBAAuB;EACvB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,gCAAgC;EAChC,WAAW;EACX,YAAY;EACZ,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,uBAAuB;EACvB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,wDAAwD;UAChD,gDAAgD;AAC1D;;AAEA;CACC,qBAAqB;CACrB,sBAAsB;AACvB;;AAEA;EACE,aAAa;AACf;AACA;EACE,qBAAqB;AACvB;;AAEA;;EAEE,WAAW;EACX,cAAc;EACd,kBAAkB;EAClB,6BAA6B;EAC7B,iCAAiC;EACjC,kDAAkD;EAClD,iCAAiC;EACjC,yBAAyB;EACzB,UAAU;EACV,YAAY;EACZ,gBAAgB;AAClB;AACA;EACE,gCAAgC;EAChC,kDAAkD;CACnD,iCAAiC;CACjC,yBAAyB;AAC1B;;AAEA;EACE,WAAW;EACX,cAAc;EACd,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,sBAAsB;EACtB,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,uCAAuC;EACvC,+BAA+B;AACjC;AACA;;EAEE,WAAW;EACX,cAAc;EACd,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,8BAA8B;EAC9B,QAAQ;EACR,SAAS;EACT,uCAAuC;EACvC,+BAA+B;AACjC;AACA;EACE,SAAS;AACX;;AAEA;;;;;;EAME,aAAa;AACf;AACA;;EAEE,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;CACnB,WAAW;CACX,aAAa;CACb,kBAAkB;CAClB,YAAY;CACZ,qBAAqB;CACrB,wBAAwB;CACxB,6BAA6B;CAC7B,gCAAgC;AACjC;AACA;EACE,YAAY;AACd;;AAEA;EACE,aAAa;CACd,WAAW;CACX,YAAY;CACZ,qBAAqB;CACrB,eAAe;CACf,kBAAkB;CAClB,gBAAgB;CAChB,yDAAyD;SACjD,iDAAiD;AAC1D;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,cAAc;CACf,sBAAsB;CACtB,UAAU;CACV,YAAY;CACZ,qBAAqB;CACrB,kBAAkB;CAClB,QAAQ;CACR,QAAQ;CACR,kCAAkC;CAClC,0CAA0C;CAC1C,kBAAkB;CAClB,SAAS;CACT,0CAA0C;CAC1C,kDAAkD;AACnD;AACA;EACE,SAAS;CACV,0CAA0C;CAC1C,kDAAkD;AACnD;;AAEA;EACE,kBAAkB;CACnB,yCAAyC;SACjC,iCAAiC;CACzC,WAAW;CACX,cAAc;CACd,SAAS;CACT,OAAO;CACP,kBAAkB;CAClB,SAAS;CACT,QAAQ;AACT;AACA;EACE,UAAU;CACX,OAAO;CACP,QAAQ;CACR,cAAc;CACd,kBAAkB;CAClB,yBAAyB;CACzB,6BAA6B;CAC7B,mBAAmB;CACnB,UAAU;CACV,SAAS;AACV;;AAEA;EACE,kBAAkB;EAClB,iEAAiE;UACzD,yDAAyD;EACjE,WAAW;EACX,cAAc;EACd,YAAY;EACZ,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,WAAW;EACX,UAAU;AACZ;AACA;EACE,kBAAkB;EAClB,uDAAuD;UAC/C,+CAA+C;EACvD,WAAW;EACX,cAAc;EACd,SAAS;EACT,SAAS;EACT,kBAAkB;EAClB,QAAQ;EACR,iCAAiC;UACzB,yBAAyB;EACjC,UAAU;EACV,UAAU;AACZ;;;AAGA;EACE,YAAY;AACd;;AAEA;EACE,YAAY;CACb,QAAQ;CACR,qBAAqB;CACrB,6BAA6B;AAC9B;AACA;EACE,UAAU;CACX,YAAY;CACZ,2BAA2B;CAC3B,mCAAmC;AACpC;AACA;EACE,UAAU;CACX,YAAY;CACZ,wBAAwB;CACxB,gCAAgC;AACjC;;AAEA;EACE,gBAAgB;CACjB,sBAAsB;CACtB,cAAc;CACd,gBAAgB;CAChB,KAAK;CACL,OAAO;AACR;AACA;EACE,UAAU;AACZ;AACA;EACE,QAAQ;CACT,SAAS;CACT,gBAAgB;AACjB;AACA;EACE,gBAAgB;CACjB,eAAe;AAChB;AACA;EACE,sBAAsB;AACxB;AACA;;EAEE,4BAA4B;CAC7B,UAAU;CACV,cAAc;AACf;AACA;EACE,kBAAkB;AACpB;AACA;EACE,WAAW;AACb;AACA;EACE,WAAW;AACb;;AAEA;EACE,QAAQ;EACR,OAAO;EACP,QAAQ;EACR,UAAU;EACV,iBAAiB;EACjB,uBAAuB;EACvB,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,mCAAmC;UAC3B,2BAA2B;AACrC;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,mBAAmB;EACnB,uBAAuB;EACvB,gBAAgB;EAChB,WAAW;AACb;AACA;EACE,sBAAsB;AACxB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,oCAAoC;UAC5B,4BAA4B;EACpC,aAAa;EACb,qDAAqD;UAC7C,6CAA6C;AACvD;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,uDAAuD;UAC/C,+CAA+C;EACvD,QAAQ;EACR,SAAS;EACT,WAAW;EACX,YAAY;EACZ,+BAA+B;EAC/B,6BAA6B;AAC/B;AACA;EACE,QAAQ;EACR,uDAAuD;UAC/C,+CAA+C;AACzD;;AAEA;;EAEE,iCAAiC;AACnC;;AAEA;;EAEE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,UAAU;EACV,uBAAuB;EACvB,4BAA4B;EAC5B,mBAAmB;EACnB,mCAAmC;UAC3B,2BAA2B;EACnC,UAAU;EACV,WAAW;EACX,oBAAoB;EACpB,uCAAuC;UAC/B,+BAA+B;AACzC;AACA;EACE,4BAA4B;EAC5B,UAAU;EACV,WAAW;EACX,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;;;AAGA;EACE,kBAAkB;EAClB,YAAY;EACZ,qBAAqB;EACrB,eAAe;AACjB;AACA;EACE,gBAAgB;EAChB,+BAA+B;EAC/B,8BAA8B;UACtB,sBAAsB;EAC9B,UAAU;EACV,sBAAsB;EACtB,cAAc;AAChB;AACA;EACE,SAAS;AACX;;AAEA;EACE,sBAAsB;AACxB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,SAAS;EACT,SAAS;EACT,aAAa;EACb,WAAW;EACX,gCAAgC;EAChC,eAAe;EACf,gBAAgB;EAChB,mBAAmB;EACnB,kBAAkB;EAClB,kBAAkB;EAClB,8CAA8C;UACtC,sCAAsC;AAChD;AACA;;CAEC;AACD;EACE,cAAc;AAChB;;AAEA;;;EAGE,kBAAkB;AACpB;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,+BAA+B;EAC/B,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,+DAA+D;UACvD,uDAAuD;EAC/D,WAAW;AACb;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,uDAAuD;UAC/C,+CAA+C;EACvD,kBAAkB;EAClB,8BAA8B;EAC9B,gCAAgC;EAChC,wBAAwB;UAChB,gBAAgB;EACxB,8BAA8B;UACtB,sBAAsB;EAC9B,WAAW;AACb;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,uDAAuD;UAC/C,+CAA+C;EACvD,UAAU;EACV,YAAY;EACZ,+BAA+B;EAC/B,8BAA8B;UACtB;AACV;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,aAAa;EACb,QAAQ;EACR,SAAS;EACT,uDAAuD;UAC/C,+CAA+C;EACvD,yEAAyE;UACjE,iEAAiE;AAC3E;;AAEA;;EAEE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,+BAA+B;EAC/B,8BAA8B;UACtB,sBAAsB;EAC9B,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,8BAA8B;EAC9B,8BAA8B;EAC9B,sCAAsC;AACxC;AACA;EACE,8BAA8B;AAChC;;AAEA;EACE,aAAa;AACf;AACA;EACE,UAAU;EACV,iBAAiB;EACjB,cAAc;AAChB;AACA;EACE,UAAU;AACZ;;AAEA;;EAEE,aAAa;AACf;AACA;;EAEE,cAAc;AAChB;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,gBAAgB;EAChB,QAAQ;AACV;AACA;EACE,UAAU;EACV,eAAe;AACjB;;AAEA;EACE,gBAAgB;EAChB,eAAe;EACf,QAAQ;EACR,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,gBAAgB;AAClB;;AAEA;EACE,YAAY;AACd;AACA;EACE,aAAa;AACf;;AAEA;EACE,uBAAuB;EACvB,yDAAu5C;EACv5C,2BAA2B;EAC3B,4BAA4B;EAC5B,YAAY;EACZ,YAAY;EACZ,WAAW;AACb;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,+CAA+C;EAC/C,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;;EAEE,gCAAgC;EAChC,UAAU;AACZ;AACA;EACE,gCAAgC;EAChC,UAAU;AACZ;;AAEA;EACE,wBAAwB;EACxB,iBAAiB;EACjB,eAAe;EACf,6BAA6B;EAC7B,8BAA8B;EAC9B,iBAAiB;AACnB;AACA;EACE,oBAAoB;AACtB;;AAEA;;EAEE,kDAAkD;UAC1C,0CAA0C;AACpD;AACA;EACE,kBAAkB;EAClB,8BAA8B;EAC9B,sBAAsB;EACtB,mBAAmB;EACnB,UAAU;AACZ;AACA;EACE,UAAU;EACV,8BAA8B;UACtB,sBAAsB;EAC9B,kBAAkB;AACpB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gCAAgC;EAChC,WAAW;AACb;AACA;EACE,aAAa;AACf;AACA;EACE,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,aAAa;EACb,YAAY;EACZ,SAAS;EACT,8BAA8B;UACtB,sBAAsB;EAC9B,kBAAkB;EAClB,6BAA6B;EAC7B,uBAAuB;AACzB;AACA;EACE,mCAAmC;AACrC;AACA;EACE,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,SAAS;EACT,8BAA8B;EAC9B,UAAU;EACV,WAAW;EACX,iCAAiC;UACzB,yBAAyB;AACnC;AACA;EACE,cAAc;AAChB;;AAEA;EACE,sCAAsC;EACtC,eAAe;EACf,yBAAyB;EACzB,iBAAiB;EACjB,kBAAkB;EAClB,8BAA8B;UACtB,sBAAsB;EAC9B,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;EACnB,iBAAiB;EACjB,8BAA8B;UACtB,sBAAsB;EAC9B,mDAAmD;EACnD,2CAA2C;EAC3C,mCAAmC;EACnC,0DAA0D;EAC1D,gCAAgC;UACxB,wBAAwB;AAClC;AACA;EACE,sCAAsC;AACxC;AACA;EACE,eAAe;EACf,iCAAiC;UACzB,yBAAyB;AACnC;AACA;EACE,iBAAiB;EACjB,8BAA8B;UACtB,sBAAsB;AAChC;;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,WAAW;EACX,kDAAkD;UAC1C,0CAA0C;EAClD,sBAAsB;EACtB,iBAAiB;EACjB,WAAW;AACb;AACA;;EAEE,qBAAqB;EACrB,aAAa;AACf;AACA;;EAEE,cAAc;AAChB;AACA;EACE,eAAe;EACf,qBAAqB;EACrB,sBAAsB;EACtB,iBAAiB;EACjB,6BAA6B;AAC/B;;AAEA;;EAEE,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,aAAa;EACb,YAAY;EACZ,SAAS;AACX;AACA;EACE,sBAAsB;EACtB;AACF;AACA;EACE,mCAAmC;AACrC;;AAEA,iBAAiB;AACjB;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;AACb;AACA;EACE,gBAAgB;AAClB;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,aAAa;AACf;AACA;EACE,iBAAiB;EACjB,kBAAkB;AACpB;AACA;;EAEE,gBAAgB;EAChB,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,gBAAgB;EAChB,QAAQ;EACR,4BAA4B;EAC5B,8BAA8B;UACtB,sBAAsB;EAC9B,gBAAgB;AAClB;AACA;;EAEE;AACF;AACA;;EAEE,aAAa;AACf;AACA;;EAEE,cAAc;AAChB;;AAEA;;EAEE,kBAAkB;EAClB,KAAK;EACL,MAAM;EACN,OAAO;EACP,YAAY;EACZ,gBAAgB;EAChB,SAAS;EACT,SAAS;EACT,eAAe;EACf,gCAAgC;EAChC,4BAA4B;EAC5B,YAAY;EACZ,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,SAAS;EACT,SAAS;EACT,WAAW;EACX,yBAAyB;EACzB,mCAAmC;AACrC;AACA;;EAEE,UAAU;EACV,kBAAkB;EAClB,QAAQ;EACR,OAAO;EACP,6BAA6B;EAC7B,OAAO;EACP,QAAQ;EACR,gCAAgC;EAChC,wCAAwC;EACxC,WAAW;AACb;;AAEA;;EAEE,SAAS;AACX;AACA;EACE,yBAAyB;EACzB,aAAa;AACf;AACA;EACE,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA;EACE,sBAAsB;EACtB,0BAA0B;EAC1B,WAAW;EACX,cAAc,EAAE,wCAAwC;EACxD,sBAAsB;AACxB;;AAEA;EACE,gBAAgB;EAChB,UAAU;EACV,SAAS;EACT,gBAAgB;EAChB,qCAAqC;EACrC,eAAe;EACf,4BAA4B;EAC5B,oBAAoB;EACpB,kBAAkB;EAClB,KAAK;AACP;;AAEA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,gBAAgB;EAChB,WAAW;AACb;;AAEA;CACC;AACD;;EAEE,YAAY;AACd;;AAEA;EACE,iDAAiD;EACjD,iDAAiD;EACjD,yCAAyC;EACzC,iCAAiC;EACjC,gEAAgE;EAChE,WAAW;EACX,cAAc;EACd,4BAA4B;EAC5B,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,mCAAmC;EACnC,eAAe;EACf;AACF;AACA,kBAAkB;AAClB;EACE,YAAY;EACZ,oBAAoB;EACpB,4BAA4B;AAC9B;AACA;EACE,+BAA+B;EAC/B,WAAW;AACb;AACA;;;EAGE,4BAA4B;EAC5B,oBAAoB;AACtB;;AAEA,sBAAsB;AACtB;;EAEE,4BAA4B;EAC5B,wBAAwB;AAC1B;AACA;;EAEE,yBAAyB;EACzB,0BAA0B;EAC1B,2BAA2B;EAC3B,8BAA8B;EAC9B,sBAAsB;EACtB,kCAAkC;EAClC,0BAA0B;AAC5B;;AAEA;EACE,mCAAmC;AACrC;;AAEA;EACE,qBAAqB;EACrB,aAAa;EACb,eAAe;EACf,gBAAgB;EAChB,mBAAmB;EACnB,uBAAuB;EACvB,oBAAoB;EACpB,kBAAkB;AACpB;;AAEA;EACE,qBAAqB;EACrB,WAAW;EACX,YAAY;EACZ,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;AACrB;AACA;;;;EAIE,WAAW;EACX,kBAAkB;EAClB,WAAW,EAAE,UAAU;EACvB,YAAY,EAAE,aAAa;EAC3B,sBAAsB;EACtB,gBAAgB;EAChB,6BAA6B;UACrB,qBAAqB;AAC/B;;AAEA;;EAEE,kBAAkB;AACpB;;AAEA;EACE,uCAAuC;EACvC,aAAa;EACb,YAAY;EACZ,aAAa;AACf;;AAEA;EACE,uBAAuB;EACvB,yBAAyB;EACzB,mBAAmB;EACnB,kBAAkB;IAChB,YAAY;IACZ,WAAW;IACX,gCAAgC;IAChC,wBAAwB;IACxB,YAAY;IACZ,YAAY;IACZ,wCAAwC;YAChC,gCAAgC;AAC5C;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,YAAY;AACd;AACA;EACE,aAAa;AACf;;AAEA;;EAEE,uBAAuB;EACvB,YAAY;EACZ,WAAW;EACX,kBAAkB;EAClB,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;;;EAIE,WAAW;EACX,iBAAiB;EACjB,YAAY;EACZ,aAAa;EACb,qBAAqB;EACrB,2CAA2C;EAC3C,mCAAmC;AACrC;AACA;;EAEE,mBAAmB;EACnB,UAAU;EACV,WAAW;EACX,uCAAuC;EACvC,+BAA+B;AACjC;AACA;;EAEE,UAAU;EACV,WAAW;EACX,mBAAmB;EACnB,iGAAiG;AACnG;AACA;EACE,aAAa;EACb,YAAY;EACZ,gBAAgB;AAClB;AACA;EACE,qBAAqB;EACrB,kBAAkB;EAClB,eAAe;EACf,UAAU;EACV,SAAS;EACT,UAAU;EACV,gBAAgB;IACd,kBAAkB;IAClB,gBAAgB;IAChB,sBAAsB;IACtB,WAAW;AACf;;AAEA;EACE,qBAAqB;EACrB,kBAAkB;AACpB;;AAEA,eAAe;AACf;EACE,aAAa;EACb,OAAO;EACP,QAAQ;EACR,SAAS;EACT,QAAQ;AACV;;AAEA;EACE,YAAY;EACZ,YAAY;EACZ,sBAAsB;EACtB,YAAY;EACZ,YAAY;EACZ,iBAAiB;AACnB;;AAEA;;EAEE,8BAA8B;EAC9B,mBAAmB;EACnB,2BAA2B;EAC3B,WAAW;EACX,SAAS;EACT,kBAAkB;EAClB,WAAW;EACX,WAAW;EACX,QAAQ;AACV;AACA;EACE,2BAA2B;EAC3B,OAAO;EACP,YAAY;AACd;;AAEA;EACE,gBAAgB;EAChB,mBAAmB;AACrB;AACA;EACE,WAAW;EACX,YAAY;EACZ,cAAc;EACd,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,aAAa;EACb,iBAAiB;EACjB,OAAO;EACP,MAAM;AACR;;AAEA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;EACX,gBAAgB;EAChB,aAAa;EACb,QAAQ;EACR,OAAO;EACP,QAAQ;EACR,kBAAkB;EAClB,gBAAgB;EAChB,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;AACA;EACE,4BAA4B;EAC5B,6BAA6B;EAC7B,WAAW;EACX,cAAc;EACd,kBAAkB;EAClB,SAAS;EACT,UAAU;EACV,QAAQ;EACR,WAAW;AACb;AACA;EACE,2BAA2B;EAC3B,0BAA0B;EAC1B,WAAW;EACX,cAAc;EACd,kBAAkB;EAClB,WAAW;EACX,SAAS;EACT,UAAU;EACV,QAAQ;AACV;;AAEA;;EAEE,aAAa;EACb,6BAA6B;AAC/B;AACA;;EAEE,UAAU;EACV,iBAAiB;EACjB,OAAO;EACP,MAAM;EACN,eAAe;EACf,UAAU;EACV,UAAU;EACV,eAAe;AACjB;AACA;EACE,UAAU;EACV,iBAAiB;EACjB,QAAQ;EACR,KAAK;EACL,gBAAgB;EAChB,SAAS;EACT,WAAW;EACX,eAAe;AACjB;AACA;;;;;;;;;;;;;;;CAeC;;AAED;EACE,iBAAiB;EACjB,sBAAsB;EACtB,WAAW;EACX,YAAY;EACZ,uBAAuB;EACvB,8BAA8B;UACtB,sBAAsB;EAC9B,kBAAkB;EAClB,gBAAgB;EAChB,yGAAyG;EACzG,2EAA2E;EAC3E,eAAe;EACf,+CAA+C;UACvC,uCAAuC;AACjD;;AAEA;;EAEE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;EACT,8BAA8B;EAC9B,kBAAkB;EAClB,wCAAwC;EACxC,gCAAgC;EAChC,UAAU;AACZ;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,WAAW;AACb;AACA;EACE,WAAW;EACX,YAAY;AACd;;AAEA;EACE,YAAY;EACZ,kBAAkB;EAClB,aAAa;EACb,WAAW;EACX,gBAAgB;AAClB;AACA;EACE,WAAW;AACb;;AAEA;EACE,aAAa;EACb,uBAAuB;EACvB,YAAY;AACd;AACA;EACE,sBAAsB;EACtB,UAAU;EACV,aAAa;EACb,OAAO;AACT;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,gBAAgB;EAChB,QAAQ;EACR,4BAA4B;EAC5B,oCAAoC;AACtC;AACA;EACE,OAAO;EACP,wBAAwB;EACxB,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;EAChB,eAAe;EACf,QAAQ;EACR,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,gBAAgB;AAClB;;AAEA;EACE,YAAY;AACd;AACA;EACE,aAAa;EACb,UAAU;AACZ;;AAEA;EACE,YAAY;EACZ,YAAY;AACd;;AAEA;EACE,aAAa;EACb,iBAAiB;AACnB;;AAEA;EACE,kBAAkB;EAClB,6BAA6B;EAC7B,kDAAkD;UAC1C,0CAA0C;EAClD,qBAAqB;EACrB,WAAW;EACX,YAAY;EACZ,UAAU;EACV,kBAAkB;EAClB,sBAAsB;EACtB,gBAAgB;EAChB,sBAAsB;EACtB,cAAc;AAChB;AACA;EACE,YAAY;EACZ,iBAAiB;AACnB;AACA;EACE,aAAa;AACf;;AAEA;EACE,iBAAiB;EACjB,cAAc;AAChB;AACA;;EAEE,qBAAqB;AACvB;;AAEA;EACE,YAAY;AACd;AACA;EACE,oCAAoC;EACpC,WAAW;EACX,SAAS;EACT,cAAc;EACd,OAAO;EACP,SAAS;EACT,gBAAgB;EAChB,kBAAkB;EAClB,QAAQ;EACR,kBAAkB;EAClB,YAAY;EACZ,uCAAuC;EACvC,eAAe;AACjB;AACA;EACE,YAAY;EACZ,UAAU;EACV,UAAU;EACV,eAAe;EACf,cAAc;EACd,kBAAkB;EAClB,gBAAgB;EAChB,sCAAsC;AACxC;AACA;EACE,sCAAsC;AACxC;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,aAAa;AACf;AACA;;EAEE,cAAc;AAChB;AACA;EACE,aAAa;AACf;;AAEA;;EAEE,WAAW;AACb;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,MAAM;EACN,QAAQ;EACR,gBAAgB;EAChB,eAAe;EACf,UAAU;AACZ;AACA;;;EAGE,aAAa;AACf;AACA;EACE,cAAc;EACd,gBAAgB;EAChB,wBAAwB;EACxB,gBAAgB;AAClB;AACA;EACE,uBAAuB;AACzB;AACA;EACE,cAAc;AAChB;AACA;;EAEE,aAAa;AACf;AACA;EACE,cAAc;AAChB;;AAEA;;EAEE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,UAAU;EACV,WAAW;EACX,YAAY;EACZ,8BAA8B;EAC9B,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,UAAU;EACV,WAAW;EACX,aAAa;EACb,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,WAAW;EACX,SAAS;EACT,UAAU;EACV,gBAAgB;AAClB;AACA;;EAEE,aAAa;AACf;AACA;EACE,cAAc;AAChB;AACA;EACE,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,kBAAkB;AACpB;AACA;EACE,gBAAgB;EAChB,UAAU;EACV,mBAAmB;AACrB;AACA;EACE,qBAAqB;EACrB,mBAAmB;AACrB;;AAEA;EACE,qBAAqB;AACvB;AACA;;EAEE,aAAa;AACf;AACA;EACE,WAAW;AACb;AACA;EACE,kBAAkB;EAClB,YAAY;EACZ,gBAAgB;EAChB,SAAS;EACT,4BAA4B;EAC5B,8BAA8B;UACtB,sBAAsB;EAC9B,gBAAgB;AAClB;;AAEA;EACE,QAAQ;AACV;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,iBAAiB;AACnB;AACA;EACE,kBAAkB;AACpB;AACA;EACE,aAAa;AACf;;AAEA;EACE,+BAA+B;EAC/B,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,WAAW;EACX,8BAA8B;EAC9B,YAAY;EACZ,YAAY;EACZ,kBAAkB;EAClB,UAAU;EACV,UAAU;EACV,kBAAkB;EAClB;;;;sCAIoC;UAC5B;;;;;AAKV;;AAEA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,UAAU;EACV,WAAW;EACX,kBAAkB;AACpB;AACA;EACE,aAAa;AACf;AACA;EACE,SAAS;EACT,kBAAkB;EAClB,SAAS;EACT,sCAAsC;EACtC,WAAW;EACX,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,gBAAgB;EAChB,6EAA6E;EAC7E,+BAA+B;UACvB,uBAAuB;EAC/B,6BAA6B;UACrB,qBAAqB;EAC7B,eAAe;AACjB;;AAEA;EACE,WAAW;EACX,SAAS;EACT,SAAS;EACT,gBAAgB;EAChB,SAAS;EACT,UAAU;AACZ;AACA;;EAEE,kBAAkB;EAClB,gCAAgC;EAChC,WAAW;EACX,SAAS;EACT,YAAY;EACZ,0BAA0B;EAC1B,cAAc;EACd,eAAe;EACf,eAAe;EACf,0BAA0B;EAC1B,kBAAkB;EAClB,kBAAkB;EAClB,8BAA8B;UACtB,sBAAsB;EAC9B,mCAAmC;UAC3B,2BAA2B;EACnC,uBAAuB;EACvB,eAAe;EACf,UAAU;AACZ;AACA;EACE,YAAY;EACZ,UAAU;AACZ;;AAEA;EACE,WAAW;EACX,eAAe;AACjB;;AAEA;;EAEE,oBAAoB;AACtB;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,YAAY;AACd;AACA;EACE,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,UAAU;EACV,YAAY;EACZ,iCAAiC;EACjC,YAAY;EACZ,WAAW;EACX,8BAA8B;UACtB,sBAAsB;EAC9B,UAAU;EACV,UAAU;EACV,aAAa;EACb,eAAe;EACf,gBAAgB;EAChB,4BAA4B;EAC5B,oBAAoB;EACpB,oBAAoB;EACpB,UAAU;AACZ;;AAEA;EACE,2BAA2B;EAC3B,mCAAmC;AACrC;AACA;EACE,oCAAoC;EACpC,4BAA4B;AAC9B;AACA;EACE,oCAAoC;EACpC,4BAA4B;AAC9B;AACA;EACE,mCAAmC;EACnC,2BAA2B;AAC7B;AACA;EACE,QAAQ;EACR,SAAS;EACT,WAAW;EACX,gDAAgD;EAChD,wCAAwC;AAC1C;AACA;EACE,2BAA2B;EAC3B,mBAAmB;AACrB;AACA;EACE,QAAQ;EACR,SAAS;EACT,WAAW;EACX,+DAA+D;EAC/D,uDAAuD;AACzD;AACA;EACE,QAAQ;EACR,SAAS;EACT,WAAW;EACX,iDAAiD;EACjD,0CAA0C;AAC5C;AACA;EACE,QAAQ;EACR,SAAS;EACT,WAAW;EACX,iDAAiD;EACjD,0CAA0C;AAC5C;AACA;EACE,UAAU;EACV,uCAAuC;EACvC,gDAAgD;AAClD;AACA;EACE,qDAAqD;EACrD,6CAA6C;AAC/C;AACA;EACE,YAAY;EACZ,yDAAyD;EACzD,iDAAiD;AACnD;AACA;EACE,kEAAkE;EAClE,2DAA2D;EAC3D,iCAAiC;EACjC,yBAAyB;AAC3B;AACA;EACE,iCAAiC;EACjC,yBAAyB;AAC3B;;AAEA;EACE,SAAS;EACT,MAAM;EACN,OAAO;EACP,QAAQ;EACR,SAAS;EACT,uBAAuB;EACvB,eAAe;EACf,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,UAAU;EACV,UAAU;EACV,WAAW;EACX,eAAe;EACf,SAAS;AACX;AACA;EACE,gBAAgB;EAChB,cAAc;EACd,kBAAkB;EAClB,sBAAsB;AACxB;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,SAAS;EACT,QAAQ;AACV;AACA;EACE,kBAAkB;EAClB,eAAe;EACf,gBAAgB;EAChB,8BAA8B;UACtB,sBAAsB;EAC9B,YAAY;EACZ,QAAQ;EACR,SAAS;EACT,wCAAwC;EACxC,gCAAgC;AAClC;AACA;EACE,mBAAmB;AACrB;AACA;EACE,gCAAgC;EAChC,aAAa;EACb,kBAAkB;EAClB,OAAO;EACP,QAAQ;EACR,SAAS;EACT,SAAS;EACT,kBAAkB;AACpB;AACA;EACE,kBAAkB;CACnB,WAAW;CACX,gBAAgB;CAChB,aAAa;AACd;;AAEA;EACE,aAAa;CACd,WAAW;CACX,YAAY;CACZ,UAAU;CACV,qBAAqB;CACrB,qBAAqB;CACrB,eAAe;AAChB;;AAEA;EACE,iBAAiB;CAClB,UAAU;CACV,QAAQ;CACR,SAAS;AACV;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,eAAe;AACjB;AACA;EACE,eAAe;AACjB;;;AAGA;EACE,UAAU;CACX,YAAY;AACb;AACA;EACE,SAAS;CACV,SAAS;AACV;AACA;EACE,eAAe;AACjB;AACA;EACE,eAAe;AACjB;;AAEA;EACE,YAAY;CACb,QAAQ;AACT;AACA;EACE,WAAW;CACZ,OAAO;AACR;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,YAAY;AACd;AACA;EACE,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,cAAc;EACd,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,8BAA8B;EAC9B,OAAO;EACP,MAAM;EACN,YAAY;EACZ,WAAW;EACX,8BAA8B;UACtB,sBAAsB;EAC9B,yBAAyB;EACzB,gBAAgB;AAClB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,8BAA8B;EAC9B,QAAQ;EACR,SAAS;EACT,UAAU;EACV,aAAa;EACb,8BAA8B;UACtB,sBAAsB;EAC9B,yBAAyB;EACzB,cAAc;AAChB;AACA;EACE,QAAQ;EACR,SAAS;AACX;AACA;EACE,WAAW;EACX,WAAW;EACX,aAAa;EACb,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;EACnC,uEAAuE;UAC/D,+DAA+D;AACzE;AACA;EACE,WAAW;EACX,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;EACnC,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,WAAW;EACX,YAAY;EACZ,UAAU;EACV,WAAW;AACb;AACA;EACE,WAAW;AACb;AACA;EACE,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,kBAAkB;EAClB,iBAAiB;EACjB,iBAAiB;EACjB,cAAc;AAChB;AACA;EACE,cAAc;AAChB;;;AAGA;;EAEE,wBAAwB;EACxB,gBAAgB;EAChB,QAAQ;EACR,SAAS;EACT,WAAW;EACX,UAAU;EACV,uBAAuB;UACf,eAAe;EACvB,eAAe;EACf,gBAAgB;EAChB,sBAAsB;EACtB,UAAU;AACZ;AACA;EACE,kBAAkB;EAClB,MAAM;EACN,SAAS;EACT,QAAQ;EACR,wBAAwB;EACxB,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gBAAgB;EAChB,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,+BAA+B;UACvB,uBAAuB;AACjC;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,uBAAuB;AACzB;;AAEA;EACE,kBAAkB;EAClB,kBAAkB;EAClB,MAAM;EACN,SAAS;EACT,OAAO;EACP,WAAW;EACX,sBAAsB;EACtB,YAAY;EACZ,8BAA8B;UACtB,sBAAsB;AAChC;;AAEA;EACE,cAAc;EACd,wBAAwB;EACxB,gBAAgB;AAClB;AACA;EACE,UAAU;EACV,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,cAAc;EACd,eAAe;AACjB;AACA;EACE,aAAa;AACf;AACA;EACE,UAAU;EACV,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,aAAa;EACb,sBAAsB;AACxB;;AAEA;EACE,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,QAAQ;EACR,SAAS;AACX;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,cAAc;EACd,qBAAqB;AACvB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,aAAa;EACb,aAAa;EACb,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;EACnC,WAAW;EACX,8BAA8B;EAC9B,8BAA8B;EAC9B,wBAAwB;EACxB,WAAW;EACX,gBAAgB;EAChB,4CAA4C;UACpC,oCAAoC;AAC9C;;AAEA;EACE,YAAY;EACZ,WAAW;EACX,cAAc;EACd,4CAA4C;UACpC,oCAAoC;AAC9C;AACA;EACE,UAAU;EACV,2CAA2C;UACnC,mCAAmC;AAC7C;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;AACrC;;AAEA;EACE,gBAAgB;EAChB,uBAAuB;EACvB,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;;EAEE,kBAAkB;AACpB;AACA;;EAEE,mCAAmC;EACnC,WAAW;EACX,aAAa;EACb,eAAe;EACf,cAAc;EACd,SAAS;EACT,iBAAiB;EACjB,eAAe;AACjB;AACA;;EAEE,sBAAsB;EACtB,WAAW;AACb;AACA;EACE,aAAa;AACf;;AAEA;EACE,iBAAiB;EACjB,0BAA0B;EAC1B,kBAAkB;EAClB,cAAc;AAChB;AACA;EACE,cAAc;EACd,cAAc;EACd,sBAAsB;EACtB,gBAAgB;EAChB,iBAAiB;EACjB,WAAW;AACb;AACA;EACE,mCAAmC;EACnC,WAAW;EACX,iBAAiB;AACnB;;AAEA;EACE,kBAAkB;EAClB,oBAAoB;EACpB,MAAM;EACN,gCAAgC;EAChC,WAAW;EACX,iBAAiB;EACjB,kBAAkB;EAClB,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;EACnC,0BAA0B;EAC1B,uBAAuB;EACvB,kBAAkB;EAClB,sBAAsB;EACtB,cAAc;EACd,UAAU;AACZ;AACA;EACE,uCAAuC;UAC/B,+BAA+B;AACzC;AACA;EACE,wBAAwB;AAC1B;AACA;EACE,wBAAwB;AAC1B;AACA;EACE,MAAM;EACN,QAAQ;EACR,WAAW;EACX,YAAY;EACZ,YAAY;AACd;;AAEA;EACE,KAAK,UAAU,EAAE,MAAM,EAAE;EACzB,MAAM,UAAU,EAAE,SAAS,EAAE;EAC7B,OAAO,UAAU,EAAE,SAAS,EAAE;AAChC;;AAEA;EACE,KAAK,UAAU,EAAE,MAAM,EAAE;EACzB,MAAM,UAAU,EAAE,SAAS,EAAE;EAC7B,OAAO,UAAU,EAAE,SAAS,EAAE;AAChC;;AAEA;EACE;IACE,mBAAmB;IACnB,oBAAoB;EACtB;EACA;IACE,uBAAuB;EACzB;EACA;IACE,wBAAwB;EAC1B;EACA;IACE,2BAA2B;IAC3B,0BAA0B;IAC1B,sBAAsB;IACtB,uBAAuB;EACzB;EACA;;IAEE,eAAe;IACf,wBAAwB;YAChB,gBAAgB;IACxB,0BAA0B;IAC1B,SAAS;EACX;EACA;;IAEE,uBAAuB;IACvB,gBAAgB;EAClB;EACA;IACE,wBAAwB;IACxB,SAAS;IACT,gBAAgB;EAClB;EACA;IACE,eAAe;IACf,gBAAgB;IAChB,WAAW;IACX,iBAAiB;EACnB;EACA;IACE,iCAAiC;YACzB,yBAAyB;IACjC,kCAAkC;YAC1B,0BAA0B;IAClC,eAAe;EACjB;AACF;;AAEA;EACE;IACE,WAAW;EACb;EACA;IACE,wBAAwB;EAC1B;EACA;IACE,WAAW;IACX,SAAS;EACX;AACF;AACA;;EAEE,WAAW;EACX,WAAW;AACb;AACA;;EAEE,qBAAqB;EACrB,UAAU;EACV,YAAY;AACd;;AAEA;;EAEE,qBAAqB;EACrB,sBAAsB;AACxB;AACA;;EAEE,qBAAqB;EACrB,sBAAsB;EACtB,4BAA4B;EAC5B,OAAO;EACP,UAAU;AACZ;AACA;EACE,kBAAkB;EAClB,yBAAyB;KACtB,sBAAsB;MACrB,qBAAqB;UACjB,iBAAiB;AAC3B;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,UAAU;EACV,iBAAiB;EACjB,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,WAAW;EACX,UAAU;EACV,WAAW;EACX,UAAU;EACV,sBAAsB;EACtB,kBAAkB;EAClB,eAAe;AACjB;AACA;EACE,WAAW;EACX,WAAW;EACX,UAAU;EACV,wBAAwB;EACxB,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,wCAAwC;UAChC,gCAAgC;AAC1C;;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,gBAAgB;AAClB;AACA;EACE,cAAc;EACd,uCAAuC;EACvC,qBAAqB;AACvB;AACA;EACE,aAAa;AACf;;AAEA;EACE,cAAc;AAChB;AACA;EACE,cAAc;EACd,kBAAkB;EAClB,QAAQ;EACR,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,wCAAwC;UAChC,gCAAgC;EACxC,UAAU;EACV,WAAW;EACX,gBAAgB;AAClB;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,cAAc;EACd,8BAA8B;EAC9B,UAAU;EACV,YAAY;EACZ,mEAAmE;UAC3D,2DAA2D;AACrE;AACA;EACE,kEAAkE;UAC1D,0DAA0D;AACpE;;AAEA;EACE,gBAAgB;AAClB;;AAEA;;EAEE,iBAAiB;EACjB,oBAAoB;EACpB,UAAU;EACV,aAAa;AACf;AACA;EACE,QAAQ;EACR,SAAS;AACX;AACA;EACE,UAAU;EACV,oBAAoB;EACpB,cAAc;EACd,YAAY;EACZ,SAAS;EACT,UAAU;AACZ;AACA;;EAEE,eAAe;AACjB;;AAEA;EACE,kBAAkB;EAClB,WAAW;AACb;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,0CAA0C;EAC1C,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,QAAQ;EACR,mBAAmB;AACrB;AACA;EACE,OAAO;AACT;;;AAGA;EACE,cAAc;AAChB;;AAEA;EACE,kBAAkB;AACpB;AACA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,QAAQ;AACV;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,SAAS;EACT,OAAO;EACP,QAAQ;EACR,UAAU;EACV,8BAA8B;EAC9B,6BAA6B;AAC/B;;AAEA;EACE,kBAAkB;EAClB,mCAAmC;EACnC,OAAO;EACP,SAAS;EACT,YAAY;EACZ,QAAQ;EACR,6BAA6B;EAC7B,qBAAqB;EACrB,8BAA8B;UACtB,sBAAsB;AAChC;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,WAAW;EACX,cAAc;EACd,cAAc;EACd,2DAA2D;UACnD,mDAAmD;AAC7D;;AAEA;EACE;IACE,kBAAkB;EACpB;EACA;IACE,mBAAmB;EACrB;AACF;;AAEA;EACE;IACE,kBAAkB;EACpB;EACA;IACE,mBAAmB;EACrB;AACF;;AAEA;EACE,UAAU;EACV,SAAS;EACT,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,WAAW;AACb;AACA;EACE,WAAW;AACb;;AAEA;;EAEE,kBAAkB;AACpB;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,YAAY;EACZ,aAAa;EACb,wCAAwC;EACxC,yGAAyG;UACjG,iGAAiG;EACzG,2BAA2B;EAC3B,UAAU;EACV,UAAU;AACZ;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,YAAY;EACZ,aAAa;EACb,kBAAkB;EAClB,6CAA6C;UACrC,qCAAqC;EAC7C,WAAW;EACX,WAAW;AACb;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,UAAU;EACV,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;EACnC,6HAA6H;UACrH,qHAAqH;EAC7H,kCAAkC;AACpC;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,SAAS;EACT,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;EACnC,kBAAkB;EAClB,8BAA8B;AAChC;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,aAAa;AACf;;AAEA;CACC,aAAa;AACd;AACA;EACE,aAAa;AACf;AACA;EACE,mBAAmB;AACrB;AACA;EACE,qBAAqB;EACrB,mBAAmB;AACrB;AACA;EACE,gBAAgB;EAChB,cAAc;AAChB;AACA;EACE,kBAAkB;EAClB,kBAAkB;AACpB;AACA;EACE,cAAc;EACd,eAAe;EACf,iBAAiB;AACnB;;AAEA;EACE,WAAW;EACX,6BAA6B;EAC7B,kBAAkB;EAClB,aAAa;EACb,yBAAyB;EACzB,4BAA4B;EAC5B,kCAAkC;UAC1B,0BAA0B;EAClC,2CAA2C;UACnC,mCAAmC;EAC3C,UAAU;AACZ;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,aAAa;EACb,YAAY;EACZ,YAAY;EACZ,gBAAgB;EAChB,SAAS;EACT,oBAAoB;AACtB;AACA;EACE,gCAAgC;UACxB,wBAAwB;AAClC;AACA;EACE,gCAAgC;UACxB,wBAAwB;AAClC;AACA;EACE,iCAAiC;UACzB,yBAAyB;AACnC;AACA;EACE,iCAAiC;UACzB,yBAAyB;AACnC;;AAEA;EACE,sBAAsB;EACtB,qBAAqB;EACrB,kBAAkB;AACpB;AACA;;;;EAIE,gBAAgB;EAChB,kBAAkB;EAClB,qBAAqB;EACrB,YAAY;EACZ,aAAa;EACb,uBAAuB;EACvB,6BAA6B;EAC7B,cAAc;EACd,WAAW;EACX,sBAAsB;EACtB,aAAa;EACb,eAAe;AACjB;AACA;;;EAGE,UAAU;EACV,uBAAuB;AACzB;;AAEA;EACE,uCAAuC;AACzC;AACA;EACE,uCAAuC;AACzC;;AAEA;EACE,gBAAgB;AAClB;AACA;CACC,UAAU;CACV,aAAa;CACb,kBAAkB;CAClB,6BAA6B;CAC7B,6BAA6B;CAC7B,qBAAqB;CACrB,qBAAqB;CACrB,2CAA2C;AAC5C;AACA;CACC,gBAAgB;IACb,SAAS;IACT,UAAU;IACV,kBAAkB;AACtB;;AAEA;EACE,UAAU;EACV,SAAS;AACX;AACA;EACE,WAAW;AACb;AACA;EACE,QAAQ;EACR,SAAS;EACT,WAAW;AACb;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,8BAA8B;UACtB,sBAAsB;EAC9B,WAAW;EACX,YAAY;EACZ,6BAA6B;EAC7B,gCAAgC;EAChC,mBAAmB;EACnB,UAAU;EACV,WAAW;AACb;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,YAAY;EACZ,aAAa;EACb,8BAA8B;EAC9B,oBAAoB;EACpB,gCAAgC;UACxB,wBAAwB;EAChC,uCAAuC;UAC/B,+BAA+B;AACzC;;AAEA;EACE,WAAW;EACX,sBAAsB;EACtB,qBAAqB;EACrB,sBAAsB;EACtB,kBAAkB;EAClB,MAAM;EACN,OAAO;AACT;AACA;EACE;AACF;;AAEA;EACE,aAAa;AACf;AACA;EACE,WAAW;EACX,+BAA+B;EAC/B,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,uCAAuC;UAC/B,+BAA+B;EACvC,kBAAkB;EAClB,YAAY;EACZ,aAAa;EACb,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,uCAAuC;UAC/B,+BAA+B;EACvC,WAAW;EACX,YAAY;EACZ,6BAA6B;EAC7B,4GAA4G;UACpG,oGAAoG;AAC9G;;AAEA;EACE,qBAAqB;EACrB,SAAS;EACT,uBAAuB;EACvB,iBAAiB;EACjB,mBAAmB;EACnB,eAAe;EACf,8BAA8B;UACtB,sBAAsB;EAC9B,4BAA4B;EAC5B,oBAAoB;AACtB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,aAAa;AACf;AACA;EACE,cAAc;AAChB;;AAEA;EACE,gBAAgB;EAChB,UAAU;EACV,SAAS;EACT,cAAc;EACd,WAAW;EACX,eAAe;EACf,eAAe;EACf,kBAAkB;EAClB,UAAU;EACV,gBAAgB;AAClB;AACA;;;;;CAKC;AACD;EACE,oBAAoB;EACpB,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;AACzB;AACA;;EAEE,mCAAmC;EACnC,WAAW;AACb;AACA;EACE,WAAW;EACX,eAAe;AACjB;AACA;IACI,0BAA0B;EAC5B,WAAW;AACb;AACA;EACE,WAAW;EACX,qBAAqB;AACvB;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,OAAO;EACP,UAAU;EACV,sDAAsD;UAC9C,8CAA8C;EACtD,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,KAAK,MAAM,EAAE,UAAU,EAAE;EACzB,MAAM,SAAS,EAAE,UAAU,EAAE;EAC7B,OAAO,SAAS,EAAE,QAAQ,EAAE;AAC9B;;AAEA;EACE,KAAK,MAAM,EAAE,UAAU,EAAE;EACzB,MAAM,SAAS,EAAE,UAAU,EAAE;EAC7B,OAAO,SAAS,EAAE,QAAQ,EAAE;AAC9B;;;AAGA;EACE,sCAAsC;EACtC,oBAAoB;AACtB;AACA;EACE,aAAa;AACf;AACA;EACE,gBAAgB;EAChB,WAAW;AACb;AACA;EACE,gBAAgB;EAChB,WAAW;AACb;AACA;EACE,aAAa;AACf;;AAEA;EACE,cAAc;EACd,WAAW;AACb;;AAEA;EACE,iBAAiB;AACnB;AACA;;EAEE,UAAU;EACV,8BAA8B;UACtB,sBAAsB;EAC9B,qBAAqB;EACrB,YAAY;EACZ,cAAc;EACd,gBAAgB;EAChB,uBAAuB;AACzB;AACA;EACE,uBAAuB;AACzB;AACA;EACE,eAAe;EACf,UAAU;EACV,kBAAkB;EAClB,aAAa;AACf;AACA;;EAEE,cAAc;AAChB;AACA;;;EAGE,aAAa;AACf;AACA;EACE,qBAAqB;EACrB,WAAW;EACX,6BAA6B;EAC7B,kBAAkB;EAClB,YAAY;EACZ,aAAa;EACb,aAAa;EACb,cAAc;AAChB;AACA;EACE,4BAA4B;AAC9B;;AAEA,QAAQ;AACR;EACE,aAAa;AACf;AACA;EACE,sBAAsB;AACxB;AACA;EACE,cAAc;EACd,eAAe;EACf,cAAc;EACd,6BAA6B;UACrB,qBAAqB;EAC7B,aAAa;EACb,gBAAgB;EAChB,WAAW;EACX,YAAY;AACd;AACA;EACE,cAAc;AAChB;AACA;;EAEE,WAAW;AACb;AACA;;EAEE,YAAY;EACZ,qBAAqB;EACrB,iBAAiB;EACjB,6BAA6B;UACrB,qBAAqB;EAC7B,mBAAmB;EACnB,6BAA6B;UACrB,qBAAqB;AAC/B;AACA;;EAEE,eAAe;AACjB;;AAEA;EACE,eAAe;EACf,YAAY;EACZ,YAAY;EACZ,eAAe;AACjB;;AAEA;EACE,qBAAqB;EACrB,kBAAkB;AACpB;AACA;;EAEE,aAAa;EACb,UAAU;EACV,iBAAiB;AACnB;AACA;EACE,qBAAqB;AACvB;;AAEA;EACE,WAAW;EACX,gBAAgB;AAClB;AACA;EACE,aAAa;AACf;AACA;EACE,MAAM;EACN,YAAY;EACZ,iBAAiB;EACjB,sBAAsB;EACtB,kBAAkB;AACpB;AACA;EACE,UAAU;EACV,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,WAAW;EACX,YAAY;EACZ,+BAA+B;EAC/B,kBAAkB;EAClB,uCAAuC;UAC/B,+BAA+B;AACzC;AACA;EACE,UAAU;EACV,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,WAAW;EACX,YAAY;EACZ,6BAA6B;EAC7B,uCAAuC;UAC/B,+BAA+B;EACvC;;4FAE0F;UAClF;;4FAEkF;AAC5F;AACA;EACE,SAAS;EACT,SAAS;EACT,sCAAsC;AACxC;AACA;EACE,sCAAsC;AACxC;AACA;EACE,WAAW;AACb;AACA;EACE,YAAY;EACZ,eAAe;EACf,mBAAmB;EACnB,kBAAkB;EAClB,+BAA+B;UACvB,uBAAuB;EAC/B,UAAU;EACV,WAAW;EACX,6BAA6B;EAC7B,+BAA+B;EAC/B,mBAAmB;EACnB,SAAS;EACT,UAAU;EACV,gBAAgB;EAChB,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,SAAS;EACT,YAAY;EACZ,aAAa;EACb,8BAA8B;EAC9B,oBAAoB;EACpB,gCAAgC;UACxB,wBAAwB;EAChC,uCAAuC;UAC/B,+BAA+B;AACzC;AACA;EACE,WAAW;EACX,eAAe;EACf,YAAY;EACZ,mBAAmB;EACnB,aAAa;EACb,kBAAkB;AACpB;AACA;IACI,YAAY;EACd,WAAW;EACX,sBAAsB;EACtB,qBAAqB;EACrB,kBAAkB;EAClB,eAAe;AACjB;AACA;EACE,eAAe;EACf,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,WAAW;EACX,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;EACd,eAAe;AACjB;AACA;EACE,WAAW;EACX,kBAAkB;AACpB;AACA;EACE,cAAc;EACd,aAAa;AACf;AACA;EACE,aAAa;AACf;;AAEA;EACE,eAAe;AACjB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;EAChB,SAAS;EACT,UAAU;AACZ;AACA;;EAEE,UAAU;AACZ;;AAEA;EACE,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,cAAc;EACd,gBAAgB;EAChB,sBAAsB;EACtB,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,eAAe;AACjB;AACA;EACE,WAAW;EACX,6BAA6B;AAC/B;AACA;EACE,aAAa;AACf;;AAEA;;EAEE,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,uBAAuB;AACzB;AACA;;EAEE,aAAa;AACf;AACA;;EAEE,cAAc;AAChB;;AAEA;EACE,MAAM;EACN,OAAO;EACP,0BAA0B;EAC1B,WAAW;EACX,eAAe;EACf,iBAAiB;EACjB,gBAAgB;EAChB,WAAW;EACX,8BAA8B;UACtB,sBAAsB;EAC9B,8BAA8B;EAC9B,aAAa;AACf;AACA;EACE,gBAAgB;AAClB;AACA;EACE,SAAS;EACT,SAAS;AACX;AACA;EACE,MAAM;EACN,SAAS;EACT,2BAA2B;EAC3B,WAAW;AACb;AACA;EACE,MAAM;EACN,SAAS;EACT,UAAU;EACV,QAAQ;EACR,2BAA2B;EAC3B,WAAW;AACb;AACA;EACE,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;AACrC;;AAEA;EACE,SAAS;EACT,UAAU;EACV,YAAY;EACZ,cAAc;EACd,mBAAmB;EACnB,kBAAkB;EAClB,YAAY;EACZ,sCAAsC;AACxC;AACA;EACE,gBAAgB;EAChB,UAAU;EACV,YAAY;EACZ,kBAAkB;AACpB;AACA;EACE,gBAAgB;EAChB,UAAU;EACV,YAAY;EACZ,kBAAkB;EAClB,uBAAuB;EACvB,yBAAyB;KACtB,sBAAsB;MACrB,qBAAqB;UACjB,iBAAiB;AAC3B;AACA;EACE,sBAAsB;AACxB;;AAEA;EACE,kBAAkB;EAClB,aAAa;EACb,gBAAgB;AAClB;AACA;EACE,mBAAmB;AACrB;AACA;EACE,eAAe;EACf,WAAW;AACb;AACA;EACE,eAAe;EACf,UAAU;EACV,sCAAsC;AACxC;;AAEA;;EAEE,kBAAkB;EAClB,iBAAiB;EACjB,wBAAwB;EACxB,kBAAkB;EAClB,eAAe;AACjB;AACA;EACE,qBAAqB;EACrB,cAAc;AAChB;AACA;EACE,kBAAkB;EAClB,cAAc;AAChB;;AAEA;;EAEE,WAAW;EACX,+BAA+B;EAC/B,mBAAmB;EACnB,+DAA+D;EAC/D,WAAW;EACX,YAAY;EACZ,cAAc;EACd,kBAAkB;EAClB,SAAS;EACT,iDAAiD;UACzC,yCAAyC;EACjD,mEAAmE;UAC3D,2DAA2D;EACnE,oBAAoB;AACtB;AACA;EACE,+DAA+D;EAC/D,gEAAgE;UACxD,wDAAwD;AAClE;;AAEA;EACE,MAAM,UAAU,CAAC;EACjB,MAAM,SAAS,CAAC;AAClB;;AAEA;EACE,MAAM,UAAU,CAAC;EACjB,MAAM,SAAS,CAAC;AAClB;AACA;EACE,MAAM,aAAa,CAAC;EACpB,MAAM,YAAY,CAAC;AACrB;AACA;EACE,MAAM,aAAa,CAAC;EACpB,MAAM,YAAY,CAAC;AACrB;;AAEA;EACE,eAAe;AACjB;;AAEA,2BAA2B;AAC3B;;EAEE,MAAM;EACN,SAAS;EACT,6BAA6B;EAC7B,gBAAgB;EAChB,cAAc;AAChB;AACA;;EAEE,sBAAsB;EACtB,cAAc;AAChB;AACA;;EAEE,eAAe;AACjB;AACA;;;;EAIE,UAAU;AACZ;;AAEA;;EAEE,mBAAmB;AACrB;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,YAAY;EACZ,MAAM;EACN,SAAS;EACT,WAAW;EACX,sBAAsB;AACxB;;AAEA;;EAEE,wBAAwB;EACxB,UAAU;EACV,UAAU;EACV,oBAAoB;EACpB,WAAW;EACX,iBAAiB;EACjB,wBAAwB;EACxB,gBAAgB;AAClB;AACA;EACE,6BAA6B;EAC7B,iBAAiB;EACjB,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;EACnC,yBAAyB;UACjB,iBAAiB;AAC3B;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,sBAAsB;EACtB,sBAAsB;EACtB,SAAS;EACT,QAAQ;EACR,wCAAwC;UAChC,gCAAgC;AAC1C;;AAEA;EACE,aAAa;AACf;AACA;EACE,WAAW;EACX,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,kBAAkB;EAClB,cAAc;EACd,yDAAyD;UACjD,iDAAiD;EACzD,kBAAkB;EAClB,6BAA6B;EAC7B,8BAA8B;UACtB,sBAAsB;EAC9B,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,sBAAsB;MAClB,kBAAkB;AACxB;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,YAAY;EACZ,eAAe;EACf,SAAS;EACT,UAAU;EACV,gBAAgB;EAChB,UAAU;EACV,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,aAAa;EACb,cAAc;EACd,QAAQ;EACR,YAAY;EACZ,WAAW;EACX,WAAW;AACb;;AAEA;;EAEE,iBAAiB;AACnB;AACA;;EAEE,iBAAiB;AACnB;;AAEA;;;EAGE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,WAAW;EACX,SAAS;EACT,UAAU;EACV,wBAAwB;EACxB,6BAA6B;EAC7B,qCAAqC;AACvC;AACA;EACE,kCAAkC;UAC1B,0BAA0B;AACpC;AACA;EACE,mCAAmC;UAC3B,2BAA2B;AACrC;;AAEA;EACE,SAAS;EACT,OAAO;EACP,QAAQ;EACR,uBAAuB;EACvB,eAAe;EACf,sCAAsC;AACxC;AACA;EACE,mCAAmC;UAC3B,2BAA2B;AACrC;AACA;EACE,gBAAgB;EAChB,gBAAgB;AAClB;AACA;EACE,gBAAgB;EAChB,UAAU;EACV,uBAAuB;EACvB,gBAAgB;EAChB,WAAW;EACX,cAAc;AAChB;AACA;EACE,sBAAsB;AACxB;;AAEA;EACE,kBAAkB;EAClB,4BAA4B;AAC9B;AACA;EACE,aAAa;EACb,kBAAkB;EAClB,MAAM;EACN,gCAAgC;EAChC,YAAY;EACZ,SAAS;EACT,OAAO;EACP,WAAW;AACb;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;EACd,WAAW;EACX,kBAAkB;AACpB;AACA;;EAEE,YAAY;EACZ,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,YAAY;AACd;;AAEA;EACE,YAAY;EACZ,kBAAkB;AACpB;;AAEA;EACE,gCAAgC;EAChC,WAAW;EACX,SAAS;EACT,kBAAkB;EAClB,aAAa;EACb,cAAc;AAChB;AACA;EACE,kBAAkB;EAClB,eAAe;EACf,WAAW;EACX,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;AACrC;AACA;EACE,WAAW;EACX,UAAU;AACZ;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,aAAa;EACb,SAAS;EACT,aAAa;EACb,mCAAmC;AACrC;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,WAAW;EACX,YAAY;EACZ,cAAc;EACd,mBAAmB;EACnB,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,eAAe;EACf,WAAW;EACX,MAAM;EACN,gBAAgB;EAChB,cAAc;EACd,iBAAiB;EACjB,eAAe;EACf,kBAAkB;EAClB,sBAAsB;EACtB,gBAAgB;EAChB,mBAAmB;EACnB,2BAA2B;EAC3B,mBAAmB;EACnB,eAAe;EACf,8BAA8B;UACtB,sBAAsB;AAChC;;AAEA;;EAEE,UAAU;EACV,6BAA6B;UACrB,qBAAqB;EAC7B,gBAAgB;EAChB,+BAA+B;AACjC;;AAEA,WAAW;AACX;EACE,aAAa;EACb,kBAAkB;EAClB,SAAS;EACT,YAAY;EACZ,UAAU;EACV,SAAS;EACT,UAAU;EACV,oBAAoB;EACpB,mCAAmC;UAC3B,2BAA2B;EACnC,sBAAsB;EACtB,WAAW;AACb;AACA;EACE,uBAAuB;AACzB;;AAEA,gBAAgB;AAChB;EACE,cAAc;AAChB;AACA;;EAEE,WAAW;EACX,+BAA+B;EAC/B,wBAAwB;EACxB,kBAAkB;EAClB,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;AACrC;AACA;EACE,sBAAsB;EACtB,MAAM;AACR;AACA;EACE,yBAAyB;EACzB;AACF;;AAEA,kBAAkB;AAClB;EACE,cAAc;EACd,6BAA6B;EAC7B,oBAAoB;EACpB,uBAAuB;EACvB,+BAA+B;UACvB,uBAAuB;EAC/B,WAAW;AACb;AACA;EACE,MAAM;EACN,SAAS;EACT,mCAAmC;UAC3B,2BAA2B;EACnC,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,WAAW;EACX,YAAY;EACZ,wCAAwC;UAChC,gCAAgC;EACxC,8BAA8B;AAChC;AACA;EACE,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,sBAAsB;AACxB;AACA;EACE,WAAW;EACX,6BAA6B;EAC7B,mCAAmC;UAC3B,2BAA2B;AACrC;AACA;EACE,mBAAmB;EACnB,uBAAuB;EACvB,WAAW;EACX,8BAA8B;EAC9B,8DAA8D;EAC9D,8BAA8B;UACtB,sBAAsB;AAChC;;AAEA;;;;;EAKE,aAAa;AACf;AACA;;;;EAIE,qBAAqB;AACvB;;AAEA;EACE,SAAS;EACT,YAAY;AACd;AACA;EACE,UAAU;AACZ;AACA;EACE,aAAa;AACf;AACA;EACE,YAAY;EACZ,kBAAkB;EAClB,sBAAsB;EACtB,SAAS;EACT,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,WAAW;EACX,YAAY;EACZ,aAAa;EACb,kBAAkB;EAClB,uBAAuB;EACvB,sBAAsB;EACtB,SAAS;EACT,iEAAiE;UACzD,yDAAyD;EACjE,mJAAmJ;UAC3I,2IAA2I;EACnJ,qBAAqB;EACrB,+BAA+B;EAC/B,6BAA6B;AAC/B;;AAEA;EACE,WAAW;AACb;AACA;EACE,WAAW;EACX,WAAW;EACX,YAAY;EACZ,8BAA8B;EAC9B,kBAAkB;EAClB,QAAQ;EACR,kBAAkB;EAClB,cAAc;EACd,uBAAuB;EACvB,oGAAoG;UAC5F,4FAA4F;EACpG,8DAA8D;UACtD,sDAAsD;AAChE;AACA;EACE,OAAO,gCAAgC,EAAE,wBAAwB,EAAE;AACrE;AACA;EACE,OAAO,gCAAgC,EAAE,wBAAwB,EAAE;AACrE;;AAEA;EACE,wBAAwB;EACxB,8BAA8B;UACtB,sBAAsB;EAC9B,0BAA0B;AAC5B;AACA;EACE,UAAU;EACV,YAAY;EACZ,YAAY;AACd;AACA;EACE,YAAY;EACZ,iBAAiB;AACnB;AACA;EACE,aAAa;EACb,gBAAgB;AAClB;AACA;EACE,cAAc;AAChB;;AAEA;EACE,kBAAkB;EAClB,sBAAsB;EACtB,kBAAkB;EAClB,yBAAyB;EACzB,8BAA8B;UACtB,sBAAsB;EAC9B,kBAAkB;AACpB;AACA;EACE,eAAe;EACf,eAAe;EACf,WAAW;EACX,8BAA8B;UACtB,sBAAsB;EAC9B,uBAAuB;EACvB,gBAAgB;AAClB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,mBAAmB;AACrB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,mBAAmB;AACrB;AACA;EACE,iBAAiB;AACnB;;AAEA;EACE,kBAAkB;AACpB;AACA;EACE,mCAAmC;AACrC;AACA;EACE,mCAAmC;EACnC,WAAW;AACb;AACA;EACE,mCAAmC;EACnC,WAAW;AACb;;AAEA;EACE,YAAY;EACZ,YAAY;EACZ,6BAA6B;EAC7B,WAAW;EACX,kBAAkB;EAClB,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,YAAY;EACZ,YAAY;EACZ,6BAA6B;EAC7B,WAAW;EACX,kBAAkB;EAClB,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,WAAW;EACX,cAAc;EACd,gBAAgB;AAClB;AACA;EACE,eAAe;EACf,aAAa;AACf;AACA;EACE,cAAc;AAChB;AACA;EACE,WAAW;EACX,iBAAiB;AACnB;AACA;EACE,SAAS;AACX;AACA;EACE,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,WAAW;AACb;;AAEA;EACE,aAAa;EACb,gBAAgB;EAChB,UAAU;AACZ;AACA;EACE,cAAc;AAChB;AACA;EACE,qBAAqB;EACrB,iBAAiB;EACjB,uBAAuB;EACvB,kBAAkB;AACpB;AACA;EACE,qBAAqB;EACrB,UAAU;EACV,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,WAAW;AACb;AACA;EACE,YAAY;EACZ,aAAa;AACf;;AAEA;EACE,sBAAsB;AACxB;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,aAAa;EACb,SAAS;EACT,sBAAsB;EACtB,WAAW;AACb;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,+BAA+B;EAC/B,QAAQ;EACR,SAAS;EACT,sDAAsD;UAC9C,8CAA8C;AACxD;AACA;EACE,sEAAsE;UAC9D,8DAA8D;EACtE,iCAAiC;UACzB,yBAAyB;AACnC;;AAEA;EACE,YAAY;EACZ,gBAAgB;EAChB,QAAQ;EACR,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,6BAA6B;AAC/B;;AAEA;EACE,aAAa;AACf;AACA;EACE,aAAa;AACf;AACA;EACE,kBAAkB;AACpB;AACA;;EAEE,WAAW;EACX,oBAAoB;AACtB;;AAEA;EACE,YAAY;EACZ,kBAAkB;AACpB;AACA;EACE,YAAY;AACd;AACA;EACE,YAAY;AACd;;AAEA;;EAEE,aAAa;AACf;AACA;EACE,cAAc;EACd,WAAW;AACb;AACA;EACE,6BAA6B;CAC9B,oCAAoC;SAC5B,4BAA4B;CACpC,cAAc;CACd,YAAY;CACZ,QAAQ;AACT;;AAEA;;EAEE,UAAU;CACX,sBAAsB;CACtB,oCAAoC;SAC5B,4BAA4B;CACpC,cAAc;CACd,WAAW;CACX,SAAS;CACT,iBAAiB;CACjB,QAAQ;CACR,UAAU;AACX;AACA;EACE,wBAAwB,EAAE,gBAAgB;CAC3C,YAAY;CACZ,QAAQ;CACR,OAAO;CACP,QAAQ;AACT;;AAEA;EACE;;GAEC;EACD,WAAW;EACX,YAAY;EACZ,WAAW;EACX,kBAAkB;EAClB,eAAe;EACf,gCAAgC;EAChC,wCAAwC;UAChC,gCAAgC;AAC1C;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,UAAU;EACV,WAAW;EACX;AACF;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,WAAW;EACX,UAAU;EACV,kBAAkB;EAClB,eAAe;EACf,gCAAgC;EAChC,gDAAgD;UACxC,wCAAwC;EAChD,QAAQ;EACR,SAAS;EACT,iDAAiD;UACzC,yCAAyC;EACjD,sDAAsD;EACtD,8CAA8C;EAC9C,gBAAgB;AAClB;AACA;EACE,WAAW;EACX,kCAAkC;AACpC;AACA;EACE,iDAAiD;UACzC,yCAAyC;AACnD;AACA;EACE,SAAS;EACT,UAAU;AACZ;AACA;EACE,QAAQ;EACR,UAAU;AACZ;AACA;EACE,SAAS;EACT,UAAU;AACZ;AACA;EACE,SAAS;EACT,SAAS;AACX;AACA;EACE,SAAS;EACT,UAAU;AACZ;AACA,kBAAkB;AAClB;EACE,QAAQ;EACR,UAAU;AACZ;AACA;EACE,SAAS;EACT,UAAU;AACZ;AACA;EACE,SAAS;EACT,SAAS;AACX;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,gBAAgB;EAChB,kBAAkB;AACpB;AACA;;EAEE,YAAY;EACZ,kBAAkB;EAClB,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,YAAY;AACd;AACA;EACE,gBAAgB;EAChB,gBAAgB;EAChB,iBAAiB;AACnB;AACA;EACE,gBAAgB;EAChB,gBAAgB;AAClB;AACA;EACE,gBAAgB;EAChB,iBAAiB;AACnB;;AAEA;;;EAGE,WAAW;EACX,kCAAkC;AACpC;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;AAC1C;;AAEA;EACE,gBAAgB;EAChB,iBAAiB;AACnB;;;;AAIA,4BAA4B;AAC5B;EACE,aAAa;AACf;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,WAAW;EACX,YAAY;EACZ,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,qBAAqB,EAAE,uBAAuB;AAChD;AACA;EACE,2EAA2E;UACnE,mEAAmE;AAC7E;;AAEA;;EAEE,oBAAoB;EACpB,qBAAqB;EACrB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;AAC1C;;AAEA;EACE,4BAA4B;CAC7B,qBAAqB;CACrB,kBAAkB;CAClB,aAAa;CACb,YAAY;CACZ,gBAAgB;CAChB,kDAAkD;SAC1C,0CAA0C;CAClD,iBAAiB;CACjB,SAAS;AACV;;AAEA;EACE,kBAAkB;CACnB,0DAA0D;SAClD,kDAAkD;CAC1D,WAAW;CACX,cAAc;CACd,YAAY;CACZ,OAAO;CACP,kBAAkB;CAClB,MAAM;CACN,WAAW;CACX,UAAU;AACX;;AAEA;;CAEC,kBAAkB;CAClB,uDAAuD;SAC/C,+CAA+C;CACvD,WAAW;CACX,cAAc;CACd,SAAS;CACT,SAAS;CACT,kBAAkB;CAClB,QAAQ;CACR,UAAU;CACV,UAAU;CACV,yBAAyB;CACzB,iCAAiC;AAClC;AACA;CACC;AACD;EACE,kBAAkB;AACpB;;AAEA;EACE,mBAAmB;AACrB;AACA;CACC;AACD;EACE,mBAAmB;EACnB,uBAAuB;UACf,eAAe;EACvB,8CAA8C;UACtC,sCAAsC;AAChD;;AAEA;EACE,OAAO,2BAA2B,EAAE,mBAAmB,EAAE;EACzD,OAAO,6BAA6B,EAAE,sBAAsB;EAC5D,OAAO,8BAA8B,EAAE,uBAAuB;EAC9D,OAAO,2BAA2B,EAAE,mBAAmB,EAAE;AAC3D;;AAEA;EACE,OAAO,2BAA2B,EAAE,mBAAmB,EAAE;EACzD,OAAO,6BAA6B,EAAE,sBAAsB;EAC5D,OAAO,8BAA8B,EAAE,uBAAuB;EAC9D,OAAO,2BAA2B,EAAE,mBAAmB,EAAE;AAC3D;;AAEA,sBAAsB;AACtB;EACE,+BAA+B;UACvB,uBAAuB;AACjC;AACA;EACE,kCAAkC;UAC1B,0BAA0B;AACpC;AACA;EACE,iCAAiC;UACzB,yBAAyB;AACnC;AACA;EACE,4BAA4B;UACpB,oBAAoB;AAC9B;AACA;EACE,+BAA+B;UACvB,uBAAuB;AACjC;AACA;EACE,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,iCAAiC;UACzB,yBAAyB;AACnC;;AAEA;EACE;;GAEC;AACH;;AAEA,cAAc;AACd;EACE,eAAe;EACf,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;AACnB;AACA;EACE,eAAe;EACf,eAAe;EACf,qBAAqB;AACvB;AACA;EACE,mBAAmB;AACrB;AACA;EACE,WAAW;EACX,WAAW;EACX,cAAc;EACd,YAAY;EACZ,SAAS;AACX;;AAEA,qBAAqB;AACrB;EACE,cAAc;EACd,UAAU;EACV,WAAW;EACX,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,oBAAoB;AACtB;AACA;;EAEE,iBAAiB;AACnB;AACA;;EAEE,OAAO;AACT;AACA,wBAAwB,KAAK,EAAE;AAC/B,2BAA2B,QAAQ,EAAE;AACrC,0BAA0B,OAAO,EAAE;AACnC,yBAAyB,MAAM,EAAE;AACjC;EACE,QAAQ;EACR,wBAAwB;AAC1B;AACA;EACE,OAAO;EACP,uBAAuB;AACzB;AACA;EACE,YAAY;AACd;;AAEA,iBAAiB;AACjB;EACE,mBAAmB;EACnB,mBAAmB;EACnB,qBAAqB;EACrB,oBAAoB;EACpB,sBAAsB;EACtB,iCAAiC;UACzB,yBAAyB;AACnC;AACA;EACE,aAAa;AACf;AACA;EACE,uBAAuB;UACf,eAAe;AACzB;;AAEA;EACE,UAAU;EACV,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,eAAe;AACjB;AACA;EACE,WAAW;EACX,WAAW;EACX,YAAY;EACZ,cAAc;EACd,uBAAuB;MACnB,yBAAyB;EAC7B,wBAAwB;EACxB,8BAA8B;UACtB,sBAAsB;EAC9B,YAAY;AACd;;AAEA,+BAA+B;AAC/B;EACE,mDAAmD;UAC3C,2CAA2C;AACrD;;AAEA,eAAe;AACf;EACE,uCAAuC;EACvC,WAAW;EACX,SAAS;EACT,kBAAkB;EAClB,eAAe;EACf,YAAY;EACZ,gBAAgB;EAChB,gBAAgB;EAChB,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,UAAU;EACV,kBAAkB;EAClB,YAAY;AACd;AACA;EACE,aAAa;AACf;;AAEA;EACE,uCAAuC;AACzC;AACA,UAAU;AACV;EACE,gBAAgB;EAChB,eAAe;EACf,QAAQ;EACR,OAAO;EACP,QAAQ;EACR,WAAW;EACX,kBAAkB;EAClB,gBAAgB;EAChB,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA,uBAAuB;AACvB;EACE,sBAAsB;AACxB;AACA;EACE,iBAAiB;EACjB,iBAAiB;EACjB,mBAAmB;AACrB;AACA;EACE,qBAAqB;AACvB;;AAEA,oBAAoB;AACpB;EACE,sBAAsB;AACxB;AACA;EACE,iBAAiB;EACjB,iBAAiB;EACjB,mBAAmB;AACrB;;AAEA,mBAAmB;AACnB;EACE,sBAAsB;EACtB,qBAAqB;EACrB,kBAAkB;AACpB;AACA;EACE,eAAe;EACf,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;EACE,cAAc;EACd,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,mBAAmB;EACnB,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;EACE,kBAAkB;EAClB,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,kBAAkB;EAClB,yCAAyC;UACjC,iCAAiC;AAC3C;AACA;EACE,iBAAiB;EACjB,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,aAAa;EACb,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,cAAc;EACd,sCAAsC;UAC9B,8BAA8B;AACxC;;AAEA;EACE,WAAW;AACb;AACA;;EAEE,UAAU;EACV,sCAAsC;EACtC,mBAAmB;EACnB,kBAAkB;EAClB,eAAe;AACjB;AACA;EACE,8BAA8B;EAC9B,kBAAkB;EAClB,iBAAiB;AACnB;;AAEA;;EAEE,YAAY;EACZ,KAAK;AACP;;AAEA;;EAEE,eAAe;EACf,QAAQ;AACV;;AAEA;EACE,mBAAmB;EACnB,sCAAsC;AACxC;AACA;EACE,mBAAmB;EACnB,8BAA8B;AAChC;AACA;;EAEE,aAAa;AACf;AACA;;EAEE,cAAc;AAChB;;AAEA,qBAAqB;AACrB;EACE,WAAW;EACX,gBAAgB;EAChB,uCAAuC;UAC/B,+BAA+B;AACzC;AACA;EACE,kBAAkB;EAClB,eAAe;EACf,sBAAsB;EACtB,SAAS;EACT,sCAAsC;UAC9B,8BAA8B;EACtC,UAAU;EACV,WAAW;EACX,kBAAkB;EAClB,gBAAgB;EAChB,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,gBAAgB;EAChB,eAAe;EACf,kBAAkB;EAClB,gBAAgB;EAChB,UAAU;EACV,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,gBAAgB;AAClB;AACA;EACE,SAAS;AACX;;AAEA;EACE,WAAW;EACX,mBAAmB;EACnB,uBAAuB;EACvB,UAAU;EACV,YAAY;EACZ,kBAAkB;EAClB,8CAA8C;UACtC,sCAAsC;AAChD;AACA;EACE,WAAW;EACX,sCAAsC;EACtC,mBAAmB;EACnB,wBAAwB;EACxB,oBAAoB;EACpB,QAAQ;AACV;;AAEA,sBAAsB;AACtB;EACE,mBAAmB;AACrB;;AAEA;IACI,wBAAwB;IACxB,kBAAkB;AACtB;;AAEA,sBAAsB;AACtB;EACE,mBAAmB;AACrB;;AAEA,8BAA8B;AAC9B;EACE,gBAAgB;EAChB,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,gBAAgB;EAChB,iCAAiC;EACjC,4CAA4C;UACpC,oCAAoC;EAC5C,YAAY;AACd;AACA;EACE,WAAW;EACX,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,uCAAuC;UAC/B,+BAA+B;EACvC,sCAAsC;EACtC,4BAA4B;EAC5B,oBAAoB;AACtB;;AAEA;EACE,cAAc;EACd,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;;EAEE,cAAc;AAChB;AACA;;EAEE,mBAAmB;IACjB,yBAAyB;IACzB,qBAAqB;IACrB,WAAW;AACf;AACA;;IAEI,oBAAoB;AACxB;;AAEA,oBAAoB;AACpB;EACE,gBAAgB;EAChB,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,gBAAgB;EAChB,wBAAwB;UAChB,gBAAgB;EACxB,6BAA6B;AAC/B;AACA;EACE,WAAW;EACX,6BAA6B;EAC7B,kBAAkB;EAClB,mCAAmC;EACnC,oBAAoB;AACtB;AACA;EACE,cAAc;AAChB;;AAEA;EACE,gBAAgB;EAChB,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,gBAAgB;EAChB,2CAA2C;UACnC,mCAAmC;AAC7C;AACA;EACE,cAAc;AAChB;AACA;;EAEE,mBAAmB;EACnB,yBAAyB;EACzB,mBAAmB;EACnB,WAAW;AACb;AACA;;EAEE,sBAAsB;AACxB;;AAEA;EACE,gBAAgB;AAClB;AACA;EACE;;8GAE4G;EAC5G,wBAAwB;EACxB,mCAAmC;EACnC,qCAAqC;UAC7B,6BAA6B;AACvC;;AAEA,iBAAiB;AACjB;EACE,kCAAkC;EAClC,kBAAkB;EAClB,WAAW;AACb;AACA;EACE,kCAAkC;EAClC,UAAU;AACZ;;AAEA;EACE,eAAe;EACf,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;EACE,iCAAiC;EACjC,kBAAkB;EAClB,UAAU;AACZ;AACA;EACE,cAAc;EACd,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,mBAAmB;EACnB,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;EACE,kBAAkB;EAClB,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,kBAAkB;EAClB,yCAAyC;UACjC,iCAAiC;AAC3C;AACA;EACE,iBAAiB;EACjB,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,cAAc;EACd,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,cAAc;EACd,sCAAsC;UAC9B,8BAA8B;AACxC;;AAEA;EACE,kBAAkB;EAClB,sBAAsB;AACxB;AACA;EACE,UAAU;EACV,sCAAsC;EACtC,mBAAmB;EACnB,uBAAuB;AACzB;;AAEA;EACE,YAAY;EACZ,KAAK;AACP;;AAEA;EACE,eAAe;EACf,QAAQ;AACV;;AAEA;EACE,mBAAmB;EACnB,sCAAsC;AACxC;AACA;EACE,aAAa;AACf;AACA;EACE,cAAc;AAChB;;AAEA;EACE,eAAe;AACjB;;;AAGA,sBAAsB;AACtB;EACE,sBAAsB;EACtB,kBAAkB;EAClB,WAAW;EACX,WAAW;EACX,YAAY;AACd;AACA;EACE,sBAAsB;AACxB;;AAEA;EACE,eAAe;EACf,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,sBAAsB;EACtB,sBAAsB;EACtB,kBAAkB;EAClB,UAAU;AACZ;AACA;EACE,cAAc;EACd,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,mBAAmB;EACnB,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,kBAAkB;EAClB,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,kBAAkB;EAClB,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,iBAAiB;EACjB,oCAAoC;UAC5B,4BAA4B;AACtC;AACA;EACE,QAAQ;EACR,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,cAAc;EACd,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,eAAe;EACf,qCAAqC;UAC7B,6BAA6B;AACvC;;AAEA;EACE,kBAAkB;EAClB,WAAW;AACb;AACA;EACE,UAAU;EACV,sCAAsC;EACtC,mBAAmB;EACnB,uBAAuB;AACzB;;AAEA;EACE,YAAY;EACZ,KAAK;AACP;AACA;EACE,eAAe;EACf,QAAQ;AACV;AACA;EACE,sBAAsB;EACtB,cAAc;AAChB;AACA;EACE,aAAa;EACb,aAAa;AACf;AACA;EACE,cAAc;EACd,cAAc;AAChB;;AAEA;EACE,kBAAkB;EAClB,sCAAsC;EACtC,qBAAqB;AACvB;AACA;EACE,aAAa;AACf;AACA;EACE,cAAc;AAChB;;AAEA,mBAAmB;AACnB;EACE,sBAAsB;EACtB,kBAAkB;EAClB,WAAW;EACX,iBAAiB;AACnB;AACA;EACE,sBAAsB;AACxB;;AAEA;EACE,sBAAsB;EACtB,kBAAkB;EAClB,sBAAsB;EACtB,aAAa;EACb,UAAU;EACV,kBAAkB;EAClB,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;EACE,iBAAiB;EACjB,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,mBAAmB;EACnB,sCAAsC;UAC9B,8BAA8B;AACxC;AACA;EACE,kBAAkB;EAClB,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,kBAAkB;EAClB,yCAAyC;UACjC,iCAAiC;AAC3C;AACA;EACE,iBAAiB;EACjB,qCAAqC;UAC7B,6BAA6B;AACvC;AACA;EACE,QAAQ;EACR,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,aAAa;EACb,uBAAuB;UACf,eAAe;AACzB;AACA;EACE,cAAc;EACd,sCAAsC;UAC9B,8BAA8B;AACxC;;AAEA;EACE,iBAAiB;AACnB;AACA;EACE,UAAU;EACV,8BAA8B;EAC9B,mBAAmB;EACnB,uBAAuB;AACzB;;AAEA;EACE,YAAY;EACZ,KAAK;AACP;AACA;EACE,eAAe;EACf,QAAQ;AACV;;AAEA;EACE,eAAe;AACjB;AACA;EACE,mBAAmB;EACnB,8BAA8B;EAC9B,sBAAsB;AACxB;AACA;EACE,aAAa;AACf;AACA;EACE,cAAc;AAChB;;AAEA;EACE,WAAW;AACb;AACA;EACE,eAAe;EACf,gBAAgB;EAChB,uBAAuB;AACzB;AACA;EACE,gBAAgB;EAChB,iBAAiB;AACnB;AACA;EACE,sBAAsB;AACxB;AACA;EACE,SAAS;EACT,UAAU;EACV,WAAW;EACX,qBAAqB;EACrB,wBAAwB;EACxB,kBAAkB;EAClB,uBAAuB;EACvB,aAAa;AACf;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,8BAA8B;UACtB,sBAAsB;EAC9B,UAAU;EACV,WAAW;EACX,6BAA6B;EAC7B,gCAAgC;EAChC,mBAAmB;EACnB,SAAS;EACT,UAAU;AACZ;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,8BAA8B;UACtB,sBAAsB;EAC9B,WAAW;EACX,YAAY;EACZ,uBAAuB;EACvB,mBAAmB;EACnB,oBAAoB;EACpB,gCAAgC;UACxB,wBAAwB;EAChC,sCAAsC;UAC9B,8BAA8B;AACxC;;AAEA;EACE,YAAY;EACZ,eAAe;AACjB;AACA;;EAEE,mBAAmB;EACnB,2CAA2C;EAC3C,8BAA8B;EAC9B,qBAAqB;EACrB,sBAAsB;EACtB,cAAc;EACd,eAAe;AACjB;AACA;EACE,8BAA8B;AAChC;;AAEA;EACE,6BAA6B;AAC/B;AACA;EACE,8BAA8B;UACtB,sBAAsB;EAC9B,kBAAkB;EAClB,kCAAkC;AACpC;AACA;EACE,sBAAsB;EACtB,kBAAkB;AACpB;;AAEA;EACE,SAAS;AACX;;AAEA;;;EAGE,SAAS;AACX;;AAEA;EACE,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,8BAA8B;EAC9B,sBAAsB;AACxB;AACA;EACE,sBAAsB;MAClB,kBAAkB;EACtB,kBAAkB;EAClB,UAAU;EACV,UAAU;EACV,YAAY;EACZ,gBAAgB;EAChB,UAAU;EACV,kBAAkB;EAClB,kCAAkC;EAClC,0BAA0B;EAC1B,gBAAgB;EAChB,UAAU;AACZ;AACA;EACE,sBAAsB;MAClB,kBAAkB;EACtB,kBAAkB;EAClB,MAAM;EACN,UAAU;EACV,UAAU;EACV,WAAW;EACX,6CAA6C;UACrC,qCAAqC;EAC7C,yBAAyB;EACzB,6BAA6B;EAC7B,8BAA8B;UACtB,sBAAsB;EAC9B,eAAe;AACjB;AACA;EACE,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,WAAW;EACX,YAAY;AACd;AACA,kBAAkB;AAClB;EACE,eAAe;EACf,kBAAkB;AACpB;AACA;;EAEE,aAAa;AACf;AACA;EACE,wBAAwB;EACxB,kBAAkB;EAClB,eAAe;EACf,sBAAsB;EACtB,6DAA6D;EAC7D,qDAAqD;EACrD,YAAY;EACZ,WAAW;EACX,qBAAqB;EACrB,kBAAkB;EAClB,gBAAgB;EAChB,sBAAsB;EACtB,yBAAyB;AAC3B;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,WAAW;EACX,UAAU;EACV,OAAO;EACP,QAAQ;EACR,sBAAsB;EACtB,uBAAuB;EACvB,eAAe;EACf,kBAAkB;EAClB,cAAc;EACd,mCAAmC;UAC3B,2BAA2B;EACnC,sBAAsB;EACtB,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,sBAAsB;AACxB;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,8BAA8B;AAChC;AACA;EACE,uCAAuC;UAC/B,+BAA+B;EACvC,0BAA0B;AAC5B;;AAEA,wBAAwB;AACxB;EACE,kBAAkB;EAClB,qBAAqB;AACvB;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,eAAe;EACf,SAAS;EACT,QAAQ;AACV;AACA;EACE,wBAAwB;EACxB,kBAAkB;EAClB,qBAAqB;EACrB,UAAU;EACV,WAAW;EACX,uBAAuB;EACvB,sBAAsB;EACtB,sBAAsB;AACxB;AACA;EACE,sBAAsB;AACxB;AACA;EACE,8BAA8B;AAChC;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;EACT,wEAAwE;UAChE,gEAAgE;EACxE,4CAA4C;UACpC,oCAAoC;AAC9C;;AAEA;EACE,YAAY;EACZ,aAAa;EACb,kBAAkB;AACpB;AACA;EACE,sBAAsB;AACxB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,kBAAkB;EAClB,8BAA8B;AAChC;;AAEA;EACE,SAAS;EACT,UAAU;EACV,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,oBAAoB;AACtB;AACA;EACE,mCAAmC;AACrC;AACA;EACE,mCAAmC;EACnC,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,sBAAsB;MAClB,kBAAkB;EACtB,QAAQ;EACR,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;EACnC,UAAU;EACV,YAAY;EACZ,gBAAgB;AAClB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,wCAAwC;UAChC,gCAAgC;EACxC,WAAW;EACX,WAAW;EACX,8BAA8B;EAC9B,iCAAiC;UACzB,yBAAyB;EACjC,kBAAkB;AACpB;;AAEA;EACE,UAAU;EACV,aAAa;EACb,6BAA6B;EAC7B;;gFAE8E;EAC9E,0BAA0B;EAC1B,oCAAoC;AACtC;;AAEA;EACE,sBAAsB;EACtB,6BAA6B;EAC7B,aAAa;AACf;AACA;EACE,cAAc;AAChB;;AAEA;EACE,qBAAqB;EACrB,sBAAsB;EACtB,eAAe;EACf,sBAAsB;EACtB,0BAA0B;EAC1B,kBAAkB;EAClB,QAAQ;EACR,eAAe;AACjB;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,yBAAyB;AAC3B;;AAEA;EACE,YAAY;AACd;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;AACA;EACE,cAAc;AAChB;AACA;EACE,aAAa;AACf;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,MAAM;EACN,OAAO;EACP,SAAS;EACT,8BAA8B;EAC9B,oBAAoB;AACtB;;AAEA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,mBAAmB;AACrB;AACA;EACE,oBAAoB;AACtB;;AAEA;EACE,kBAAkB;EAClB,iBAAiB;EACjB,YAAY;EACZ,aAAa;EACb,sBAAsB;EACtB,8BAA8B;EAC9B;8EAC4E;EAC5E;6CAC2C;AAC7C;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gCAAgC;EAChC,kDAAkD;UAC1C,0CAA0C;EAClD,wCAAwC;UAChC,gCAAgC;EACxC,WAAW;EACX,YAAY;EACZ,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,iBAAiB;EACjB,sBAAsB;EACtB,YAAY;EACZ,YAAY;EACZ,kBAAkB;EAClB,sBAAsB;EACtB,mBAAmB;EACnB;;gFAE8E;EAC9E,0BAA0B;EAC1B,oCAAoC;AACtC;AACA;EACE,WAAW;EACX,YAAY;EACZ,2DAA2D;EAC3D,oBAAoB;AACtB;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,YAAY;EACZ,sBAAsB;EACtB,QAAQ;EACR,OAAO;EACP,uBAAuB;EACvB,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,kBAAkB;EAClB,iBAAiB;EACjB,WAAW;EACX,aAAa;EACb,sBAAsB;EACtB,mBAAmB;EACnB,0BAA0B;UAClB,kBAAkB;EAC1B,MAAM;EACN,UAAU;EACV,gMAAgM;EAChM;AACF;AACA;EACE,kBAAkB;EAClB,MAAM;EACN,SAAS;EACT,sBAAsB;EACtB,WAAW;EACX,WAAW;EACX,wCAAwC;UAChC,gCAAgC;AAC1C;;AAEA;EACE,kBAAkB;EAClB,sBAAsB;EACtB,UAAU;EACV,UAAU;EACV,WAAW;EACX,YAAY;AACd;AACA;;EAEE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,WAAW;EACX,sBAAsB;EACtB,QAAQ;EACR,SAAS;EACT,sDAAsD;UAC9C,8CAA8C;AACxD;AACA;EACE,uDAAuD;UAC/C,+CAA+C;AACzD;;AAEA;;EAEE,aAAa;AACf;AACA;EACE,aAAa;AACf;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,aAAa;AACf;AACA;EACE,UAAU;EACV,8BAA8B;UACtB,sBAAsB;EAC9B,kBAAkB;EAClB,sBAAsB;EACtB,kBAAkB;EAClB,eAAe;AACjB;AACA;CACC,kCAAkC;AACnC;AACA;CACC,kCAAkC;AACnC;AACA;CACC,mCAAmC;AACpC;;AAEA;;EAEE,eAAe;EACf,iBAAiB;EACjB,kBAAkB;EAClB,YAAY;EACZ,8BAA8B;UACtB,sBAAsB;EAC9B,UAAU;EACV,sBAAsB;EACtB,kBAAkB;EAClB,cAAc;AAChB;AACA;EACE,sBAAsB;AACxB;AACA;EACE,yBAAyB;AAC3B;;AAEA;EACE,kCAAkC;AACpC;;AAEA;EACE,YAAY;EACZ,qBAAqB;EACrB,YAAY;AACd;AACA;EACE,WAAW;EACX,YAAY;EACZ,qBAAqB;EACrB;;gFAE8E;EAC9E,0BAA0B;EAC1B,iCAAiC;EACjC,WAAW;EACX,oCAAoC;UAC5B,4BAA4B;EACpC,kBAAkB;EAClB,eAAe;EACf,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,8BAA8B;EAC9B,WAAW;EACX,YAAY;AACd;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,YAAY;EACZ,8CAA8C;UACtC,sCAAsC;EAC9C,QAAQ;EACR,SAAS;EACT,sDAAsD;UAC9C,8CAA8C;AACxD;AACA;EACE,oCAAoC;UAC5B,4BAA4B;AACtC;AACA;EACE,SAAS;AACX;;AAEA;EACE,qBAAqB;EACrB,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,wCAAwC;UAChC,gCAAgC;EACxC,sBAAsB;EACtB,UAAU;EACV,aAAa;EACb,UAAU;EACV,UAAU;EACV,SAAS;EACT,gBAAgB;EAChB,mBAAmB;AACrB;AACA;;EAEE,cAAc;AAChB;AACA;EACE,UAAU;EACV,WAAW;AACb;AACA;EACE,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;AACrC;;;AAGA;EACE,kBAAkB;EAClB,iBAAiB;AACnB;;AAEA;EACE,sBAAsB;AACxB;AACA;EACE,sBAAsB;AACxB;;AAEA;;EAEE,kBAAkB;EAClB,OAAO;EACP,yBAAyB;UACjB,iBAAiB;EACzB,6BAA6B;EAC7B,qBAAqB;EACrB,sBAAsB;AACxB;AACA;EACE,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,sBAAsB;EACtB,kBAAkB;EAClB,sBAAsB;EACtB;AACF;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,UAAU;EACV,QAAQ;EACR,6BAA6B;EAC7B,0BAA0B;AAC5B;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;AACrB;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,aAAa;EACb,qBAAqB;EACrB,sBAAsB;EACtB,uBAAuB;EACvB,oCAAoC;UAC5B,4BAA4B;EACpC,kBAAkB;EAClB,+BAA+B;UACvB,uBAAuB;EAC/B,yBAAyB;KACtB,sBAAsB;MACrB,qBAAqB;UACjB,iBAAiB;EACzB,sBAAsB;AACxB;AACA;EACE,WAAW;EACX,kBAAkB;EAClB,uBAAuB;EACvB,yBAAyB;EACzB,8BAA8B;EAC9B,YAAY;EACZ,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;EACnC,oBAAoB;AACtB;;AAEA;EACE,+BAA+B;UACvB,uBAAuB;AACjC;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,eAAe;EACf,OAAO;EACP,wCAAwC;UAChC,gCAAgC;EACxC,cAAc;EACd,sBAAsB;EACtB,aAAa;EACb,UAAU;AACZ;AACA;EACE,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,SAAS;EACT,UAAU;AACZ;;AAEA;EACE,mBAAmB;EACnB,YAAY;EACZ,YAAY;EACZ,sBAAsB;AACxB;;AAEA;EACE,sBAAsB;EACtB,kBAAkB;EAClB,sBAAsB;EACtB,UAAU;EACV,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,8BAA8B;EAC9B,WAAW;EACX,6BAA6B;EAC7B,8BAA8B;UACtB,sBAAsB;AAChC;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,wCAAwC;UAChC,gCAAgC;AAC1C;AACA;EACE,WAAW;EACX,UAAU;EACV,WAAW;EACX,sBAAsB;EACtB,uDAAuD;UAC/C,+CAA+C;AACzD;;AAEA;EACE,qBAAqB;EACrB,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,wCAAwC;UAChC,gCAAgC;EACxC,sBAAsB;EACtB,UAAU;EACV,aAAa;EACb,UAAU;AACZ;AACA;EACE,UAAU;EACV,WAAW;AACb;AACA;;EAEE,cAAc;EACd,mBAAmB;AACrB;AACA;;EAEE,qBAAqB;EACrB,sBAAsB;AACxB;AACA;;EAEE,iBAAiB;AACnB;AACA;;EAEE,kBAAkB;AACpB;AACA;EACE,qBAAqB;EACrB,sBAAsB;EACtB,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,2BAA2B;EAC3B,uBAAuB;EACvB,wCAAwC;UAChC,gCAAgC;EACxC,+BAA+B;UACvB,uBAAuB;EAC/B,eAAe;AACjB;;AAEA;EACE,kBAAkB;EAClB,UAAU;EACV,YAAY;EACZ,QAAQ;EACR,wCAAwC;UAChC,gCAAgC;EACxC,sBAAsB;EACtB,oBAAoB;AACtB;AACA;EACE,eAAe;EACf,YAAY;AACd;AACA;EACE,mBAAmB;EACnB,eAAe;EACf,WAAW;EACX,kBAAkB;EAClB,+BAA+B;AACjC;AACA;EACE,oBAAoB;AACtB;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,mCAAmC;UAC3B,2BAA2B;EACnC,SAAS;EACT,UAAU;EACV,YAAY;EACZ,+BAA+B;EAC/B,oBAAoB;AACtB;;AAEA;;EAEE,kBAAkB;EAClB,OAAO;EACP,yBAAyB;UACjB,iBAAiB;EACzB,6BAA6B;EAC7B,qBAAqB;EACrB,sBAAsB;AACxB;AACA;EACE,WAAW;AACb;;AAEA,SAAS;AACT;EACE,YAAY;EACZ,wBAAwB;UAChB,gBAAgB;AAC1B;AACA;EACE,QAAQ;EACR,WAAW;EACX,2BAA2B;EAC3B,4BAA4B;EAC5B,sCAAsC;EACtC,oBAAoB;AACtB;;AAEA;EACE,UAAU;EACV,wBAAwB;EACxB,qBAAqB;EACrB,mBAAmB;EACnB,8BAA8B;EAC9B,wBAAwB;KACrB,qBAAqB;EACxB,6BAA6B;EAC7B,sCAAsC;UAC9B,8BAA8B;AACxC;;AAEA;EACE,YAAY;AACd;;;AAGA;EACE,sBAAsB;EACtB,YAAY;EACZ,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,kEAAkE;EAClE,6BAA6B;EAC7B,oBAAoB;AACtB","sourcesContent":[".ol-control i {\r\n  cursor: default;\r\n}\r\n\r\n/* Bar style */\r\n.ol-control.ol-bar {\r\n  left: 50%;\r\n  min-height: 1em;\r\n  min-width: 1em;\r\n  position: absolute;\r\n  top: 0.5em;\r\n  transform: translate(-50%,0);\r\n  -webkit-transform: translate(-50%,0);\r\n  white-space: nowrap;\r\n}\r\n\r\n/* Hide subbar when not inserted in a parent bar */\r\n.ol-control.ol-toggle .ol-option-bar {\r\n  display: none;\r\n}\r\n\r\n/* Default position for controls */\r\n.ol-control.ol-bar .ol-bar {\r\n  position: static;\r\n}\r\n.ol-control.ol-bar .ol-control {\r\n  position: relative;\r\n  top: auto;\r\n  left:auto;\r\n  right:auto;\r\n  bottom: auto;\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n  background-color: transparent;\r\n  padding: 0;\r\n  margin: 0;\r\n  transform: none;\r\n  -webkit-transform: none;\r\n}\r\n.ol-control.ol-bar .ol-bar {\r\n  position: static;\r\n}\r\n.ol-control.ol-bar .ol-control button {\r\n  margin:2px 1px;\r\n  outline: none;\r\n}\r\n\r\n/* Positionning */\r\n.ol-control.ol-bar.ol-left {\r\n  left: 0.5em;\r\n  top: 50%;\r\n  -webkit-transform: translate(0px, -50%);\r\n          transform: translate(0px, -50%);\r\n}\r\n.ol-control.ol-bar.ol-left .ol-control {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-bar.ol-right {\r\n  left: auto;\r\n  right: 0.5em;\r\n  top: 50%;\r\n  -webkit-transform: translate(0px, -50%);\r\n          transform: translate(0px, -50%);\r\n}\r\n.ol-control.ol-bar.ol-right .ol-control {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-bar.ol-bottom {\r\n  top: auto;\r\n  bottom: 0.5em;\r\n}\r\n\r\n.ol-control.ol-bar.ol-top.ol-left,\r\n.ol-control.ol-bar.ol-top.ol-right {\r\n  top: 4.5em;\r\n  -webkit-transform:none;\r\n          transform:none;\r\n}\r\n.ol-touch .ol-control.ol-bar.ol-top.ol-left,\r\n.ol-touch .ol-control.ol-bar.ol-top.ol-right {\r\n  top: 5.5em;\r\n}\r\n.ol-control.ol-bar.ol-bottom.ol-left,\r\n.ol-control.ol-bar.ol-bottom.ol-right {\r\n  top: auto;\r\n  bottom: 0.5em;\r\n  -webkit-transform:none;\r\n          transform:none;\r\n}\r\n\r\n/* Group buttons */\r\n.ol-control.ol-bar.ol-group {\r\n  margin: 1px 1px 1px 0;\r\n}\r\n.ol-control.ol-bar.ol-right .ol-group,\r\n.ol-control.ol-bar.ol-left .ol-group {\r\n  margin: 1px 1px 0 1px;\r\n}\r\n\r\n.ol-control.ol-bar.ol-group button {\r\n  border-radius:0;\r\n  margin: 0 0 0 1px;\r\n}\r\n.ol-control.ol-bar.ol-right.ol-group button,\r\n.ol-control.ol-bar.ol-left.ol-group button,\r\n.ol-control.ol-bar.ol-right .ol-group button,\r\n.ol-control.ol-bar.ol-left .ol-group button {\r\n  margin: 0 0 1px 0;\r\n}\r\n.ol-control.ol-bar.ol-group .ol-control:first-child > button {\r\n  border-radius: 5px 0 0 5px;\r\n}\r\n.ol-control.ol-bar.ol-group .ol-control:last-child > button {\r\n  border-radius: 0 5px 5px 0;\r\n}\r\n.ol-control.ol-bar.ol-left.ol-group .ol-control:first-child > button,\r\n.ol-control.ol-bar.ol-right.ol-group .ol-control:first-child > button,\r\n.ol-control.ol-bar.ol-left .ol-group .ol-control:first-child > button,\r\n.ol-control.ol-bar.ol-right .ol-group .ol-control:first-child > button {\r\n  border-radius: 5px 5px 0 0;\r\n}\r\n.ol-control.ol-bar.ol-left.ol-group .ol-control:last-child > button,\r\n.ol-control.ol-bar.ol-right.ol-group .ol-control:last-child > button,\r\n.ol-control.ol-bar.ol-left .ol-group .ol-control:last-child > button,\r\n.ol-control.ol-bar.ol-right .ol-group .ol-control:last-child > button {\r\n  border-radius: 0 0 5px 5px;\r\n}\r\n\r\n/* */\r\n.ol-control.ol-bar .ol-rotate {\r\n  opacity:1;\r\n  visibility: visible;\r\n}\r\n.ol-control.ol-bar .ol-rotate button {\r\n  display: block\r\n}\r\n\r\n/* Active buttons */\r\n.ol-control.ol-bar .ol-toggle.ol-active > button,\r\n.ol-control.ol-bar .ol-toggle.ol-active button:hover {\r\n  background-color: #00AAFF;\r\n  color: #fff;\r\n}\r\n.ol-control.ol-toggle button:disabled {\r\n  background-color: #ccc;\r\n}\r\n\r\n/* Subbar toolbar */\r\n.ol-control.ol-bar .ol-control.ol-option-bar {\r\n  display: none;\r\n  position:absolute;\r\n  top:100%;\r\n  left:0;\r\n  margin: 5px 0;\r\n  border-radius: 0;\r\n  background-color: rgba(255,255,255, 0.8);\r\n  /* border: 1px solid rgba(0, 60, 136, 0.5); */\r\n  -webkit-box-shadow: 0 0 0 1px rgba(0, 60, 136, 0.5), 1px 1px 2px rgba(0, 0, 0, 0.5);\r\n          box-shadow: 0 0 0 1px rgba(0, 60, 136, 0.5), 1px 1px 2px rgba(0, 0, 0, 0.5);\r\n}\r\n\r\n.ol-control.ol-bar .ol-option-bar:before {\r\n  content: \"\";\r\n  border: 0.5em solid transparent;\r\n  border-color: transparent transparent rgba(0, 60, 136, 0.5);\r\n  position: absolute;\r\n  bottom: 100%;\r\n  left: 0.3em;\r\n  pointer-events: none;\r\n}\r\n\r\n.ol-control.ol-bar .ol-option-bar .ol-control {\r\n  display: table-cell;\r\n}\r\n.ol-control.ol-bar .ol-control .ol-bar\r\n{\tdisplay: none;\r\n}\r\n.ol-control.ol-bar .ol-control.ol-active > .ol-option-bar {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-bar .ol-control.ol-collapsed ul {\r\n  display: none;\r\n}\r\n\r\n.ol-control.ol-bar .ol-control.ol-text-button > div:hover,\r\n.ol-control.ol-bar .ol-control.ol-text-button > div {\r\n  background-color: transparent;\r\n  color: rgba(0, 60, 136, 0.5);\r\n  width: auto;\r\n  min-width: 1.375em;\r\n  margin: 0;\r\n}\r\n\r\n.ol-control.ol-bar .ol-control.ol-text-button {\r\n  font-size:0.9em;\r\n  border-left: 1px solid rgba(0, 60, 136, 0.8);\r\n  border-radius: 0;\r\n}\r\n.ol-control.ol-bar .ol-control.ol-text-button:first-child {\r\n  border-left:0;\r\n}\r\n.ol-control.ol-bar .ol-control.ol-text-button > div {\r\n  padding: .11em 0.3em;\r\n  font-weight: normal;\r\n  font-size: 1.14em;\r\n  font-family: Arial,Helvetica,sans-serif;\r\n}\r\n.ol-control.ol-bar .ol-control.ol-text-button div:hover {\r\n  color: rgba(0, 60, 136, 1);\r\n}\r\n\r\n.ol-control.ol-bar.ol-bottom .ol-option-bar {\r\n  top: auto;\r\n  bottom: 100%;\r\n}\r\n.ol-control.ol-bar.ol-bottom .ol-option-bar:before {\r\n  border-color: rgba(0, 60, 136, 0.5) transparent transparent ;\r\n  bottom: auto;\r\n  top: 100%;\r\n}\r\n\r\n.ol-control.ol-bar.ol-left .ol-option-bar {\r\n  left:100%;\r\n  top: 0;\r\n  bottom: auto;\r\n  margin: 0 5px;\r\n}\r\n.ol-control.ol-bar.ol-left .ol-option-bar:before {\r\n  border-color: transparent rgba(0, 60, 136, 0.5) transparent transparent;\r\n  bottom: auto;\r\n  right: 100%;\r\n  left: auto;\r\n  top: 0.3em;\r\n}\r\n.ol-control.ol-bar.ol-right .ol-option-bar {\r\n  right:100%;\r\n  left:auto;\r\n  top: 0;\r\n  bottom: auto;\r\n  margin: 0 5px;\r\n}\r\n.ol-control.ol-bar.ol-right .ol-option-bar:before {\r\n  border-color: transparent transparent transparent rgba(0, 60, 136, 0.5);\r\n  bottom: auto;\r\n  left: 100%;\r\n  top: 0.3em;\r\n}\r\n\r\n.ol-control.ol-bar.ol-left .ol-option-bar .ol-option-bar,\r\n.ol-control.ol-bar.ol-right .ol-option-bar .ol-option-bar {\r\n  top: 100%;\r\n  bottom: auto;\r\n  left: 0.3em;\r\n  right: auto;\r\n  margin: 5px 0;\r\n}\r\n.ol-control.ol-bar.ol-right .ol-option-bar .ol-option-bar {\r\n  right: 0.3em;\r\n  left: auto;\r\n}\r\n.ol-control.ol-bar.ol-left .ol-option-bar .ol-option-bar:before,\r\n.ol-control.ol-bar.ol-right .ol-option-bar .ol-option-bar:before {\r\n  border-color: transparent transparent rgba(0, 60, 136, 0.5);\r\n  bottom: 100%;\r\n  top: auto;\r\n  left: 0.3em;\r\n  right: auto;\r\n}\r\n.ol-control.ol-bar.ol-right .ol-option-bar .ol-option-bar:before {\r\n  right: 0.3em;\r\n  left: auto;\r\n}\r\n\r\n.ol-control-title {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n}\r\n\r\n.ol-center-position {\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  background-color: rgba(255,255,255,.8);\r\n  padding: .1em 1em;\r\n}\r\n\r\n.ol-compassctrl {\r\n  display: none;\r\n  top: 1em;\r\n  left: auto;\r\n  right: 1em;\r\n}\r\n.ol-compassctrl.ol-visible {\r\n  display: block!important;\r\n}\r\n.ol-ext-dialog {\r\n  position: fixed;\r\n  top: -100%;\r\n  left: 0;\r\n  width: 150%;\r\n  height: 100%;\r\n  opacity: 0;\r\n  background-color: rgba(0,0,0,.5);\r\n  z-index: 1000;\r\n  pointer-events: none!important;\r\n  -webkit-transition: opacity .2s, top 0s .2s;\r\n  transition: opacity .2s, top 0s .2s;\r\n}\r\n.ol-ext-dialog.ol-visible {\r\n  opacity: 1;\r\n  top: 0;\r\n  pointer-events: all!important;\r\n  -webkit-transition: opacity .2s, top 0s;\r\n  transition: opacity .2s, top 0s;\r\n}\r\n\r\n.ol-viewport .ol-ext-dialog {\r\n  position: absolute;\r\n}\r\n.ol-ext-dialog > form > h2 {\r\n  margin: 0 .5em .5em 0;\r\n  display: none;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.ol-ext-dialog > form.ol-title > h2 {\r\n  display: block;\r\n}\r\n.ol-ext-dialog > form {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 33.33%;\r\n  min-width: 5em;\r\n  max-width: 60%;\r\n  min-height: 3em;\r\n  max-height: 100%;\r\n  background-color: #fff;\r\n  border: 1px solid #333;\r\n  -webkit-box-shadow: 3px 3px 4px rgba(0,0,0, 0.5);\r\n          box-shadow: 3px 3px 4px rgba(0,0,0, 0.5);\r\n  -webkit-transform: translate(-50%, -30%);\r\n          transform: translate(-50%, -30%);\r\n  -webkit-transition: top .2s, -webkit-transform .2s;\r\n  transition: top .2s, -webkit-transform .2s;\r\n  transition: top .2s, transform .2s;\r\n  transition: top .2s, transform .2s, -webkit-transform .2s;\r\n  padding: 1em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  overflow-x: hidden;\r\n  overflow-y: auto;\r\n}\r\n.ol-ext-dialog > form.ol-closebox {\r\n  padding-top: 1.5em;\r\n}\r\n.ol-ext-dialog > form.ol-title {\r\n  padding-top: 1em;\r\n}\r\n.ol-ext-dialog > form.ol-button {\r\n  padding-bottom: .5em;\r\n}\r\n\r\n.ol-ext-dialog.ol-zoom > form {\r\n  top: 30%;\r\n  -webkit-transform: translate(-50%, -30%) scale(0);\r\n          transform: translate(-50%, -30%) scale(0);\r\n}\r\n.ol-ext-dialog.ol-visible > form {\r\n  top: 30%;\r\n}\r\n.ol-ext-dialog.ol-zoom.ol-visible > form {\r\n  -webkit-transform: translate(-50%, -30%) scale(1);\r\n          transform: translate(-50%, -30%) scale(1);\r\n}\r\n\r\n.ol-ext-dialog > form .ol-content {\r\n  overflow-x: hidden;\r\n  overflow-y: auto;\r\n}\r\n\r\n.ol-ext-dialog > form .ol-closebox {\r\n  position: absolute;\r\n  top: .5em;\r\n  right: .5em;\r\n  width: 1em;\r\n  height: 1em;\r\n  cursor: pointer;\r\n  display: none;\r\n}\r\n.ol-ext-dialog > form.ol-closebox .ol-closebox {\r\n  display: block;\r\n}\r\n.ol-ext-dialog > form .ol-closebox:before,\r\n.ol-ext-dialog > form .ol-closebox:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  background-color: currentColor;\r\n  top: 50%;\r\n  left: 50%;\r\n  width: 1em;\r\n  height: .1em;\r\n  border-radius: .1em;\r\n  -webkit-transform: translate(-50%, -50%) rotate(45deg);\r\n          transform: translate(-50%, -50%) rotate(45deg);\r\n}\r\n.ol-ext-dialog > form .ol-closebox:before {\r\n  -webkit-transform: translate(-50%, -50%) rotate(-45deg);\r\n          transform: translate(-50%, -50%) rotate(-45deg);\r\n}\r\n\r\n.ol-ext-dialog > form .ol-buttons {\r\n  text-align: right;\r\n  overflow-x: hidden;\r\n}\r\n.ol-ext-dialog > form .ol-buttons input {\r\n  margin-top: .5em;\r\n  padding: .5em;\r\n  background: none;\r\n  border: 0;\r\n  font-size: 1em;\r\n  color: rgba(0,60,136,1);\r\n  cursor: pointer;\r\n  border-radius: .25em;\r\n  outline-width: 0;\r\n}\r\n.ol-ext-dialog > form .ol-buttons input:hover {\r\n  background-color:  rgba(0,60,136,.1);\r\n}\r\n.ol-ext-dialog > form .ol-buttons input[type=submit] {\r\n  font-weight: bold;\r\n}\r\n\r\n.ol-ext-dialog .ol-progress-message {\r\n  font-size: .9em;\r\n  text-align: center;\r\n  padding-bottom: .5em;\r\n}\r\n.ol-ext-dialog .ol-progress-bar {\r\n  border: 1px solid #369;\r\n  width: 20em;\r\n  height: 1em;\r\n  max-width: 100%;\r\n  padding: 2px;\r\n  margin: .5em auto 0;\r\n  overflow: hidden;\r\n}\r\n.ol-ext-dialog .ol-progress-bar > div {\r\n  background: #369;\r\n  height: 100%;\r\n  width: 50%;\r\n  -webkit-transition: width .3s;\r\n  transition: width .3s;\r\n}\r\n.ol-ext-dialog .ol-progress-bar > div.notransition {\r\n  -webkit-transition: unset;\r\n  transition: unset;\r\n}\r\n\r\n/* full screen */\r\n.ol-ext-dialog.ol-fullscreen-dialog form {\r\n  top: 1em;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n  left: 1em;\r\n  bottom: 1em;\r\n  right: 1em;\r\n  max-width: calc(66.6% - 2em);\r\n  text-align: center;\r\n  background: transparent;\r\n  -webkit-box-shadow: none;\r\n          box-shadow: none;\r\n  border: none;\r\n  color: #fff;\r\n}\r\n.ol-ext-dialog.ol-fullscreen-dialog form .ol-closebox {\r\n  top: 0;\r\n  right: 0;\r\n  font-size: 2em;\r\n}\r\n.ol-ext-dialog.ol-fullscreen-dialog .ol-closebox:before,\r\n.ol-ext-dialog.ol-fullscreen-dialog .ol-closebox:after {\r\n  border: .1em solid currentColor;\r\n}\r\n.ol-ext-dialog.ol-fullscreen-dialog img,\r\n.ol-ext-dialog.ol-fullscreen-dialog video {\r\n  max-width: 100%;\r\n}\r\n\r\n/* Fullscreen dialog */\r\nbody > .ol-ext-dialog .ol-content {\r\n  max-height: calc(100vh - 10em);\r\n}\r\n\r\nbody > .ol-ext-dialog > form {\r\n  overflow: visible;\r\n}\r\n.ol-editbar .ol-button button {\r\n  position: relative;\r\n  display: inline-block;\r\n  font-style: normal;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  vertical-align: middle;\r\n}\r\n.ol-editbar .ol-button button:before, \r\n.ol-editbar .ol-button button:after {\r\n  content: \"\";\r\n  border-width: 0;\r\n  position: absolute;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  background-color: currentColor;\r\n}\r\n.ol-editbar .ol-button button:focus {\r\n  outline: none;\r\n}\r\n\r\n.ol-editbar .ol-selection > button:before {\r\n  width: .6em;\r\n  height: 1em;\r\n  background-color: transparent;\r\n  border: .5em solid currentColor;\r\n  border-width: 0 .25em .65em;\r\n  border-color: currentColor transparent;\r\n  -webkit-box-shadow:0 0.6em 0 -0.23em;\r\n          box-shadow:0 0.6em 0 -0.23em;\r\n  top: .35em;\r\n  left: .5em;\r\n  -webkit-transform: translate(-50%, -50%) rotate(-30deg);\r\n          transform: translate(-50%, -50%) rotate(-30deg);\r\n}\r\n.ol-editbar .ol-selection0 > button:after {\r\n  width: .28em;\r\n  height: .6em;\r\n  background-color: transparent;\r\n  border: .5em solid currentColor;\r\n  border-width: 0 .05em .7em;\r\n  border-color: currentColor transparent;\r\n  top: .5em;\r\n  left: .7em;\r\n  -webkit-transform: rotate(-45deg);\r\n          transform: rotate(-45deg);\r\n}\r\n\r\n.ol-editbar .ol-delete button:after,\r\n.ol-editbar .ol-delete button:before {\r\n  width: 1em;\r\n  height: .2em;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(45deg);\r\n          transform: translate(-50%, -50%) rotate(45deg);\r\n}\r\n.ol-editbar .ol-delete button:after {\r\n  -webkit-transform: translate(-50%, -50%) rotate(-45deg);\r\n          transform: translate(-50%, -50%) rotate(-45deg);\r\n}\r\n\r\n.ol-editbar .ol-info button:before {\r\n  width: .25em;\r\n  height: .6em;\r\n  border-radius: .03em;\r\n  top: .47em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n.ol-editbar .ol-info button:after {\r\n  width: .25em;\r\n  height: .2em;\r\n  border-radius: .03em;\r\n  -webkit-box-shadow: -0.1em 0.35em, -0.1em 0.82em, 0.1em 0.82em;\r\n          box-shadow: -0.1em 0.35em, -0.1em 0.82em, 0.1em 0.82em;\r\n  top: .12em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n\r\n.ol-editbar .ol-drawpoint button:before {\r\n  width: .7em;\r\n  height: .7em;\r\n  border-radius: 50%;\r\n  border: .15em solid currentColor;\r\n  background-color: transparent;\r\n  top: .2em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n.ol-editbar .ol-drawpoint button:after {\r\n  width: .4em;\r\n  height: .4em;\r\n  border: .15em solid currentColor;\r\n  border-color: currentColor transparent;\r\n  border-width: .4em .2em 0;\r\n  background-color: transparent;\r\n  top: .8em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n\r\n.ol-editbar .ol-drawline > button:before,\r\n.ol-editbar .ol-drawpolygon > button:before,\r\n.ol-editbar .ol-drawhole > button:before {\r\n  width: .8em;\r\n  height: .8em;\r\n  border: .13em solid currentColor;\r\n  background-color: transparent;\r\n  border-width: .2em .13em .09em;\r\n  top: .2em;\r\n  left: .25em;\r\n  -webkit-transform: rotate(10deg) perspective(1em) rotateX(40deg);\r\n          transform: rotate(10deg) perspective(1em) rotateX(40deg);\r\n}\r\n.ol-editbar .ol-drawline > button:before {\r\n  border-bottom: 0;\r\n}\r\n.ol-editbar .ol-drawline > button:after,\r\n.ol-editbar .ol-drawhole > button:after,\r\n.ol-editbar .ol-drawpolygon > button:after {\r\n  width: .3em;\r\n  height: .3em;\r\n  top: 0.2em;\r\n  left: .25em;\r\n  -webkit-box-shadow: -0.2em 0.55em, 0.6em 0.1em, 0.65em 0.7em;\r\n          box-shadow: -0.2em 0.55em, 0.6em 0.1em, 0.65em 0.7em;\r\n}\r\n.ol-editbar .ol-drawhole > button:after {\r\n  -webkit-box-shadow: -0.2em 0.55em, 0.6em 0.1em, 0.65em 0.7em, 0.25em 0.35em;\r\n          box-shadow: -0.2em 0.55em, 0.6em 0.1em, 0.65em 0.7em, 0.25em 0.35em;\r\n}\r\n\r\n\r\n.ol-editbar .ol-offset > button i,\r\n.ol-editbar .ol-transform > button i {\r\n  position: absolute;\r\n  width: .9em;\r\n  height: .9em;\r\n  overflow: hidden;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-editbar .ol-offset > button i{\r\n  width: .8em;\r\n  height: .8em;\r\n}\r\n\r\n.ol-editbar .ol-offset > button i:before,\r\n.ol-editbar .ol-transform > button i:before,\r\n.ol-editbar .ol-transform > button i:after {\r\n  content: \"\";\r\n  height: 1em;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(45deg);\r\n          transform: translate(-50%, -50%) rotate(45deg);\r\n  -webkit-box-shadow: 0.5em 0 0 0.1em, -0.5em 0 0 0.1em;\r\n          box-shadow: 0.5em 0 0 0.1em, -0.5em 0 0 0.1em;\r\n  width: .1em;\r\n  position: absolute;\r\n  background-color: currentColor;\r\n}\r\n.ol-editbar .ol-offset > button i:before{\r\n  -webkit-box-shadow: 0.45em 0 0 0.1em, -0.45em 0 0 0.1em;\r\n          box-shadow: 0.45em 0 0 0.1em, -0.45em 0 0 0.1em;\r\n}\r\n.ol-editbar .ol-transform > button i:after {\r\n  -webkit-transform: translate(-50%, -50%) rotate(-45deg);\r\n          transform: translate(-50%, -50%) rotate(-45deg);\r\n}\r\n\r\n.ol-editbar .ol-split > button:before {\r\n  width: .3em;\r\n  height: .3em;\r\n  top: .81em;\r\n  left: .75em;\r\n  border-radius: 50%;\r\n  -webkit-box-shadow: 0.1em -0.4em, -0.15em -0.25em;\r\n          box-shadow: 0.1em -0.4em, -0.15em -0.25em;\r\n}\r\n.ol-editbar .ol-split > button:after {\r\n  width: .8em;\r\n  height: .8em;\r\n  top: .15em;\r\n  left: -.1em;\r\n  border: .1em solid currentColor;\r\n  border-width: 0 .2em .2em 0;\r\n  background-color: transparent;\r\n  border-radius: .1em;\r\n  -webkit-transform: rotate(20deg) scaleY(.6) rotate(-45deg);\r\n          transform: rotate(20deg) scaleY(.6) rotate(-45deg);\r\n}\r\n\r\n.ol-editbar .ol-drawregular > button:before {\r\n  width: .9em;\r\n  height: .9em;\r\n  top: 50%;\r\n  left: 50%;\r\n  border: .1em solid currentColor;\r\n  background-color: transparent;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-editbar .ol-drawregular .ol-bar .ol-text-button > div > div > div {\r\n  border: .5em solid currentColor;\r\n  border-color: transparent currentColor;\r\n  display: inline-block;\r\n  cursor: pointer;\r\n  vertical-align: text-bottom;\r\n}\r\n.ol-editbar .ol-drawregular .ol-bar:before,\r\n.ol-control.ol-bar.ol-editbar .ol-drawregular .ol-bar {\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n.ol-editbar .ol-drawregular .ol-bar .ol-text-button {\r\n  min-width: 6em;\r\n  text-align: center;\r\n}\r\n.ol-editbar .ol-drawregular .ol-bar .ol-text-button > div > div > div:first-child {\r\n  border-width: .5em .5em .5em 0;\r\n  margin: 0 .5em 0 0;\r\n}\r\n.ol-editbar .ol-drawregular .ol-bar .ol-text-button > div > div > div:last-child {\r\n  border-width: .5em 0 .5em .5em;\r\n  margin: 0 0 0 .5em;\r\n}\r\n\r\n.ol-feature-list {\r\n  position: relative;\r\n}\r\n.ol-control.ol-feature-list {\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 100%;\r\n}\r\n.ol-control.ol-feature-list > button:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 60%;\r\n  height: 50%;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  -webkit-box-shadow: inset 0 2.5px;\r\n          box-shadow: inset 0 2.5px;  \r\n  background-image: -webkit-gradient(linear, left top, right top, from(currentColor), to(transparent));  \r\n  background-image: linear-gradient(90deg, currentColor, transparent);\r\n}\r\n\r\n.ol-control.ol-feature-list.ol-collapsed {\r\n  bottom: .5em;\r\n  left: .5em;\r\n  width: auto;\r\n}\r\n.ol-feature-list .ol-content {\r\n  background-color: #f4f6f8;\r\n  clear: both;\r\n}\r\n.ol-feature-list.ol-collapsed .ol-content > * {\r\n  display: none;\r\n}\r\n.ol-feature-list .ol-header {\r\n  position: relative;\r\n  overflow: hidden;\r\n}\r\n.ol-feature-list.ol-collapsed .ol-header {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-feature-list > button,\r\n.ol-control.ol-feature-list.ol-collapsed .ol-content {\r\n  display: none;\r\n}\r\n.ol-control.ol-feature-list.ol-collapsed > button {\r\n  display: block;\r\n}\r\n\r\n.ol-feature-list .ol-sizer {\r\n  width: 100%;\r\n  height: 1px;\r\n  cursor: row-resize;\r\n  background-color: #ccc;\r\n  position: relative;\r\n  border: 1px solid #f4f6f8;\r\n  border-width: 1px 0;\r\n}\r\n.ol-feature-list.ol-bottom .ol-sizer {\r\n  position: absolute;\r\n  bottom: 0;\r\n}\r\n.ol-feature-list .ol-sizer:before {\r\n  content: \"\";\r\n  width: 1.5em;\r\n  height: 4px;\r\n  background-color: #ddd;\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  z-index: 1;\r\n  border: 3px solid transparent;\r\n  border-width: 3px 1.5em;\r\n  -webkit-box-shadow: inset 0 -1px #aaa, inset 0 1px #aaa;\r\n          box-shadow: inset 0 -1px #aaa, inset 0 1px #aaa;\r\n  border-radius: 2px;\r\n}\r\n.ol-feature-list .ol-sizer:hover:before {\r\n  background-color: #ccc;\r\n}\r\n\r\n.ol-feature-list .ol-content .ol-header p {\r\n  display: inline-block;\r\n  margin: 0.1em .25em;\r\n  vertical-align: middle;\r\n  white-space: nowrap;\r\n  width: calc(100% - 2em);\r\n  text-overflow: ellipsis;\r\n  overflow: hidden;\r\n}\r\n.ol-feature-list .ol-content .ol-header .ol-buttons {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 50%;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n}\r\n\r\n.ol-feature-list .ol-content .ol-header button {\r\n  position: relative;\r\n  border: 0;\r\n  background: transparent;\r\n  vertical-align: middle;\r\n  width: 1em;\r\n  height: 1em;\r\n  margin: 0 .2em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-feature-list .ol-content .ol-header button.ol-closebox:before,\r\n.ol-feature-list .ol-content .ol-header button.ol-closebox:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(45deg);\r\n          transform: translate(-50%, -50%) rotate(45deg);\r\n  background: currentColor;\r\n  width: .1em;\r\n  height: 1em;\r\n  display: block;\r\n  font-style: normal;\r\n}\r\n.ol-feature-list .ol-content .ol-header button.ol-closebox:after {\r\n  -webkit-transform: translate(-50%, -50%) rotate(-45deg);\r\n          transform: translate(-50%, -50%) rotate(-45deg);\r\n}\r\n\r\n.ol-feature-list.ol-collapsed .ol-content .ol-header button.ol-closebox {\r\n  border: 1px solid currentColor;\r\n}\r\n.ol-feature-list.ol-collapsed .ol-content .ol-header button.ol-closebox:before {\r\n  -webkit-transform: translate(-50%, -50%) rotate(90deg);\r\n          transform: translate(-50%, -50%) rotate(90deg);\r\n}\r\n.ol-feature-list.ol-collapsed .ol-content .ol-header button.ol-closebox:after {\r\n  display: none;\r\n}\r\n\r\n.ol-feature-list .ol-scroll-container {\r\n  overflow: auto;\r\n  height: 10em;\r\n  min-height: 3em;\r\n}\r\n.ol-feature-list .ol-scroll-container:focus {\r\n  outline: unset;\r\n}\r\n\r\n.ol-feature-list table {\r\n  background-color: #fff;\r\n  border-collapse: collapse;\r\n  white-space: nowrap;\r\n  position: relative;\r\n}\r\n.ol-feature-list table thead {\r\n  background-color: #f4f6f8;\r\n  position: -webkit-sticky;\r\n  position: sticky;\r\n  top: 0;\r\n  overflow: hidden;\r\n}\r\n/* Fixed height */\r\n.ol-feature-list table tr {\r\n  height: 1.4em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-feature-list table tbody tr:hover {\r\n  background-color: #eee;\r\n  cursor: pointer;\r\n}\r\n\r\n.ol-feature-list table tbody tr.ol-selected {\r\n  background-color: #eee;\r\n}\r\n\r\n.ol-feature-list table td {\r\n  border: 0 solid #ddd;\r\n  border-width: 0 0 1px 1px;\r\n  overflow: hidden;\r\n  width: 100px;\r\n}\r\n.ol-feature-list table td.number {\r\n  text-align: right;\r\n}\r\n.ol-feature-list table td.undefined {\r\n  text-align: center;\r\n  background-color: #fafafa;\r\n}\r\n.ol-feature-list table tr:hover td,\r\n.ol-feature-list table .ol-selected td {\r\n  background-color: transparent;\r\n}\r\n.ol-feature-list thead td {\r\n  position: relative;\r\n}\r\n.ol-feature-list thead td.sort {\r\n  padding-right: 1.5em;\r\n}\r\n\r\n.ol-feature-list thead td p {\r\n  margin: 0;\r\n  display: inline-block;\r\n}\r\n.ol-feature-list table td button {\r\n  position: absolute;\r\n  width: 1.2em;\r\n  height: 1.4em;\r\n  top: 0;\r\n  right: 0;\r\n  margin: .1em 0;\r\n  padding: 0;\r\n  background-color: transparent;\r\n  border: 0;\r\n}\r\n.ol-feature-list thead td button.sort:before {\r\n  content: '⇅';\r\n  font-style: normal;\r\n  font-weight: normal;\r\n  cursor: pointer;\r\n  font-size: 1em;\r\n  line-height: 1em;\r\n}\r\n.ol-feature-list thead td button.sortup:before {\r\n  content: '↧';\r\n}\r\n.ol-feature-list thead td button.sortdown:before {\r\n  content: '↥';\r\n}\r\n\r\n.ol-gauge {\r\n  top: 0.5em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n  transform: translateX(-50%);\r\n  background-color: rgba(255,255,255,.5);\r\n  padding: 0.1em 0.5em;\r\n}\r\n\r\n.ol-gauge > * {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n.ol-gauge > span {\r\n  margin: 0 0.5em 0 0;\r\n}\r\n.ol-gauge > div {\r\n  display: inline-block;\r\n  width: 200px;\r\n  border: 1px solid rgba(0,60,136,.5);\r\n  border-radius: 3px;\r\n  padding:1px;\r\n}\r\n.ol-gauge button {\r\n  height: 0.8em;\r\n  margin:0;\r\n  max-width:100%;\r\n}\r\n\r\n.ol-control.ol-bookmark {\r\n  top: 0.5em;\r\n  left: 3em;\r\n  background-color: rgba(255,255,255,.5);\r\n}\r\n.ol-control.ol-bookmark button {\r\n  position: relative;\r\n}\r\n.ol-control.ol-bookmark > button::before {\r\n  content: \"\";\r\n  position: absolute;\r\n  border-width: 10px 5px 4px;\r\n  border-style: solid;\r\n  border-color: currentColor;\r\n  border-bottom-color: transparent;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n  transform: translate(-50%, -50%);\r\n  height: 0;\r\n}\r\n\r\n\r\n.ol-control.ol-bookmark > div {\r\n  display: block;\r\n  min-width: 5em;\r\n}\r\n.ol-control.ol-bookmark.ol-collapsed > div {\r\n  display: none;\r\n}\r\n.ol-control.ol-bookmark input {\r\n  font-size: 0.9em;\r\n  margin: 0 0.5em 0.5em;\r\n  padding: 0 0.5em;\r\n}\r\n.ol-control.ol-bookmark ul {\r\n  margin: 0 0 0.5em;\r\n  padding: 0;\r\n  list-style: none;\r\n  min-width: 10em;\r\n}\r\n.ol-control.ol-bookmark li {\r\n  color: rgba(0,60,136,0.8);\r\n  font-size: 0.9em;\r\n  padding: 0 0.2em 0 0.5em;\r\n  cursor: default;\r\n  clear:both;\r\n}\r\n\r\n.ol-control.ol-bookmark li:hover {\r\n  background-color: rgba(0,60,136,.5);\r\n  color: #fff;\r\n}\r\n\r\n.ol-control.ol-bookmark > div button {\r\n  width: 1em;\r\n  height: 0.8em;\r\n  float: right;\r\n  background-color: transparent;\r\n  cursor: pointer;\r\n  border-radius: 0;\r\n}\r\n.ol-control.ol-bookmark > div button:before {\r\n  content: \"\\2A2F\";\r\n  color: #936;\r\n  font-size: 1.2em;\r\n  line-height: 1em;\r\n  border-radius: 0;\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    -webkit-transform: translate(-50%, -50%);\r\n    transform: translate(-50%, -50%);\r\n}\r\n\r\n.ol-bookmark ul li button,\r\n.ol-bookmark input {\r\n  display: none;\r\n}\r\n.ol-bookmark.ol-editable ul li button,\r\n.ol-bookmark.ol-editable input {\r\n  display: block;\r\n}\r\n\r\n\r\n.ol-control.ol-geobt {\r\n  top: auto;\r\n  left: auto;\r\n  right: .5em;\r\n  bottom: 3em;\r\n}\r\n.ol-touch .ol-control.ol-geobt {\r\n  bottom: 3.5em;\r\n}\r\n.ol-control.ol-geobt button:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  background: transparent;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  border: .16em solid currentColor;\r\n  width: .4em;\r\n  height: .4em;\r\n  border-radius: 50%;\r\n}\r\n.ol-control.ol-geobt button:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: .2em;\r\n  height: .2em;\r\n  background: transparent;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  -webkit-box-shadow: .42em 0, -.42em 0, 0 .42em, 0 -.42em;\r\n          box-shadow: .42em 0, -.42em 0, 0 .42em, 0 -.42em;\r\n}\r\n\r\n.ol-control.ol-bar.ol-geobar .ol-control {\r\n\tdisplay: inline-block;\r\n\tvertical-align: middle;\r\n}\r\n\r\n.ol-control.ol-bar.ol-geobar .ol-bar {\r\n  display: none;\r\n}\r\n.ol-bar.ol-geobar.ol-active .ol-bar {\r\n  display: inline-block;\r\n}\r\n\r\n.ol-bar.ol-geobar .geolocBt button:before,\r\n.ol-bar.ol-geobar .geolocBt button:after {\r\n  content: \"\";\r\n  display: block;\r\n  position: absolute;\r\n  border: 1px solid transparent;\r\n  border-width: 0.3em 0.8em 0 0.2em;\r\n  border-color: currentColor transparent transparent;\r\n  -webkit-transform: rotate(-30deg);\r\n  transform: rotate(-30deg);\r\n  top: .45em;\r\n  left: 0.15em;\r\n  font-size: 1.2em;\r\n}\r\n.ol-bar.ol-geobar .geolocBt button:after {\r\n  border-width: 0 0.8em .3em 0.2em;\r\n  border-color: transparent transparent currentColor;\r\n\t-webkit-transform: rotate(-61deg);\r\n\ttransform: rotate(-61deg);\r\n}\r\n\r\n.ol-bar.ol-geobar .startBt button:before {\r\n  content: \"\";\r\n  display: block;\r\n  position: absolute;\r\n  width: 1em;\r\n  height: 1em;\r\n  background-color: #800;\r\n  border-radius: 50%;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%,-50%);\r\n  transform: translate(-50%,-50%);\r\n}\r\n.ol-bar.ol-geobar .pauseBt button:before,\r\n.ol-bar.ol-geobar .pauseBt button:after {\r\n  content: \"\";\r\n  display: block;\r\n  position: absolute;\r\n  width: .25em;\r\n  height: 1em;\r\n  background-color: currentColor;\r\n  top: 50%;\r\n  left: 35%;\r\n  -webkit-transform: translate(-50%,-50%);\r\n  transform: translate(-50%,-50%);\r\n}\r\n.ol-bar.ol-geobar .pauseBt button:after {\r\n  left: 65%;\r\n}\r\n\r\n.ol-control.ol-bar.ol-geobar .centerBt,\r\n.ol-control.ol-bar.ol-geobar .pauseBt,\r\n.ol-bar.ol-geobar.pauseTrack .startBt,\r\n.ol-bar.ol-geobar.centerTrack .startBt,\r\n.ol-bar.ol-geobar.centerTrack.pauseTrack .pauseBt,\r\n.ol-bar.ol-geobar.centerTrack .pauseBt {\r\n  display: none;\r\n}\r\n.ol-bar.ol-geobar.pauseTrack .pauseBt,\r\n.ol-bar.ol-geobar.centerTrack .centerBt{\r\n  display: inline-block;\r\n}\r\n\r\n.ol-control.ol-globe\r\n{\tposition: absolute;\r\n\tleft: 0.5em;\r\n\tbottom: 0.5em;\r\n\tborder-radius: 50%;\r\n\topacity: 0.7;\r\n\ttransform: scale(0.5);\r\n\ttransform-origin: 0 100%;\r\n\t-webkit-transform: scale(0.5);\r\n\t-webkit-transform-origin: 0 100%;\r\n}\r\n.ol-control.ol-globe:hover\r\n{\topacity: 0.9;\r\n}\r\n\r\n.ol-control.ol-globe .panel\r\n{\tdisplay:block;\r\n\twidth:170px;\r\n\theight:170px;\r\n\tbackground-color:#fff;\r\n\tcursor: pointer;\r\n\tborder-radius: 50%;\r\n\toverflow: hidden;\r\n\t-webkit-box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.5);\r\n\t        box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.5);\r\n}\r\n.ol-control.ol-globe .panel .ol-viewport\r\n{\tborder-radius: 50%;\r\n}\r\n\r\n.ol-control.ol-globe .ol-pointer\r\n{\tdisplay: block;\r\n\tbackground-color: #fff;\r\n\twidth:10px;\r\n\theight: 10px;\r\n\tborder:10px solid red;\r\n\tposition: absolute;\r\n\ttop: 50%;\r\n\tleft:50%;\r\n\ttransform: translate(-15px, -40px);\r\n\t-webkit-transform: translate(-15px, -40px);\r\n\tborder-radius: 50%;\r\n\tz-index:1;\r\n\ttransition: opacity 0.15s, top 0s, left 0s;\r\n\t-webkit-transition: opacity 0.15s, top 0s, left 0s;\r\n}\r\n.ol-control.ol-globe .ol-pointer.hidden\r\n{\topacity:0;\r\n\ttransition: opacity 0.15s, top 3s, left 5s;\r\n\t-webkit-transition: opacity 0.15s, top 3s, left 5s;\r\n}\r\n\r\n.ol-control.ol-globe .ol-pointer::before\r\n{\tborder-radius: 50%;\r\n\t-webkit-box-shadow: 6px 6px 10px 5px #000;\r\n\t        box-shadow: 6px 6px 10px 5px #000;\r\n\tcontent: \"\";\r\n\tdisplay: block;\r\n\theight: 0;\r\n\tleft: 0;\r\n\tposition: absolute;\r\n\ttop: 23px;\r\n\twidth: 0;\r\n}\r\n.ol-control.ol-globe .ol-pointer::after\r\n{\tcontent:\"\";\r\n\twidth:0;\r\n\theight:0;\r\n\tdisplay: block;\r\n\tposition: absolute;\r\n\tborder-width: 20px 10px 0;\r\n\tborder-color: red transparent;\r\n\tborder-style: solid;\r\n\tleft: -50%;\r\n\ttop: 100%;\r\n}\r\n\r\n.ol-control.ol-globe .panel::before {\r\n  border-radius: 50%;\r\n  -webkit-box-shadow: -20px -20px 80px 2px rgba(0, 0, 0, 0.7) inset;\r\n          box-shadow: -20px -20px 80px 2px rgba(0, 0, 0, 0.7) inset;\r\n  content: \"\";\r\n  display: block;\r\n  height: 100%;\r\n  left: 0;\r\n  position: absolute;\r\n  top: 0;\r\n  width: 100%;\r\n  z-index: 1;\r\n}\r\n.ol-control.ol-globe .panel::after {\r\n  border-radius: 50%;\r\n  -webkit-box-shadow: 0 0 20px 7px rgba(255, 255, 255, 1);\r\n          box-shadow: 0 0 20px 7px rgba(255, 255, 255, 1);\r\n  content: \"\";\r\n  display: block;\r\n  height: 0;\r\n  left: 23%;\r\n  position: absolute;\r\n  top: 20%;\r\n  -webkit-transform: rotate(-40deg);\r\n          transform: rotate(-40deg);\r\n  width: 20%;\r\n  z-index: 1;\r\n}\r\n\r\n\r\n.ol-control.ol-globe.ol-collapsed .panel\r\n{\tdisplay:none;\r\n}\r\n\r\n.ol-control-top.ol-globe\r\n{\tbottom: auto;\r\n\ttop: 5em;\r\n\ttransform-origin: 0 0;\r\n\t-webkit-transform-origin: 0 0;\r\n}\r\n.ol-control-right.ol-globe\r\n{\tleft: auto;\r\n\tright: 0.5em;\r\n\ttransform-origin: 100% 100%;\r\n\t-webkit-transform-origin: 100% 100%;\r\n}\r\n.ol-control-right.ol-control-top.ol-globe\r\n{\tleft: auto;\r\n\tright: 0.5em;\r\n\ttransform-origin: 100% 0;\r\n\t-webkit-transform-origin: 100% 0;\r\n}\r\n\r\n.ol-gridreference\r\n{\tbackground: #fff;\r\n\tborder: 1px solid #000;\r\n\toverflow: auto;\r\n\tmax-height: 100%;\r\n\ttop:0;\r\n\tright:0;\r\n}\r\n.ol-gridreference input\r\n{\twidth:100%;\r\n}\r\n.ol-gridreference ul\r\n{\tmargin:0;\r\n\tpadding:0;\r\n\tlist-style: none;\r\n} \r\n.ol-gridreference li\r\n{\tpadding: 0 0.5em;\r\n\tcursor: pointer;\r\n}\r\n.ol-gridreference ul li:hover \r\n{\tbackground-color: #ccc;\r\n}\r\n.ol-gridreference li.ol-title,\r\n.ol-gridreference li.ol-title:hover\r\n{\tbackground:rgba(0,60,136,.5);\r\n\tcolor:#fff;\r\n\tcursor:default;\r\n}\r\n.ol-gridreference ul li .ol-ref\r\n{\tmargin-left: 0.5em;\r\n}\r\n.ol-gridreference ul li .ol-ref:before\r\n{\tcontent:\"(\";\r\n}\r\n.ol-gridreference ul li .ol-ref:after\r\n{\tcontent:\")\";\r\n}\r\n\r\n.ol-control.ol-imageline {\r\n  bottom:0;\r\n  left: 0;\r\n  right: 0;\r\n  padding: 0;\r\n  overflow: visible;\r\n  -webkit-transition: .3s;\r\n  transition: .3s;\r\n  border-radius: 0;\r\n}\r\n.ol-control.ol-imageline.ol-collapsed {\r\n  -webkit-transform: translateY(100%);\r\n          transform: translateY(100%);\r\n}\r\n.ol-imageline > div {\r\n  height: 4em;\r\n  position: relative;\r\n  white-space: nowrap;\r\n  scroll-behavior: smooth;\r\n  overflow: hidden;\r\n  width: 100%;\r\n}\r\n.ol-imageline > div.ol-move {\r\n  scroll-behavior: unset;\r\n}\r\n\r\n.ol-control.ol-imageline button {\r\n  position: absolute;\r\n  top: -1em;\r\n  -webkit-transform: translateY(-100%);\r\n          transform: translateY(-100%);\r\n  margin: .65em;\r\n  -webkit-box-shadow: 0 0 0 0.15em rgba(255,255,255,.4);\r\n          box-shadow: 0 0 0 0.15em rgba(255,255,255,.4);\r\n}\r\n.ol-control.ol-imageline button:before {\r\n  content: '';\r\n  position: absolute;\r\n  -webkit-transform: translate(-50%, -50%) rotate(135deg);\r\n          transform: translate(-50%, -50%) rotate(135deg);\r\n  top: 40%;\r\n  left: 50%;\r\n  width: .4em;\r\n  height: .4em;\r\n  border: .1em solid currentColor;\r\n  border-width: .15em .15em 0 0;\r\n}\r\n.ol-control.ol-imageline.ol-collapsed button:before {\r\n  top: 60%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(-45deg);\r\n          transform: translate(-50%, -50%) rotate(-45deg);\r\n}\r\n\r\n.ol-imageline,\r\n.ol-imageline:hover {\r\n  background-color: rgba(0,0,0,.75);\r\n}\r\n\r\n.ol-imageline.ol-arrow:after,\r\n.ol-imageline.ol-arrow:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  top: 50%;\r\n  left: .2em;\r\n  border-color: #fff #000;\r\n  border-width: 1em .6em 1em 0;\r\n  border-style: solid;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n  z-index: 1;\r\n  opacity: .8;\r\n  pointer-events: none;\r\n  -webkit-box-shadow: -0.6em 0 0 1em #fff;\r\n          box-shadow: -0.6em 0 0 1em #fff;\r\n}\r\n.ol-imageline.ol-arrow:after {\r\n  border-width: 1em 0 1em .6em;\r\n  left: auto;\r\n  right: .2em;\r\n  -webkit-box-shadow: 0.6em 0 0 1em #fff;\r\n          box-shadow: 0.6em 0 0 1em #fff;\r\n}\r\n.ol-imageline.ol-scroll0.ol-arrow:before {\r\n  display: none;\r\n}\r\n.ol-imageline.ol-scroll1.ol-arrow:after {\r\n  display: none;\r\n}\r\n\r\n\r\n.ol-imageline .ol-image {\r\n  position: relative;\r\n  height: 100%;\r\n  display: inline-block;\r\n  cursor: pointer;\r\n}\r\n.ol-imageline img {\r\n  max-height: 100%;\r\n  border: .25em solid transparent;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  opacity: 0;\r\n  -webkit-transition: 1s;\r\n  transition: 1s;\r\n}\r\n.ol-imageline img.ol-loaded {\r\n  opacity:1;\r\n}\r\n\r\n.ol-imageline .ol-image.select {\r\n  background-color: #fff;\r\n}\r\n.ol-imageline .ol-image span {\r\n  position: absolute;\r\n  width: 125%;\r\n  max-height: 2.4em;\r\n  left: 50%;\r\n  bottom: 0;\r\n  display: none;\r\n  color: #fff;\r\n  background-color: rgba(0,0,0,.5);\r\n  font-size: .8em;\r\n  overflow: hidden;\r\n  white-space: normal;\r\n  text-align: center;\r\n  line-height: 1.2em;\r\n  -webkit-transform: translateX(-50%) scaleX(.8);\r\n          transform: translateX(-50%) scaleX(.8);\r\n}\r\n/*\r\n.ol-imageline .ol-image.select span,\r\n*/\r\n.ol-imageline .ol-image:hover span {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-routing.ol-isochrone .ol-method-time,\r\n.ol-control.ol-routing.ol-isochrone .ol-method-distance,\r\n.ol-control.ol-routing.ol-isochrone > button {\r\n  position: relative;\r\n}\r\n.ol-control.ol-routing.ol-isochrone .ol-method-time:before,\r\n.ol-control.ol-routing.ol-isochrone > button:before {\r\n  content: '';\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  border: .1em solid currentColor;\r\n  width: .8em;\r\n  height: .8em;\r\n  border-radius: 50%;\r\n  -webkit-box-shadow: 0 -0.5em 0 -0.35em, 0.4em -0.35em 0 -0.35em;\r\n          box-shadow: 0 -0.5em 0 -0.35em, 0.4em -0.35em 0 -0.35em;\r\n  clip: unset;\r\n}\r\n.ol-control.ol-routing.ol-isochrone .ol-method-time:after,\r\n.ol-control.ol-routing.ol-isochrone > button:after {\r\n  content: '';\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(-60deg);\r\n          transform: translate(-50%, -50%) rotate(-60deg);\r\n  border-radius: 50%;\r\n  border: .3em solid transparent;\r\n  border-right-color: currentColor;\r\n  -webkit-box-shadow: none;\r\n          box-shadow: none;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  clip: unset;\r\n}\r\n\r\n.ol-control.ol-routing.ol-isochrone .ol-method-distance:before {\r\n  content: '';\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(-30deg);\r\n          transform: translate(-50%, -50%) rotate(-30deg);\r\n  width: 1em;\r\n  height: .5em;\r\n  border: .1em solid currentColor;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box\r\n}\r\n.ol-control.ol-routing.ol-isochrone .ol-method-distance:after {\r\n  content: '';\r\n  position: absolute;\r\n  width: .1em;\r\n  height: .15em;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(-30deg);\r\n          transform: translate(-50%, -50%) rotate(-30deg);\r\n  -webkit-box-shadow: inset 0 -0.15em, 0 0.1em, 0.25em 0.1em, -0.25em 0.1em;\r\n          box-shadow: inset 0 -0.15em, 0 0.1em, 0.25em 0.1em, -0.25em 0.1em;\r\n}\r\n\r\n.ol-control.ol-routing.ol-isochrone .ol-direction-direct:before,\r\n.ol-control.ol-routing.ol-isochrone .ol-direction-reverse:before {\r\n  content: '';\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 30%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  width: .3em;\r\n  height: .3em;\r\n  border-radius: 50%;\r\n  border: .1em solid currentColor;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  -webkit-box-shadow: 0.25em 0 0 -0.05em;\r\n          box-shadow: 0.25em 0 0 -0.05em;\r\n}\r\n.ol-control.ol-routing.ol-isochrone .ol-direction-direct:after,\r\n.ol-control.ol-routing.ol-isochrone .ol-direction-reverse:after {\r\n  content: '';\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 70%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  border: .4em solid transparent;\r\n  border-width: .4em 0 .4em .4em;\r\n  border-color: transparent currentColor;\r\n}\r\n.ol-control.ol-routing.ol-isochrone .ol-direction-reverse:after {\r\n  border-width: .4em .4em .4em 0;\r\n}\r\n\r\n.ol-control.ol-isochrone.ol-collapsed .content {\r\n  display: none;\r\n}\r\n.ol-control.ol-isochrone input[type=\"number\"] {\r\n  width: 3em;\r\n  text-align: right;\r\n  margin: 0 .1em;\r\n}\r\n.ol-control.ol-isochrone .ol-distance input[type=\"number\"] {\r\n  width: 5em;\r\n}\r\n\r\n.ol-isochrone .ol-time,\r\n.ol-isochrone .ol-distance {\r\n  display: none;\r\n}\r\n.ol-isochrone .ol-time.selected,\r\n.ol-isochrone .ol-distance.selected {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-layerswitcher-popup {\r\n  position: absolute;\r\n  right: 0.5em;\r\n  text-align: left;\r\n  top: 3em;\r\n}\r\n.ol-control.ol-layerswitcher-popup .panel {\r\n  clear:both;\r\n  background:#fff;\r\n}\r\n\r\n.ol-layerswitcher-popup .panel {\r\n  list-style: none;\r\n  padding: 0.25em;\r\n  margin:0;\r\n  overflow: hidden;\r\n}\r\n\r\n.ol-layerswitcher-popup .panel ul {\r\n  list-style: none;\r\n  padding: 0 0 0 20px;\r\n  overflow: hidden;\r\n}\r\n\r\n.ol-layerswitcher-popup.ol-collapsed .panel {\r\n  display:none;\r\n}\r\n.ol-layerswitcher-popup.ol-forceopen .panel {\r\n  display:block;\r\n}\r\n\r\n.ol-layerswitcher-popup button  {\r\n  background-color: white;\r\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAACE1BMVEX///8A//8AgICA//8AVVVAQID///8rVVVJtttgv98nTmJ2xNgkW1ttyNsmWWZmzNZYxM4gWGgeU2JmzNNr0N1Rwc0eU2VXxdEhV2JqytQeVmMhVmNoydUfVGUgVGQfVGQfVmVqy9hqy9dWw9AfVWRpydVry9YhVmMgVGNUw9BrytchVWRexdGw294gVWQgVmUhVWPd4N6HoaZsy9cfVmQgVGRrytZsy9cgVWQgVWMgVWRsy9YfVWNsy9YgVWVty9YgVWVry9UgVWRsy9Zsy9UfVWRsy9YgVWVty9YgVWRty9Vsy9aM09sgVWRTws/AzM0gVWRtzNYgVWRuy9Zsy9cgVWRGcHxty9bb5ORbxdEgVWRty9bn6OZTws9mydRfxtLX3Nva5eRix9NFcXxOd4JPeINQeIMiVmVUws9Vws9Vw9BXw9BYxNBaxNBbxNBcxdJexdElWWgmWmhjyNRlx9IqXGtoipNpytVqytVryNNrytZsjZUuX210k5t1y9R2zNR3y9V4lp57zth9zdaAnKOGoaeK0NiNpquV09mesrag1tuitbmj1tuj19uktrqr2d2svcCu2d2xwMO63N+7x8nA3uDC3uDFz9DK4eHL4eLN4eIyYnDX5OM5Z3Tb397e4uDf4uHf5uXi5ePi5+Xj5+Xk5+Xm5+Xm6OY6aHXQ19fT4+NfhI1Ww89gx9Nhx9Nsy9ZWw9Dpj2abAAAAWnRSTlMAAQICAwQEBgcIDQ0ODhQZGiAiIyYpKywvNTs+QklPUlNUWWJjaGt0dnd+hIWFh4mNjZCSm6CpsbW2t7nDzNDT1dje5efr7PHy9PT29/j4+Pn5+vr8/f39/f6DPtKwAAABTklEQVR4Xr3QVWPbMBSAUTVFZmZmhhSXMjNvkhwqMzMzMzPDeD+xASvObKePPa+ffHVl8PlsnE0+qPpBuQjVJjno6pZpSKXYl7/bZyFaQxhf98hHDKEppwdWIW1frFnrxSOWHFfWesSEWC6R/P4zOFrix3TzDFLlXRTR8c0fEEJ1/itpo7SVO9Jdr1DVxZ0USyjZsEY5vZfiiAC0UoTGOrm9PZLuRl8X+Dq1HQtoFbJZbv61i+Poblh/97TC7n0neCcK0ETNUrz1/xPHf+DNAW9Ac6t8O8WH3Vp98f5lCaYKAOFZMLyHL4Y0fe319idMNgMMp+zWVSybUed/+/h7I4wRAG1W6XDy4XmjR9HnzvDRZXUAYDFOhC1S/Hh+fIXxen+eO+AKqbs+wAo30zDTDvDxKoJN88sjUzDFAvBzEUGFsnADoIvAJzoh2BZ8sner+Ke/vwECuQAAAABJRU5ErkJggg==\");\r\n  background-position: center;\r\n  background-repeat: no-repeat;\r\n  float: right;\r\n  height: 38px;\r\n  width: 38px;\r\n}\r\n\r\n.ol-layerswitcher-popup li {\r\n  color:#369;\r\n  padding:0.25em 1em;\r\n  font-family:\"Trebuchet MS\",Helvetica,sans-serif;\r\n  cursor:pointer;\r\n}\r\n.ol-layerswitcher-popup li.ol-header {\r\n  display: none;\r\n}\r\n.ol-layerswitcher-popup li.select,\r\n.ol-layerswitcher-popup li.ol-visible {\r\n  background:rgba(0, 60, 136, 0.7);\r\n  color:#fff;\r\n}\r\n.ol-layerswitcher-popup li:hover {\r\n  background:rgba(0, 60, 136, 0.9);\r\n  color:#fff;\r\n}\r\n\r\n.ol-control.ol-layerswitcher.ol-layer-shop {\r\n  height: calc(100% - 4em);\r\n  max-height: unset;\r\n  max-width: 16em;\r\n  background-color: transparent;\r\n  pointer-events: none!important;\r\n  overflow: visible;\r\n}\r\n.ol-control.ol-layerswitcher > * {\r\n  pointer-events: auto;\r\n}\r\n\r\n.ol-control.ol-layer-shop > button,\r\n.ol-control.ol-layer-shop .panel-container {\r\n  -webkit-box-shadow: 0 0 0 3px rgba(255,255,255,.5);\r\n          box-shadow: 0 0 0 3px rgba(255,255,255,.5);\r\n}\r\n.ol-control.ol-layerswitcher.ol-layer-shop .panel-container {\r\n  overflow-y: scroll;\r\n  max-height: calc(100% - 6.5em);\r\n  border: 2px solid #369;\r\n  border-width: 2px 0;\r\n  padding: 0;\r\n}\r\n.ol-control.ol-layer-shop .panel {\r\n  padding: 0;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  margin: .25em .5em;\r\n}\r\n.ol-control.ol-layerswitcher.ol-layer-shop .panel-container.ol-scrolldiv {\r\n  overflow: hidden;\r\n}\r\n.ol-control.ol-layer-shop .ol-scroll {\r\n  background-color: rgba(0,0,0,.3);\r\n  opacity: .5;\r\n}\r\n.ol-layerswitcher.ol-layer-shop ul.panel li.ol-header {\r\n  display: none;\r\n}\r\n.ol-layerswitcher.ol-layer-shop ul.panel li {\r\n  margin-right: 0;\r\n  padding-right: 0;\r\n}\r\n.ol-layerswitcher.ol-layer-shop .layerup {\r\n  height: 1.5em;\r\n  width: 1.4em;\r\n  margin: 0;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  border-radius: 3px;\r\n  background-color: transparent;\r\n  color: rgba(0,60,136,1);\r\n}\r\n.ol-layerswitcher.ol-layer-shop .layerup:hover {\r\n  background-color: rgba(0,60,136,.3);\r\n}\r\n.ol-layerswitcher.ol-layer-shop .layerup:before {\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  border: 0;\r\n  background-color: currentColor;\r\n  width: 1em;\r\n  height: 2px;\r\n  -webkit-box-shadow: 0 -4px, 0 4px;\r\n          box-shadow: 0 -4px, 0 4px;\r\n}\r\n.ol-layerswitcher.ol-layer-shop .layerup:after {\r\n  content: unset;\r\n}\r\n\r\n.ol-control.ol-layer-shop .ol-title-bar {\r\n  background-color: rgba(255,255,255,.5);\r\n  font-size: .9em;\r\n  height: calc(2.8em - 4px);\r\n  max-width: 14.6em;\r\n  padding: .7em .5em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n  text-align: right;\r\n  -webkit-transform: scaleY(1.1);\r\n          transform: scaleY(1.1);\r\n  -webkit-transition: width 0s, -webkit-transform .1s;\r\n  transition: width 0s, -webkit-transform .1s;\r\n  transition: transform .1s, width 0s;\r\n  transition: transform .1s, width 0s, -webkit-transform .1s;\r\n  -webkit-transform-origin: 100% 0;\r\n          transform-origin: 100% 0;\r\n}\r\n.ol-control.ol-layer-shop:hover .ol-title-bar {\r\n  background-color: rgba(255,255,255,.7);\r\n}\r\n.ol-control.ol-layer-shop.ol-collapsed .ol-title-bar {\r\n  max-width: 10em;\r\n  -webkit-transform: scale(.9, 1.1);\r\n          transform: scale(.9, 1.1);\r\n}\r\n.ol-control.ol-layer-shop.ol-forceopen .ol-title-bar {\r\n  max-width: 14.6em;\r\n  -webkit-transform: scaleY(1.1);\r\n          transform: scaleY(1.1);\r\n}\r\n\r\n.ol-control.ol-layer-shop .ol-bar {\r\n  position: relative;\r\n  height: 1.75em;\r\n  clear: both;\r\n  -webkit-box-shadow: 0 0 0 3px rgba(255,255,255,.5);\r\n          box-shadow: 0 0 0 3px rgba(255,255,255,.5);\r\n  background-color: #fff;\r\n  text-align: right;\r\n  z-index: 10;\r\n}\r\n.ol-control.ol-layer-shop.ol-collapsed .ol-scroll,\r\n.ol-control.ol-layer-shop.ol-collapsed .ol-bar {\r\n  border-width: 2px 0 0;\r\n  display: none;\r\n}\r\n.ol-control.ol-layer-shop.ol-forceopen .ol-scroll,\r\n.ol-control.ol-layer-shop.ol-forceopen .ol-bar  {\r\n  display: block;\r\n}\r\n.ol-control.ol-layer-shop .ol-bar > * {\r\n  font-size: .9em;\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n  margin-top: .25em;\r\n  background-color: transparent;\r\n}\r\n\r\n.ol-layer-shop .ol-bar .ol-button,\r\n.ol-touch .ol-layer-shop .ol-bar .ol-button {\r\n  position: relative;\r\n  top: unset;\r\n  left: unset;\r\n  bottom: unset;\r\n  right: unset;\r\n  margin: 0;\r\n}\r\n.ol-layer-shop .ol-bar button {\r\n  background-color: #fff;\r\n  color: rgba(0,60,136,1)\r\n}\r\n.ol-layer-shop .ol-bar button:hover {\r\n  background-color: rgba(0,60,136,.2);\r\n}\r\n\r\n/* Touch device */\r\n.ol-touch .ol-layerswitcher.ol-layer-shop > button {\r\n  font-size: 1.7em;\r\n}\r\n.ol-touch .ol-layer-shop .ol-bar {\r\n  height: 2em;\r\n}\r\n.ol-touch .ol-layer-shop .ol-control button {\r\n  font-size: 1.4em;\r\n}\r\n.ol-touch .ol-control.ol-layer-shop .panel {\r\n  max-height: calc(100% - 7em);\r\n}\r\n.ol-touch .ol-control.ol-layer-shop .panel label {\r\n  height: 1.8em;\r\n}\r\n.ol-touch .ol-control.ol-layer-shop .panel label span {\r\n  margin-left: .5em;\r\n  padding-top: .25em;\r\n}\r\n.ol-touch .ol-control.ol-layer-shop .panel label:before,\r\n.ol-touch .ol-control.ol-layer-shop .panel label:after {\r\n  font-size: 1.3em;\r\n  z-index: 1;\r\n}\r\n\r\n.ol-control.ol-layerswitcher {\r\n  position: absolute;\r\n  right: 0.5em;\r\n  text-align: left;\r\n  top: 3em;\r\n  max-height: calc(100% - 6em);\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  overflow: hidden;\r\n}\r\n.ol-control.ol-layerswitcher .ol-switchertopdiv,\r\n.ol-control.ol-layerswitcher .ol-switcherbottomdiv {\r\n  display: block\r\n}\r\n.ol-control.ol-layerswitcher.ol-collapsed .ol-switchertopdiv,\r\n.ol-control.ol-layerswitcher.ol-collapsed .ol-switcherbottomdiv {\r\n  display: none;\r\n}\r\n.ol-layerswitcher.ol-forceopen.ol-collapsed .ol-switchertopdiv,\r\n.ol-layerswitcher.ol-forceopen.ol-collapsed .ol-switcherbottomdiv {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-layerswitcher .ol-switchertopdiv,\r\n.ol-control.ol-layerswitcher .ol-switcherbottomdiv {\r\n  position: absolute;\r\n  top:0;\r\n  left:0;\r\n  right:0;\r\n  height: 45px;\r\n  background: #fff; \r\n  z-index:2;\r\n  opacity:1;\r\n  cursor: pointer;\r\n  border-top:2px solid transparent;\r\n  border-bottom:2px solid #369;\r\n  margin:0 2px;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-control.ol-layerswitcher .ol-switcherbottomdiv {\r\n  top: auto;\r\n  bottom: 0;\r\n  height: 2em;\r\n  border-top:2px solid #369;\r\n  border-bottom:2px solid transparent;\r\n}\r\n.ol-control.ol-layerswitcher .ol-switchertopdiv:before,\r\n.ol-control.ol-layerswitcher .ol-switcherbottomdiv:before {\r\n  content:\"\";\r\n  position: absolute;\r\n  left:50%;\r\n  top:50%;\r\n  border:10px solid transparent;\r\n  width:0;\r\n  height:0;\r\n  transform: translate(-50%, -50%);\r\n  -webkit-transform: translate(-50%, -50%);\r\n  opacity:0.8;\r\n}\r\n\r\n.ol-control.ol-layerswitcher .ol-switchertopdiv:hover:before,\r\n.ol-control.ol-layerswitcher .ol-switcherbottomdiv:hover:before {\r\n  opacity:1;\r\n}\r\n.ol-control.ol-layerswitcher .ol-switchertopdiv:before {\r\n  border-bottom-color: #369;\r\n  border-top: 0;\r\n}\r\n.ol-control.ol-layerswitcher .ol-switcherbottomdiv:before {\r\n  border-top-color: #369;\r\n  border-bottom: 0;\r\n}\r\n\r\n.ol-control.ol-layerswitcher .panel-container {\r\n  background-color: #fff;\r\n  border-radius: 0 0 2px 2px;\r\n  clear: both;\r\n  display: block; /* display:block to show panel on over */\r\n  padding: 0.5em 0.5em 0;\r\n}\r\n\r\n.ol-layerswitcher .panel {\r\n  list-style: none;\r\n  padding: 0;\r\n  margin: 0;\r\n  overflow: hidden;\r\n  font-family: Tahoma,Geneva,sans-serif;\r\n  font-size:0.9em;\r\n  -webkit-transition: top 0.3s;\r\n  transition: top 0.3s;\r\n  position: relative;\r\n  top:0;\r\n}\r\n\r\n.ol-layerswitcher .panel ul {\r\n  list-style: none;\r\n  padding: 0 0 0 20px;\r\n  overflow: hidden;\r\n  clear: both;\r\n}\r\n\r\n/** Customize checkbox\r\n*/\r\n.ol-layerswitcher input[type=\"radio\"],\r\n.ol-layerswitcher input[type=\"checkbox\"] {\r\n  display:none;\r\n}\r\n\r\n.ol-layerswitcher .panel li {\r\n  -weblit-transition: -webkit-transform 0.2s linear;\r\n  -webkit-transition: -webkit-transform 0.2s linear;\r\n  transition: -webkit-transform 0.2s linear;\r\n  transition: transform 0.2s linear;\r\n  transition: transform 0.2s linear, -webkit-transform 0.2s linear;\r\n  clear: both;\r\n  display: block;\r\n  border:1px solid transparent;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-layerswitcher .panel li.ol-layer-select {\r\n  background-color: rgba(0,60,136,.2);\r\n  margin: 0 -.5em;\r\n  padding: 0 .5em\r\n}\r\n/* drag and drop */\r\n.ol-layerswitcher .panel li.drag {\r\n  opacity: 0.5;\r\n  transform:scale(0.8);\r\n  -webkit-transform:scale(0.8);\r\n}\r\n.ol-dragover {\r\n  background:rgba(51,102,153,0.5);\r\n  opacity:0.8;\r\n}\r\n.ol-layerswitcher .panel li.forbidden,\r\n.forbidden .ol-layerswitcher-buttons div,\r\n.forbidden .layerswitcher-opacity div {\r\n  background:rgba(255,0,0,0.5);\r\n  color:#f00!important;\r\n}\r\n\r\n/* cursor management */\r\n.ol-layerswitcher.drag,\r\n.ol-layerswitcher.drag * {\r\n  cursor:not-allowed!important;\r\n  cursor:no-drop!important;\r\n}\r\n.ol-layerswitcher.drag .panel li.dropover,\r\n.ol-layerswitcher.drag .panel li.dropover * {\r\n  cursor: pointer!important;\r\n  cursor: n-resize!important;\r\n  cursor: ns-resize!important;\r\n  cursor: -webkit-grab!important;\r\n  cursor: grab!important;\r\n  cursor: -webkit-grabbing!important;\r\n  cursor: grabbing!important;\r\n}\r\n\r\n.ol-layerswitcher .panel li.dropover {\r\n  background: rgba(51, 102, 153, 0.5);\r\n}\r\n\r\n.ol-layerswitcher .panel li label {\r\n  display: inline-block;\r\n  height: 1.4em;\r\n  max-width: 12em;\r\n  overflow: hidden;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n  padding: 0 0 0 1.7em;\r\n  position: relative;\r\n}\r\n\r\n.ol-layerswitcher .panel li label span {\r\n  display: inline-block;\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  padding-right: .2em;\r\n}\r\n.ol-layerswitcher [type=\"radio\"] + label:before,\r\n.ol-layerswitcher [type=\"checkbox\"] + label:before,\r\n.ol-layerswitcher [type=\"radio\"]:checked + label:after,\r\n.ol-layerswitcher [type=\"checkbox\"]:checked + label:after {\r\n  content: '';\r\n  position: absolute;\r\n  left: 0.1em; top: 0.1em;\r\n  width: 1.2em; height: 1.2em; \r\n  border: 2px solid #369;\r\n  background: #fff;\r\n  -webkit-box-sizing:border-box;\r\n          box-sizing:border-box;\r\n}\r\n\r\n.ol-layerswitcher [type=\"radio\"] + label:before,\r\n.ol-layerswitcher [type=\"radio\"] + label:after {\r\n  border-radius: 50%;\r\n}\r\n\r\n.ol-layerswitcher [type=\"radio\"]:checked + label:after {\r\n  background: #369 none repeat scroll 0 0;\r\n  margin: 0.3em;\r\n  width: 0.6em;\r\n  height: 0.6em;\r\n}\r\n\r\n.ol-layerswitcher [type=\"checkbox\"]:checked + label:after {\r\n  background: transparent;\r\n  border-width: 0 3px 3px 0;\r\n  border-style: solid;\r\n  border-color: #369;\r\n    width: 0.7em;\r\n    height: 1em;\r\n    -webkit-transform: rotate(45deg);\r\n    transform: rotate(45deg);\r\n    left: 0.55em;\r\n    top: -0.05em;\r\n    -webkit-box-shadow: 1px 0px 1px 1px #fff;\r\n            box-shadow: 1px 0px 1px 1px #fff;\r\n}\r\n\r\n.ol-layerswitcher .panel li.ol-layer-hidden {\r\n  opacity: 0.6;\r\n}\r\n\r\n.ol-layerswitcher.ol-collapsed .panel-container {\r\n  display:none;\r\n}\r\n.ol-layerswitcher.ol-forceopen .panel-container {\r\n  display:block;\r\n}\r\n\r\n.ol-layerswitcher-image > button,\r\n.ol-layerswitcher > button {\r\n  background-color: white;\r\n  float: right;\r\n  z-index: 10;\r\n  position: relative;\r\n  font-size: 1.7em;\r\n}\r\n.ol-touch .ol-layerswitcher-image > button,\r\n.ol-touch .ol-layerswitcher > button {\r\n  font-size: 2.5em;\r\n}\r\n.ol-layerswitcher-image > button:before,\r\n.ol-layerswitcher-image > button:after,\r\n.ol-layerswitcher > button:before,\r\n.ol-layerswitcher > button:after {\r\n  content: \"\";\r\n  position:absolute;\r\n  width: .75em;\r\n  height: .75em;\r\n  border-radius: 0.15em;\r\n  -webkit-transform: scaleY(.8) rotate(45deg);\r\n  transform: scaleY(.8) rotate(45deg);\r\n}\r\n.ol-layerswitcher-image > button:before,\r\n.ol-layerswitcher > button:before {\r\n  background: #e2e4e1;\r\n  top: .32em;\r\n  left: .34em;\r\n  -webkit-box-shadow: 0.1em 0.1em #325158;\r\n  box-shadow: 0.1em 0.1em #325158;\r\n}\r\n.ol-layerswitcher-image > button:after,\r\n.ol-layerswitcher > button:after {\r\n  top: .22em;\r\n  left: .34em;\r\n  background: #83bcc5;\r\n  background-image: radial-gradient( circle at .85em .6em, #70b3be 0, #70b3be .65em, #83bcc5 .65em);\r\n}\r\n.ol-layerswitcher-buttons {\r\n  display:block;\r\n  float: right;\r\n  text-align:right;\r\n}\r\n.ol-layerswitcher-buttons > div {\r\n  display: inline-block;\r\n  position: relative;\r\n  cursor: pointer;\r\n  height:1em;\r\n  width:1em;\r\n  margin:2px;\r\n  line-height: 1em;\r\n    text-align: center;\r\n    background: #369;\r\n    vertical-align: middle;\r\n    color: #fff;\r\n}\r\n\r\n.ol-layerswitcher .panel li > div {\r\n  display: inline-block;\r\n  position: relative;\r\n}\r\n\r\n/* line break */\r\n.ol-layerswitcher .ol-separator {\r\n  display:block;\r\n  width:0;\r\n  height:0;\r\n  padding:0;\r\n  margin:0;\r\n}\r\n\r\n.ol-layerswitcher .layerup {\r\n  float: right;\r\n  height:2.5em;\r\n  background-color: #369;\r\n  opacity: 0.5;\r\n  cursor: move;\r\n  cursor: ns-resize;\r\n}\r\n\r\n.ol-layerswitcher .layerup:before,\r\n.ol-layerswitcher .layerup:after {\r\n  border-color: #fff transparent;\r\n  border-style: solid;\r\n  border-width: 0.4em 0.4em 0;\r\n  content: \"\";\r\n  height: 0;\r\n  position: absolute;\r\n  bottom: 3px;\r\n  left: 0.1em;\r\n  width: 0;\r\n}\r\n.ol-layerswitcher .layerup:after {\r\n  border-width: 0 0.4em 0.4em;\r\n  top:3px;\r\n  bottom: auto;\r\n}\r\n\r\n.ol-layerswitcher .layerInfo {\r\n  background: #369;\r\n  border-radius: 100%;\r\n}\r\n.ol-layerswitcher .layerInfo:before {\r\n  color: #fff;\r\n  content: \"i\";\r\n  display: block;\r\n  font-size: 0.8em;\r\n  font-weight: bold;\r\n  text-align: center;\r\n  width: 1.25em;\r\n  position:absolute;\r\n  left: 0;\r\n  top: 0;\r\n}\r\n\r\n.ol-layerswitcher .layerTrash {\r\n  background: #369;\r\n}\r\n.ol-layerswitcher .layerTrash:before {\r\n  color: #fff;\r\n  content: \"\\00d7\";\r\n  font-size:1em;\r\n  top: 50%;\r\n  left: 0;\r\n  right: 0;\r\n  text-align: center;\r\n  line-height: 1em;\r\n  margin: -0.5em 0;\r\n  position: absolute;\r\n}\r\n\r\n.ol-layerswitcher .layerExtent {\r\n  background: #369;\r\n}\r\n.ol-layerswitcher .layerExtent:before {\r\n  border-right: 1px solid #fff;\r\n  border-bottom: 1px solid #fff;\r\n  content: \"\";\r\n  display: block;\r\n  position: absolute;\r\n  left: 6px;\r\n  right: 2px;\r\n  top: 6px;\r\n  bottom: 3px;\r\n}\r\n.ol-layerswitcher .layerExtent:after {\r\n  border-left: 1px solid #fff;\r\n  border-top: 1px solid #fff;\r\n  content: \"\";\r\n  display: block;\r\n  position: absolute;\r\n  bottom: 6px;\r\n  left: 2px;\r\n  right: 6px;\r\n  top: 3px;\r\n}\r\n\r\n.ol-layerswitcher .expend-layers,\r\n.ol-layerswitcher .collapse-layers {\r\n  margin: 0 2px;\r\n  background-color: transparent;\r\n}\r\n.ol-layerswitcher .expend-layers:before,\r\n.ol-layerswitcher .collapse-layers:before {\r\n  content:\"\";\r\n  position:absolute;\r\n  top:50%;\r\n  left:0;\r\n  margin-top:-2px;\r\n  height:4px;\r\n  width:100%;\r\n  background:#369;\r\n}\r\n.ol-layerswitcher .expend-layers:after {\r\n  content:\"\";\r\n  position:absolute;\r\n  left:50%;\r\n  top:0;\r\n  margin-left:-2px;\r\n  width:4px;\r\n  height:100%;\r\n  background:#369;\r\n}\r\n/*\r\n.ol-layerswitcher .collapse-layers:before {\r\n  content:\"\";\r\n  position:absolute;\r\n  border:0.5em solid #369;\r\n  border-color: #369 transparent transparent;\r\n  margin-top:0.25em;\r\n}\r\n.ol-layerswitcher .expend-layers:before {\r\n  content:\"\";\r\n  position:absolute;\r\n  border:0.5em solid #369;\r\n  border-color: transparent transparent transparent #369 ;\r\n  margin-left:0.25em;\r\n}\r\n*/\r\n\r\n.ol-layerswitcher .layerswitcher-opacity {\r\n  position:relative;\r\n  border: 1px solid #369;\r\n  height: 3px;\r\n  width: 120px;\r\n  margin:5px 1em 10px 7px;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  border-radius: 3px;\r\n  background: #69c;\r\n  background: -webkit-gradient(linear, left top, right top, from(rgba(0,60,136,0)), to(rgba(0,60,136,0.6)));\r\n  background: linear-gradient(to right, rgba(0,60,136,0), rgba(0,60,136,0.6));\r\n  cursor: pointer;\r\n  -webkit-box-shadow: 1px 1px 1px rgba(0,0,0,0.5);\r\n          box-shadow: 1px 1px 1px rgba(0,0,0,0.5);\r\n}\r\n\r\n.ol-layerswitcher .layerswitcher-opacity .layerswitcher-opacity-cursor,\r\n.ol-layerswitcher .layerswitcher-opacity .layerswitcher-opacity-cursor:before {\r\n  position: absolute;\r\n  width: 20px;\r\n  height: 20px;\r\n  top: 50%;\r\n  left: 50%;\r\n  background: rgba(0,60,136,0.5);\r\n  border-radius: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n  transform: translate(-50%, -50%);\r\n  z-index: 1;\r\n}\r\n.ol-layerswitcher .layerswitcher-opacity .layerswitcher-opacity-cursor:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 50%;\r\n  height: 50%;\r\n}\r\n.ol-touch .ol-layerswitcher .layerswitcher-opacity .layerswitcher-opacity-cursor {\r\n  width: 26px;\r\n  height: 26px;\r\n}\r\n\r\n.ol-layerswitcher .layerswitcher-opacity-label { \r\n  display:none;\r\n  position: absolute;\r\n  right: -2.5em;\r\n  bottom: 5px;\r\n  font-size: 0.8em;\r\n}\r\n.ol-layerswitcher .layerswitcher-opacity-label::after {\r\n  content:\"%\";\r\n}\r\n\r\n.ol-layerswitcher .layerswitcher-progress {\r\n  display:block;\r\n  margin:-4px 1em 2px 7px;\r\n  width: 120px;\r\n}\r\n.ol-layerswitcher .layerswitcher-progress div {\r\n  background-color: #369;\r\n  height:2px;\r\n  display:block;\r\n  width:0;\r\n}\r\n\r\n.ol-control.ol-layerswitcher-image {\r\n  position: absolute;\r\n  right: 0.5em;\r\n  text-align: left;\r\n  top: 1em;\r\n  transition: all 0.2s ease 0s;\r\n  -webkit-transition: all 0.2s ease 0s;\r\n}\r\n.ol-control.ol-layerswitcher-image.ol-collapsed {\r\n  top:3em;\r\n  -webkit-transition: none;\r\n  transition: none;\r\n}\r\n\r\n.ol-layerswitcher-image .panel {\r\n  list-style: none;\r\n  padding: 0.25em;\r\n  margin:0;\r\n  overflow: hidden;\r\n}\r\n\r\n.ol-layerswitcher-image .panel ul {\r\n  list-style: none;\r\n  padding: 0 0 0 20px;\r\n  overflow: hidden;\r\n}\r\n\r\n.ol-layerswitcher-image.ol-collapsed .panel {\r\n  display:none;\r\n}\r\n.ol-layerswitcher-image.ol-forceopen .panel {\r\n  display:block;\r\n  clear:both;\r\n}\r\n\r\n.ol-layerswitcher-image button {\r\n  float: right;\r\n  display:none;\r\n}\r\n\r\n.ol-layerswitcher-image.ol-collapsed button {\r\n  display:block;\r\n  position:relative;\r\n}\r\n\r\n.ol-layerswitcher-image li {\r\n  border-radius: 4px;\r\n  border: 3px solid transparent;\r\n  -webkit-box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);\r\n          box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);\r\n  display: inline-block;\r\n  width: 64px;\r\n  height: 64px;\r\n  margin:2px;\r\n  position: relative;\r\n  background-color: #fff;\r\n  overflow: hidden;\r\n  vertical-align: middle;\r\n  cursor:pointer;\r\n}\r\n.ol-layerswitcher-image li.ol-layer-hidden {\r\n  opacity: 0.5;\r\n  border-color:#555;\r\n}\r\n.ol-layerswitcher-image li.ol-header {\r\n  display: none;\r\n}\r\n\r\n.ol-layerswitcher-image li img {\r\n  position:absolute;\r\n  max-width:100%;\r\n}\r\n.ol-layerswitcher-image li.select,\r\n.ol-layerswitcher-image li.ol-visible {\r\n  border: 3px solid red;\r\n}\r\n\r\n.ol-layerswitcher-image li p {\r\n  display:none;\r\n}\r\n.ol-layerswitcher-image li:hover p {\r\n  background-color: rgba(0, 0, 0, 0.5);\r\n  color: #fff;\r\n  bottom: 0;\r\n  display: block;\r\n  left: 0;\r\n  margin: 0;\r\n  overflow: hidden;\r\n  position: absolute;\r\n  right: 0;\r\n  text-align: center;\r\n  height:1.2em;\r\n  font-family:Verdana, Geneva, sans-serif;\r\n  font-size:0.8em;\r\n}\r\n.ol-control.ol-legend {\r\n  bottom: .5em;\r\n  left: .5em;\r\n  z-index: 1;\r\n  max-height: 90%;\r\n  max-width: 90%;\r\n  overflow-x: hidden;\r\n  overflow-y: auto;\r\n  background-color: rgba(255,255,255,.6);\r\n}\r\n.ol-control.ol-legend:hover {\r\n  background-color: rgba(255,255,255,.8);\r\n}\r\n.ol-control.ol-legend.ol-empty,\r\n.ol-control.ol-legend.ol-collapsed {\r\n  overflow: hidden;\r\n}\r\n.ol-control.ol-legend button {\r\n  position: relative;\r\n  display: none;\r\n}\r\n.ol-control.ol-legend.ol-empty button,\r\n.ol-control.ol-legend.ol-collapsed button {\r\n  display: block;\r\n}\r\n.ol-control.ol-legend.ol-uncollapsible button {\r\n  display: none;\r\n}\r\n\r\n.ol-control.ol-legend > ul,\r\n.ol-control.ol-legend > canvas {\r\n  margin: 2px;\r\n}\r\n\r\n.ol-control.ol-legend button.ol-closebox {\r\n  display: block;\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  background: none;\r\n  cursor: pointer;\r\n  z-index: 1;\r\n}\r\n.ol-control.ol-legend.ol-empty button.ol-closebox,\r\n.ol-control.ol-legend.ol-uncollapsible button.ol-closebox,\r\n.ol-control.ol-legend.ol-collapsed button.ol-closebox {\r\n  display: none;\r\n}\r\n.ol-control.ol-legend button.ol-closebox:before {\r\n  content: \"\\D7\";\r\n  background: none;\r\n  color: rgba(0,60,136,.5);\r\n  font-size: 1.3em;\r\n}\r\n.ol-control.ol-legend button.ol-closebox:hover:before {\r\n  color: rgba(0,60,136,1);\r\n}\r\n.ol-control.ol-legend .ol-legendImg {\r\n  display: block;\r\n}\r\n.ol-control.ol-legend.ol-empty .ol-legendImg,\r\n.ol-control.ol-legend.ol-collapsed .ol-legendImg {\r\n  display: none;\r\n}\r\n.ol-control.ol-legend.ol-uncollapsible .ol-legendImg {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-legend > button:first-child:before,\r\n.ol-control.ol-legend > button:first-child:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  top: .25em;\r\n  left: .2em;\r\n  width: .2em;\r\n  height: .2em;\r\n  background-color: currentColor;\r\n  -webkit-box-shadow: 0 0.35em, 0 0.7em;\r\n          box-shadow: 0 0.35em, 0 0.7em;\r\n}\r\n.ol-control.ol-legend button:first-child:after {\r\n  top: .27em;\r\n  left: .55em;\r\n  height: .15em;\r\n  width: .6em;\r\n}\r\n\r\nul.ol-legend {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  margin: 0;\r\n  padding: 0;\r\n  list-style: none;\r\n}\r\n.ol-control.ol-legend.ol-empty ul,\r\n.ol-control.ol-legend.ol-collapsed ul {\r\n  display: none;\r\n}\r\n.ol-control.ol-legend.ol-uncollapsible ul {\r\n  display: block;\r\n}\r\nul.ol-legend li.ol-title {\r\n  text-align: center;\r\n  font-weight: bold;\r\n}\r\nul.ol-legend li.ol-title > div:first-child {\r\n  width: 0!important;\r\n}\r\nul.ol-legend li {\r\n  overflow: hidden;\r\n  padding: 0;\r\n  white-space: nowrap;\r\n}\r\nul.ol-legend li div {\r\n  display: inline-block;\r\n  vertical-align: top;\r\n}\r\n\r\n.ol-control.ol-legend .ol-legend {\r\n  display: inline-block;\r\n}\r\n.ol-control.ol-legend.ol-empty .ol-legend,\r\n.ol-control.ol-legend.ol-collapsed .ol-legend {\r\n  display: none;\r\n}\r\n.ol-control.ol-legend.ol-empty button {\r\n  opacity: .4;\r\n}\r\n.ol-control.ol-mapzone {\r\n  position: absolute;\r\n  right: 0.5em;\r\n  text-align: left;\r\n  top: .5em;\r\n  max-height: calc(100% - 6em);\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  overflow: hidden;\r\n}\r\n\r\n.ol-control.ol-mapzone.ol-collapsed {\r\n  top: 3em;\r\n}\r\n\r\n.ol-control.ol-mapzone button {\r\n  position: relative;\r\n  float: right;\r\n  margin-top: 2.5em;\r\n}\r\n.ol-touch .ol-control.ol-mapzone button {\r\n  margin-top: 1.67em;\r\n}\r\n.ol-control.ol-mapzone.ol-collapsed button {\r\n  margin-top: 0;\r\n}\r\n\r\n.ol-control.ol-mapzone button i {\r\n  border: .1em solid currentColor;\r\n  border-radius: 50%;\r\n  width: .9em;\r\n  height: .9em; \r\n  overflow: hidden;\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-control.ol-mapzone button i:before {\r\n  content: \"\";\r\n  background-color: currentColor;\r\n  width: 0.4em;\r\n  height: .4em;\r\n  position: absolute;\r\n  left: .5em;\r\n  top: 0.3em;\r\n  border-radius: 50%;\r\n  -webkit-box-shadow: .05em .3em 0 -.051em currentColor,\r\n  \t-.05em -.35em 0 -.1em currentColor,\r\n  \t-.5em -.35em 0 0em currentColor,\r\n  \t-.65em .1em 0 -.03em currentColor,\r\n  \t-.65em -.05em 0 -.05em currentColor;\r\n          box-shadow: .05em .3em 0 -.051em currentColor,\r\n  \t-.05em -.35em 0 -.1em currentColor,\r\n  \t-.5em -.35em 0 0em currentColor,\r\n  \t-.65em .1em 0 -.03em currentColor,\r\n  \t-.65em -.05em 0 -.05em currentColor\r\n}\r\n\r\n.ol-mapzone > div {\r\n  position: relative;\r\n  display: inline-block;\r\n  width: 5em;\r\n  height: 5em;\r\n  margin: 0 .2em 0 0;\r\n}\r\n.ol-control.ol-mapzone.ol-collapsed > div {\r\n  display: none;\r\n}\r\n.ol-mapzone > div p {\r\n  margin: 0;\r\n  position: absolute;\r\n  bottom: 0;\r\n  /* background: rgba(255,255,255,.5); */\r\n  color: #fff;\r\n  font-weight: bold;\r\n  text-align: center;\r\n  width: 160%;\r\n  overflow: hidden;\r\n  font-family: 'Lucida Grande',Verdana,Geneva,Lucida,Arial,Helvetica,sans-serif;\r\n  -webkit-transform: scaleX(.625);\r\n          transform: scaleX(.625);\r\n  -webkit-transform-origin: 0 0;\r\n          transform-origin: 0 0;\r\n  cursor: default;\r\n}\r\n\r\n.ol-notification {\r\n  width: 150%;\r\n  bottom: 0;\r\n  border: 0;\r\n  background: none;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n.ol-notification > div,\r\n.ol-notification > div:hover {\r\n  position: absolute;\r\n  background-color: rgba(0,0,0,.8);\r\n  color: #fff;\r\n  bottom: 0;\r\n  left: 33.33%;\r\n  max-width: calc(66% - 4em);\r\n  min-width: 5em;\r\n  max-height: 5em;\r\n  min-height: 1em;\r\n  border-radius: 4px 4px 0 0;\r\n  padding: .2em .5em;\r\n  text-align: center;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  -webkit-transition: .3s;\r\n  transition: .3s;\r\n  opacity: 1;\r\n}\r\n.ol-notification.ol-collapsed > div {\r\n  bottom: -5em;\r\n  opacity: 0;\r\n}\r\n\r\n.ol-notification a {\r\n  color: #9cf;\r\n  cursor: pointer;\r\n}\r\n\r\n.ol-notification .ol-close,\r\n.ol-notification .ol-close:hover {\r\n  padding-right: 1.5em;\r\n}\r\n\r\n.ol-notification .closeBox {\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0.3em;\r\n}\r\n.ol-notification .closeBox:before {\r\n  content: '\\00d7';\r\n}\r\n.ol-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width:100%;\r\n  height: 100%;\r\n  background-color: rgba(0,0,0,0.4);\r\n  padding: 1em;\r\n  color: #fff;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  z-index: 1;\r\n  opacity: 0;\r\n  display: none;\r\n  cursor: default;\r\n  overflow: hidden;\r\n  -webkit-transition: all 0.5s;\r\n  transition: all 0.5s;\r\n  pointer-events: none;\r\n  z-index: 9;\r\n}\r\n\r\n.ol-overlay.slide-up {\r\n  transform: translateY(100%);\r\n  -webkit-transform: translateY(100%);\r\n}\r\n.ol-overlay.slide-down {\r\n  -webkit-transform: translateY(-100%);\r\n  transform: translateY(-100%);\r\n}\r\n.ol-overlay.slide-left\r\n{\t-webkit-transform: translateX(-100%);\r\n  transform: translateX(-100%);\r\n}\r\n.ol-overlay.slide-right {\r\n  -webkit-transform: translateX(100%);\r\n  transform: translateX(100%);\r\n}\r\n.ol-overlay.zoom {\r\n  top: 50%;\r\n  left: 50%;\r\n  opacity:0.5;\r\n  -webkit-transform: translate(-50%,-50%) scale(0);\r\n  transform: translate(-50%,-50%) scale(0);\r\n}\r\n.ol-overlay.zoomout {\r\n  -webkit-transform: scale(3);\r\n  transform: scale(3);\r\n}\r\n.ol-overlay.zoomrotate {\r\n  top: 50%;\r\n  left: 50%;\r\n  opacity:0.5;\r\n  -webkit-transform: translate(-50%,-50%) scale(0) rotate(360deg);\r\n  transform: translate(-50%,-50%) scale(0) rotate(360deg);\r\n}\r\n.ol-overlay.stretch {\r\n  top: 50%;\r\n  left: 50%;\r\n  opacity:0.5;\r\n  -webkit-transform: translate(-50%,-50%) scaleX(0);\r\n  transform: translate(-50%,-50%) scaleX(0) ;\r\n}\r\n.ol-overlay.stretchy {\r\n  top: 50%;\r\n  left: 50%;\r\n  opacity:0.5;\r\n  -webkit-transform: translate(-50%,-50%) scaleY(0);\r\n  transform: translate(-50%,-50%) scaleY(0) ;\r\n}\r\n.ol-overlay.wipe {\r\n  opacity: 1;\r\n  /* clip: must be set programmatically */\r\n  /* clip-path: use % but not crossplatform (IE) */\r\n}\r\n.ol-overlay.flip {\r\n  -webkit-transform: perspective(600px) rotateY(180deg);\r\n  transform: perspective(600px) rotateY(180deg);\r\n}\r\n.ol-overlay.card {\r\n  opacity: 0.5;\r\n  -webkit-transform: translate(-80%, 100%) rotate(-0.5turn);\r\n  transform: translate(-80%, 100%) rotate(-0.5turn);\r\n}\r\n.ol-overlay.book {\r\n  -webkit-transform: perspective(600px) rotateY(-180deg) scaleX(0.6);\r\n  transform: perspective(600px) rotateY(-180deg) scaleX(0.6) ;\r\n  -webkit-transform-origin: 10% 50%;\r\n  transform-origin: 10% 50%;\r\n}\r\n.ol-overlay.book.visible {\r\n  -webkit-transform-origin: 10% 50%;\r\n  transform-origin: 10% 50%;\r\n}\r\n\r\n.ol-overlay.ol-visible {\r\n  opacity:1;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  -webkit-transform: none;\r\n  transform: none;\r\n  pointer-events: all;  \r\n}\r\n\r\n.ol-overlay .ol-closebox {\r\n  position: absolute;\r\n  top: 1em;\r\n  right: 1em;\r\n  width: 1em;\r\n  height: 1em;\r\n  cursor: pointer;\r\n  z-index:1;\r\n}\r\n.ol-overlay .ol-closebox:before {\r\n  content: \"\\274c\";\r\n  display: block;\r\n  text-align: center;\r\n  vertical-align: middle;\r\n}\r\n\r\n.ol-overlay .ol-fullscreen-image {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  bottom: 0;\r\n  right: 0;\r\n}\r\n.ol-overlay .ol-fullscreen-image img {\r\n  position: absolute;\r\n  max-width: 100%;\r\n  max-height: 100%;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  padding: 1em;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n  transform: translate(-50%, -50%);\r\n}\r\n.ol-overlay .ol-fullscreen-image.ol-has-title img {\r\n  padding-bottom: 3em;\r\n}\r\n.ol-overlay .ol-fullscreen-image p {\r\n  background-color: rgba(0,0,0,.5);\r\n  padding: .5em;\r\n  position: absolute;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  margin: 0;\r\n  text-align: center;\r\n}\r\n.ol-control.ol-overview\r\n{\tposition: absolute;\r\n\tleft: 0.5em;\r\n\ttext-align: left;\r\n\tbottom: 0.5em;\r\n}\r\n\r\n.ol-control.ol-overview .panel\r\n{\tdisplay:block;\r\n\twidth:150px;\r\n\theight:150px;\r\n\tmargin:2px;\r\n\tbackground-color:#fff;\r\n\tborder:1px solid #369;\r\n\tcursor: pointer;\r\n}\r\n\r\n.ol-overview:not(.ol-collapsed) button\r\n{\tposition:absolute;\r\n\tbottom:2px;\r\n\tleft:2px;\r\n\tz-index:2;\r\n}\r\n\r\n.ol-control.ol-overview.ol-collapsed .panel\r\n{\tdisplay:none;\r\n}\r\n\r\n.ol-overview.ol-collapsed button:before\r\n{\tcontent:'\\00bb';\r\n}\r\n.ol-overview button:before\r\n{\tcontent:'\\00ab';\r\n}\r\n\r\n\r\n.ol-control-right.ol-overview\r\n{\tleft: auto;\r\n\tright: 0.5em;\r\n}\r\n.ol-control-right.ol-overview:not(.ol-collapsed) button\r\n{\tleft:auto;\r\n\tright:2px;\r\n}\r\n.ol-control-right.ol-overview.ol-collapsed button:before\r\n{\tcontent:'\\00ab';\r\n}\r\n.ol-control-right.ol-overview button:before\r\n{\tcontent:'\\00bb';\r\n}\r\n\r\n.ol-control-top.ol-overview\r\n{\tbottom: auto;\r\n\ttop: 5em;\r\n}\r\n.ol-control-top.ol-overview:not(.ol-collapsed) button\r\n{\tbottom:auto;\r\n\ttop:2px;\r\n}\r\n\r\n.ol-permalink {\r\n  position: absolute;\r\n  top:0.5em;\r\n  right: 2.5em;\r\n}\r\n.ol-touch .ol-permalink {\r\n  right: 3em;\r\n}\r\n\r\n.ol-permalink button i {\r\n  position: absolute;\r\n  width: 1em;\r\n  height: 1em;\r\n  display: block;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-permalink button i:before {\r\n  content: '\\2197';\r\n  position: absolute;\r\n  border: 1px solid currentColor;\r\n  left: 0;\r\n  top: 0;\r\n  width: 0.3em;\r\n  height: 1em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  border-width: 1px 0 0 1px;\r\n  padding: 0 0.2em;\r\n}\r\n.ol-permalink button i:after {\r\n  content: '';\r\n  position: absolute;\r\n  border: 1px solid currentColor;\r\n  right: 0;\r\n  bottom: 0;\r\n  width: 1em;\r\n  height: 0.3em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  border-width: 0 1px 1px 0;\r\n  padding: 0.2em;\r\n}\r\n.ol-control.ol-print {\r\n  top:.5em;\r\n  left: 3em;\r\n}\r\n.ol-control.ol-print button:before {\r\n  content: \"\";\r\n  width: .9em;\r\n  height: .35em;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  -webkit-box-shadow: inset 0 0 0 0.1em, inset 0.55em 0, 0 0.2em 0 -0.1em;\r\n          box-shadow: inset 0 0 0 0.1em, inset 0.55em 0, 0 0.2em 0 -0.1em;\r\n}\r\n.ol-control.ol-print button:after {\r\n  content: \"\";\r\n  width: .7em;\r\n  height: .6em;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 25%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  -webkit-box-shadow: inset 0 0 0 0.15em;\r\n          box-shadow: inset 0 0 0 0.15em;\r\n}\r\n.ol-ext-print-dialog {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.ol-ext-print-dialog > form .ol-closebox {\r\n  right: auto;\r\n  left: 16.5em;\r\n  z-index: 1;\r\n  color: #999;\r\n}\r\n.ol-ext-print-dialog .ol-content[data-status=\"printing\"] {\r\n  opacity: .5;\r\n}\r\n.ol-ext-print-dialog .ol-content .ol-error {\r\n  display: none;\r\n  background: #b00;\r\n  color: yellow;\r\n  text-align: center;\r\n  padding: 1em .5em;\r\n  font-weight: bold;\r\n  margin: 0 -1em;\r\n}\r\n.ol-ext-print-dialog .ol-content[data-status=\"error\"] .ol-error {\r\n  display: block;\r\n}\r\n\r\n\r\n.ol-ext-print-dialog > form,\r\n.ol-ext-print-dialog.ol-visible > form {\r\n  -webkit-transition: none;\r\n  transition: none;\r\n  top: 1em;\r\n  left: 1em;\r\n  bottom: 1em;\r\n  right: 1em;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n  max-width: 100%;\r\n  max-height: 100%;\r\n  background-color: #eee;\r\n  padding: 0;\r\n}\r\n.ol-ext-print-dialog .ol-print-map {\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  right: 0;\r\n  width: calc(100% - 18em);\r\n  overflow: hidden;\r\n}\r\n.ol-ext-print-dialog .ol-print-map .ol-page {\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  background: #fff;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-ext-print-dialog .ol-print-map .ol-page.margin {\r\n  -webkit-box-sizing: content-box;\r\n          box-sizing: content-box;\r\n}\r\n.ol-ext-print-dialog .ol-map {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.ol-ext-print-dialog .ol-print-map .ol-control {\r\n  display: none!important;\r\n}\r\n\r\n.ol-ext-print-dialog .ol-print-param {\r\n  position: absolute;\r\n  overflow-x: hidden;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 18em;\r\n  background-color: #fff;\r\n  padding: 1em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n\r\n.ol-ext-print-dialog .ol-print-param h2 {\r\n  display: block;\r\n  color: rgba(0,60,136,.7);\r\n  font-size: 1.1em;\r\n}\r\n.ol-ext-print-dialog .ol-print-param ul {\r\n  padding: 0;\r\n  list-style: none;\r\n}\r\n.ol-ext-print-dialog .ol-print-param li {\r\n  position: relative;\r\n  margin: .5em 0;\r\n  font-size: .9em;\r\n}\r\n.ol-ext-print-dialog .ol-print-param li.hidden {\r\n  display: none;\r\n}\r\n.ol-ext-print-dialog .ol-print-param label {\r\n  width: 8em;\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\n.ol-ext-print-dialog select {\r\n  outline: none;\r\n  vertical-align: middle;\r\n}\r\n\r\n.ol-ext-print-dialog .ol-orientation {\r\n  text-align: center;\r\n}\r\n.ol-ext-print-dialog .ol-orientation label {\r\n  position: relative;\r\n  width: 7em;\r\n  cursor: pointer;\r\n}\r\n.ol-ext-print-dialog .ol-orientation input {\r\n  position: absolute;\r\n  opacity: 0;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n.ol-ext-print-dialog .ol-orientation span {\r\n  position: relative;\r\n  width: 80%;\r\n  display: block;\r\n  padding: 3.5em 0 .2em;\r\n}\r\n.ol-ext-print-dialog .ol-orientation span:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 2em;\r\n  height: 2.6em;\r\n  bottom: 1.5em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  color: #333;\r\n  background-color: currentColor;\r\n  border: 1px solid currentColor;\r\n  border-radius: 0 1em 0 0;\r\n  opacity: .5;\r\n  overflow: hidden;\r\n  -webkit-box-shadow: inset 1.3em -1.91em #ddd;\r\n          box-shadow: inset 1.3em -1.91em #ddd;\r\n}\r\n\r\n.ol-ext-print-dialog .ol-orientation .landscape span:before {\r\n  width: 2.6em;\r\n  height: 2em;\r\n  margin: .2em 0;\r\n  -webkit-box-shadow: inset 1.91em -1.3em #ddd;\r\n          box-shadow: inset 1.91em -1.3em #ddd;\r\n}\r\n.ol-ext-print-dialog .ol-orientation input:checked + span {\r\n  opacity: 1;\r\n  -webkit-box-shadow: 0 0 .2em rgba(0,0,0,.5);\r\n          box-shadow: 0 0 .2em rgba(0,0,0,.5);\r\n}\r\n\r\n.ol-ext-print-dialog .ol-ext-toggle-switch span {\r\n  position: absolute;\r\n  right: -2em;\r\n  top: 50%;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n}\r\n\r\n.ol-print-title input[type=text] {\r\n  margin-top: .5em;\r\n  width: calc(100% - 6em);\r\n  margin-left: 6em;\r\n}\r\n\r\n.ol-ext-print-dialog .ol-size option:first-child {\r\n  font-style: italic;\r\n}\r\n\r\n.ol-ext-print-dialog .ol-saveas,\r\n.ol-ext-print-dialog .ol-savelegend {\r\n  text-align: center;\r\n}\r\n.ol-ext-print-dialog .ol-saveas select,\r\n.ol-ext-print-dialog .ol-savelegend select {\r\n  background-color: rgba(0,60,136,.7);\r\n  color: #fff;\r\n  padding: .5em;\r\n  margin: 1em 0 0;\r\n  font-size: 1em;\r\n  border: 0;\r\n  font-weight: bold;\r\n  max-width: 12em;\r\n}\r\n.ol-ext-print-dialog .ol-saveas select option,\r\n.ol-ext-print-dialog .ol-savelegend select option {\r\n  background-color: #fff;\r\n  color: #666;\r\n}\r\n.ol-ext-print-dialog .ol-savelegend select {\r\n  margin-top: 0;\r\n}\r\n\r\n.ol-ext-print-dialog .ol-ext-buttons {\r\n  text-align: right;\r\n  border-top: 1px solid #ccc;\r\n  padding: .8em .5em;\r\n  margin: 0 -1em;\r\n}\r\n.ol-ext-print-dialog button {\r\n  font-size: 1em;\r\n  margin: 0 .2em;\r\n  border: 1px solid #999;\r\n  background: none;\r\n  padding: .3em 1em;\r\n  color: #333;\r\n}\r\n.ol-ext-print-dialog button[type=\"submit\"] {\r\n  background-color: rgba(0,60,136,.7);\r\n  color: #fff;\r\n  font-weight: bold;\r\n}\r\n\r\n.ol-ext-print-dialog .ol-clipboard-copy {\r\n  position: absolute;\r\n  pointer-events: none;\r\n  top: 0;\r\n  background-color: rgba(0,0,0,.5);\r\n  color: #fff;\r\n  padding: .5em 1em;\r\n  border-radius: 1em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  width: -webkit-fit-content;\r\n  width: -moz-fit-content;\r\n  width: fit-content;\r\n  -webkit-transition: 0s;\r\n  transition: 0s;\r\n  opacity: 0;\r\n}\r\n.ol-ext-print-dialog .ol-clipboard-copy.visible {\r\n  -webkit-animation: 1s ol-clipboard-copy;\r\n          animation: 1s ol-clipboard-copy;\r\n}\r\n.ol-ext-print-dialog .ol-print-map .ol-control.ol-canvas-control {\r\n  display: block!important;\r\n}\r\n.ol-ext-print-dialog .ol-print-map .ol-control.ol-print-compass {\r\n  display: block!important;\r\n}\r\n.ol-ext-print-dialog .ol-print-map .ol-control.olext-print-compass {\r\n  top: 0;\r\n  right: 0;\r\n  width: 60px;\r\n  height: 60px;\r\n  margin: 20px;\r\n}\r\n\r\n@-webkit-keyframes ol-clipboard-copy { \r\n  0% { opacity: 0; top: 0; }\r\n  80% { opacity: 1; top: -3em; }\r\n  100% { opacity: 0; top: -3em; }  \r\n}\r\n\r\n@keyframes ol-clipboard-copy { \r\n  0% { opacity: 0; top: 0; }\r\n  80% { opacity: 1; top: -3em; }\r\n  100% { opacity: 0; top: -3em; }  \r\n}\r\n\r\n@media print {\r\n  body.ol-print-document {\r\n    margin: 0!important;\r\n    padding: 0!important;\r\n  }\r\n  body.ol-print-document > * {\r\n    display: none!important;\r\n  }\r\n  body.ol-print-document > .ol-ext-print-dialog {\r\n    display: block!important;\r\n  }\r\n  body.ol-print-document > .ol-ext-print-dialog .ol-content {\r\n    max-height: unset!important;\r\n    max-width: unset!important;\r\n    width: unset!important;\r\n    height: unset!important;\r\n  }\r\n  .ol-ext-print-dialog > form,\r\n  .ol-ext-print-dialog {\r\n    position: unset;\r\n    -webkit-box-shadow: none;\r\n            box-shadow: none;\r\n    background: none!important;\r\n    border: 0;\r\n  }\r\n  .ol-ext-print-dialog > form > *,\r\n  .ol-ext-print-dialog .ol-print-param {\r\n    display: none!important;\r\n    background: none;\r\n  } \r\n  .ol-ext-print-dialog .ol-content {\r\n    display: block!important;\r\n    border: 0;\r\n    background: none;\r\n  }\r\n  .ol-ext-print-dialog .ol-print-map {\r\n    position: unset; \r\n    background: none;\r\n    width: auto;\r\n    overflow: visible;\r\n  }\r\n  .ol-ext-print-dialog .ol-print-map .ol-page {\r\n    -webkit-transform: none!important;\r\n            transform: none!important;\r\n    -webkit-box-shadow: none!important;\r\n            box-shadow: none!important;\r\n    position: unset;\r\n  }\r\n}\r\n\r\n@media (max-width: 25em) {\r\n  .ol-ext-print-dialog .ol-print-param {\r\n    width: 13em;\r\n  }\r\n  .ol-ext-print-dialog .ol-print-map {\r\n    width: calc(100% - 13em);\r\n  }\r\n  .ol-ext-print-dialog .ol-print-param .ol-print-title input[type=\"text\"] {\r\n    width: 100%;\r\n    margin: 0;\r\n  }\r\n}\r\n.ol-ext-print-dialog2x .ol-map,\r\n.ol-ext-print-dialog2x .ol-map2 {\r\n  width: 100%;\r\n  height: 50%;\r\n}\r\n.ol-ext-print-dialog2x[data-orientation=\"landscape\"] .ol-map,\r\n.ol-ext-print-dialog2x[data-orientation=\"landscape\"] .ol-map2 {\r\n  display: inline-block;\r\n  width: 50%;\r\n  height: 100%;\r\n}\r\n\r\n.ol-ext-print-dialog2x[data-clip-map] .ol-map,\r\n.ol-ext-print-dialog2x[data-swipe-orientation] .ol-map {\r\n  width: 100%!important;\r\n  height: 100%!important;\r\n}\r\n.ol-ext-print-dialog2x[data-clip-map] .ol-map2,\r\n.ol-ext-print-dialog2x[data-swipe-orientation] .ol-map2 {\r\n  width: 100%!important;\r\n  height: 100%!important;\r\n  position: relative!important;\r\n  left: 0;\r\n  top: -100%;\r\n}\r\n.ol-profile {\r\n  position: relative;\r\n  -webkit-user-select: none;\r\n     -moz-user-select: none;\r\n      -ms-user-select: none;\r\n          user-select: none;\r\n}\r\n.ol-control.ol-profile {\r\n  position: absolute;\r\n  top: 0.5em;\r\n  right: 3em;\r\n  text-align: right;\r\n  overflow: hidden;\r\n}\r\n.ol-profile .ol-zoom-out {\r\n  position: absolute;\r\n  top: 10px;\r\n  right: 10px;\r\n  width: 1em;\r\n  height: 1em;\r\n  padding: 0;\r\n  border: 1px solid #000;\r\n  border-radius: 2px;\r\n  cursor: pointer;\r\n}\r\n.ol-profile .ol-zoom-out:before {\r\n  content: '';\r\n  height: 2px;\r\n  width: 60%;\r\n  background: currentColor;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n\r\n.ol-profile .ol-inner  {\r\n  position: relative;\r\n  padding: 0.5em;\r\n  font-size: 0.8em;\r\n}\r\n.ol-control.ol-profile .ol-inner {\r\n  display: block;\r\n  background-color: rgba(255,255,255,0.7);\r\n  margin: 2.3em 2px 2px;\r\n}\r\n.ol-control.ol-profile.ol-collapsed .ol-inner {\r\n  display: none;\r\n}\r\n\r\n.ol-profile canvas {\r\n  display: block;\r\n}\r\n.ol-profile button {\r\n  display: block;\r\n  position: absolute;\r\n  right: 0;\r\n  overflow: hidden;\r\n}\r\n.ol-profile button i {\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  width: 1em;\r\n  height: 1em;\r\n  overflow: hidden;\r\n}\r\n.ol-profile button i:before,\r\n.ol-profile button i:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  display: block;\r\n  background-color: currentColor;\r\n  width: 1em;\r\n  height: .9em;\r\n  -webkit-transform: scaleX(.8) translate(-.25em, .5em) rotate(45deg);\r\n          transform: scaleX(.8) translate(-.25em, .5em) rotate(45deg);\r\n}\r\n.ol-profile button i:after {\r\n  -webkit-transform: scaleX(.8) translate(.35em, .7em) rotate(45deg);\r\n          transform: scaleX(.8) translate(.35em, .7em) rotate(45deg);\r\n}\r\n\r\n.ol-profile.ol-collapsed button {\r\n  position: static;\r\n}\r\n\r\n.ol-profile .ol-profilebar,\r\n.ol-profile .ol-profilecursor {\r\n  position:absolute;\r\n  pointer-events: none;\r\n  width: 1px;\r\n  display: none;\r\n}\r\n.ol-profile .ol-profilecursor {\r\n  width: 0;\r\n  height: 0;\r\n}\r\n.ol-profile .ol-profilecursor:before {\r\n  content:\"\";\r\n  pointer-events: none;\r\n  display: block;\r\n  margin: -2px;\r\n  width:5px;\r\n  height:5px;\r\n}\r\n.ol-profile .ol-profilebar,\r\n.ol-profile .ol-profilecursor:before {\r\n  background: red;\r\n}\r\n\r\n.ol-profile table {\r\n  text-align: center;\r\n  width: 100%;\r\n}\r\n\r\n.ol-profile table span {\r\n  display: block;\r\n}\r\n\r\n.ol-profilepopup {\r\n  background-color: rgba(255, 255, 255, 0.5);\r\n  margin: 0.5em;\r\n  padding: 0 0.5em;\r\n  position: absolute;\r\n  top:-1em;\r\n  white-space: nowrap;\r\n}\r\n.ol-profilepopup.ol-left {\r\n  right:0;\r\n}\r\n\r\n\r\n.ol-profile table td {\r\n  padding: 0 2px;\r\n}\r\n\r\n.ol-profile table .track-info {\r\n  display: table-row;\r\n}\r\n.ol-profile table .point-info {\r\n  display: none;\r\n}\r\n.ol-profile .over table .track-info {\r\n  display: none;\r\n}\r\n.ol-profile .over table .point-info {\r\n  display: table-row;\r\n}\r\n\r\n.ol-profile p {\r\n  text-align: center;\r\n  margin:0;\r\n}\r\n\r\n.ol-control.ol-progress-bar {\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  padding: 0;\r\n  pointer-events: none!important;\r\n  background-color: transparent;\r\n}\r\n\r\n.ol-control.ol-progress-bar > .ol-bar {\r\n  position: absolute;\r\n  background-color: rgba(0,60,136,.5);\r\n  left: 0;\r\n  bottom: 0;\r\n  height: .5em;\r\n  width: 0;\r\n  -webkit-transition: width .2s;\r\n  transition: width .2s;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n\r\n.ol-progress-bar > .ol-waiting {\r\n  display: none;\r\n}\r\n\r\n.ol-viewport .ol-control.ol-progress-bar > .ol-waiting {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  color: #fff;\r\n  font-size: 2em;\r\n  display: block;\r\n  -webkit-animation: 1s linear infinite ol-progress-bar-blink;\r\n          animation: 1s linear infinite ol-progress-bar-blink;\r\n}\r\n\r\n@-webkit-keyframes ol-progress-bar-blink {\r\n  0%, 30% {\r\n    visibility: hidden;\r\n  }\r\n  100% {\r\n    visibility: visible;\r\n  }\r\n}\r\n\r\n@keyframes ol-progress-bar-blink {\r\n  0%, 30% {\r\n    visibility: hidden;\r\n  }\r\n  100% {\r\n    visibility: visible;\r\n  }\r\n}\r\n\r\n.ol-control.ol-routing {\r\n  top: 0.5em;\r\n  left: 3em;\r\n  max-height: 90%;\r\n  overflow-y: auto;\r\n}\r\n.ol-touch .ol-control.ol-routing {\r\n  left: 3.5em;\r\n}\r\n.ol-control.ol-routing.ol-searching {\r\n  opacity: .5;\r\n}\r\n\r\n.ol-control.ol-routing .ol-car,\r\n.ol-control.ol-routing > button {\r\n  position: relative;\r\n}\r\n.ol-control.ol-routing .ol-car:after,\r\n.ol-control.ol-routing > button:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: .78em;\r\n  height: 0.6em;\r\n  border-radius: 40% 50% 0 0 / 50% 70% 0 0;\r\n  -webkit-box-shadow: inset 0 0 0 0.065em, -0.35em 0.14em 0 -0.09em, inset 0 -0.37em, inset -0.14em 0.005em;\r\n          box-shadow: inset 0 0 0 0.065em, -0.35em 0.14em 0 -0.09em, inset 0 -0.37em, inset -0.14em 0.005em;\r\n  clip: rect(0 1em .5em -1em);\r\n  top: .35em;\r\n  left: .4em;\r\n}\r\n.ol-control.ol-routing .ol-car:before,\r\n.ol-control.ol-routing > button:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: .28em;\r\n  height: .28em;\r\n  border-radius: 50%;\r\n  -webkit-box-shadow: inset 0 0 0 1em, 0.65em 0;\r\n          box-shadow: inset 0 0 0 1em, 0.65em 0;\r\n  top: 0.73em;\r\n  left: .20em;\r\n}\r\n.ol-control.ol-routing .ol-pedestrian:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: .3em;\r\n  height: .4em;\r\n  top: .25em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  -webkit-box-shadow: inset 0.3em 0, 0.1em 0.5em 0 -0.1em, -0.1em 0.5em 0 -0.1em, 0.25em 0.1em 0 -0.1em, -0.25em 0.1em 0 -0.1em;\r\n          box-shadow: inset 0.3em 0, 0.1em 0.5em 0 -0.1em, -0.1em 0.5em 0 -0.1em, 0.25em 0.1em 0 -0.1em, -0.25em 0.1em 0 -0.1em;\r\n  border-top: .2em solid transparent;\r\n}\r\n.ol-control.ol-routing .ol-pedestrian:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: .3em;\r\n  height: .3em;\r\n  top: .1em;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  border-radius: 50%;\r\n  background-color: currentColor;\r\n}\r\n\r\n.ol-control.ol-routing .content {\r\n  margin: .5em;\r\n}\r\n\r\n.ol-control.ol-routing.ol-collapsed .content {\r\n  display: none;\r\n}\r\n\r\n.ol-routing .ol-search.ol-collapsed ul {\r\n\tdisplay: none;\r\n}\r\n.ol-routing .ol-search ul .copy {\r\n  display: none;\r\n}\r\n.ol-routing .ol-search ul.history {\r\n  /* display: none; */\r\n}\r\n.ol-routing .content .search-input > div > * {\r\n  display: inline-block;\r\n  vertical-align: top;\r\n}\r\n.ol-routing .ol-result ul {\r\n  list-style: none;\r\n  display: block;\r\n}\r\n.ol-routing .ol-result li {\r\n  position: relative;\r\n  min-height: 1.65em;\r\n}\r\n.ol-routing .ol-result li i {\r\n  display: block;\r\n  font-size: .8em;\r\n  font-weight: bold;\r\n}\r\n\r\n.ol-routing .ol-result li:before {\r\n  content: \"\";\r\n  border: 5px solid transparent;\r\n  position: absolute;\r\n  left: -1.75em;\r\n  border-bottom-color: #369;\r\n  border-width: .6em .4em .6em;\r\n  -webkit-transform-origin: 50% 125%;\r\n          transform-origin: 50% 125%;\r\n  -webkit-box-shadow: 0 0.65em 0 -0.25em #369;\r\n          box-shadow: 0 0.65em 0 -0.25em #369;\r\n  top: -.8em;\r\n}\r\n.ol-routing .ol-result li:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 0.25em;\r\n  height: .6em;\r\n  left: -1.5em;\r\n  background: #369;\r\n  top: .6em;\r\n  border-radius: 0.1em;\r\n}\r\n.ol-routing .ol-result li.R:before {\r\n  -webkit-transform: rotate(90deg);\r\n          transform: rotate(90deg);\r\n}\r\n.ol-routing .ol-result li.FR:before {\r\n  -webkit-transform: rotate(45deg);\r\n          transform: rotate(45deg);\r\n}\r\n.ol-routing .ol-result li.L:before {\r\n  -webkit-transform: rotate(-90deg);\r\n          transform: rotate(-90deg);\r\n}\r\n.ol-routing .ol-result li.FL:before {\r\n  -webkit-transform: rotate(-45deg);\r\n          transform: rotate(-45deg);\r\n}\r\n\r\n.ol-routing .content > i {\r\n  vertical-align: middle;\r\n  margin: 0 .3em 0 .1em;\r\n  font-style: normal;\r\n}\r\n.ol-routing .ol-button,\r\n.ol-routing .ol-button:focus,\r\n.ol-routing .ol-pedestrian,\r\n.ol-routing .ol-car {\r\n  font-size: 1.1em;\r\n  position: relative;\r\n  display: inline-block;\r\n  width: 1.4em;\r\n  height: 1.4em;\r\n  color: rgba(0,60,136,1);\r\n  background-color: transparent;\r\n  margin: 0 .1em;\r\n  opacity: .5;\r\n  vertical-align: middle;\r\n  outline: none;\r\n  cursor: pointer;\r\n}\r\n.ol-routing .ol-button:hover,\r\n.ol-routing .ol-button.selected,\r\n.ol-routing i.selected {\r\n  opacity: 1;\r\n  background: transparent;\r\n}\r\n\r\n.ol-control.ol-routing {\r\n  background-color: rgba(255,255,255,.25);\r\n}\r\n.ol-control.ol-routing:hover {\r\n  background-color: rgba(255,255,255,.75);\r\n}\r\n\r\n.search-input > div > button:before {\r\n  content: '\\00b1';\r\n}\r\n.ol-viewport .ol-scale {\r\n\tleft: .5em;\r\n\tbottom: 2.5em;\r\n\ttext-align: center;\r\n\t-webkit-transform: scaleX(.8);\r\n\t-webkit-transform-origin: 0 0;\r\n\ttransform: scaleX(.8);\r\n\ttransform-origin: 0 0;\r\n\tbackground-color: rgba(255, 255, 255, 0.75);\r\n}\r\n.ol-viewport .ol-scale input {\r\n\tbackground: none;\r\n    border: 0;\r\n    width: 8em;\r\n    text-align: center;\r\n}\r\n\r\n.ol-search{\r\n  top: 0.5em;\r\n  left: 3em;\r\n}\r\n.ol-touch .ol-search {\r\n  left: 3.5em;\r\n}\r\n.ol-search button {\r\n  top: 2px;\r\n  left: 2px;\r\n  float: left;\r\n}\r\n.ol-control.ol-search > button:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  width: .7em;\r\n  height: .7em;\r\n  background-color: transparent;\r\n  border: .12em solid currentColor;\r\n  border-radius: 100%;\r\n  top: .35em;\r\n  left: .35em;\r\n}\r\n.ol-control.ol-search > button:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  top: 1.1em;\r\n  left: .95em;\r\n  width: .45em;\r\n  height: .15em;\r\n  background-color: currentColor;\r\n  border-radius: .05em;\r\n  -webkit-transform: rotate(45deg);\r\n          transform: rotate(45deg);\r\n  -webkit-box-shadow: -0.18em 0 0 -0.03em;\r\n          box-shadow: -0.18em 0 0 -0.03em;\r\n}\r\n\r\n.ol-search button.ol-revers {\r\n  float: none;\r\n  background-image: none;\r\n  display: inline-block;\r\n  vertical-align: bottom;\r\n  position: relative;\r\n  top: 0;\r\n  left: 0;\r\n}\r\n.ol-search.ol-revers button.ol-revers {\r\n  background-color: rgba(0,136,60,.5)\r\n}\r\n\r\n.ol-control.ol-search.ol-collapsed button.ol-revers {\r\n  display: none;\r\n}\r\n.ol-search button.ol-revers:before {\r\n  content: \"\";\r\n  border: .1em solid currentColor;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%,-50%);\r\n          transform: translate(-50%,-50%);\r\n  border-radius: 50%;\r\n  width: .55em;\r\n  height: .55em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-search button.ol-revers:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%,-50%);\r\n          transform: translate(-50%,-50%);\r\n  width: .2em;\r\n  height: .2em;\r\n  background-color: transparent;\r\n  -webkit-box-shadow: .35em 0 currentColor, 0 .35em currentColor, -.35em 0 currentColor, 0 -.35em currentColor;\r\n          box-shadow: .35em 0 currentColor, 0 .35em currentColor, -.35em 0 currentColor, 0 -.35em currentColor;\r\n}\r\n\r\n.ol-search input {\r\n  display: inline-block;\r\n  border: 0;\r\n  margin: 1px 1px 1px 2px;\r\n  font-size: 1.14em;\r\n  padding-left: 0.3em;\r\n  height: 1.375em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  -webkit-transition: all 0.1s;\r\n  transition: all 0.1s;\r\n}\r\n.ol-touch .ol-search input,\r\n.ol-touch .ol-search ul {\r\n  font-size: 1.5em;\r\n}\r\n.ol-search.ol-revers > ul,\r\n.ol-control.ol-search.ol-collapsed > * {\r\n  display: none;\r\n}\r\n.ol-control.ol-search.ol-collapsed > button {\r\n  display: block;\r\n}\r\n\r\n.ol-search ul {\r\n  list-style: none;\r\n  padding: 0;\r\n  margin: 0;\r\n  display: block;\r\n  clear: both;\r\n  cursor: pointer;\r\n  max-width: 17em;\r\n  overflow-x: hidden;\r\n  z-index: 1;\r\n  background: #fff;\r\n}\r\n/*\r\n.ol-control.ol-search ul {\r\n  position: absolute;\r\n  box-shadow: 5px 5px 5px rgba(0,0,0,0.5);\r\n}\r\n*/\r\n.ol-search ul li {\r\n  padding: 0.1em 0.5em;\r\n  white-space: nowrap;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n}\r\n.ol-search ul li.select,\r\n.ol-search ul li:hover {\r\n  background-color: rgba(0,60,136,.5);\r\n  color: #fff;\r\n}\r\n.ol-search ul li img {\r\n  float: left;\r\n  max-height: 2em;\r\n}\r\n.ol-search li.copy {\r\n    background: rgba(0,0,0,.5);\r\n  color: #fff;\r\n}\r\n.ol-search li.copy a {\r\n  color: #fff;\r\n  text-decoration: none;\r\n}\r\n\r\n.ol-search.searching:before {\r\n  content: '';\r\n  position: absolute;\r\n  height: 3px;\r\n  left: 0;\r\n  top: 1.6em;\r\n  -webkit-animation: pulse .5s infinite alternate linear;\r\n          animation: pulse .5s infinite alternate linear;\r\n  background: red;\r\n  z-index: 2;\r\n}\r\n\r\n@-webkit-keyframes pulse {\r\n  0% { left:0; right: 95%; }\r\n  50% {\tleft: 30%; right: 30%; }\r\n  100% {\tleft: 95%; right: 0; }\r\n}\r\n\r\n@keyframes pulse {\r\n  0% { left:0; right: 95%; }\r\n  50% {\tleft: 30%; right: 30%; }\r\n  100% {\tleft: 95%; right: 0; }\r\n}\r\n\r\n\r\n.ol-control.ol-search.IGNF-parcelle {\r\n  background-color: rgba(255,255,255,.7);\r\n  padding-bottom: .2em;\r\n}\r\n.ol-search.IGNF-parcelle input {\r\n  width: 14.5em;\r\n}\r\n.ol-search.IGNF-parcelle input:-moz-read-only {\r\n  background: #ccc;\r\n  opacity: .8;\r\n}\r\n.ol-search.IGNF-parcelle input:read-only {\r\n  background: #ccc;\r\n  opacity: .8;\r\n}\r\n.ol-search.IGNF-parcelle.ol-collapsed-list > ul.autocomplete {\r\n  display: none;\r\n}\r\n\r\n.ol-search.IGNF-parcelle label {\r\n  display: block;\r\n  clear: both;\r\n}\r\n\r\n.ol-search.IGNF-parcelle > div input {\r\n  text-align: right;\r\n}\r\n.ol-search.IGNF-parcelle > div input,\r\n.ol-search.IGNF-parcelle > div label {\r\n  width: 4em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  display: inline-block;\r\n  margin: .1em;\r\n  font-size: 1em;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n}\r\n.ol-search.IGNF-parcelle > div label {\r\n  letter-spacing: -0.04em;\r\n}\r\n.ol-search.IGNF-parcelle ul.autocomplete-page {\r\n  margin-top:.5em;\r\n  width:100%;\r\n  text-align: center;\r\n  display: none;\r\n}\r\n.ol-search.IGNF-parcelle.ol-collapsed-list ul.autocomplete-parcelle,\r\n.ol-search.IGNF-parcelle.ol-collapsed-list ul.autocomplete-page {\r\n  display: block;\r\n}\r\n.ol-search.IGNF-parcelle.ol-collapsed ul.autocomplete-page,\r\n.ol-search.IGNF-parcelle.ol-collapsed ul.autocomplete-parcelle,\r\n.ol-search.IGNF-parcelle ul.autocomplete-parcelle {\r\n  display: none;\r\n}\r\n.ol-search.IGNF-parcelle ul.autocomplete-page li {\r\n  display: inline-block;\r\n  color: #fff;\r\n  background: rgba(0,60,136,.5);\r\n  border-radius: 50%;\r\n  width: 1.3em;\r\n  height: 1.3em;\r\n  padding: .1em;\r\n  margin: 0 .1em;\r\n}\r\n.ol-search.IGNF-parcelle ul.autocomplete-page li.selected {\r\n  background: rgba(0,60,136,1);\r\n}\r\n\r\n/* GPS */\r\n.ol-searchgps input.search {\r\n  display: none;\r\n}\r\n.ol-control.ol-searchgps > button:first-child {\r\n  background-image: none;\r\n}\r\n.ol-control.ol-searchgps > button:first-child:before {\r\n  content: \"x/y\";\r\n  position: unset;\r\n  display: block;\r\n  -webkit-transform: scaleX(.8);\r\n          transform: scaleX(.8);\r\n  border: unset;\r\n  border-radius: 0;\r\n  width: auto;\r\n  height: auto;\r\n}\r\n.ol-control.ol-searchgps > button:first-child:after {\r\n  content: unset;\r\n}\r\n.ol-control.ol-searchgps .ol-latitude,\r\n.ol-control.ol-searchgps .ol-longitude {\r\n  clear: both;\r\n}\r\n.ol-control.ol-searchgps .ol-latitude label,\r\n.ol-control.ol-searchgps .ol-longitude label {\r\n  width: 5.5em;\r\n  display: inline-block;\r\n  text-align: right;\r\n  -webkit-transform: scaleX(.8);\r\n          transform: scaleX(.8);\r\n  margin: 0 -.8em 0 0;\r\n  -webkit-transform-origin: 0 0;\r\n          transform-origin: 0 0;\r\n}\r\n.ol-control.ol-searchgps .ol-latitude input,\r\n.ol-control.ol-searchgps .ol-longitude input {\r\n  max-width: 10em;\r\n}\r\n\r\n.ol-control.ol-searchgps .ol-ext-toggle-switch {\r\n  cursor: pointer;\r\n  float: right;\r\n  margin: .5em;\r\n  font-size: .9em;\r\n}\r\n\r\n.ol-searchgps .ol-decimal{\r\n  display: inline-block;\r\n  margin-right: .7em;\r\n}\r\n.ol-searchgps .ol-dms,\r\n.ol-searchgps.ol-dms .ol-decimal {\r\n  display: none;\r\n  width: 3em;\r\n  text-align: right;\r\n}\r\n.ol-searchgps.ol-dms .ol-dms {\r\n  display: inline-block;\r\n}\r\n\r\n.ol-searchgps span.ol-dms {\r\n  width: .5em;\r\n  text-align: left;\r\n}\r\n.ol-searchgps.ol-control.ol-collapsed button.ol-geoloc {\r\n  display: none;\r\n}\r\n.ol-searchgps button.ol-geoloc {\r\n  top: 0;\r\n  float: right;\r\n  margin-right: 3px;\r\n  background-image: none;\r\n  position: relative;\r\n}\r\n.ol-searchgps button.ol-geoloc:before {\r\n  content:\"\";\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  width: .6em;\r\n  height: .6em;\r\n  border: .1em solid currentColor;\r\n  border-radius: 50%;\r\n  -webkit-transform: translate(-50%,-50%);\r\n          transform: translate(-50%,-50%);\r\n}\r\n.ol-searchgps button.ol-geoloc:after {\r\n  content:\"\";\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  width: .2em;\r\n  height: .2em;\r\n  background-color: transparent;\r\n  -webkit-transform: translate(-50%,-50%);\r\n          transform: translate(-50%,-50%);\r\n  -webkit-box-shadow: \r\n    .45em 0 currentColor, -.45em 0 currentColor, 0 -.45em currentColor, 0 .45em currentColor,\r\n    .25em 0 currentColor, -.25em 0 currentColor, 0 -.25em currentColor, 0 .25em currentColor;\r\n          box-shadow: \r\n    .45em 0 currentColor, -.45em 0 currentColor, 0 -.45em currentColor, 0 .45em currentColor,\r\n    .25em 0 currentColor, -.25em 0 currentColor, 0 -.25em currentColor, 0 .25em currentColor;\r\n}\r\n.ol-control.ol-select {\r\n  top: .5em;\r\n  left: 3em;\r\n  background-color: rgba(255,255,255,.5);\r\n}\r\n.ol-control.ol-select:hover {\r\n  background-color: rgba(255,255,255,.7);\r\n}\r\n.ol-touch .ol-control.ol-select {\r\n  left: 3.5em;\r\n}\r\n.ol-control.ol-select > button:before {\r\n  content: \"A\";\r\n  font-size: .6em;\r\n  font-weight: normal;\r\n  position: absolute;\r\n  -webkit-box-sizing: content-box;\r\n          box-sizing: content-box;\r\n  width: 1em;\r\n  height: 1em;\r\n  background-color: transparent;\r\n  border: .2em solid currentColor;\r\n  border-radius: 100%;\r\n  top: .5em;\r\n  left: .5em;\r\n  line-height: 1em;\r\n  text-align: center;\r\n}\r\n.ol-control.ol-select > button:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  top: 1.15em;\r\n  left: 1em;\r\n  width: .45em;\r\n  height: .15em;\r\n  background-color: currentColor;\r\n  border-radius: .05em;\r\n  -webkit-transform: rotate(45deg);\r\n          transform: rotate(45deg);\r\n  -webkit-box-shadow: -0.18em 0 0 -0.03em;\r\n          box-shadow: -0.18em 0 0 -0.03em;\r\n}\r\n.ol-select > div button {\r\n  width: auto;\r\n  padding: 0 .5em;\r\n  float: right;\r\n  font-weight: normal;\r\n  height: 1.2em;\r\n  line-height: 1.2em;\r\n}\r\n.ol-select .ol-delete {\r\n    width: 1.5em;\r\n  height: 1em;\r\n  vertical-align: middle;\r\n  display: inline-block;\r\n  position: relative;\r\n  cursor: pointer;\r\n}\r\n.ol-select .ol-delete:before {\r\n  content:'\\00d7';\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  width: 100%;\r\n  text-align: center;\r\n  font-weight: bold;\r\n}\r\n.ol-control.ol-select input {\r\n  font-size: 1em;\r\n}\r\n.ol-control.ol-select select {\r\n  font-size: 1em;\r\n  max-width: 10em;\r\n}\r\n.ol-control.ol-select select option.ol-default {\r\n  color: #999;\r\n  font-style: italic;\r\n}\r\n.ol-control.ol-select > div {\r\n  display: block;\r\n  margin: .25em;\r\n}\r\n.ol-control.ol-select.ol-collapsed > div {\r\n  display: none;\r\n}\r\n\r\n.ol-control.ol-select.ol-select-check {\r\n  max-width: 20em;\r\n}\r\n.ol-control.ol-select label.ol-ext-check {\r\n  margin-right: 1em;\r\n}\r\n.ol-control.ol-select label.ol-ext-toggle-switch span {\r\n  font-size: 1.1em;\r\n}\r\n\r\n.ol-select ul {\r\n  list-style: none;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n.ol-control.ol-select input[type=\"search\"],\r\n.ol-control.ol-select input[type=\"text\"]  {\r\n  width: 8em;\r\n}\r\n\r\n.ol-select .ol-autocomplete {\r\n  display: inline;\r\n}\r\n.ol-select .ol-autocomplete ul {\r\n  position: absolute;\r\n  display: block;\r\n  background: #fff;\r\n  border: 1px solid #999;\r\n  min-width: 10em;\r\n  font-size: .85em;\r\n}\r\n.ol-select .ol-autocomplete ul li {\r\n  padding: 0 .5em;\r\n}\r\n.ol-select .ol-autocomplete ul li:hover {\r\n  color: #fff;\r\n  background: rgba(0,60,136,.5);\r\n}\r\n.ol-select ul.ol-hidden {\r\n  display: none;\r\n}\r\n\r\n.ol-select-multi li > div:hover,\r\n.ol-select-multi li > div.ol-control.ol-select {\r\n  position: relative;\r\n  top: unset;\r\n  left: unset;\r\n  background: transparent;\r\n}\r\n.ol-select-multi li > div  > button,\r\n.ol-select-multi li > div  .ol-ok {\r\n  display: none;\r\n}\r\n.ol-select-multi li .ol-control.ol-select.ol-collapsed > div,\r\n.ol-select-multi li > div  > div {\r\n  display: block;\r\n}\r\n\r\n.ol-control.ol-status {\r\n  top: 0;\r\n  left: 0;\r\n  background: rgba(0,0,0,.2);\r\n  color: #fff;\r\n  font-size: .9em;\r\n  padding: .3em 3em;\r\n  border-radius: 0;\r\n  width: 100%;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  pointer-events: none!important;\r\n  display: none;\r\n}\r\n.ol-control.ol-status.ol-visible {\r\n  display: initial;\r\n}\r\n.ol-control.ol-status.ol-bottom {\r\n  top: auto;\r\n  bottom: 0;\r\n}\r\n.ol-control.ol-status.ol-left {\r\n  top: 0;\r\n  bottom: 0;\r\n  padding: .3em .5em .3em 3em;\r\n  width: auto;\r\n}\r\n.ol-control.ol-status.ol-right {\r\n  top: 0;\r\n  bottom: 0;\r\n  left: auto;\r\n  right: 0;\r\n  padding: .3em 3em .3em .5em;\r\n  width: auto;\r\n}\r\n.ol-control.ol-status.ol-center {\r\n  top: 50%;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n}\r\n\r\n.ol-control.ol-storymap {\r\n  top: .5em;\r\n  left: .5em;\r\n  bottom: .5em;\r\n  max-width: 35%;\r\n  border-radius: .5em;\r\n  position: absolute;\r\n  height: auto;\r\n  background-color: rgba(255,255,255,.5);\r\n}\r\n.ol-storymap {\r\n  overflow: hidden;\r\n  padding: 0;\r\n  height: 100%;\r\n  position: relative;\r\n}\r\n.ol-storymap > div {\r\n  overflow: hidden;\r\n  padding: 0;\r\n  height: 100%;\r\n  position: relative;\r\n  scroll-behavior: smooth;\r\n  -webkit-user-select: none;\r\n     -moz-user-select: none;\r\n      -ms-user-select: none;\r\n          user-select: none;\r\n}\r\n.ol-storymap >div.ol-move {\r\n  scroll-behavior: unset;\r\n}\r\n\r\n.ol-control.ol-storymap .chapter {\r\n  position: relative;\r\n  padding: .5em;\r\n  overflow: hidden;\r\n}\r\n.ol-control.ol-storymap .chapter:last-child {\r\n  margin-bottom: 100%;\r\n}\r\n.ol-storymap .chapter {\r\n  cursor: pointer;\r\n  opacity: .4;\r\n}\r\n.ol-storymap .chapter.ol-select {\r\n  cursor: default;\r\n  opacity: 1;\r\n  background-color: rgba(255,255,255,.8);\r\n}\r\n\r\n.ol-storymap .ol-scroll-top,\r\n.ol-storymap .ol-scroll-next {\r\n  position: relative;\r\n  min-height: 1.7em;\r\n  color: rgba(0,60,136,.5);\r\n  text-align: center;\r\n  cursor: pointer;\r\n}\r\n.ol-storymap .ol-scroll-next span {\r\n  padding-bottom: 1.4em;\r\n  display: block;\r\n}\r\n.ol-storymap .ol-scroll-top span {\r\n  padding-top: 1.4em;\r\n  display: block;\r\n}\r\n\r\n.ol-storymap .ol-scroll-top:before,\r\n.ol-storymap .ol-scroll-next:before {\r\n  content: \"\";\r\n  border: .3em solid currentColor;\r\n  border-radius: .3em;\r\n  border-color: transparent currentColor currentColor transparent;\r\n  width: .8em;\r\n  height: .8em;\r\n  display: block;\r\n  position: absolute;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%) rotate(45deg);\r\n          transform: translateX(-50%) rotate(45deg);\r\n  -webkit-animation: ol-bounce-bottom 0.35s linear infinite alternate;\r\n          animation: ol-bounce-bottom 0.35s linear infinite alternate;\r\n  pointer-events: none;\r\n}\r\n.ol-storymap .ol-scroll-top:before {\r\n  border-color: currentColor transparent transparent currentColor;\r\n  -webkit-animation: ol-bounce-top 0.35s linear infinite alternate;\r\n          animation: ol-bounce-top 0.35s linear infinite alternate;\r\n}\r\n\r\n@-webkit-keyframes ol-bounce-top{\r\n  from {top: -.2em;}\r\n  to   {top: .5em;}\r\n}\r\n\r\n@keyframes ol-bounce-top{\r\n  from {top: -.2em;}\r\n  to   {top: .5em;}\r\n}\r\n@-webkit-keyframes ol-bounce-bottom{\r\n  from {bottom: -.2em;}\r\n  to   {bottom: .5em;}\r\n}\r\n@keyframes ol-bounce-bottom{\r\n  from {bottom: -.2em;}\r\n  to   {bottom: .5em;}\r\n}\r\n\r\n.ol-storymap img[data-title] {\r\n  cursor: pointer;\r\n}\r\n\r\n/* scrollLine / scrollbox */\r\n.ol-storymap.scrollLine,\r\n.ol-storymap.scrollBox {\r\n  top: 0;\r\n  bottom: 0;\r\n  background-color: transparent;\r\n  border-radius: 0;\r\n  max-width: 40%;\r\n}\r\n.ol-storymap.scrollLine .chapter,\r\n.ol-storymap.scrollBox .chapter {\r\n  background-color: #fff;\r\n  margin: 100% 0;\r\n}\r\n.ol-storymap.scrollLine .chapter:first-child,\r\n.ol-storymap.scrollBox .chapter:first-child {\r\n  margin-top: 3em;\r\n}\r\n.ol-storymap.scrollLine .chapter.ol-select,\r\n.ol-storymap.scrollLine .chapter,\r\n.ol-storymap.scrollBox .chapter.ol-select,\r\n.ol-storymap.scrollBox .chapter {\r\n  opacity: 1;\r\n}\r\n\r\n.ol-storymap.scrollLine .ol-scrolldiv,\r\n.ol-storymap.scrollBox .ol-scrolldiv {\r\n  padding-right: 30px;\r\n}\r\n.ol-storymap.scrollLine:before,\r\n.ol-storymap.scrollBox:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 2px;\r\n  height: 100%;\r\n  top: 0;\r\n  bottom: 0;\r\n  right: 14px;\r\n  background-color: #fff;\r\n}\r\n\r\n.ol-storymap.scrollLine .ol-scroll,\r\n.ol-storymap.scrollBox .ol-scroll {\r\n  display: block!important;\r\n  padding: 0;\r\n  width: 1px;\r\n  opacity: 1!important;\r\n  right: 15px;\r\n  overflow: visible;\r\n  -webkit-transition: none;\r\n  transition: none;\r\n}\r\n.ol-storymap.scrollLine .ol-scroll > div {\r\n  background-color: transparent;\r\n  overflow: visible;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  -webkit-box-shadow: unset;\r\n          box-shadow: unset;\r\n}\r\n.ol-storymap.scrollLine .ol-scroll > div:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 10px;\r\n  height: 10px;\r\n  border-radius: 50%;\r\n  background-color: #0af;\r\n  border: 2px solid #fff;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n\r\n.ol-storymap.scrollBox .ol-scroll > div {\r\n  display: none;\r\n}\r\n.ol-storymap.scrollBox .chapter:after {\r\n  content: \"\";\r\n  width: 20px;\r\n  height: 20px;\r\n  position: absolute;\r\n  top: Min(30%, 5em);\r\n  right: -24.5px;\r\n  -webkit-box-shadow: 0 0 0 2px #fff, inset 0 0 0 15px #0af;\r\n          box-shadow: 0 0 0 2px #fff, inset 0 0 0 15px #0af; \r\n  border-radius: 50%;\r\n  border: 5px solid transparent;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  z-index: 1;\r\n}\r\n\r\n.ol-swipe {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  -ms-touch-action: none;\r\n      touch-action: none;\r\n}\r\n\r\n.ol-swipe:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  top: -5000px;\r\n  bottom: -5000px;\r\n  left: 50%;\r\n  width: 4px;\r\n  background: #fff;\r\n  z-index:-1;\r\n  -webkit-transform: translate(-2px, 0);\r\n          transform: translate(-2px, 0);\r\n}\r\n.ol-swipe.horizontal:before {\r\n  left: -5000px;\r\n  right: -5000px;\r\n  top: 50%;\r\n  bottom: auto;\r\n  width: auto;\r\n  height: 4px;\r\n}\r\n\r\n.ol-swipe,\r\n.ol-swipe button {\r\n  cursor: ew-resize;\r\n}\r\n.ol-swipe.horizontal,\r\n.ol-swipe.horizontal button {\r\n  cursor: ns-resize;\r\n}\r\n\r\n.ol-swipe:after,\r\n.ol-swipe button:before,\r\n.ol-swipe button:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  top: 25%;\r\n  bottom: 25%;\r\n  left: 50%;\r\n  width: 2px;\r\n  background: currentColor;\r\n  transform: translate(-1px, 0);\r\n  -webkit-transform: translate(-1px, 0);\r\n}\r\n.ol-swipe button:after {\r\n  -webkit-transform: translateX(4px);\r\n          transform: translateX(4px);\r\n}\r\n.ol-swipe button:before {\r\n  -webkit-transform: translateX(-6px);\r\n          transform: translateX(-6px);\r\n}\r\n\r\n.ol-control.ol-timeline {\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  -webkit-transition: .3s;\r\n  transition: .3s;\r\n  background-color: rgba(255,255,255,.4);\r\n}\r\n.ol-control.ol-timeline.ol-collapsed {\r\n  -webkit-transform: translateY(100%);\r\n          transform: translateY(100%);\r\n}\r\n.ol-timeline {\r\n  overflow: hidden;\r\n  padding: 2px 0 0;\r\n}\r\n.ol-timeline .ol-scroll {\r\n  overflow: hidden;\r\n  padding: 0;\r\n  scroll-behavior: smooth;\r\n  line-height: 1em;\r\n  height: 6em;\r\n  padding: 0 50%;\r\n}\r\n.ol-timeline .ol-scroll.ol-move {\r\n  scroll-behavior: unset;\r\n}\r\n\r\n.ol-timeline.ol-hasbutton .ol-scroll {\r\n  margin-left: 1.5em;\r\n  padding: 0 calc(50% - .75em);\r\n}\r\n.ol-timeline .ol-buttons {\r\n  display: none;\r\n  position: absolute;\r\n  top: 0;\r\n  background: rgba(255,255,255,.5);\r\n  width: 1.5em;\r\n  bottom: 0;\r\n  left: 0;\r\n  z-index: 10;\r\n}\r\n.ol-timeline.ol-hasbutton .ol-buttons {\r\n  display: block;\r\n}\r\n.ol-timeline .ol-buttons button {\r\n  font-size: 1em;\r\n  margin: 1px;\r\n  position: relative;\r\n}\r\n.ol-timeline .ol-buttons .ol-zoom-in:before,\r\n.ol-timeline .ol-buttons .ol-zoom-out:before {\r\n  content: \"+\";\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-timeline .ol-buttons .ol-zoom-out:before{\r\n  content: '−';\r\n}\r\n\r\n.ol-timeline .ol-scroll > div {\r\n  height: 100%;\r\n  position: relative;\r\n}\r\n\r\n.ol-timeline .ol-scroll .ol-times {\r\n  background: rgba(255,255,255,.5);\r\n  height: 1em;\r\n  bottom: 0;\r\n  position: absolute;\r\n  left: -1000px;\r\n  right: -1000px;\r\n}\r\n.ol-timeline .ol-scroll .ol-time {\r\n  position: absolute;\r\n  font-size: .7em;\r\n  color: #999;\r\n  bottom: 0;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n.ol-timeline .ol-scroll .ol-time.ol-year {\r\n  color: #666;\r\n  z-index: 1;\r\n}\r\n.ol-timeline .ol-scroll .ol-time:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  bottom: 1.2em;\r\n  left: 50%;\r\n  height: 500px;\r\n  border-left: 1px solid currentColor;\r\n}\r\n\r\n.ol-timeline .ol-scroll .ol-features {\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 1em;\r\n  left: -200px;\r\n  right: -1000px;\r\n  margin: 0 0 0 200px;\r\n  overflow: hidden;\r\n}\r\n\r\n.ol-timeline .ol-scroll .ol-feature {\r\n  position: absolute;\r\n  font-size: .7em;\r\n  color: #999;\r\n  top: 0;\r\n  background: #fff;\r\n  max-width: 3em;\r\n  max-height: 2.4em;\r\n  min-height: 1em;\r\n  line-height: 1.2em;\r\n  border: 1px solid #ccc;\r\n  overflow: hidden;\r\n  padding: 0 .5em 0 0;\r\n  -webkit-transition: all .3s;\r\n  transition: all .3s;\r\n  cursor: pointer;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n\r\n.ol-timeline.ol-zoomhover .ol-scroll .ol-feature:hover,\r\n.ol-timeline.ol-zoomhover .ol-scroll .ol-feature.ol-select {\r\n  z-index: 1;\r\n  -webkit-transform: scale(1.2);\r\n          transform: scale(1.2);\r\n  background: #eee;\r\n  /* max-width: 14em!important; */\r\n}\r\n\r\n/* Center */\r\n.ol-timeline .ol-center-date {\r\n  display: none;\r\n  position: absolute;\r\n  left: 50%;\r\n  height: 100%;\r\n  width: 2px;\r\n  bottom: 0;\r\n  z-index: 2;\r\n  pointer-events: none;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  background-color: #f00;\r\n  opacity: .4;\r\n}\r\n.ol-timeline.ol-hasbutton .ol-center-date {\r\n  left: calc(50% + .75em);\r\n}\r\n\r\n/* Show center */ \r\n.ol-timeline.ol-pointer .ol-center-date {\r\n  display: block;\r\n}\r\n.ol-timeline.ol-pointer .ol-center-date:before, \r\n.ol-timeline.ol-pointer .ol-center-date:after {\r\n  content: '';\r\n  border: 0.3em solid transparent;\r\n  border-width: .3em .25em;\r\n  position: absolute;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n.ol-timeline.ol-pointer .ol-center-date:before {\r\n  border-top-color: #f00;\r\n  top: 0;\r\n}\r\n.ol-timeline.ol-pointer .ol-center-date:after {\r\n  border-bottom-color: #f00;\r\n  bottom: 0\r\n}\r\n\r\n/* show interval */\r\n.ol-timeline.ol-interval .ol-center-date {\r\n  display: block;\r\n  background-color: transparent;\r\n  border: 0 solid #000;\r\n  border-width: 0 10000px;\r\n  -webkit-box-sizing: content-box;\r\n          box-sizing: content-box;\r\n  opacity: .2;\r\n}\r\n.ol-control.ol-videorec {\r\n  top: 0;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n  white-space: nowrap;\r\n}\r\n\r\n.ol-control.ol-videorec button {\r\n  position: relative;\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\n.ol-control.ol-videorec button:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  width: .8em;\r\n  height: .8em;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  background-color: currentColor;\r\n}\r\n.ol-control.ol-videorec button.ol-start:before {\r\n  width: .9em;\r\n  height: .9em;\r\n  border-radius: 50%;\r\n  background-color: #c00;\r\n}\r\n.ol-control.ol-videorec button.ol-pause:before {\r\n  width: .2em;\r\n  background-color: transparent;\r\n  -webkit-box-shadow: -.2em 0, .2em 0;\r\n          box-shadow: -.2em 0, .2em 0;\r\n}\r\n.ol-control.ol-videorec button.ol-resume:before {\r\n  border-style: solid;\r\n  background: transparent;\r\n  width: auto;\r\n  border-width: .4em 0 .4em .6em;\r\n  border-color: transparent transparent transparent currentColor;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n\r\n.ol-control.ol-videorec button.ol-stop,\r\n.ol-control.ol-videorec button.ol-pause,\r\n.ol-control.ol-videorec button.ol-resume,\r\n.ol-control.ol-videorec[data-state=\"rec\"] .ol-start,\r\n.ol-control.ol-videorec[data-state=\"pause\"] .ol-start {\r\n  display: none;\r\n}\r\n.ol-control.ol-videorec[data-state=\"rec\"] .ol-stop,\r\n.ol-control.ol-videorec[data-state=\"pause\"] .ol-stop,\r\n.ol-control.ol-videorec[data-state=\"rec\"] .ol-pause,\r\n.ol-control.ol-videorec[data-state=\"pause\"] .ol-resume {\r\n  display: inline-block;\r\n}\r\n\r\n.ol-control.ol-wmscapabilities {\r\n  top: .5em;\r\n  right: 2.5em;\r\n}\r\n.ol-touch .ol-control.ol-wmscapabilities {\r\n  right: 3em;\r\n}\r\n.ol-control.ol-wmscapabilities.ol-hidden {\r\n  display: none;\r\n}\r\n.ol-control.ol-wmscapabilities button:before {\r\n  content: \"+\";\r\n  position: absolute;\r\n  top: calc(50% - .35em);\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-control.ol-wmscapabilities button:after {\r\n  content: \"\";\r\n  width: .75em;\r\n  height: .75em;\r\n  position: absolute;\r\n  background: transparent;\r\n  top: calc(50% - .05em);\r\n  left: 50%;\r\n  -webkit-transform: scaleY(.6) translate(-50%, -50%) rotate(45deg);\r\n          transform: scaleY(.6) translate(-50%, -50%) rotate(45deg);\r\n  -webkit-box-shadow: inset -.18em -.18em currentColor, -.4em .1em 0 -.25em currentColor, .1em -.35em 0 -.25em currentColor, .15em .15em currentColor;\r\n          box-shadow: inset -.18em -.18em currentColor, -.4em .1em 0 -.25em currentColor, .1em -.35em 0 -.25em currentColor, .15em .15em currentColor;\r\n  border-radius: .1em 0;\r\n  border: .15em solid transparent;\r\n  border-width: 0 .15em .15em 0;\r\n}\r\n\r\n.ol-wmscapabilities .ol-searching {\r\n  opacity: .5;\r\n}\r\n.ol-wmscapabilities .ol-searching .ol-url:after{\r\n  content: \"\";\r\n  width: .7em;\r\n  height: .7em;\r\n  background-color: currentColor;\r\n  position: absolute;\r\n  top: 6em;\r\n  border-radius: 50%;\r\n  display: block;\r\n  left: calc(50% - .35em);\r\n  -webkit-box-shadow: 0 1em currentColor, 0 -1em currentColor, 1em 0 currentColor, -1em 0 currentColor;\r\n          box-shadow: 0 1em currentColor, 0 -1em currentColor, 1em 0 currentColor, -1em 0 currentColor;\r\n  -webkit-animation:ol-wmscapabilities-rotate 2s linear infinite;\r\n          animation:ol-wmscapabilities-rotate 2s linear infinite;\r\n}\r\n@-webkit-keyframes ol-wmscapabilities-rotate { \r\n  100% { -webkit-transform:rotate(360deg); transform:rotate(360deg); } \r\n}\r\n@keyframes ol-wmscapabilities-rotate { \r\n  100% { -webkit-transform:rotate(360deg); transform:rotate(360deg); } \r\n}\r\n\r\n.ol-wmscapabilities .ol-url input {\r\n  width: calc(100% - 10em);\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  min-width: Min(100%, 20em);\r\n}\r\n.ol-wmscapabilities .ol-url select {\r\n  width: 2em;\r\n  height: 100%;\r\n  padding: 1px;\r\n}\r\n.ol-wmscapabilities .ol-url button {\r\n  width: 7.5em;\r\n  margin-left: .5em;\r\n}\r\n.ol-wmscapabilities .ol-result {\r\n  display: none;\r\n  margin-top: .5em;\r\n}\r\n.ol-wmscapabilities .ol-result.ol-visible {\r\n  display: block;\r\n}\r\n\r\n.ol-wmscapabilities .ol-select-list {\r\n  position: relative;\r\n  border: 1px solid #369;\r\n  overflow-x: hidden;\r\n  width: calc(100% - 120px);\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  max-height: 14.5em;\r\n}\r\n.ol-wmscapabilities .ol-select-list div {\r\n  padding: 0 .5em;\r\n  cursor: pointer;\r\n  width: 100%;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  text-overflow: ellipsis;\r\n  overflow: hidden;\r\n}\r\n.ol-wmscapabilities .ol-select-list .level-1 {\r\n  padding-left: 1em;\r\n}\r\n.ol-wmscapabilities .ol-select-list .level-2 {\r\n  padding-left: 1.5em;\r\n}\r\n.ol-wmscapabilities .ol-select-list .level-3 {\r\n  padding-left: 2em;\r\n}\r\n.ol-wmscapabilities .ol-select-list .level-4 {\r\n  padding-left: 2.5em;\r\n}\r\n.ol-wmscapabilities .ol-select-list .level-5 {\r\n  padding-left: 3em;\r\n}\r\n\r\n.ol-wmscapabilities .ol-select-list .ol-info {\r\n  font-style: italic;\r\n}\r\n.ol-wmscapabilities .ol-select-list .ol-title {\r\n  background-color: rgba(0,60,136,.1);\r\n}\r\n.ol-wmscapabilities .ol-select-list div:hover {\r\n  background-color: rgba(0,60,136,.5);\r\n  color: #fff;\r\n}\r\n.ol-wmscapabilities .ol-select-list div.selected {\r\n  background-color: rgba(0,60,136,.7);\r\n  color: #fff;\r\n}\r\n\r\n.ol-wmscapabilities .ol-preview {\r\n  width: 100px;\r\n  float: right;\r\n  background: rgba(0,60,136,.1);\r\n  color: #666;\r\n  padding: 0 5px 5px;\r\n  text-align: center;\r\n  margin-left: 10px;\r\n}\r\n.ol-wmscapabilities .ol-preview.tainted {\r\n  width: 100px;\r\n  float: right;\r\n  background: rgba(136,0,60,.1);\r\n  color: #666;\r\n  padding: 0 5px 5px;\r\n  text-align: center;\r\n  margin-left: 10px;\r\n}\r\n.ol-wmscapabilities .ol-preview img {\r\n  width: 100%;\r\n  display: block;\r\n  background: #fff;\r\n}\r\n.ol-wmscapabilities .ol-legend {\r\n  max-width: 100%;\r\n  display: none;\r\n}\r\n.ol-wmscapabilities .ol-legend.visible {\r\n  display: block;\r\n}\r\n.ol-wmscapabilities .ol-buttons {\r\n  clear: both;\r\n  text-align: right;\r\n}\r\n.ol-wmscapabilities .ol-data p {\r\n  margin: 0;\r\n}\r\n.ol-wmscapabilities .ol-data p.ol-title {\r\n  font-weight: bold;\r\n  margin: 1em 0 .5em;\r\n}\r\n.ol-wmscapabilities .ol-error {\r\n  color: #800;\r\n}\r\n\r\n.ol-wmscapabilities ul.ol-wmsform {\r\n  display: none;\r\n  list-style: none;\r\n  padding: 0;\r\n}\r\n.ol-wmscapabilities ul.ol-wmsform.visible {\r\n  display: block;\r\n}\r\n.ol-wmscapabilities .ol-wmsform label {\r\n  display: inline-block;\r\n  text-align: right;\r\n  width: calc(40% - .5em);\r\n  margin-right: .5em;\r\n}\r\n.ol-wmscapabilities .ol-wmsform input {\r\n  display: inline-block;\r\n  width: 60%;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-wmscapabilities .ol-wmsform input[type=\"checkbox\"] {\r\n  width: auto;\r\n}\r\n.ol-wmscapabilities .ol-wmsform button {\r\n  float: right;\r\n  margin: 1em 0;\r\n}\r\n\r\n.ol-wmscapabilities ul.ol-wmsform li[data-param=\"extent\"] input {\r\n  width: calc(60% - 2em);\r\n}\r\n.ol-wmscapabilities ul.ol-wmsform li[data-param=\"extent\"] button {\r\n  position: relative;\r\n  width: 2em;\r\n  height: 1.6em;\r\n  margin: 0;\r\n  vertical-align: middle;\r\n  color: #444;\r\n}\r\n.ol-wmscapabilities ul.ol-wmsform li[data-param=\"extent\"] button:before,\r\n.ol-wmscapabilities ul.ol-wmsform li[data-param=\"extent\"] button:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: .25em;\r\n  height: .9em;\r\n  border: .1em solid currentColor;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) skewY(-15deg);\r\n          transform: translate(-50%, -50%) skewY(-15deg);\r\n}\r\n.ol-wmscapabilities ul.ol-wmsform li[data-param=\"extent\"] button:after {\r\n  -webkit-transform: translateX(.4em) translate(-50%, -50%) skewY(15deg);\r\n          transform: translateX(.4em) translate(-50%, -50%) skewY(15deg);\r\n  -webkit-box-shadow: -0.8em 0.25em;\r\n          box-shadow: -0.8em 0.25em;\r\n}\r\n\r\n.ol-ext-dialog.ol-wmscapabilities form {\r\n  width: 600px;\r\n  min-height: 15em;\r\n  top: 15%;\r\n  -webkit-transform: translate(-50%, -15%);\r\n          transform: translate(-50%, -15%);\r\n}\r\n.ol-ext-dialog.ol-wmscapabilities .ol-content {\r\n  max-height: calc(100vh - 6em);\r\n}\r\n\r\n.ol-ext-dialog.ol-wmtscapabilities [data-param=\"map\"] {\r\n  display: none;\r\n}\r\n.ol-ext-dialog [data-param=\"style\"] {\r\n  display: none;\r\n}\r\n.ol-ext-dialog.ol-wmtscapabilities [data-param=\"style\"] {\r\n  display: list-item;\r\n}\r\n.ol-ext-dialog.ol-wmtscapabilities [data-param=\"proj\"],\r\n.ol-ext-dialog.ol-wmtscapabilities [data-param=\"version\"] {\r\n  opacity: .6;\r\n  pointer-events: none;\r\n}\r\n\r\n.ol-ext-dialog.ol-wmscapabilities button.ol-wmsform {\r\n  width: 1.8em;\r\n  text-align: center;\r\n}\r\n.ol-ext-dialog.ol-wmscapabilities button.ol-wmsform:before {\r\n  content: \"+\";\r\n}\r\n.ol-ext-dialog.ol-wmscapabilities .ol-form button.ol-wmsform:before {\r\n  content: \"-\";\r\n}\r\n\r\n.ol-ext-dialog.ol-wmscapabilities .ol-form button.ol-load,\r\n.ol-ext-dialog.ol-wmscapabilities .ol-form .ol-legend {\r\n  display: none;\r\n}\r\n.ol-ext-dialog.ol-wmscapabilities .ol-form ul.ol-wmsform {\r\n  display: block;\r\n  clear: both;\r\n}\r\n.ol-target-overlay .ol-target \r\n{\tborder: 1px solid transparent;\r\n\t-webkit-box-shadow: 0 0 1px 1px #fff;\r\n\t        box-shadow: 0 0 1px 1px #fff;\r\n\tdisplay: block;\r\n\theight: 20px;\r\n\twidth: 0;\r\n}\r\n\r\n.ol-target-overlay .ol-target:after,\r\n.ol-target-overlay .ol-target:before\r\n{\tcontent:\"\";\r\n\tborder: 1px solid #369;\r\n\t-webkit-box-shadow: 0 0 1px 1px #fff;\r\n\t        box-shadow: 0 0 1px 1px #fff;\r\n\tdisplay: block;\r\n\twidth: 20px;\r\n\theight: 0;\r\n\tposition:absolute;\r\n\ttop:10px;\r\n\tleft:-10px;\r\n}\r\n.ol-target-overlay .ol-target:after\r\n{\t-webkit-box-shadow: none;\tbox-shadow: none;\r\n\theight: 20px;\r\n\twidth: 0;\r\n\ttop:0px;\r\n\tleft:0px;\r\n}\r\n\r\n.ol-overlaycontainer .ol-touch-cursor {\r\n  /* human fingertips are typically 16x20 mm = 45x57 pixels\r\n    source: http://touchlab.mit.edu/publications/2003_009.pdf\r\n  */\r\n  width: 56px;\r\n  height: 56px;\r\n  margin: 6px;\r\n  border-radius: 50%;\r\n  cursor: pointer;\r\n  background: rgba(255,255,255,.4);\r\n  -webkit-box-shadow: inset 0 0 0 5px #369;\r\n          box-shadow: inset 0 0 0 5px #369;\r\n}\r\n\r\n.ol-overlaycontainer .ol-touch-cursor:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 50%;\r\n  height: 50%;\r\n  background: radial-gradient(circle at 100% 100%, transparent, transparent 70%, #369 70%, #369)\r\n}\r\n\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button {\r\n  position: absolute;\r\n  color: #369;\r\n  height: 55%;\r\n  width: 55%;\r\n  border-radius: 50%;\r\n  cursor: pointer;\r\n  background: rgba(255,255,255,.4);\r\n  -webkit-box-shadow: inset 0 0 0 3px currentColor;\r\n          box-shadow: inset 0 0 0 3px currentColor;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) scale(0);\r\n          transform: translate(-50%, -50%) scale(0);\r\n  -webkit-transition: all .5s, opacity 0s, background 0s;\r\n  transition: all .5s, opacity 0s, background 0s;\r\n  overflow: hidden;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active.disable .ol-button {\r\n  opacity: .8;\r\n  background: rgba(51, 102, 153, .2);\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button {\r\n  -webkit-transform: translate(-50%, -50%) scale(1);\r\n          transform: translate(-50%, -50%) scale(1);\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button-0 {\r\n  top: -18%;\r\n  left: 118%;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button-1 {\r\n  top: 50%;\r\n  left: 140%;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button-2 {\r\n  top: 120%;\r\n  left: 120%;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button-3 {\r\n  top: 140%;\r\n  left: 50%;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button-4 {\r\n  top: 118%;\r\n  left: -18%;\r\n}\r\n/* extra buttons */\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button-5 {\r\n  top: 50%;\r\n  left: -40%;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button-6 {\r\n  top: -18%;\r\n  left: -18%;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor.active .ol-button-7 {\r\n  top: -40%;\r\n  left: 50%;\r\n}\r\n\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button:before {\r\n  content: \"\";\r\n  width: 1.5em;\r\n  height: 1em;\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  line-height: 1em;\r\n  text-align: center;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-add:before,\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-remove:before {\r\n  content: \"−\";\r\n  line-height: .95em;\r\n  font-size: 1.375em;\r\n  font-weight: bold;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-add:before {\r\n  content: \"+\";\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-x:before {\r\n  content: \"\\00D7\";\r\n  font-size: 1.2em;\r\n  font-weight: bold;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-move:before {\r\n  content: \"\\2725\";\r\n  font-size: 1.2em;\r\n}\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button.ol-button-check:before {\r\n  content: \"\\2713\";\r\n  font-weight: bold;\r\n}\r\n\r\n.ol-overlaycontainer .ol-touch-cursor.nodrawing .ol-button.ol-button-x,\r\n.ol-overlaycontainer .ol-touch-cursor.nodrawing .ol-button.ol-button-remove,\r\n.ol-overlaycontainer .ol-touch-cursor.nodrawing .ol-button.ol-button-check {\r\n  opacity: .8;\r\n  background: rgba(51, 102, 153, .2);\r\n}\r\n\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button > div {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n\r\n.ol-overlaycontainer .ol-touch-cursor .ol-button-type:before {\r\n  content: \"\\21CE\";\r\n  font-weight: bold;\r\n}\r\n\r\n\r\n\r\n/* remove outline on focus */\r\n.mapboxgl-canvas:focus {\r\n  outline: none;\r\n}\r\n.ol-perspective-map {\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  width: 200%;\r\n  height: 200%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-perspective-map .ol-layer {\r\n  z-index: -1!important; /* bug using Chrome ? */\r\n}\r\n.ol-perspective-map .ol-layers {\r\n  -webkit-transform: translateY(0) perspective(200px) rotateX(0deg) scaleY(1);\r\n          transform: translateY(0) perspective(200px) rotateX(0deg) scaleY(1);\r\n}\r\n\r\n.ol-perspective-map .ol-overlaycontainer,\r\n.ol-perspective-map .ol-overlaycontainer-stopevent {\r\n  width: 50%!important;\r\n  height: 50%!important;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n\r\n.ol-overlay-container .ol-magnify \r\n{\tbackground: rgba(0,0,0, 0.5);\r\n\tborder:3px solid #369;\r\n\tborder-radius: 50%;\r\n\theight: 150px;\r\n\twidth: 150px;\r\n\toverflow: hidden;\r\n\t-webkit-box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5);\r\n\t        box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5);\r\n\tposition:relative;\r\n\tz-index:0;\r\n}\r\n\r\n.ol-overlay-container .ol-magnify:before \r\n{\tborder-radius: 50%;\r\n\t-webkit-box-shadow: 0 0 40px 2px rgba(0, 0, 0, 0.25) inset;\r\n\t        box-shadow: 0 0 40px 2px rgba(0, 0, 0, 0.25) inset;\r\n\tcontent: \"\";\r\n\tdisplay: block;\r\n\theight: 100%;\r\n\tleft: 0;\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\twidth: 100%;\r\n\tz-index: 1;\r\n}\r\n\r\n.ol-overlay-container .ol-magnify:after \r\n{\r\n\tborder-radius: 50%;\r\n\t-webkit-box-shadow: 0 0 20px 7px rgba(255, 255, 255, 1);\r\n\t        box-shadow: 0 0 20px 7px rgba(255, 255, 255, 1);\r\n\tcontent: \"\";\r\n\tdisplay: block;\r\n\theight: 0;\r\n\tleft: 23%;\r\n\tposition: absolute;\r\n\ttop: 20%;\r\n\twidth: 20%;\r\n\tz-index: 1;\r\n\ttransform: rotate(-40deg);\r\n\t-webkit-transform: rotate(-40deg);\r\n}\r\n/** popup animation using visible class\r\n*/\r\n.ol-popup.anim {\r\n  visibility: hidden;\r\n}\r\n\r\n.ol-popup.anim.visible {\r\n  visibility: visible;\r\n}\r\n/** No transform when visible \r\n*/\r\n.ol-popup.anim.visible > div {\r\n  visibility: visible;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n  -webkit-animation: ol-popup_bounce 0.4s ease 1;\r\n          animation: ol-popup_bounce 0.4s ease 1;\r\n}\r\n\r\n@-webkit-keyframes ol-popup_bounce {\r\n  from { -webkit-transform: scale(0); transform: scale(0); }\r\n  50%  { -webkit-transform: scale(1.1); transform: scale(1.1) }\r\n  80%  { -webkit-transform: scale(0.95); transform: scale(0.95) }\r\n  to   { -webkit-transform: scale(1); transform: scale(1); }\r\n}\r\n\r\n@keyframes ol-popup_bounce {\r\n  from { -webkit-transform: scale(0); transform: scale(0); }\r\n  50%  { -webkit-transform: scale(1.1); transform: scale(1.1) }\r\n  80%  { -webkit-transform: scale(0.95); transform: scale(0.95) }\r\n  to   { -webkit-transform: scale(1); transform: scale(1); }\r\n}\r\n\r\n/** Transform Origin */\r\n.ol-popup.anim.ol-popup-bottom.ol-popup-left > div  {\r\n  -webkit-transform-origin:0 100%;\r\n          transform-origin:0 100%;\r\n}\r\n.ol-popup.anim.ol-popup-bottom.ol-popup-right > div {\r\n  -webkit-transform-origin:100% 100%;\r\n          transform-origin:100% 100%;\r\n}\r\n.ol-popup.anim.ol-popup-bottom.ol-popup-center > div {\r\n  -webkit-transform-origin:50% 100%;\r\n          transform-origin:50% 100%;\r\n}\r\n.ol-popup.anim.ol-popup-top.ol-popup-left > div {\r\n  -webkit-transform-origin:0 0;\r\n          transform-origin:0 0;\r\n}\r\n.ol-popup.anim.ol-popup-top.ol-popup-right > div {\r\n  -webkit-transform-origin:100% 0;\r\n          transform-origin:100% 0;\r\n}\r\n.ol-popup.anim.ol-popup-top.ol-popup-center > div {\r\n  -webkit-transform-origin:50% 0;\r\n          transform-origin:50% 0;\r\n}\r\n.ol-popup.anim.ol-popup-middle.ol-popup-left > div {\r\n  -webkit-transform-origin:0 50%;\r\n          transform-origin:0 50%;\r\n}\r\n.ol-popup.anim.ol-popup-middle.ol-popup-right > div {\r\n  -webkit-transform-origin:100% 50%;\r\n          transform-origin:100% 50%;\r\n}\r\n\r\n.ol-overlaycontainer-stopevent {\r\n  /* BOUG ol6.1 to enable DragOverlay interaction \r\n  position: initial!important;\r\n  */\r\n}\r\n\r\n/** ol.popup */\r\n.ol-popup {\r\n  font-size:0.9em;\r\n  -webkit-user-select: none;  \r\n  -moz-user-select: none;    \r\n  -ms-user-select: none;      \r\n  user-select: none;\r\n}\r\n.ol-popup .ol-popup-content {\r\n  overflow:hidden;\r\n  cursor: default;\r\n  padding: 0.25em 0.5em;\r\n}\r\n.ol-popup.hasclosebox .ol-popup-content {\r\n  margin-right: 1.7em;\r\n}\r\n.ol-popup .ol-popup-content:after {\r\n  clear: both;\r\n  content: \"\";\r\n  display: block;\r\n  font-size: 0;\r\n  height: 0;\r\n}\r\n\r\n/** Anchor position */\r\n.ol-popup .anchor {\r\n  display: block;\r\n  width: 0px;\r\n  height: 0px;\r\n  background:red;\r\n  position: absolute;\r\n  margin: -11px 22px;\r\n  pointer-events: none;\r\n}\r\n.ol-popup .anchor:after,\r\n.ol-popup .anchor:before {\r\n  position:absolute;\r\n}\r\n.ol-popup-right .anchor:after,\r\n.ol-popup-right .anchor:before {\r\n  right:0;\r\n}\r\n.ol-popup-top .anchor { top:0; }\r\n.ol-popup-bottom .anchor { bottom:0; }\r\n.ol-popup-right .anchor { right:0; }\r\n.ol-popup-left .anchor { left:0; }\r\n.ol-popup-center .anchor { \r\n  left:50%; \r\n  margin-left: 0!important;\r\n}\r\n.ol-popup-middle .anchor { \r\n  top:50%; \r\n  margin-top: 0!important;\r\n}\r\n.ol-popup-center.ol-popup-middle .anchor { \r\n  display:none; \r\n}\r\n\r\n/** Fixed popup */\r\n.ol-popup.ol-fixed {\r\n  margin: 0!important;\r\n  top: .5em!important;\r\n  right: .5em!important;\r\n  left: auto!important;\r\n  bottom: auto!important;\r\n  -webkit-transform: none!important;\r\n          transform: none!important;\r\n}\r\n.ol-popup.ol-fixed .anchor {\r\n  display: none;\r\n}\r\n.ol-popup.ol-fixed.anim > div {\r\n  -webkit-animation: none;\r\n          animation: none;\r\n}\r\n\r\n.ol-popup .ol-fix {\r\n  width: 1em;\r\n  height: .9em;\r\n  background: #fff;\r\n  position: relative;\r\n  float: right;\r\n  margin: .2em;\r\n  cursor: pointer;\r\n}\r\n.ol-popup .ol-fix:before {\r\n  content: \"\";\r\n  width: .8em;\r\n  height: .7em;\r\n  display: block;\r\n  border: .1em solid #666;\r\n      border-right-width: 0.1em;\r\n  border-right-width: .3em;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  margin: .1em;\r\n}\r\n\r\n/** Add a shadow to the popup */\r\n.ol-popup.shadow {\r\n  -webkit-box-shadow: 2px 2px 2px 2px rgba(0,0,0,0.5);\r\n          box-shadow: 2px 2px 2px 2px rgba(0,0,0,0.5);\r\n}\r\n\r\n/** Close box */\r\n.ol-popup .closeBox {\r\n  background-color: rgba(0, 60, 136, 0.5);\r\n  color: #fff;\r\n  border: 0;\r\n  border-radius: 2px;\r\n  cursor: pointer;\r\n  float: right;\r\n  font-size: 0.9em;\r\n  font-weight: 700;\r\n  width: 1.4em;\r\n  height: 1.4em;\r\n  margin: 5px 5px 0 0;\r\n  padding: 0;\r\n  position: relative;\r\n  display:none;\r\n}\r\n.ol-popup.hasclosebox .closeBox {\r\n  display:block;\r\n}\r\n\r\n.ol-popup .closeBox:hover {\r\n  background-color: rgba(0, 60, 136, 0.7);\r\n}\r\n/* the X */\r\n.ol-popup .closeBox:after {\r\n  content: \"\\00d7\";\r\n  font-size:1.5em;\r\n  top: 50%;\r\n  left: 0;\r\n  right: 0;\r\n  width: 100%;\r\n  text-align: center;\r\n  line-height: 1em;\r\n  margin: -0.5em 0;\r\n  position: absolute;\r\n}\r\n\r\n/** Modify touch poup */\r\n.ol-popup.modifytouch {\r\n  background-color: #eee;\r\n}\r\n.ol-popup.modifytouch .ol-popup-content {\t\r\n  padding: 0 0.25em;\r\n  font-size: 0.85em;\r\n  white-space: nowrap;\r\n}\r\n.ol-popup.modifytouch .ol-popup-content a {\r\n  text-decoration: none;\r\n}\r\n\r\n/** Tool tips popup*/\r\n.ol-popup.tooltips {\r\n  background-color: #ffa;\r\n}\r\n.ol-popup.tooltips .ol-popup-content{\r\n  padding: 0 0.25em;\r\n  font-size: 0.85em;\r\n  white-space: nowrap;\r\n}\r\n\r\n/** Default popup */\r\n.ol-popup.default > div {\r\n  background-color: #fff;\r\n  border:1px solid #69f;\r\n  border-radius: 5px;\r\n}\r\n.ol-popup.default {\r\n  margin: -11px 0;\r\n  -webkit-transform: translate(0, -22px);\r\n          transform: translate(0, -22px);\r\n}\r\n.ol-popup-top.ol-popup.default {\r\n  margin: 11px 0;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-left.default {\r\n  margin: -11px -22px;\r\n  -webkit-transform: translate(0, -22px);\r\n          transform: translate(0, -22px);\r\n}\r\n.ol-popup-top.ol-popup-left.default {\r\n  margin: 11px -22px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-right.default {\r\n  margin: -11px 22px;\r\n  -webkit-transform: translate(44px, -22px);\r\n          transform: translate(44px, -22px);\r\n}\r\n.ol-popup-top.ol-popup-right.default {\r\n  margin: 11px 22px;\r\n  -webkit-transform: translate(44px, 0);\r\n          transform: translate(44px, 0);\r\n}\r\n.ol-popup-middle.default {\r\n  margin:0 10px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-middle.ol-popup-right.default {\r\n  margin:0 -10px;\r\n  -webkit-transform: translate(-20px, 0);\r\n          transform: translate(-20px, 0);\r\n}\r\n\r\n.ol-popup.default .anchor {\r\n  color: #69f;\r\n}\r\n.ol-popup.default .anchor:after,\r\n.ol-popup.default .anchor:before {\r\n  content:\"\";\r\n  border-color: currentColor transparent;\r\n  border-style: solid;\r\n  border-width: 11px;\r\n  margin: 0 -11px;\r\n}\r\n.ol-popup.default .anchor:after {\r\n  border-color: #fff transparent;\r\n  border-width: 11px;\r\n  margin: 2px -11px;\r\n}\r\n\r\n.ol-popup-top.default .anchor:before,\r\n.ol-popup-top.default .anchor:after {\r\n  border-top:0;\r\n  top:0;\r\n}\r\n\r\n.ol-popup-bottom.default .anchor:before,\r\n.ol-popup-bottom.default .anchor:after {\r\n  border-bottom:0;\r\n  bottom:0;\r\n}\r\n\r\n.ol-popup-middle.default .anchor:before {\r\n  margin: -11px -33px;\r\n  border-color: transparent currentColor;\r\n}\r\n.ol-popup-middle.default .anchor:after {\r\n  margin: -11px -31px;\r\n  border-color: transparent #fff;\r\n}\r\n.ol-popup-middle.ol-popup-left.default .anchor:before,\r\n.ol-popup-middle.ol-popup-left.default .anchor:after {\r\n  border-left:0;\r\n}\r\n.ol-popup-middle.ol-popup-right.default .anchor:before,\r\n.ol-popup-middle.ol-popup-right.default .anchor:after {\r\n  border-right:0;\r\n}\r\n\r\n/** Placemark popup */\r\n.ol-popup.placemark {\r\n  color: #c00;\r\n  margin: -.65em 0;\r\n  -webkit-transform: translate(0, -1.3em);\r\n          transform: translate(0, -1.3em);\r\n}\r\n.ol-popup.placemark > div {\r\n  position: relative;\r\n  font-size: 15px;\t\r\n  background-color: #fff;\r\n  border: 0;\r\n  -webkit-box-shadow: inset 0 0 0 0.45em;\r\n          box-shadow: inset 0 0 0 0.45em;\r\n  width: 2em;\r\n  height: 2em;\r\n  border-radius: 50%;\r\n  min-width: unset;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-popup.placemark .ol-popup-content {\r\n  overflow: hidden;\r\n  cursor: default;\r\n  text-align: center;\r\n  padding: .25em 0;\r\n  width: 1em;\r\n  height: 1em;\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  line-height: 1em;\r\n}\r\n.ol-popup.placemark .anchor {\r\n  margin: 0;\r\n}\r\n\r\n.ol-popup.placemark .anchor:before {\r\n  content: \"\";\r\n  margin: -.5em -.5em;\r\n  background: transparent;\r\n  width: 1em;\r\n  height: .5em;\r\n  border-radius: 50%;\r\n  -webkit-box-shadow: 0 1em 0.5em rgba(0,0,0,.5);\r\n          box-shadow: 0 1em 0.5em rgba(0,0,0,.5);\r\n}\r\n.ol-popup.placemark .anchor:after {\r\n  content: \"\";\r\n  border-color: currentColor transparent;\r\n  border-style: solid;\r\n  border-width: 1em .7em 0;\r\n  margin: -.75em -.7em;\r\n  bottom:0;\r\n}\r\n\r\n/** Placemark Shield */\r\n.ol-popup.placemark.shield > div {\r\n  border-radius: .2em;\r\n}\r\n\r\n.ol-popup.placemark.shield .anchor:after {\r\n    border-width: .8em 1em 0;\r\n    margin: -.7em -1em;\r\n}\r\n\r\n/** Placemark Blazon */\r\n.ol-popup.placemark.blazon > div {\r\n  border-radius: .2em;\r\n}\r\n\r\n/** Placemark Needle/Pushpin */\r\n.ol-popup.placemark.pushpin {\t\r\n  margin: -2.2em 0;\r\n  -webkit-transform: translate(0, -4em);\r\n          transform: translate(0, -4em);\r\n}\r\n.ol-popup.placemark.pushpin > div {\t\r\n  border-radius: 0;\r\n  background: transparent!important;\r\n  -webkit-box-shadow: inset 2em 0 currentColor;\r\n          box-shadow: inset 2em 0 currentColor;\r\n  width: 1.1em;\r\n}\r\n.ol-popup.placemark.pushpin > div:before {\r\n  content: \"\";\r\n  width: 1.3em;\r\n  height: 1.5em;\r\n  border-style: solid;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%,-50%);\r\n          transform: translate(-50%,-50%);\r\n  border-color: currentColor transparent;\r\n  border-width: .3em .5em .5em;\r\n  pointer-events: none;\r\n}\r\n\r\n.ol-popup.placemark.needle {\t\r\n  margin: -2em 0;\r\n  -webkit-transform: translate(0, -4em);\r\n          transform: translate(0, -4em);\r\n}\r\n.ol-popup.placemark.pushpin .anchor,\r\n.ol-popup.placemark.needle .anchor {\r\n  margin: -1.2em;\r\n}\r\n.ol-popup.placemark.pushpin .anchor:after,\r\n.ol-popup.placemark.needle .anchor:after {\r\n  border-style: solid;\r\n    border-width: 2em .15em 0;\r\n    margin: -.55em -0.2em;\r\n    width: .1em;\r\n}\r\n.ol-popup.placemark.pushpin .anchor:before,\r\n.ol-popup.placemark.needle .anchor:before {\r\n    margin: -.75em -.5em;\r\n}\r\n\r\n/** Placemark Flag */\r\n.ol-popup.placemark.flagv {\r\n  margin: -2em 1em;\r\n  -webkit-transform: translate(0, -4em);\r\n          transform: translate(0, -4em);\r\n}\r\n.ol-popup.placemark.flagv > div {\r\n  border-radius: 0;\r\n  -webkit-box-shadow: none;\r\n          box-shadow: none;\r\n  background-color: transparent;\r\n}\r\n.ol-popup.placemark.flagv > div:before {\r\n  content: \"\";\r\n  border: 1em solid transparent;\r\n  position: absolute;\r\n  border-left: 2em solid currentColor;\r\n  pointer-events: none;\r\n}\r\n.ol-popup.placemark.flagv .anchor {\r\n  margin: -1.4em;\r\n}\r\n\r\n.ol-popup.placemark.flag {\t\r\n  margin: -2em 1em;\r\n  -webkit-transform: translate(0, -4em);\r\n          transform: translate(0, -4em);\r\n}\r\n.ol-popup.placemark.flag > div {\t\r\n  border-radius: 0;\r\n  -webkit-transform-origin: 0% 150%!important;\r\n          transform-origin: 0% 150%!important;\r\n}\r\n.ol-popup.placemark.flag .anchor {\r\n  margin: -1.4em;\r\n}\r\n.ol-popup.placemark.flagv .anchor:after, \r\n.ol-popup.placemark.flag .anchor:after {\r\n  border-style: solid;\r\n  border-width: 2em .15em 0;\r\n  margin: -.55em -1em;\r\n  width: .1em;\r\n}\r\n.ol-popup.placemark.flagv .anchor:before,\r\n.ol-popup.placemark.flag .anchor:before {\r\n  margin: -.75em -1.25em;\r\n}\r\n\r\n.ol-popup.placemark.flag.finish {\r\n  margin: -2em 1em;\r\n}\r\n.ol-popup.placemark.flag.finish > div {\r\n  background-image: \r\n    linear-gradient(45deg, currentColor 25%, transparent 25%, transparent 75%, currentColor 75%, currentColor), \r\n    linear-gradient(45deg, currentColor 25%, transparent 25%, transparent 75%, currentColor 75%, currentColor);\r\n  background-size: 1em 1em;\r\n  background-position: .5em 0, 0 .5em;\r\n  -webkit-box-shadow: inset 0 0 0 .25em;\r\n          box-shadow: inset 0 0 0 .25em;\r\n}\r\n\r\n/** Black popup */\r\n.ol-popup.black .closeBox {\r\n  background-color: rgba(0,0,0, 0.5);\r\n  border-radius: 5px;\r\n  color: #f80;\r\n}\r\n.ol-popup.black .closeBox:hover {\r\n  background-color: rgba(0,0,0, 0.7);\r\n  color:#da2;\r\n}\r\n\r\n.ol-popup.black {\r\n  margin: -20px 0;\r\n  -webkit-transform: translate(0, -40px);\r\n          transform: translate(0, -40px);\r\n}\r\n.ol-popup.black > div{\r\n  background-color: rgba(0,0,0,0.6);\r\n  border-radius: 5px;\r\n  color:#fff;\r\n}\r\n.ol-popup-top.ol-popup.black {\r\n  margin: 20px 0;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-left.black {\r\n  margin: -20px -22px;\r\n  -webkit-transform: translate(0, -40px);\r\n          transform: translate(0, -40px);\r\n}\r\n.ol-popup-top.ol-popup-left.black {\r\n  margin: 20px -22px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-right.black {\r\n  margin: -20px 22px;\r\n  -webkit-transform: translate(44px, -40px);\r\n          transform: translate(44px, -40px);\r\n}\r\n.ol-popup-top.ol-popup-right.black {\r\n  margin: 20px 22px;\r\n  -webkit-transform: translate(44px, 0);\r\n          transform: translate(44px, 0);\r\n}\r\n.ol-popup-middle.black {\r\n  margin: 0 11px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-left.ol-popup-middle.black {\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-right.ol-popup-middle.black {\r\n  margin:0 -11px;\r\n  -webkit-transform: translate(-22px, 0);\r\n          transform: translate(-22px, 0);\r\n}\r\n\r\n.ol-popup.black .anchor {\r\n  margin: -20px 11px;\r\n  color: rgba(0,0,0,0.6);\r\n} \r\n.ol-popup.black .anchor:before {\r\n  content:\"\";\r\n  border-color: currentColor transparent;\r\n  border-style: solid;\r\n  border-width: 20px 11px;\r\n}\r\n\r\n.ol-popup-top.black .anchor:before {\r\n  border-top:0;\r\n  top:0;\r\n}\r\n\r\n.ol-popup-bottom.black .anchor:before {\r\n  border-bottom:0;\r\n  bottom:0;\r\n}\r\n\r\n.ol-popup-middle.black .anchor:before {\r\n  margin: -20px -22px;\r\n  border-color: transparent currentColor;\r\n}\r\n.ol-popup-middle.ol-popup-left.black .anchor:before {\r\n  border-left:0;\r\n}\r\n.ol-popup-middle.ol-popup-right.black .anchor:before {\r\n  border-right:0;\r\n}\r\n\r\n.ol-popup-center.black .anchor:before {\r\n  margin: 0 -10px;\r\n}\r\n\r\n\r\n/** Green tips popup */\r\n.ol-popup.tips .closeBox {\r\n  background-color: #f00;\r\n  border-radius: 50%;\r\n  color: #fff;\r\n  width:1.2em;\r\n  height:1.2em;\r\n}\r\n.ol-popup.tips .closeBox:hover {\r\n  background-color: #f40;\r\n}\r\n\r\n.ol-popup.tips {\r\n  margin: -20px 0;\r\n  -webkit-transform: translate(0,-40px);\r\n          transform: translate(0,-40px);\r\n}\r\n.ol-popup.tips > div {\r\n  background-color: #cea;\r\n  border: 5px solid #ad7;\r\n  border-radius: 5px;\r\n  color:#333;\r\n}\r\n.ol-popup-top.ol-popup.tips {\r\n  margin: 20px 0;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-left.tips {\r\n  margin: -20px -22px;\r\n  -webkit-transform: translate(0,-40px);\r\n          transform: translate(0,-40px);\r\n}\r\n.ol-popup-top.ol-popup-left.tips {\r\n  margin: 20px -22px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-right.tips {\r\n  margin: -20px 22px;\r\n  -webkit-transform: translate(44px,-40px);\r\n          transform: translate(44px,-40px);\r\n}\r\n.ol-popup-top.ol-popup-right.tips {\r\n  margin: 20px 22px;\r\n  -webkit-transform: translate(44px,0);\r\n          transform: translate(44px,0);\r\n}\r\n.ol-popup-middle.tips {\r\n  margin:0;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-left.ol-popup-middle.tips {\r\n  margin: 0 22px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-right.ol-popup-middle.tips {\r\n  margin: 0 -22px;\r\n  -webkit-transform: translate(-44px,0);\r\n          transform: translate(-44px,0);\r\n}\r\n\r\n.ol-popup.tips .anchor {\r\n  margin: -18px 22px;\r\n  color: #ad7;\r\n} \r\n.ol-popup.tips .anchor:before {\r\n  content:\"\";\r\n  border-color: currentColor transparent;\r\n  border-style: solid;\r\n  border-width: 20px 11px;\r\n}\r\n\r\n.ol-popup-top.tips .anchor:before {\r\n  border-top:0;\r\n  top:0;\r\n}\r\n.ol-popup-bottom.tips .anchor:before {\r\n  border-bottom:0;\r\n  bottom:0;\r\n}\r\n.ol-popup-center.tips .anchor:before {\r\n  border-width: 20px 6px;\r\n  margin: 0 -6px;\r\n}\r\n.ol-popup-left.tips .anchor:before {\r\n  border-left:0;\r\n  margin-left:0;\r\n}\r\n.ol-popup-right.tips .anchor:before {\r\n  border-right:0;\r\n  margin-right:0;\r\n}\r\n\r\n.ol-popup-middle.tips .anchor:before {\r\n  margin: -6px -41px;\r\n  border-color: transparent currentColor;\r\n  border-width:6px 20px;\r\n}\r\n.ol-popup-middle.ol-popup-left.tips .anchor:before {\r\n  border-left:0;\r\n}\r\n.ol-popup-middle.ol-popup-right.tips .anchor:before {\r\n  border-right:0;\r\n}\r\n\r\n/** Warning popup */\r\n.ol-popup.warning .closeBox {\r\n  background-color: #f00;\r\n  border-radius: 50%;\r\n  color: #fff;\r\n  font-size: 0.83em;\r\n}\r\n.ol-popup.warning .closeBox:hover {\r\n  background-color: #f40;\r\n}\r\n\r\n.ol-popup.warning {\r\n  background-color: #fd0;\r\n  border-radius: 3px;\r\n  border:4px dashed #f00;\r\n  margin:20px 0;\r\n  color:#900;\r\n  margin: -28px 10px;\r\n  -webkit-transform: translate(0, -56px);\r\n          transform: translate(0, -56px);\r\n}\r\n.ol-popup-top.ol-popup.warning {\r\n  margin: 28px 10px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-left.warning {\r\n  margin: -28px -22px;\r\n  -webkit-transform: translate(0, -56px);\r\n          transform: translate(0, -56px);\r\n}\r\n.ol-popup-top.ol-popup-left.warning {\r\n  margin: 28px -22px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-right.warning {\r\n  margin: -28px 22px;\r\n  -webkit-transform: translate(44px, -56px);\r\n          transform: translate(44px, -56px);\r\n}\r\n.ol-popup-top.ol-popup-right.warning {\r\n  margin: 28px 22px;\r\n  -webkit-transform: translate(44px, 0);\r\n          transform: translate(44px, 0);\r\n}\r\n.ol-popup-middle.warning {\r\n  margin:0;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-left.ol-popup-middle.warning {\r\n  margin:0 22px;\r\n  -webkit-transform: none;\r\n          transform: none;\r\n}\r\n.ol-popup-right.ol-popup-middle.warning {\r\n  margin:0 -22px;\r\n  -webkit-transform: translate(-44px, 0);\r\n          transform: translate(-44px, 0);\r\n}\r\n\r\n.ol-popup.warning .anchor {\r\n  margin: -33px 7px;\r\n} \r\n.ol-popup.warning .anchor:before {\r\n  content:\"\";\r\n  border-color: #f00 transparent;\r\n  border-style: solid;\r\n  border-width: 30px 11px;\r\n}\r\n\r\n.ol-popup-top.warning .anchor:before {\r\n  border-top:0;\r\n  top:0;\r\n}\r\n.ol-popup-bottom.warning .anchor:before {\r\n  border-bottom:0;\r\n  bottom:0;\r\n}\r\n\r\n.ol-popup-center.warning .anchor:before {\r\n  margin: 0 -21px;\r\n}\r\n.ol-popup-middle.warning .anchor:before {\r\n  margin: -10px -33px;\r\n  border-color: transparent #f00;\r\n  border-width:10px 22px;\r\n}\r\n.ol-popup-middle.ol-popup-left.warning .anchor:before {\r\n  border-left:0;\r\n}\r\n.ol-popup-middle.ol-popup-right.warning .anchor:before {\r\n  border-right:0;\r\n}\r\n\r\n.ol-popup .ol-popupfeature table {\r\n  width: 100%;\r\n}\r\n.ol-popup .ol-popupfeature table td {\r\n  max-width: 25em;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n}\r\n.ol-popup .ol-popupfeature table td img {\r\n  max-width: 100px;\r\n  max-height: 100px;\r\n}\r\n.ol-popup .ol-popupfeature tr:nth-child(2n+1) {\r\n  background-color: #eee;\r\n}\r\n.ol-popup .ol-popupfeature .ol-zoombt {\r\n  border: 0;\r\n  width: 2em;\r\n  height: 2em;\r\n  display: inline-block;\r\n  color: rgba(0,60,136,.5);\r\n  position: relative;\r\n  background: transparent;\r\n  outline: none;\r\n}\r\n.ol-popup .ol-popupfeature .ol-zoombt:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  width: 1em;\r\n  height: 1em;\r\n  background-color: transparent;\r\n  border: .17em solid currentColor;\r\n  border-radius: 100%;\r\n  top: .3em;\r\n  left: .3em;\r\n}\r\n.ol-popup .ol-popupfeature .ol-zoombt:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  top: 1.35em;\r\n  left: 1.15em;\r\n  border-width: .1em .3em;\r\n  border-style: solid;\r\n  border-radius: .03em;\r\n  -webkit-transform: rotate(45deg);\r\n          transform: rotate(45deg);\r\n  -webkit-box-shadow: -0.2em 0 0 -0.04em;\r\n          box-shadow: -0.2em 0 0 -0.04em;\r\n}\r\n\r\n.ol-popup .ol-popupfeature .ol-count{\r\n  float: right;\r\n  margin: .25em 0;\r\n}\r\n.ol-popup .ol-popupfeature .ol-prev,\r\n.ol-popup .ol-popupfeature .ol-next {\r\n  border-style: solid;\r\n  border-color: transparent rgba(0,60,136,.5);\r\n  border-width: .5em 0 .5em .5em;\r\n  display: inline-block;\r\n  vertical-align: bottom;\r\n  margin: 0 .5em;\r\n  cursor: pointer;\r\n}\r\n.ol-popup .ol-popupfeature .ol-prev{\r\n  border-width: .5em .5em .5em 0;\r\n}\r\n\r\n.ol-popup.tooltips.black {\r\n  background-color: transparent;\r\n}\r\n.ol-popup.tooltips.black > div {\r\n  -webkit-transform: scaleY(1.3);\r\n          transform: scaleY(1.3);\r\n  padding: .2em .5em;\r\n  background-color: rgba(0,0,0, 0.5);\r\n}\r\n.ol-popup-middle.tooltips.black .anchor:before {\r\n  border-width: 5px 10px;\r\n  margin: -5px -21px;\r\n}\r\n\r\n.ol-popup-center.ol-popup-middle { \r\n  margin: 0;\r\n}\r\n\r\n.ol-popup-top.ol-popup-left.ol-fixPopup,\r\n.ol-popup-top.ol-popup-right.ol-fixPopup,\r\n.ol-popup.ol-fixPopup {\r\n  margin: 0;\r\n}\r\n\r\n.ol-miniscroll {\r\n  position: relative;\r\n}\r\n.ol-miniscroll:hover .ol-scroll {\r\n  opacity: .5;\r\n  -webkit-transition: opacity 1s;\r\n  transition: opacity 1s;\r\n}\r\n.ol-miniscroll .ol-scroll {\r\n  -ms-touch-action: none;\r\n      touch-action: none;\r\n  position: absolute;\r\n  right: 0px;\r\n  width: 9px;\r\n  height: auto;\r\n  max-height: 100%;\r\n  opacity: 0;\r\n  border-radius: 9px;\r\n  -webkit-transition: opacity 1s .5s;\r\n  transition: opacity 1s .5s;\r\n  overflow: hidden;\r\n  z-index: 1;\r\n}\r\n.ol-miniscroll .ol-scroll > div {\r\n  -ms-touch-action: none;\r\n      touch-action: none;\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0px;\r\n  width: 9px;\r\n  height: 9px;\r\n  -webkit-box-shadow: inset 10px 0 currentColor;\r\n          box-shadow: inset 10px 0 currentColor;\r\n  border-radius: 9px / 12px;\r\n  border: 2px solid transparent;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  cursor: pointer;\r\n}\r\n.ol-miniscroll .ol-scroll.ol-100pc {\r\n  opacity: 0;\r\n}\r\n\r\n.ol-viewport canvas.ol-fixedoverlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n/* Toggle Switch */\r\n.ol-ext-toggle-switch {\r\n  cursor: pointer;\r\n  position: relative;\r\n}\r\n.ol-ext-toggle-switch input[type=\"radio\"],\r\n.ol-ext-toggle-switch input[type=\"checkbox\"] {\r\n  display: none;\r\n}\r\n.ol-ext-toggle-switch span {\r\n  color: rgba(0,60,136,.5);\r\n  position: relative;\r\n  cursor: pointer;\r\n  background-color: #ccc;\r\n  -webkit-transition: .4s, background-color 0s, border-color 0s;\r\n  transition: .4s, background-color 0s, border-color 0s;\r\n  width: 1.6em;\r\n  height: 1em;\r\n  display: inline-block;\r\n  border-radius: 1em;\r\n  font-size: 1.3em;\r\n  vertical-align: middle;\r\n  margin: -.15em .2em .15em;\r\n}\r\n.ol-ext-toggle-switch span:before {\r\n  position: absolute;\r\n  content: \"\";\r\n  height: 1em;\r\n  width: 1em;\r\n  left: 0;\r\n  top: 50%;\r\n  background-color: #fff;\r\n  -webkit-transition: .4s;\r\n  transition: .4s;\r\n  border-radius: 1em;\r\n  display: block;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n  border: 2px solid #ccc;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-ext-toggle-switch:hover span {\r\n  background-color: #999;\r\n}\r\n.ol-ext-toggle-switch:hover span:before {\r\n  border-color: #999;\r\n}\r\n\r\n.ol-ext-toggle-switch input:checked + span {\r\n  background-color: currentColor;\r\n}\r\n.ol-ext-toggle-switch input:checked + span:before {\r\n  -webkit-transform: translate(.6em,-50%);\r\n          transform: translate(.6em,-50%);\r\n  border-color: currentColor;\r\n}\r\n\r\n/* Check/radio buttons */\r\n.ol-ext-check {\r\n  position: relative;\r\n  display: inline-block;\r\n}\r\n.ol-ext-check input {\r\n  position: absolute;\r\n  opacity: 0;\r\n  cursor: pointer;\r\n  height: 0;\r\n  width: 0;\r\n}\r\n.ol-ext-check span {\r\n  color: rgba(0,60,136,.5);\r\n  position: relative;\r\n  display: inline-block;\r\n  width: 1em;\r\n  height: 1em;\r\n  margin: -.1em .5em .1em;\r\n  background-color: #ccc;\r\n  vertical-align: middle;\r\n}\r\n.ol-ext-check:hover span {\r\n  background-color: #999;\r\n}\r\n.ol-ext-checkbox input:checked ~ span {\r\n  background-color: currentColor;\r\n}\r\n.ol-ext-checkbox input:checked ~ span:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: .5em;\r\n  height: .8em;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translateY(-.1em) translate(-50%, -50%) rotate(45deg);\r\n          transform: translateY(-.1em) translate(-50%, -50%) rotate(45deg);\r\n  -webkit-box-shadow: inset -0.2em -0.2em #fff;\r\n          box-shadow: inset -0.2em -0.2em #fff;\r\n}\r\n\r\n.ol-ext-radio span {\r\n  width: 1.1em;\r\n  height: 1.1em;\r\n  border-radius: 50%;\r\n}\r\n.ol-ext-radio:hover input:checked ~ span {\r\n  background-color: #ccc;\r\n}\r\n.ol-ext-radio input:checked ~ span:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 50%;\r\n  height: 50%;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  border-radius: 50%;\r\n  background-color: currentColor;\r\n}\r\n\r\n.ol-collection-list {\r\n  margin: 0;\r\n  padding: 0;\r\n  list-style: none;\r\n}\r\n.ol-collection-list li {\r\n  position: relative;\r\n  padding: 0 2em 0 1em;\r\n}\r\n.ol-collection-list li:hover {\r\n  background-color: rgba(0,60,136,.2);\r\n}\r\n.ol-collection-list li.ol-select {\r\n  background-color: rgba(0,60,136,.5);\r\n  color: #fff;\r\n}\r\n\r\n.ol-collection-list li .ol-order {\r\n  position: absolute;\r\n  -ms-touch-action: none;\r\n      touch-action: none;\r\n  right: 0;\r\n  top: 50%;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n  width: 2em;\r\n  height: 100%;\r\n  cursor: n-resize;\r\n}\r\n.ol-collection-list li .ol-order:before {\r\n  content: '';\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  width: 18px;\r\n  height: 2px;\r\n  background-color: currentColor;\r\n  -webkit-box-shadow: 0 5px, 0 -5px;\r\n          box-shadow: 0 5px, 0 -5px;\r\n  border-radius: 2px;\r\n}\r\n\r\n.ol-ext-colorpicker.ol-popup {\r\n  width: 2em;\r\n  height: 1.5em;\r\n  background-color: transparent;\r\n  background-image: \r\n    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%), \r\n    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);\r\n  background-size: 10px 10px;\r\n  background-position: 0 -1px, 5px 4px;\r\n}\r\n\r\n.ol-ext-colorpicker .ol-tabbar {\r\n  background-color: #eee;\r\n  border-bottom: 1px solid #999;\r\n  display: none;\r\n}\r\n.ol-ext-colorpicker.ol-tab .ol-tabbar {\r\n  display: block;\r\n}\r\n\r\n.ol-ext-colorpicker .ol-tabbar > div {\r\n  display: inline-block;\r\n  background-color: #fff;\r\n  padding: 0 .5em;\r\n  border: 1px solid #999;\r\n  border-radius: 2px 2px 0 0;\r\n  position: relative;\r\n  top: 1px;\r\n  cursor: pointer;\r\n}\r\n.ol-ext-colorpicker .ol-tabbar > div:nth-child(1) {\r\n  border-bottom-color: #fff;\r\n}\r\n.ol-ext-colorpicker.ol-picker-tab .ol-tabbar > div:nth-child(1) {\r\n  border-bottom-color: #999;\r\n}\r\n.ol-ext-colorpicker.ol-picker-tab .ol-tabbar > div:nth-child(2) {\r\n  border-bottom-color: #fff;\r\n}\r\n\r\n.ol-ext-colorpicker.ol-popup.ol-tab .ol-popup {\r\n  width: 180px;\r\n}\r\n.ol-ext-colorpicker.ol-tab .ol-palette {\r\n  margin: 0 10px;\r\n}\r\n.ol-ext-colorpicker.ol-tab .ol-container {\r\n  display: none;\r\n}\r\n.ol-ext-colorpicker.ol-tab.ol-picker-tab .ol-container {\r\n  display: block;\r\n}\r\n.ol-ext-colorpicker.ol-tab.ol-picker-tab .ol-palette {\r\n  display: none;\r\n}\r\n\r\n.ol-ext-colorpicker.ol-popup .ol-popup {\r\n  width: 340px;\r\n}\r\n\r\n.ol-ext-colorpicker.ol-popup .ol-vignet {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n  top: 0;\r\n  left: 0;\r\n  border: 0;\r\n  background-color: currentColor;\r\n  pointer-events: none;\r\n}\r\n\r\n.ol-ext-colorpicker .ol-container {\r\n  position: relative;\r\n  display: inline-block;\r\n  vertical-align: top;\r\n}\r\n.ol-ext-colorpicker .ol-cursor {\r\n  pointer-events: none;\r\n}\r\n\r\n.ol-ext-colorpicker .ol-picker {\r\n  position: relative;\r\n  cursor: crosshair;\r\n  width: 150px;\r\n  height: 150px;\r\n  border: 5px solid #fff;\r\n  background-color: currentColor;\r\n  background-image: -webkit-gradient(linear, left top, left bottom, from(0), color-stop(#000), to(transparent)),\r\n    -webkit-gradient(linear, left top, right top, from(#fff), to(transparent));\r\n  background-image: linear-gradient(0, #000, transparent),\r\n    linear-gradient(90deg, #fff, transparent);\r\n}\r\n.ol-ext-colorpicker .ol-picker .ol-cursor {\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  border: 1px solid rgba(0,0,0,.7);\r\n  -webkit-box-shadow: 0 0 0 1px rgba(255,255,255,.7);\r\n          box-shadow: 0 0 0 1px rgba(255,255,255,.7);\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  width: 10px;\r\n  height: 10px;\r\n  border-radius: 50%;\r\n}\r\n\r\n.ol-ext-colorpicker .ol-slider {\r\n  position: relative;\r\n  cursor: crosshair;\r\n  background-color: #fff;\r\n  height: 10px;\r\n  width: 150px;\r\n  margin: 5px 0 10px;\r\n  border: 5px solid #fff;\r\n  border-width: 0 5px;\r\n  background-image: \r\n    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%), \r\n    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);\r\n  background-size: 10px 10px;\r\n  background-position: 0 -1px, 5px 4px;\r\n}\r\n.ol-ext-colorpicker .ol-slider > div {\r\n  width: 100%;\r\n  height: 100%;\r\n  background-image: linear-gradient(45deg, transparent, #fff);\r\n  pointer-events: none;\r\n}\r\n.ol-ext-colorpicker .ol-slider .ol-cursor {\r\n  position: absolute;\r\n  width: 4px;\r\n  height: 12px;\r\n  border: 1px solid #000;\r\n  top: 50%;\r\n  left: 0;\r\n  background: transparent;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-ext-colorpicker .ol-tint {\r\n  position: absolute;\r\n  cursor: crosshair;\r\n  width: 10px;\r\n  height: 150px;\r\n  border: 5px solid #fff;\r\n  border-width: 5px 0;\r\n  -webkit-box-sizing: border;\r\n          box-sizing: border;\r\n  top: 0;\r\n  right: 5px;\r\n  background-image: -webkit-gradient(linear, left top, left bottom, from(0), color-stop(#f00), color-stop(#f0f), color-stop(#00f), color-stop(#0ff), color-stop(#0f0), color-stop(#ff0), to(#f00));\r\n  background-image: linear-gradient(0, #f00, #f0f, #00f, #0ff, #0f0, #ff0, #f00)\r\n}\r\n.ol-ext-colorpicker .ol-tint .ol-cursor {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 50%;\r\n  border: 1px solid #000;\r\n  height: 4px;\r\n  width: 12px;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n\r\n.ol-ext-colorpicker .ol-clear {\r\n  position: absolute;\r\n  border: 2px solid #999;\r\n  right: 4px;\r\n  top: 163px;\r\n  width: 10px;\r\n  height: 10px;\r\n}\r\n.ol-ext-colorpicker .ol-clear:before,\r\n.ol-ext-colorpicker .ol-clear:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 15px;\r\n  height: 2px;\r\n  background-color: #999;\r\n  top: 50%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(45deg);\r\n          transform: translate(-50%, -50%) rotate(45deg);\r\n}\r\n.ol-ext-colorpicker .ol-clear:after {\r\n  -webkit-transform: translate(-50%, -50%) rotate(-45deg);\r\n          transform: translate(-50%, -50%) rotate(-45deg);\r\n}\r\n\r\n.ol-ext-colorpicker.ol-nopacity .ol-slider,\r\n.ol-ext-colorpicker.ol-nopacity .ol-clear {\r\n  display: none;\r\n}\r\n.ol-ext-colorpicker.ol-nopacity .ol-alpha {\r\n  display: none;\r\n}\r\n\r\n.ol-ext-colorpicker .ol-rgb {\r\n  position: relative;\r\n  padding: 5px;\r\n  width: 170px;\r\n  display: none;\r\n}\r\n.ol-ext-colorpicker .ol-rgb input {\r\n  width: 25%;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  padding: 0 0 0 2px;\r\n  border: 1px solid #999;\r\n  border-radius: 2px;\r\n  font-size: 13px;\r\n}\r\n.ol-ext-colorpicker .ol-rgb input:nth-child(1) {\r\n\tbackground-color: rgba(255,0,0,.1);\r\n}\r\n.ol-ext-colorpicker .ol-rgb input:nth-child(2) {\r\n\tbackground-color: rgba(0,255,0,.1);\r\n}\r\n.ol-ext-colorpicker .ol-rgb input:nth-child(3) {\r\n\tbackground-color: rgba(0,0,255,.12);\r\n}\r\n\r\n.ol-ext-colorpicker button,\r\n.ol-ext-colorpicker .ol-txt-color {\r\n  font-size: 13px;\r\n  margin: 0 5px 5px;\r\n  text-align: center;\r\n  width: 170px;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  padding: 0;\r\n  border: 1px solid #999;\r\n  border-radius: 2px;\r\n  display: block;\r\n}\r\n.ol-ext-colorpicker button {\r\n  background-color: #eee;\r\n}\r\n.ol-ext-colorpicker button:hover {\r\n  background-color: #e9e9e9;\r\n}\r\n\r\n.ol-ext-colorpicker .ol-txt-color.ol-error {\r\n  background-color: rgba(255,0,0,.2);\r\n}\r\n\r\n.ol-ext-colorpicker .ol-palette {\r\n  padding: 2px;\r\n  display: inline-block;\r\n  width: 152px;\r\n}\r\n.ol-ext-colorpicker .ol-palette > div {\r\n  width: 15px;\r\n  height: 15px;\r\n  display: inline-block;\r\n  background-image: \r\n    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%), \r\n    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);\r\n  background-size: 10px 10px;\r\n  background-position: 0 0, 5px 5px;\r\n  margin: 2px;\r\n  -webkit-box-shadow: 0 0 2px 0px #666;\r\n          box-shadow: 0 0 2px 0px #666;\r\n  border-radius: 1px;\r\n  cursor: pointer;\r\n  position: relative;\r\n}\r\n.ol-ext-colorpicker .ol-palette > div:before {\r\n  content: \"\";\r\n  position: absolute;\r\n  background-color: currentColor;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.ol-ext-colorpicker .ol-palette > div.ol-select:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  width: 6px;\r\n  height: 12px;\r\n  -webkit-box-shadow: 1px 1px #fff, 2px 2px #000;\r\n          box-shadow: 1px 1px #fff, 2px 2px #000;\r\n  top: 30%;\r\n  left: 50%;\r\n  -webkit-transform: translate(-50%, -50%) rotate(45deg);\r\n          transform: translate(-50%, -50%) rotate(45deg);\r\n}\r\n.ol-ext-colorpicker .ol-palette > div:hover {\r\n  -webkit-box-shadow: 0 0 2px 1px #d90;\r\n          box-shadow: 0 0 2px 1px #d90;\r\n}\r\n.ol-ext-colorpicker .ol-palette hr {\r\n  margin: 0;\r\n}\r\n\r\n.ol-input-popup {\r\n  display: inline-block;\r\n  position: relative;\r\n}\r\n.ol-input-popup .ol-popup {\r\n  position: absolute;\r\n  -webkit-box-shadow: 1px 1px 3px 1px #999;\r\n          box-shadow: 1px 1px 3px 1px #999;\r\n  background-color: #fff;\r\n  z-index: 1;\r\n  display: none;\r\n  left: -5px;\r\n  padding: 0;\r\n  margin: 0;\r\n  list-style: none;\r\n  white-space: nowrap;\r\n}\r\n.ol-input-popup.ol-hover:hover .ol-popup,\r\n.ol-input-popup.ol-focus .ol-popup {\r\n  display: block;\r\n}\r\n.ol-input-popup.ol-right .ol-popup {\r\n  left: auto;\r\n  right: -5px;\r\n}\r\n.ol-input-popup.ol-middle .ol-popup {\r\n  top: 50%;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n}\r\n\r\n\r\n.ol-input-popup .ol-popup li {\r\n  position: relative;\r\n  padding: 10px 5px;\r\n}\r\n\r\n.ol-input-popup li:hover {\r\n  background-color: #ccc;\r\n}\r\n.ol-input-popup li.ol-selected {\r\n  background-color: #ccc;\r\n}\r\n\r\n.ol-input-popup.ol-fixed:hover .ol-popup,\r\n.ol-input-popup.ol-fixed .ol-popup {\r\n  position: relative;\r\n  left: 0;\r\n  -webkit-box-shadow: unset;\r\n          box-shadow: unset;\r\n  background-color: transparent;\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n.ol-input-popup.ol-fixed.ol-left .ol-popup {\r\n  float: left;\r\n}\r\n\r\n.ol-input-popup > div {\r\n  position: relative;\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n  border-radius: 2px;\r\n  border: 1px solid #999;\r\n  padding: 3px 20px 3px 10px\r\n}\r\n.ol-input-popup > div:before {\r\n  position: absolute;\r\n  content: \"\";\r\n  right: 5px;\r\n  top: 50%;\r\n  border: 5px solid transparent;\r\n  border-top: 5px solid #999;\r\n}\r\n\r\n.ol-ext-popup-input {\r\n  display: inline-block;\r\n  vertical-align: top;\r\n}\r\n.ol-ext-popup-input.ol-popup {\r\n  position: relative;\r\n  width: 2em;\r\n  height: 1.5em;\r\n  display: inline-block;\r\n  border: 3px solid #fff;\r\n  border-right-width: 1em;\r\n  -webkit-box-shadow: 0 0 2px 1px #666;\r\n          box-shadow: 0 0 2px 1px #666;\r\n  border-radius: 2px;\r\n  -webkit-box-sizing: content-box;\r\n          box-sizing: content-box;\r\n  -webkit-user-select: none;\r\n     -moz-user-select: none;\r\n      -ms-user-select: none;\r\n          user-select: none;\r\n  vertical-align: middle;\r\n}\r\n.ol-ext-popup-input.ol-popup:after {\r\n  content: \"\";\r\n  position: absolute;\r\n  border: .5em solid #aaa;\r\n  border-width: .5em .3em 0;\r\n  border-color: #999 transparent;\r\n  right: -.8em;\r\n  top: 50%;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n  pointer-events: none;\r\n}\r\n\r\n.ol-ext-popup-input * {\r\n  -webkit-box-sizing: content-box;\r\n          box-sizing: content-box;\r\n}\r\n\r\n.ol-ext-popup-input.ol-popup .ol-popup {\r\n  position: absolute;\r\n  top: 100%;\r\n  min-width: 3em;\r\n  min-height: 3em;\r\n  left: 0;\r\n  -webkit-box-shadow: 1px 1px 3px 1px #999;\r\n          box-shadow: 1px 1px 3px 1px #999;\r\n  display: block;\r\n  background-color: #fff;\r\n  display: none;\r\n  z-index: 1;\r\n}\r\n.ol-ext-popup-input.ol-popup .ol-popup.ol-visible {\r\n  display: block;\r\n}\r\n\r\n.ol-ext-popup-input.ol-popup-fixed .ol-popup {\r\n  position: fixed;\r\n  top: auto;\r\n  left: auto;\r\n}\r\n\r\n.ol-input-popup.ol-size li {\r\n  display: table-cell;\r\n  height: 100%;\r\n  padding: 5px;\r\n  vertical-align: middle;\r\n}\r\n\r\n.ol-input-popup.ol-size li > * {\r\n  background-color: #369;\r\n  border-radius: 50%;\r\n  vertical-align: middle;\r\n  width: 1em;\r\n  height: 1em;\r\n}\r\n\r\n.ol-input-popup.ol-size li > .ol-option-0 {\r\n  position: relative;\r\n  width: 1em;\r\n  height: 1em;\r\n  border: 2px solid currentColor;\r\n  color: #aaa;\r\n  background-color: transparent;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n}\r\n.ol-input-popup.ol-size li > *:before {\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n}\r\n.ol-input-popup.ol-size li > .ol-option-0:before {\r\n  content: \"\";\r\n  width: 1em;\r\n  height: 2px;\r\n  background-color: #aaa;\r\n  -webkit-transform: translate(-50%, -50%) rotate(-45deg);\r\n          transform: translate(-50%, -50%) rotate(-45deg);\r\n}\r\n\r\n.ol-input-slider {\r\n  display: inline-block;\r\n  position: relative;\r\n}\r\n.ol-input-slider .ol-popup {\r\n  position: absolute;\r\n  -webkit-box-shadow: 1px 1px 3px 1px #999;\r\n          box-shadow: 1px 1px 3px 1px #999;\r\n  background-color: #fff;\r\n  z-index: 1;\r\n  display: none;\r\n  left: -5px;\r\n}\r\n.ol-input-slider.ol-right .ol-popup {\r\n  left: auto;\r\n  right: -5px;\r\n}\r\n.ol-input-slider.ol-hover:hover .ol-popup,\r\n.ol-input-slider.ol-focus .ol-popup {\r\n  display: block;\r\n  white-space: nowrap;\r\n}\r\n.ol-input-slider.ol-hover:hover .ol-popup > *,\r\n.ol-input-slider.ol-focus .ol-popup > * {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n.ol-input-slider.ol-hover:hover .ol-popup > .ol-before,\r\n.ol-input-slider.ol-focus .ol-popup > .ol-before {\r\n  margin-left: 10px;\r\n}\r\n.ol-input-slider.ol-hover:hover .ol-popup > .ol-after,\r\n.ol-input-slider.ol-focus .ol-popup > .ol-after {\r\n  margin-right: 10px;\r\n}\r\n.ol-input-slider .ol-slider {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n  position: relative;\r\n  width: 100px;\r\n  height: 3px;\r\n  border: 0 solid transparent;\r\n  border-width: 10px 15px;\r\n  -webkit-box-shadow: inset 0 0 0 1px #999;\r\n          box-shadow: inset 0 0 0 1px #999;\r\n  -webkit-box-sizing: content-box;\r\n          box-sizing: content-box;\r\n  cursor: pointer;\r\n}\r\n\r\n.ol-input-slider .ol-slider > .ol-cursor {\r\n  position: absolute;\r\n  width: 5px;\r\n  height: 10px;\r\n  top: 50%;\r\n  -webkit-transform: translate(-50%, -50%);\r\n          transform: translate(-50%, -50%);\r\n  background-color: #999;\r\n  pointer-events: none;\r\n}\r\n.ol-input-range .ol-slider {\r\n  cursor: default;\r\n  width: 150px;\r\n}\r\n.ol-input-range .ol-slider > .ol-cursor {\r\n  pointer-events: all;\r\n  cursor: pointer;\r\n  width: 10px;\r\n  border-radius: 50%;\r\n  background-color: rgb(0,60,136);\r\n}\r\n.ol-input-range.ol-moving .ol-slider > .ol-cursor {\r\n  pointer-events: none;\r\n}\r\n.ol-input-range .ol-slider > .ol-back {\r\n  position: absolute;\r\n  top: 50%;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n  left: 30%;\r\n  right: 20%;\r\n  height: 100%;\r\n  background-color: rgb(0,60,136);\r\n  pointer-events: none;\r\n}\r\n\r\n.ol-input-slider.ol-fixed:hover .ol-popup,\r\n.ol-input-slider.ol-fixed .ol-popup {\r\n  position: relative;\r\n  left: 0;\r\n  -webkit-box-shadow: unset;\r\n          box-shadow: unset;\r\n  background-color: transparent;\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n.ol-input-slider.ol-fixed.ol-left .ol-popup {\r\n  float: left;\r\n}\r\n\r\n/* Grow */\r\n.ol-input-slider.ol-size .ol-slider {\r\n  height: auto;\r\n  -webkit-box-shadow: none;\r\n          box-shadow: none;\r\n}\r\n.ol-input-slider.ol-size .ol-slider .ol-back {\r\n  width: 0;\r\n  color: #aaa;\r\n  border: 0 solid transparent;\r\n  border-width: 0 0 20px 100px;\r\n  border-color: currentColor transparent;\r\n  pointer-events: none;\r\n}\r\n\r\n.ol-input-slider.ol-size .ol-slider > .ol-cursor {\r\n  width: 2px;\r\n  height: calc(100% + 4px);\r\n  border-width: 5px 3px;\r\n  border-style: solid;\r\n  border-color: #f00 transparent;\r\n  -o-border-image: initial;\r\n     border-image: initial;\r\n  background-color: transparent;\r\n  -webkit-box-shadow: inset 3px 0px #f00;\r\n          box-shadow: inset 3px 0px #f00;\r\n}\r\n\r\n.ol-input-popup.ol-width li {\r\n  padding: 5px;\r\n}\r\n\r\n\r\n.ol-input-popup.ol-width li > * {\r\n  background-color: #369;\r\n  width: 100px;\r\n  height: 1em;\r\n}\r\n\r\n.ol-input-popup.ol-width li > .ol-option-0 {\r\n  position: relative;\r\n  height: 1px;\r\n  background-image: linear-gradient(90deg,#aaa 2px, transparent 2px);\r\n  background-color: transparent;\r\n  background-size: 4px;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/ol/ol.css":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `:root,
:host {
  --ol-background-color: white;
  --ol-accent-background-color: #F5F5F5;
  --ol-subtle-background-color: rgba(128, 128, 128, 0.25);
  --ol-partial-background-color: rgba(255, 255, 255, 0.75);
  --ol-foreground-color: #333333;
  --ol-subtle-foreground-color: #666666;
  --ol-brand-color: #00AAFF;
}

.ol-box {
  box-sizing: border-box;
  border-radius: 2px;
  border: 1.5px solid var(--ol-background-color);
  background-color: var(--ol-partial-background-color);
}

.ol-mouse-position {
  top: 8px;
  right: 8px;
  position: absolute;
}

.ol-scale-line {
  background: var(--ol-partial-background-color);
  border-radius: 4px;
  bottom: 8px;
  left: 8px;
  padding: 2px;
  position: absolute;
}

.ol-scale-line-inner {
  border: 1px solid var(--ol-subtle-foreground-color);
  border-top: none;
  color: var(--ol-foreground-color);
  font-size: 10px;
  text-align: center;
  margin: 1px;
  will-change: contents, width;
  transition: all 0.25s;
}

.ol-scale-bar {
  position: absolute;
  bottom: 8px;
  left: 8px;
}

.ol-scale-bar-inner {
  display: flex;
}

.ol-scale-step-marker {
  width: 1px;
  height: 15px;
  background-color: var(--ol-foreground-color);
  float: right;
  z-index: 10;
}

.ol-scale-step-text {
  position: absolute;
  bottom: -5px;
  font-size: 10px;
  z-index: 11;
  color: var(--ol-foreground-color);
  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);
}

.ol-scale-text {
  position: absolute;
  font-size: 12px;
  text-align: center;
  bottom: 25px;
  color: var(--ol-foreground-color);
  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);
}

.ol-scale-singlebar {
  position: relative;
  height: 10px;
  z-index: 9;
  box-sizing: border-box;
  border: 1px solid var(--ol-foreground-color);
}

.ol-scale-singlebar-even {
  background-color: var(--ol-subtle-foreground-color);
}

.ol-scale-singlebar-odd {
  background-color: var(--ol-background-color);
}

.ol-unsupported {
  display: none;
}

.ol-viewport,
.ol-unselectable {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.ol-viewport canvas {
  all: unset;
}

.ol-selectable {
  -webkit-touch-callout: default;
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

.ol-grabbing {
  cursor: -webkit-grabbing;
  cursor: -moz-grabbing;
  cursor: grabbing;
}

.ol-grab {
  cursor: move;
  cursor: -webkit-grab;
  cursor: -moz-grab;
  cursor: grab;
}

.ol-control {
  position: absolute;
  background-color: var(--ol-subtle-background-color);
  border-radius: 4px;
}

.ol-zoom {
  top: .5em;
  left: .5em;
}

.ol-rotate {
  top: .5em;
  right: .5em;
  transition: opacity .25s linear, visibility 0s linear;
}

.ol-rotate.ol-hidden {
  opacity: 0;
  visibility: hidden;
  transition: opacity .25s linear, visibility 0s linear .25s;
}

.ol-zoom-extent {
  top: 4.643em;
  left: .5em;
}

.ol-full-screen {
  right: .5em;
  top: .5em;
}

.ol-control button {
  display: block;
  margin: 1px;
  padding: 0;
  color: var(--ol-subtle-foreground-color);
  font-weight: bold;
  text-decoration: none;
  font-size: inherit;
  text-align: center;
  height: 1.375em;
  width: 1.375em;
  line-height: .4em;
  background-color: var(--ol-background-color);
  border: none;
  border-radius: 2px;
}

.ol-control button::-moz-focus-inner {
  border: none;
  padding: 0;
}

.ol-zoom-extent button {
  line-height: 1.4em;
}

.ol-compass {
  display: block;
  font-weight: normal;
  will-change: transform;
}

.ol-touch .ol-control button {
  font-size: 1.5em;
}

.ol-touch .ol-zoom-extent {
  top: 5.5em;
}

.ol-control button:hover,
.ol-control button:focus {
  text-decoration: none;
  outline: 1px solid var(--ol-subtle-foreground-color);
  color: var(--ol-foreground-color);
}

.ol-zoom .ol-zoom-in {
  border-radius: 2px 2px 0 0;
}

.ol-zoom .ol-zoom-out {
  border-radius: 0 0 2px 2px;
}

.ol-attribution {
  text-align: right;
  bottom: .5em;
  right: .5em;
  max-width: calc(100% - 1.3em);
  display: flex;
  flex-flow: row-reverse;
  align-items: center;
}

.ol-attribution a {
  color: var(--ol-subtle-foreground-color);
  text-decoration: none;
}

.ol-attribution ul {
  margin: 0;
  padding: 1px .5em;
  color: var(--ol-foreground-color);
  text-shadow: 0 0 2px var(--ol-background-color);
  font-size: 12px;
}

.ol-attribution li {
  display: inline;
  list-style: none;
}

.ol-attribution li:not(:last-child):after {
  content: " ";
}

.ol-attribution img {
  max-height: 2em;
  max-width: inherit;
  vertical-align: middle;
}

.ol-attribution button {
  flex-shrink: 0;
}

.ol-attribution.ol-collapsed ul {
  display: none;
}

.ol-attribution:not(.ol-collapsed) {
  background: var(--ol-partial-background-color);
}

.ol-attribution.ol-uncollapsible {
  bottom: 0;
  right: 0;
  border-radius: 4px 0 0;
}

.ol-attribution.ol-uncollapsible img {
  margin-top: -.2em;
  max-height: 1.6em;
}

.ol-attribution.ol-uncollapsible button {
  display: none;
}

.ol-zoomslider {
  top: 4.5em;
  left: .5em;
  height: 200px;
}

.ol-zoomslider button {
  position: relative;
  height: 10px;
}

.ol-touch .ol-zoomslider {
  top: 5.5em;
}

.ol-overviewmap {
  left: 0.5em;
  bottom: 0.5em;
}

.ol-overviewmap.ol-uncollapsible {
  bottom: 0;
  left: 0;
  border-radius: 0 4px 0 0;
}

.ol-overviewmap .ol-overviewmap-map,
.ol-overviewmap button {
  display: block;
}

.ol-overviewmap .ol-overviewmap-map {
  border: 1px solid var(--ol-subtle-foreground-color);
  height: 150px;
  width: 150px;
}

.ol-overviewmap:not(.ol-collapsed) button {
  bottom: 0;
  left: 0;
  position: absolute;
}

.ol-overviewmap.ol-collapsed .ol-overviewmap-map,
.ol-overviewmap.ol-uncollapsible button {
  display: none;
}

.ol-overviewmap:not(.ol-collapsed) {
  background: var(--ol-subtle-background-color);
}

.ol-overviewmap-box {
  border: 1.5px dotted var(--ol-subtle-foreground-color);
}

.ol-overviewmap .ol-overviewmap-box:hover {
  cursor: move;
}
`, "",{"version":3,"sources":["webpack://./node_modules/ol/ol.css"],"names":[],"mappings":"AAAA;;EAEE,4BAA4B;EAC5B,qCAAqC;EACrC,uDAAuD;EACvD,wDAAwD;EACxD,8BAA8B;EAC9B,qCAAqC;EACrC,yBAAyB;AAC3B;;AAEA;EACE,sBAAsB;EACtB,kBAAkB;EAClB,8CAA8C;EAC9C,oDAAoD;AACtD;;AAEA;EACE,QAAQ;EACR,UAAU;EACV,kBAAkB;AACpB;;AAEA;EACE,8CAA8C;EAC9C,kBAAkB;EAClB,WAAW;EACX,SAAS;EACT,YAAY;EACZ,kBAAkB;AACpB;;AAEA;EACE,mDAAmD;EACnD,gBAAgB;EAChB,iCAAiC;EACjC,eAAe;EACf,kBAAkB;EAClB,WAAW;EACX,4BAA4B;EAC5B,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,SAAS;AACX;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,UAAU;EACV,YAAY;EACZ,4CAA4C;EAC5C,YAAY;EACZ,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,eAAe;EACf,WAAW;EACX,iCAAiC;EACjC,6LAA6L;AAC/L;;AAEA;EACE,kBAAkB;EAClB,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,iCAAiC;EACjC,6LAA6L;AAC/L;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,UAAU;EACV,sBAAsB;EACtB,4CAA4C;AAC9C;;AAEA;EACE,mDAAmD;AACrD;;AAEA;EACE,4CAA4C;AAC9C;;AAEA;EACE,aAAa;AACf;;AAEA;;EAEE,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,iBAAiB;EACjB,wCAAwC;AAC1C;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,8BAA8B;EAC9B,yBAAyB;EACzB,sBAAsB;EACtB,iBAAiB;AACnB;;AAEA;EACE,wBAAwB;EACxB,qBAAqB;EACrB,gBAAgB;AAClB;;AAEA;EACE,YAAY;EACZ,oBAAoB;EACpB,iBAAiB;EACjB,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,mDAAmD;EACnD,kBAAkB;AACpB;;AAEA;EACE,SAAS;EACT,UAAU;AACZ;;AAEA;EACE,SAAS;EACT,WAAW;EACX,qDAAqD;AACvD;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,0DAA0D;AAC5D;;AAEA;EACE,YAAY;EACZ,UAAU;AACZ;;AAEA;EACE,WAAW;EACX,SAAS;AACX;;AAEA;EACE,cAAc;EACd,WAAW;EACX,UAAU;EACV,wCAAwC;EACxC,iBAAiB;EACjB,qBAAqB;EACrB,kBAAkB;EAClB,kBAAkB;EAClB,eAAe;EACf,cAAc;EACd,iBAAiB;EACjB,4CAA4C;EAC5C,YAAY;EACZ,kBAAkB;AACpB;;AAEA;EACE,YAAY;EACZ,UAAU;AACZ;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,cAAc;EACd,mBAAmB;EACnB,sBAAsB;AACxB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,UAAU;AACZ;;AAEA;;EAEE,qBAAqB;EACrB,oDAAoD;EACpD,iCAAiC;AACnC;;AAEA;EACE,0BAA0B;AAC5B;;AAEA;EACE,0BAA0B;AAC5B;;AAEA;EACE,iBAAiB;EACjB,YAAY;EACZ,WAAW;EACX,6BAA6B;EAC7B,aAAa;EACb,sBAAsB;EACtB,mBAAmB;AACrB;;AAEA;EACE,wCAAwC;EACxC,qBAAqB;AACvB;;AAEA;EACE,SAAS;EACT,iBAAiB;EACjB,iCAAiC;EACjC,+CAA+C;EAC/C,eAAe;AACjB;;AAEA;EACE,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,sBAAsB;AACxB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,8CAA8C;AAChD;;AAEA;EACE,SAAS;EACT,QAAQ;EACR,sBAAsB;AACxB;;AAEA;EACE,iBAAiB;EACjB,iBAAiB;AACnB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,UAAU;EACV,UAAU;EACV,aAAa;AACf;;AAEA;EACE,kBAAkB;EAClB,YAAY;AACd;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,WAAW;EACX,aAAa;AACf;;AAEA;EACE,SAAS;EACT,OAAO;EACP,wBAAwB;AAC1B;;AAEA;;EAEE,cAAc;AAChB;;AAEA;EACE,mDAAmD;EACnD,aAAa;EACb,YAAY;AACd;;AAEA;EACE,SAAS;EACT,OAAO;EACP,kBAAkB;AACpB;;AAEA;;EAEE,aAAa;AACf;;AAEA;EACE,6CAA6C;AAC/C;;AAEA;EACE,sDAAsD;AACxD;;AAEA;EACE,YAAY;AACd","sourcesContent":[":root,\n:host {\n  --ol-background-color: white;\n  --ol-accent-background-color: #F5F5F5;\n  --ol-subtle-background-color: rgba(128, 128, 128, 0.25);\n  --ol-partial-background-color: rgba(255, 255, 255, 0.75);\n  --ol-foreground-color: #333333;\n  --ol-subtle-foreground-color: #666666;\n  --ol-brand-color: #00AAFF;\n}\n\n.ol-box {\n  box-sizing: border-box;\n  border-radius: 2px;\n  border: 1.5px solid var(--ol-background-color);\n  background-color: var(--ol-partial-background-color);\n}\n\n.ol-mouse-position {\n  top: 8px;\n  right: 8px;\n  position: absolute;\n}\n\n.ol-scale-line {\n  background: var(--ol-partial-background-color);\n  border-radius: 4px;\n  bottom: 8px;\n  left: 8px;\n  padding: 2px;\n  position: absolute;\n}\n\n.ol-scale-line-inner {\n  border: 1px solid var(--ol-subtle-foreground-color);\n  border-top: none;\n  color: var(--ol-foreground-color);\n  font-size: 10px;\n  text-align: center;\n  margin: 1px;\n  will-change: contents, width;\n  transition: all 0.25s;\n}\n\n.ol-scale-bar {\n  position: absolute;\n  bottom: 8px;\n  left: 8px;\n}\n\n.ol-scale-bar-inner {\n  display: flex;\n}\n\n.ol-scale-step-marker {\n  width: 1px;\n  height: 15px;\n  background-color: var(--ol-foreground-color);\n  float: right;\n  z-index: 10;\n}\n\n.ol-scale-step-text {\n  position: absolute;\n  bottom: -5px;\n  font-size: 10px;\n  z-index: 11;\n  color: var(--ol-foreground-color);\n  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);\n}\n\n.ol-scale-text {\n  position: absolute;\n  font-size: 12px;\n  text-align: center;\n  bottom: 25px;\n  color: var(--ol-foreground-color);\n  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);\n}\n\n.ol-scale-singlebar {\n  position: relative;\n  height: 10px;\n  z-index: 9;\n  box-sizing: border-box;\n  border: 1px solid var(--ol-foreground-color);\n}\n\n.ol-scale-singlebar-even {\n  background-color: var(--ol-subtle-foreground-color);\n}\n\n.ol-scale-singlebar-odd {\n  background-color: var(--ol-background-color);\n}\n\n.ol-unsupported {\n  display: none;\n}\n\n.ol-viewport,\n.ol-unselectable {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.ol-viewport canvas {\n  all: unset;\n}\n\n.ol-selectable {\n  -webkit-touch-callout: default;\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  user-select: text;\n}\n\n.ol-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n\n.ol-grab {\n  cursor: move;\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n\n.ol-control {\n  position: absolute;\n  background-color: var(--ol-subtle-background-color);\n  border-radius: 4px;\n}\n\n.ol-zoom {\n  top: .5em;\n  left: .5em;\n}\n\n.ol-rotate {\n  top: .5em;\n  right: .5em;\n  transition: opacity .25s linear, visibility 0s linear;\n}\n\n.ol-rotate.ol-hidden {\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity .25s linear, visibility 0s linear .25s;\n}\n\n.ol-zoom-extent {\n  top: 4.643em;\n  left: .5em;\n}\n\n.ol-full-screen {\n  right: .5em;\n  top: .5em;\n}\n\n.ol-control button {\n  display: block;\n  margin: 1px;\n  padding: 0;\n  color: var(--ol-subtle-foreground-color);\n  font-weight: bold;\n  text-decoration: none;\n  font-size: inherit;\n  text-align: center;\n  height: 1.375em;\n  width: 1.375em;\n  line-height: .4em;\n  background-color: var(--ol-background-color);\n  border: none;\n  border-radius: 2px;\n}\n\n.ol-control button::-moz-focus-inner {\n  border: none;\n  padding: 0;\n}\n\n.ol-zoom-extent button {\n  line-height: 1.4em;\n}\n\n.ol-compass {\n  display: block;\n  font-weight: normal;\n  will-change: transform;\n}\n\n.ol-touch .ol-control button {\n  font-size: 1.5em;\n}\n\n.ol-touch .ol-zoom-extent {\n  top: 5.5em;\n}\n\n.ol-control button:hover,\n.ol-control button:focus {\n  text-decoration: none;\n  outline: 1px solid var(--ol-subtle-foreground-color);\n  color: var(--ol-foreground-color);\n}\n\n.ol-zoom .ol-zoom-in {\n  border-radius: 2px 2px 0 0;\n}\n\n.ol-zoom .ol-zoom-out {\n  border-radius: 0 0 2px 2px;\n}\n\n.ol-attribution {\n  text-align: right;\n  bottom: .5em;\n  right: .5em;\n  max-width: calc(100% - 1.3em);\n  display: flex;\n  flex-flow: row-reverse;\n  align-items: center;\n}\n\n.ol-attribution a {\n  color: var(--ol-subtle-foreground-color);\n  text-decoration: none;\n}\n\n.ol-attribution ul {\n  margin: 0;\n  padding: 1px .5em;\n  color: var(--ol-foreground-color);\n  text-shadow: 0 0 2px var(--ol-background-color);\n  font-size: 12px;\n}\n\n.ol-attribution li {\n  display: inline;\n  list-style: none;\n}\n\n.ol-attribution li:not(:last-child):after {\n  content: \" \";\n}\n\n.ol-attribution img {\n  max-height: 2em;\n  max-width: inherit;\n  vertical-align: middle;\n}\n\n.ol-attribution button {\n  flex-shrink: 0;\n}\n\n.ol-attribution.ol-collapsed ul {\n  display: none;\n}\n\n.ol-attribution:not(.ol-collapsed) {\n  background: var(--ol-partial-background-color);\n}\n\n.ol-attribution.ol-uncollapsible {\n  bottom: 0;\n  right: 0;\n  border-radius: 4px 0 0;\n}\n\n.ol-attribution.ol-uncollapsible img {\n  margin-top: -.2em;\n  max-height: 1.6em;\n}\n\n.ol-attribution.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-zoomslider {\n  top: 4.5em;\n  left: .5em;\n  height: 200px;\n}\n\n.ol-zoomslider button {\n  position: relative;\n  height: 10px;\n}\n\n.ol-touch .ol-zoomslider {\n  top: 5.5em;\n}\n\n.ol-overviewmap {\n  left: 0.5em;\n  bottom: 0.5em;\n}\n\n.ol-overviewmap.ol-uncollapsible {\n  bottom: 0;\n  left: 0;\n  border-radius: 0 4px 0 0;\n}\n\n.ol-overviewmap .ol-overviewmap-map,\n.ol-overviewmap button {\n  display: block;\n}\n\n.ol-overviewmap .ol-overviewmap-map {\n  border: 1px solid var(--ol-subtle-foreground-color);\n  height: 150px;\n  width: 150px;\n}\n\n.ol-overviewmap:not(.ol-collapsed) button {\n  bottom: 0;\n  left: 0;\n  position: absolute;\n}\n\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\n.ol-overviewmap.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-overviewmap:not(.ol-collapsed) {\n  background: var(--ol-subtle-background-color);\n}\n\n.ol-overviewmap-box {\n  border: 1.5px dotted var(--ol-subtle-foreground-color);\n}\n\n.ol-overviewmap .ol-overviewmap-box:hover {\n  cursor: move;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./public/app/core/components/ColorScale/ColorScale.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorScale: () => (/* binding */ ColorScale)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");




const GRADIENT_STOPS = 10;
const ColorScale = ({ colorPalette, min, max, display, hoverValue, useStopsPercentage }) => {
  const [colors, setColors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
  const [scaleHover, setScaleHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({ isShown: false, value: 0 });
  const [percent, setPercent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme2)();
  const styles = getStyles(theme, colors);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    setColors(getGradientStops({ colorArray: colorPalette, stops: GRADIENT_STOPS, useStopsPercentage }));
  }, [colorPalette, useStopsPercentage]);
  const onScaleMouseMove = (event) => {
    const divOffset = event.nativeEvent.offsetX;
    const offsetWidth = event.currentTarget.offsetWidth;
    const normPercentage = Math.floor(divOffset * 100 / offsetWidth + 1);
    const scaleValue = Math.floor((max - min) * normPercentage / 100 + min);
    setScaleHover({ isShown: true, value: scaleValue });
    setPercent(normPercentage);
  };
  const onScaleMouseLeave = () => {
    setScaleHover({ isShown: false, value: 0 });
  };
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    setPercent(hoverValue == null ? null : clampPercent100((hoverValue - min) / (max - min)));
  }, [hoverValue, min, max]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.scaleWrapper, onMouseMove: onScaleMouseMove, onMouseLeave: onScaleMouseLeave }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.scaleGradient }, display && (scaleHover.isShown || hoverValue !== void 0) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.followerContainer }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.follower, style: { left: "".concat(percent, "%") } }))), display && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.followerContainer }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.legendValues }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: styles.disabled }, display(min)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: styles.disabled }, display(max))), percent != null && (scaleHover.isShown || hoverValue !== void 0) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: styles.hoverValue, style: { left: "".concat(percent, "%") } }, display(hoverValue != null ? hoverValue : scaleHover.value))));
};
const getGradientStops = ({
  colorArray,
  stops,
  useStopsPercentage = true
}) => {
  const colorCount = colorArray.length;
  if (useStopsPercentage && colorCount <= 20) {
    const incr = 1 / colorCount * 100;
    let per = 0;
    const stops2 = [];
    for (const color of colorArray) {
      if (per > 0) {
        stops2.push("".concat(color, " ").concat(per, "%"));
      } else {
        stops2.push(color);
      }
      per += incr;
      stops2.push("".concat(color, " ").concat(per, "%"));
    }
    return stops2;
  }
  const gradientEnd = colorArray[colorCount - 1];
  const skip = Math.ceil(colorCount / stops);
  const gradientStops = /* @__PURE__ */ new Set();
  for (let i = 0; i < colorCount; i += skip) {
    gradientStops.add(colorArray[i]);
  }
  gradientStops.add(gradientEnd);
  return [...gradientStops];
};
function clampPercent100(v) {
  if (v > 1) {
    return 100;
  }
  if (v < 0) {
    return 0;
  }
  return v * 100;
}
const getStyles = (theme, colors) => ({
  scaleWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    width: "100%",
    fontSize: "11px",
    opacity: 1
  }),
  scaleGradient: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    background: "linear-gradient(90deg, ".concat(colors.join(), ")"),
    height: "9px",
    pointerEvents: "none",
    borderRadius: theme.shape.radius.default
  }),
  legendValues: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    display: "flex",
    justifyContent: "space-between",
    pointerEvents: "none"
  }),
  hoverValue: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    position: "absolute",
    marginTop: "-14px",
    padding: "3px 15px",
    transform: "translateX(-50%)"
  }),
  followerContainer: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    position: "relative",
    pointerEvents: "none",
    whiteSpace: "nowrap"
  }),
  follower: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    position: "absolute",
    height: "13px",
    width: "13px",
    borderRadius: theme.shape.radius.default,
    transform: "translateX(-50%) translateY(-50%)",
    border: "2px solid ".concat(theme.colors.text.primary),
    top: "5px"
  }),
  disabled: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    color: theme.colors.text.disabled
  })
});


/***/ }),

/***/ "./public/app/core/components/Layers/AddLayerButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddLayerButton: () => (/* binding */ AddLayerButton)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/components/ValuePicker/ValuePicker.tsx");



const AddLayerButton = ({ onChange, options, label }) => {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_1__.ValuePicker,
    {
      icon: "plus",
      label,
      variant: "secondary",
      options,
      onChange,
      isFullWidth: true
    }
  );
};


/***/ }),

/***/ "./public/app/core/components/Layers/LayerDragDropList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATA_TEST_ID: () => (/* binding */ DATA_TEST_ID),
/* harmony export */   LayerDragDropList: () => (/* binding */ LayerDragDropList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/IconButton/IconButton.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/Icon/Icon.tsx");
/* harmony import */ var _LayerName__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/Layers/LayerName.tsx");






const DATA_TEST_ID = "layer-drag-drop-list";
const LayerDragDropList = ({
  layers,
  getLayerInfo,
  onDragEnd,
  onSelect,
  onDelete,
  onDuplicate,
  showActions,
  selection,
  excludeBaseLayer,
  onNameChange,
  verifyLayerNameUniqueness
}) => {
  const style = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const getRowStyle = (isSelected) => {
    return isSelected ? "".concat(style.row, " ").concat(style.sel) : style.row;
  };
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_4__.DragDropContext, { onDragEnd }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_4__.Droppable, { droppableId: "droppable" }, (provided, snapshot) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { ...provided.droppableProps, ref: provided.innerRef, "data-testid": DATA_TEST_ID }, (() => {
    const rows = [];
    const lastLayerIndex = excludeBaseLayer ? 1 : 0;
    const shouldRenderDragIconLengthThreshold = excludeBaseLayer ? 2 : 1;
    for (let i = layers.length - 1; i >= lastLayerIndex; i--) {
      const element = layers[i];
      const uid = element.getName();
      const isSelected = Boolean(selection == null ? void 0 : selection.includes(uid));
      rows.push(
        /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_4__.Draggable, { key: uid, draggableId: uid, index: rows.length }, (provided2, snapshot2) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
          "div",
          {
            className: getRowStyle(isSelected),
            ref: provided2.innerRef,
            ...provided2.draggableProps,
            ...provided2.dragHandleProps,
            onMouseDown: () => onSelect(element),
            role: "button",
            tabIndex: 0
          },
          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
            _LayerName__WEBPACK_IMPORTED_MODULE_2__.LayerName,
            {
              name: uid,
              onChange: (v) => onNameChange(element, v),
              verifyLayerNameUniqueness: verifyLayerNameUniqueness != null ? verifyLayerNameUniqueness : void 0
            }
          ),
          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: style.textWrapper }, "\xA0 ", getLayerInfo(element)),
          showActions(element) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, onDuplicate ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
            _grafana_ui__WEBPACK_IMPORTED_MODULE_5__.IconButton,
            {
              name: "copy",
              tooltip: "Duplicate",
              className: style.actionIcon,
              onClick: () => onDuplicate(element)
            }
          ) : null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
            _grafana_ui__WEBPACK_IMPORTED_MODULE_5__.IconButton,
            {
              name: "trash-alt",
              tooltip: "Remove",
              className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(style.actionIcon, style.dragIcon),
              onClick: () => onDelete(element)
            }
          )),
          layers.length > shouldRenderDragIconLengthThreshold && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
            _grafana_ui__WEBPACK_IMPORTED_MODULE_6__.Icon,
            {
              "aria-label": "Drag and drop icon",
              title: "Drag and drop to reorder",
              name: "draggabledots",
              size: "lg",
              className: style.dragIcon
            }
          )
        ))
      );
    }
    return rows;
  })(), provided.placeholder)));
};
const getStyles = (theme) => ({
  wrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    marginBottom: theme.spacing(2)
  }),
  row: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    padding: theme.spacing(0.5, 1),
    borderRadius: theme.shape.radius.default,
    background: theme.colors.background.secondary,
    minHeight: theme.spacing(4),
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: "3px",
    cursor: "pointer",
    border: "1px solid ".concat(theme.components.input.borderColor),
    "&:hover": {
      border: "1px solid ".concat(theme.components.input.borderHover)
    }
  }),
  sel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    border: "1px solid ".concat(theme.colors.primary.border),
    "&:hover": {
      border: "1px solid ".concat(theme.colors.primary.border)
    }
  }),
  dragIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    cursor: "drag"
  }),
  actionIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    color: theme.colors.text.secondary,
    "&:hover": {
      color: theme.colors.text.primary
    }
  }),
  typeWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    color: theme.colors.primary.text,
    marginRight: "5px"
  }),
  textWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    display: "flex",
    alignItems: "center",
    flexGrow: 1,
    overflow: "hidden",
    marginRight: theme.spacing(1)
  })
});


/***/ }),

/***/ "./public/app/core/components/Layers/LayerName.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayerName: () => (/* binding */ LayerName)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/components/Icon/Icon.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/components/Input/Input.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/FieldValidationMessage.tsx");




const LayerName = ({ name, onChange, verifyLayerNameUniqueness, overrideStyles }) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [validationError, setValidationError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
  const onEditLayer = (event) => {
    setIsEditing(true);
  };
  const onEndEditName = (newName) => {
    setIsEditing(false);
    if (validationError) {
      setValidationError(null);
      return;
    }
    if (name !== newName) {
      onChange(newName);
    }
  };
  const onInputChange = (event) => {
    const newName = event.currentTarget.value.trim();
    if (newName.length === 0) {
      setValidationError("An empty layer name is not allowed");
      return;
    }
    if (verifyLayerNameUniqueness && !verifyLayerNameUniqueness(newName) && newName !== name) {
      setValidationError("Layer name already exists");
      return;
    }
    if (validationError) {
      setValidationError(null);
    }
  };
  const onEditLayerBlur = (event) => {
    onEndEditName(event.currentTarget.value.trim());
  };
  const onKeyDown = (event) => {
    if (event.key === "Enter") {
      onEndEditName(event.currentTarget.value);
    }
  };
  const onFocus = (event) => {
    event.target.select();
  };
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.wrapper }, !isEditing && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    "button",
    {
      className: styles.layerNameWrapper,
      title: "Edit layer name",
      onClick: onEditLayer,
      "data-testid": "layer-name-div"
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: overrideStyles ? "" : styles.layerName }, name),
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, { name: "pen", className: styles.layerEditIcon, size: "sm" })
  ), isEditing && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input,
    {
      type: "text",
      defaultValue: name,
      onBlur: onEditLayerBlur,
      autoFocus: true,
      onKeyDown,
      onFocus,
      invalid: validationError !== null,
      onChange: onInputChange,
      className: styles.layerNameInput,
      "data-testid": "layer-name-input"
    }
  ), validationError && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.FieldValidationMessage, { horizontal: true }, validationError))));
};
const getStyles = (theme) => {
  return {
    wrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: "Wrapper",
      display: "flex",
      alignItems: "center",
      marginLeft: theme.spacing(0.5)
    }),
    layerNameWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: "flex",
      cursor: "pointer",
      border: "1px solid transparent",
      borderRadius: theme.shape.radius.default,
      alignItems: "center",
      padding: "0 0 0 ".concat(theme.spacing(0.5)),
      margin: 0,
      background: "transparent",
      "&:hover": {
        background: theme.colors.action.hover,
        border: "1px dashed ".concat(theme.colors.border.strong)
      },
      "&:focus": {
        border: "2px solid ".concat(theme.colors.primary.border)
      },
      "&:hover, &:focus": {
        ".query-name-edit-icon": {
          visibility: "visible"
        }
      }
    }),
    layerName: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontWeight: theme.typography.fontWeightMedium,
      color: theme.colors.primary.text,
      cursor: "pointer",
      overflow: "hidden",
      marginLeft: theme.spacing(0.5)
    }),
    layerEditIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(
      (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
        marginLeft: theme.spacing(2),
        visibility: "hidden"
      }),
      "query-name-edit-icon"
    ),
    layerNameInput: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      maxWidth: "300px",
      margin: "-4px 0"
    })
  };
};


/***/ }),

/***/ "./public/app/features/dimensions/editors/ColorDimensionEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorDimensionEditor: () => (/* binding */ ColorDimensionEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/ColorPicker/ColorPicker.tsx");
/* harmony import */ var _grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/components/MatchersUI/utils.ts");

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a, _b;




const fixedColorOption = {
  label: "Fixed color",
  value: "_____fixed_____"
};
const ColorDimensionEditor = (props) => {
  var _a2, _b2, _c;
  const { value, context, onChange, item } = props;
  const defaultColor = "dark-green";
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const fieldName = value == null ? void 0 : value.field;
  const isFixed = value && Boolean(!fieldName) && (value == null ? void 0 : value.fixed);
  const names = (0,_grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_3__.useFieldDisplayNames)(context.data);
  const selectOptions = (0,_grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_3__.useSelectOptions)(names, fieldName, fixedColorOption, void 0, (_a2 = item.settings) == null ? void 0 : _a2.baseNameMode);
  const onSelectChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (selection) => {
      var _a3;
      if (!selection) {
        onChange(void 0);
        return;
      }
      const field = selection.value;
      if (field && field !== fixedColorOption.value) {
        onChange({
          ...value,
          field
        });
      } else {
        const fixed = (_a3 = value == null ? void 0 : value.fixed) != null ? _a3 : defaultColor;
        onChange({
          ...value,
          field: void 0,
          fixed
        });
      }
    },
    [onChange, value]
  );
  const onColorChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (c) => {
      onChange({
        field: void 0,
        fixed: c != null ? c : defaultColor
      });
    },
    [onChange]
  );
  const selectedOption = isFixed ? fixedColorOption : selectOptions.find((v) => v.value === fieldName);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.container }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select,
    {
      value: selectedOption,
      options: selectOptions,
      onChange: onSelectChange,
      noOptionsMessage: "No fields found",
      isClearable: (_b2 = item.settings) == null ? void 0 : _b2.isClearable,
      placeholder: (_c = item.settings) == null ? void 0 : _c.placeholder
    }
  ), isFixed && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.picker }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.ColorPicker, { color: value == null ? void 0 : value.fixed, onChange: onColorChange, enableNamedColors: true }))));
};
const getStyles = (theme) => ({
  container: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_a || (_a = __template(["\n    display: flex;\n    flex-wrap: nowrap;\n    justify-content: flex-end;\n    align-items: center;\n  "]))),
  picker: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_b || (_b = __template(["\n    padding-left: 8px;\n  "])))
});


/***/ }),

/***/ "./public/app/features/dimensions/editors/IconSelector.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/services/backendSrv.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");




const IconSelector = ({ value, onChange }) => {
  const [icons, setIcons] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value ? [{ value, label: value }] : []);
  const [icon, setIcon] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();
  const iconRoot = window.__grafana_public_path__ + "img/icons/unicons/";
  const onChangeIcon = (value2) => {
    onChange(value2);
    setIcon(value2);
  };
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getBackendSrv)().get("".concat(iconRoot, "/index.json")).then((data) => {
      setIcons(
        data.files.map((icon2) => ({
          value: icon2,
          label: icon2
        }))
      );
    });
  }, [iconRoot]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select,
    {
      options: icons,
      value: icon,
      onChange: (selectedValue) => {
        onChangeIcon(selectedValue.value);
      }
    }
  );
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconSelector);


/***/ }),

/***/ "./public/app/features/dimensions/editors/ResourceDimensionEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResourceDimensionEditor: () => (/* binding */ ResourceDimensionEditor),
/* harmony export */   niceName: () => (/* binding */ niceName)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/RadioButtonGroup/RadioButtonGroup.tsx");
/* harmony import */ var _grafana_ui_src_components_MatchersUI_FieldNamePicker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-ui/src/components/MatchersUI/FieldNamePicker.tsx");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dimensions/types.ts");
/* harmony import */ var _ResourcePicker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/ResourcePicker.tsx");








const resourceOptions = [
  { label: "Fixed", value: _grafana_schema__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionMode.Fixed, description: "Fixed value" },
  { label: "Field", value: _grafana_schema__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionMode.Field, description: "Use a string field result" }
  //  { label: 'Mapping', value: ResourceDimensionMode.Mapping, description: 'Map the results of a value to an svg' },
];
const dummyFieldSettings = {
  settings: {}
};
const ResourceDimensionEditor = (props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  const { value, context, onChange, item } = props;
  const labelWidth = 9;
  const onModeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (mode2) => {
      onChange({
        ...value,
        mode: mode2
      });
    },
    [onChange, value]
  );
  const onFieldChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (field = "") => {
      onChange({
        ...value,
        field
      });
    },
    [onChange, value]
  );
  const onFixedChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (fixed) => {
      onChange({
        ...value,
        fixed: fixed != null ? fixed : ""
      });
    },
    [onChange, value]
  );
  const onClear = (event) => {
    event.stopPropagation();
    onChange({ mode: _grafana_schema__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionMode.Fixed, fixed: "", field: "" });
  };
  const mode = (_a = value == null ? void 0 : value.mode) != null ? _a : _grafana_schema__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionMode.Fixed;
  const showSourceRadio = (_c = (_b = item.settings) == null ? void 0 : _b.showSourceRadio) != null ? _c : true;
  const mediaType = (_e = (_d = item.settings) == null ? void 0 : _d.resourceType) != null ? _e : _types__WEBPACK_IMPORTED_MODULE_2__.MediaType.Icon;
  const folderName = (_g = (_f = item.settings) == null ? void 0 : _f.folderName) != null ? _g : ___WEBPACK_IMPORTED_MODULE_1__.ResourceFolderName.Icon;
  const maxFiles = (_h = item.settings) == null ? void 0 : _h.maxFiles;
  let srcPath = "";
  if (mediaType === _types__WEBPACK_IMPORTED_MODULE_2__.MediaType.Icon) {
    if (value == null ? void 0 : value.fixed) {
      srcPath = (0,___WEBPACK_IMPORTED_MODULE_1__.getPublicOrAbsoluteUrl)(value.fixed);
    } else if ((_i = item.settings) == null ? void 0 : _i.placeholderValue) {
      srcPath = (0,___WEBPACK_IMPORTED_MODULE_1__.getPublicOrAbsoluteUrl)(item.settings.placeholderValue);
    }
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, showSourceRadio && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.InlineField, { label: "Source", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.RadioButtonGroup, { value: mode, options: resourceOptions, onChange: onModeChange, fullWidth: true }))), mode !== _grafana_schema__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionMode.Fixed && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.InlineField, { label: "Field", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _grafana_ui_src_components_MatchersUI_FieldNamePicker__WEBPACK_IMPORTED_MODULE_8__.FieldNamePicker,
    {
      context,
      value: (_j = value.field) != null ? _j : "",
      onChange: onFieldChange,
      item: dummyFieldSettings
    }
  ))), mode === _grafana_schema__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionMode.Fixed && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _ResourcePicker__WEBPACK_IMPORTED_MODULE_3__.ResourcePicker,
    {
      onChange: onFixedChange,
      onClear,
      value: value == null ? void 0 : value.fixed,
      src: srcPath,
      placeholder: (_l = (_k = item.settings) == null ? void 0 : _k.placeholderText) != null ? _l : "Select a value",
      name: (_m = niceName(value == null ? void 0 : value.fixed)) != null ? _m : "",
      mediaType,
      folderName,
      size: _types__WEBPACK_IMPORTED_MODULE_2__.ResourcePickerSize.NORMAL,
      maxFiles
    }
  ), mode === _grafana_schema__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionMode.Mapping && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.InlineField, { label: "Mappings", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, "TODO mappings editor!"))));
};
function niceName(value) {
  if (!value) {
    return void 0;
  }
  const idx = value.lastIndexOf("/");
  if (idx > 0) {
    return value.substring(idx + 1);
  }
  return value;
}


/***/ }),

/***/ "./public/app/features/dimensions/editors/ScalarDimensionEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScalarDimensionEditor: () => (/* binding */ ScalarDimensionEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/RadioButtonGroup/RadioButtonGroup.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/components/MatchersUI/utils.ts");
/* harmony import */ var _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/OptionsUI/NumberInput.tsx");

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;







const fixedValueOption = {
  label: "Fixed value",
  value: "_____fixed_____"
};
const scalarOptions = [
  { label: "Mod", value: _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionMode.Mod, description: "Use field values, mod from max" },
  { label: "Clamped", value: _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionMode.Clamped, description: "Use field values, clamped to max and min" }
];
const ScalarDimensionEditor = ({ value, context, onChange, item }) => {
  var _a2, _b;
  const { settings } = item;
  const DEFAULT_VALUE = 0;
  const fieldName = value == null ? void 0 : value.field;
  const isFixed = Boolean(!fieldName);
  const names = (0,_grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_4__.useFieldDisplayNames)(context.data);
  const selectOptions = (0,_grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_4__.useSelectOptions)(names, fieldName, fixedValueOption, _grafana_data__WEBPACK_IMPORTED_MODULE_5__.FieldType.number);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.useStyles2)(getStyles);
  const onSelectChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (selection) => {
      var _a3;
      const field = selection.value;
      if (field && field !== fixedValueOption.value) {
        onChange({
          ...value,
          field
        });
      } else {
        const fixed = (_a3 = value.fixed) != null ? _a3 : DEFAULT_VALUE;
        onChange({
          ...value,
          field: void 0,
          fixed
        });
      }
    },
    [onChange, value]
  );
  const onModeChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (mode2) => {
      onChange({
        ...value,
        mode: mode2
      });
    },
    [onChange, value]
  );
  const onValueChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (v) => {
      onChange({
        ...value,
        field: void 0,
        fixed: v != null ? v : DEFAULT_VALUE
      });
    },
    [onChange, value]
  );
  const val = value != null ? value : {};
  const mode = (_a2 = value == null ? void 0 : value.mode) != null ? _a2 : _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionMode.Mod;
  const selectedOption = isFixed ? fixedValueOption : selectOptions.find((v) => v.value === fieldName);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_8__.InlineField, { label: "Limit", labelWidth: 8, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_9__.RadioButtonGroup, { value: mode, options: scalarOptions, onChange: onModeChange, fullWidth: true }))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_10__.Select,
    {
      value: selectedOption,
      options: selectOptions,
      onChange: onSelectChange,
      noOptionsMessage: "No fields found"
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.range }, isFixed && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_8__.InlineField, { label: "Value", labelWidth: 8, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__.NumberInput,
    {
      value: (_b = val == null ? void 0 : val.fixed) != null ? _b : DEFAULT_VALUE,
      onChange: onValueChange,
      max: settings == null ? void 0 : settings.max,
      min: settings == null ? void 0 : settings.min
    }
  )))));
};
const getStyles = (theme) => ({
  range: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_a || (_a = __template(["\n    padding-top: 8px;\n  "])))
});


/***/ }),

/***/ "./public/app/features/dimensions/editors/ScaleDimensionEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScaleDimensionEditor: () => (/* binding */ ScaleDimensionEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/MatchersUI/utils.ts");
/* harmony import */ var _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/OptionsUI/NumberInput.tsx");
/* harmony import */ var _scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/scale.ts");

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;






const fixedValueOption = {
  label: "Fixed value",
  value: "_____fixed_____"
};
const ScaleDimensionEditor = (props) => {
  const { value, context, onChange, item } = props;
  const { settings } = item;
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  const fieldName = value == null ? void 0 : value.field;
  const isFixed = Boolean(!fieldName);
  const names = (0,_grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_5__.useFieldDisplayNames)(context.data);
  const selectOptions = (0,_grafana_ui_src_components_MatchersUI_utils__WEBPACK_IMPORTED_MODULE_5__.useSelectOptions)(names, fieldName, fixedValueOption, settings == null ? void 0 : settings.filteredFieldType);
  const minMaxStep = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    return (0,_scale__WEBPACK_IMPORTED_MODULE_3__.validateScaleOptions)(settings);
  }, [settings]);
  const validateAndDoChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (v) => {
      onChange((0,_scale__WEBPACK_IMPORTED_MODULE_3__.validateScaleConfig)(v, minMaxStep));
    },
    [onChange, minMaxStep]
  );
  const onSelectChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (selection) => {
      const field = selection.value;
      if (field && field !== fixedValueOption.value) {
        validateAndDoChange({
          ...value,
          field
        });
      } else {
        validateAndDoChange({
          ...value,
          field: void 0
        });
      }
    },
    [validateAndDoChange, value]
  );
  const onMinChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (min) => {
      if (min !== void 0) {
        validateAndDoChange({
          ...value,
          min
        });
      }
    },
    [validateAndDoChange, value]
  );
  const onMaxChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (max) => {
      if (max !== void 0) {
        validateAndDoChange({
          ...value,
          max
        });
      }
    },
    [validateAndDoChange, value]
  );
  const onValueChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (fixed) => {
      if (fixed !== void 0) {
        validateAndDoChange({
          ...value,
          fixed
        });
      }
    },
    [validateAndDoChange, value]
  );
  const val = value != null ? value : {};
  const selectedOption = isFixed ? fixedValueOption : selectOptions.find((v) => v.value === fieldName);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_6__.Select,
    {
      value: selectedOption,
      options: selectOptions,
      onChange: onSelectChange,
      noOptionsMessage: "No fields found"
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.range }, isFixed && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_8__.InlineField, { label: "Value", labelWidth: 8, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__.NumberInput, { value: val.fixed, ...minMaxStep, onChange: onValueChange }))), !isFixed && !minMaxStep.hideRange && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_8__.InlineField, { label: "Min", labelWidth: 8, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__.NumberInput, { value: val.min, ...minMaxStep, onChange: onMinChange }))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_8__.InlineField, { label: "Max", labelWidth: 8, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__.NumberInput, { value: val.max, ...minMaxStep, onChange: onMaxChange }))))));
};
const getStyles = (theme) => ({
  range: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_a || (_a = __template(["\n    padding-top: 8px;\n  "])))
});


/***/ }),

/***/ "./public/app/features/dimensions/editors/TextDimensionEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextDimensionEditor: () => (/* binding */ TextDimensionEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/RadioButtonGroup/RadioButtonGroup.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-ui/src/components/Button/Button.tsx");
/* harmony import */ var _grafana_ui_src_components_MatchersUI_FieldNamePicker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/MatchersUI/FieldNamePicker.tsx");
/* harmony import */ var _core_components_OptionsUI_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/core/components/OptionsUI/string.tsx");






const textOptions = [
  { label: "Fixed", value: _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.TextDimensionMode.Fixed, description: "Fixed value" },
  { label: "Field", value: _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.TextDimensionMode.Field, description: "Display field value" }
  //  { label: 'Template', value: TextDimensionMode.Template, description: 'use template text' },
];
const dummyFieldSettings = {
  settings: {}
};
const dummyStringSettings = {
  settings: {}
};
const TextDimensionEditor = ({ value, context, onChange }) => {
  var _a, _b;
  const labelWidth = 9;
  const onModeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (mode2) => {
      onChange({
        ...value,
        mode: mode2
      });
    },
    [onChange, value]
  );
  const onFieldChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (field) => {
      onChange({
        ...value,
        field
      });
    },
    [onChange, value]
  );
  const onFixedChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (fixed = "") => {
      onChange({
        ...value,
        fixed
      });
    },
    [onChange, value]
  );
  const onClearFixed = () => {
    onFixedChange("");
  };
  const mode = (_a = value == null ? void 0 : value.mode) != null ? _a : _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.TextDimensionMode.Fixed;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, { label: "Source", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.RadioButtonGroup, { value: mode, options: textOptions, onChange: onModeChange, fullWidth: true }))), mode !== _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.TextDimensionMode.Fixed && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, { label: "Field", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _grafana_ui_src_components_MatchersUI_FieldNamePicker__WEBPACK_IMPORTED_MODULE_6__.FieldNamePicker,
    {
      context,
      value: (_b = value.field) != null ? _b : "",
      onChange: onFieldChange,
      item: dummyFieldSettings
    }
  ))), mode === _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.TextDimensionMode.Fixed && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFieldRow, { key: value == null ? void 0 : value.fixed }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, { label: "Value", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _core_components_OptionsUI_string__WEBPACK_IMPORTED_MODULE_1__.StringValueEditor,
    {
      context,
      value: value == null ? void 0 : value.fixed,
      onChange: onFixedChange,
      item: dummyStringSettings,
      suffix: (value == null ? void 0 : value.fixed) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.Button, { icon: "times", variant: "secondary", fill: "text", size: "sm", onClick: onClearFixed })
    }
  ))), mode === _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.TextDimensionMode.Template && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, { label: "Template", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _core_components_OptionsUI_string__WEBPACK_IMPORTED_MODULE_1__.StringValueEditor,
    {
      context,
      value: value == null ? void 0 : value.fixed,
      onChange: onFixedChange,
      item: dummyStringSettings
    }
  ))));
};


/***/ }),

/***/ "./public/app/features/dimensions/editors/index.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorDimensionEditor: () => (/* reexport safe */ _ColorDimensionEditor__WEBPACK_IMPORTED_MODULE_0__.ColorDimensionEditor),
/* harmony export */   ResourceDimensionEditor: () => (/* reexport safe */ _ResourceDimensionEditor__WEBPACK_IMPORTED_MODULE_2__.ResourceDimensionEditor),
/* harmony export */   ScalarDimensionEditor: () => (/* reexport safe */ _ScalarDimensionEditor__WEBPACK_IMPORTED_MODULE_4__.ScalarDimensionEditor),
/* harmony export */   ScaleDimensionEditor: () => (/* reexport safe */ _ScaleDimensionEditor__WEBPACK_IMPORTED_MODULE_3__.ScaleDimensionEditor),
/* harmony export */   TextDimensionEditor: () => (/* reexport safe */ _TextDimensionEditor__WEBPACK_IMPORTED_MODULE_5__.TextDimensionEditor),
/* harmony export */   niceName: () => (/* reexport safe */ _ResourceDimensionEditor__WEBPACK_IMPORTED_MODULE_2__.niceName)
/* harmony export */ });
/* harmony import */ var _ColorDimensionEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/dimensions/editors/ColorDimensionEditor.tsx");
/* harmony import */ var _IconSelector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/editors/IconSelector.tsx");
/* harmony import */ var _ResourceDimensionEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dimensions/editors/ResourceDimensionEditor.tsx");
/* harmony import */ var _ScaleDimensionEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/ScaleDimensionEditor.tsx");
/* harmony import */ var _ScalarDimensionEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/dimensions/editors/ScalarDimensionEditor.tsx");
/* harmony import */ var _TextDimensionEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/dimensions/editors/TextDimensionEditor.tsx");









/***/ }),

/***/ "./public/app/features/geo/editor/GazetteerPathEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GazetteerPathEditor: () => (/* binding */ GazetteerPathEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/Alert/Alert.tsx");
/* harmony import */ var _gazetteer_gazetteer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/geo/gazetteer/gazetteer.ts");

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;




const defaultPaths = [
  {
    label: "Countries",
    description: "Lookup countries by name, two letter code, or three letter code",
    value: _gazetteer_gazetteer__WEBPACK_IMPORTED_MODULE_2__.COUNTRIES_GAZETTEER_PATH
  },
  {
    label: "USA States",
    description: "Lookup states by name or 2 ",
    value: "public/gazetteer/usa-states.json"
  },
  {
    label: "Airports",
    description: "Lookup airports by id or code",
    value: "public/gazetteer/airports.geojson"
  }
];
const GazetteerPathEditor = ({
  value,
  onChange,
  context,
  item
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const [gaz, setGaz] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();
  const settings = item.settings;
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    async function fetchData() {
      const p = await (0,_gazetteer_gazetteer__WEBPACK_IMPORTED_MODULE_2__.getGazetteer)(value);
      setGaz(p);
    }
    fetchData();
  }, [value, setGaz]);
  const { current, options } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    let options2 = (settings == null ? void 0 : settings.options) ? [...settings.options] : [...defaultPaths];
    let current2 = options2 == null ? void 0 : options2.find((f) => f.value === (gaz == null ? void 0 : gaz.path));
    if (!current2 && gaz) {
      current2 = {
        label: gaz.path,
        value: gaz.path
      };
      options2.push(current2);
    }
    return { options: options2, current: current2 };
  }, [gaz, settings == null ? void 0 : settings.options]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select,
    {
      value: current,
      options,
      onChange: (v) => onChange(v.value),
      allowCustomValue: true,
      formatCreateLabel: (txt) => "Load from URL: ".concat(txt)
    }
  ), gaz && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, gaz.error && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Alert, { title: gaz.error, severity: "warning" }), gaz.count && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.keys }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("b", null, "(", gaz.count, ")"), gaz.examples(10).map((k) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { key: k }, k, ",")), gaz.count > 10 && " ...")));
};
const getStyles = () => ({
  keys: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_a || (_a = __template(["\n    margin-top: 4px;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n\n    > span {\n      margin-left: 4px;\n    }\n  "])))
});


/***/ }),

/***/ "./public/app/features/geo/editor/locationEditor.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addLocationFields: () => (/* binding */ addLocationFields)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _GazetteerPathEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/geo/editor/GazetteerPathEditor.tsx");
/* harmony import */ var _locationModeEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/geo/editor/locationModeEditor.tsx");





function addLocationFields(title, prefix, builder, source, data) {
  builder.addCustomEditor({
    id: "modeEditor",
    path: "".concat(prefix, "mode"),
    name: "Location Mode",
    editor: _locationModeEditor__WEBPACK_IMPORTED_MODULE_1__.LocationModeEditor,
    settings: { data, source }
  });
  switch (source == null ? void 0 : source.mode) {
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.FrameGeometrySourceMode.Coords:
      builder.addFieldNamePicker({
        path: "".concat(prefix, "latitude"),
        name: "Latitude field",
        settings: {
          filter: (f) => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number,
          noFieldsMessage: "No numeric fields found"
        }
      }).addFieldNamePicker({
        path: "".concat(prefix, "longitude"),
        name: "Longitude field",
        settings: {
          filter: (f) => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number,
          noFieldsMessage: "No numeric fields found"
        }
      });
      break;
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.FrameGeometrySourceMode.Geohash:
      builder.addFieldNamePicker({
        path: "".concat(prefix, "geohash"),
        name: "Geohash field",
        settings: {
          filter: (f) => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string,
          noFieldsMessage: "No strings fields found"
        }
      });
      break;
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.FrameGeometrySourceMode.Lookup:
      builder.addFieldNamePicker({
        path: "".concat(prefix, "lookup"),
        name: "Lookup field",
        settings: {
          filter: (f) => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string,
          noFieldsMessage: "No strings fields found"
        }
      }).addCustomEditor({
        id: "gazetteer",
        path: "".concat(prefix, "gazetteer"),
        name: "Gazetteer",
        editor: _GazetteerPathEditor__WEBPACK_IMPORTED_MODULE_0__.GazetteerPathEditor
      });
  }
}


/***/ }),

/***/ "./public/app/features/geo/editor/locationModeEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LocationModeEditor: () => (/* binding */ LocationModeEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-e2e-selectors/src/selectors/index.ts");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/Alert/Alert.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-ui/src/components/Icon/Icon.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-ui/src/components/Layout/Layout.tsx");
/* harmony import */ var _utils_location__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/geo/utils/location.ts");

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a, _b;






const MODE_OPTIONS = [
  {
    value: _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Auto,
    label: "Auto",
    ariaLabel: _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_4__.selectors.components.Transforms.SpatialOperations.location.autoOption,
    description: "Automatically identify location data based on default field names"
  },
  {
    value: _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Coords,
    label: "Coords",
    ariaLabel: _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_4__.selectors.components.Transforms.SpatialOperations.location.coords.option,
    description: "Specify latitude and longitude fields"
  },
  {
    value: _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Geohash,
    label: "Geohash",
    ariaLabel: _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_4__.selectors.components.Transforms.SpatialOperations.location.geohash.option,
    description: "Specify geohash field"
  },
  {
    value: _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Lookup,
    label: "Lookup",
    ariaLabel: _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_4__.selectors.components.Transforms.SpatialOperations.location.lookup.option,
    description: "Specify Gazetteer and lookup field"
  }
];
const helpUrl = "https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/geomap/#location";
const LocationModeEditor = ({
  value,
  onChange,
  context,
  item
}) => {
  const [info, setInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    var _a2, _b2, _c;
    if (((_a2 = item.settings) == null ? void 0 : _a2.source) && ((_c = (_b2 = item.settings) == null ? void 0 : _b2.data) == null ? void 0 : _c.length) && item.settings.data[0]) {
      (0,_utils_location__WEBPACK_IMPORTED_MODULE_2__.getLocationMatchers)(item.settings.source).then((location) => {
        if (item.settings && item.settings.data) {
          setInfo((0,_utils_location__WEBPACK_IMPORTED_MODULE_2__.getGeometryField)(item.settings.data[0], location));
        }
      });
    }
  }, [item.settings]);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.useStyles2)(getStyles);
  const dataValidation = () => {
    if (info) {
      if (info.warning) {
        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
          _grafana_ui__WEBPACK_IMPORTED_MODULE_6__.Alert,
          {
            title: info.warning,
            severity: "warning",
            buttonContent: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.Icon, { name: "question-circle", size: "xl" }),
            className: styles.alert,
            onRemove: () => {
              const newWindow = window.open(helpUrl, "_blank", "noopener,noreferrer");
              if (newWindow) {
                newWindow.opener = null;
              }
            }
          }
        );
      } else if (value === _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Auto && info.description) {
        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", null, info.description);
      }
    }
    return null;
  };
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_8__.Select,
    {
      options: MODE_OPTIONS,
      value,
      onChange: (v) => {
        onChange(v.value);
      }
    }
  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_9__.HorizontalGroup, { className: styles.hGroup }, dataValidation()));
};
const getStyles = (theme) => {
  return {
    alert: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_a || (_a = __template(["\n      & div {\n        padding: 4px;\n      }\n      margin-bottom: 0px;\n      margin-top: 5px;\n      padding: 2px;\n    "]))),
    // TODO apply styling to horizontal group (currently not working)
    hGroup: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_b || (_b = __template(["\n      & div {\n        width: 100%;\n      }\n    "])))
  };
};


/***/ }),

/***/ "./public/app/features/geo/format/geohash.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decodeGeohash: () => (/* binding */ decodeGeohash)
/* harmony export */ });

function decodeGeohash(geohash) {
  if (!(geohash == null ? void 0 : geohash.length)) {
    return void 0;
  }
  const BITS = [16, 8, 4, 2, 1];
  const BASE32 = "0123456789bcdefghjkmnpqrstuvwxyz";
  let isEven = true;
  const lat = [];
  const lon = [];
  lat[0] = -90;
  lat[1] = 90;
  lon[0] = -180;
  lon[1] = 180;
  let base32Decoded;
  geohash.split("").forEach((item) => {
    base32Decoded = BASE32.indexOf(item);
    BITS.forEach((mask) => {
      if (isEven) {
        refineInterval(lon, base32Decoded, mask);
      } else {
        refineInterval(lat, base32Decoded, mask);
      }
      isEven = !isEven;
    });
  });
  const latCenter = (lat[0] + lat[1]) / 2;
  const lonCenter = (lon[0] + lon[1]) / 2;
  return [lonCenter, latCenter];
}
function refineInterval(interval, base32Decoded, mask) {
  if (base32Decoded & mask) {
    interval[0] = (interval[0] + interval[1]) / 2;
  } else {
    interval[1] = (interval[0] + interval[1]) / 2;
  }
}


/***/ }),

/***/ "./public/app/features/geo/format/geojson.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   frameFromGeoJSON: () => (/* binding */ frameFromGeoJSON)
/* harmony export */ });
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/format/GeoJSON.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/dataframe/processDataFrame.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");



function frameFromGeoJSON(body) {
  const data = new ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0__["default"]().readFeatures(body, { featureProjection: "EPSG:3857" });
  const length = data.length;
  const geo = new Array(length).fill(null);
  const fieldOrder = [];
  const lookup = /* @__PURE__ */ new Map();
  const getField = (name) => {
    let f = lookup.get(name);
    if (!f) {
      f = {
        types: /* @__PURE__ */ new Set(),
        values: new Array(length).fill(null),
        count: 0
      };
      fieldOrder.push(name);
      lookup.set(name, f);
    }
    return f;
  };
  const getBestName = (...names) => {
    for (const k of names) {
      if (!lookup.has(k)) {
        return k;
      }
    }
    return "___" + names[0];
  };
  const idfield = {
    types: /* @__PURE__ */ new Set(),
    values: new Array(length).fill(null),
    count: 0
  };
  for (let i = 0; i < length; i++) {
    const feature = data[i];
    geo[i] = feature.getGeometry();
    const id = feature.getId();
    if (id != null) {
      idfield.values[i] = id;
      idfield.types.add((0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.getFieldTypeFromValue)(id));
      idfield.count++;
    }
    for (const key of feature.getKeys()) {
      const val = feature.get(key);
      if (val === geo[i] || val == null) {
        continue;
      }
      const field = getField(key);
      field.values[i] = val;
      field.types.add((0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.getFieldTypeFromValue)(val));
      field.count++;
    }
  }
  const fields = [];
  if (idfield.count > 0) {
    const type = ensureSingleType(idfield);
    fields.push({
      name: getBestName("id", "_id", "__id"),
      type,
      values: idfield.values,
      config: {}
    });
  }
  fields.push({
    name: getBestName("geo", "geometry"),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.geo,
    values: geo,
    config: {}
  });
  for (const name of fieldOrder) {
    const info = lookup.get(name);
    if (!info) {
      continue;
    }
    const type = ensureSingleType(info);
    fields.push({
      name,
      type,
      values: info.values,
      config: {}
    });
  }
  return {
    fields,
    length
  };
}
function ensureSingleType(info) {
  if (info.count < 1) {
    return _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.other;
  }
  if (info.types.size > 1) {
    info.values = info.values.map((v) => {
      if (v != null) {
        return "".concat(v);
      }
      return v;
    });
    return _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string;
  }
  return info.types.values().next().value;
}


/***/ }),

/***/ "./public/app/features/geo/format/utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createGeometryCollection: () => (/* binding */ createGeometryCollection),
/* harmony export */   createLineBetween: () => (/* binding */ createLineBetween),
/* harmony export */   getGeoFieldFromGazetteer: () => (/* binding */ getGeoFieldFromGazetteer),
/* harmony export */   pointFieldFromGeohash: () => (/* binding */ pointFieldFromGeohash),
/* harmony export */   pointFieldFromLonLat: () => (/* binding */ pointFieldFromLonLat)
/* harmony export */ });
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/geom/GeometryCollection.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _transformers_spatial_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/transformers/spatial/utils.ts");
/* harmony import */ var _geohash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/geo/format/geohash.ts");






function pointFieldFromGeohash(geohash) {
  var _a;
  return {
    name: (_a = geohash.name) != null ? _a : "Point",
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.geo,
    values: geohash.values.map((v) => {
      const coords = (0,_geohash__WEBPACK_IMPORTED_MODULE_2__.decodeGeohash)(v);
      if (coords) {
        return new ol_geom__WEBPACK_IMPORTED_MODULE_4__["default"]((0,ol_proj__WEBPACK_IMPORTED_MODULE_0__.fromLonLat)(coords));
      }
      return void 0;
    }),
    config: hiddenTooltipField
  };
}
function pointFieldFromLonLat(lon, lat) {
  const buffer = new Array(lon.values.length);
  for (let i = 0; i < lon.values.length; i++) {
    const longitude = lon.values[i];
    const latitude = lat.values[i];
    if (longitude === null || latitude === null) {
      continue;
    }
    buffer[i] = new ol_geom__WEBPACK_IMPORTED_MODULE_4__["default"]((0,ol_proj__WEBPACK_IMPORTED_MODULE_0__.fromLonLat)([longitude, latitude]));
  }
  return {
    name: "Point",
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.geo,
    values: buffer,
    config: hiddenTooltipField
  };
}
function getGeoFieldFromGazetteer(gaz, field) {
  var _a;
  const count = field.values.length;
  const geo = new Array(count);
  for (let i = 0; i < count; i++) {
    geo[i] = (_a = gaz.find(field.values[i])) == null ? void 0 : _a.geometry();
  }
  return {
    name: "Geometry",
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.geo,
    values: geo,
    config: hiddenTooltipField
  };
}
function createGeometryCollection(src, dest) {
  const v0 = src.values;
  const v1 = dest.values;
  if (!v0 || !v1) {
    throw "missing src/dest";
  }
  if (v0.length !== v1.length) {
    throw "Source and destination field lengths do not match";
  }
  const count = src.values.length;
  const geo = new Array(count);
  for (let i = 0; i < count; i++) {
    const a = v0[i];
    const b = v1[i];
    if (a && b) {
      geo[i] = new ol_geom__WEBPACK_IMPORTED_MODULE_5__["default"]([a, b]);
    } else if (a) {
      geo[i] = a;
    } else if (b) {
      geo[i] = b;
    }
  }
  return {
    name: "Geometry",
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.geo,
    values: geo,
    config: hiddenTooltipField
  };
}
function createLineBetween(src, dest) {
  const v0 = src.values;
  const v1 = dest.values;
  if (!v0 || !v1) {
    throw "missing src/dest";
  }
  if (v0.length !== v1.length) {
    throw "Source and destination field lengths do not match";
  }
  const count = src.values.length;
  const geo = new Array(count);
  for (let i = 0; i < count; i++) {
    const a = v0[i];
    const b = v1[i];
    if (a && b) {
      geo[i] = new ol_geom__WEBPACK_IMPORTED_MODULE_6__["default"]([(0,_transformers_spatial_utils__WEBPACK_IMPORTED_MODULE_1__.getCenterPoint)(a), (0,_transformers_spatial_utils__WEBPACK_IMPORTED_MODULE_1__.getCenterPoint)(b)]);
    }
  }
  return {
    name: "Geometry",
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.geo,
    values: geo,
    config: hiddenTooltipField
  };
}
const hiddenTooltipField = Object.freeze({
  custom: {
    hideFrom: { tooltip: true }
  }
});


/***/ }),

/***/ "./public/app/features/geo/gazetteer/gazetteer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COUNTRIES_GAZETTEER_PATH: () => (/* binding */ COUNTRIES_GAZETTEER_PATH),
/* harmony export */   frameAsGazetter: () => (/* binding */ frameAsGazetter),
/* harmony export */   getGazetteer: () => (/* binding */ getGazetteer),
/* harmony export */   loadGazetteer: () => (/* binding */ loadGazetteer)
/* harmony export */ });
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/dataframe/processDataFrame.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-runtime/src/services/backendSrv.ts");
/* harmony import */ var _format_geojson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/geo/format/geojson.ts");
/* harmony import */ var _format_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/geo/format/utils.ts");
/* harmony import */ var _worldmap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/geo/gazetteer/worldmap.ts");








function loadGazetteer(path, data) {
  let frame = void 0;
  if (Array.isArray(data)) {
    const first = data[0];
    if (first.latitude && first.longitude && (first.key || first.keys)) {
      return (0,_worldmap__WEBPACK_IMPORTED_MODULE_2__.loadWorldmapPoints)(path, data);
    }
  } else {
    if (Array.isArray(data == null ? void 0 : data.features) && (data == null ? void 0 : data.type) === "FeatureCollection") {
      frame = (0,_format_geojson__WEBPACK_IMPORTED_MODULE_0__.frameFromGeoJSON)(data);
    }
  }
  if (!frame) {
    try {
      frame = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.toDataFrame)(data);
    } catch (ex) {
      return {
        path,
        error: "".concat(ex),
        find: (k) => void 0,
        examples: (v) => []
      };
    }
  }
  return frameAsGazetter(frame, { path });
}
function frameAsGazetter(frame, opts) {
  var _a;
  const keys = [];
  let geo = void 0;
  let lat = void 0;
  let lng = void 0;
  let geohash = void 0;
  let firstString = void 0;
  for (const f of frame.fields) {
    if (f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldType.geo) {
      geo = f;
    }
    if (!firstString && f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldType.string) {
      firstString = f;
    }
    if (f.name) {
      if (opts.keys && opts.keys.includes(f.name)) {
        keys.push(f);
      }
      const name = f.name.toUpperCase();
      switch (name) {
        case "LAT":
        case "LATITUTE":
          lat = f;
          break;
        case "LON":
        case "LNG":
        case "LONG":
        case "LONGITUE":
          lng = f;
          break;
        case "GEOHASH":
          geohash = f;
          break;
        case "ID":
        case "UID":
        case "KEY":
        case "CODE":
          if (!opts.keys) {
            keys.push(f);
          }
          break;
        default: {
          if (!opts.keys) {
            if (name.endsWith("_ID") || name.endsWith("_CODE")) {
              keys.push(f);
            }
          }
        }
      }
    }
  }
  if (!keys.length && firstString) {
    keys.push(firstString);
  }
  let isPoint = false;
  if (!geo) {
    if (geohash) {
      geo = (0,_format_utils__WEBPACK_IMPORTED_MODULE_1__.pointFieldFromGeohash)(geohash);
      isPoint = true;
    } else if (lat && lng) {
      geo = (0,_format_utils__WEBPACK_IMPORTED_MODULE_1__.pointFieldFromLonLat)(lng, lat);
      isPoint = true;
    }
  } else {
    isPoint = ((_a = geo.values[0]) == null ? void 0 : _a.getType()) === "Point";
  }
  const lookup = /* @__PURE__ */ new Map();
  keys.forEach((f) => {
    f.values.forEach((k, idx) => {
      const str = "".concat(k);
      lookup.set(str.toUpperCase(), idx);
      lookup.set(str, idx);
    });
  });
  return {
    path: opts.path,
    find: (k) => {
      const index = lookup.get(k);
      if (index != null) {
        const g = geo == null ? void 0 : geo.values[index];
        return {
          frame,
          index,
          point: () => {
            if (!g || isPoint) {
              return g;
            }
            return new ol_geom__WEBPACK_IMPORTED_MODULE_5__["default"]((0,ol_extent__WEBPACK_IMPORTED_MODULE_6__.getCenter)(g.getExtent()));
          },
          geometry: () => g
        };
      }
      return void 0;
    },
    examples: (v) => {
      const ex = [];
      for (let k of lookup.keys()) {
        ex.push(k);
        if (ex.length > v) {
          break;
        }
      }
      return ex;
    },
    frame: () => frame,
    count: frame.length
  };
}
const registry = {};
const COUNTRIES_GAZETTEER_PATH = "public/gazetteer/countries.json";
async function getGazetteer(path) {
  if (!path) {
    path = COUNTRIES_GAZETTEER_PATH;
  }
  let lookup = registry[path];
  if (!lookup) {
    try {
      const data = await (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_7__.getBackendSrv)().get(path);
      lookup = loadGazetteer(path, data);
    } catch (err) {
      console.warn("Error loading placename lookup", path, err);
      lookup = {
        path,
        error: "Error loading URL",
        find: (k) => void 0,
        examples: (v) => []
      };
    }
    registry[path] = lookup;
  }
  return lookup;
}


/***/ }),

/***/ "./public/app/features/geo/gazetteer/worldmap.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadWorldmapPoints: () => (/* binding */ loadWorldmapPoints)
/* harmony export */ });
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");



function loadWorldmapPoints(path, data) {
  let count = 0;
  const values = /* @__PURE__ */ new Map();
  for (const v of data) {
    const point = new ol_geom__WEBPACK_IMPORTED_MODULE_1__["default"]((0,ol_proj__WEBPACK_IMPORTED_MODULE_0__.fromLonLat)([v.longitude, v.latitude]));
    const info = {
      point: () => point,
      geometry: () => point
    };
    if (v.name) {
      values.set(v.name, info);
      values.set(v.name.toUpperCase(), info);
    }
    if (v.key) {
      values.set(v.key, info);
      values.set(v.key.toUpperCase(), info);
    }
    if (v.keys) {
      for (const key of v.keys) {
        values.set(key, info);
        values.set(key.toUpperCase(), info);
      }
    }
    count++;
  }
  return {
    path,
    find: (k) => {
      let v = values.get(k);
      if (!v && typeof k === "string") {
        v = values.get(k.toUpperCase());
      }
      return v;
    },
    count,
    examples: (count2) => {
      const first = [];
      if (values.size < 1) {
        first.push("no values found");
      } else {
        for (const key of values.keys()) {
          first.push(key);
          if (first.length >= count2) {
            break;
          }
        }
      }
      return first;
    }
  };
}


/***/ }),

/***/ "./public/app/features/geo/utils/frameVectorSource.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FrameVectorSource: () => (/* binding */ FrameVectorSource)
/* harmony export */ });
/* harmony import */ var ol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/geo/utils/location.ts");





class FrameVectorSource extends ol_source_Vector__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(location) {
    super({});
    this.location = location;
  }
  update(frame) {
    this.clear(true);
    const info = (0,_location__WEBPACK_IMPORTED_MODULE_0__.getGeometryField)(frame, this.location);
    if (!info.field) {
      this.changed();
      return;
    }
    for (let i = 0; i < frame.length; i++) {
      this.addFeatureInternal(
        new ol__WEBPACK_IMPORTED_MODULE_2__["default"]({
          frame,
          rowIndex: i,
          geometry: info.field.values[i]
        })
      );
    }
    this.changed();
  }
  updateLineString(frame) {
    this.clear(true);
    const info = (0,_location__WEBPACK_IMPORTED_MODULE_0__.getGeometryField)(frame, this.location);
    if (!info.field) {
      this.changed();
      return;
    }
    const field = info.field;
    const geometry = new ol_geom__WEBPACK_IMPORTED_MODULE_3__["default"](field.values.map((p) => p.getCoordinates()));
    this.addFeatureInternal(
      new ol__WEBPACK_IMPORTED_MODULE_2__["default"]({
        frame,
        rowIndex: 0,
        geometry
      })
    );
    this.changed();
  }
}


/***/ }),

/***/ "./public/app/features/geo/utils/location.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGeometryField: () => (/* binding */ getGeometryField),
/* harmony export */   getLocationFields: () => (/* binding */ getLocationFields),
/* harmony export */   getLocationMatchers: () => (/* binding */ getLocationMatchers)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/field/fieldState.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/transformations/matchers.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-data/src/transformations/matchers/ids.ts");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _format_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/geo/format/utils.ts");
/* harmony import */ var _gazetteer_gazetteer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/geo/gazetteer/gazetteer.ts");





function getFieldFinder(matcher) {
  return (frame) => {
    for (const field of frame.fields) {
      if (matcher(field, frame, [])) {
        return field;
      }
    }
    return void 0;
  };
}
function matchLowerNames(names) {
  return (frame) => {
    for (const field of frame.fields) {
      if (names.has(field.name.toLowerCase())) {
        return field;
      }
      const disp = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.getFieldDisplayName)(field, frame);
      if (names.has(disp)) {
        return field;
      }
    }
    return void 0;
  };
}
const defaultMatchers = {
  mode: _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Auto,
  geohash: matchLowerNames(/* @__PURE__ */ new Set(["geohash"])),
  latitude: matchLowerNames(/* @__PURE__ */ new Set(["latitude", "lat"])),
  longitude: matchLowerNames(/* @__PURE__ */ new Set(["longitude", "lon", "lng"])),
  h3: matchLowerNames(/* @__PURE__ */ new Set(["h3"])),
  wkt: matchLowerNames(/* @__PURE__ */ new Set(["wkt"])),
  lookup: matchLowerNames(/* @__PURE__ */ new Set(["lookup"])),
  geo: (frame) => frame.fields.find((f) => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldType.geo)
};
async function getLocationMatchers(src) {
  var _a, _b;
  const info = {
    ...defaultMatchers,
    mode: (_a = src == null ? void 0 : src.mode) != null ? _a : _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Auto
  };
  info.gazetteer = await (0,_gazetteer_gazetteer__WEBPACK_IMPORTED_MODULE_1__.getGazetteer)(src == null ? void 0 : src.gazetteer);
  switch (info.mode) {
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Geohash:
      if (src == null ? void 0 : src.geohash) {
        info.geohash = getFieldFinder((0,_grafana_data__WEBPACK_IMPORTED_MODULE_5__.getFieldMatcher)({ id: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FieldMatcherID.byName, options: src.geohash }));
      } else {
        info.geohash = () => void 0;
      }
      break;
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Lookup:
      const m = ((_b = src == null ? void 0 : src.lookup) == null ? void 0 : _b.length) ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_5__.getFieldMatcher)({ id: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FieldMatcherID.byName, options: src.lookup }) : (0,_grafana_data__WEBPACK_IMPORTED_MODULE_5__.getFieldMatcher)({ id: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FieldMatcherID.byType, options: _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldType.string });
      info.lookup = getFieldFinder(m);
      break;
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Coords:
      if (src == null ? void 0 : src.latitude) {
        info.latitude = getFieldFinder((0,_grafana_data__WEBPACK_IMPORTED_MODULE_5__.getFieldMatcher)({ id: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FieldMatcherID.byName, options: src.latitude }));
      } else {
        info.latitude = () => void 0;
      }
      if (src == null ? void 0 : src.longitude) {
        info.longitude = getFieldFinder((0,_grafana_data__WEBPACK_IMPORTED_MODULE_5__.getFieldMatcher)({ id: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FieldMatcherID.byName, options: src.longitude }));
      } else {
        info.longitude = () => void 0;
      }
      break;
  }
  return info;
}
function getLocationFields(frame, location) {
  var _a;
  const fields = {
    mode: (_a = location.mode) != null ? _a : _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Auto
  };
  if (fields.mode === _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Auto) {
    fields.geo = location.geo(frame);
    if (fields.geo) {
      return fields;
    }
    fields.latitude = location.latitude(frame);
    fields.longitude = location.longitude(frame);
    if (fields.latitude && fields.longitude) {
      fields.mode = _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Coords;
      return fields;
    }
    fields.geohash = location.geohash(frame);
    if (fields.geohash) {
      fields.mode = _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Geohash;
      return fields;
    }
    fields.lookup = location.lookup(frame);
    if (fields.lookup) {
      fields.mode = _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Lookup;
      return fields;
    }
  }
  switch (fields.mode) {
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Coords:
      fields.latitude = location.latitude(frame);
      fields.longitude = location.longitude(frame);
      break;
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Geohash:
      fields.geohash = location.geohash(frame);
      break;
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Lookup:
      fields.lookup = location.lookup(frame);
      break;
  }
  return fields;
}
function getGeometryField(frame, location) {
  const fields = getLocationFields(frame, location);
  switch (fields.mode) {
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Auto:
      if (fields.geo) {
        return {
          field: fields.geo
        };
      }
      return {
        warning: "Unable to find location fields"
      };
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Coords:
      if (fields.latitude && fields.longitude) {
        return {
          field: (0,_format_utils__WEBPACK_IMPORTED_MODULE_0__.pointFieldFromLonLat)(fields.longitude, fields.latitude),
          derived: true,
          description: "".concat(fields.mode, ": ").concat(fields.latitude.name, ", ").concat(fields.longitude.name)
        };
      }
      return {
        warning: "Select latitude/longitude fields"
      };
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Geohash:
      if (fields.geohash) {
        return {
          field: (0,_format_utils__WEBPACK_IMPORTED_MODULE_0__.pointFieldFromGeohash)(fields.geohash),
          derived: true,
          description: "".concat(fields.mode)
        };
      }
      return {
        warning: "Select geohash field"
      };
    case _grafana_schema__WEBPACK_IMPORTED_MODULE_3__.FrameGeometrySourceMode.Lookup:
      if (fields.lookup) {
        if (location.gazetteer) {
          return {
            field: (0,_format_utils__WEBPACK_IMPORTED_MODULE_0__.getGeoFieldFromGazetteer)(location.gazetteer, fields.lookup),
            derived: true,
            description: "".concat(fields.mode, ": ").concat(location.gazetteer.path)
            // TODO get better name for this
          };
        }
        return {
          warning: "Gazetteer not found"
        };
      }
      return {
        warning: "Select lookup field"
      };
  }
  return { warning: "unable to find geometry" };
}


/***/ }),

/***/ "./public/app/features/transformers/spatial/models.gen.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpatialAction: () => (/* binding */ SpatialAction),
/* harmony export */   SpatialCalculation: () => (/* binding */ SpatialCalculation),
/* harmony export */   SpatialOperation: () => (/* binding */ SpatialOperation),
/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions)
/* harmony export */ });
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");


var SpatialAction = /* @__PURE__ */ ((SpatialAction2) => {
  SpatialAction2["Prepare"] = "prepare";
  SpatialAction2["Calculate"] = "calculate";
  SpatialAction2["Modify"] = "modify";
  return SpatialAction2;
})(SpatialAction || {});
var SpatialCalculation = /* @__PURE__ */ ((SpatialCalculation2) => {
  SpatialCalculation2["Heading"] = "heading";
  SpatialCalculation2["Distance"] = "distance";
  SpatialCalculation2["Area"] = "area";
  return SpatialCalculation2;
})(SpatialCalculation || {});
var SpatialOperation = /* @__PURE__ */ ((SpatialOperation2) => {
  SpatialOperation2["AsLine"] = "asLine";
  SpatialOperation2["LineBuilder"] = "lineBuilder";
  return SpatialOperation2;
})(SpatialOperation || {});
const defaultOptions = {
  action: "prepare" /* Prepare */,
  source: {
    mode: _grafana_schema__WEBPACK_IMPORTED_MODULE_0__.FrameGeometrySourceMode.Auto
  }
};


/***/ }),

/***/ "./public/app/features/transformers/spatial/utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateBearings: () => (/* binding */ calculateBearings),
/* harmony export */   doGeomeryCalculation: () => (/* binding */ doGeomeryCalculation),
/* harmony export */   getCenterPoint: () => (/* binding */ getCenterPoint),
/* harmony export */   getCenterPointWGS84: () => (/* binding */ getCenterPointWGS84),
/* harmony export */   toLineString: () => (/* binding */ toLineString)
/* harmony export */ });
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/sphere.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _models_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/transformers/spatial/models.gen.ts");







function toLineString(field) {
  const coords = [];
  for (const geo of field.values) {
    if (geo) {
      coords.push(getCenterPoint(geo));
    }
  }
  return new ol_geom__WEBPACK_IMPORTED_MODULE_2__["default"](coords);
}
function calculateBearings(values) {
  const bearing = new Array(values.length);
  if (values.length > 1) {
    let prev = getCenterPointWGS84(values[0]);
    for (let i = 1; i < values.length; i++) {
      let next = getCenterPointWGS84(values[i]);
      if (prev && next) {
        let degrees = Math.atan2(next[0] - prev[0], next[1] - prev[1]) * 180 / Math.PI;
        if (degrees < 0) {
          degrees += 360;
        }
        bearing[i - 1] = bearing[i] = degrees;
      }
    }
  } else {
    bearing.fill(0);
  }
  return bearing;
}
function getCenterPoint(geo) {
  if (geo instanceof ol_geom__WEBPACK_IMPORTED_MODULE_3__["default"]) {
    return geo.getCoordinates();
  }
  return (0,ol_extent__WEBPACK_IMPORTED_MODULE_4__.getCenter)(geo.getExtent());
}
function getCenterPointWGS84(geo) {
  if (!geo) {
    return void 0;
  }
  return (0,ol_proj__WEBPACK_IMPORTED_MODULE_0__.toLonLat)(getCenterPoint(geo));
}
function doGeomeryCalculation(field, options) {
  var _a, _b;
  const values = field.values;
  const buffer = new Array(field.values.length);
  const op = (_a = options.calc) != null ? _a : _models_gen__WEBPACK_IMPORTED_MODULE_1__.SpatialCalculation.Heading;
  const name = (_b = options.field) != null ? _b : op;
  switch (op) {
    case _models_gen__WEBPACK_IMPORTED_MODULE_1__.SpatialCalculation.Area: {
      for (let i = 0; i < values.length; i++) {
        const geo = values[i];
        if (geo) {
          buffer[i] = (0,ol_sphere__WEBPACK_IMPORTED_MODULE_5__.getArea)(geo);
        }
      }
      return {
        name,
        type: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FieldType.number,
        config: {
          unit: "areaM2"
        },
        values: buffer
      };
    }
    case _models_gen__WEBPACK_IMPORTED_MODULE_1__.SpatialCalculation.Distance: {
      for (let i = 0; i < values.length; i++) {
        const geo = values[i];
        if (geo) {
          buffer[i] = (0,ol_sphere__WEBPACK_IMPORTED_MODULE_5__.getLength)(geo);
        }
      }
      return {
        name,
        type: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FieldType.number,
        config: {
          unit: "lengthm"
        },
        values: buffer
      };
    }
    case _models_gen__WEBPACK_IMPORTED_MODULE_1__.SpatialCalculation.Heading:
    default: {
      return {
        name,
        type: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FieldType.number,
        config: {
          unit: "degree"
        },
        values: calculateBearings(values)
      };
    }
  }
}


/***/ }),

/***/ "./public/app/features/visualization/data-hover/ComplexDataHoverView.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComplexDataHoverView: () => (/* binding */ ComplexDataHoverView)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_components_CloseButton_CloseButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/core/components/CloseButton/CloseButton.tsx");
/* harmony import */ var _DataHoverRows__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/visualization/data-hover/DataHoverRows.tsx");
/* harmony import */ var _DataHoverTabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/visualization/data-hover/DataHoverTabs.tsx");





const ComplexDataHoverView = ({ layers, onClose, isOpen }) => {
  const [activeTabIndex, setActiveTabIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);
  if (!layers) {
    return null;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, isOpen && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_core_components_CloseButton_CloseButton__WEBPACK_IMPORTED_MODULE_1__.CloseButton, { style: { zIndex: 1 }, onClick: onClose }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_DataHoverTabs__WEBPACK_IMPORTED_MODULE_3__.DataHoverTabs, { layers, setActiveTabIndex, activeTabIndex }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_DataHoverRows__WEBPACK_IMPORTED_MODULE_2__.DataHoverRows, { layers, activeTabIndex }));
};


/***/ }),

/***/ "./public/app/features/visualization/data-hover/DataHoverRow.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataHoverRow: () => (/* binding */ DataHoverRow)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/dataframe/ArrayDataFrame.ts");
/* harmony import */ var _DataHoverView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/visualization/data-hover/DataHoverView.tsx");




const DataHoverRow = ({ feature }) => {
  let data;
  let rowIndex = 0;
  if (!feature) {
    return null;
  }
  data = feature.get("frame");
  if (data) {
    rowIndex = feature.get("rowIndex");
  } else {
    const { geometry, ...properties } = feature.getProperties();
    data = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayDataFrame([properties]);
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_DataHoverView__WEBPACK_IMPORTED_MODULE_1__.DataHoverView, { data, rowIndex });
};


/***/ }),

/***/ "./public/app/features/visualization/data-hover/DataHoverRows.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataHoverRows: () => (/* binding */ DataHoverRows),
/* harmony export */   generateLabel: () => (/* binding */ generateLabel)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-data/src/field/fieldState.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/Tabs/TabContent.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-ui/src/components/Collapse/Collapse.tsx");
/* harmony import */ var _plugins_panel_geomap_utils_uiUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/uiUtils.tsx");
/* harmony import */ var _DataHoverRow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/visualization/data-hover/DataHoverRow.tsx");

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;







const DataHoverRows = ({ layers, activeTabIndex }) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.useStyles2)(getStyles);
  const [rowMap, setRowMap] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(/* @__PURE__ */ new Map());
  const updateRowMap = (key, value) => {
    setRowMap(new Map(rowMap.set(key, value)));
  };
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.TabContent, null, layers.map(
    (geomapLayer, index) => index === activeTabIndex && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("div", { key: geomapLayer.layer.getName() }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("div", null, geomapLayer.features.map((feature, idx) => {
      var _a2;
      const key = (_a2 = feature.getId()) != null ? _a2 : idx;
      const shouldDisplayCollapse = geomapLayer.features.length > 1;
      return shouldDisplayCollapse ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
        _grafana_ui__WEBPACK_IMPORTED_MODULE_7__.Collapse,
        {
          key,
          collapsible: true,
          label: generateLabel(feature, idx),
          isOpen: rowMap.get(key),
          onToggle: () => {
            updateRowMap(key, !rowMap.get(key));
          },
          className: styles.collapsibleRow
        },
        /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_DataHoverRow__WEBPACK_IMPORTED_MODULE_4__.DataHoverRow, { feature })
      ) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_DataHoverRow__WEBPACK_IMPORTED_MODULE_4__.DataHoverRow, { key, feature });
    })))
  ));
};
const generateLabel = (feature, idx) => {
  const names = ["Name", "name", "Title", "ID", "id"];
  let props = feature.getProperties();
  let first = "";
  const frame = feature.get("frame");
  if (frame) {
    const rowIndex = feature.get("rowIndex");
    for (const f of frame.fields) {
      if (f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_8__.FieldType.string) {
        const k = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_9__.getFieldDisplayName)(f, frame);
        if (!first) {
          first = k;
        }
        props[k] = f.values[rowIndex];
      }
    }
  }
  for (let k of names) {
    const v = props[k];
    if (v) {
      return v;
    }
  }
  if (first) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("span", null, first, ": ", (0,_plugins_panel_geomap_utils_uiUtils__WEBPACK_IMPORTED_MODULE_3__.renderValue)(props[first]));
  }
  for (let k of Object.keys(props)) {
    const v = props[k];
    if ((0,lodash__WEBPACK_IMPORTED_MODULE_1__.isString)(v)) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("span", null, k, ": ", (0,_plugins_panel_geomap_utils_uiUtils__WEBPACK_IMPORTED_MODULE_3__.renderValue)(v));
    }
  }
  return "Match: ".concat(idx + 1);
};
const getStyles = (theme) => ({
  collapsibleRow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_a || (_a = __template(["\n    margin-bottom: 0;\n  "])))
});


/***/ }),

/***/ "./public/app/features/visualization/data-hover/DataHoverTabs.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataHoverTabs: () => (/* binding */ DataHoverTabs)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/components/Tabs/TabsBar.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/components/Tabs/Tab.tsx");



const DataHoverTabs = ({ layers, setActiveTabIndex, activeTabIndex }) => {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.TabsBar, null, layers && layers.map((g, index) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tab,
    {
      key: index,
      label: g.layer.getName(),
      active: index === activeTabIndex,
      counter: g.features.length > 1 ? g.features.length : null,
      onChangeTab: () => {
        setActiveTabIndex(index);
      }
    }
  )));
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/GeomapOverlay.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomapOverlay: () => (/* binding */ GeomapOverlay)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");




const GeomapOverlay = ({ topRight1, topRight2, bottomLeft, blStyle }) => {
  var _a;
  const topRight1Exists = (_a = topRight1 && topRight1.length > 0) != null ? _a : false;
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles(topRight1Exists));
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.overlay }, Boolean(topRight1 == null ? void 0 : topRight1.length) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.TR1 }, topRight1), Boolean(topRight2 == null ? void 0 : topRight2.length) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.TR2 }, topRight2), Boolean(bottomLeft == null ? void 0 : bottomLeft.length) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.BL, style: blStyle }, bottomLeft));
};
const getStyles = (topRight1Exists) => (theme) => ({
  overlay: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    position: "absolute",
    width: "100%",
    height: "100%",
    zIndex: 500,
    pointerEvents: "none"
  }),
  TR1: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    right: "0.5em",
    pointerEvents: "auto",
    position: "absolute",
    top: "0.5em"
  }),
  TR2: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    position: "absolute",
    top: topRight1Exists ? "80px" : "8px",
    right: "8px",
    pointerEvents: "auto"
  }),
  BL: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    position: "absolute",
    bottom: "8px",
    left: "8px",
    pointerEvents: "auto"
  })
});


/***/ }),

/***/ "./public/app/plugins/panel/geomap/GeomapPanel.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomapPanel: () => (/* binding */ GeomapPanel)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./node_modules/@emotion/react/dist/emotion-react.cjs.dev.js");
/* harmony import */ var ol__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./node_modules/ol/View.js");
/* harmony import */ var ol_control_Attribution__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./node_modules/ol/control/Attribution.js");
/* harmony import */ var ol_control_ScaleLine__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./node_modules/ol/control/ScaleLine.js");
/* harmony import */ var ol_control_Zoom__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./node_modules/ol/control/Zoom.js");
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var ol_interaction_MouseWheelZoom__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./node_modules/ol/interaction/MouseWheelZoom.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./packages/grafana-data/src/events/common.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./packages/grafana-runtime/src/config.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./packages/grafana-ui/src/components/PanelChrome/PanelContext.ts");
/* harmony import */ var app_types_events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/types/events.ts");
/* harmony import */ var _GeomapOverlay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/GeomapOverlay.tsx");
/* harmony import */ var _GeomapTooltip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/GeomapTooltip.tsx");
/* harmony import */ var _components_DebugOverlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/components/DebugOverlay.tsx");
/* harmony import */ var _components_MeasureOverlay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/components/MeasureOverlay.tsx");
/* harmony import */ var _components_MeasureVectorLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/geomap/components/MeasureVectorLayer.ts");
/* harmony import */ var _globalStyles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/panel/geomap/globalStyles.ts");
/* harmony import */ var _layers_data_markersLayer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/markersLayer.tsx");
/* harmony import */ var _layers_registry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/registry.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/panel/geomap/types.ts");
/* harmony import */ var _utils_actions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/actions.ts");
/* harmony import */ var _utils_getLayersExtent__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/getLayersExtent.ts");
/* harmony import */ var _utils_layers__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/layers.ts");
/* harmony import */ var _utils_tooltip__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/tooltip.ts");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/utils.ts");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/plugins/panel/geomap/view.ts");































let sharedView = void 0;
class GeomapPanel extends react__WEBPACK_IMPORTED_MODULE_2__.Component {
  constructor(props) {
    super(props);
    this.panelContext = void 0;
    this.subs = new rxjs__WEBPACK_IMPORTED_MODULE_19__.Subscription();
    this.globalCSS = (0,_globalStyles__WEBPACK_IMPORTED_MODULE_9__.getGlobalStyles)(_grafana_runtime__WEBPACK_IMPORTED_MODULE_20__.config.theme2);
    this.hoverPayload = { point: {}, pageX: -1, pageY: -1 };
    this.hoverEvent = new _grafana_data__WEBPACK_IMPORTED_MODULE_21__.DataHoverEvent(this.hoverPayload);
    this.layers = [];
    this.byName = /* @__PURE__ */ new Map();
    this.actions = (0,_utils_actions__WEBPACK_IMPORTED_MODULE_13__.getActions)(this);
    this.initMapRef = async (div) => {
      var _a, _b;
      if (!div) {
        return;
      }
      this.mapDiv = div;
      if (this.map) {
        this.map.dispose();
      }
      const { options } = this.props;
      const map = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_17__.getNewOpenLayersMap)(this, options, div);
      this.byName.clear();
      const layers = [];
      try {
        layers.push(await (0,_utils_layers__WEBPACK_IMPORTED_MODULE_15__.initLayer)(this, map, (_a = options.basemap) != null ? _a : _layers_registry__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_BASEMAP_CONFIG, true));
        if (!options.layers) {
          options.layers = [_layers_data_markersLayer__WEBPACK_IMPORTED_MODULE_10__.defaultMarkersConfig];
        }
        for (const lyr of options.layers) {
          layers.push(await (0,_utils_layers__WEBPACK_IMPORTED_MODULE_15__.initLayer)(this, map, lyr, false));
        }
      } catch (ex) {
        console.error("error loading layers", ex);
      }
      for (const lyr of layers) {
        map.addLayer(lyr.layer);
      }
      this.layers = layers;
      this.map = map;
      this.initViewExtent(map.getView(), options.view);
      this.mouseWheelZoom = new ol_interaction_MouseWheelZoom__WEBPACK_IMPORTED_MODULE_22__["default"]();
      (_b = this.map) == null ? void 0 : _b.addInteraction(this.mouseWheelZoom);
      (0,_utils_utils__WEBPACK_IMPORTED_MODULE_17__.updateMap)(this, options);
      (0,_utils_tooltip__WEBPACK_IMPORTED_MODULE_16__.setTooltipListeners)(this);
      (0,_utils_utils__WEBPACK_IMPORTED_MODULE_17__.notifyPanelEditor)(this, layers, layers.length - 1);
      this.setState({ legends: this.getLegends() });
    };
    this.clearTooltip = () => {
      if (this.state.ttip && !this.state.ttipOpen) {
        this.tooltipPopupClosed();
      }
    };
    this.tooltipPopupClosed = () => {
      this.setState({ ttipOpen: false, ttip: void 0 });
    };
    this.pointerClickListener = (evt) => {
      (0,_utils_tooltip__WEBPACK_IMPORTED_MODULE_16__.pointerClickListener)(evt, this);
    };
    this.pointerMoveListener = (evt) => {
      (0,_utils_tooltip__WEBPACK_IMPORTED_MODULE_16__.pointerMoveListener)(evt, this);
    };
    this.initMapView = (config2) => {
      let view = new ol__WEBPACK_IMPORTED_MODULE_23__["default"]({
        center: [0, 0],
        zoom: 1,
        showFullExtent: true
        // allows zooming so the full range is visible
      });
      if (config2.shared) {
        if (!sharedView) {
          sharedView = view;
        } else {
          view = sharedView;
        }
      }
      this.initViewExtent(view, config2);
      return view;
    };
    this.state = { ttipOpen: false, legends: [] };
    this.subs.add(
      this.props.eventBus.subscribe(app_types_events__WEBPACK_IMPORTED_MODULE_3__.PanelEditExitedEvent, (evt) => {
        if (this.mapDiv && this.props.id === evt.payload) {
          this.initMapRef(this.mapDiv);
        }
      })
    );
  }
  componentDidMount() {
    this.panelContext = this.context;
  }
  componentWillUnmount() {
    var _a, _b, _c;
    this.subs.unsubscribe();
    for (const lyr of this.layers) {
      (_b = (_a = lyr.handler).dispose) == null ? void 0 : _b.call(_a);
    }
    (_c = this.map) == null ? void 0 : _c.dispose();
  }
  shouldComponentUpdate(nextProps) {
    if (!this.map) {
      return true;
    }
    if (this.props.height !== nextProps.height || this.props.width !== nextProps.width) {
      this.map.updateSize();
    }
    if (this.props.data !== nextProps.data) {
      this.dataChanged(nextProps.data);
    }
    if (this.props.options !== nextProps.options) {
      this.optionsChanged(nextProps.options);
    }
    return true;
  }
  componentDidUpdate(prevProps) {
    if (this.map && (this.props.height !== prevProps.height || this.props.width !== prevProps.width)) {
      this.map.updateSize();
    }
    if (this.map && this.props.data !== prevProps.data) {
      this.dataChanged(this.props.data);
    }
  }
  /** This function will actually update the JSON model */
  doOptionsUpdate(selected) {
    var _a;
    const { options, onOptionsChange } = this.props;
    const layers = this.layers;
    (_a = this.map) == null ? void 0 : _a.getLayers().forEach((l) => {
      var _a2, _b;
      if (l instanceof _components_MeasureVectorLayer__WEBPACK_IMPORTED_MODULE_8__.MeasureVectorLayer) {
        (_a2 = this.map) == null ? void 0 : _a2.removeLayer(l);
        (_b = this.map) == null ? void 0 : _b.addLayer(l);
      }
    });
    onOptionsChange({
      ...options,
      basemap: layers[0].options,
      layers: layers.slice(1).map((v) => v.options)
    });
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_17__.notifyPanelEditor)(this, layers, selected);
    this.setState({ legends: this.getLegends() });
  }
  /**
   * Called when the panel options change
   *
   * NOTE: changes to basemap and layers are handled independently
   */
  optionsChanged(options) {
    var _a;
    const oldOptions = this.props.options;
    if (options.view !== oldOptions.view) {
      const view = this.initMapView(options.view);
      if (this.map && view) {
        this.map.setView(view);
      }
    }
    if (options.controls !== oldOptions.controls) {
      this.initControls((_a = options.controls) != null ? _a : { showZoom: true, showAttribution: true });
    }
  }
  /**
   * Called when PanelData changes (query results etc)
   */
  dataChanged(data) {
    if (data === this.props.data) {
      for (const state of this.layers) {
        (0,_utils_layers__WEBPACK_IMPORTED_MODULE_15__.applyLayerFilter)(state.handler, state.options, this.props.data);
      }
    }
    const v = _view__WEBPACK_IMPORTED_MODULE_18__.centerPointRegistry.getIfExists(this.props.options.view.id);
    if (v && v.id === _view__WEBPACK_IMPORTED_MODULE_18__.MapCenterID.Fit) {
      const view = this.initMapView(this.props.options.view);
      if (this.map && view) {
        this.map.setView(view);
      }
    }
  }
  initViewExtent(view, config2) {
    var _a, _b, _c, _d, _e, _f, _g;
    const v = _view__WEBPACK_IMPORTED_MODULE_18__.centerPointRegistry.getIfExists(config2.id);
    if (v) {
      let coord = void 0;
      if (v.lat == null) {
        if (v.id === _view__WEBPACK_IMPORTED_MODULE_18__.MapCenterID.Coordinates) {
          coord = [(_a = config2.lon) != null ? _a : 0, (_b = config2.lat) != null ? _b : 0];
        } else if (v.id === _view__WEBPACK_IMPORTED_MODULE_18__.MapCenterID.Fit) {
          const extent = (0,_utils_getLayersExtent__WEBPACK_IMPORTED_MODULE_14__.getLayersExtent)(this.layers, config2.allLayers, config2.lastOnly, config2.layer);
          if (!(0,ol_extent__WEBPACK_IMPORTED_MODULE_24__.isEmpty)(extent)) {
            const padding = (_c = config2.padding) != null ? _c : 5;
            const res = view.getResolutionForExtent(extent, (_d = this.map) == null ? void 0 : _d.getSize());
            const maxZoom = (_e = config2.zoom) != null ? _e : config2.maxZoom;
            view.fit(extent, {
              maxZoom
            });
            view.setResolution(res * (padding / 100 + 1));
            const adjustedZoom = view.getZoom();
            if (adjustedZoom && maxZoom && adjustedZoom > maxZoom) {
              view.setZoom(maxZoom);
            }
          }
        } else {
        }
      } else {
        coord = [(_f = v.lon) != null ? _f : 0, (_g = v.lat) != null ? _g : 0];
      }
      if (coord) {
        view.setCenter((0,ol_proj__WEBPACK_IMPORTED_MODULE_1__.fromLonLat)(coord));
      }
    }
    if (config2.maxZoom) {
      view.setMaxZoom(config2.maxZoom);
    }
    if (config2.minZoom) {
      view.setMaxZoom(config2.minZoom);
    }
    if (config2.zoom && (v == null ? void 0 : v.id) !== _view__WEBPACK_IMPORTED_MODULE_18__.MapCenterID.Fit) {
      view.setZoom(config2.zoom);
    }
  }
  initControls(options) {
    if (!this.map) {
      return;
    }
    this.map.getControls().clear();
    if (options.showZoom) {
      this.map.addControl(new ol_control_Zoom__WEBPACK_IMPORTED_MODULE_25__["default"]());
    }
    if (options.showScale) {
      this.map.addControl(
        new ol_control_ScaleLine__WEBPACK_IMPORTED_MODULE_26__["default"]({
          units: options.scaleUnits,
          minWidth: 100
        })
      );
    }
    this.mouseWheelZoom.setActive(Boolean(options.mouseWheelZoom));
    if (options.showAttribution) {
      this.map.addControl(new ol_control_Attribution__WEBPACK_IMPORTED_MODULE_27__["default"]({ collapsed: true, collapsible: true }));
    }
    let topRight1 = [];
    if (options.showMeasure) {
      topRight1 = [
        /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
          _components_MeasureOverlay__WEBPACK_IMPORTED_MODULE_7__.MeasureOverlay,
          {
            key: "measure",
            map: this.map,
            menuActiveState: (value) => {
              this.setState({ ttipOpen: value, measureMenuActive: value });
            }
          }
        )
      ];
    }
    let topRight2 = [];
    if (options.showDebug) {
      topRight2 = [/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_components_DebugOverlay__WEBPACK_IMPORTED_MODULE_6__.DebugOverlay, { key: "debug", map: this.map })];
    }
    this.setState({ topRight1, topRight2 });
  }
  getLegends() {
    const legends = [];
    for (const state of this.layers) {
      if (state.handler.legend) {
        legends.push(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("div", { key: state.options.name }, state.handler.legend));
      }
    }
    return legends;
  }
  render() {
    var _a;
    let { ttip, ttipOpen, topRight1, legends, topRight2 } = this.state;
    const { options } = this.props;
    const showScale = options.controls.showScale;
    if (!ttipOpen && ((_a = options.tooltip) == null ? void 0 : _a.mode) === _types__WEBPACK_IMPORTED_MODULE_12__.TooltipMode.None) {
      ttip = void 0;
    }
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement((react__WEBPACK_IMPORTED_MODULE_2___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_emotion_react__WEBPACK_IMPORTED_MODULE_28__.Global, { styles: this.globalCSS }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("div", { className: styles.wrap, onMouseLeave: this.clearTooltip }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
      "div",
      {
        role: "application",
        className: styles.map,
        tabIndex: 0,
        "aria-label": "Navigable map",
        ref: this.initMapRef
      }
    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
      _GeomapOverlay__WEBPACK_IMPORTED_MODULE_4__.GeomapOverlay,
      {
        bottomLeft: legends,
        topRight1,
        topRight2,
        blStyle: { bottom: showScale ? "35px" : "8px" }
      }
    )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_GeomapTooltip__WEBPACK_IMPORTED_MODULE_5__.GeomapTooltip, { ttip, isOpen: ttipOpen, onClose: this.tooltipPopupClosed }));
  }
}
GeomapPanel.contextType = _grafana_ui__WEBPACK_IMPORTED_MODULE_29__.PanelContextRoot;
const styles = {
  wrap: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    position: "relative",
    width: "100%",
    height: "100%"
  }),
  map: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    position: "absolute",
    zIndex: 0,
    width: "100%",
    height: "100%"
  })
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/GeomapTooltip.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomapTooltip: () => (/* binding */ GeomapTooltip)
/* harmony export */ });
/* harmony import */ var _react_aria_dialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@react-aria/dialog/dist/useDialog.mjs");
/* harmony import */ var _react_aria_overlays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@react-aria/overlays/dist/useOverlay.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/components/Portal/Portal.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/VizTooltip/VizTooltipContainer.tsx");
/* harmony import */ var _features_visualization_data_hover_ComplexDataHoverView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/visualization/data-hover/ComplexDataHoverView.tsx");






const GeomapTooltip = ({ ttip, onClose, isOpen }) => {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();
  const { overlayProps } = (0,_react_aria_overlays__WEBPACK_IMPORTED_MODULE_2__.useOverlay)({ onClose, isDismissable: true, isOpen }, ref);
  const { dialogProps } = (0,_react_aria_dialog__WEBPACK_IMPORTED_MODULE_3__.useDialog)({}, ref);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, ttip && ttip.layers && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Portal, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.VizTooltipContainer, { position: { x: ttip.pageX, y: ttip.pageY }, offset: { x: 10, y: 10 }, allowPointerEvents: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("section", { ref, ...overlayProps, ...dialogProps }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_features_visualization_data_hover_ComplexDataHoverView__WEBPACK_IMPORTED_MODULE_1__.ComplexDataHoverView, { layers: ttip.layers, isOpen, onClose })))));
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/components/DebugOverlay.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DebugOverlay: () => (/* binding */ DebugOverlay)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/tinycolor2/esm/tinycolor.js");
/* harmony import */ var _grafana_e2e_selectors_src__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-e2e-selectors/src/selectors/index.ts");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/config.ts");







class DebugOverlay extends react__WEBPACK_IMPORTED_MODULE_2__.PureComponent {
  constructor(props) {
    super(props);
    this.style = getStyles(_core_config__WEBPACK_IMPORTED_MODULE_4__.config.theme2);
    this.updateViewState = () => {
      const view = this.props.map.getView();
      this.setState({
        zoom: view.getZoom(),
        center: (0,ol_proj__WEBPACK_IMPORTED_MODULE_1__.transform)(view.getCenter(), view.getProjection(), "EPSG:4326")
      });
    };
    this.state = { zoom: 0, center: [0, 0] };
  }
  componentDidMount() {
    this.props.map.on("moveend", this.updateViewState);
    this.updateViewState();
  }
  render() {
    const { zoom, center } = this.state;
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("div", { className: this.style.infoWrap, "aria-label": _grafana_e2e_selectors_src__WEBPACK_IMPORTED_MODULE_5__.selectors.components.DebugOverlay.wrapper }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("table", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("tbody", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("tr", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("th", null, "Zoom:"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("td", null, zoom == null ? void 0 : zoom.toFixed(1))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("tr", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("th", null, "Center:\xA0"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("td", null, center[0].toFixed(5), ", ", center[1].toFixed(5))))));
  }
}
const getStyles = (theme) => ({
  infoWrap: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    color: theme.colors.text.primary,
    background: (0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__["default"])(theme.components.panel.background).setAlpha(0.7).toString(),
    borderRadius: theme.shape.radius.default,
    padding: theme.spacing(1)
  })
});


/***/ }),

/***/ "./public/app/plugins/panel/geomap/components/MarkersLegend.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MarkersLegend: () => (/* binding */ MarkersLegend)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/react-use/esm/useObservable.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-data/src/field/fieldColor.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./packages/grafana-data/src/valueFormats/valueFormats.ts");
/* harmony import */ var _grafana_data_src_field_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./packages/grafana-data/src/field/scale.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _core_components_ColorScale_ColorScale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/ColorScale/ColorScale.tsx");
/* harmony import */ var _core_components_SVG_SanitizedSVG__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/components/SVG/SanitizedSVG.tsx");
/* harmony import */ var _core_components_TimelineChart_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/TimelineChart/utils.ts");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/config.ts");












function MarkersLegend(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const { layerName, styleConfig, layer } = props;
  const style = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.useStyles2)(getStyles);
  const hoverEvent = (0,react_use__WEBPACK_IMPORTED_MODULE_7__["default"])((_b = (_a = layer == null ? void 0 : layer.__state) == null ? void 0 : _a.mouseEvents) != null ? _b : (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.of)(void 0));
  const colorField = (_d = (_c = styleConfig == null ? void 0 : styleConfig.dims) == null ? void 0 : _c.color) == null ? void 0 : _d.field;
  const hoverValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    if (!colorField || !hoverEvent) {
      return void 0;
    }
    const props2 = hoverEvent.getProperties();
    const frame = props2.frame;
    if (!frame) {
      return void 0;
    }
    const rowIndex = props2.rowIndex;
    return colorField.values[rowIndex];
  }, [hoverEvent, colorField]);
  if (!styleConfig) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null);
  }
  const { color, opacity } = (_e = styleConfig == null ? void 0 : styleConfig.base) != null ? _e : {};
  const symbol = (_f = styleConfig == null ? void 0 : styleConfig.config.symbol) == null ? void 0 : _f.fixed;
  if (color && symbol && !colorField) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: style.infoWrap }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: style.layerName }, layerName), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(style.layerBody, style.fixedColorContainer) }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
      _core_components_SVG_SanitizedSVG__WEBPACK_IMPORTED_MODULE_3__.SanitizedSVG,
      {
        src: "public/".concat(symbol),
        className: style.legendSymbol,
        title: "Symbol",
        style: { fill: color, opacity }
      }
    )));
  }
  if (!colorField) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null);
  }
  const colorMode = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_9__.getFieldColorModeForField)(colorField);
  if (colorMode.isContinuous && colorMode.getColors) {
    const colors = colorMode.getColors(_core_config__WEBPACK_IMPORTED_MODULE_5__.config.theme2);
    const colorRange = (0,_grafana_data_src_field_scale__WEBPACK_IMPORTED_MODULE_10__.getMinMaxAndDelta)(colorField);
    const display = colorField.display ? (v) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_11__.formattedValueToString)(colorField.display(v)) : (v) => "".concat(v);
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: style.infoWrap }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: style.layerName }, layerName), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(style.layerBody, style.colorScaleWrapper) }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
      _core_components_ColorScale_ColorScale__WEBPACK_IMPORTED_MODULE_2__.ColorScale,
      {
        hoverValue,
        colorPalette: colors,
        min: (_g = colorRange.min) != null ? _g : 0,
        max: (_h = colorRange.max) != null ? _h : 100,
        display,
        useStopsPercentage: false
      }
    )));
  }
  const thresholds = (_i = colorField == null ? void 0 : colorField.config) == null ? void 0 : _i.thresholds;
  if (!thresholds || thresholds.steps.length < 2) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", null);
  }
  const items = (0,_core_components_TimelineChart_utils__WEBPACK_IMPORTED_MODULE_4__.getThresholdItems)(colorField.config, _core_config__WEBPACK_IMPORTED_MODULE_5__.config.theme2);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: style.infoWrap }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: style.layerName }, layerName), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(style.layerBody, style.legend) }, items.map((item, idx) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { key: "".concat(idx, "/").concat(item.label), className: style.legendItem }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("i", { style: { background: item.color } }), item.label))));
}
const getStyles = (theme) => ({
  infoWrap: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    display: "flex",
    flexDirection: "column",
    background: theme.colors.background.secondary,
    // eslint-disable-next-line @grafana/no-border-radius-literal
    borderRadius: "1px",
    padding: theme.spacing(1),
    borderBottom: "2px solid ".concat(theme.colors.border.strong),
    minWidth: "150px"
  }),
  layerName: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    fontSize: theme.typography.body.fontSize
  }),
  layerBody: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    paddingLeft: "10px"
  }),
  legend: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    lineHeight: "18px",
    display: "flex",
    flexDirection: "column",
    fontSize: theme.typography.bodySmall.fontSize,
    padding: "5px 10px 0",
    i: {
      width: "15px",
      height: "15px",
      float: "left",
      marginRight: "8px",
      opacity: 0.7,
      borderRadius: theme.shape.radius.circle
    }
  }),
  legendItem: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    whiteSpace: "nowrap"
  }),
  fixedColorContainer: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    minWidth: "80px",
    fontSize: theme.typography.bodySmall.fontSize,
    paddingTop: "5px"
  }),
  legendSymbol: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    height: "18px",
    width: "18px",
    margin: "auto"
  }),
  colorScaleWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    minWidth: "200px",
    fontSize: theme.typography.bodySmall.fontSize,
    paddingTop: "10px"
  })
});


/***/ }),

/***/ "./public/app/plugins/panel/geomap/components/MeasureOverlay.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeasureOverlay: () => (/* binding */ MeasureOverlay)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/RadioButtonGroup/RadioButtonGroup.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/Button/Button.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-ui/src/components/IconButton/IconButton.tsx");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var _utils_measure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/measure.ts");
/* harmony import */ var _MeasureVectorLayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/components/MeasureVectorLayer.ts");







const MeasureOverlay = ({ map, menuActiveState }) => {
  const vector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new _MeasureVectorLayer__WEBPACK_IMPORTED_MODULE_4__.MeasureVectorLayer());
  const measureStyle = getStyles(_core_config__WEBPACK_IMPORTED_MODULE_2__.config.theme2);
  const [firstLoad, setFirstLoad] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);
  const [menuActive, setMenuActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [options, setOptions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
    action: _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures[0].value,
    unit: _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures[0].units[0].value
  });
  const unit = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    var _a;
    const action = (_a = _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures.find((m) => m.value === options.action)) != null ? _a : _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures[0];
    const current = action.getUnit(options.unit);
    vector.current.setOptions(options);
    return {
      current,
      options: action.units
    };
  }, [options]);
  const clearPrevious = true;
  const showSegments = false;
  function toggleMenu() {
    var _a;
    setMenuActive(!menuActive);
    menuActiveState(!menuActive);
    if (menuActive) {
      map.removeInteraction(vector.current.draw);
      vector.current.setVisible(false);
    } else {
      if (firstLoad) {
        setFirstLoad(false);
        vector.current.setZIndex(1);
        map.addLayer(vector.current);
        map.addInteraction(vector.current.modify);
      }
      vector.current.setVisible(true);
      map.removeInteraction(vector.current.draw);
      const a = (_a = _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures.find((v) => v.value === options.action)) != null ? _a : _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures[0];
      vector.current.addInteraction(map, a.geometry, showSegments, clearPrevious);
    }
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: "".concat(measureStyle.infoWrap, " ").concat(!menuActive ? measureStyle.infoWrapClosed : null) }, menuActive ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: measureStyle.rowGroup }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_5__.RadioButtonGroup,
    {
      value: options.action,
      options: _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures,
      size: "md",
      fullWidth: false,
      onChange: (e) => {
        var _a;
        map.removeInteraction(vector.current.draw);
        const m = (_a = _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures.find((v) => v.value === e)) != null ? _a : _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures[0];
        const unit2 = m.getUnit(options.unit);
        setOptions({ ...options, action: m.value, unit: unit2.value });
        vector.current.addInteraction(map, m.geometry, showSegments, clearPrevious);
      }
    }
  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.Button, { className: measureStyle.button, icon: "times", variant: "secondary", size: "sm", onClick: toggleMenu })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_7__.Select,
    {
      className: measureStyle.unitSelect,
      value: unit.current,
      options: unit.options,
      isSearchable: false,
      onChange: (v) => {
        var _a, _b;
        const a = (_a = _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures.find((v2) => v2.value === options.action)) != null ? _a : _utils_measure__WEBPACK_IMPORTED_MODULE_3__.measures[0];
        const unit2 = (_b = a.getUnit(v.value)) != null ? _b : a.units[0];
        setOptions({ ...options, unit: unit2.value });
      }
    }
  )) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_8__.IconButton,
    {
      className: measureStyle.icon,
      name: "ruler-combined",
      tooltip: "show measure tools",
      tooltipPlacement: "left",
      onClick: toggleMenu
    }
  ));
};
const getStyles = (theme) => ({
  button: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    marginLeft: "auto"
  }),
  icon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    backgroundColor: theme.colors.secondary.main,
    display: "inline-block",
    height: "19.25px",
    margin: "1px",
    width: "19.25px"
  }),
  infoWrap: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    color: "".concat(theme.colors.text),
    backgroundColor: theme.colors.background.secondary,
    // eslint-disable-next-line @grafana/no-border-radius-literal
    borderRadius: "4px",
    padding: "2px"
  }),
  infoWrapClosed: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    height: "25.25px",
    width: "25.25px"
  }),
  rowGroup: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    display: "flex",
    justifyContent: "flex-end"
  }),
  unitSelect: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    minWidth: "200px"
  })
});


/***/ }),

/***/ "./public/app/plugins/panel/geomap/components/MeasureVectorLayer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeasureVectorLayer: () => (/* binding */ MeasureVectorLayer)
/* harmony export */ });
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/geom/Polygon.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/interaction/Modify.js");
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/ol/interaction/Draw.js");
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/layer/Vector.js");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/sphere.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/style/Text.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/style/RegularShape.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/style/Circle.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./packages/grafana-data/src/valueFormats/valueFormats.ts");
/* harmony import */ var _utils_measure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/measure.ts");









class MeasureVectorLayer extends ol_layer_Vector__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_2__["default"]()
    });
    this.opts = {
      action: "length",
      unit: "m"
    };
    this.segmentStyle = new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
      text: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({
        font: "12px Calibri,sans-serif",
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(255, 255, 255, 1)"
        }),
        backgroundFill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(0, 0, 0, 0.4)"
        }),
        padding: [2, 2, 2, 2],
        textBaseline: "bottom",
        offsetY: -12
      }),
      image: new ol_style__WEBPACK_IMPORTED_MODULE_6__["default"]({
        radius: 6,
        points: 3,
        angle: Math.PI,
        displacement: [0, 8],
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(0, 0, 0, 0.4)"
        })
      })
    });
    this.segmentStyles = [this.segmentStyle];
    // Open Layer styles
    this.shapeStyle = [
      new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(255, 255, 255, 0.2)"
        }),
        image: new ol_style__WEBPACK_IMPORTED_MODULE_7__["default"]({
          radius: 5,
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
            color: "rgba(0, 0, 0, 0.7)"
          }),
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
            color: "rgba(255, 255, 255, 0.2)"
          })
        })
      }),
      new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
          color: [0, 0, 0, 1],
          width: 2,
          lineDash: [4, 8],
          lineDashOffset: 6
        })
      }),
      new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
          color: [255, 255, 255, 1],
          width: 2,
          lineDash: [4, 8]
        })
      })
    ];
    this.labelStyle = new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
      text: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({
        font: "14px Calibri,sans-serif",
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(255, 255, 255, 1)"
        }),
        backgroundFill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(0, 0, 0, 0.7)"
        }),
        padding: [3, 3, 3, 3],
        textBaseline: "bottom",
        offsetY: -15
      }),
      image: new ol_style__WEBPACK_IMPORTED_MODULE_6__["default"]({
        radius: 8,
        points: 3,
        angle: Math.PI,
        displacement: [0, 10],
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(0, 0, 0, 0.7)"
        })
      })
    });
    this.tipStyle = new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
      text: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({
        font: "12px Calibri,sans-serif",
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(255, 255, 255, 1)"
        }),
        backgroundFill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(0, 0, 0, 0.4)"
        }),
        padding: [2, 2, 2, 2],
        textAlign: "left",
        offsetX: 15
      })
    });
    this.modifyStyle = new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
      image: new ol_style__WEBPACK_IMPORTED_MODULE_7__["default"]({
        radius: 5,
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
          color: "rgba(0, 0, 0, 0.7)"
        }),
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(0, 0, 0, 0.4)"
        })
      }),
      text: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({
        text: "Drag to modify",
        font: "12px Calibri,sans-serif",
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(255, 255, 255, 1)"
        }),
        backgroundFill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: "rgba(0, 0, 0, 0.7)"
        }),
        padding: [2, 2, 2, 2],
        textAlign: "left",
        offsetX: 15
      })
    });
    this.modify = new ol_interaction__WEBPACK_IMPORTED_MODULE_9__["default"]({ source: this.getSource(), style: this.modifyStyle });
    this.setStyle((feature) => {
      return this.styleFunction(feature, false);
    });
    this.setVisible(true);
  }
  setOptions(options) {
    var _a;
    this.opts = options;
    (_a = this.getSource()) == null ? void 0 : _a.refresh();
  }
  getMapMeasurement(geo) {
    let v = 0;
    let action = _utils_measure__WEBPACK_IMPORTED_MODULE_0__.measures[0];
    if (this.opts.action === "area") {
      action = _utils_measure__WEBPACK_IMPORTED_MODULE_0__.measures[1];
      v = (0,ol_sphere__WEBPACK_IMPORTED_MODULE_10__.getArea)(geo);
    } else {
      v = (0,ol_sphere__WEBPACK_IMPORTED_MODULE_10__.getLength)(geo);
    }
    return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_11__.formattedValueToString)(action.getUnit(this.opts.unit).format(v));
  }
  // global so we can remove it later
  styleFunction(feature, segments, drawType, tip) {
    const styles = [...this.shapeStyle];
    const geometry = feature.getGeometry();
    if (geometry) {
      const type = geometry.getType();
      let point;
      let label;
      let line;
      if (!drawType || drawType === type) {
        if (type === "Polygon" && geometry instanceof ol_geom__WEBPACK_IMPORTED_MODULE_12__["default"]) {
          point = geometry.getInteriorPoint();
          label = this.getMapMeasurement(geometry);
          line = new ol_geom__WEBPACK_IMPORTED_MODULE_13__["default"](geometry.getCoordinates()[0]);
        } else if (type === "LineString" && geometry instanceof ol_geom__WEBPACK_IMPORTED_MODULE_13__["default"]) {
          point = new ol_geom__WEBPACK_IMPORTED_MODULE_14__["default"](geometry.getLastCoordinate());
          label = this.getMapMeasurement(geometry);
        }
      }
      if (segments && line) {
        let count = 0;
        line.forEachSegment((a, b) => {
          const segment = new ol_geom__WEBPACK_IMPORTED_MODULE_13__["default"]([a, b]);
          const label2 = this.getMapMeasurement(segment);
          if (this.segmentStyles.length - 1 < count) {
            this.segmentStyles.push(this.segmentStyle.clone());
          }
          const segmentPoint = new ol_geom__WEBPACK_IMPORTED_MODULE_14__["default"](segment.getCoordinateAt(0.5));
          this.segmentStyles[count].setGeometry(segmentPoint);
          this.segmentStyles[count].getText().setText(label2);
          styles.push(this.segmentStyles[count]);
          count++;
        });
      }
      if (label) {
        this.labelStyle.setGeometry(point);
        this.labelStyle.getText().setText(label);
        styles.push(this.labelStyle);
      }
      if (tip && type === "Point" && geometry instanceof ol_geom__WEBPACK_IMPORTED_MODULE_14__["default"] && !this.modify.getOverlay().getSource().getFeatures().length) {
        this.tipPoint = geometry;
        this.tipStyle.getText().setText(tip);
        styles.push(this.tipStyle);
      }
    }
    return styles;
  }
  addInteraction(map, typeSelect, showSegments, clearPrevious) {
    const drawType = typeSelect;
    const activeTip = " Click to continue " + (drawType === "Polygon" ? "polygon" : "line") + " \n (double-click to end) ";
    const idleTip = " Click to start ";
    let tip = idleTip;
    this.draw = new ol_interaction__WEBPACK_IMPORTED_MODULE_15__["default"]({
      source: this.getSource(),
      type: drawType,
      style: (feature) => {
        return this.styleFunction(feature, showSegments, drawType, tip);
      }
    });
    this.draw.on("drawstart", () => {
      if (clearPrevious) {
        this.getSource().clear();
      }
      this.modify.setActive(false);
      tip = activeTip;
    });
    this.draw.on("drawend", () => {
      this.modifyStyle.setGeometry(this.tipPoint);
      this.modify.setActive(true);
      map.once("pointermove", () => {
        this.modifyStyle.setGeometry("");
      });
      tip = idleTip;
    });
    this.modify.setActive(true);
    map.addInteraction(this.draw);
  }
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/components/ObservablePropsWrapper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObservablePropsWrapper: () => (/* binding */ ObservablePropsWrapper)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


class ObservablePropsWrapper extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = {
      subProps: props.initialSubProps
    };
  }
  componentDidMount() {
    this.sub = this.props.watch.subscribe({
      next: (subProps) => {
        this.setState({ subProps });
      },
      complete: () => {
      },
      error: (err) => {
      }
    });
  }
  componentWillUnmount() {
    if (this.sub) {
      this.sub.unsubscribe();
    }
  }
  render() {
    const { subProps } = this.state;
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(this.props.child, { ...subProps });
  }
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/editor/CoordinatesMapViewEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CoordinatesMapViewEditor: () => (/* binding */ CoordinatesMapViewEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/core/components/OptionsUI/NumberInput.tsx");




const CoordinatesMapViewEditor = ({ labelWidth, value, onChange }) => {
  const onLatitudeChange = (latitude) => {
    onChange({ ...value, lat: latitude });
  };
  const onLongitudeChange = (longitude) => {
    onChange({ ...value, lon: longitude });
  };
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, { label: "Latitude", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_1__.NumberInput, { value: value.lat, min: -90, max: 90, step: 1e-3, onChange: onLatitudeChange }))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, { label: "Longitude", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_1__.NumberInput, { value: value.lon, min: -180, max: 180, step: 1e-3, onChange: onLongitudeChange }))));
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/editor/FitMapViewEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FitMapViewEditor: () => (/* binding */ FitMapViewEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/RadioButtonGroup/RadioButtonGroup.tsx");
/* harmony import */ var _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/core/components/OptionsUI/NumberInput.tsx");




var DataScopeValues = /* @__PURE__ */ ((DataScopeValues2) => {
  DataScopeValues2["all"] = "all";
  DataScopeValues2["layer"] = "layer";
  DataScopeValues2["last"] = "last";
  return DataScopeValues2;
})(DataScopeValues || {});
var DataScopeLabels = /* @__PURE__ */ ((DataScopeLabels2) => {
  DataScopeLabels2["all"] = "All layers";
  DataScopeLabels2["layer"] = "Layer";
  DataScopeLabels2["last"] = "Last value";
  return DataScopeLabels2;
})(DataScopeLabels || {});
const ScopeOptions = Object.values(DataScopeValues);
const DataScopeOptions = ScopeOptions.map((dataScopeOption) => ({
  label: DataScopeLabels[dataScopeOption],
  value: dataScopeOption
}));
const FitMapViewEditor = ({ labelWidth, value, onChange, context }) => {
  var _a, _b, _c;
  const layers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    var _a2;
    if ((_a2 = context.options) == null ? void 0 : _a2.layers) {
      return context.options.layers.map((layer) => ({
        label: layer.name,
        value: layer.name,
        description: void 0
      }));
    }
    return [];
  }, [(_a = context.options) == null ? void 0 : _a.layers]);
  const onSelectLayer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (selection) => {
      onChange({ ...value, layer: selection.value });
    },
    [value, onChange]
  );
  const allLayersEditorFragment = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, { label: "Layer", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, { options: layers, onChange: onSelectLayer, placeholder: (_b = layers[0]) == null ? void 0 : _b.label })));
  const onChangePadding = (padding) => {
    onChange({ ...value, padding });
  };
  const lastOnlyEditorFragment = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField,
    {
      label: "Padding",
      labelWidth,
      grow: true,
      tooltip: "sets padding in relative percent beyond data extent"
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_1__.NumberInput, { value: (_c = value == null ? void 0 : value.padding) != null ? _c : 5, min: 0, step: 1, onChange: onChangePadding })
  ));
  const currentDataScope = value.allLayers ? "all" /* all */ : !value.allLayers && value.lastOnly ? "last" /* last */ : "layer" /* layer */;
  const onDataScopeChange = (dataScope) => {
    if (dataScope !== "all" /* all */ && !value.layer) {
      onChange({
        ...value,
        allLayers: dataScope === String("all" /* all */),
        lastOnly: dataScope === String("last" /* last */),
        layer: layers[0].value
      });
    } else {
      onChange({
        ...value,
        allLayers: dataScope === String("all" /* all */),
        lastOnly: dataScope === String("last" /* last */)
      });
    }
  };
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, { label: "Data", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_5__.RadioButtonGroup,
    {
      value: currentDataScope,
      options: DataScopeOptions,
      onChange: onDataScopeChange
    }
  ))), !(value == null ? void 0 : value.allLayers) && allLayersEditorFragment, !(value == null ? void 0 : value.lastOnly) && lastOnlyEditorFragment);
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/editor/GeomapStyleRulesEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomapStyleRulesEditor: () => (/* binding */ GeomapStyleRulesEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/components/Button/Button.tsx");
/* harmony import */ var _layers_data_geojsonLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/geojsonLayer.ts");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _StyleRuleEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/StyleRuleEditor.tsx");






const GeomapStyleRulesEditor = ({ value, onChange, context, item }) => {
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useTheme2)();
  const settings = item.settings;
  const onAddRule = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    const { palette } = theme.visualization;
    const color = {
      fixed: palette[Math.floor(Math.random() * palette.length)]
    };
    const newRule = [...value, { ..._layers_data_geojsonLayer__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_STYLE_RULE, style: { ..._style_types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig, color } }];
    onChange(newRule);
  }, [onChange, value, theme.visualization]);
  const onRuleChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (idx) => (style) => {
      const copyStyles = [...value];
      if (style) {
        copyStyles[idx] = style;
      } else {
        copyStyles.splice(idx, 1);
      }
      onChange(copyStyles);
    },
    [onChange, value]
  );
  const styleOptions = value && value.map((style, idx) => {
    var _a;
    const itemSettings = {
      settings
    };
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
      _StyleRuleEditor__WEBPACK_IMPORTED_MODULE_3__.StyleRuleEditor,
      {
        value: style,
        onChange: onRuleChange(idx),
        context,
        item: itemSettings,
        key: "".concat(idx, "-").concat((_a = style.check) == null ? void 0 : _a.property)
      }
    );
  });
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, styleOptions, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Button, { size: "sm", icon: "plus", onClick: onAddRule, variant: "secondary", "aria-label": "Add geomap style rule" }, "Add style rule"));
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/editor/LayersEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayersEditor: () => (/* binding */ LayersEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/components/Layout/Layout.tsx");
/* harmony import */ var _core_components_Layers_AddLayerButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/core/components/Layers/AddLayerButton.tsx");
/* harmony import */ var _core_components_Layers_LayerDragDropList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/Layers/LayerDragDropList.tsx");
/* harmony import */ var _layers_registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/registry.ts");






const LayersEditor = (props) => {
  var _a, _b;
  const { layers, selected, actions } = (_a = props.context.instanceState) != null ? _a : {};
  if (!layers || !actions) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, "No layers?");
  }
  const onDragEnd = (result) => {
    var _a2;
    if (!result.destination) {
      return;
    }
    const { layers: layers2, actions: actions2 } = (_a2 = props.context.instanceState) != null ? _a2 : {};
    if (!layers2 || !actions2) {
      return;
    }
    const count = layers2.length - 1;
    const src = (result.source.index - count) * -1;
    const dst = (result.destination.index - count) * -1;
    actions2.reorder(src, dst);
  };
  const onSelect = (element) => {
    actions.selectLayer(element.options.name);
  };
  const onDelete = (element) => {
    actions.deleteLayer(element.options.name);
  };
  const getLayerInfo = (element) => {
    return element.options.type;
  };
  const onNameChange = (element, name) => {
    element.onChange({ ...element.options, name });
  };
  const selection = selected ? [(_b = layers[selected]) == null ? void 0 : _b.getName()] : [];
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Container, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _core_components_Layers_AddLayerButton__WEBPACK_IMPORTED_MODULE_1__.AddLayerButton,
    {
      onChange: (v) => actions.addlayer(v.value),
      options: (0,_layers_registry__WEBPACK_IMPORTED_MODULE_3__.getLayersOptions)(false).options,
      label: "Add layer"
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("br", null), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    _core_components_Layers_LayerDragDropList__WEBPACK_IMPORTED_MODULE_2__.LayerDragDropList,
    {
      layers,
      showActions: () => layers.length > 2,
      getLayerInfo,
      onDragEnd,
      onSelect,
      onDelete,
      selection,
      excludeBaseLayer: true,
      onNameChange,
      verifyLayerNameUniqueness: actions.canRename
    }
  ));
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/editor/MapViewEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MapViewEditor: () => (/* binding */ MapViewEditor)
/* harmony export */ });
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-ui/src/components/Layout/Layout.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./packages/grafana-ui/src/components/Button/Button.tsx");
/* harmony import */ var _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/OptionsUI/NumberInput.tsx");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/view.ts");
/* harmony import */ var _CoordinatesMapViewEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/CoordinatesMapViewEditor.tsx");
/* harmony import */ var _FitMapViewEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/FitMapViewEditor.tsx");








const MapViewEditor = ({
  value,
  onChange,
  context
}) => {
  var _a;
  const labelWidth = 10;
  const views = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    const ids = [];
    if (value == null ? void 0 : value.id) {
      ids.push(value.id);
    } else {
      ids.push(_view__WEBPACK_IMPORTED_MODULE_3__.centerPointRegistry.list()[0].id);
    }
    return _view__WEBPACK_IMPORTED_MODULE_3__.centerPointRegistry.selectOptions(ids);
  }, [value == null ? void 0 : value.id]);
  const onSetCurrentView = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
    var _a2;
    const map = (_a2 = context.instanceState) == null ? void 0 : _a2.map;
    if (map) {
      const view = map.getView();
      const coords = view.getCenter();
      if (coords) {
        const center = (0,ol_proj__WEBPACK_IMPORTED_MODULE_0__.toLonLat)(coords, view.getProjection());
        onChange({
          ...value,
          id: _view__WEBPACK_IMPORTED_MODULE_3__.MapCenterID.Coordinates,
          lon: +center[0].toFixed(6),
          lat: +center[1].toFixed(6),
          zoom: +view.getZoom().toFixed(2)
        });
      }
    }
  }, [value, onChange, context.instanceState]);
  const onSelectView = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (selection) => {
      var _a2, _b, _c;
      const v = _view__WEBPACK_IMPORTED_MODULE_3__.centerPointRegistry.getIfExists(selection.value);
      if (v) {
        onChange({
          ...value,
          id: v.id,
          lat: (_a2 = v.lat) != null ? _a2 : value == null ? void 0 : value.lat,
          lon: (_b = v.lon) != null ? _b : value == null ? void 0 : value.lon,
          zoom: (_c = v.zoom) != null ? _c : value == null ? void 0 : value.zoom
        });
      }
    },
    [value, onChange]
  );
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.InlineField, { label: "View", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_8__.Select, { options: views.options, value: views.current, onChange: onSelectView }))), value.id === _view__WEBPACK_IMPORTED_MODULE_3__.MapCenterID.Coordinates && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_CoordinatesMapViewEditor__WEBPACK_IMPORTED_MODULE_4__.CoordinatesMapViewEditor, { labelWidth, value, onChange }), value.id === _view__WEBPACK_IMPORTED_MODULE_3__.MapCenterID.Fit && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_FitMapViewEditor__WEBPACK_IMPORTED_MODULE_5__.FitMapViewEditor, { labelWidth, value, onChange, context }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_7__.InlineField, { label: (value == null ? void 0 : value.id) === _view__WEBPACK_IMPORTED_MODULE_3__.MapCenterID.Fit ? "Max Zoom" : "Zoom", labelWidth, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__.NumberInput,
    {
      value: (_a = value == null ? void 0 : value.zoom) != null ? _a : 1,
      min: 1,
      max: 18,
      step: 0.01,
      onChange: (v) => {
        onChange({ ...value, zoom: v });
      }
    }
  ))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_9__.VerticalGroup, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_10__.Button, { variant: "secondary", size: "sm", fullWidth: true, onClick: onSetCurrentView }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", null, "Use current map settings"))));
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/editor/StyleEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StyleEditor: () => (/* binding */ StyleEditor)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/react-use/esm/useObservable.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/Field.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineLabel.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./packages/grafana-ui/src/components/ColorPicker/ColorPicker.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/RadioButtonGroup/RadioButtonGroup.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./packages/grafana-ui/src/components/Layout/Layout.tsx");
/* harmony import */ var _core_components_OptionsUI_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/OptionsUI/number.tsx");
/* harmony import */ var _core_components_OptionsUI_slider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/components/OptionsUI/slider.tsx");
/* harmony import */ var _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var _features_dimensions_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/dimensions/types.ts");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _style_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/style/utils.ts");












const StyleEditor = (props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
  const { value, onChange, item } = props;
  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    var _a2;
    if (!((_a2 = item.settings) == null ? void 0 : _a2.frameMatcher)) {
      return props.context;
    }
    return { ...props.context, data: props.context.data.filter(item.settings.frameMatcher) };
  }, [props.context, item.settings]);
  const settings = item.settings;
  const onSizeChange = (sizeValue) => {
    onChange({ ...value, size: sizeValue });
  };
  const onSymbolChange = (symbolValue) => {
    onChange({ ...value, symbol: symbolValue });
  };
  const onColorChange = (colorValue) => {
    onChange({ ...value, color: colorValue });
  };
  const onOpacityChange = (opacityValue) => {
    onChange({ ...value, opacity: opacityValue });
  };
  const onRotationChange = (rotationValue) => {
    onChange({ ...value, rotation: rotationValue });
  };
  const onTextChange = (textValue) => {
    onChange({ ...value, text: textValue });
  };
  const onTextFontSizeChange = (fontSize) => {
    onChange({ ...value, textConfig: { ...value.textConfig, fontSize } });
  };
  const onTextOffsetXChange = (offsetX) => {
    onChange({ ...value, textConfig: { ...value.textConfig, offsetX } });
  };
  const onTextOffsetYChange = (offsetY) => {
    onChange({ ...value, textConfig: { ...value.textConfig, offsetY } });
  };
  const onTextAlignChange = (textAlign) => {
    onChange({ ...value, textConfig: { ...value.textConfig, textAlign } });
  };
  const onTextBaselineChange = (textBaseline) => {
    onChange({ ...value, textConfig: { ...value.textConfig, textBaseline } });
  };
  const onAlignHorizontalChange = (alignHorizontal) => {
    onChange({ ...value, symbolAlign: { ...value == null ? void 0 : value.symbolAlign, horizontal: alignHorizontal } });
  };
  const onAlignVerticalChange = (alignVertical) => {
    onChange({ ...value, symbolAlign: { ...value == null ? void 0 : value.symbolAlign, vertical: alignVertical } });
  };
  const propertyOptions = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])((_a = settings == null ? void 0 : settings.layerInfo) != null ? _a : (0,rxjs__WEBPACK_IMPORTED_MODULE_9__.of)());
  const featuresHavePoints = (propertyOptions == null ? void 0 : propertyOptions.geometryType) === _style_types__WEBPACK_IMPORTED_MODULE_6__.GeometryTypeId.Point;
  const hasTextLabel = (0,_style_utils__WEBPACK_IMPORTED_MODULE_7__.styleUsesText)(value);
  const maxFiles = 2e3;
  if (settings == null ? void 0 : settings.simpleFixedValues) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, featuresHavePoints && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_10__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_11__.InlineField, { label: "Symbol" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
      _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionEditor,
      {
        value: (_b = value == null ? void 0 : value.symbol) != null ? _b : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.symbol,
        context,
        onChange: onSymbolChange,
        item: {
          settings: {
            resourceType: "icon",
            folderName: _features_dimensions_types__WEBPACK_IMPORTED_MODULE_5__.ResourceFolderName.Marker,
            placeholderText: hasTextLabel ? "Select a symbol" : "Select a symbol or add a text label",
            placeholderValue: _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.symbol.fixed,
            showSourceRadio: false,
            maxFiles
          }
        }
      }
    ))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Rotation angle" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
      _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ScalarDimensionEditor,
      {
        value: (_c = value == null ? void 0 : value.rotation) != null ? _c : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.rotation,
        context,
        onChange: onRotationChange,
        item: {
          settings: {
            min: _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.rotation.min,
            max: _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.rotation.max
          }
        }
      }
    ))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_10__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_11__.InlineField, { label: "Color", labelWidth: 10 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_13__.InlineLabel, { width: 4 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
      _grafana_ui__WEBPACK_IMPORTED_MODULE_14__.ColorPicker,
      {
        color: (_e = (_d = value == null ? void 0 : value.color) == null ? void 0 : _d.fixed) != null ? _e : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.color.fixed,
        onChange: (v) => {
          onColorChange({ fixed: v });
        }
      }
    )))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_10__.InlineFieldRow, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_11__.InlineField, { label: "Opacity", labelWidth: 10, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
      _core_components_OptionsUI_slider__WEBPACK_IMPORTED_MODULE_3__.SliderValueEditor,
      {
        value: (_f = value == null ? void 0 : value.opacity) != null ? _f : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.opacity,
        context,
        onChange: onOpacityChange,
        item: {
          settings: {
            min: 0,
            max: 1,
            step: 0.1
          }
        }
      }
    ))));
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Size" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ScaleDimensionEditor,
    {
      value: (_g = value == null ? void 0 : value.size) != null ? _g : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.size,
      context,
      onChange: onSizeChange,
      item: {
        settings: {
          min: 1,
          max: 100
        }
      }
    }
  )), !(settings == null ? void 0 : settings.hideSymbol) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Symbol" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionEditor,
    {
      value: (_h = value == null ? void 0 : value.symbol) != null ? _h : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.symbol,
      context,
      onChange: onSymbolChange,
      item: {
        settings: {
          resourceType: _features_dimensions_types__WEBPACK_IMPORTED_MODULE_5__.MediaType.Icon,
          folderName: _features_dimensions_types__WEBPACK_IMPORTED_MODULE_5__.ResourceFolderName.Marker,
          placeholderText: hasTextLabel ? "Select a symbol" : "Select a symbol or add a text label",
          placeholderValue: _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.symbol.fixed,
          showSourceRadio: false,
          maxFiles
        }
      }
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Symbol Vertical Align" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_15__.RadioButtonGroup,
    {
      value: (_j = (_i = value == null ? void 0 : value.symbolAlign) == null ? void 0 : _i.vertical) != null ? _j : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.symbolAlign.vertical,
      onChange: onAlignVerticalChange,
      options: [
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.VerticalAlign.Top, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.VerticalAlign.Top) },
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.VerticalAlign.Center, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.VerticalAlign.Center) },
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.VerticalAlign.Bottom, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.VerticalAlign.Bottom) }
      ]
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Symbol Horizontal Align" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_15__.RadioButtonGroup,
    {
      value: (_l = (_k = value == null ? void 0 : value.symbolAlign) == null ? void 0 : _k.horizontal) != null ? _l : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.symbolAlign.horizontal,
      onChange: onAlignHorizontalChange,
      options: [
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.HorizontalAlign.Left, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.HorizontalAlign.Left) },
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.HorizontalAlign.Center, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.HorizontalAlign.Center) },
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.HorizontalAlign.Right, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.HorizontalAlign.Right) }
      ]
    }
  ))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Color" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ColorDimensionEditor,
    {
      value: (_m = value == null ? void 0 : value.color) != null ? _m : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.color,
      context,
      onChange: onColorChange,
      item: {}
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Fill opacity" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _core_components_OptionsUI_slider__WEBPACK_IMPORTED_MODULE_3__.SliderValueEditor,
    {
      value: (_n = value == null ? void 0 : value.opacity) != null ? _n : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.opacity,
      context,
      onChange: onOpacityChange,
      item: {
        settings: {
          min: 0,
          max: 1,
          step: 0.1
        }
      }
    }
  )), (settings == null ? void 0 : settings.displayRotation) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Rotation angle" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ScalarDimensionEditor,
    {
      value: (_o = value == null ? void 0 : value.rotation) != null ? _o : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.rotation,
      context,
      onChange: onRotationChange,
      item: {
        settings: {
          min: _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.rotation.min,
          max: _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.rotation.max
        }
      }
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Text label" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.TextDimensionEditor,
    {
      value: (_p = value == null ? void 0 : value.text) != null ? _p : _features_dimensions_types__WEBPACK_IMPORTED_MODULE_5__.defaultTextConfig,
      context,
      onChange: onTextChange,
      item: {}
    }
  )), hasTextLabel && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_16__.HorizontalGroup, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Font size" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _core_components_OptionsUI_number__WEBPACK_IMPORTED_MODULE_2__.NumberValueEditor,
    {
      value: (_r = (_q = value == null ? void 0 : value.textConfig) == null ? void 0 : _q.fontSize) != null ? _r : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.textConfig.fontSize,
      context,
      onChange: onTextFontSizeChange,
      item: {}
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "X offset" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _core_components_OptionsUI_number__WEBPACK_IMPORTED_MODULE_2__.NumberValueEditor,
    {
      value: (_t = (_s = value == null ? void 0 : value.textConfig) == null ? void 0 : _s.offsetX) != null ? _t : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.textConfig.offsetX,
      context,
      onChange: onTextOffsetXChange,
      item: {}
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Y offset" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _core_components_OptionsUI_number__WEBPACK_IMPORTED_MODULE_2__.NumberValueEditor,
    {
      value: (_v = (_u = value == null ? void 0 : value.textConfig) == null ? void 0 : _u.offsetY) != null ? _v : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.textConfig.offsetY,
      context,
      onChange: onTextOffsetYChange,
      item: {}
    }
  ))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Align" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_15__.RadioButtonGroup,
    {
      value: (_x = (_w = value == null ? void 0 : value.textConfig) == null ? void 0 : _w.textAlign) != null ? _x : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.textConfig.textAlign,
      onChange: onTextAlignChange,
      options: [
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.TextAlignment.Left, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.TextAlignment.Left) },
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.TextAlignment.Center, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.TextAlignment.Center) },
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.TextAlignment.Right, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.TextAlignment.Right) }
      ]
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.Field, { label: "Baseline" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_15__.RadioButtonGroup,
    {
      value: (_z = (_y = value == null ? void 0 : value.textConfig) == null ? void 0 : _y.textBaseline) != null ? _z : _style_types__WEBPACK_IMPORTED_MODULE_6__.defaultStyleConfig.textConfig.textBaseline,
      onChange: onTextBaselineChange,
      options: [
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.TextBaseline.Top, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.TextBaseline.Top) },
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.TextBaseline.Middle, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.TextBaseline.Middle) },
        { value: _style_types__WEBPACK_IMPORTED_MODULE_6__.TextBaseline.Bottom, label: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(_style_types__WEBPACK_IMPORTED_MODULE_6__.TextBaseline.Bottom) }
      ]
    }
  ))));
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/editor/StyleRuleEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StyleRuleEditor: () => (/* binding */ StyleRuleEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/react-use/esm/useObservable.js");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineFieldRow.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/InlineField.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./packages/grafana-ui/src/components/Select/Select.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./packages/grafana-ui/src/components/Button/Button.tsx");
/* harmony import */ var _grafana_ui_src_components_MatchersUI_FieldValueMatcher__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./packages/grafana-ui/src/components/MatchersUI/FieldValueMatcher.tsx");
/* harmony import */ var _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/OptionsUI/NumberInput.tsx");
/* harmony import */ var _layers_data_geojsonLayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/geojsonLayer.ts");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _utils_getFeatures__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/getFeatures.ts");
/* harmony import */ var _utils_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/selection.ts");
/* harmony import */ var _StyleEditor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/StyleEditor.tsx");













const StyleRuleEditor = ({ value, onChange, item, context }) => {
  var _a, _b;
  const settings = item.settings;
  if (!settings) {
    throw Error("Settings not found");
  }
  const { features, layerInfo } = settings;
  const propertyOptions = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])(layerInfo);
  const feats = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])(features);
  const uniqueSelectables = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    var _a2, _b2;
    const key = (_a2 = value == null ? void 0 : value.check) == null ? void 0 : _a2.property;
    if (key && feats && ((_b2 = value.check) == null ? void 0 : _b2.operation) === _grafana_schema__WEBPACK_IMPORTED_MODULE_9__.ComparisonOperation.EQ) {
      return (0,_utils_getFeatures__WEBPACK_IMPORTED_MODULE_5__.getUniqueFeatureValues)(feats, key).map((v) => {
        let newValue;
        let isNewValueNumber = !isNaN(Number(v));
        if (isNewValueNumber) {
          newValue = {
            value: Number(v),
            label: v
          };
        } else {
          newValue = { value: v, label: v };
        }
        return newValue;
      });
    }
    return [];
  }, [feats, value]);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_10__.useStyles2)(getStyles);
  const LABEL_WIDTH = 10;
  const onChangeProperty = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (selection) => {
      onChange({
        ...value,
        check: {
          ...value.check,
          property: selection == null ? void 0 : selection.value
        }
      });
    },
    [onChange, value]
  );
  const onChangeComparison = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (selection) => {
      var _a2;
      onChange({
        ...value,
        check: {
          ...value.check,
          operation: (_a2 = selection.value) != null ? _a2 : _grafana_schema__WEBPACK_IMPORTED_MODULE_9__.ComparisonOperation.EQ
        }
      });
    },
    [onChange, value]
  );
  const onChangeValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (selection) => {
      onChange({
        ...value,
        check: {
          ...value.check,
          value: selection == null ? void 0 : selection.value
        }
      });
    },
    [onChange, value]
  );
  const onChangeNumericValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (v) => {
      onChange({
        ...value,
        check: {
          ...value.check,
          value: v
        }
      });
    },
    [onChange, value]
  );
  const onChangeStyle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
    (style) => {
      onChange({ ...value, style });
    },
    [onChange, value]
  );
  const onDelete = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
    onChange(void 0);
  }, [onChange]);
  const check = (_a = value.check) != null ? _a : _layers_data_geojsonLayer__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_STYLE_RULE.check;
  const propv = (0,_utils_selection__WEBPACK_IMPORTED_MODULE_6__.getSelectionInfo)(check.property, propertyOptions == null ? void 0 : propertyOptions.propertes);
  const valuev = (0,_utils_selection__WEBPACK_IMPORTED_MODULE_6__.getSelectionInfo)(check.value, uniqueSelectables);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.rule }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_11__.InlineFieldRow, { className: styles.row }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.InlineField, { label: "Rule", labelWidth: LABEL_WIDTH, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_13__.Select,
    {
      placeholder: "Feature property",
      value: propv.current,
      options: propv.options,
      onChange: onChangeProperty,
      "aria-label": "Feature property",
      isClearable: true,
      allowCustomValue: true
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.InlineField, { className: styles.inline }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_13__.Select,
    {
      value: _grafana_ui_src_components_MatchersUI_FieldValueMatcher__WEBPACK_IMPORTED_MODULE_14__.comparisonOperationOptions.find((v) => v.value === check.operation),
      options: _grafana_ui_src_components_MatchersUI_FieldValueMatcher__WEBPACK_IMPORTED_MODULE_14__.comparisonOperationOptions,
      onChange: onChangeComparison,
      "aria-label": "Comparison operator",
      width: 8
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_12__.InlineField, { className: styles.inline, grow: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: styles.flexRow }, (check.operation === _grafana_schema__WEBPACK_IMPORTED_MODULE_9__.ComparisonOperation.EQ || check.operation === _grafana_schema__WEBPACK_IMPORTED_MODULE_9__.ComparisonOperation.NEQ) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_13__.Select,
    {
      placeholder: "value",
      value: valuev.current,
      options: valuev.options,
      onChange: onChangeValue,
      "aria-label": "Comparison value",
      isClearable: true,
      allowCustomValue: true
    }
  ), check.operation !== _grafana_schema__WEBPACK_IMPORTED_MODULE_9__.ComparisonOperation.EQ && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__.NumberInput,
    {
      key: "".concat(check.property, "/").concat(check.operation),
      value: !isNaN(Number(check.value)) ? Number(check.value) : 0,
      placeholder: "numeric value",
      onChange: onChangeNumericValue
    }
  ))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _grafana_ui__WEBPACK_IMPORTED_MODULE_15__.Button,
    {
      size: "md",
      icon: "trash-alt",
      onClick: () => onDelete(),
      variant: "secondary",
      "aria-label": "Delete style rule",
      className: styles.button
    }
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(
    _StyleEditor__WEBPACK_IMPORTED_MODULE_7__.StyleEditor,
    {
      value: (_b = value.style) != null ? _b : _style_types__WEBPACK_IMPORTED_MODULE_4__.defaultStyleConfig,
      context,
      onChange: onChangeStyle,
      item: {
        settings: {
          simpleFixedValues: true,
          layerInfo
        }
      }
    }
  )));
};
const getStyles = (theme) => ({
  rule: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    marginBottom: theme.spacing(1)
  }),
  row: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    display: "flex",
    marginBottom: "4px"
  }),
  inline: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    marginBottom: 0,
    marginLeft: "4px"
  }),
  button: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    marginLeft: "4px"
  }),
  flexRow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
    display: "flex",
    flexDirection: "row",
    alignItems: "flex-start"
  })
});


/***/ }),

/***/ "./public/app/plugins/panel/geomap/editor/layerEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLayerEditor: () => (/* binding */ getLayerEditor)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-data/src/transformations/matchers.ts");
/* harmony import */ var _features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _features_geo_editor_locationEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/geo/editor/locationEditor.ts");
/* harmony import */ var _layers_data_markersLayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/markersLayer.tsx");
/* harmony import */ var _layers_registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/registry.ts");
/* harmony import */ var _FrameSelectionEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/FrameSelectionEditor.tsx");








function getLayerEditor(opts) {
  return {
    category: opts.category,
    path: "--",
    // Not used
    defaultValue: opts.basemaps ? _layers_registry__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BASEMAP_CONFIG : _layers_data_markersLayer__WEBPACK_IMPORTED_MODULE_3__.defaultMarkersConfig,
    values: (parent) => ({
      getContext: (parent2) => {
        return { ...parent2, options: opts.state.options, instanceState: opts.state };
      },
      getValue: (path) => (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(opts.state.options, path),
      onChange: (path, value) => {
        var _a;
        const { state } = opts;
        const { options } = state;
        if (path === "type" && value) {
          const layer = _layers_registry__WEBPACK_IMPORTED_MODULE_4__.geomapLayerRegistry.getIfExists(value);
          if (layer) {
            const opts2 = {
              ...options,
              // keep current shared options
              type: layer.id,
              config: { ...layer.defaultOptions }
              // clone?
            };
            if (layer.showLocation) {
              if (!((_a = opts2.location) == null ? void 0 : _a.mode)) {
                opts2.location = { mode: _grafana_data__WEBPACK_IMPORTED_MODULE_6__.FrameGeometrySourceMode.Auto };
              } else {
                delete opts2.location;
              }
            }
            state.onChange(opts2);
            return;
          }
        }
        state.onChange((0,_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_1__.setOptionImmutably)(options, path, value));
      }
    }),
    build: (builder, context) => {
      if (!opts.state) {
        return;
      }
      const { handler, options } = opts.state;
      const layer = _layers_registry__WEBPACK_IMPORTED_MODULE_4__.geomapLayerRegistry.getIfExists(options == null ? void 0 : options.type);
      const layerTypes = (0,_layers_registry__WEBPACK_IMPORTED_MODULE_4__.getLayersOptions)(
        opts.basemaps,
        (options == null ? void 0 : options.type) ? options.type : _layers_registry__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BASEMAP_CONFIG.type
      );
      builder.addSelect({
        path: "type",
        name: "Layer type",
        // required, but hide space
        settings: {
          options: layerTypes.options
        }
      });
      if (handler.update) {
        builder.addCustomEditor({
          id: "filterData",
          path: "filterData",
          name: "Data",
          editor: _FrameSelectionEditor__WEBPACK_IMPORTED_MODULE_5__.FrameSelectionEditor,
          defaultValue: void 0
        });
      }
      if (!layer) {
        return;
      }
      if (options.type === _layers_registry__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BASEMAP_CONFIG.type) {
        return;
      }
      if (layer.showLocation) {
        let data = context.data;
        if (options.filterData) {
          const matcherFunc = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_7__.getFrameMatchers)(options.filterData);
          data = data.filter(matcherFunc);
        }
        (0,_features_geo_editor_locationEditor__WEBPACK_IMPORTED_MODULE_2__.addLocationFields)("Location", "location.", builder, options.location, data);
      }
      if (handler.registerOptionsUI) {
        handler.registerOptionsUI(builder, context);
      }
      if (!(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(opts.category, ["Base layer"])) {
        if (!layer.hideOpacity) {
          builder.addSliderInput({
            path: "opacity",
            name: "Opacity",
            defaultValue: 1,
            settings: {
              min: 0,
              max: 1,
              step: 0.1
            }
          });
        }
        builder.addBooleanSwitch({
          path: "tooltip",
          name: "Display tooltip",
          description: "Show the tooltip for layer",
          defaultValue: true
        });
      }
    }
  };
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/globalStyles.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlobalStyles: () => (/* binding */ getGlobalStyles)
/* harmony export */ });
/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@emotion/react/dist/emotion-react.cjs.dev.js");
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/ol.css");
/* harmony import */ var ol_ext_dist_ol_ext_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol-ext/dist/ol-ext.css");




function getGlobalStyles(theme) {
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_2__.css)({
    ".ol-scale-line": {
      background: theme.colors.border.weak
      // rgba(0,60,136,0.3);
    },
    ".ol-scale-line-inner": {
      border: "1px solid ".concat(theme.colors.text.primary),
      // #eee;
      borderTop: 0,
      // 0px;
      color: theme.colors.text.primary
      //  #eee;
    },
    ".ol-control": {
      backgroundColor: theme.colors.background.primary
      // rgba(255,255,255,0.4);
    },
    ".ol-control:hover": {
      backgroundColor: theme.colors.background.secondary
      // rgba(255,255,255,0.6);
    },
    ".ol-control button": {
      color: theme.colors.secondary.text,
      // white;
      backgroundColor: theme.colors.secondary.main
      // rgba(0,60,136,0.5);
    },
    ".ol-control button:hover": {
      color: theme.colors.secondary.text,
      backgroundColor: theme.colors.secondary.shade
      // rgba(0,60,136,0.5);
    },
    ".ol-control button:focus": {
      color: theme.colors.secondary.text,
      backgroundColor: theme.colors.secondary.main
      // rgba(0,60,136,0.5);
    },
    ".ol-attribution ul": {
      color: theme.colors.text.primary,
      //  #000;
      textShadow: "none"
    },
    ".ol-attribution:not(.ol-collapsed)": {
      backgroundColor: theme.colors.background.secondary
      // rgba(255,255,255,0.8);
    }
  });
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/basemaps/carto.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LayerTheme: () => (/* binding */ LayerTheme),
/* harmony export */   carto: () => (/* binding */ carto),
/* harmony export */   cartoLayers: () => (/* binding */ cartoLayers),
/* harmony export */   defaultCartoConfig: () => (/* binding */ defaultCartoConfig)
/* harmony export */ });
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/Tile.js");
/* harmony import */ var ol_source_XYZ__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/source/XYZ.js");



var LayerTheme = /* @__PURE__ */ ((LayerTheme2) => {
  LayerTheme2["Auto"] = "auto";
  LayerTheme2["Light"] = "light";
  LayerTheme2["Dark"] = "dark";
  return LayerTheme2;
})(LayerTheme || {});
const defaultCartoConfig = {
  theme: "auto" /* Auto */,
  showLabels: true
};
const carto = {
  id: "carto",
  name: "CARTO basemap",
  description: "Add layer CARTO Raster basemaps",
  isBaseMap: true,
  defaultOptions: defaultCartoConfig,
  /**
   * Function that configures transformation and returns a transformer
   * @param options
   */
  create: async (map, options, eventBus, theme) => ({
    init: () => {
      const cfg = { ...defaultCartoConfig, ...options.config };
      let style = cfg.theme;
      if (!style || style === "auto" /* Auto */) {
        style = theme.isDark ? "dark" : "light";
      }
      if (cfg.showLabels) {
        style += "_all";
      } else {
        style += "_nolabels";
      }
      return new ol_layer_Tile__WEBPACK_IMPORTED_MODULE_0__["default"]({
        source: new ol_source_XYZ__WEBPACK_IMPORTED_MODULE_1__["default"]({
          attributions: '<a href="https://carto.com/attribution/">\xA9 CARTO</a>',
          url: "https://{1-4}.basemaps.cartocdn.com/".concat(style, "/{z}/{x}/{y}.png")
        })
      });
    },
    registerOptionsUI: (builder) => {
      builder.addRadio({
        path: "config.theme",
        name: "Theme",
        settings: {
          options: [
            { value: "auto" /* Auto */, label: "Auto", description: "Match grafana theme" },
            { value: "light" /* Light */, label: "Light" },
            { value: "dark" /* Dark */, label: "Dark" }
          ]
        },
        defaultValue: defaultCartoConfig.theme
      }).addBooleanSwitch({
        path: "config.showLabels",
        name: "Show labels",
        description: "",
        defaultValue: defaultCartoConfig.showLabels
      });
    }
  })
};
const cartoLayers = [carto];


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/basemaps/esri.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   esriLayers: () => (/* binding */ esriLayers),
/* harmony export */   esriXYZTiles: () => (/* binding */ esriXYZTiles),
/* harmony export */   publicServiceRegistry: () => (/* binding */ publicServiceRegistry)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/utils/Registry.ts");
/* harmony import */ var _generic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/basemaps/generic.ts");



const CUSTOM_SERVICE = "custom";
const DEFAULT_SERVICE = "streets";
const publicServiceRegistry = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.Registry(() => [
  {
    id: DEFAULT_SERVICE,
    name: "World Street Map",
    slug: "World_Street_Map"
  },
  {
    id: "world-imagery",
    name: "World Imagery",
    slug: "World_Imagery"
  },
  {
    id: "world-physical",
    name: "World Physical",
    slug: "World_Physical_Map"
  },
  {
    id: "topo",
    name: "Topographic",
    slug: "World_Topo_Map"
  },
  {
    id: "usa-topo",
    name: "USA Topographic",
    slug: "USA_Topo_Maps"
  },
  {
    id: "ocean",
    name: "World Ocean",
    slug: "Ocean/World_Ocean_Base"
  },
  {
    id: CUSTOM_SERVICE,
    name: "Custom MapServer",
    description: "Use a custom MapServer with pre-cached values",
    slug: ""
  }
]);
const esriXYZTiles = {
  id: "esri-xyz",
  name: "ArcGIS MapServer",
  description: "Add layer from an ESRI ArcGIS MapServer",
  isBaseMap: true,
  create: async (map, options, eventBus, theme) => {
    var _a;
    const cfg = { ...options.config };
    const svc = publicServiceRegistry.getIfExists((_a = cfg.server) != null ? _a : DEFAULT_SERVICE);
    if (svc.id !== CUSTOM_SERVICE) {
      const base = "https://services.arcgisonline.com/ArcGIS/rest/services/";
      cfg.url = "".concat(base).concat(svc.slug, "/MapServer/tile/{z}/{y}/{x}");
      cfg.attribution = 'Tiles \xA9 <a href="'.concat(base).concat(svc.slug, '/MapServer">ArcGIS</a>');
    }
    const opts = { ...options, config: cfg };
    return _generic__WEBPACK_IMPORTED_MODULE_0__.xyzTiles.create(map, opts, eventBus, theme).then((xyz) => {
      xyz.registerOptionsUI = (builder) => {
        builder.addSelect({
          path: "config.server",
          name: "Server instance",
          settings: {
            options: publicServiceRegistry.selectOptions().options
          }
        }).addTextInput({
          path: "config.url",
          name: "URL template",
          description: "Must include {x}, {y} or {-y}, and {z} placeholders",
          settings: {
            placeholder: _generic__WEBPACK_IMPORTED_MODULE_0__.defaultXYZConfig.url
          },
          showIf: (cfg2) => {
            var _a2;
            return ((_a2 = cfg2.config) == null ? void 0 : _a2.server) === CUSTOM_SERVICE;
          }
        }).addTextInput({
          path: "config.attribution",
          name: "Attribution",
          settings: {
            placeholder: _generic__WEBPACK_IMPORTED_MODULE_0__.defaultXYZConfig.attribution
          },
          showIf: (cfg2) => {
            var _a2;
            return ((_a2 = cfg2.config) == null ? void 0 : _a2.server) === CUSTOM_SERVICE;
          }
        });
      };
      return xyz;
    });
  },
  defaultOptions: {
    server: DEFAULT_SERVICE
  }
};
const esriLayers = [esriXYZTiles];


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/basemaps/generic.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultXYZConfig: () => (/* binding */ defaultXYZConfig),
/* harmony export */   genericLayers: () => (/* binding */ genericLayers),
/* harmony export */   xyzTiles: () => (/* binding */ xyzTiles)
/* harmony export */ });
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/Tile.js");
/* harmony import */ var ol_source_XYZ__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/source/XYZ.js");



const sampleURL = "https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer";
const defaultXYZConfig = {
  url: sampleURL + "/tile/{z}/{y}/{x}",
  attribution: 'Tiles \xA9 <a href="'.concat(sampleURL, '">ArcGIS</a>')
};
const xyzTiles = {
  id: "xyz",
  name: "XYZ Tile layer",
  description: "Add map from a generic tile layer",
  isBaseMap: true,
  create: async (map, options, eventBus, theme) => ({
    init: () => {
      var _a;
      const cfg = { ...options.config };
      if (!cfg.url) {
        cfg.url = defaultXYZConfig.url;
        cfg.attribution = (_a = cfg.attribution) != null ? _a : defaultXYZConfig.attribution;
      }
      return new ol_layer_Tile__WEBPACK_IMPORTED_MODULE_0__["default"]({
        source: new ol_source_XYZ__WEBPACK_IMPORTED_MODULE_1__["default"]({
          url: cfg.url,
          attributions: cfg.attribution
          // singular?
        }),
        minZoom: cfg.minZoom,
        maxZoom: cfg.maxZoom
      });
    },
    registerOptionsUI: (builder) => {
      builder.addTextInput({
        path: "config.url",
        name: "URL template",
        description: "Must include {x}, {y} or {-y}, and {z} placeholders",
        settings: {
          placeholder: defaultXYZConfig.url
        }
      }).addTextInput({
        path: "config.attribution",
        name: "Attribution",
        settings: {
          placeholder: defaultXYZConfig.attribution
        }
      });
    }
  })
};
const genericLayers = [xyzTiles];


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/basemaps/index.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basemapLayers: () => (/* binding */ basemapLayers)
/* harmony export */ });
/* harmony import */ var _carto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/basemaps/carto.ts");
/* harmony import */ var _esri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/basemaps/esri.ts");
/* harmony import */ var _generic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/basemaps/generic.ts");
/* harmony import */ var _osm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/basemaps/osm.ts");





const basemapLayers = [
  ..._osm__WEBPACK_IMPORTED_MODULE_3__.osmLayers,
  ..._carto__WEBPACK_IMPORTED_MODULE_0__.cartoLayers,
  ..._esri__WEBPACK_IMPORTED_MODULE_1__.esriLayers,
  // keep formatting
  ..._generic__WEBPACK_IMPORTED_MODULE_2__.genericLayers
];


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/basemaps/osm.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   osmLayers: () => (/* binding */ osmLayers),
/* harmony export */   standard: () => (/* binding */ standard)
/* harmony export */ });
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/Tile.js");
/* harmony import */ var ol_source_OSM__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/source/OSM.js");



const standard = {
  id: "osm-standard",
  name: "Open Street Map",
  description: "Add map from a collaborative free geographic world database",
  isBaseMap: true,
  /**
   * Function that configures transformation and returns a transformer
   * @param options
   */
  create: async (map, options, eventBus) => ({
    init: () => {
      return new ol_layer_Tile__WEBPACK_IMPORTED_MODULE_0__["default"]({
        source: new ol_source_OSM__WEBPACK_IMPORTED_MODULE_1__["default"]()
      });
    }
  })
};
const osmLayers = [standard];


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/dayNightLayer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DAY_NIGHT_LAYER_ID: () => (/* binding */ DAY_NIGHT_LAYER_ID),
/* harmony export */   ShowTime: () => (/* binding */ ShowTime),
/* harmony export */   dayNightLayer: () => (/* binding */ dayNightLayer),
/* harmony export */   defaultDayNightConfig: () => (/* binding */ defaultDayNightConfig)
/* harmony export */ });
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var ol_geom_Point__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var ol_layer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/layer/Group.js");
/* harmony import */ var ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/layer/VectorImage.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/style/Circle.js");
/* harmony import */ var ol_ext_source_DayNight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol-ext/source/DayNight.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js");












var ShowTime = /* @__PURE__ */ ((ShowTime2) => {
  ShowTime2["From"] = "from";
  ShowTime2["To"] = "to";
  return ShowTime2;
})(ShowTime || {});
const defaultConfig = {
  show: "to" /* To */,
  sun: false,
  nightColor: "#a7a6ba4D"
};
const DAY_NIGHT_LAYER_ID = "dayNight";
const defaultDayNightConfig = {
  type: DAY_NIGHT_LAYER_ID,
  name: "",
  // will get replaced
  config: defaultConfig,
  tooltip: true
};
const dayNightLayer = {
  id: DAY_NIGHT_LAYER_ID,
  name: "Night / Day",
  description: "Show day and night regions",
  isBaseMap: false,
  /**
   * Function that configures transformation and returns a transformer
   * @param map
   * @param options
   * @param theme
   */
  create: async (map, options, eventBus, theme) => {
    const config = {
      ...defaultConfig,
      ...options == null ? void 0 : options.config
    };
    const source = new ol_ext_source_DayNight__WEBPACK_IMPORTED_MODULE_1__["default"]({});
    const sourceMethods = Object.getPrototypeOf(source);
    const sourceLine = new ol_ext_source_DayNight__WEBPACK_IMPORTED_MODULE_1__["default"]({});
    const sourceLineMethods = Object.getPrototypeOf(sourceLine);
    const vectorLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_2__["default"]({
      source,
      style: new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({
          color: theme.visualization.getColorByName(config.nightColor)
        })
      })
    });
    const nightLineLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_2__["default"]({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_5__["default"]({
        features: []
      }),
      style: new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_6__["default"]({
          color: "#607D8B",
          width: 1.5,
          lineDash: [2, 3]
        })
      })
    });
    const sunFeature = new ol_Feature__WEBPACK_IMPORTED_MODULE_7__["default"]({
      geometry: new ol_geom_Point__WEBPACK_IMPORTED_MODULE_8__["default"]([])
    });
    const sunLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_2__["default"]({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_5__["default"]({
        features: [sunFeature]
      }),
      style: new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_9__["default"]({
          radius: 13,
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({ color: "rgb(253,184,19)" })
        })
      })
    });
    const sunLineFeature = new ol_Feature__WEBPACK_IMPORTED_MODULE_7__["default"]({
      geometry: new ol_geom_Point__WEBPACK_IMPORTED_MODULE_8__["default"]([])
    });
    const sunLineStyle = new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
      image: new ol_style__WEBPACK_IMPORTED_MODULE_9__["default"]({
        radius: 13,
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_6__["default"]({
          color: "rgb(253,184,19)",
          width: 1.5
        })
      })
    });
    const sunLineStyleDash = new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
      image: new ol_style__WEBPACK_IMPORTED_MODULE_9__["default"]({
        radius: 15,
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_6__["default"]({
          color: "#607D8B",
          width: 1.5,
          lineDash: [2, 3]
        })
      })
    });
    const sunLineLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_2__["default"]({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_5__["default"]({
        features: [sunLineFeature]
      }),
      style: [sunLineStyleDash, sunLineStyle]
    });
    const layer = new ol_layer__WEBPACK_IMPORTED_MODULE_10__["default"]({
      layers: config.sun ? [vectorLayer, sunLayer, sunLineLayer, nightLineLayer] : [vectorLayer, nightLineLayer]
    });
    const subscriptions = new rxjs__WEBPACK_IMPORTED_MODULE_11__.Subscription();
    if (false) {}
    return {
      init: () => layer,
      dispose: () => subscriptions.unsubscribe(),
      update: (data) => {
        var _a;
        const from = new Date(data.timeRange.from.valueOf());
        const to = new Date(data.timeRange.to.valueOf());
        let selectedTime = /* @__PURE__ */ new Date();
        let sunPos = [];
        if (config.show === "from" /* From */) {
          selectedTime = from;
        } else {
          selectedTime = to;
        }
        source.setTime(selectedTime);
        if (config.sun) {
          sunPos = sourceMethods.getSunPosition(selectedTime);
          (_a = sunFeature.getGeometry()) == null ? void 0 : _a.setCoordinates((0,ol_proj__WEBPACK_IMPORTED_MODULE_0__.fromLonLat)(sunPos));
        }
      },
      // Marker overlay options
      registerOptionsUI: (builder) => {
        var _a;
        if (!((_a = options.config) == null ? void 0 : _a.nightColor)) {
          options.config = { ...defaultConfig, ...options.config };
        }
        builder.addRadio({
          path: "config.show",
          name: "Show",
          settings: {
            options: [
              { label: "From", value: "from" /* From */ },
              { label: "To", value: "to" /* To */ }
            ]
          },
          defaultValue: defaultConfig.show
        });
        builder.addColorPicker({
          path: "config.nightColor",
          name: "Night region color",
          description: "Pick color of night region",
          defaultValue: defaultConfig.nightColor,
          settings: [{ enableNamedColors: false }]
        });
        builder.addBooleanSwitch({
          path: "config.sun",
          name: "Display sun",
          description: "Show the sun",
          defaultValue: defaultConfig.sun
        });
      }
    };
  },
  // fill in the default values
  defaultOptions: defaultConfig
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/geojsonDynamic.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_STYLE_RULE: () => (/* binding */ DEFAULT_STYLE_RULE),
/* harmony export */   dynamicGeoJSONLayer: () => (/* binding */ dynamicGeoJSONLayer)
/* harmony export */ });
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/Observable.js");
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/ol/format/GeoJSON.js");
/* harmony import */ var ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/ol/layer/VectorImage.js");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/first.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-data/src/types/plugin.ts");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _features_dimensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/dimensions/index.ts");
/* harmony import */ var _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/StyleEditor.tsx");
/* harmony import */ var _style_markers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/style/markers.ts");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _style_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/style/utils.ts");
/* harmony import */ var _utils_checkFeatureMatchesStyleRule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/checkFeatureMatchesStyleRule.ts");
/* harmony import */ var _utils_getFeatures__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/getFeatures.ts");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/utils.ts");


















const defaultOptions = {
  src: "public/maps/countries.geojson",
  rules: [],
  style: _style_types__WEBPACK_IMPORTED_MODULE_3__.defaultStyleConfig,
  dataStyle: {}
};
const DEFAULT_STYLE_RULE = {
  style: _style_types__WEBPACK_IMPORTED_MODULE_3__.defaultStyleConfig,
  check: {
    property: "",
    operation: _grafana_schema__WEBPACK_IMPORTED_MODULE_8__.ComparisonOperation.EQ,
    value: ""
  }
};
const dynamicGeoJSONLayer = {
  id: "dynamic-geojson",
  name: "Dynamic GeoJSON",
  description: "Style a geojson file based on query results",
  isBaseMap: false,
  state: _grafana_data__WEBPACK_IMPORTED_MODULE_9__.PluginState.alpha,
  /**
   * Function that configures transformation and returns a transformer
   * @param map
   * @param options
   * @param theme
   */
  create: async (map, options, eventBus, theme) => {
    const config = { ...defaultOptions, ...options.config };
    const source = new ol_source_Vector__WEBPACK_IMPORTED_MODULE_10__["default"]({
      url: config.src,
      format: new ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_11__["default"]()
    });
    const features = new rxjs__WEBPACK_IMPORTED_MODULE_12__.ReplaySubject();
    const key = source.on("change", () => {
      if (source.getState() === "ready") {
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_13__.unByKey)(key);
        features.next(source.getFeatures());
      }
    });
    const styles = [];
    if (config.rules) {
      for (const r of config.rules) {
        if (r.style) {
          const s = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_4__.getStyleConfigState)(r.style);
          styles.push({
            state: s,
            rule: r.check
          });
        }
      }
    }
    if (true) {
      const s = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_4__.getStyleConfigState)(config.style);
      styles.push({
        state: s
      });
    }
    const style = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_4__.getStyleConfigState)(config.style);
    const idToIdx = /* @__PURE__ */ new Map();
    const vectorLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_14__["default"]({
      source,
      style: (feature) => {
        var _a, _b, _c;
        const idx = idToIdx.get(feature.getId());
        const dims = style.dims;
        if (idx && dims) {
          return new ol_style__WEBPACK_IMPORTED_MODULE_15__["default"]({
            fill: new ol_style__WEBPACK_IMPORTED_MODULE_16__["default"]({ color: (_a = dims.color) == null ? void 0 : _a.get(idx) }),
            stroke: new ol_style__WEBPACK_IMPORTED_MODULE_17__["default"]({ color: style.base.color, width: (_b = style.base.lineWidth) != null ? _b : 1 })
          });
        }
        const isPoint = ((_c = feature.getGeometry()) == null ? void 0 : _c.getType()) === "Point";
        for (const check of styles) {
          if (check.rule && !(0,_utils_checkFeatureMatchesStyleRule__WEBPACK_IMPORTED_MODULE_5__.checkFeatureMatchesStyleRule)(check.rule, feature)) {
            continue;
          }
          if (check.state.fields) {
            const values = { ...check.state.base };
            const { text } = check.state.fields;
            if (text) {
              values.text = "".concat(feature.get(text));
            }
            if (isPoint) {
              return check.state.maker(values);
            }
            return (0,_style_markers__WEBPACK_IMPORTED_MODULE_2__.polyStyle)(values);
          }
          if (isPoint) {
            if (!check.point) {
              check.point = check.state.maker(check.state.base);
            }
            return check.point;
          }
          if (!check.poly) {
            check.poly = (0,_style_markers__WEBPACK_IMPORTED_MODULE_2__.polyStyle)(check.state.base);
          }
          return check.poly;
        }
        return void 0;
      }
    });
    return {
      init: () => vectorLayer,
      update: (data) => {
        const frame = data.series[0];
        if (frame) {
          const field = (0,_features_dimensions__WEBPACK_IMPORTED_MODULE_0__.findField)(frame, config.idField);
          if (field) {
            idToIdx.clear();
            field.values.forEach((v, i) => idToIdx.set(v, i));
          }
          style.dims = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_7__.getStyleDimension)(frame, style, theme, config.dataStyle);
        }
        vectorLayer.changed();
      },
      registerOptionsUI: (builder) => {
        var _a;
        const layerInfo = features.pipe(
          (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.first)(),
          (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.map)((v) => (0,_utils_getFeatures__WEBPACK_IMPORTED_MODULE_6__.getLayerPropertyInfo)(v))
        );
        builder.addSelect({
          path: "config.src",
          name: "GeoJSON URL",
          settings: {
            options: (_a = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_7__.getPublicGeoJSONFiles)()) != null ? _a : [],
            allowCustomValue: true
          },
          defaultValue: defaultOptions.src
        }).addFieldNamePicker({
          path: "config.idField",
          name: "ID Field"
        }).addCustomEditor({
          id: "config.dataStyle",
          path: "config.dataStyle",
          name: "Data style",
          editor: _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_1__.StyleEditor,
          settings: {
            displayRotation: false
          },
          defaultValue: defaultOptions.dataStyle
        }).addCustomEditor({
          id: "config.style",
          path: "config.style",
          name: "Default style",
          description: "The style to apply when no rules above match",
          editor: _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_1__.StyleEditor,
          settings: {
            simpleFixedValues: true,
            layerInfo
          },
          defaultValue: defaultOptions.style
        });
      }
    };
  },
  defaultOptions
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/geojsonLayer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_STYLE_RULE: () => (/* binding */ DEFAULT_STYLE_RULE),
/* harmony export */   geojsonLayer: () => (/* binding */ geojsonLayer)
/* harmony export */ });
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/Observable.js");
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/format/GeoJSON.js");
/* harmony import */ var ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/layer/VectorImage.js");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/first.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _editor_GeomapStyleRulesEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/GeomapStyleRulesEditor.tsx");
/* harmony import */ var _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/StyleEditor.tsx");
/* harmony import */ var _style_markers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/style/markers.ts");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _style_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/style/utils.ts");
/* harmony import */ var _utils_checkFeatureMatchesStyleRule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/checkFeatureMatchesStyleRule.ts");
/* harmony import */ var _utils_getFeatures__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/getFeatures.ts");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/utils.ts");
















const defaultOptions = {
  src: "public/maps/countries.geojson",
  rules: [],
  style: _style_types__WEBPACK_IMPORTED_MODULE_3__.defaultStyleConfig
};
const DEFAULT_STYLE_RULE = {
  style: _style_types__WEBPACK_IMPORTED_MODULE_3__.defaultStyleConfig,
  check: {
    property: "",
    operation: _grafana_schema__WEBPACK_IMPORTED_MODULE_8__.ComparisonOperation.EQ,
    value: ""
  }
};
const geojsonLayer = {
  id: "geojson",
  name: "GeoJSON",
  description: "Load static data from a geojson file",
  isBaseMap: false,
  /**
   * Function that configures transformation and returns a transformer
   * @param options
   */
  create: async (map, options, eventBus, theme) => {
    const config = { ...defaultOptions, ...options.config };
    const source = new ol_source_Vector__WEBPACK_IMPORTED_MODULE_9__["default"]({
      url: config.src,
      format: new ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_10__["default"]()
    });
    const features = new rxjs__WEBPACK_IMPORTED_MODULE_11__.ReplaySubject();
    const key = source.on("change", () => {
      if (source.getState() === "ready") {
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_12__.unByKey)(key);
        features.next(source.getFeatures());
      }
    });
    const styles = [];
    if (config.rules) {
      for (const r of config.rules) {
        if (r.style) {
          const s = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_4__.getStyleConfigState)(r.style);
          styles.push({
            state: s,
            rule: r.check
          });
        }
      }
    }
    if (true) {
      const s = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_4__.getStyleConfigState)(config.style);
      styles.push({
        state: s
      });
    }
    const polyStyleStrings = Object.values(_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONPolyStyles);
    const pointStyleStrings = Object.values(_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONPointStyles);
    const lineStyleStrings = Object.values(_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONLineStyles);
    const vectorLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_13__["default"]({
      source,
      style: (feature) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const featureType = (_a = feature.getGeometry()) == null ? void 0 : _a.getType();
        const isPoint = featureType === "Point" || featureType === "MultiPoint";
        const isPolygon = featureType === "Polygon" || featureType === "MultiPolygon";
        const isLine = featureType === "LineString" || featureType === "MultiLineString";
        for (const check of styles) {
          if (check.rule && !(0,_utils_checkFeatureMatchesStyleRule__WEBPACK_IMPORTED_MODULE_5__.checkFeatureMatchesStyleRule)(check.rule, feature)) {
            continue;
          }
          if (check.state.fields) {
            const values = { ...check.state.base };
            const { text } = check.state.fields;
            if (text) {
              values.text = "".concat(feature.get(text));
            }
            if (isPoint) {
              return check.state.maker(values);
            }
            return (0,_style_markers__WEBPACK_IMPORTED_MODULE_2__.polyStyle)(values);
          }
          const featureProps = feature.getProperties();
          if (isPolygon && Object.keys(featureProps).some((property) => polyStyleStrings.includes(property))) {
            const values = {
              color: (_b = featureProps[_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONPolyStyles.color]) != null ? _b : check.state.base.color,
              opacity: (_c = featureProps[_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONPolyStyles.opacity]) != null ? _c : check.state.base.opacity,
              lineWidth: (_d = featureProps[_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONPolyStyles.lineWidth]) != null ? _d : check.state.base.lineWidth
            };
            return (0,_style_markers__WEBPACK_IMPORTED_MODULE_2__.polyStyle)(values);
          } else if (isLine && Object.keys(featureProps).some((property) => lineStyleStrings.includes(property))) {
            const values = {
              color: (_e = featureProps[_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONLineStyles.color]) != null ? _e : check.state.base.color,
              lineWidth: (_f = featureProps[_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONLineStyles.lineWidth]) != null ? _f : check.state.base.lineWidth
            };
            return check.state.maker(values);
          } else if (isPoint && Object.keys(featureProps).some((property) => pointStyleStrings.includes(property))) {
            const values = {
              color: (_g = featureProps[_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONPointStyles.color]) != null ? _g : check.state.base.color,
              size: (_h = featureProps[_style_types__WEBPACK_IMPORTED_MODULE_3__.GeoJSONPointStyles.size]) != null ? _h : check.state.base.size
            };
            return check.state.maker(values);
          }
          if (isPoint) {
            if (!check.point) {
              check.point = check.state.maker(check.state.base);
            }
            return check.point;
          }
          if (!check.poly) {
            check.poly = (0,_style_markers__WEBPACK_IMPORTED_MODULE_2__.polyStyle)(check.state.base);
          }
          return check.poly;
        }
        return void 0;
      }
    });
    return {
      init: () => vectorLayer,
      registerOptionsUI: (builder) => {
        var _a;
        const layerInfo = features.pipe(
          (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.first)(),
          (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.map)((v) => (0,_utils_getFeatures__WEBPACK_IMPORTED_MODULE_6__.getLayerPropertyInfo)(v))
        );
        builder.addSelect({
          path: "config.src",
          name: "GeoJSON URL",
          settings: {
            options: (_a = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_7__.getPublicGeoJSONFiles)()) != null ? _a : [],
            allowCustomValue: true
          },
          defaultValue: defaultOptions.src
        }).addCustomEditor({
          id: "config.style",
          path: "config.style",
          name: "Default style",
          description: "The style to apply when no rules above match",
          editor: _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_1__.StyleEditor,
          settings: {
            simpleFixedValues: true,
            layerInfo
          },
          defaultValue: defaultOptions.style
        }).addCustomEditor({
          id: "config.rules",
          path: "config.rules",
          name: "Style rules",
          description: "Apply styles based on feature properties",
          editor: _editor_GeomapStyleRulesEditor__WEBPACK_IMPORTED_MODULE_0__.GeomapStyleRulesEditor,
          settings: {
            features,
            layerInfo
          },
          defaultValue: []
        });
      }
    };
  },
  defaultOptions
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/heatMap.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   heatmapLayer: () => (/* binding */ heatmapLayer)
/* harmony export */ });
/* harmony import */ var ol_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/layer/Heatmap.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-data/src/field/fieldColor.ts");
/* harmony import */ var _features_dimensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/dimensions/index.ts");
/* harmony import */ var _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/geo/utils/frameVectorSource.ts");
/* harmony import */ var _features_geo_utils_location__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/geo/utils/location.ts");







const defaultOptions = {
  weight: {
    fixed: 1,
    min: 0,
    max: 1
  },
  blur: 15,
  radius: 5
};
const heatmapLayer = {
  id: "heatmap",
  name: "Heatmap",
  description: "Visualizes a heatmap of the data",
  isBaseMap: false,
  showLocation: true,
  /**
   * Function that configures transformation and returns a transformer
   * @param options
   */
  create: async (map, options, eventBus, theme) => {
    const config = { ...defaultOptions, ...options.config };
    const location = await (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_3__.getLocationMatchers)(options.location);
    const source = new _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_2__.FrameVectorSource(location);
    const WEIGHT_KEY = "_weight";
    const vectorLayer = new ol_layer__WEBPACK_IMPORTED_MODULE_4__["default"]({
      source,
      blur: config.blur,
      radius: config.radius,
      weight: (feature) => {
        return feature.get(WEIGHT_KEY);
      }
    });
    return {
      init: () => vectorLayer,
      update: (data) => {
        var _a;
        const frame = data.series[0];
        if (!frame) {
          return;
        }
        source.update(frame);
        const weightDim = (0,_features_dimensions__WEBPACK_IMPORTED_MODULE_0__.getScaledDimension)(frame, config.weight);
        source.forEachFeature((f) => {
          const idx = f.get("rowIndex");
          if (idx != null) {
            f.set(WEIGHT_KEY, weightDim.get(idx));
          }
        });
        let colors = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
        const field = (_a = weightDim.field) != null ? _a : frame.fields.find((field2) => field2.type === _grafana_data__WEBPACK_IMPORTED_MODULE_5__.FieldType.number);
        if (field) {
          const colorMode = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_6__.getFieldColorModeForField)(field);
          if (colorMode.isContinuous && colorMode.getColors) {
            colors = colorMode.getColors(theme);
          }
        }
        vectorLayer.setGradient(colors);
      },
      // Heatmap overlay options
      registerOptionsUI: (builder) => {
        builder.addCustomEditor({
          id: "config.weight",
          path: "config.weight",
          name: "Weight values",
          description: "Scale the distribution for each row",
          editor: _features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ScaleDimensionEditor,
          settings: {
            min: 0,
            // no contribution
            max: 1,
            hideRange: true
            // Don't show the scale factor
          },
          defaultValue: {
            // Configured values
            fixed: 1,
            min: 0,
            max: 1
          }
        }).addSliderInput({
          path: "config.radius",
          description: "Configures the size of clusters",
          name: "Radius",
          defaultValue: defaultOptions.radius,
          settings: {
            min: 1,
            max: 50,
            step: 1
          }
        }).addSliderInput({
          path: "config.blur",
          description: "Configures the amount of blur of clusters",
          name: "Blur",
          defaultValue: defaultOptions.blur,
          settings: {
            min: 1,
            max: 50,
            step: 1
          }
        });
      }
    };
  },
  // fill in the default values
  defaultOptions
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/index.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataLayers: () => (/* binding */ dataLayers)
/* harmony export */ });
/* harmony import */ var _dayNightLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/dayNightLayer.tsx");
/* harmony import */ var _geojsonDynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/geojsonDynamic.ts");
/* harmony import */ var _geojsonLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/geojsonLayer.ts");
/* harmony import */ var _heatMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/heatMap.tsx");
/* harmony import */ var _lastPointTracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/lastPointTracker.ts");
/* harmony import */ var _markersLayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/markersLayer.tsx");
/* harmony import */ var _networkLayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/networkLayer.tsx");
/* harmony import */ var _photosLayer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/photosLayer.tsx");
/* harmony import */ var _routeLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/routeLayer.tsx");










const dataLayers = [
  _markersLayer__WEBPACK_IMPORTED_MODULE_5__.markersLayer,
  _heatMap__WEBPACK_IMPORTED_MODULE_3__.heatmapLayer,
  _lastPointTracker__WEBPACK_IMPORTED_MODULE_4__.lastPointTracker,
  _geojsonLayer__WEBPACK_IMPORTED_MODULE_2__.geojsonLayer,
  _geojsonDynamic__WEBPACK_IMPORTED_MODULE_1__.dynamicGeoJSONLayer,
  _dayNightLayer__WEBPACK_IMPORTED_MODULE_0__.dayNightLayer,
  _routeLayer__WEBPACK_IMPORTED_MODULE_8__.routeLayer,
  _photosLayer__WEBPACK_IMPORTED_MODULE_7__.photosLayer,
  _networkLayer__WEBPACK_IMPORTED_MODULE_6__.networkLayer
];


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/lastPointTracker.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lastPointTracker: () => (/* binding */ lastPointTracker)
/* harmony export */ });
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var ol_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/layer/Vector.js");
/* harmony import */ var ol_source__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/style/Icon.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/types/plugin.ts");
/* harmony import */ var _features_geo_utils_location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/geo/utils/location.ts");







const defaultOptions = {
  icon: "https://openlayers.org/en/latest/examples/data/icon.png"
};
const lastPointTracker = {
  id: "last-point-tracker",
  name: "Icon at last point",
  description: "Show an icon at the last point",
  isBaseMap: false,
  showLocation: true,
  state: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.PluginState.alpha,
  /**
   * Function that configures transformation and returns a transformer
   * @param options
   */
  create: async (map, options, eventBus, theme) => {
    const point = new ol_Feature__WEBPACK_IMPORTED_MODULE_2__["default"]({});
    const config = { ...defaultOptions, ...options.config };
    point.setStyle(
      new ol_style__WEBPACK_IMPORTED_MODULE_3__["default"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({
          src: config.icon
        })
      })
    );
    const vectorSource = new ol_source__WEBPACK_IMPORTED_MODULE_5__["default"]({
      features: [point]
    });
    const vectorLayer = new ol_layer__WEBPACK_IMPORTED_MODULE_6__["default"]({
      source: vectorSource
    });
    const matchers = await (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_0__.getLocationMatchers)(options.location);
    return {
      init: () => vectorLayer,
      update: (data) => {
        const frame = data.series[0];
        if (frame && frame.length) {
          const out = (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_0__.getGeometryField)(frame, matchers);
          if (!out.field) {
            return;
          }
          point.setGeometry(out.field.values[frame.length - 1]);
        }
      }
    };
  },
  // fill in the default values
  defaultOptions
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/markersLayer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MARKERS_LAYER_ID: () => (/* binding */ MARKERS_LAYER_ID),
/* harmony export */   defaultMarkersConfig: () => (/* binding */ defaultMarkersConfig),
/* harmony export */   markersLayer: () => (/* binding */ markersLayer)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/ol/layer/VectorImage.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/geo/utils/frameVectorSource.ts");
/* harmony import */ var _features_geo_utils_location__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/geo/utils/location.ts");
/* harmony import */ var _components_MarkersLegend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/components/MarkersLegend.tsx");
/* harmony import */ var _components_ObservablePropsWrapper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/components/ObservablePropsWrapper.tsx");
/* harmony import */ var _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/StyleEditor.tsx");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _style_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/geomap/style/utils.ts");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/utils.ts");














const defaultOptions = {
  style: _style_types__WEBPACK_IMPORTED_MODULE_7__.defaultStyleConfig,
  showLegend: true
};
const MARKERS_LAYER_ID = "markers";
const defaultMarkersConfig = {
  type: MARKERS_LAYER_ID,
  name: "",
  // will get replaced
  config: defaultOptions,
  location: {
    mode: _grafana_data__WEBPACK_IMPORTED_MODULE_10__.FrameGeometrySourceMode.Auto
  },
  tooltip: true
};
const markersLayer = {
  id: MARKERS_LAYER_ID,
  name: "Markers",
  description: "Use markers to render each data point",
  isBaseMap: false,
  showLocation: true,
  hideOpacity: true,
  /**
   * Function that configures transformation and returns a transformer
   * @param map
   * @param options
   * @param theme
   */
  create: async (map, options, eventBus, theme) => {
    const config = {
      ...defaultOptions,
      ...options == null ? void 0 : options.config
    };
    const style = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_8__.getStyleConfigState)(config.style);
    const location = await (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_3__.getLocationMatchers)(options.location);
    const source = new _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_2__.FrameVectorSource(location);
    const vectorLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_11__["default"]({
      source,
      declutter: false
      // TODO consider making this an option or explore grouping strategies
    });
    const legendProps = new rxjs__WEBPACK_IMPORTED_MODULE_12__.ReplaySubject(1);
    let legend = null;
    if (config.showLegend) {
      legend = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_components_ObservablePropsWrapper__WEBPACK_IMPORTED_MODULE_5__.ObservablePropsWrapper, { watch: legendProps, initialSubProps: {}, child: _components_MarkersLegend__WEBPACK_IMPORTED_MODULE_4__.MarkersLegend });
    }
    if (!style.fields) {
      vectorLayer.setStyle(style.maker(style.base));
    } else {
      vectorLayer.setStyle((feature) => {
        const idx = feature.get("rowIndex");
        const dims = style.dims;
        if (!dims || !(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(idx)) {
          return style.maker(style.base);
        }
        const values = { ...style.base };
        if (dims.color) {
          values.color = dims.color.get(idx);
        }
        if (dims.size) {
          values.size = dims.size.get(idx);
        }
        if (dims.text) {
          values.text = dims.text.get(idx);
        }
        if (dims.rotation) {
          values.rotation = dims.rotation.get(idx);
        }
        return style.maker(values);
      });
    }
    return {
      init: () => vectorLayer,
      legend,
      update: (data) => {
        var _a, _b;
        if (!((_a = data.series) == null ? void 0 : _a.length)) {
          source.clear();
          return;
        }
        for (const frame of data.series) {
          style.dims = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_9__.getStyleDimension)(frame, style, theme);
          if (legend) {
            legendProps.next({
              styleConfig: style,
              size: (_b = style.dims) == null ? void 0 : _b.size,
              layerName: options.name,
              layer: vectorLayer
            });
          }
          source.update(frame);
          break;
        }
      },
      // Marker overlay options
      registerOptionsUI: (builder) => {
        builder.addCustomEditor({
          id: "config.style",
          path: "config.style",
          name: "Styles",
          editor: _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_6__.StyleEditor,
          settings: {
            displayRotation: true
          },
          defaultValue: defaultOptions.style
        }).addBooleanSwitch({
          path: "config.showLegend",
          name: "Show legend",
          description: "Show map legend",
          defaultValue: defaultOptions.showLegend
        });
      }
    };
  },
  // fill in the default values
  defaultOptions
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/networkLayer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NETWORK_LAYER_ID: () => (/* binding */ NETWORK_LAYER_ID),
/* harmony export */   defaultMarkersConfig: () => (/* binding */ defaultMarkersConfig),
/* harmony export */   networkLayer: () => (/* binding */ networkLayer)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/ol/layer/VectorImage.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/ol/style/Text.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var ol_ext_style_FlowLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol-ext/style/FlowLine.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/tinycolor2/esm/tinycolor.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./packages/grafana-data/src/types/plugin.ts");
/* harmony import */ var _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/geo/utils/frameVectorSource.ts");
/* harmony import */ var _features_geo_utils_location__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/geo/utils/location.ts");
/* harmony import */ var _plugins_panel_nodeGraph_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/nodeGraph/utils.ts");
/* harmony import */ var _components_MarkersLegend__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/components/MarkersLegend.tsx");
/* harmony import */ var _components_ObservablePropsWrapper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/geomap/components/ObservablePropsWrapper.tsx");
/* harmony import */ var _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/StyleEditor.tsx");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _style_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/panel/geomap/style/utils.ts");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/utils.ts");





















const defaultOptions = {
  style: _style_types__WEBPACK_IMPORTED_MODULE_10__.defaultStyleConfig,
  showLegend: false,
  edgeStyle: _style_types__WEBPACK_IMPORTED_MODULE_10__.defaultStyleConfig,
  arrow: 0
};
const NETWORK_LAYER_ID = "network";
const defaultMarkersConfig = {
  type: NETWORK_LAYER_ID,
  name: "",
  // will get replaced
  config: defaultOptions,
  location: {
    mode: _grafana_data__WEBPACK_IMPORTED_MODULE_13__.FrameGeometrySourceMode.Auto
  }
};
const networkLayer = {
  id: NETWORK_LAYER_ID,
  name: "Network",
  description: "Render a node graph as a map layer",
  isBaseMap: false,
  showLocation: true,
  hideOpacity: true,
  state: _grafana_data__WEBPACK_IMPORTED_MODULE_14__.PluginState.beta,
  /**
   * Function that configures transformation and returns a transformer
   * @param map
   * @param options
   * @param eventBus
   * @param theme
   */
  create: async (map, options, eventBus, theme) => {
    const config = {
      ...defaultOptions,
      ...options == null ? void 0 : options.config
    };
    const style = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_11__.getStyleConfigState)(config.style);
    const edgeStyle = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_11__.getStyleConfigState)(config.edgeStyle);
    const location = await (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_5__.getLocationMatchers)(options.location);
    const source = new _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_4__.FrameVectorSource(location);
    const vectorLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_15__["default"]({
      source
    });
    const hasArrows = config.arrow === 1 || config.arrow === -1 || config.arrow === 2;
    const legendProps = new rxjs__WEBPACK_IMPORTED_MODULE_16__.ReplaySubject(1);
    let legend = null;
    if (config.showLegend) {
      legend = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_components_ObservablePropsWrapper__WEBPACK_IMPORTED_MODULE_8__.ObservablePropsWrapper, { watch: legendProps, initialSubProps: {}, child: _components_MarkersLegend__WEBPACK_IMPORTED_MODULE_7__.MarkersLegend });
    }
    vectorLayer.setStyle((feature) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      const geom = feature.getGeometry();
      const idx = feature.get("rowIndex");
      const dims = style.dims;
      if (!style.fields && !edgeStyle.fields && !hasArrows && (geom == null ? void 0 : geom.getType()) !== "LineString") {
        return style.maker(style.base);
      }
      if ((geom == null ? void 0 : geom.getType()) === "LineString" && geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_17__["default"]) {
        const edgeDims = edgeStyle.dims;
        const edgeTextConfig = edgeStyle.config.textConfig;
        const edgeId = Number(feature.getId());
        const coordinates = geom.getCoordinates();
        const opacity = (_a = edgeStyle.config.opacity) != null ? _a : 1;
        if (coordinates && edgeDims) {
          const segmentStartCoords = coordinates[0];
          const segmentEndCoords = coordinates[1];
          const color1 = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__["default"])(
            theme.visualization.getColorByName((_b = edgeDims.color && edgeDims.color.get(edgeId)) != null ? _b : edgeStyle.base.color)
          ).setAlpha(opacity).toString();
          const color2 = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__["default"])(
            theme.visualization.getColorByName((_c = edgeDims.color && edgeDims.color.get(edgeId)) != null ? _c : edgeStyle.base.color)
          ).setAlpha(opacity).toString();
          const arrowSize1 = (_d = edgeDims.size && edgeDims.size.get(edgeId)) != null ? _d : edgeStyle.base.size;
          const arrowSize2 = (_e = edgeDims.size && edgeDims.size.get(edgeId)) != null ? _e : edgeStyle.base.size;
          const styles = [];
          const flowStyle = new ol_ext_style_FlowLine__WEBPACK_IMPORTED_MODULE_1__["default"]({
            visible: true,
            lineCap: config.arrow === 0 ? "round" : "square",
            color: color1,
            color2,
            width: (_f = edgeDims.size && edgeDims.size.get(edgeId)) != null ? _f : edgeStyle.base.size,
            width2: (_g = edgeDims.size && edgeDims.size.get(edgeId)) != null ? _g : edgeStyle.base.size
          });
          if (config.arrow) {
            flowStyle.setArrow(config.arrow);
            if (config.arrow > 0) {
              flowStyle.setArrowColor(color2);
              flowStyle.setArrowSize((arrowSize2 != null ? arrowSize2 : 0) * 2);
            } else {
              flowStyle.setArrowColor(color1);
              flowStyle.setArrowSize((arrowSize1 != null ? arrowSize1 : 0) * 2);
            }
          }
          const LS = new ol_geom__WEBPACK_IMPORTED_MODULE_18__["default"]([segmentStartCoords, segmentEndCoords]);
          flowStyle.setGeometry(LS);
          const fontFamily = theme.typography.fontFamily;
          if (edgeDims.text || ((_h = edgeStyle.config.text) == null ? void 0 : _h.mode) === _grafana_data__WEBPACK_IMPORTED_MODULE_13__.TextDimensionMode.Fixed) {
            const labelStyle = new ol_style__WEBPACK_IMPORTED_MODULE_19__["default"]({
              zIndex: 10,
              text: new ol_style__WEBPACK_IMPORTED_MODULE_20__["default"]({
                text: (_k = (_i = edgeDims.text) == null ? void 0 : _i.get(edgeId)) != null ? _k : (_j = edgeStyle.config.text) == null ? void 0 : _j.fixed,
                font: "normal ".concat(edgeTextConfig == null ? void 0 : edgeTextConfig.fontSize, "px ").concat(fontFamily),
                fill: new ol_style__WEBPACK_IMPORTED_MODULE_21__["default"]({ color: color1 != null ? color1 : _style_types__WEBPACK_IMPORTED_MODULE_10__.defaultStyleConfig.color.fixed }),
                stroke: new ol_style__WEBPACK_IMPORTED_MODULE_22__["default"]({
                  color: (0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__["default"])(theme.visualization.getColorByName("text")).setAlpha(opacity).toString(),
                  width: Math.max((edgeTextConfig == null ? void 0 : edgeTextConfig.fontSize) / 10, 1)
                }),
                ...edgeTextConfig
              })
            });
            labelStyle.setGeometry(LS);
            styles.push(labelStyle);
          }
          styles.push(flowStyle);
          return styles;
        }
      }
      if (!dims || !(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(idx)) {
        return style.maker(style.base);
      }
      const values = { ...style.base };
      if (dims.color) {
        values.color = dims.color.get(idx);
      }
      if (dims.size) {
        values.size = dims.size.get(idx);
      }
      if (dims.text) {
        values.text = dims.text.get(idx);
      }
      if (dims.rotation) {
        values.rotation = dims.rotation.get(idx);
      }
      return style.maker(values);
    });
    return {
      init: () => vectorLayer,
      legend,
      update: (data) => {
        var _a, _b;
        if (!((_a = data.series) == null ? void 0 : _a.length)) {
          source.clear();
          return;
        }
        if (legend) {
          legendProps.next({
            styleConfig: style,
            size: (_b = style.dims) == null ? void 0 : _b.size,
            layerName: options.name,
            layer: vectorLayer
          });
        }
        const graphFrames = (0,_plugins_panel_nodeGraph_utils__WEBPACK_IMPORTED_MODULE_6__.getGraphFrame)(data.series);
        for (const frame of data.series) {
          if (frame === graphFrames.edges[0]) {
            edgeStyle.dims = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.getStyleDimension)(frame, edgeStyle, theme);
          } else {
            style.dims = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.getStyleDimension)(frame, style, theme);
          }
          updateEdge(source, graphFrames);
        }
      },
      // Marker overlay options
      registerOptionsUI: (builder, context) => {
        const networkFrames = (0,_plugins_panel_nodeGraph_utils__WEBPACK_IMPORTED_MODULE_6__.getGraphFrame)(context.data);
        const frameNodes = networkFrames.nodes[0];
        const frameEdges = networkFrames.edges[0];
        builder.addCustomEditor({
          id: "config.style",
          category: ["Node Styles"],
          path: "config.style",
          name: "Node Styles",
          editor: _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_9__.StyleEditor,
          settings: {
            displayRotation: true,
            frameMatcher: (frame) => frame === frameNodes
          },
          defaultValue: defaultOptions.style
        }).addCustomEditor({
          id: "config.edgeStyle",
          category: ["Edge Styles"],
          path: "config.edgeStyle",
          name: "Edge Styles",
          editor: _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_9__.StyleEditor,
          settings: {
            hideSymbol: true,
            frameMatcher: (frame) => frame === frameEdges
          },
          defaultValue: defaultOptions.style
        }).addRadio({
          path: "config.arrow",
          name: "Arrow",
          settings: {
            options: [
              { label: "None", value: 0 },
              { label: "Forward", value: 1 },
              { label: "Reverse", value: -1 },
              { label: "Both", value: 2 }
            ]
          },
          defaultValue: defaultOptions.arrow
        }).addBooleanSwitch({
          path: "config.showLegend",
          name: "Show legend",
          description: "Show map legend",
          defaultValue: defaultOptions.showLegend
        });
      }
    };
  },
  // fill in the default values
  defaultOptions
};
function updateEdge(source, graphFrames) {
  source.clear(true);
  const frameNodes = graphFrames.nodes[0];
  const frameEdges = graphFrames.edges[0];
  if (!frameNodes || !frameEdges) {
    return;
  }
  const info = (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_5__.getGeometryField)(frameNodes, source.location);
  if (!info.field) {
    source.changed();
    return;
  }
  const field = info.field;
  const nodeIdIndex = frameNodes.fields.findIndex((f) => f.name === "id");
  const nodeIdValues = frameNodes.fields[nodeIdIndex].values;
  const sourceIndex = frameEdges.fields.findIndex((f) => f.name === "source");
  const targetIndex = frameEdges.fields.findIndex((f) => f.name === "target");
  const sources = frameEdges.fields[sourceIndex].values;
  const targets = frameEdges.fields[targetIndex].values;
  for (let i = 0; i < sources.length; i++) {
    const sourceId = sources[i];
    const targetId = targets[i];
    const sourceNodeIndex = nodeIdValues.findIndex((value) => value === sourceId);
    const targetNodeIndex = nodeIdValues.findIndex((value) => value === targetId);
    if (!field.values[sourceNodeIndex] || !field.values[targetNodeIndex]) {
      continue;
    }
    const geometryEdge = new ol_geom__WEBPACK_IMPORTED_MODULE_18__["default"]([
      field.values[sourceNodeIndex].getCoordinates(),
      field.values[targetNodeIndex].getCoordinates()
    ]);
    const edgeFeature = new ol__WEBPACK_IMPORTED_MODULE_23__["default"]({
      geometry: geometryEdge
    });
    edgeFeature.setId(i);
    source["addFeatureInternal"](edgeFeature);
  }
  for (let i = 0; i < frameNodes.length; i++) {
    source["addFeatureInternal"](
      new ol__WEBPACK_IMPORTED_MODULE_23__["default"]({
        frameNodes,
        rowIndex: i,
        geometry: info.field.values[i]
      })
    );
  }
  source.changed();
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/photosLayer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PHOTOS_LAYER_ID: () => (/* binding */ PHOTOS_LAYER_ID),
/* harmony export */   defaultPhotosConfig: () => (/* binding */ defaultPhotosConfig),
/* harmony export */   photosLayer: () => (/* binding */ photosLayer)
/* harmony export */ });
/* harmony import */ var ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/layer/VectorImage.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var ol_ext_style_Photo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol-ext/style/Photo.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/types/plugin.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _features_dimensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/index.ts");
/* harmony import */ var _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/geo/utils/frameVectorSource.ts");
/* harmony import */ var _features_geo_utils_location__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/geo/utils/location.ts");









const defaultOptions = {
  kind: "square",
  border: 2,
  shadow: true,
  crop: true,
  radius: 20,
  color: "rgb(200, 200, 200)"
};
const PHOTOS_LAYER_ID = "photos";
const defaultPhotosConfig = {
  type: PHOTOS_LAYER_ID,
  name: "",
  // will get replaced
  config: defaultOptions,
  location: {
    mode: _grafana_schema__WEBPACK_IMPORTED_MODULE_4__.FrameGeometrySourceMode.Auto
  },
  tooltip: true
};
const unknownImage = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiBjbGFzcz0iY3NzLWV5eDRkbyI+PHBhdGggZD0iTTExLjI5LDE1LjI5YTEuNTgsMS41OCwwLDAsMC0uMTIuMTUuNzYuNzYsMCwwLDAtLjA5LjE4LjY0LjY0LDAsMCwwLS4wNi4xOCwxLjM2LDEuMzYsMCwwLDAsMCwuMi44NC44NCwwLDAsMCwuMDguMzguOS45LDAsMCwwLC41NC41NC45NC45NCwwLDAsMCwuNzYsMCwuOS45LDAsMCwwLC41NC0uNTRBMSwxLDAsMCwwLDEzLDE2YTEsMSwwLDAsMC0uMjktLjcxQTEsMSwwLDAsMCwxMS4yOSwxNS4yOVpNMTIsMkExMCwxMCwwLDEsMCwyMiwxMiwxMCwxMCwwLDAsMCwxMiwyWm0wLDE4YTgsOCwwLDEsMSw4LThBOCw4LDAsMCwxLDEyLDIwWk0xMiw3QTMsMywwLDAsMCw5LjQsOC41YTEsMSwwLDEsMCwxLjczLDFBMSwxLDAsMCwxLDEyLDlhMSwxLDAsMCwxLDAsMiwxLDEsMCwwLDAtMSwxdjFhMSwxLDAsMCwwLDIsMHYtLjE4QTMsMywwLDAsMCwxMiw3WiI+PC9wYXRoPjwvc3ZnPgo=";
const blankPixel = "data:image/svg+xml;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==";
let photoLoad = [];
const photosLayer = {
  id: PHOTOS_LAYER_ID,
  name: "Photos",
  description: "Render photos at each data point",
  isBaseMap: false,
  showLocation: true,
  hideOpacity: true,
  state: _grafana_data__WEBPACK_IMPORTED_MODULE_5__.PluginState.beta,
  /**
   * Function that configures transformation and returns a transformer
   * @param map
   * @param options
   * @param theme
   */
  create: async (map, options, eventBus, theme) => {
    const config = {
      ...defaultOptions,
      ...options == null ? void 0 : options.config
    };
    const location = await (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_3__.getLocationMatchers)(options.location);
    const source = new _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_2__.FrameVectorSource(location);
    const vectorLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_6__["default"]({
      source
    });
    let images = [];
    vectorLayer.setStyle((feature) => {
      var _a, _b;
      let src = unknownImage;
      let idx = Infinity;
      if (images.length > 0) {
        idx = feature.get("rowIndex");
        src = (_a = images[idx]) != null ? _a : unknownImage;
      }
      const photoStyle = new ol_style__WEBPACK_IMPORTED_MODULE_7__["default"]({
        image: new ol_ext_style_Photo__WEBPACK_IMPORTED_MODULE_0__["default"]({
          src,
          radius: config.radius,
          crop: config.crop,
          kind: config.kind,
          shadow: false,
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
            width: 0,
            color: "rgba(0,0,0,0)"
          }),
          onload: () => {
            vectorLayer.changed();
            if (photoLoad && !photoLoad.includes(idx)) {
              photoLoad.push(idx);
            }
          }
        })
      });
      const blankStyle = new ol_style__WEBPACK_IMPORTED_MODULE_7__["default"]({
        image: new ol_ext_style_Photo__WEBPACK_IMPORTED_MODULE_0__["default"]({
          src: blankPixel,
          radius: config.radius,
          crop: false,
          kind: config.kind,
          shadow: config.shadow,
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
            width: (_b = config.border) != null ? _b : 0,
            color: theme.visualization.getColorByName(config.color)
          }),
          onload: () => {
            vectorLayer.changed();
          }
        })
      });
      const errorStyle = new ol_style__WEBPACK_IMPORTED_MODULE_7__["default"]({
        image: new ol_ext_style_Photo__WEBPACK_IMPORTED_MODULE_0__["default"]({
          src: unknownImage,
          radius: config.radius,
          crop: false,
          kind: config.kind,
          shadow: false,
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
            width: 0,
            color: "rgba(0,0,0,0)"
          }),
          onload: () => {
            vectorLayer.changed();
          }
        })
      });
      if (photoLoad && photoLoad.includes(idx)) {
        return [blankStyle, photoStyle];
      }
      return [blankStyle, errorStyle, photoStyle];
    });
    return {
      init: () => vectorLayer,
      update: (data) => {
        var _a;
        if (!((_a = data.series) == null ? void 0 : _a.length)) {
          source.clear();
          return;
        }
        for (const frame of data.series) {
          source.update(frame);
          if (config.src) {
            const srcField = (0,_features_dimensions__WEBPACK_IMPORTED_MODULE_1__.findField)(frame, config.src);
            if (srcField) {
              images = srcField == null ? void 0 : srcField.values;
            }
          } else {
            for (let i = 0; i < frame.fields.length; i++) {
              const field = frame.fields[i];
              if (field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_9__.FieldType.string) {
                images = field.values;
                break;
              }
            }
          }
          break;
        }
      },
      // Marker overlay options
      registerOptionsUI: (builder) => {
        builder.addFieldNamePicker({
          path: "config.src",
          name: "Image Source field",
          settings: {
            filter: (f) => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_9__.FieldType.string,
            noFieldsMessage: "No string fields found"
          }
        }).addRadio({
          path: "config.kind",
          name: "Kind",
          settings: {
            options: [
              { label: "Square", value: "square" },
              { label: "Circle", value: "circle" },
              { label: "Anchored", value: "anchored" },
              { label: "Folio", value: "folio" }
            ]
          },
          defaultValue: defaultOptions.kind
        }).addBooleanSwitch({
          path: "config.crop",
          name: "Crop",
          settings: {},
          defaultValue: defaultOptions.crop
        }).addBooleanSwitch({
          path: "config.shadow",
          name: "Shadow",
          settings: {},
          defaultValue: defaultOptions.shadow
        }).addSliderInput({
          path: "config.border",
          name: "Border",
          settings: {
            min: 0,
            max: 10
          },
          defaultValue: defaultOptions.border
        }).addColorPicker({
          path: "config.color",
          name: "Border color",
          defaultValue: defaultOptions.color,
          settings: [{ enableNamedColors: false }]
        }).addSliderInput({
          path: "config.radius",
          name: "Radius",
          settings: {
            min: 1,
            max: 100
          },
          defaultValue: defaultOptions.radius
        });
      }
    };
  },
  // fill in the default values
  defaultOptions
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/data/routeLayer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ROUTE_LAYER_ID: () => (/* binding */ ROUTE_LAYER_ID),
/* harmony export */   defaultRouteConfig: () => (/* binding */ defaultRouteConfig),
/* harmony export */   routeLayer: () => (/* binding */ routeLayer)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var ol_layer__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./node_modules/ol/layer/Group.js");
/* harmony import */ var ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/layer/VectorImage.js");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/ol/style/Circle.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var ol_ext_style_FlowLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol-ext/style/FlowLine.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js");
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/tinycolor2/esm/tinycolor.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./packages/grafana-data/src/types/plugin.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./packages/grafana-data/src/events/common.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_data_src_themes_colorManipulator__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./packages/grafana-data/src/themes/colorManipulator.ts");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/geo/utils/frameVectorSource.ts");
/* harmony import */ var _features_geo_utils_location__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/geo/utils/location.ts");
/* harmony import */ var _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/StyleEditor.tsx");
/* harmony import */ var _style_markers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/style/markers.ts");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _style_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/geomap/style/utils.ts");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/utils.ts");





















const defaultOptions = {
  style: {
    ..._style_types__WEBPACK_IMPORTED_MODULE_7__.defaultStyleConfig,
    opacity: 1,
    lineWidth: 2
  },
  arrow: 0
};
const ROUTE_LAYER_ID = "route";
const defaultRouteConfig = {
  type: ROUTE_LAYER_ID,
  name: "",
  // will get replaced
  config: defaultOptions,
  location: {
    mode: _grafana_schema__WEBPACK_IMPORTED_MODULE_10__.FrameGeometrySourceMode.Auto
  },
  tooltip: false
};
var mapIndex = /* @__PURE__ */ ((mapIndex2) => {
  mapIndex2[mapIndex2["x1"] = 0] = "x1";
  mapIndex2[mapIndex2["y1"] = 1] = "y1";
  mapIndex2[mapIndex2["x2"] = 2] = "x2";
  mapIndex2[mapIndex2["y2"] = 3] = "y2";
  return mapIndex2;
})(mapIndex || {});
const crosshairColor = "#607D8B";
const routeLayer = {
  id: ROUTE_LAYER_ID,
  name: "Route",
  description: "Render data points as a route",
  isBaseMap: false,
  showLocation: true,
  state: _grafana_data__WEBPACK_IMPORTED_MODULE_11__.PluginState.beta,
  /**
   * Function that configures transformation and returns a transformer
   * @param options
   */
  create: async (map, options, eventBus, theme) => {
    const config = {
      ...defaultOptions,
      ...options == null ? void 0 : options.config
    };
    const style = await (0,_style_utils__WEBPACK_IMPORTED_MODULE_8__.getStyleConfigState)(config.style);
    const location = await (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_4__.getLocationMatchers)(options.location);
    const source = new _features_geo_utils_frameVectorSource__WEBPACK_IMPORTED_MODULE_3__.FrameVectorSource(location);
    const vectorLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_12__["default"]({ source });
    const hasArrows = config.arrow === 1 || config.arrow === -1;
    if (!style.fields && !hasArrows) {
      const styleBase = (0,_style_markers__WEBPACK_IMPORTED_MODULE_6__.routeStyle)(style.base);
      if (style.config.size && style.config.size.fixed) {
        styleBase.getStroke().setWidth(style.config.size.fixed);
      }
      vectorLayer.setStyle(styleBase);
    } else {
      vectorLayer.setStyle((feature) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const idx = feature.get("rowIndex");
        const dims = style.dims;
        if (!dims || !(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isNumber)(idx)) {
          return (0,_style_markers__WEBPACK_IMPORTED_MODULE_6__.routeStyle)(style.base);
        }
        const styles = [];
        const geom = feature.getGeometry();
        const opacity = (_a = style.config.opacity) != null ? _a : 1;
        if (geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_13__["default"]) {
          const coordinates = geom.getCoordinates();
          if (coordinates) {
            let startIndex = 0;
            const pixelTolerance = 2;
            for (let i = 0; i < coordinates.length - 1; i++) {
              const segmentStartCoords = coordinates[startIndex];
              const segmentEndCoords = coordinates[i + 1];
              const color1 = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_2__["default"])(
                theme.visualization.getColorByName((_b = dims.color && dims.color.get(startIndex)) != null ? _b : style.base.color)
              ).setAlpha(opacity).toString();
              const color2 = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_2__["default"])(
                theme.visualization.getColorByName((_c = dims.color && dims.color.get(i + 1)) != null ? _c : style.base.color)
              ).setAlpha(opacity).toString();
              const arrowSize1 = (_d = dims.size && dims.size.get(startIndex)) != null ? _d : style.base.size;
              const arrowSize2 = (_e = dims.size && dims.size.get(i + 1)) != null ? _e : style.base.size;
              const flowStyle = new ol_ext_style_FlowLine__WEBPACK_IMPORTED_MODULE_1__["default"]({
                visible: true,
                lineCap: config.arrow === 0 ? "round" : "square",
                color: color1,
                color2,
                width: (_f = dims.size && dims.size.get(startIndex)) != null ? _f : style.base.size,
                width2: (_g = dims.size && dims.size.get(i + 1)) != null ? _g : style.base.size
              });
              if (config.arrow) {
                flowStyle.setArrow(config.arrow);
                if (config.arrow > 0) {
                  flowStyle.setArrowColor(color2);
                  flowStyle.setArrowSize((arrowSize2 != null ? arrowSize2 : 0) * 1.5);
                } else {
                  flowStyle.setArrowColor(color1);
                  flowStyle.setArrowSize((arrowSize1 != null ? arrowSize1 : 0) * 1.5);
                }
              }
              if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_9__.isSegmentVisible)(map, pixelTolerance, segmentStartCoords, segmentEndCoords)) {
                const LS = new ol_geom__WEBPACK_IMPORTED_MODULE_14__["default"]([segmentStartCoords, segmentEndCoords]);
                flowStyle.setGeometry(LS);
                styles.push(flowStyle);
                startIndex = i + 1;
              }
            }
            if (styles.length === 0) {
              const P = new ol_geom__WEBPACK_IMPORTED_MODULE_15__["default"](coordinates[0]);
              const radius = ((_i = (_h = dims.size && dims.size.get(0)) != null ? _h : style.base.size) != null ? _i : 10) / 2;
              const color = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_2__["default"])(
                theme.visualization.getColorByName((_j = dims.color && dims.color.get(0)) != null ? _j : style.base.color)
              ).setAlpha(opacity).toString();
              const ZoomOutCircle = new ol_style__WEBPACK_IMPORTED_MODULE_16__["default"]({
                image: new ol_style__WEBPACK_IMPORTED_MODULE_17__["default"]({
                  radius,
                  fill: new ol_style__WEBPACK_IMPORTED_MODULE_18__["default"]({
                    color
                  })
                })
              });
              ZoomOutCircle.setGeometry(P);
              styles.push(ZoomOutCircle);
            }
          }
          return styles;
        }
        const values = { ...style.base };
        if (dims.color) {
          values.color = dims.color.get(idx);
        }
        return (0,_style_markers__WEBPACK_IMPORTED_MODULE_6__.routeStyle)(values);
      });
    }
    const crosshairFeature = new ol_Feature__WEBPACK_IMPORTED_MODULE_19__["default"]({});
    const hLineFeature = new ol_Feature__WEBPACK_IMPORTED_MODULE_19__["default"]({});
    const vLineFeature = new ol_Feature__WEBPACK_IMPORTED_MODULE_19__["default"]({});
    const lineFeatures = [hLineFeature, vLineFeature];
    const crosshairRadius = (style.base.lineWidth || 6) + 3;
    const crosshairStyle = new ol_style__WEBPACK_IMPORTED_MODULE_16__["default"]({
      image: new ol_style__WEBPACK_IMPORTED_MODULE_17__["default"]({
        radius: crosshairRadius,
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_20__["default"]({
          color: (0,_grafana_data_src_themes_colorManipulator__WEBPACK_IMPORTED_MODULE_21__.alpha)(crosshairColor, 1),
          width: 1
        }),
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_18__["default"]({ color: (0,_grafana_data_src_themes_colorManipulator__WEBPACK_IMPORTED_MODULE_21__.alpha)(crosshairColor, 0.4) })
      })
    });
    const lineStyle = new ol_style__WEBPACK_IMPORTED_MODULE_16__["default"]({
      stroke: new ol_style__WEBPACK_IMPORTED_MODULE_20__["default"]({
        color: crosshairColor,
        width: 1,
        lineDash: [3, 3],
        lineCap: "square"
      })
    });
    const crosshairLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_12__["default"]({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_22__["default"]({
        features: [crosshairFeature]
      }),
      style: crosshairStyle
    });
    const linesLayer = new ol_layer_VectorImage__WEBPACK_IMPORTED_MODULE_12__["default"]({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_22__["default"]({
        features: lineFeatures
      }),
      style: lineStyle
    });
    const layer = new ol_layer__WEBPACK_IMPORTED_MODULE_23__["default"]({
      layers: [vectorLayer, crosshairLayer, linesLayer]
    });
    const subscriptions = new rxjs__WEBPACK_IMPORTED_MODULE_24__.Subscription();
    subscriptions.add(
      eventBus.getStream(_grafana_data__WEBPACK_IMPORTED_MODULE_25__.DataHoverEvent).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_26__.throttleTime)(8)).subscribe({
        next: (event) => {
          var _a, _b;
          const mapExtents = map.getView().calculateExtent(map.getSize());
          const feature = source.getFeatures()[0];
          const frame = feature == null ? void 0 : feature.get("frame");
          const time = (_b = (_a = event.payload) == null ? void 0 : _a.point) == null ? void 0 : _b.time;
          if (frame && time) {
            const timeField = frame.fields.find((f) => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_27__.FieldType.time);
            if (timeField) {
              const timestamps = timeField.values;
              const pointIdx = findNearestTimeIndex(timestamps, time);
              if (pointIdx !== null) {
                const out = (0,_features_geo_utils_location__WEBPACK_IMPORTED_MODULE_4__.getGeometryField)(frame, location);
                if (out.field) {
                  const crosshairPoint = out.field.values[pointIdx];
                  const crosshairPointCoords = crosshairPoint.getCoordinates();
                  crosshairFeature.setGeometry(crosshairPoint);
                  crosshairFeature.setStyle(crosshairStyle);
                  hLineFeature.setGeometry(
                    new ol_geom__WEBPACK_IMPORTED_MODULE_14__["default"]([
                      [mapExtents[0 /* x1 */], crosshairPointCoords[1 /* y1 */]],
                      [mapExtents[2 /* x2 */], crosshairPointCoords[1 /* y1 */]]
                    ])
                  );
                  vLineFeature.setGeometry(
                    new ol_geom__WEBPACK_IMPORTED_MODULE_14__["default"]([
                      [crosshairPointCoords[0 /* x1 */], mapExtents[1 /* y1 */]],
                      [crosshairPointCoords[0 /* x1 */], mapExtents[3 /* y2 */]]
                    ])
                  );
                  lineFeatures.forEach((feature2) => feature2.setStyle(lineStyle));
                }
              }
            }
          }
        }
      })
    );
    subscriptions.add(
      eventBus.subscribe(_grafana_data__WEBPACK_IMPORTED_MODULE_25__.DataHoverClearEvent, (event) => {
        crosshairFeature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_16__["default"]({}));
        lineFeatures.forEach((feature) => feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_16__["default"]({})));
      })
    );
    return {
      init: () => layer,
      dispose: () => subscriptions.unsubscribe(),
      update: (data) => {
        var _a;
        if (!((_a = data.series) == null ? void 0 : _a.length)) {
          return;
        }
        for (const frame of data.series) {
          if (style.fields || hasArrows) {
            style.dims = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_9__.getStyleDimension)(frame, style, theme);
          }
          source.updateLineString(frame);
          break;
        }
      },
      // Route layer options
      registerOptionsUI: (builder) => {
        builder.addCustomEditor({
          id: "config.style",
          path: "config.style",
          name: "Style",
          editor: _editor_StyleEditor__WEBPACK_IMPORTED_MODULE_5__.StyleEditor,
          settings: {
            simpleFixedValues: false
          },
          defaultValue: defaultOptions.style
        }).addRadio({
          path: "config.arrow",
          name: "Arrow",
          settings: {
            options: [
              { label: "None", value: 0 },
              { label: "Forward", value: 1 },
              { label: "Reverse", value: -1 }
            ]
          },
          defaultValue: defaultOptions.arrow
        });
      }
    };
  },
  // fill in the default values
  defaultOptions
};
function findNearestTimeIndex(timestamps, time) {
  if (timestamps.length === 0) {
    return null;
  } else if (timestamps.length === 1) {
    return 0;
  }
  const lastIdx = timestamps.length - 1;
  if (time < timestamps[0]) {
    return 0;
  } else if (time > timestamps[lastIdx]) {
    return lastIdx;
  }
  const probableIdx = Math.abs(Math.round(lastIdx * (time - timestamps[0]) / (timestamps[lastIdx] - timestamps[0])));
  if (time < timestamps[probableIdx]) {
    for (let i = probableIdx; i > 0; i--) {
      if (time > timestamps[i]) {
        return i < lastIdx ? i + 1 : lastIdx;
      }
    }
    return 0;
  } else {
    for (let i = probableIdx; i < lastIdx; i++) {
      if (time < timestamps[i]) {
        return i > 0 ? i - 1 : 0;
      }
    }
    return lastIdx;
  }
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/layers/registry.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_BASEMAP_CONFIG: () => (/* binding */ DEFAULT_BASEMAP_CONFIG),
/* harmony export */   defaultBaseLayer: () => (/* binding */ defaultBaseLayer),
/* harmony export */   geomapLayerRegistry: () => (/* binding */ geomapLayerRegistry),
/* harmony export */   getLayersOptions: () => (/* binding */ getLayersOptions)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-data/src/utils/Registry.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/types/plugin.ts");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var _basemaps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/basemaps/index.ts");
/* harmony import */ var _basemaps_carto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/basemaps/carto.ts");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/index.ts");






const DEFAULT_BASEMAP_CONFIG = {
  type: "default",
  name: "",
  // will get filled in with a non-empty name
  config: {}
};
const defaultBaseLayer = {
  id: DEFAULT_BASEMAP_CONFIG.type,
  name: "Default base layer",
  isBaseMap: true,
  create: (map, options, eventBus, theme) => {
    var _a, _b;
    const serverLayerType = (_b = (_a = _core_config__WEBPACK_IMPORTED_MODULE_0__.config) == null ? void 0 : _a.geomapDefaultBaseLayerConfig) == null ? void 0 : _b.type;
    if (serverLayerType) {
      const layer = geomapLayerRegistry.getIfExists(serverLayerType);
      if (!layer) {
        throw new Error("Invalid basemap configuration on server");
      }
      return layer.create(map, _core_config__WEBPACK_IMPORTED_MODULE_0__.config.geomapDefaultBaseLayerConfig, eventBus, theme);
    }
    return _basemaps_carto__WEBPACK_IMPORTED_MODULE_2__.carto.create(map, options, eventBus, theme);
  }
};
const geomapLayerRegistry = new _grafana_data__WEBPACK_IMPORTED_MODULE_4__.Registry(() => [
  defaultBaseLayer,
  ..._basemaps__WEBPACK_IMPORTED_MODULE_1__.basemapLayers,
  // simple basemaps
  ..._data__WEBPACK_IMPORTED_MODULE_3__.dataLayers
  // Layers with update functions
]);
function getLayersSelection(items, current) {
  const registry = { options: [], current: [] };
  const alpha = [];
  for (const layer of items) {
    const option = { label: layer.name, value: layer.id, description: layer.description };
    switch (layer.state) {
      case _grafana_data__WEBPACK_IMPORTED_MODULE_5__.PluginState.alpha:
        if (!_core_config__WEBPACK_IMPORTED_MODULE_0__.hasAlphaPanels) {
          break;
        }
        option.label = "".concat(layer.name, " (Alpha)");
        option.icon = "bolt";
        alpha.push(option);
        break;
      case _grafana_data__WEBPACK_IMPORTED_MODULE_5__.PluginState.beta:
        option.label = "".concat(layer.name, " (Beta)");
      default:
        registry.options.push(option);
    }
    if (layer.id === current) {
      registry.current.push(option);
    }
  }
  for (const layer of alpha) {
    registry.options.push(layer);
  }
  return registry;
}
function getLayersOptions(basemap, current) {
  if (basemap) {
    return getLayersSelection([defaultBaseLayer, ..._basemaps__WEBPACK_IMPORTED_MODULE_1__.basemapLayers], current);
  }
  return getLayersSelection([..._data__WEBPACK_IMPORTED_MODULE_3__.dataLayers, ..._basemaps__WEBPACK_IMPORTED_MODULE_1__.basemapLayers], current);
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/migrations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapMigrationHandler: () => (/* binding */ mapMigrationHandler),
/* harmony export */   mapPanelChangedHandler: () => (/* binding */ mapPanelChangedHandler),
/* harmony export */   worldmapToGeomapOptions: () => (/* binding */ worldmapToGeomapOptions)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-data/src/transformations/fieldReducer.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-data/src/transformations/transformers/ids.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-data/src/types/thresholds.ts");
/* harmony import */ var _layers_data_markersLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/markersLayer.tsx");
/* harmony import */ var _style_markers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/style/markers.ts");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/types.ts");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/view.ts");









const mapPanelChangedHandler = (panel, prevPluginId, prevOptions, prevFieldConfig) => {
  var _a;
  if (prevPluginId === "grafana-worldmap-panel" && prevOptions.angular) {
    const { fieldConfig, options, xform } = worldmapToGeomapOptions({
      ...prevOptions.angular,
      fieldConfig: prevFieldConfig
    });
    if ((_a = xform == null ? void 0 : xform.id) == null ? void 0 : _a.length) {
      panel.transformations = panel.transformations ? [...panel.transformations, xform] : [xform];
    }
    panel.fieldConfig = fieldConfig;
    return options;
  }
  return {};
};
function worldmapToGeomapOptions(angular) {
  var _a;
  const fieldConfig = {
    defaults: {},
    overrides: []
  };
  const markersLayer = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(_layers_data_markersLayer__WEBPACK_IMPORTED_MODULE_1__.defaultMarkersConfig);
  const options = {
    view: {
      id: _view__WEBPACK_IMPORTED_MODULE_5__.MapCenterID.Zero
    },
    controls: {
      showZoom: true,
      mouseWheelZoom: Boolean(angular.mouseWheelZoom)
    },
    basemap: {
      type: "default",
      // was carto
      name: "Basemap"
    },
    layers: [markersLayer],
    tooltip: { mode: _types__WEBPACK_IMPORTED_MODULE_4__.TooltipMode.Details }
  };
  let v = asNumber(angular.decimals);
  if (v) {
    fieldConfig.defaults.decimals = v;
  }
  const style = markersLayer.config.style;
  v = asNumber(angular.circleMaxSize);
  if (v) {
    style.size.max = v;
  }
  v = asNumber(angular.circleMinSize);
  if (v) {
    style.size.min = v;
  }
  let xform = void 0;
  const reducer = _grafana_data__WEBPACK_IMPORTED_MODULE_6__.fieldReducers.getIfExists(angular.valueName);
  if (reducer && ((_a = angular.locationData) == null ? void 0 : _a.length)) {
    xform = {
      id: _grafana_data__WEBPACK_IMPORTED_MODULE_7__.DataTransformerID.reduce,
      options: {
        reducers: [reducer.id]
      }
    };
    switch (angular.locationData) {
      case "countries":
      case "countries_3letter":
        markersLayer.location = {
          mode: _grafana_data__WEBPACK_IMPORTED_MODULE_8__.FrameGeometrySourceMode.Lookup,
          gazetteer: "public/gazetteer/countries.json",
          lookup: void 0
          // will default to first string field from reducer
        };
        break;
      case "states":
        markersLayer.location = {
          mode: _grafana_data__WEBPACK_IMPORTED_MODULE_8__.FrameGeometrySourceMode.Lookup,
          gazetteer: "public/gazetteer/usa-states.json",
          lookup: void 0
          // will default to first string field from reducer
        };
        break;
    }
  }
  if (angular.thresholds && angular.colors) {
    const levels = angular.thresholds.split(",").map((strVale) => {
      return Number(strVale.trim());
    });
    const thresholds = [];
    for (const color of angular.colors) {
      const idx = thresholds.length - 1;
      if (idx >= 0) {
        thresholds.push({ value: levels[idx], color });
      } else {
        thresholds.push({ value: -Infinity, color });
      }
    }
    fieldConfig.defaults.thresholds = {
      mode: _grafana_data__WEBPACK_IMPORTED_MODULE_9__.ThresholdsMode.Absolute,
      steps: thresholds
    };
  }
  v = asNumber(angular.initialZoom);
  if (v) {
    options.view.zoom = v;
  }
  const mapCenters = {
    "(0\xB0, 0\xB0)": _view__WEBPACK_IMPORTED_MODULE_5__.MapCenterID.Zero,
    "North America": "north-america",
    Europe: "europe",
    "West Asia": "west-asia",
    "SE Asia": "se-asia",
    "Last GeoHash": _view__WEBPACK_IMPORTED_MODULE_5__.MapCenterID.Coordinates
    // MapCenterID.LastPoint,
  };
  options.view.id = mapCenters[angular.mapCenter];
  options.view.lat = asNumber(angular.mapCenterLatitude);
  options.view.lon = asNumber(angular.mapCenterLongitude);
  return { fieldConfig, options, xform };
}
function asNumber(v) {
  const num = Number(v);
  return isNaN(num) ? void 0 : num;
}
const mapMigrationHandler = (panel) => {
  var _a, _b;
  const pluginVersion = (_a = panel == null ? void 0 : panel.pluginVersion) != null ? _a : "";
  if (pluginVersion.startsWith("8.1") || pluginVersion.startsWith("8.2")) {
    const layers = (_b = panel.options) == null ? void 0 : _b.layers;
    if ((layers == null ? void 0 : layers.length) === 1) {
      const layer = panel.options.layers[0];
      if ((layer == null ? void 0 : layer.type) === "markers" && layer.config) {
        const oldConfig = layer.config;
        const config = {
          style: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(_style_types__WEBPACK_IMPORTED_MODULE_3__.defaultStyleConfig),
          showLegend: Boolean(oldConfig.showLegend)
        };
        if (oldConfig.size) {
          config.style.size = oldConfig.size;
        }
        if (oldConfig.color) {
          config.style.color = oldConfig.color;
        }
        if (oldConfig.fillOpacity) {
          config.style.opacity = oldConfig.fillOpacity;
        }
        const symbol = (0,_style_markers__WEBPACK_IMPORTED_MODULE_2__.getMarkerAsPath)(oldConfig.shape);
        if (symbol) {
          config.style.symbol = {
            fixed: symbol,
            mode: _grafana_data__WEBPACK_IMPORTED_MODULE_8__.ResourceDimensionMode.Fixed
          };
        }
        return { ...panel.options, layers: [{ ...layer, config }] };
      }
    }
  }
  return panel.options;
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/module.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   plugin: () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-data/src/panel/PanelPlugin.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/grafana-runtime/src/config.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/grafana-ui/src/options/builder/hideSeries.tsx");
/* harmony import */ var _GeomapPanel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/GeomapPanel.tsx");
/* harmony import */ var _editor_LayersEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/LayersEditor.tsx");
/* harmony import */ var _editor_MapViewEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/MapViewEditor.tsx");
/* harmony import */ var _editor_layerEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/editor/layerEditor.tsx");
/* harmony import */ var _migrations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/geomap/migrations.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/geomap/types.ts");











const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_7__.PanelPlugin(_GeomapPanel__WEBPACK_IMPORTED_MODULE_1__.GeomapPanel).setNoPadding().setPanelChangeHandler(_migrations__WEBPACK_IMPORTED_MODULE_5__.mapPanelChangedHandler).setMigrationHandler(_migrations__WEBPACK_IMPORTED_MODULE_5__.mapMigrationHandler).useFieldConfig({
  useCustomConfig: (builder) => {
    _grafana_ui__WEBPACK_IMPORTED_MODULE_8__.addHideFrom(builder);
  }
}).setPanelOptions((builder, context) => {
  let category = ["Map view"];
  builder.addCustomEditor({
    category,
    id: "view",
    path: "view",
    name: "Initial view",
    // don't show it
    description: "This location will show when the panel first loads.",
    editor: _editor_MapViewEditor__WEBPACK_IMPORTED_MODULE_3__.MapViewEditor,
    defaultValue: _types__WEBPACK_IMPORTED_MODULE_6__.defaultMapViewConfig
  });
  builder.addBooleanSwitch({
    category,
    path: "view.shared",
    description: "Use the same view across multiple panels.  Note: this may require a dashboard reload.",
    name: "Share view",
    defaultValue: _types__WEBPACK_IMPORTED_MODULE_6__.defaultMapViewConfig.shared
  });
  const state = context.instanceState;
  if (!(state == null ? void 0 : state.layers)) {
  } else {
    const layersCategory = ["Map layers"];
    const basemapCategory = ["Basemap layer"];
    builder.addCustomEditor({
      category: layersCategory,
      id: "layers",
      path: "",
      name: "",
      editor: _editor_LayersEditor__WEBPACK_IMPORTED_MODULE_2__.LayersEditor
    });
    const selected = state.layers[state.selected];
    if (state.selected && selected) {
      builder.addNestedOptions(
        (0,_editor_layerEditor__WEBPACK_IMPORTED_MODULE_4__.getLayerEditor)({
          state: selected,
          category: layersCategory,
          basemaps: false
        })
      );
    }
    const baselayer = state.layers[0];
    if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_9__.config.geomapDisableCustomBaseLayer) {
      builder.addCustomEditor({
        category: basemapCategory,
        id: "layers",
        path: "",
        name: "",
        // eslint-disable-next-line react/display-name
        editor: () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, "The basemap layer is configured by the server admin.")
      });
    } else if (baselayer) {
      builder.addNestedOptions(
        (0,_editor_layerEditor__WEBPACK_IMPORTED_MODULE_4__.getLayerEditor)({
          state: baselayer,
          category: basemapCategory,
          basemaps: true
        })
      );
    }
  }
  category = ["Map controls"];
  builder.addBooleanSwitch({
    category,
    path: "controls.showZoom",
    description: "Show zoom control buttons in the upper left corner",
    name: "Show zoom control",
    defaultValue: true
  }).addBooleanSwitch({
    category,
    path: "controls.mouseWheelZoom",
    description: "Enable zoom control via mouse wheel",
    name: "Mouse wheel zoom",
    defaultValue: true
  }).addBooleanSwitch({
    category,
    path: "controls.showAttribution",
    name: "Show attribution",
    description: "Show the map source attribution info in the lower right",
    defaultValue: true
  }).addBooleanSwitch({
    category,
    path: "controls.showScale",
    name: "Show scale",
    description: "Indicate map scale",
    defaultValue: false
  }).addBooleanSwitch({
    category,
    path: "controls.showMeasure",
    name: "Show measure tools",
    description: "Show tools for making measurements on the map",
    defaultValue: false
  }).addBooleanSwitch({
    category,
    path: "controls.showDebug",
    name: "Show debug",
    description: "Show map info",
    defaultValue: false
  }).addRadio({
    category,
    path: "tooltip.mode",
    name: "Tooltip",
    defaultValue: _types__WEBPACK_IMPORTED_MODULE_6__.TooltipMode.Details,
    settings: {
      options: [
        { label: "None", value: _types__WEBPACK_IMPORTED_MODULE_6__.TooltipMode.None, description: "Show contents on click, not hover" },
        { label: "Details", value: _types__WEBPACK_IMPORTED_MODULE_6__.TooltipMode.Details, description: "Show popup on hover" }
      ]
    }
  });
});


/***/ }),

/***/ "./public/app/plugins/panel/geomap/panelcfg.gen.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MapCenterID: () => (/* binding */ MapCenterID),
/* harmony export */   TooltipMode: () => (/* binding */ TooltipMode),
/* harmony export */   defaultMapViewConfig: () => (/* binding */ defaultMapViewConfig),
/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions)
/* harmony export */ });

const defaultOptions = {
  layers: []
};
const defaultMapViewConfig = {
  allLayers: true,
  id: "zero",
  lat: 0,
  lon: 0,
  zoom: 1
};
var TooltipMode = /* @__PURE__ */ ((TooltipMode2) => {
  TooltipMode2["Details"] = "details";
  TooltipMode2["None"] = "none";
  return TooltipMode2;
})(TooltipMode || {});
var MapCenterID = /* @__PURE__ */ ((MapCenterID2) => {
  MapCenterID2["Coords"] = "coords";
  MapCenterID2["Fit"] = "fit";
  MapCenterID2["Zero"] = "zero";
  return MapCenterID2;
})(MapCenterID || {});


/***/ }),

/***/ "./public/app/plugins/panel/geomap/style/markers.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circleMarker: () => (/* binding */ circleMarker),
/* harmony export */   getFillColor: () => (/* binding */ getFillColor),
/* harmony export */   getMarkerAsPath: () => (/* binding */ getMarkerAsPath),
/* harmony export */   getMarkerMaker: () => (/* binding */ getMarkerMaker),
/* harmony export */   getStrokeStyle: () => (/* binding */ getStrokeStyle),
/* harmony export */   polyStyle: () => (/* binding */ polyStyle),
/* harmony export */   routeStyle: () => (/* binding */ routeStyle),
/* harmony export */   textMarker: () => (/* binding */ textMarker)
/* harmony export */ });
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/style/Text.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/style/Circle.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/style/RegularShape.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/style/Icon.js");
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/tinycolor2/esm/tinycolor.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./packages/grafana-data/src/text/index.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./packages/grafana-data/src/utils/Registry.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-runtime/src/config.ts");
/* harmony import */ var _features_dimensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/style/utils.ts");








var RegularShapeId = /* @__PURE__ */ ((RegularShapeId2) => {
  RegularShapeId2["circle"] = "circle";
  RegularShapeId2["square"] = "square";
  RegularShapeId2["triangle"] = "triangle";
  RegularShapeId2["star"] = "star";
  RegularShapeId2["cross"] = "cross";
  RegularShapeId2["x"] = "x";
  return RegularShapeId2;
})(RegularShapeId || {});
const MarkerShapePath = {
  circle: "img/icons/marker/circle.svg",
  square: "img/icons/marker/square.svg",
  triangle: "img/icons/marker/triangle.svg",
  star: "img/icons/marker/star.svg",
  cross: "img/icons/marker/cross.svg",
  x: "img/icons/marker/x-mark.svg"
};
function getFillColor(cfg) {
  const opacity = cfg.opacity == null ? 0.8 : cfg.opacity;
  if (opacity === 1) {
    return new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({ color: cfg.color });
  }
  if (opacity > 0) {
    const color = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_0__["default"])(cfg.color).setAlpha(opacity).toRgbString();
    return new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({ color });
  }
  return void 0;
}
function getStrokeStyle(cfg) {
  var _a, _b;
  const opacity = cfg.opacity == null ? 0.8 : cfg.opacity;
  if (opacity === 1) {
    return new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: cfg.color, width: (_a = cfg.lineWidth) != null ? _a : 1 });
  }
  if (opacity > 0) {
    const color = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_0__["default"])(cfg.color).setAlpha(opacity).toRgbString();
    return new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color, width: (_b = cfg.lineWidth) != null ? _b : 1 });
  }
  return void 0;
}
const textLabel = (cfg) => {
  var _a;
  if (!cfg.text) {
    return void 0;
  }
  const fontFamily = _grafana_runtime__WEBPACK_IMPORTED_MODULE_6__.config.theme2.typography.fontFamily;
  const textConfig = {
    ..._types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.textConfig,
    ...cfg.textConfig
  };
  return new ol_style__WEBPACK_IMPORTED_MODULE_7__["default"]({
    text: cfg.text,
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({ color: (_a = cfg.color) != null ? _a : _types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.color.fixed }),
    font: "normal ".concat(textConfig.fontSize, "px ").concat(fontFamily),
    ...textConfig
  });
};
const textMarker = (cfg) => {
  return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
    text: textLabel(cfg)
  });
};
const circleMarker = (cfg) => {
  var _a, _b, _c;
  const stroke = new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: cfg.color, width: (_a = cfg.lineWidth) != null ? _a : 1 });
  const radius = (_b = cfg.size) != null ? _b : _types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE;
  return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
    image: new ol_style__WEBPACK_IMPORTED_MODULE_9__["default"]({
      stroke,
      fill: getFillColor(cfg),
      radius,
      displacement: (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getDisplacement)((_c = cfg.symbolAlign) != null ? _c : _types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.symbolAlign, radius)
    }),
    text: textLabel(cfg),
    stroke
    // in case lines are sent to the markers layer
  });
};
const polyStyle = (cfg) => {
  var _a;
  return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
    fill: getFillColor(cfg),
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: cfg.color, width: (_a = cfg.lineWidth) != null ? _a : 1 }),
    text: textLabel(cfg)
  });
};
const routeStyle = (cfg) => {
  return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
    fill: getFillColor(cfg),
    stroke: getStrokeStyle(cfg),
    text: textLabel(cfg)
  });
};
const errorMarker = (cfg) => {
  var _a;
  const radius = (_a = cfg.size) != null ? _a : _types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE;
  const stroke = new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: "#F00", width: 1 });
  return [
    new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
      image: new ol_style__WEBPACK_IMPORTED_MODULE_10__["default"]({
        stroke,
        points: 4,
        radius,
        angle: Math.PI / 4
      })
    }),
    new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
      image: new ol_style__WEBPACK_IMPORTED_MODULE_10__["default"]({
        stroke,
        points: 4,
        radius,
        radius2: 0,
        angle: 0
      })
    })
  ];
};
const makers = [
  {
    id: "circle" /* circle */,
    name: "Circle",
    aliasIds: [MarkerShapePath.circle],
    make: circleMarker
  },
  {
    id: "square" /* square */,
    name: "Square",
    aliasIds: [MarkerShapePath.square],
    make: (cfg) => {
      var _a, _b, _c, _d;
      const radius = (_a = cfg.size) != null ? _a : _types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE;
      const rotation = (_b = cfg.rotation) != null ? _b : 0;
      return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_10__["default"]({
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: cfg.color, width: (_c = cfg.lineWidth) != null ? _c : 1 }),
          fill: getFillColor(cfg),
          points: 4,
          radius,
          angle: Math.PI / 4,
          rotation: rotation * Math.PI / 180,
          displacement: (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getDisplacement)((_d = cfg.symbolAlign) != null ? _d : _types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.symbolAlign, radius)
        }),
        text: textLabel(cfg)
      });
    }
  },
  {
    id: "triangle" /* triangle */,
    name: "Triangle",
    aliasIds: [MarkerShapePath.triangle],
    make: (cfg) => {
      var _a, _b, _c, _d;
      const radius = (_a = cfg.size) != null ? _a : _types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE;
      const rotation = (_b = cfg.rotation) != null ? _b : 0;
      return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_10__["default"]({
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: cfg.color, width: (_c = cfg.lineWidth) != null ? _c : 1 }),
          fill: getFillColor(cfg),
          points: 3,
          radius,
          rotation: rotation * Math.PI / 180,
          angle: 0,
          displacement: (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getDisplacement)((_d = cfg.symbolAlign) != null ? _d : _types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.symbolAlign, radius)
        }),
        text: textLabel(cfg)
      });
    }
  },
  {
    id: "star" /* star */,
    name: "Star",
    aliasIds: [MarkerShapePath.star],
    make: (cfg) => {
      var _a, _b, _c, _d;
      const radius = (_a = cfg.size) != null ? _a : _types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE;
      const rotation = (_b = cfg.rotation) != null ? _b : 0;
      return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_10__["default"]({
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: cfg.color, width: (_c = cfg.lineWidth) != null ? _c : 1 }),
          fill: getFillColor(cfg),
          points: 5,
          radius,
          radius2: radius * 0.4,
          angle: 0,
          rotation: rotation * Math.PI / 180,
          displacement: (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getDisplacement)((_d = cfg.symbolAlign) != null ? _d : _types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.symbolAlign, radius)
        }),
        text: textLabel(cfg)
      });
    }
  },
  {
    id: "cross" /* cross */,
    name: "Cross",
    aliasIds: [MarkerShapePath.cross],
    make: (cfg) => {
      var _a, _b, _c, _d;
      const radius = (_a = cfg.size) != null ? _a : _types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE;
      const rotation = (_b = cfg.rotation) != null ? _b : 0;
      return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_10__["default"]({
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: cfg.color, width: (_c = cfg.lineWidth) != null ? _c : 1 }),
          points: 4,
          radius,
          radius2: 0,
          angle: 0,
          rotation: rotation * Math.PI / 180,
          displacement: (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getDisplacement)((_d = cfg.symbolAlign) != null ? _d : _types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.symbolAlign, radius)
        }),
        text: textLabel(cfg)
      });
    }
  },
  {
    id: "x" /* x */,
    name: "X",
    aliasIds: [MarkerShapePath.x],
    make: (cfg) => {
      var _a, _b, _c, _d;
      const radius = (_a = cfg.size) != null ? _a : _types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE;
      const rotation = (_b = cfg.rotation) != null ? _b : 0;
      return new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_10__["default"]({
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["default"]({ color: cfg.color, width: (_c = cfg.lineWidth) != null ? _c : 1 }),
          points: 4,
          radius,
          radius2: 0,
          angle: Math.PI / 4,
          rotation: rotation * Math.PI / 180,
          displacement: (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getDisplacement)((_d = cfg.symbolAlign) != null ? _d : _types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.symbolAlign, radius)
        }),
        text: textLabel(cfg)
      });
    }
  }
];
async function prepareSVG(url, size) {
  return fetch(url, { method: "GET" }).then((res) => {
    return res.text();
  }).then((text) => {
    var _a, _b;
    text = _grafana_data__WEBPACK_IMPORTED_MODULE_11__.textUtil.sanitizeSVGContent(text);
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, "image/svg+xml");
    const svg = doc.getElementsByTagName("svg")[0];
    if (!svg) {
      return "";
    }
    const svgSize = size != null ? size : 100;
    const width = (_a = svg.getAttribute("width")) != null ? _a : svgSize;
    const height = (_b = svg.getAttribute("height")) != null ? _b : svgSize;
    svg.setAttribute("fill", "#fff");
    svg.setAttribute("width", "".concat(width, "px"));
    svg.setAttribute("height", "".concat(height, "px"));
    const svgString = new XMLSerializer().serializeToString(svg);
    const svgURI = encodeURIComponent(svgString);
    return "data:image/svg+xml,".concat(svgURI);
  }).catch((error) => {
    console.error(error);
    return "";
  });
}
const markerMakers = new _grafana_data__WEBPACK_IMPORTED_MODULE_12__.Registry(() => makers);
function getMarkerAsPath(shape) {
  var _a;
  const marker = markerMakers.getIfExists(shape);
  if ((_a = marker == null ? void 0 : marker.aliasIds) == null ? void 0 : _a.length) {
    return marker.aliasIds[0];
  }
  return void 0;
}
async function getMarkerMaker(symbol, hasTextLabel) {
  if (!symbol) {
    return hasTextLabel ? textMarker : circleMarker;
  }
  let maker = markerMakers.getIfExists(symbol);
  if (maker) {
    return maker.make;
  }
  if (symbol.endsWith(".svg")) {
    const src = await prepareSVG((0,_features_dimensions__WEBPACK_IMPORTED_MODULE_1__.getPublicOrAbsoluteUrl)(symbol));
    maker = {
      id: symbol,
      name: symbol,
      aliasIds: [],
      make: src ? (cfg) => {
        var _a, _b, _c, _d;
        const radius = (_a = cfg.size) != null ? _a : _types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE;
        const rotation = (_b = cfg.rotation) != null ? _b : 0;
        return [
          new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
            image: new ol_style__WEBPACK_IMPORTED_MODULE_13__["default"]({
              src,
              color: cfg.color,
              opacity: (_c = cfg.opacity) != null ? _c : 1,
              scale: (_types__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SIZE + radius) / 100,
              rotation: rotation * Math.PI / 180,
              displacement: (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getDisplacement)((_d = cfg.symbolAlign) != null ? _d : _types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.symbolAlign, radius / 2)
            }),
            text: !(cfg == null ? void 0 : cfg.text) ? void 0 : textLabel(cfg)
          }),
          // transparent bounding box for featureAtPixel detection
          new ol_style__WEBPACK_IMPORTED_MODULE_8__["default"]({
            image: new ol_style__WEBPACK_IMPORTED_MODULE_10__["default"]({
              fill: new ol_style__WEBPACK_IMPORTED_MODULE_4__["default"]({ color: "rgba(0,0,0,0)" }),
              points: 4,
              radius: cfg.size,
              rotation: rotation * Math.PI / 180 + Math.PI / 4
            })
          })
        ];
      } : errorMarker
    };
    markerMakers.register(maker);
    return maker.make;
  }
  return errorMarker;
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/style/utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDisplacement: () => (/* binding */ getDisplacement),
/* harmony export */   getStyleConfigState: () => (/* binding */ getStyleConfigState),
/* harmony export */   styleUsesText: () => (/* binding */ styleUsesText)
/* harmony export */ });
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/config.ts");
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _markers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/style/markers.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");





function styleUsesText(config2) {
  var _a, _b;
  const text = config2 == null ? void 0 : config2.text;
  if (!text) {
    return false;
  }
  if (text.mode === _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.TextDimensionMode.Fixed && ((_a = text.fixed) == null ? void 0 : _a.length)) {
    return true;
  }
  if (text.mode === _grafana_schema__WEBPACK_IMPORTED_MODULE_2__.TextDimensionMode.Field && ((_b = text.field) == null ? void 0 : _b.length)) {
    return true;
  }
  return false;
}
async function getStyleConfigState(cfg) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
  if (!cfg) {
    cfg = _types__WEBPACK_IMPORTED_MODULE_1__.defaultStyleConfig;
  }
  const hasText = styleUsesText(cfg);
  const fields = {};
  const maker = await (0,_markers__WEBPACK_IMPORTED_MODULE_0__.getMarkerMaker)((_a = cfg.symbol) == null ? void 0 : _a.fixed, hasText);
  const state = {
    config: cfg,
    // raw values
    hasText,
    fields,
    base: {
      color: _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.theme2.visualization.getColorByName((_c = (_b = cfg.color) == null ? void 0 : _b.fixed) != null ? _c : _types__WEBPACK_IMPORTED_MODULE_1__.defaultStyleConfig.color.fixed),
      opacity: (_d = cfg.opacity) != null ? _d : _types__WEBPACK_IMPORTED_MODULE_1__.defaultStyleConfig.opacity,
      lineWidth: (_e = cfg.lineWidth) != null ? _e : 1,
      size: (_g = (_f = cfg.size) == null ? void 0 : _f.fixed) != null ? _g : _types__WEBPACK_IMPORTED_MODULE_1__.defaultStyleConfig.size.fixed,
      rotation: (_i = (_h = cfg.rotation) == null ? void 0 : _h.fixed) != null ? _i : _types__WEBPACK_IMPORTED_MODULE_1__.defaultStyleConfig.rotation.fixed,
      // add ability follow path later
      symbolAlign: (_j = cfg.symbolAlign) != null ? _j : _types__WEBPACK_IMPORTED_MODULE_1__.defaultStyleConfig.symbolAlign
    },
    maker
  };
  if ((_l = (_k = cfg.color) == null ? void 0 : _k.field) == null ? void 0 : _l.length) {
    fields.color = cfg.color.field;
  }
  if ((_n = (_m = cfg.size) == null ? void 0 : _m.field) == null ? void 0 : _n.length) {
    fields.size = cfg.size.field;
  }
  if ((_p = (_o = cfg.rotation) == null ? void 0 : _o.field) == null ? void 0 : _p.length) {
    fields.rotation = cfg.rotation.field;
  }
  if (hasText) {
    state.base.text = (_q = cfg.text) == null ? void 0 : _q.fixed;
    state.base.textConfig = (_r = cfg.textConfig) != null ? _r : _types__WEBPACK_IMPORTED_MODULE_1__.defaultStyleConfig.textConfig;
    if ((_t = (_s = cfg.text) == null ? void 0 : _s.field) == null ? void 0 : _t.length) {
      fields.text = cfg.text.field;
    }
  }
  if (!Object.keys(fields).length) {
    state.fields = void 0;
  }
  return state;
}
function getDisplacement(symbolAlign, radius) {
  const displacement = [0, 0];
  if ((symbolAlign == null ? void 0 : symbolAlign.horizontal) === _types__WEBPACK_IMPORTED_MODULE_1__.HorizontalAlign.Left) {
    displacement[0] = -radius;
  } else if ((symbolAlign == null ? void 0 : symbolAlign.horizontal) === _types__WEBPACK_IMPORTED_MODULE_1__.HorizontalAlign.Right) {
    displacement[0] = radius;
  }
  if ((symbolAlign == null ? void 0 : symbolAlign.vertical) === _types__WEBPACK_IMPORTED_MODULE_1__.VerticalAlign.Top) {
    displacement[1] = radius;
  } else if ((symbolAlign == null ? void 0 : symbolAlign.vertical) === _types__WEBPACK_IMPORTED_MODULE_1__.VerticalAlign.Bottom) {
    displacement[1] = -radius;
  }
  return displacement;
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TooltipMode: () => (/* reexport safe */ _panelcfg_gen__WEBPACK_IMPORTED_MODULE_0__.TooltipMode),
/* harmony export */   defaultMapViewConfig: () => (/* reexport safe */ _panelcfg_gen__WEBPACK_IMPORTED_MODULE_0__.defaultMapViewConfig)
/* harmony export */ });
/* harmony import */ var _panelcfg_gen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/panelcfg.gen.ts");




/***/ }),

/***/ "./public/app/plugins/panel/geomap/utils/actions.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActions: () => (/* binding */ getActions)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_schema__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-schema/src/common/common.gen.ts");
/* harmony import */ var _layers_registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/registry.ts");
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");
/* harmony import */ var _layers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/layers.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/utils.ts");







const getActions = (panel) => {
  const actions = {
    selectLayer: (uid) => {
      const selected = panel.layers.findIndex((v) => v.options.name === uid);
      if (panel.panelContext && panel.panelContext.onInstanceStateChange) {
        panel.panelContext.onInstanceStateChange({
          map: panel.map,
          layers: panel.layers,
          selected,
          actions: panel.actions
        });
      }
    },
    canRename: (v) => {
      return !panel.byName.has(v);
    },
    deleteLayer: (uid) => {
      var _a;
      const layers = [];
      for (const lyr of panel.layers) {
        if (lyr.options.name === uid) {
          (_a = panel.map) == null ? void 0 : _a.removeLayer(lyr.layer);
        } else {
          layers.push(lyr);
        }
      }
      panel.layers = layers;
      panel.doOptionsUpdate(0);
    },
    addlayer: (type) => {
      const item = _layers_registry__WEBPACK_IMPORTED_MODULE_1__.geomapLayerRegistry.getIfExists(type);
      if (!item) {
        return;
      }
      (0,_layers__WEBPACK_IMPORTED_MODULE_3__.initLayer)(
        panel,
        panel.map,
        {
          type: item.id,
          name: (0,_utils__WEBPACK_IMPORTED_MODULE_4__.getNextLayerName)(panel),
          config: (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(item.defaultOptions),
          location: item.showLocation ? { mode: _grafana_schema__WEBPACK_IMPORTED_MODULE_5__.FrameGeometrySourceMode.Auto } : void 0,
          tooltip: true,
          ...!item.hideOpacity && { opacity: _style_types__WEBPACK_IMPORTED_MODULE_2__.defaultStyleConfig.opacity }
        },
        false
      ).then((lyr) => {
        var _a;
        panel.layers = panel.layers.slice(0);
        panel.layers.push(lyr);
        (_a = panel.map) == null ? void 0 : _a.addLayer(lyr.layer);
        panel.doOptionsUpdate(panel.layers.length - 1);
      });
    },
    reorder: (startIndex, endIndex) => {
      var _a;
      const result = Array.from(panel.layers);
      const [removed] = result.splice(startIndex, 1);
      result.splice(endIndex, 0, removed);
      panel.layers = result;
      panel.doOptionsUpdate(endIndex);
      const group = (_a = panel.map) == null ? void 0 : _a.getLayers();
      group.clear();
      panel.layers.forEach((v) => group.push(v.layer));
    }
  };
  return actions;
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/utils/checkFeatureMatchesStyleRule.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkFeatureMatchesStyleRule: () => (/* binding */ checkFeatureMatchesStyleRule)
/* harmony export */ });
/* harmony import */ var _grafana_data_src_transformations_matchers_compareValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/transformations/matchers/compareValues.ts");


const checkFeatureMatchesStyleRule = (rule, feature) => {
  const val = feature.get(rule.property);
  return (0,_grafana_data_src_transformations_matchers_compareValues__WEBPACK_IMPORTED_MODULE_0__.compareValues)(val, rule.operation, rule.value);
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/utils/getFeatures.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLayerPropertyInfo: () => (/* binding */ getLayerPropertyInfo),
/* harmony export */   getUniqueFeatureValues: () => (/* binding */ getUniqueFeatureValues)
/* harmony export */ });
/* harmony import */ var _style_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/style/types.ts");


function getLayerPropertyInfo(features) {
  const types = /* @__PURE__ */ new Set();
  const props = /* @__PURE__ */ new Set();
  features.some((feature, idx) => {
    for (const key in feature.getProperties()) {
      if (key === "geometry") {
        continue;
      }
      props.add(key);
      const g = feature.getGeometry();
      if (g) {
        types.add(g.getType());
      }
    }
    return idx > 10;
  });
  let geometryType = _style_types__WEBPACK_IMPORTED_MODULE_0__.GeometryTypeId.Any;
  if (types.size === 1) {
    switch (types.values().next().value) {
      case "Point":
      case "MultiPoint":
        geometryType = _style_types__WEBPACK_IMPORTED_MODULE_0__.GeometryTypeId.Point;
        break;
      case "Line":
      case "MultiLine":
        geometryType = _style_types__WEBPACK_IMPORTED_MODULE_0__.GeometryTypeId.Line;
        break;
      case "Polygon":
        geometryType = _style_types__WEBPACK_IMPORTED_MODULE_0__.GeometryTypeId.Polygon;
    }
  }
  return {
    geometryType,
    propertes: Array.from(props.keys()).map((v) => ({ label: v, value: v }))
  };
}
function getUniqueFeatureValues(features, key) {
  const unique = /* @__PURE__ */ new Set();
  for (const feature of features) {
    const v = feature.get(key);
    if (v != null) {
      unique.add("".concat(v));
    }
  }
  const buffer = Array.from(unique);
  buffer.sort();
  return buffer;
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/utils/getLayersExtent.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLayerGroupExtent: () => (/* binding */ getLayerGroupExtent),
/* harmony export */   getLayersExtent: () => (/* binding */ getLayersExtent)
/* harmony export */ });
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var ol_layer_Group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/layer/Group.js");
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/Vector.js");




function getLayersExtent(layers = [], allLayers = false, lastOnly = false, layer) {
  return layers.filter((l) => l.layer instanceof ol_layer_Vector__WEBPACK_IMPORTED_MODULE_0__["default"] || l.layer instanceof ol_layer_Group__WEBPACK_IMPORTED_MODULE_1__["default"]).flatMap((ll) => {
    const l = ll.layer;
    if (l instanceof ol_layer_Group__WEBPACK_IMPORTED_MODULE_1__["default"]) {
      return getLayerGroupExtent(l);
    } else if (l instanceof ol_layer_Vector__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      if (allLayers) {
        return [l.getSource().getExtent()];
      } else if (lastOnly && layer === ll.options.name) {
        const feat = l.getSource().getFeatures();
        const featOfInterest = feat[feat.length - 1];
        const geo = featOfInterest == null ? void 0 : featOfInterest.getGeometry();
        if (geo) {
          return [geo.getExtent()];
        }
        return [];
      } else if (!lastOnly && layer === ll.options.name) {
        return [l.getSource().getExtent()];
      }
      return [];
    } else {
      return [];
    }
  }).reduce(ol_extent__WEBPACK_IMPORTED_MODULE_2__.extend, (0,ol_extent__WEBPACK_IMPORTED_MODULE_2__.createEmpty)());
}
function getLayerGroupExtent(lg) {
  return lg.getLayers().getArray().filter((l) => l instanceof ol_layer_Vector__WEBPACK_IMPORTED_MODULE_0__["default"]).map((l) => {
    var _a;
    if (l instanceof ol_layer_Vector__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      return (_a = l.getSource().getExtent()) != null ? _a : [];
    } else {
      return [];
    }
  });
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/utils/layers.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyLayerFilter: () => (/* binding */ applyLayerFilter),
/* harmony export */   getMapLayerState: () => (/* binding */ getMapLayerState),
/* harmony export */   initLayer: () => (/* binding */ initLayer),
/* harmony export */   updateLayer: () => (/* binding */ updateLayer)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/transformations/matchers.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/text/index.ts");
/* harmony import */ var _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-runtime/src/config.ts");
/* harmony import */ var _layers_data_markersLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/data/markersLayer.tsx");
/* harmony import */ var _layers_registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/geomap/layers/registry.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/utils.ts");







const applyLayerFilter = (handler, options, panelDataProps) => {
  if (handler.update) {
    let panelData = panelDataProps;
    if (options.filterData) {
      const matcherFunc = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.getFrameMatchers)(options.filterData);
      panelData = {
        ...panelData,
        series: panelData.series.filter(matcherFunc)
      };
    }
    handler.update(panelData);
  }
};
async function updateLayer(panel, uid, newOptions) {
  var _a, _b, _c, _d;
  if (!panel.map) {
    return false;
  }
  const current = panel.byName.get(uid);
  if (!current) {
    return false;
  }
  let layerIndex = -1;
  const group = (_a = panel.map) == null ? void 0 : _a.getLayers();
  for (let i = 0; i < (group == null ? void 0 : group.getLength()); i++) {
    if (group.item(i) === current.layer) {
      layerIndex = i;
      break;
    }
  }
  if (newOptions.name !== uid) {
    if (!newOptions.name) {
      newOptions.name = uid;
    } else if (panel.byName.has(newOptions.name)) {
      return false;
    }
    panel.byName.delete(uid);
    uid = newOptions.name;
    panel.byName.set(uid, current);
  }
  if (current.options.type !== newOptions.type) {
  } else {
  }
  const layers = panel.layers.slice(0);
  try {
    const info = await initLayer(panel, panel.map, newOptions, current.isBasemap);
    (_d = (_b = layers[layerIndex]) == null ? void 0 : (_c = _b.handler).dispose) == null ? void 0 : _d.call(_c);
    layers[layerIndex] = info;
    group.setAt(layerIndex, info.layer);
    applyLayerFilter(info.handler, newOptions, panel.props.data);
  } catch (err) {
    console.warn("ERROR", err);
    return false;
  }
  panel.setState({ legends: [] });
  panel.layers = layers;
  panel.doOptionsUpdate(layerIndex);
  return true;
}
async function initLayer(panel, map, options, isBasemap) {
  var _a;
  if (isBasemap && (!(options == null ? void 0 : options.type) || _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_4__.config.geomapDisableCustomBaseLayer)) {
    options = _layers_registry__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BASEMAP_CONFIG;
  }
  if (!(options == null ? void 0 : options.type)) {
    options = {
      type: _layers_data_markersLayer__WEBPACK_IMPORTED_MODULE_0__.MARKERS_LAYER_ID,
      name: (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getNextLayerName)(panel),
      config: {}
    };
  }
  const item = _layers_registry__WEBPACK_IMPORTED_MODULE_1__.geomapLayerRegistry.getIfExists(options.type);
  if (!item) {
    return Promise.reject("unknown layer: " + options.type);
  }
  if ((_a = options.config) == null ? void 0 : _a.attribution) {
    options.config.attribution = _grafana_data__WEBPACK_IMPORTED_MODULE_5__.textUtil.sanitizeTextPanelContent(options.config.attribution);
  }
  const handler = await item.create(map, options, panel.props.eventBus, _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_4__.config.theme2);
  const layer = handler.init();
  if (options.opacity != null) {
    layer.setOpacity(options.opacity);
  }
  if (!options.name) {
    options.name = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getNextLayerName)(panel);
  }
  const UID = options.name;
  const state = {
    // UID, // unique name when added to the map (it may change and will need special handling)
    isBasemap,
    options,
    layer,
    handler,
    mouseEvents: new rxjs__WEBPACK_IMPORTED_MODULE_6__.Subject(),
    getName: () => UID,
    // Used by the editors
    onChange: (cfg) => {
      updateLayer(panel, UID, cfg);
    }
  };
  panel.byName.set(UID, state);
  state.layer.__state = state;
  applyLayerFilter(handler, options, panel.props.data);
  return state;
}
const getMapLayerState = (l) => {
  return l == null ? void 0 : l.__state;
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/utils/measure.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   measures: () => (/* binding */ measures)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/valueFormats/valueFormats.ts");


const measures = [
  {
    value: "length",
    label: "Length",
    geometry: "LineString",
    units: [
      {
        label: "Metric (m/km)",
        value: "m",
        format: (m) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getValueFormat)("lengthm")(m)
      },
      {
        label: "Feet (ft)",
        value: "ft",
        format: (m) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getValueFormat)("lengthft")(m * 3.28084)
      },
      {
        label: "Miles (mi)",
        value: "mi",
        format: (m) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getValueFormat)("lengthmi")(m / 1609)
      },
      {
        label: "Nautical miles (nmi)",
        value: "nmi",
        format: (m) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getValueFormat)("nmi")(m / 1852)
      }
    ],
    getUnit: (v) => {
      var _a;
      const units = measures[0].units;
      if (v == null ? void 0 : v.endsWith("2")) {
        v = v.substring(0, v.length - 1);
      }
      return (_a = units.find((u) => u.value === v)) != null ? _a : units[0];
    }
  },
  {
    value: "area",
    label: "Area",
    geometry: "Polygon",
    units: [
      {
        label: "Square Meters (m\xB2)",
        value: "m2",
        format: (m2) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getValueFormat)("areaM2")(m2)
      },
      {
        label: "Square Kilometers (km\xB2)",
        value: "km2",
        format: (m2) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.toFixedUnit)("km\xB2")(m2 * 1e-6)
      },
      {
        label: "Square Feet (ft\xB2)",
        value: "ft2",
        format: (m2) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getValueFormat)("areaF2")(m2 * 10.76391)
      },
      {
        label: "Square Miles (mi\xB2)",
        value: "mi2",
        format: (m2) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getValueFormat)("areaMI2")(m2 * 3861e-10)
      },
      {
        label: "Acres",
        value: "acre2",
        format: (m2) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.toFixedUnit)("acre")(m2 * 247105e-9)
      },
      {
        label: "Hectare",
        value: "hectare2",
        format: (m2) => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.toFixedUnit)("ha")(m2 * 1e-4)
      }
    ],
    getUnit: (v) => {
      var _a;
      const units = measures[1].units;
      if (!(v == null ? void 0 : v.endsWith("2"))) {
        v += "2";
      }
      return (_a = units.find((u) => u.value === v)) != null ? _a : units[0];
    }
  }
];


/***/ }),

/***/ "./public/app/plugins/panel/geomap/utils/selection.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSelectionInfo: () => (/* binding */ getSelectionInfo)
/* harmony export */ });

function getSelectionInfo(v, options) {
  if (v && !options) {
    const current2 = { label: "".concat(v), value: v };
    return { options: [current2], current: current2 };
  }
  if (!options) {
    options = [];
  }
  let current = options.find((item) => item.value === v);
  if (v && !current) {
    current = {
      label: "".concat(v, " (not found)"),
      value: v
    };
    options.push(current);
  }
  return {
    options,
    current
  };
}


/***/ }),

/***/ "./public/app/plugins/panel/geomap/utils/tooltip.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pointerClickListener: () => (/* binding */ pointerClickListener),
/* harmony export */   pointerMoveListener: () => (/* binding */ pointerMoveListener),
/* harmony export */   setTooltipListeners: () => (/* binding */ setTooltipListeners)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _grafana_data_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/events/common.ts");
/* harmony import */ var _layers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/geomap/utils/layers.ts");





const setTooltipListeners = (panel) => {
  var _a, _b, _c;
  (_a = panel.map) == null ? void 0 : _a.on("singleclick", panel.pointerClickListener);
  (_b = panel.map) == null ? void 0 : _b.on("pointermove", (0,lodash__WEBPACK_IMPORTED_MODULE_0__.debounce)(panel.pointerMoveListener, 200));
  (_c = panel.map) == null ? void 0 : _c.getViewport().addEventListener("mouseout", (evt) => {
    panel.props.eventBus.publish(new _grafana_data_src__WEBPACK_IMPORTED_MODULE_3__.DataHoverClearEvent());
  });
};
const pointerClickListener = (evt, panel) => {
  if (pointerMoveListener(evt, panel)) {
    evt.preventDefault();
    evt.stopPropagation();
    panel.mapDiv.style.cursor = "auto";
    panel.setState({ ttipOpen: true });
  }
};
const pointerMoveListener = (evt, panel) => {
  var _a, _b, _c, _d;
  if (panel.state.measureMenuActive) {
    return true;
  }
  if (!panel.map || panel.state.ttipOpen && ((_c = (_b = (_a = panel.state) == null ? void 0 : _a.ttip) == null ? void 0 : _b.layers) == null ? void 0 : _c.length)) {
    return false;
  }
  const mouse = evt.originalEvent;
  const pixel = panel.map.getEventPixel(mouse);
  const hover = (0,ol_proj__WEBPACK_IMPORTED_MODULE_1__.toLonLat)(panel.map.getCoordinateFromPixel(pixel));
  const { hoverPayload } = panel;
  hoverPayload.pageX = mouse.pageX;
  hoverPayload.pageY = mouse.pageY;
  hoverPayload.point = {
    lat: hover[1],
    lon: hover[0]
  };
  hoverPayload.data = void 0;
  hoverPayload.columnIndex = void 0;
  hoverPayload.rowIndex = void 0;
  hoverPayload.layers = void 0;
  const layers = [];
  const layerLookup = /* @__PURE__ */ new Map();
  let ttip = {};
  panel.map.forEachFeatureAtPixel(
    pixel,
    (feature, layer, geo) => {
      const s = (0,_layers__WEBPACK_IMPORTED_MODULE_2__.getMapLayerState)(layer);
      if (!hoverPayload.data) {
        const props = feature.getProperties();
        const frame = props["frame"];
        if (frame) {
          hoverPayload.data = ttip.data = frame;
          hoverPayload.rowIndex = ttip.rowIndex = props["rowIndex"];
        }
        if (s == null ? void 0 : s.mouseEvents) {
          s.mouseEvents.next(feature);
        }
      }
      if (s) {
        let h = layerLookup.get(s);
        if (!h) {
          h = { layer: s, features: [] };
          layerLookup.set(s, h);
          layers.push(h);
        }
        h.features.push(feature);
      }
    },
    {
      layerFilter: (l) => {
        var _a2;
        const hoverLayerState = (0,_layers__WEBPACK_IMPORTED_MODULE_2__.getMapLayerState)(l);
        return ((_a2 = hoverLayerState == null ? void 0 : hoverLayerState.options) == null ? void 0 : _a2.tooltip) !== false;
      }
    }
  );
  panel.hoverPayload.layers = layers.length ? layers : void 0;
  panel.props.eventBus.publish(panel.hoverEvent);
  if (panel.state.ttip === void 0 || ((_d = panel.state.ttip) == null ? void 0 : _d.layers) !== hoverPayload.layers || hoverPayload.layers) {
    panel.setState({ ttip: { ...hoverPayload } });
  }
  if (!layers.length) {
    panel.layers.forEach((layer) => {
      layer.mouseEvents.next(void 0);
    });
  }
  const found = Boolean(layers.length);
  panel.mapDiv.style.cursor = found ? "pointer" : "auto";
  return found;
};


/***/ }),

/***/ "./public/app/plugins/panel/geomap/view.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MapCenterID: () => (/* binding */ MapCenterID),
/* harmony export */   centerPointRegistry: () => (/* binding */ centerPointRegistry)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/utils/Registry.ts");


var MapCenterID = /* @__PURE__ */ ((MapCenterID2) => {
  MapCenterID2["Zero"] = "zero";
  MapCenterID2["Coordinates"] = "coords";
  MapCenterID2["Fit"] = "fit";
  return MapCenterID2;
})(MapCenterID || {});
const centerPointRegistry = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(() => [
  {
    id: "fit" /* Fit */,
    name: "Fit to data",
    zoom: 15
    // max zoom
  },
  {
    id: "zero" /* Zero */,
    name: "(0\xB0, 0\xB0)",
    lat: 0,
    lon: 0
  },
  {
    id: "coords" /* Coordinates */,
    name: "Coordinates"
  },
  {
    id: "north-america",
    name: "North America",
    lat: 40,
    lon: -100,
    zoom: 4
  },
  {
    id: "south-america",
    name: "South America",
    lat: -20,
    lon: -60,
    zoom: 3
  },
  {
    id: "europe",
    name: "Europe",
    lat: 46,
    lon: 14,
    zoom: 4
  },
  {
    id: "africa",
    name: "Africa",
    lat: 0,
    lon: 30,
    zoom: 3
  },
  {
    id: "west-asia",
    name: "West Asia",
    lat: 26,
    lon: 53,
    zoom: 4
  },
  {
    id: "s-asia",
    name: "South Asia",
    lat: 19.5,
    lon: 80,
    zoom: 4
  },
  {
    id: "se-asia",
    name: "South-East Asia",
    lat: 10,
    lon: 106,
    zoom: 4
  },
  {
    id: "e-asia",
    name: "East Asia",
    lat: 33,
    lon: 120,
    zoom: 4
  },
  {
    id: "australia",
    name: "Australia",
    lat: -25,
    lon: 135,
    zoom: 4
  },
  {
    id: "oceania",
    name: "Oceania",
    lat: -10,
    lon: -140,
    zoom: 3
  }
]);


/***/ }),

/***/ "./public/app/plugins/panel/nodeGraph/Node.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Node: () => (/* binding */ Node),
/* harmony export */   computeNodeCircumferenceStrokeWidth: () => (/* binding */ computeNodeCircumferenceStrokeWidth),
/* harmony export */   highlightedNodeColor: () => (/* binding */ highlightedNodeColor),
/* harmony export */   nodeR: () => (/* binding */ nodeR)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/tinycolor2/esm/tinycolor.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/grafana-data/src/field/fieldColor.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/themes/ThemeContext.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-ui/src/components/Icon/Icon.tsx");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/nodeGraph/utils.ts");

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a, _b, _c, _d, _e, _f, _g, _h, _i;







const nodeR = 40;
const highlightedNodeColor = "#a00";
const getStyles = (theme, hovering) => ({
  mainGroup: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_a || (_a = __template(["\n    cursor: pointer;\n    font-size: 10px;\n    transition: opacity 300ms;\n    opacity: ", ";\n  "])), hovering === "inactive" ? 0.5 : 1),
  mainCircle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_b || (_b = __template(["\n    fill: ", ";\n  "])), theme.components.panel.background),
  filledCircle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_c || (_c = __template(["\n    fill: ", ";\n  "])), highlightedNodeColor),
  hoverCircle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_d || (_d = __template(["\n    opacity: 0.5;\n    fill: transparent;\n    stroke: ", ";\n  "])), theme.colors.primary.text),
  text: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_e || (_e = __template(["\n    fill: ", ";\n    pointer-events: none;\n  "])), theme.colors.text.primary),
  titleText: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_f || (_f = __template(["\n    text-align: center;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    background-color: ", ";\n    width: 140px;\n  "])), (0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__["default"])(theme.colors.background.primary).setAlpha(0.6).toHex8String()),
  statsText: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_g || (_g = __template(["\n    text-align: center;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    width: 70px;\n  "]))),
  textHovering: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_h || (_h = __template(["\n    width: 200px;\n    & span {\n      background-color: ", ";\n    }\n  "])), (0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__["default"])(theme.colors.background.primary).setAlpha(0.8).toHex8String()),
  clickTarget: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)(_i || (_i = __template(["\n    fill: none;\n    stroke: none;\n    pointer-events: fill;\n  "])))
});
const computeNodeCircumferenceStrokeWidth = (nodeRadius) => Math.ceil(nodeRadius * 0.075);
const Node = (0,react__WEBPACK_IMPORTED_MODULE_2__.memo)(function Node2(props) {
  var _a2;
  const { node, onMouseEnter, onMouseLeave, onClick, hovering } = props;
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.useTheme2)();
  const styles = getStyles(theme, hovering);
  const isHovered = hovering === "active";
  const nodeRadius = ((_a2 = node.nodeRadius) == null ? void 0 : _a2.values[node.dataFrameRowIndex]) || nodeR;
  const strokeWidth = computeNodeCircumferenceStrokeWidth(nodeRadius);
  if (!(node.x !== void 0 && node.y !== void 0)) {
    return null;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("g", { "data-node-id": node.id, className: styles.mainGroup, "aria-label": "Node: ".concat(node.title) }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
    "circle",
    {
      "data-testid": "node-circle-".concat(node.id),
      className: node.highlighted ? styles.filledCircle : styles.mainCircle,
      r: nodeRadius,
      cx: node.x,
      cy: node.y
    }
  ), isHovered && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("circle", { className: styles.hoverCircle, r: nodeRadius - 3, cx: node.x, cy: node.y, strokeWidth }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ColorCircle, { node }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("g", { className: styles.text, style: { pointerEvents: "none" } }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(NodeContents, { node, hovering }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
    "foreignObject",
    {
      x: node.x - (isHovered ? 100 : 70),
      y: node.y + nodeRadius + 5,
      width: isHovered ? "200" : "140",
      height: "40"
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("div", { className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(styles.titleText, isHovered && styles.textHovering) }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("span", null, node.title), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("br", null), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("span", null, node.subTitle))
  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
    "rect",
    {
      "data-testid": "node-click-rect-".concat(node.id),
      onMouseEnter: () => {
        onMouseEnter(node.id);
      },
      onMouseLeave: () => {
        onMouseLeave(node.id);
      },
      onClick: (event) => {
        onClick(event, node);
      },
      className: styles.clickTarget,
      x: node.x - nodeRadius - 5,
      y: node.y - nodeRadius - 5,
      width: nodeRadius * 2 + 10,
      height: nodeRadius * 2 + 50
    }
  ));
});
function NodeContents({ node, hovering }) {
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.useTheme2)();
  const styles = getStyles(theme, hovering);
  const isHovered = hovering === "active";
  if (!(node.x !== void 0 && node.y !== void 0)) {
    return null;
  }
  return node.icon ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("foreignObject", { x: node.x - 35, y: node.y - 20, width: "70", height: "40" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("div", { style: { width: 70, overflow: "hidden", display: "flex", justifyContent: "center", marginTop: -4 } }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_6__.Icon, { "data-testid": "node-icon-".concat(node.icon), name: node.icon, size: "xxxl" }))) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("foreignObject", { x: node.x - (isHovered ? 100 : 35), y: node.y - 15, width: isHovered ? "200" : "70", height: "40" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("div", { className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(styles.statsText, isHovered && styles.textHovering) }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("span", null, node.mainStat && (0,_utils__WEBPACK_IMPORTED_MODULE_4__.statToString)(node.mainStat.config, node.mainStat.values[node.dataFrameRowIndex])), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("br", null), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement("span", null, node.secondaryStat && (0,_utils__WEBPACK_IMPORTED_MODULE_4__.statToString)(node.secondaryStat.config, node.secondaryStat.values[node.dataFrameRowIndex]))));
}
function ColorCircle(props) {
  var _a2, _b2;
  const { node } = props;
  const fullStat = node.arcSections.find((s) => s.values[node.dataFrameRowIndex] >= 1);
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.useTheme2)();
  const nodeRadius = ((_a2 = node.nodeRadius) == null ? void 0 : _a2.values[node.dataFrameRowIndex]) || nodeR;
  const strokeWidth = computeNodeCircumferenceStrokeWidth(nodeRadius);
  if (fullStat) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
      "circle",
      {
        fill: "none",
        stroke: theme.visualization.getColorByName(((_b2 = fullStat.config.color) == null ? void 0 : _b2.fixedColor) || ""),
        strokeWidth,
        r: nodeRadius,
        cx: node.x,
        cy: node.y
      }
    );
  }
  const nonZero = node.arcSections.filter((s) => s.values[node.dataFrameRowIndex] !== 0);
  if (nonZero.length === 0) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
      "circle",
      {
        fill: "none",
        stroke: node.color ? getColor(node.color, node.dataFrameRowIndex, theme) : "gray",
        strokeWidth,
        r: nodeRadius,
        cx: node.x,
        cy: node.y
      }
    );
  }
  const { elements } = nonZero.reduce(
    (acc, section, index) => {
      var _a3;
      const color = ((_a3 = section.config.color) == null ? void 0 : _a3.fixedColor) || "";
      const value = section.values[node.dataFrameRowIndex];
      const el = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
        ArcSection,
        {
          key: index,
          r: nodeRadius,
          x: node.x,
          y: node.y,
          startPercent: acc.percent,
          percent: value + acc.percent > 1 ? (
            // If the values aren't correct and add up to more than 100% lets still render correctly the amounts we
            // already have and cap it at 100%
            1 - acc.percent
          ) : value,
          color: theme.visualization.getColorByName(color),
          strokeWidth
        }
      );
      acc.elements.push(el);
      acc.percent = acc.percent + value;
      return acc;
    },
    { elements: [], percent: 0 }
  );
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement((react__WEBPACK_IMPORTED_MODULE_2___default().Fragment), null, elements);
}
function ArcSection({
  r,
  x,
  y,
  startPercent,
  percent,
  color,
  strokeWidth = 2
}) {
  const endPercent = startPercent + percent;
  const startXPos = x + Math.sin(2 * Math.PI * startPercent) * r;
  const startYPos = y - Math.cos(2 * Math.PI * startPercent) * r;
  const endXPos = x + Math.sin(2 * Math.PI * endPercent) * r;
  const endYPos = y - Math.cos(2 * Math.PI * endPercent) * r;
  const largeArc = percent > 0.5 ? "1" : "0";
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(
    "path",
    {
      fill: "none",
      d: "M ".concat(startXPos, " ").concat(startYPos, " A ").concat(r, " ").concat(r, " 0 ").concat(largeArc, " 1 ").concat(endXPos, " ").concat(endYPos),
      stroke: color,
      strokeWidth
    }
  );
}
function getColor(field, index, theme) {
  if (!field.config.color) {
    return field.values[index];
  }
  return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_7__.getFieldColorModeForField)(field).getCalculator(field, theme)(0, field.values[index]);
}


/***/ }),

/***/ "./public/app/plugins/panel/nodeGraph/utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyOptionsToFrames: () => (/* binding */ applyOptionsToFrames),
/* harmony export */   findConnectedNodesForEdge: () => (/* binding */ findConnectedNodesForEdge),
/* harmony export */   findConnectedNodesForNode: () => (/* binding */ findConnectedNodesForNode),
/* harmony export */   getEdgeFields: () => (/* binding */ getEdgeFields),
/* harmony export */   getGraphFrame: () => (/* binding */ getGraphFrame),
/* harmony export */   getNodeFields: () => (/* binding */ getNodeFields),
/* harmony export */   getNodeGraphDataFrames: () => (/* binding */ getNodeGraphDataFrames),
/* harmony export */   graphBounds: () => (/* binding */ graphBounds),
/* harmony export */   makeEdgesDataFrame: () => (/* binding */ makeEdgesDataFrame),
/* harmony export */   makeNodesDataFrame: () => (/* binding */ makeNodesDataFrame),
/* harmony export */   processNodes: () => (/* binding */ processNodes),
/* harmony export */   shortenLine: () => (/* binding */ shortenLine),
/* harmony export */   statToString: () => (/* binding */ statToString)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/dataframe/FieldCache.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/utils/nodeGraph.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/types/dataFrame.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-data/src/types/fieldColor.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/dataframe/MutableDataFrame.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/panel/nodeGraph/Node.tsx");



function shortenLine(line, sourceNodeRadius, targetNodeRadius, arrowHeadHeight = 1) {
  const vx = line.x2 - line.x1;
  const vy = line.y2 - line.y1;
  const mag = Math.sqrt(vx * vx + vy * vy);
  const cosine = (line.x2 - line.x1) / mag;
  const sine = (line.y2 - line.y1) / mag;
  const scaledThickness = arrowHeadHeight - arrowHeadHeight / 10;
  return {
    x1: line.x1 + cosine * (sourceNodeRadius + 5),
    y1: line.y1 + sine * (sourceNodeRadius + 5),
    x2: line.x2 - cosine * (targetNodeRadius + 3 + scaledThickness),
    y2: line.y2 - sine * (targetNodeRadius + 3 + scaledThickness)
  };
}
function getNodeFields(nodes) {
  const normalizedFrames = {
    ...nodes,
    fields: nodes.fields.map((field) => ({ ...field, name: field.name.toLowerCase() }))
  };
  const fieldsCache = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldCache(normalizedFrames);
  return {
    id: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.id.toLowerCase()),
    title: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.title.toLowerCase()),
    subTitle: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.subTitle.toLowerCase()),
    mainStat: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),
    secondaryStat: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),
    arc: findFieldsByPrefix(nodes, _grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.arc),
    details: findFieldsByPrefix(nodes, _grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.detail),
    color: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.color),
    icon: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.icon),
    nodeRadius: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.nodeRadius.toLowerCase()),
    highlighted: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.highlighted.toLowerCase()),
    fixedX: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.fixedX.toLowerCase()),
    fixedY: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.fixedY.toLowerCase())
  };
}
function getEdgeFields(edges) {
  const normalizedFrames = {
    ...edges,
    fields: edges.fields.map((field) => ({ ...field, name: field.name.toLowerCase() }))
  };
  const fieldsCache = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldCache(normalizedFrames);
  return {
    id: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.id.toLowerCase()),
    source: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.source.toLowerCase()),
    target: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.target.toLowerCase()),
    mainStat: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),
    secondaryStat: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),
    details: findFieldsByPrefix(edges, _grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.detail.toLowerCase()),
    // @deprecated -- for edges use color instead
    highlighted: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.highlighted.toLowerCase()),
    thickness: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.thickness.toLowerCase()),
    color: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.color.toLowerCase()),
    strokeDasharray: fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.strokeDasharray.toLowerCase())
  };
}
function findFieldsByPrefix(frame, prefix) {
  return frame.fields.filter((f) => f.name.match(new RegExp("^" + prefix)));
}
function processNodes(nodes, edges) {
  var _a, _b;
  if (!(edges || nodes)) {
    return { nodes: [], edges: [] };
  }
  if (nodes) {
    const nodeFields = getNodeFields(nodes);
    if (!nodeFields.id) {
      throw new Error("id field is required for nodes data frame.");
    }
    const hasFixedPositions = nodeFields.fixedX && nodeFields.fixedX.values.every((v) => Number.isFinite(v)) && nodeFields.fixedY && nodeFields.fixedY.values.every((v) => Number.isFinite(v));
    if (!hasFixedPositions) {
      const somePosFilled = nodeFields.fixedX && nodeFields.fixedX.values.some((v) => Number.isFinite(v)) || nodeFields.fixedY && nodeFields.fixedY.values.some((v) => Number.isFinite(v));
      if (somePosFilled) {
        throw new Error("If fixedX and fixedY fields are present, the values have to be all filled and valid");
      }
    }
    const nodesMap = {};
    for (let i = 0; i < nodeFields.id.values.length; i++) {
      const id = nodeFields.id.values[i];
      nodesMap[id] = makeNodeDatum(id, nodeFields, i);
    }
    let edgeDatums = edges ? processEdges(edges, getEdgeFields(edges), nodesMap) : [];
    for (const e of edgeDatums) {
      nodesMap[e.target].incoming++;
    }
    return {
      nodes: Object.values(nodesMap),
      edges: edgeDatums,
      hasFixedPositions,
      legend: nodeFields.arc.map((f) => {
        var _a2, _b2;
        return {
          color: (_b2 = (_a2 = f.config.color) == null ? void 0 : _a2.fixedColor) != null ? _b2 : "",
          name: f.config.displayName || f.name
        };
      })
    };
  } else {
    edges = edges;
    const nodesMap = {};
    const edgeFields = getEdgeFields(edges);
    for (let i = 0; i < edges.length; i++) {
      const { source, target } = makeNodeDatumsFromEdge(edgeFields, i);
      nodesMap[target.id] = nodesMap[target.id] || target;
      nodesMap[source.id] = nodesMap[source.id] || source;
      if (computableField(edgeFields.mainStat)) {
        nodesMap[target.id].mainStatNumeric = ((_a = nodesMap[target.id].mainStatNumeric) != null ? _a : 0) + edgeFields.mainStat.values[i];
      }
      if (computableField(edgeFields.secondaryStat)) {
        nodesMap[target.id].secondaryStatNumeric = ((_b = nodesMap[target.id].secondaryStatNumeric) != null ? _b : 0) + edgeFields.secondaryStat.values[i];
      }
      nodesMap[target.id].incoming++;
    }
    let edgeDatums = processEdges(edges, edgeFields, nodesMap);
    const nodes2 = normalizeStatsForNodes(nodesMap, edgeFields);
    return {
      nodes: nodes2,
      edges: edgeDatums,
      // Edge-only datasets never have fixedX/fixedY
      hasFixedPositions: false
    };
  }
}
function processEdges(edges, edgeFields, nodesMap) {
  if (!edgeFields.id) {
    throw new Error("id field is required for edges data frame.");
  }
  return edgeFields.id.values.map((id, index) => {
    var _a, _b, _c, _d, _e, _f;
    const target = (_a = edgeFields.target) == null ? void 0 : _a.values[index];
    const source = (_b = edgeFields.source) == null ? void 0 : _b.values[index];
    const sourceNode = nodesMap[source];
    const targetNode = nodesMap[target];
    return {
      id,
      dataFrameRowIndex: index,
      source,
      target,
      sourceNodeRadius: !sourceNode.nodeRadius ? _Node__WEBPACK_IMPORTED_MODULE_0__.nodeR : sourceNode.nodeRadius.values[sourceNode.dataFrameRowIndex],
      targetNodeRadius: !targetNode.nodeRadius ? _Node__WEBPACK_IMPORTED_MODULE_0__.nodeR : targetNode.nodeRadius.values[targetNode.dataFrameRowIndex],
      mainStat: edgeFields.mainStat ? statToString(edgeFields.mainStat.config, edgeFields.mainStat.values[index]) : "",
      secondaryStat: edgeFields.secondaryStat ? statToString(edgeFields.secondaryStat.config, edgeFields.secondaryStat.values[index]) : "",
      // @deprecated -- for edges use color instead
      highlighted: ((_c = edgeFields.highlighted) == null ? void 0 : _c.values[index]) || false,
      thickness: ((_d = edgeFields.thickness) == null ? void 0 : _d.values[index]) || 1,
      color: (_e = edgeFields.color) == null ? void 0 : _e.values[index],
      strokeDasharray: (_f = edgeFields.strokeDasharray) == null ? void 0 : _f.values[index]
    };
  });
}
function computableField(field) {
  return field && field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number;
}
function normalizeStatsForNodes(nodesMap, edgeFields) {
  const secondaryStatValues = [];
  const mainStatValues = [];
  const secondaryStatField = computableField(edgeFields.secondaryStat) ? {
    ...edgeFields.secondaryStat,
    values: secondaryStatValues
  } : void 0;
  const mainStatField = computableField(edgeFields.mainStat) ? {
    ...edgeFields.mainStat,
    values: mainStatValues
  } : void 0;
  return Object.values(nodesMap).map((node, index) => {
    if (mainStatField || secondaryStatField) {
      const newNode = {
        ...node
      };
      if (mainStatField) {
        newNode.mainStat = mainStatField;
        mainStatValues.push(node.mainStatNumeric);
        newNode.dataFrameRowIndex = index;
      }
      if (secondaryStatField) {
        newNode.secondaryStat = secondaryStatField;
        secondaryStatValues.push(node.secondaryStatNumeric);
        newNode.dataFrameRowIndex = index;
      }
      return newNode;
    }
    return node;
  });
}
function makeNodeDatumsFromEdge(edgeFields, index) {
  var _a, _b;
  const targetId = (_a = edgeFields.target) == null ? void 0 : _a.values[index];
  const sourceId = (_b = edgeFields.source) == null ? void 0 : _b.values[index];
  return {
    target: makeSimpleNodeDatum(targetId, index),
    source: makeSimpleNodeDatum(sourceId, index)
  };
}
function makeSimpleNodeDatum(name, index) {
  return {
    id: name,
    title: name,
    subTitle: "",
    dataFrameRowIndex: index,
    incoming: 0,
    arcSections: [],
    highlighted: false
  };
}
function makeNodeDatum(id, nodeFields, index) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return {
    id,
    title: ((_a = nodeFields.title) == null ? void 0 : _a.values[index]) || "",
    subTitle: ((_b = nodeFields.subTitle) == null ? void 0 : _b.values[index]) || "",
    dataFrameRowIndex: index,
    incoming: 0,
    mainStat: nodeFields.mainStat,
    secondaryStat: nodeFields.secondaryStat,
    arcSections: nodeFields.arc,
    color: nodeFields.color,
    icon: ((_c = nodeFields.icon) == null ? void 0 : _c.values[index]) || "",
    nodeRadius: nodeFields.nodeRadius,
    highlighted: ((_d = nodeFields.highlighted) == null ? void 0 : _d.values[index]) || false,
    x: (_f = (_e = nodeFields.fixedX) == null ? void 0 : _e.values[index]) != null ? _f : void 0,
    y: (_h = (_g = nodeFields.fixedY) == null ? void 0 : _g.values[index]) != null ? _h : void 0
  };
}
function statToString(config, value) {
  if (typeof value === "string") {
    return value;
  } else {
    const decimals = config.decimals || 2;
    if (Number.isFinite(value)) {
      return value.toFixed(decimals) + (config.unit ? " " + config.unit : "");
    } else {
      return "";
    }
  }
}
function makeNodesDataFrame(count) {
  const frame = nodesFrame();
  for (let i = 0; i < count; i++) {
    frame.add(makeNode(i));
  }
  return frame;
}
function makeNode(index) {
  return {
    id: index.toString(),
    title: "service:".concat(index),
    subtitle: "service",
    arc__success: 0.5,
    arc__errors: 0.5,
    mainstat: 0.1,
    secondarystat: 2,
    color: 0.5,
    icon: "database",
    noderadius: 40
  };
}
function nodesFrame() {
  const fields = {
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.id]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.title]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.subTitle]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.mainStat]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.secondaryStat]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.arc + "success"]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number,
      config: { color: { mode: _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldColorModeId.Fixed, fixedColor: "green" } }
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.arc + "errors"]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number,
      config: { color: { mode: _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldColorModeId.Fixed, fixedColor: "red" } }
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.color]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number,
      config: { color: { mode: _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldColorModeId.ContinuousGrYlRd } }
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.icon]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.nodeRadius]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number
    }
  };
  return new _grafana_data__WEBPACK_IMPORTED_MODULE_5__.MutableDataFrame({
    name: "nodes",
    fields: Object.entries(fields).map(([key, value]) => ({
      ...value,
      name: key
    }))
  });
}
function makeEdgesDataFrame(edges) {
  const frame = edgesFrame();
  for (const edge of edges) {
    frame.add({
      id: edge.source + "--" + edge.target,
      ...edge
    });
  }
  return frame;
}
function edgesFrame() {
  const fields = {
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.id]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.source]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.target]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.mainStat]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number
    },
    [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.secondaryStat]: {
      values: [],
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.number
    }
  };
  return new _grafana_data__WEBPACK_IMPORTED_MODULE_5__.MutableDataFrame({
    name: "edges",
    fields: Object.entries(fields).map(([key, value]) => ({
      ...value,
      name: key
    }))
  });
}
function graphBounds(nodes) {
  if (nodes.length === 0) {
    return { top: 0, right: 0, bottom: 0, left: 0, center: { x: 0, y: 0 } };
  }
  const bounds = nodes.reduce(
    (acc, node) => {
      if (node.x > acc.right) {
        acc.right = node.x;
      }
      if (node.x < acc.left) {
        acc.left = node.x;
      }
      if (node.y > acc.bottom) {
        acc.bottom = node.y;
      }
      if (node.y < acc.top) {
        acc.top = node.y;
      }
      return acc;
    },
    { top: Infinity, right: -Infinity, bottom: -Infinity, left: Infinity }
  );
  const y = bounds.top + (bounds.bottom - bounds.top) / 2;
  const x = bounds.left + (bounds.right - bounds.left) / 2;
  return {
    ...bounds,
    center: {
      x,
      y
    }
  };
}
function getNodeGraphDataFrames(frames, options) {
  let nodeGraphFrames = frames.filter((frame) => {
    var _a;
    if (((_a = frame.meta) == null ? void 0 : _a.preferredVisualisationType) === "nodeGraph") {
      return true;
    }
    if (frame.name === "nodes" || frame.name === "edges" || frame.refId === "nodes" || frame.refId === "edges") {
      return true;
    }
    const fieldsCache = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldCache(frame);
    if (fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.id)) {
      return true;
    }
    return false;
  });
  if (options) {
    nodeGraphFrames = applyOptionsToFrames(nodeGraphFrames, options);
  }
  return nodeGraphFrames;
}
const applyOptionsToFrames = (frames, options) => {
  return frames.map((frame) => {
    var _a, _b, _c, _d, _e, _f;
    const fieldsCache = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldCache(frame);
    if (fieldsCache.getFieldByName(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.source.toLowerCase())) {
      if ((_a = options == null ? void 0 : options.edges) == null ? void 0 : _a.mainStatUnit) {
        const field = frame.fields.find((field2) => field2.name.toLowerCase() === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.mainStat);
        if (field) {
          field.config = { ...field.config, unit: options.edges.mainStatUnit };
        }
      }
      if ((_b = options == null ? void 0 : options.edges) == null ? void 0 : _b.secondaryStatUnit) {
        const field = frame.fields.find(
          (field2) => field2.name.toLowerCase() === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.secondaryStat
        );
        if (field) {
          field.config = { ...field.config, unit: options.edges.secondaryStatUnit };
        }
      }
    } else {
      if ((_c = options == null ? void 0 : options.nodes) == null ? void 0 : _c.mainStatUnit) {
        const field = frame.fields.find((field2) => field2.name.toLowerCase() === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.mainStat);
        if (field) {
          field.config = { ...field.config, unit: options.nodes.mainStatUnit };
        }
      }
      if ((_d = options == null ? void 0 : options.nodes) == null ? void 0 : _d.secondaryStatUnit) {
        const field = frame.fields.find(
          (field2) => field2.name.toLowerCase() === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.NodeGraphDataFrameFieldNames.secondaryStat
        );
        if (field) {
          field.config = { ...field.config, unit: options.nodes.secondaryStatUnit };
        }
      }
      if ((_f = (_e = options == null ? void 0 : options.nodes) == null ? void 0 : _e.arcs) == null ? void 0 : _f.length) {
        for (const arc of options.nodes.arcs) {
          const field = frame.fields.find((field2) => {
            var _a2;
            return field2.name.toLowerCase() === ((_a2 = arc.field) == null ? void 0 : _a2.toLowerCase());
          });
          if (field && arc.color) {
            field.config = { ...field.config, color: { fixedColor: arc.color, mode: _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldColorModeId.Fixed } };
          }
        }
      }
    }
    return frame;
  });
};
const findConnectedNodesForEdge = (nodes, edges, edgeId) => {
  const edge = edges.find((edge2) => edge2.id === edgeId);
  if (edge) {
    return [
      ...new Set(nodes.filter((node) => edge.source === node.id || edge.target === node.id).map((node) => node.id))
    ];
  }
  return [];
};
const findConnectedNodesForNode = (nodes, edges, nodeId) => {
  const node = nodes.find((node2) => node2.id === nodeId);
  if (node) {
    const linkedEdges = edges.filter((edge) => edge.source === node.id || edge.target === node.id);
    return [
      ...new Set(
        linkedEdges.flatMap(
          (edge) => nodes.filter((n) => edge.source === n.id || edge.target === n.id).map((n) => n.id)
        )
      )
    ];
  }
  return [];
};
const getGraphFrame = (frames) => {
  return frames.reduce(
    (acc, frame) => {
      const sourceField = frame.fields.filter((f) => f.name === "source");
      if (frame.name === "edges" || sourceField.length) {
        acc.edges.push(frame);
      } else {
        acc.nodes.push(frame);
      }
      return acc;
    },
    { edges: [], nodes: [] }
  );
};


/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/***/ (function(module) {

!function(t,i){ true?module.exports=i():0}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "./node_modules/ol-ext/dist/ol-ext.css":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_ol_ext_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/css-loader/dist/cjs.js!./node_modules/ol-ext/dist/ol-ext.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ol_ext_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ol_ext_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_ol_ext_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_ol_ext_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/ol/ol.css":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_ol_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/css-loader/dist/cjs.js!./node_modules/ol/ol.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ol_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ol_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_ol_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_ol_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAACE1BMVEX///8A//8AgICA//8AVVVAQID///8rVVVJtttgv98nTmJ2xNgkW1ttyNsmWWZmzNZYxM4gWGgeU2JmzNNr0N1Rwc0eU2VXxdEhV2JqytQeVmMhVmNoydUfVGUgVGQfVGQfVmVqy9hqy9dWw9AfVWRpydVry9YhVmMgVGNUw9BrytchVWRexdGw294gVWQgVmUhVWPd4N6HoaZsy9cfVmQgVGRrytZsy9cgVWQgVWMgVWRsy9YfVWNsy9YgVWVty9YgVWVry9UgVWRsy9Zsy9UfVWRsy9YgVWVty9YgVWRty9Vsy9aM09sgVWRTws/AzM0gVWRtzNYgVWRuy9Zsy9cgVWRGcHxty9bb5ORbxdEgVWRty9bn6OZTws9mydRfxtLX3Nva5eRix9NFcXxOd4JPeINQeIMiVmVUws9Vws9Vw9BXw9BYxNBaxNBbxNBcxdJexdElWWgmWmhjyNRlx9IqXGtoipNpytVqytVryNNrytZsjZUuX210k5t1y9R2zNR3y9V4lp57zth9zdaAnKOGoaeK0NiNpquV09mesrag1tuitbmj1tuj19uktrqr2d2svcCu2d2xwMO63N+7x8nA3uDC3uDFz9DK4eHL4eLN4eIyYnDX5OM5Z3Tb397e4uDf4uHf5uXi5ePi5+Xj5+Xk5+Xm5+Xm6OY6aHXQ19fT4+NfhI1Ww89gx9Nhx9Nsy9ZWw9Dpj2abAAAAWnRSTlMAAQICAwQEBgcIDQ0ODhQZGiAiIyYpKywvNTs+QklPUlNUWWJjaGt0dnd+hIWFh4mNjZCSm6CpsbW2t7nDzNDT1dje5efr7PHy9PT29/j4+Pn5+vr8/f39/f6DPtKwAAABTklEQVR4Xr3QVWPbMBSAUTVFZmZmhhSXMjNvkhwqMzMzMzPDeD+xASvObKePPa+ffHVl8PlsnE0+qPpBuQjVJjno6pZpSKXYl7/bZyFaQxhf98hHDKEppwdWIW1frFnrxSOWHFfWesSEWC6R/P4zOFrix3TzDFLlXRTR8c0fEEJ1/itpo7SVO9Jdr1DVxZ0USyjZsEY5vZfiiAC0UoTGOrm9PZLuRl8X+Dq1HQtoFbJZbv61i+Poblh/97TC7n0neCcK0ETNUrz1/xPHf+DNAW9Ac6t8O8WH3Vp98f5lCaYKAOFZMLyHL4Y0fe319idMNgMMp+zWVSybUed/+/h7I4wRAG1W6XDy4XmjR9HnzvDRZXUAYDFOhC1S/Hh+fIXxen+eO+AKqbs+wAo30zDTDvDxKoJN88sjUzDFAvBzEUGFsnADoIvAJzoh2BZ8sner+Ke/vwECuQAAAABJRU5ErkJggg==":
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAACE1BMVEX///8A//8AgICA//8AVVVAQID///8rVVVJtttgv98nTmJ2xNgkW1ttyNsmWWZmzNZYxM4gWGgeU2JmzNNr0N1Rwc0eU2VXxdEhV2JqytQeVmMhVmNoydUfVGUgVGQfVGQfVmVqy9hqy9dWw9AfVWRpydVry9YhVmMgVGNUw9BrytchVWRexdGw294gVWQgVmUhVWPd4N6HoaZsy9cfVmQgVGRrytZsy9cgVWQgVWMgVWRsy9YfVWNsy9YgVWVty9YgVWVry9UgVWRsy9Zsy9UfVWRsy9YgVWVty9YgVWRty9Vsy9aM09sgVWRTws/AzM0gVWRtzNYgVWRuy9Zsy9cgVWRGcHxty9bb5ORbxdEgVWRty9bn6OZTws9mydRfxtLX3Nva5eRix9NFcXxOd4JPeINQeIMiVmVUws9Vws9Vw9BXw9BYxNBaxNBbxNBcxdJexdElWWgmWmhjyNRlx9IqXGtoipNpytVqytVryNNrytZsjZUuX210k5t1y9R2zNR3y9V4lp57zth9zdaAnKOGoaeK0NiNpquV09mesrag1tuitbmj1tuj19uktrqr2d2svcCu2d2xwMO63N+7x8nA3uDC3uDFz9DK4eHL4eLN4eIyYnDX5OM5Z3Tb397e4uDf4uHf5uXi5ePi5+Xj5+Xk5+Xm5+Xm6OY6aHXQ19fT4+NfhI1Ww89gx9Nhx9Nsy9ZWw9Dpj2abAAAAWnRSTlMAAQICAwQEBgcIDQ0ODhQZGiAiIyYpKywvNTs+QklPUlNUWWJjaGt0dnd+hIWFh4mNjZCSm6CpsbW2t7nDzNDT1dje5efr7PHy9PT29/j4+Pn5+vr8/f39/f6DPtKwAAABTklEQVR4Xr3QVWPbMBSAUTVFZmZmhhSXMjNvkhwqMzMzMzPDeD+xASvObKePPa+ffHVl8PlsnE0+qPpBuQjVJjno6pZpSKXYl7/bZyFaQxhf98hHDKEppwdWIW1frFnrxSOWHFfWesSEWC6R/P4zOFrix3TzDFLlXRTR8c0fEEJ1/itpo7SVO9Jdr1DVxZ0USyjZsEY5vZfiiAC0UoTGOrm9PZLuRl8X+Dq1HQtoFbJZbv61i+Poblh/97TC7n0neCcK0ETNUrz1/xPHf+DNAW9Ac6t8O8WH3Vp98f5lCaYKAOFZMLyHL4Y0fe319idMNgMMp+zWVSybUed/+/h7I4wRAG1W6XDy4XmjR9HnzvDRZXUAYDFOhC1S/Hh+fIXxen+eO+AKqbs+wAo30zDTDvDxKoJN88sjUzDFAvBzEUGFsnADoIvAJzoh2BZ8sner+Ke/vwECuQAAAABJRU5ErkJggg==";

/***/ }),

/***/ "./node_modules/ol-ext/geom/GeomUtils.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extentIntersection: () => (/* binding */ ol_extent_intersection),
/* harmony export */   ol_coordinate_dist2d: () => (/* binding */ ol_coordinate_dist2d),
/* harmony export */   ol_coordinate_equal: () => (/* binding */ ol_coordinate_equal),
/* harmony export */   ol_coordinate_findSegment: () => (/* binding */ ol_coordinate_findSegment),
/* harmony export */   ol_coordinate_getFeatureCenter: () => (/* binding */ ol_coordinate_getFeatureCenter),
/* harmony export */   ol_coordinate_getGeomCenter: () => (/* binding */ ol_coordinate_getGeomCenter),
/* harmony export */   ol_coordinate_getIntersectionPoint: () => (/* binding */ ol_coordinate_getIntersectionPoint),
/* harmony export */   ol_coordinate_offsetCoords: () => (/* binding */ ol_coordinate_offsetCoords),
/* harmony export */   ol_coordinate_sampleAt: () => (/* binding */ ol_coordinate_sampleAt),
/* harmony export */   ol_coordinate_splitH: () => (/* binding */ ol_coordinate_splitH),
/* harmony export */   ol_extent_intersection: () => (/* binding */ ol_extent_intersection),
/* harmony export */   ol_geom_createFromType: () => (/* binding */ ol_geom_createFromType)
/* harmony export */ });
/* harmony import */ var ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var ol_geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/geom/LinearRing.js");
/* harmony import */ var ol_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var ol_geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var ol_geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/geom/Polygon.js");
/* harmony import */ var ol_geom_Circle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/geom/Circle.js");
/* harmony import */ var ol_extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/extent.js");
/*	Copyright (c) 2016 Jean-Marc VIGLINO, 
  released under the CeCILL-B license (French BSD license)
  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).

  Usefull function to handle geometric operations
*/












/** Distance beetween 2 points
 *	Usefull geometric functions
 * @param {ol.Coordinate} p1 first point
 * @param {ol.Coordinate} p2 second point
 * @return {number} distance
 */
var ol_coordinate_dist2d = function(p1, p2) {
  var dx = p1[0]-p2[0];
  var dy = p1[1]-p2[1];
  return Math.sqrt(dx*dx+dy*dy);
}

/** 2 points are equal
 *	Usefull geometric functions
 * @param {ol.Coordinate} p1 first point
 * @param {ol.Coordinate} p2 second point
 * @return {boolean}
 */
var ol_coordinate_equal = function(p1, p2) {
  return (p1[0]==p2[0] && p1[1]==p2[1]);
}

/** Get center coordinate of a feature
 * @param {ol.Feature} f
 * @return {ol.coordinate} the center
 */
var ol_coordinate_getFeatureCenter = function(f) {
  return ol_coordinate_getGeomCenter (f.getGeometry());
};

/** Get center coordinate of a geometry
* @param {ol.geom.Geometry} geom
* @return {ol.Coordinate} the center
*/
var ol_coordinate_getGeomCenter = function(geom) {
  switch (geom.getType()) {
    case 'Point': 
      return geom.getCoordinates();
    case "MultiPolygon":
      geom = geom.getPolygon(0);
      // fallthrough
    case "Polygon":
      return geom.getInteriorPoint().getCoordinates();
    default:
      return geom.getClosestPoint((0,ol_extent_js__WEBPACK_IMPORTED_MODULE_0__.getCenter)(geom.getExtent()));
  }
};

/** Offset a polyline
 * @param {Array<ol.Coordinate>} coords
 * @param {number} offset
 * @return {Array<ol.Coordinate>} resulting coord
 * @see http://stackoverflow.com/a/11970006/796832
 * @see https://drive.google.com/viewerng/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxqa2dhZGdldHN0b3JlfGd4OjQ4MzI5M2Y0MjNmNzI2MjY
 */
var ol_coordinate_offsetCoords = function (coords, offset) {
  var path = [];
  var N = coords.length-1;
  var max = N;
  var mi, mi1, li, li1, ri, ri1, si, si1, Xi1, Yi1;
  var p0, p1, p2;
  var isClosed = ol_coordinate_equal(coords[0],coords[N]);
  if (!isClosed) {
    p0 = coords[0];
    p1 = coords[1];
    p2 = [
      p0[0] + (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,
      p0[1] - (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset
    ];
    path.push(p2);
    coords.push(coords[N])
    N++;
    max--;
  }
  for (var i = 0; i < max; i++) {
    p0 = coords[i];
    p1 = coords[(i+1) % N];
    p2 = coords[(i+2) % N];

    mi = (p1[1] - p0[1])/(p1[0] - p0[0]);
    mi1 = (p2[1] - p1[1])/(p2[0] - p1[0]);
    // Prevent alignements
    if (Math.abs(mi-mi1) > 1e-10) {
      li = Math.sqrt((p1[0] - p0[0])*(p1[0] - p0[0])+(p1[1] - p0[1])*(p1[1] - p0[1]));
      li1 = Math.sqrt((p2[0] - p1[0])*(p2[0] - p1[0])+(p2[1] - p1[1])*(p2[1] - p1[1]));
      ri = p0[0] + offset*(p1[1] - p0[1])/li;
      ri1 = p1[0] + offset*(p2[1] - p1[1])/li1;
      si = p0[1] - offset*(p1[0] - p0[0])/li;
      si1 = p1[1] - offset*(p2[0] - p1[0])/li1;
      Xi1 = (mi1*ri1-mi*ri+si-si1) / (mi1-mi);
      Yi1 = (mi*mi1*(ri1-ri)+mi1*si-mi*si1) / (mi1-mi);

      // Correction for vertical lines
      if(p1[0] - p0[0] == 0) {
        Xi1 = p1[0] + offset*(p1[1] - p0[1])/Math.abs(p1[1] - p0[1]);
        Yi1 = mi1*Xi1 - mi1*ri1 + si1;
      }
      if (p2[0] - p1[0] == 0 ) {
        Xi1 = p2[0] + offset*(p2[1] - p1[1])/Math.abs(p2[1] - p1[1]);
        Yi1 = mi*Xi1 - mi*ri + si;
      }

      path.push([Xi1, Yi1]);
    }
  }
  if (isClosed) {
    path.push(path[0]);
  } else {
    coords.pop();
    p0 = coords[coords.length-1];
    p1 = coords[coords.length-2];
    p2 = [
      p0[0] - (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,
      p0[1] + (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset
    ];
    path.push(p2);
  }
  return path;
}

/** Find the segment a point belongs to
 * @param {ol.Coordinate} pt
 * @param {Array<ol.Coordinate>} coords
 * @return {} the index (-1 if not found) and the segment
 */
var ol_coordinate_findSegment = function (pt, coords) {
  for (var i=0; i<coords.length-1; i++) {
    var p0 = coords[i];
    var p1 = coords[i+1];
    if (ol_coordinate_equal(pt, p0) || ol_coordinate_equal(pt, p1)) {
      return { index:1, segment: [p0,p1] };
    } else {
      var d0 = ol_coordinate_dist2d(p0,p1);
      var v0 = [ (p1[0] - p0[0]) / d0, (p1[1] - p0[1]) / d0 ];
      var d1 = ol_coordinate_dist2d(p0,pt);
      var v1 = [ (pt[0] - p0[0]) / d1, (pt[1] - p0[1]) / d1 ];
      if (Math.abs(v0[0]*v1[1] - v0[1]*v1[0]) < 1e-10) {
        return { index:1, segment: [p0,p1] };
      }
    }
  }
  return { index: -1 };
};

/**
 * Split a Polygon geom with horizontal lines
 * @param {Array<ol.Coordinate>} geom
 * @param {number} y the y to split
 * @param {number} n contour index
 * @return {Array<Array<ol.Coordinate>>}
 */
var ol_coordinate_splitH = function (geom, y, n) {
  var x, abs;
  var list = [];
  for (var i=0; i<geom.length-1; i++) {
    // Hole separator?
    if (!geom[i].length || !geom[i+1].length) continue;
    // Intersect
    if (geom[i][1]<=y && geom[i+1][1]>y || geom[i][1]>=y && geom[i+1][1]<y) {
      abs = (y-geom[i][1]) / (geom[i+1][1]-geom[i][1]);
      x = abs * (geom[i+1][0]-geom[i][0]) + geom[i][0];
      list.push ({ contour: n, index: i, pt: [x,y], abs: abs });
    }
  }
  // Sort x
  list.sort(function(a,b) { return a.pt[0] - b.pt[0] });
  // Horizontal segment
  var result = [];
  for (var j=0; j<list.length-1; j += 2) {
    result.push([list[j], list[j+1]])
  }
  return result;
};

/** Create a geometry given a type and coordinates */
var ol_geom_createFromType = function (type, coordinates) {
  switch (type) {
    case 'LineString': return new ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"](coordinates);
    case 'LinearRing': return new ol_geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_2__["default"](coordinates);
    case 'MultiLineString': return new ol_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](coordinates);
    case 'MultiPoint': return new ol_geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__["default"](coordinates);
    case 'MultiPolygon': return new ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](coordinates);
    case 'Point': return new ol_geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"](coordinates);
    case 'Polygon': return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"](coordinates);
    default:
      console.error('[createFromType] Unsupported type: '+type);
      return null;
  }
};




/** Intersect 2 lines
 * @param {Arrar<ol.coordinate>} d1
 * @param {Arrar<ol.coordinate>} d2
 */
var ol_coordinate_getIntersectionPoint = function (d1, d2) {
  var d1x = d1[1][0] - d1[0][0];
  var d1y = d1[1][1] - d1[0][1];
  var d2x = d2[1][0] - d2[0][0];
  var d2y = d2[1][1] - d2[0][1];
  var det = d1x * d2y - d1y * d2x;
  if (det != 0) {
    var k = (d1x * d1[0][1] - d1x * d2[0][1] - d1y * d1[0][0] + d1y * d2[0][0]) / det;
    return [d2[0][0] + k*d2x, d2[0][1] + k*d2y];
  } else {
    return false;
  }
};



var ol_extent_intersection;

(function() {
// Split at x
function splitX(pts, x) {
  var pt;
  for (let i=pts.length-1; i>0; i--) {
    if ((pts[i][0]>x && pts[i-1][0]<x) || (pts[i][0]<x && pts[i-1][0]>x)) {
      pt = [ x, (x - pts[i][0]) / (pts[i-1][0]-pts[i][0]) * (pts[i-1][1]-pts[i][1]) + pts[i][1]];
      pts.splice(i, 0, pt);
    }
  }
}
// Split at y
function splitY(pts, y) {
  var pt;
  for (let i=pts.length-1; i>0; i--) {
    if ((pts[i][1]>y && pts[i-1][1]<y) || (pts[i][1]<y && pts[i-1][1]>y)) {
      pt = [ (y - pts[i][1]) / (pts[i-1][1]-pts[i][1]) * (pts[i-1][0]-pts[i][0]) + pts[i][0], y];
      pts.splice(i, 0, pt);
    }
  }
}

/** Fast polygon intersection with an extent (used for area calculation)
 * @param {ol_extent_Extent} extent
 * @param {ol_geom_Polygon|ol_geom_MultiPolygon} polygon
 * @returns {ol_geom_Polygon|ol_geom_MultiPolygon|null} return null if not a polygon geometry
 */
ol_extent_intersection = function(extent, polygon) {
  var poly = (polygon.getType() === 'Polygon');
  if (!poly && polygon.getType() !== 'MultiPolygon') return null;
  var geom = polygon.getCoordinates();
  if (poly) geom = [geom];
  geom.forEach(function(g) {
    g.forEach(function(c) {
      splitX(c, extent[0]);
      splitX(c, extent[2]);
      splitY(c, extent[1]);
      splitY(c, extent[3]);
    });
  })
  // Snap geom to the extent 
  geom.forEach(function(g) {
    g.forEach(function(c) {
      c.forEach(function(p) {
        if (p[0]<extent[0]) p[0] = extent[0];
        else if (p[0]>extent[2]) p[0] = extent[2];
        if (p[1]<extent[1]) p[1] = extent[1];
        else if (p[1]>extent[3]) p[1] = extent[3];
      })
    })
  })
  if (poly) {
    return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"](geom[0]);
  } else {
    return new ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](geom);
  }
};
})();




/** Add points along a segment
 * @param {ol_Coordinate} p1 
 * @param {ol_Coordinate} p2 
 * @param {number} d 
 * @param {boolean} start include starting point, default true
 * @returns {Array<ol_Coordinate>}
 */
var ol_coordinate_sampleAt = function(p1, p2, d, start) {
  var pts = [];
  if (start!==false) pts.push(p1);
  var dl = ol_coordinate_dist2d(p1,p2);
  if (dl) {
    var nb = Math.round(dl/d);
    if (nb>1) {
      var dx = (p2[0]-p1[0]) / nb;
      var dy = (p2[1]-p1[1]) / nb;
      for (var i=1; i<nb; i++) {
        pts.push([p1[0] + dx*i, p1[1] + dy*i])
      }
    }
  }
  pts.push(p2);
  return pts;
};


/** Sample a LineString at a distance
 * @param {number} d
 * @returns {ol_geom_LineString}
 */
ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.sampleAt = function(d) {
  var line = this.getCoordinates();
  var result = [];
  for (var i=1; i<line.length; i++) {
    result = result.concat(ol_coordinate_sampleAt(line[i-1], line[i], d, i===1));
  }
  return new ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"](result);
};

/** Sample a MultiLineString at a distance
 * @param {number} d
 * @returns {ol_geom_MultiLineString}
 */
ol_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.sampleAt = function(d) {
  var lines = this.getCoordinates();
  var result = [];
  lines.forEach(function(p) {
    var l = [];
    for (var i=1; i<p.length; i++) {
      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], d, i===1));
    }
    result.push(l);
  })
  return new ol_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](result);
};

/** Sample a Polygon at a distance
 * @param {number} d
 * @returns {ol_geom_Polygon}
 */
ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"].prototype.sampleAt = function(res) {
  var poly = this.getCoordinates();
  var result = [];
  poly.forEach(function(p) {
    var l = [];
    for (var i=1; i<p.length; i++) {
      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));
    }
    result.push(l);
  })
  return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"](result);
};

/** Sample a MultiPolygon at a distance
 * @param {number} res
 * @returns {ol_geom_MultiPolygon}
 */
ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__["default"].prototype.sampleAt = function(res) {
  var mpoly = this.getCoordinates();
  var result = [];
  mpoly.forEach(function(poly) {
    var a = [];
    result.push(a);
    poly.forEach(function(p) {
      var l = [];
      for (var i=1; i<p.length; i++) {
        l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));
      }
      a.push(l);
    })
  });
  return new ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](result);
};

/** Intersect a geometry using a circle
 * @param {ol_geom_Geometry} geom
 * @param {number} resolution circle resolution to sample the polygon on the circle, default 1
 * @returns {ol_geom_Geometry}
 */
ol_geom_Circle_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.intersection = function(geom, resolution) {
  if (geom.sampleAt) {
    var ext = (0,ol_extent_js__WEBPACK_IMPORTED_MODULE_0__.buffer)(this.getCenter().concat(this.getCenter()), this.getRadius());
    geom = ol_extent_intersection(ext, geom);
    geom = geom.simplify(resolution);
    var c = this.getCenter();
    var r = this.getRadius();
    //var res = (resolution||1) * r / 100;
    var g = geom.sampleAt(resolution).getCoordinates();
    switch (geom.getType()) {
      case 'Polygon': g = [g];
        // fallthrough
      case 'MultiPolygon': {
        var hasout = false;
        // var hasin = false;
        var result = [];
        g.forEach(function(poly) {
          var a = [];
          result.push(a);
          poly.forEach(function(ring) {
            var l = [];
            a.push(l);
            ring.forEach(function(p) {
              var d = ol_coordinate_dist2d(c, p);
              if (d > r) {
                hasout = true;
                l.push([
                  c[0] + r / d * (p[0]-c[0]),
                  c[1] + r / d * (p[1]-c[1])
                ]);
              } else {
                // hasin = true;
                l.push(p);
              }
            });
          })
        });
        if (!hasout) return geom;
        if (geom.getType() === 'Polygon') {
          return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"](result[0]);
        } else {
          return new ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](result);
        }
      }
    }
  } else {
    console.warn('[ol/geom/Circle~intersection] Unsupported geometry type: '+geom.getType());
  }
  return geom;
};


/***/ }),

/***/ "./node_modules/ol-ext/geom/LineStringSplitAt.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol-ext/geom/GeomUtils.js");
/* harmony import */ var ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/geom/LineString.js");



/** Split a lineString by a point or a list of points
 *	NB: points must be on the line, use getClosestPoint() to get one
 * @param {ol.Coordinate | Array<ol.Coordinate>} pt points to split the line
 * @param {Number} tol distance tolerance for 2 points to be equal
 */
ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.splitAt = function(pt, tol) {
  var i;
  if (!pt) return [this];
    if (!tol) tol = 1e-10;
    // Test if list of points
    if (pt.length && pt[0].length) {
      var result = [this];
      for (i=0; i<pt.length; i++) {
        var r = [];
        for (var k=0; k<result.length; k++) {
          var ri = result[k].splitAt(pt[i], tol);
          r = r.concat(ri);
        }
        result = r;
      }
      return result;
    }
    // Nothing to do
    if ((0,_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_equal)(pt,this.getFirstCoordinate())
    || (0,_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_equal)(pt,this.getLastCoordinate())) {
      return [this];
    }
    // Get
    var c0 = this.getCoordinates();
    var ci=[c0[0]];
    var c = [];
    for (i=0; i<c0.length-1; i++) {
      // Filter equal points
      if ((0,_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_equal)(c0[i],c0[i+1])) continue;
      // Extremity found
      if ((0,_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_equal)(pt,c0[i+1])) {
        ci.push(c0[i+1]);
        c.push(new ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"](ci));
        ci = [];
      }
      // Test alignement
      else if (!(0,_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_equal)(pt,c0[i])) {
        var d1, d2, split=false;
        if (c0[i][0] == c0[i+1][0]) {
          d1 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);
          split = (c0[i][0] == pt[0]) && (0 < d1 && d1 <= 1)
        } else if (c0[i][1] == c0[i+1][1]) {
          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);
          split = (c0[i][1] == pt[1]) && (0 < d1 && d1 <= 1)
        } else {
          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);
          d2 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);
          split = (Math.abs(d1-d2) <= tol && 0 < d1 && d1 <= 1)
        }
        // pt is inside the segment > split
        if (split) {
          ci.push(pt);
          c.push (new ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"](ci));
          ci = [pt];
        }
      }
      ci.push(c0[i+1]);
    }
    if (ci.length>1) c.push (new ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"](ci));
    if (c.length) return c;
    else return [this];
}

// import('ol-ext/geom/LineStringSplitAt')

/***/ }),

/***/ "./node_modules/ol-ext/source/DayNight.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/geom/Polygon.js");
/* harmony import */ var ol_Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var ol_loadingstrategy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/loadingstrategy.js");
/*	Copyright (c) 2018 Jean-Marc VIGLINO, 
  released under the CeCILL-B license (French BSD license)
  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).
*/






/** DayNight source: a source to display day/night on a map
 * @constructor 
 * @extends {ol.source.Vector}
 * @param {any} options Vector source options
 *  @param {string|Date} time source date time
 *  @param {number} step step in degree for coordinate precision
 */
var ol_source_DayNight = class olsourceDayNight extends ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(options) {
    options = options || {};
    options.strategy = ol_loadingstrategy_js__WEBPACK_IMPORTED_MODULE_1__.all;
    super(options);
    this.setLoader(this._loader);
    this.set('time', options.time || new Date());
    this.set('step', options.step || 1);
  }
  /** Compute the position of the Sun in ecliptic coordinates at julianDay.
   * @see http://en.wikipedia.org/wiki/Position_of_the_Sun
   * @param {number} julianDay
   * @private
   */
  static _sunEclipticPosition(julianDay) {
    var deg2rad = Math.PI / 180;
    // Days since start of J2000.0
    var n = julianDay - 2451545.0;
    // mean longitude of the Sun
    var L = 280.460 + 0.9856474 * n;
    L %= 360;
    // mean anomaly of the Sun
    var g = 357.528 + 0.9856003 * n;
    g %= 360;
    // ecliptic longitude of Sun
    var lambda = L + 1.915 * Math.sin(g * deg2rad) +
      0.02 * Math.sin(2 * g * deg2rad);
    // distance from Sun in AU
    var R = 1.00014 - 0.01671 * Math.cos(g * deg2rad) -
      0.0014 * Math.cos(2 * g * deg2rad);
    return { lambda: lambda, R: R };
  }
  /**
   * @see http://en.wikipedia.org/wiki/Axial_tilt#Obliquity_of_the_ecliptic_.28Earth.27s_axial_tilt.29
   * @param {number} julianDay
   * @private
   */
  static _eclipticObliquity(julianDay) {
    var n = julianDay - 2451545.0;
    // Julian centuries since J2000.0
    var T = n / 36525;
    var epsilon = 23.43929111 -
      T * (46.836769 / 3600
        - T * (0.0001831 / 3600
          + T * (0.00200340 / 3600
            - T * (0.576e-6 / 3600
              - T * 4.34e-8 / 3600))));
    return epsilon;
  }
  /* Compute the Sun's equatorial position from its ecliptic position.
   * @param {number} sunEclLng sun lon in degrees
   * @param {number} eclObliq secliptic position in degrees
   * @return {number} position in degrees
   * @private
   */
  static _sunEquatorialPosition(sunEclLon, eclObliq) {
    var rad2deg = 180 / Math.PI;
    var deg2rad = Math.PI / 180;

    var alpha = Math.atan(Math.cos(eclObliq * deg2rad)
      * Math.tan(sunEclLon * deg2rad)) * rad2deg;
    var delta = Math.asin(Math.sin(eclObliq * deg2rad)
      * Math.sin(sunEclLon * deg2rad)) * rad2deg;

    var lQuadrant = Math.floor(sunEclLon / 90) * 90;
    var raQuadrant = Math.floor(alpha / 90) * 90;
    alpha = alpha + (lQuadrant - raQuadrant);

    return { alpha: alpha, delta: delta };
  }
  /** Get the day/night separation latitude
   * @param {number} lon
   * @param {Date} time
   * @returns {number}
   */
  static getNightLat(lon, time) {
    var rad2deg = 180 / Math.PI;
    var deg2rad = Math.PI / 180;

    var date = time ? new Date(time) : new Date();

    // Calculate the present UTC Julian Date. 
    // Function is valid after the beginning of the UNIX epoch 1970-01-01 and ignores leap seconds. 
    var julianDay = (date / 86400000) + 2440587.5;

    // Calculate Greenwich Mean Sidereal Time (low precision equation).
    // http://aa.usno.navy.mil/faq/docs/GAST.php 
    var gst = (18.697374558 + 24.06570982441908 * (julianDay - 2451545.0)) % 24;

    var sunEclPos = ol_source_DayNight._sunEclipticPosition(julianDay);
    var eclObliq = ol_source_DayNight._eclipticObliquity(julianDay);
    var sunEqPos = ol_source_DayNight._sunEquatorialPosition(sunEclPos.lambda, eclObliq);

    // Hour angle (indegrees) of the sun for a longitude on Earth.
    var ha = (gst * 15 + lon) - sunEqPos.alpha;
    // Latitude     
    var lat = Math.atan(-Math.cos(ha * deg2rad) /
      Math.tan(sunEqPos.delta * deg2rad)) * rad2deg;

    return lat;
  }
  /** Loader
   * @private
   */
  _loader(extent, resolution, projection) {
    var lonlat = this.getCoordinates(this.get('time'));
    var geom = new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_2__["default"]([lonlat]);
    geom.transform('EPSG:4326', projection);
    this.addFeature(new ol_Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"](geom));
  }
  /** Set source date time
   * @param {string|Date} time source date time
   */
  setTime(time) {
    this.set('time', time);
    this.refresh();
  }
  /** Get sun coordinates on earth
   * @param {string} time DateTime string, default yet
   * @returns {ol.coordinate} position in lonlat
   */
  getSunPosition(time) {
    var date = time ? new Date(time) : new Date();

    // Calculate the present UTC Julian Date. 
    // Function is valid after the beginning of the UNIX epoch 1970-01-01 and ignores leap seconds. 
    var julianDay = (date / 86400000) + 2440587.5;

    // Calculate Greenwich Mean Sidereal Time (low precision equation).
    // http://aa.usno.navy.mil/faq/docs/GAST.php 
    var gst = (18.697374558 + 24.06570982441908 * (julianDay - 2451545.0)) % 24;

    var sunEclPos = ol_source_DayNight._sunEclipticPosition(julianDay);
    var eclObliq = ol_source_DayNight._eclipticObliquity(julianDay);
    var sunEqPos = ol_source_DayNight._sunEquatorialPosition(sunEclPos.lambda, eclObliq);

    return [sunEqPos.alpha - gst * 15, sunEqPos.delta];
  }
  /** Get night-day separation line
   * @param {string} time DateTime string, default yet
   * @param {string} options use 'line' to get the separation line, 'day' to get the day polygon, 'night' to get the night polygon or 'daynight' to get both polygon, default 'night'
   * @return {Array<ol.Point>|Array<Array<ol.Point>>}
   */
  getCoordinates(time, options) {
    var rad2deg = 180 / Math.PI;
    var deg2rad = Math.PI / 180;

    var date = time ? new Date(time) : new Date();

    // Calculate the present UTC Julian Date. 
    // Function is valid after the beginning of the UNIX epoch 1970-01-01 and ignores leap seconds. 
    var julianDay = (date / 86400000) + 2440587.5;

    // Calculate Greenwich Mean Sidereal Time (low precision equation).
    // http://aa.usno.navy.mil/faq/docs/GAST.php 
    var gst = (18.697374558 + 24.06570982441908 * (julianDay - 2451545.0)) % 24;
    var lonlat = [];

    var sunEclPos = ol_source_DayNight._sunEclipticPosition(julianDay);
    var eclObliq = ol_source_DayNight._eclipticObliquity(julianDay);
    var sunEqPos = ol_source_DayNight._sunEquatorialPosition(sunEclPos.lambda, eclObliq);

    var step = this.get('step') || 1;
    for (var i = -180; i <= 180; i += step) {
      var lon = i;
      // Hour angle (indegrees) of the sun for a longitude on Earth.
      var ha = (gst * 15 + lon) - sunEqPos.alpha;
      // Latitude     
      var lat = Math.atan(-Math.cos(ha * deg2rad) /
        Math.tan(sunEqPos.delta * deg2rad)) * rad2deg;
      // New point
      lonlat.push([lon, lat]);
    }
    switch (options) {
      case 'line': break;
      case 'day': sunEqPos.delta *= -1;
      // fallthrough
      default: {
        // Close polygon
        lat = (sunEqPos.delta < 0) ? 90 : -90;
        for (var tlon = 180; tlon >= -180; tlon -= step) {
          lonlat.push([tlon, lat]);
        }
        lonlat.push(lonlat[0]);
        break;
      }
    }
    // Return night + day polygon
    if (options === 'daynight') {
      var day = [];
      lonlat.forEach(function (t) { day.push(t.slice()); });
      day[0][1] = -day[0][1];
      day[day.length - 1][1] = -day[0][1];
      day[day.length - 1][1] = -day[0][1];
      lonlat = [lonlat, day];
    }
    // Return polygon
    return lonlat;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ol_source_DayNight);


/***/ }),

/***/ "./node_modules/ol-ext/style/FlowLine.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_style_Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var ol_color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/color.js");
/* harmony import */ var _geom_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol-ext/geom/GeomUtils.js");
/* harmony import */ var _geom_LineStringSplitAt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol-ext/geom/LineStringSplitAt.js");
/*	Copyright (c) 2019 Jean-Marc VIGLINO, 
  released under the CeCILL-B license (French BSD license)
  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).
*/







/** Flow line style
 * Draw LineString with a variable color / width
 * NB: the FlowLine style doesn't impress the hit-detection.
 * If you want your lines to be sectionable you have to add your own style to handle this.
 * (with transparent line: stroke color opacity to .1 or zero width)
 * @constructor
 * @extends {ol_style_Style}
 * @param {Object} options
 *  @param {boolean} options.visible draw only the visible part of the line, default true
 *  @param {number|function} options.width Stroke width or a function that gets a feature and the position (beetween [0,1]) and returns current width
 *  @param {number} options.width2 Final stroke width (if width is not a function)
 *  @param {number} options.arrow Arrow at start (-1), at end (1), at both (2), none (0), default geta
 *  @param {ol.colorLike|function} options.color Stroke color or a function that gets a feature and the position (beetween [0,1]) and returns current color
 *  @param {ol.colorLike} options.color2 Final sroke color if color is nor a function
 *  @param {ol.colorLike} options.arrowColor Color of arrows, if not defined used color or color2
 *  @param {string} options.lineCap CanvasRenderingContext2D.lineCap 'butt' | 'round' | 'square', default 'butt'
 *  @param {number|ol.size} options.arrowSize height and width of the arrow, default 16
 *  @param {boolean} [options.noOverlap=false] prevent segments overlaping
 *  @param {number} options.offset0 offset at line start
 *  @param {number} options.offset1 offset at line end
 */
var ol_style_FlowLine = class olstyleFlowLine extends ol_style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(options) {
    options = options || {}

    super({
      stroke: options.stroke,
      text: options.text,
      zIndex: options.zIndex,
      geometry: options.geometry
    })
    this.setRenderer(this._render.bind(this))

    // Draw only visible
    this._visible = (options.visible !== false)

    // Width
    if (typeof options.width === 'function') {
      this._widthFn = options.width
    } else {
      this.setWidth(options.width)
    }
    this.setWidth2(options.width2)
    // Color
    if (typeof options.color === 'function') {
      this._colorFn = options.color
    } else {
      this.setColor(options.color)
    }
    this.setColor2(options.color2)
    // LineCap
    this.setLineCap(options.lineCap)
    // Arrow
    this.setArrow(options.arrow)
    this.setArrowSize(options.arrowSize)
    this.setArrowColor(options.arrowColor)
    // Offset
    this._offset = [0, 0]
    this.setOffset(options.offset0, 0)
    this.setOffset(options.offset1, 1)
    // Overlap
    this._noOverlap = options.noOverlap
  }
  /** Set the initial width
   * @param {number} width width, default 0
   */
  setWidth(width) {
    this._width = width || 0
  }
  /** Set the final width
   * @param {number} width width, default 0
   */
  setWidth2(width) {
    this._width2 = width
  }
  /** Get offset at start or end
   * @param {number} where 0=start, 1=end
   * @return {number} width
   */
  getOffset(where) {
    return this._offset[where]
  }
  /** Add an offset at start or end
   * @param {number} width
   * @param {number} where 0=start, 1=end
   */
  setOffset(width, where) {
    width = Math.max(0, parseFloat(width))
    switch (where) {
      case 0: {
        this._offset[0] = width
        break
      }
      case 1: {
        this._offset[1] = width
        break
      }
    }
  }
  /** Set the LineCap
   * @param {steing} cap LineCap (round or butt), default butt
   */
  setLineCap(cap) {
    this._lineCap = (cap === 'round' ? 'round' : 'butt')
  }
  /** Get the current width at step
   * @param {ol.feature} feature
   * @param {number} step current drawing step beetween [0,1]
   * @return {number}
   */
  getWidth(feature, step) {
    if (this._widthFn)
      return this._widthFn(feature, step)
    var w2 = (typeof (this._width2) === 'number') ? this._width2 : this._width
    return this._width + (w2 - this._width) * step
  }
  /** Set the initial color
   * @param {ol.colorLike} color
   */
  setColor(color) {
    try {
      this._color = (0,ol_color_js__WEBPACK_IMPORTED_MODULE_3__.asArray)(color)
    } catch (e) {
      this._color = [0, 0, 0, 1]
    }
  }
  /** Set the final color
   * @param {ol.colorLike} color
   */
  setColor2(color) {
    try {
      this._color2 = (0,ol_color_js__WEBPACK_IMPORTED_MODULE_3__.asArray)(color)
    } catch (e) {
      this._color2 = null
    }
  }
  /** Set the arrow color
   * @param {ol.colorLike} color
   */
  setArrowColor(color) {
    try {
      this._acolor = (0,ol_color_js__WEBPACK_IMPORTED_MODULE_3__.asString)(color)
    } catch (e) {
      this._acolor = null
    }
  }
  /** Get the current color at step
   * @param {ol.feature} feature
   * @param {number} step current drawing step beetween [0,1]
   * @return {string}
   */
  getColor(feature, step) {
    if (this._colorFn)
      return (0,ol_color_js__WEBPACK_IMPORTED_MODULE_3__.asString)(this._colorFn(feature, step))
    var color = this._color
    var color2 = this._color2 || this._color
    return 'rgba(' +
      +Math.round(color[0] + (color2[0] - color[0]) * step) + ','
      + Math.round(color[1] + (color2[1] - color[1]) * step) + ','
      + Math.round(color[2] + (color2[2] - color[2]) * step) + ','
      + (color[3] + (color2[3] - color[3]) * step)
      + ')'
  }
  /** Get arrow
   */
  getArrow() {
    return this._arrow
  }
  /** Set arrow
   * @param {number} n -1 | 0 | 1 | 2, default: 0
   */
  setArrow(n) {
    this._arrow = parseInt(n)
    if (this._arrow < -1 || this._arrow > 2)
      this._arrow = 0
  }
  /** getArrowSize
   * @return {ol.size}
   */
  getArrowSize() {
    return this._arrowSize || [16, 16]
  }
  /** setArrowSize
   * @param {number|ol.size} size
   */
  setArrowSize(size) {
    if (Array.isArray(size))
      this._arrowSize = size
    else if (typeof (size) === 'number')
      this._arrowSize = [size, size]
  }
  /** drawArrow
   * @param {CanvasRenderingContext2D} ctx
   * @param {ol.coordinate} p0
   * @param ol.coordinate} p1
   * @param {number} width
   * @param {number} ratio pixelratio
   * @private
   */
  drawArrow(ctx, p0, p1, width, ratio) {
    var asize = this.getArrowSize()[0] * ratio
    var l = (0,_geom_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_dist2d)(p0, p1)
    var dx = (p0[0] - p1[0]) / l
    var dy = (p0[1] - p1[1]) / l
    width = Math.max(this.getArrowSize()[1] / 2, width / 2) * ratio
    ctx.beginPath()
    ctx.moveTo(p0[0], p0[1])
    ctx.lineTo(p0[0] - asize * dx + width * dy, p0[1] - asize * dy - width * dx)
    ctx.lineTo(p0[0] - asize * dx - width * dy, p0[1] - asize * dy + width * dx)
    ctx.lineTo(p0[0], p0[1])
    ctx.fill()
  }
  /** Renderer function
   * @param {Array<ol.coordinate>} geom The pixel coordinates of the geometry in GeoJSON notation
   * @param {ol.render.State} e The olx.render.State of the layer renderer
   */
  _render(geom, e) {
    if (e.geometry.getType() === 'LineString') {
      var i, g, p, ctx = e.context
      // Get geometry used at drawing
      if (!this._visible) {
        var a = e.pixelRatio / e.resolution
        var cos = Math.cos(e.rotation)
        var sin = Math.sin(e.rotation)
        g = e.geometry.getCoordinates()
        var dx = geom[0][0] - g[0][0] * a * cos - g[0][1] * a * sin
        var dy = geom[0][1] - g[0][0] * a * sin + g[0][1] * a * cos
        geom = []
        for (i = 0; p = g[i]; i++) {
          geom[i] = [
            dx + p[0] * a * cos + p[1] * a * sin,
            dy + p[0] * a * sin - p[1] * a * cos,
            p[2]
          ]
        }
      }

      var asize = this.getArrowSize()[0] * e.pixelRatio

      ctx.save()
      // Offsets
      if (this.getOffset(0))
        this._splitAsize(geom, this.getOffset(0) * e.pixelRatio)
      if (this.getOffset(1))
        this._splitAsize(geom, this.getOffset(1) * e.pixelRatio, true)
      // Arrow 1
      if (geom.length > 1 && (this.getArrow() === -1 || this.getArrow() === 2)) {
        p = this._splitAsize(geom, asize)
        if (this._acolor)
          ctx.fillStyle = this._acolor
        else
          ctx.fillStyle = this.getColor(e.feature, 0)
        this.drawArrow(ctx, p[0], p[1], this.getWidth(e.feature, 0), e.pixelRatio)
      }
      // Arrow 2 
      if (geom.length > 1 && this.getArrow() > 0) {
        p = this._splitAsize(geom, asize, true)
        if (this._acolor)
          ctx.fillStyle = this._acolor
        else
          ctx.fillStyle = this.getColor(e.feature, 1)
        this.drawArrow(ctx, p[0], p[1], this.getWidth(e.feature, 1), e.pixelRatio)
      }

      // Split into
      var geoms = this._splitInto(geom, 255, 2)
      var k = 0
      var nb = geoms.length

      // Draw
      ctx.lineJoin = 'round'
      ctx.lineCap = this._lineCap || 'butt'

      if (geoms.length > 1) {
        for (k = 0; k < geoms.length; k++) {
          var step = k / nb
          g = geoms[k]
          ctx.lineWidth = this.getWidth(e.feature, step) * e.pixelRatio
          ctx.strokeStyle = this.getColor(e.feature, step)
          ctx.beginPath()
          ctx.moveTo(g[0][0], g[0][1])
          for (i = 1; p = g[i]; i++) {
            ctx.lineTo(p[0], p[1])
          }
          ctx.stroke()
        }
      }
      ctx.restore()
    }
  }
  /** Split extremity at
   * @param {ol.geom.LineString} geom
   * @param {number} asize
   * @param {boolean} end start=false or end=true, default false (start)
   */
  _splitAsize(geom, asize, end) {
    var p, p1, p0
    var dl, d = 0
    if (end)
      p0 = geom.pop()
    else
      p0 = geom.shift()
    p = p0
    while (geom.length) {
      if (end)
        p1 = geom.pop()
      else
        p1 = geom.shift()
      dl = (0,_geom_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_dist2d)(p, p1)
      if (d + dl > asize) {
        p = [p[0] + (p1[0] - p[0]) * (asize - d) / dl, p[1] + (p1[1] - p[1]) * (asize - d) / dl]
        dl = (0,_geom_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_dist2d)(p, p0)
        if (end) {
          geom.push(p1)
          geom.push(p)
          geom.push([p[0] + (p0[0] - p[0]) / dl, p[1] + (p0[1] - p[1]) / dl])
        } else {
          geom.unshift(p1)
          geom.unshift(p)
          geom.unshift([p[0] + (p0[0] - p[0]) / dl, p[1] + (p0[1] - p[1]) / dl])
        }
        break
      }
      d += dl
      p = p1
    }
    return [p0, p]
  }
  /** Split line geometry into equal length geometries
   * @param {Array<ol.coordinate>} geom
   * @param {number} nb number of resulting geometries, default 255
   * @param {number} nim minimum length of the resulting geometries, default 1
   */
  _splitInto(geom, nb, min) {
    var i, p
    var dt = this._noOverlap ? 1 : .9
    // Split geom into equal length geoms
    var geoms = []
    var dl, l = 0
    for (i = 1; p = geom[i]; i++) {
      l += (0,_geom_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_dist2d)(geom[i - 1], p)
    }
    var length = Math.max(min || 2, l / (nb || 255))
    var p0 = geom[0]
    l = 0
    var g = [p0]
    i = 1
    p = geom[1]
    while (i < geom.length) {
      var dx = p[0] - p0[0]
      var dy = p[1] - p0[1]
      dl = Math.sqrt(dx * dx + dy * dy)
      if (l + dl > length) {
        var d = (length - l) / dl
        g.push([
          p0[0] + dx * d,
          p0[1] + dy * d
        ])
        geoms.push(g)
        p0 = [
          p0[0] + dx * d * dt,
          p0[1] + dy * d * dt
        ]
        g = [p0]
        l = 0
      } else {
        l += dl
        p0 = p
        g.push(p0)
        i++
        p = geom[i]
      }
    }
    geoms.push(g)
    return geoms
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ol_style_FlowLine);


/***/ }),

/***/ "./node_modules/ol-ext/style/Photo.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_style_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/style/RegularShape.js");
/* harmony import */ var ol_color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/color.js");
/* harmony import */ var ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/*	Copyright (c) 2015 Jean-Marc VIGLINO, 
  released under the CeCILL-B license (French BSD license)
  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).
*
*  Photo style for vector features
*/





/**
 * @classdesc
 * Set Photo style for vector features.
 *
 * @constructor
 * @param {} options
 *  @param { default | square | circle | anchored | folio } options.kind
 *  @param {boolean} options.crop crop within square, default is false
 *  @param {Number} options.radius symbol size
 *  @param {Number} [options.shadow=0] drop a shadow (the shadow width in pixel)
 *  @param {string} [options.declutterMode] Declutter mode "declutter" | "obstacle" | "none" | undefined	
 *  @param {ol_style_Stroke} options.stroke
 *  @param {String} options.src image src
 *  @param {String} options.crossOrigin The crossOrigin attribute for loaded images. Note that you must provide a crossOrigin value if you want to access pixel data with the Canvas renderer.
 *  @param {Array<number>} [options.displacement] to use with ol > 6
 * 	@param {number} [options.offsetX=0] Horizontal offset in pixels, deprecated use displacement with ol>6
 * 	@param {number} [options.offsetY=0] Vertical offset in pixels, deprecated use displacement with ol>6
 *  @param {function} [options.onload] callback when image is loaded (to redraw the layer)
 *  @param {function} [options.onerror] callback when image is on error (not loaded)
 * @extends {ol_style_RegularShape}
 * @implements {ol.structs.IHasChecksum}
 * @api
 */
var ol_style_Photo = class olstylePhoto extends ol_style_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(options) {
    options = options || {}
    if (!options.displacement)
      options.displacement = [options.offsetX || 0, -options.offsetY || 0]
    var sanchor = (options.kind === "anchored" ? 8 : 0)
    var shadow = (Number(options.shadow) || 0)
    if (!options.stroke) {
      options.stroke = new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_1__["default"]({ width: 0, color: "#000" })
    }
    var strokeWidth = options.stroke.getWidth()
    if (strokeWidth < 0) strokeWidth = 0;
    if (options.kind == 'folio') strokeWidth += 6;
    options.stroke.setWidth(strokeWidth)

    super({
      radius: options.radius + strokeWidth + sanchor / 2 + shadow / 2,
      points: 0,
      displacement: [options.displacement[0] || 0, (options.displacement[1] || 0) + sanchor],
      // No fill to create a hit detection Image (v5) or transparent (v6) 
      fill: ol_style_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.render ? new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ color: [0, 0, 0, 0] }) : null,
      declutterMode: options.declutterMode,
    })
    this.sanchor_ = sanchor;
    this._shadow = shadow;

    // Hack to get the hit detection Image (v4.6.5 ?)
    if (!this.getHitDetectionImage) {
      var img = super.getImage.call(this)
      if (!this.hitDetectionCanvas_) {
        for (var i in this) {
          if (this[i] && this[i].getContext && this[i] !== img) {
            this.hitDetectionCanvas_ = this[i]
            break
          }
        }
      }
      // Clone canvas for hit detection (old versions)
      this.hitDetectionCanvas_ = document.createElement('canvas')
      this.hitDetectionCanvas_.width = img.width
      this.hitDetectionCanvas_.height = img.height
      var hit = this.hitDetectionCanvas_
      this.getHitDetectionImage = function () {
        return hit
      }
    }

    this._stroke = options.stroke
    this._fill = options.fill
    this._crop = options.crop
    this._crossOrigin = options.crossOrigin
    this._kind = options.kind || "default"

    this._radius = options.radius
    this._src = options.src

    this._offset = [options.offsetX ? options.offsetX : 0, options.offsetY ? options.offsetY : 0]

    this._onload = options.onload
    this._onerror = options.onerror

    if (typeof (options.opacity) == 'number')
      this.setOpacity(options.opacity)
    if (typeof (options.rotation) == 'number')
      this.setRotation(options.rotation)

    // Calculate image
    this.getImage()
  }
  /** Set photo offset
   * @param {ol.pixel} offset
   */
  setOffset(offset) {
    this._offset = [offset[0] || 0, offset[1] || 0]
    this.getImage()
  }
  /**
   * Clones the style.
   * @return {ol_style_Photo}
   */
  clone() {
    var i = new ol_style_Photo({
      stroke: this._stroke,
      fill: this._fill,
      shadow: this._shadow,
      crop: this._crop,
      crossOrigin: this._crossOrigin,
      kind: this._kind,
      radius: this._radius,
      src: this._src,
      offsetX: this._offset[0],
      offsetY: this._offset[1],
      opacity: this.getOpacity(),
      rotation: this.getRotation(),
      declutterMode: this.getDeclutterMode ? this.getDeclutterMode() : null,
    })
    i.getImage()
    return i
  }
  /**
   * Draw the form without the image
   * @private
   */
  drawBack_(context, color, strokeWidth, pixelratio) {
    var shadow = this._shadow
    var canvas = context.canvas
    context.beginPath()
    context.fillStyle = color
    context.clearRect(0, 0, canvas.width, canvas.height)
    var width = canvas.width / pixelratio
    var height = canvas.height / pixelratio
    switch (this._kind) {
      case 'square': {
        context.rect(0, 0, width - shadow, height - shadow)
        break
      }
      case 'circle': {
        context.arc(this._radius + strokeWidth, this._radius + strokeWidth, this._radius + strokeWidth, 0, 2 * Math.PI, false)
        break
      }
      case 'folio': {
        var offset = 6
        strokeWidth -= offset
        context.strokeStyle = 'rgba(0,0,0,0.5)'
        context.lineWidth = 1
        var w = width - shadow - 2 * offset
        var a = Math.atan(6 / w)
        context.save()
        context.rotate(-a)
        context.translate(-6, 2)
        context.beginPath()
        context.rect(offset, offset, w, w)
        context.stroke()
        context.fill()
        context.restore()
        context.save()
        context.translate(6, -1)
        context.rotate(a)
        context.beginPath()
        context.rect(offset, offset, w, w)
        context.stroke()
        context.fill()
        context.restore()
        context.beginPath()
        context.rect(offset, offset, w, w)
        context.stroke()
        break
      }
      case 'anchored': {
        context.roundRect(this.sanchor_ / 2, 0, width - this.sanchor_ - shadow, height - this.sanchor_ - shadow, strokeWidth)
        context.moveTo(width / 2 - this.sanchor_ - shadow / 2, height - this.sanchor_ - shadow)
        context.lineTo(width / 2 + this.sanchor_ - shadow / 2, height - this.sanchor_ - shadow)
        context.lineTo(width / 2 - shadow / 2, height - shadow); break
      }
      default: {
        // roundrect
        context.roundRect(0, 0, width - shadow, height - shadow, strokeWidth)
        break
      }
    }
    context.closePath()
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(pixelratio) {
    pixelratio = pixelratio || window.devicePixelRatio;
    var canvas = ol_style_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.getImage.call(this, pixelratio)
    if ((this._gethit || this.img_) && this._currentRatio === pixelratio) return canvas;
    // Calculate image at pixel ratio
    this._currentRatio = pixelratio;

    var strokeStyle
    var strokeWidth = 0
    if (this._stroke) {
      strokeStyle = (0,ol_color_js__WEBPACK_IMPORTED_MODULE_3__.asString)(this._stroke.getColor())
      strokeWidth = this._stroke.getWidth()
    }

    // Draw hitdetection image
    this._gethit = true
      var context = this.getHitDetectionImage().getContext('2d')
      context.save()
      context.setTransform(1, 0, 0, 1, 0, 0)
      this.drawBack_(context, "#000", strokeWidth, 1)
      context.fill()
      context.restore()
    this._gethit = false

    // Draw the image
    context = canvas.getContext('2d')
    context.save()
    context.setTransform(pixelratio, 0, 0, pixelratio, 0, 0)
    this.drawBack_(context, strokeStyle, strokeWidth, pixelratio)

    // Draw a shadow
    if (this._shadow) {
      context.shadowColor = 'rgba(0,0,0,0.5)'
      context.shadowBlur = pixelratio * this._shadow / 2
      context.shadowOffsetX = pixelratio * this._shadow / 2
      context.shadowOffsetY = pixelratio * this._shadow / 2
    }
    context.fill()
    context.restore()

    var self = this
    var img = this.img_ = new Image()
    if (this._crossOrigin) img.crossOrigin = this._crossOrigin
    img.src = this._src

    // Draw image
    if (img.width) {
      self.drawImage_(canvas, img, pixelratio)
    } else {
      img.onload = function () {
        self.drawImage_(canvas, img, pixelratio)
        // Force change (?!)
        // self.setScale(1);
        if (self._onload) self._onload()
      }
      if (self._onerror) {
        img.onerror = function () {
          self._onerror()
        }
      }
    }

    // Set anchor (ol < 6)
    if (!this.getDisplacement) {
      var a = this.getAnchor()
      a[0] = (canvas.width / pixelratio - this._shadow) / 2 - this._offset[0]
      if (this.sanchor_) {
        a[1] = canvas.height / pixelratio - this._shadow - this._offset[1]
      } else {
        a[1] = (canvas.height / pixelratio - this._shadow) / 2 - this._offset[1]
      }
    }

    return canvas
  }
  /** Returns the photo image
   * @returns {HTMLImageElement}
   */
  getPhoto() {
    return this.img_
  }
  /**
   * Draw an timage when loaded
   * @private
   */
  drawImage_(canvas, img, pixelratio) {
    // Remove the circle on the canvas
    var context = (canvas.getContext('2d'))

    var strokeWidth = 0
    if (this._stroke)
      strokeWidth = this._stroke.getWidth()
    var size = 2 * this._radius

    context.save()
    if (ol_style_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.render)
      context.setTransform(pixelratio, 0, 0, pixelratio, 0, 0)
    if (this._kind == 'circle') {
      context.beginPath()
      context.arc(this._radius + strokeWidth, this._radius + strokeWidth, this._radius, 0, 2 * Math.PI, false)
      context.clip()
    }
    var s, x, y, w, h, sx, sy, sw, sh
    // Crop the image to a square vignette
    if (this._crop) {
      s = Math.min(img.width / size, img.height / size)
      sw = sh = s * size
      sx = (img.width - sw) / 2
      sy = (img.height - sh) / 2

      x = y = 0
      w = h = size + 1
    } else {
      // Fit the image to the size
      s = Math.min(size / img.width, size / img.height)
      sx = sy = 0
      sw = img.width
      sh = img.height

      w = s * sw
      h = s * sh
      x = (size - w) / 2
      y = (size - h) / 2
    }
    x += strokeWidth + this.sanchor_ / 2
    y += strokeWidth

    context.drawImage(img, sx, sy, sw, sh, x, y, w, h)

    // Draw a circle to avoid aliasing on clip
    if (this._kind == 'circle' && strokeWidth) {
      context.beginPath()
      context.strokeStyle = (0,ol_color_js__WEBPACK_IMPORTED_MODULE_3__.asString)(this._stroke.getColor())
      context.lineWidth = strokeWidth / 4
      context.arc(this._radius + strokeWidth, this._radius + strokeWidth, this._radius, 0, 2 * Math.PI, false)
      context.stroke()
    }
    context.restore()
  }
}

/**
 * Draws a rounded rectangle using the current state of the canvas. 
 * Draw a rectangle if the radius is null.
 * @param {Number} x The top left x coordinate
 * @param {Number} y The top left y coordinate 
 * @param {Number} width The width of the rectangle 
 * @param {Number} height The height of the rectangle
 * @param {Number} radius The corner radius.
 */
CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
  if (!r) {
    this.rect(x,y,w,h);
  } else {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    this.beginPath();
    this.moveTo(x+r, y);
    this.arcTo(x+w, y, x+w, y+h, r);
    this.arcTo(x+w, y+h, x, y+h, r);
    this.arcTo(x, y+h, x, y, r);
    this.arcTo(x, y, x+w, y, r);
    this.closePath();
  }
  return this;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ol_style_Photo);


/***/ }),

/***/ "./node_modules/ol/Image.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   listenImage: () => (/* binding */ listenImage)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/ImageState.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/has.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/events.js");
/**
 * @module ol/Image
 */







/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string): void} LoadFunction
 * @api
 */

class ImageWrapper extends _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   * @param {CanvasRenderingContext2D} [context] Canvas context. When provided, the image will be
   *    drawn into the context's canvas, and `getImage()` will return the canvas once the image
   *    has finished loading.
   */
  constructor(
    extent,
    resolution,
    pixelRatio,
    src,
    crossOrigin,
    imageLoadFunction,
    context
  ) {
    super(extent, resolution, pixelRatio, _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE);

    /**
     * @private
     * @type {string}
     */
    this.src_ = src;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = context;

    /**
     * @private
     * @type {?function():void}
     */
    this.unlisten_ = null;

    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;

    /**
     * @private
     * @type {LoadFunction}
     */
    this.imageLoadFunction_ = imageLoadFunction;
  }

  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    if (
      this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED &&
      this.context_ &&
      !(this.image_ instanceof HTMLCanvasElement)
    ) {
      const canvas = this.context_.canvas;
      canvas.width = this.image_.width;
      canvas.height = this.image_.height;
      this.context_.drawImage(this.image_, 0, 0);
      this.image_ = this.context_.canvas;
    }
    return this.image_;
  }

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.changed();
  }

  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    if (this.resolution === undefined) {
      this.resolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(this.extent) / this.image_.height;
    }
    this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    this.unlistenImage_();
    this.changed();
  }

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @api
   */
  load() {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE || this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.imageLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }

  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */
  setImage(image) {
    this.image_ = image;
    this.resolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(this.extent) / this.image_.height;
  }

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
}

/**
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */
function listenImage(image, loadHandler, errorHandler) {
  const img = /** @type {HTMLImageElement} */ (image);
  let listening = true;
  let decoding = false;
  let loaded = false;

  const listenerKeys = [
    (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listenOnce)(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOAD, function () {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    }),
  ];

  if (img.src && _has_js__WEBPACK_IMPORTED_MODULE_5__.IMAGE_DECODE) {
    decoding = true;
    img
      .decode()
      .then(function () {
        if (listening) {
          loadHandler();
        }
      })
      .catch(function (error) {
        if (listening) {
          if (loaded) {
            loadHandler();
          } else {
            errorHandler();
          }
        }
      });
  } else {
    listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listenOnce)(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR, errorHandler));
  }

  return function unlisten() {
    listening = false;
    listenerKeys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__.unlistenByKey);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageWrapper);


/***/ }),

/***/ "./node_modules/ol/ImageBase.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/ImageBase
 */




/**
 * @abstract
 */
class ImageBase extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */
  constructor(extent, resolution, pixelRatio, state) {
    super();

    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */
    this.extent = extent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @protected
     * @type {number|undefined}
     */
    this.resolution = resolution;

    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    this.state = state;
  }

  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE);
  }

  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }

  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }

  /**
   * @return {number} Resolution.
   */
  getResolution() {
    return /** @type {number} */ (this.resolution);
  }

  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }

  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageBase);


/***/ }),

/***/ "./node_modules/ol/ImageCanvas.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/ImageState.js");
/**
 * @module ol/ImageCanvas
 */



/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=): void): void} Loader
 */

class ImageCanvas extends _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader} [loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */
  constructor(extent, resolution, pixelRatio, canvas, loader) {
    const state = loader !== undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;

    super(extent, resolution, pixelRatio, state);

    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */
    this.loader_ = loader !== undefined ? loader : null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = canvas;

    /**
     * @private
     * @type {?Error}
     */
    this.error_ = null;
  }

  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */
  getError() {
    return this.error_;
  }

  /**
   * Handle async drawing complete.
   * @param {Error} [err] Any error during drawing.
   * @private
   */
  handleLoad_(err) {
    if (err) {
      this.error_ = err;
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    } else {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    }
    this.changed();
  }

  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  }

  /**
   * @return {HTMLCanvasElement} Canvas element.
   */
  getImage() {
    return this.canvas_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageCanvas);


/***/ }),

/***/ "./node_modules/ol/ImageState.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
});


/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/dom.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/Image.js");
/**
 * @module ol/ImageTile
 */





class ImageTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    this.src_ = src;

    this.key = src;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {?function():void}
     */
    this.unlisten_ = null;

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    this.tileLoadFunction_ = tileLoadFunction;
  }

  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }

  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    this.unlistenImage_();
    this.changed();
  }

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }

  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = /** @type {HTMLImageElement} */ (this.image_);
    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    } else {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = (0,_Image_js__WEBPACK_IMPORTED_MODULE_2__.listenImage)(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
}

/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  const ctx = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageTile);


/***/ }),

/***/ "./node_modules/ol/Tile.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/TileState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/easing.js");
/**
 * @module ol/Tile
 */






/**
 * A function that takes an {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState.js';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
class Tile extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();

    options = options ? options : {};

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    this.tileCoord = tileCoord;

    /**
     * @protected
     * @type {import("./TileState.js").default}
     */
    this.state = state;

    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */
    this.interimTile = null;

    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */
    this.key = '';

    /**
     * The duration for the opacity transition.
     * @type {number}
     */
    this.transition_ =
      options.transition === undefined ? 250 : options.transition;

    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */
    this.transitionStarts_ = {};

    /**
     * @type {boolean}
     */
    this.interpolate = !!options.interpolate;
  }

  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE);
  }

  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    if (this.state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`
      this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY);
    }
  }

  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + '/' + this.tileCoord;
  }

  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    if (!this.interimTile) {
      //empty chain
      return this;
    }
    let tile = this.interimTile;

    // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)
    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        // Show tile immediately instead of fading it in after loading, because
        // the interim tile is in place already
        this.transition_ = 0;
        return tile;
      }
      tile = tile.interimTile;
    } while (tile);

    // we can not find a better tile
    return this;
  }

  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    if (!this.interimTile) {
      return;
    }

    let tile = this.interimTile;

    /**
     * @type {Tile}
     */
    let prev = this;

    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }
      tile = prev.interimTile;
    } while (tile);
  }

  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }

  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }

  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR && this.state > state) {
      throw new Error('Tile load sequence violation');
    }
    this.state = state;
    this.changed();
  }

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  }

  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }

    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    const delta = time - start + 1000 / 60; // avoid rendering at 0
    if (delta >= this.transition_) {
      return 1;
    }
    return (0,_easing_js__WEBPACK_IMPORTED_MODULE_4__.easeIn)(delta / this.transition_);
  }

  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }

  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tile);


/***/ }),

/***/ "./node_modules/ol/TileCache.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/tilecoord.js");
/**
 * @module ol/TileCache
 */



class TileCache extends _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  clear() {
    while (this.getCount() > 0) {
      this.pop().release();
    }
    super.clear();
  }

  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(usedTiles) {
    while (this.canExpireCache()) {
      const tile = this.peekLast();
      if (tile.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  }

  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0) {
      return;
    }
    const key = this.peekFirstKey();
    const tileCoord = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.fromKey)(key);
    const z = tileCoord[0];
    this.forEach((tile) => {
      if (tile.tileCoord[0] !== z) {
        this.remove((0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.getKey)(tile.tileCoord));
        tile.release();
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileCache);


/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
class TileRange {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    /**
     * @type {number}
     */
    this.minX = minX;

    /**
     * @type {number}
     */
    this.maxX = maxX;

    /**
     * @type {number}
     */
    this.minY = minY;

    /**
     * @type {number}
     */
    this.maxY = maxY;
  }

  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return (
      this.minX <= tileRange.minX &&
      tileRange.maxX <= this.maxX &&
      this.minY <= tileRange.minY &&
      tileRange.maxY <= this.maxY
    );
  }

  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return (
      this.minX == tileRange.minX &&
      this.minY == tileRange.minY &&
      this.maxX == tileRange.maxX &&
      this.maxY == tileRange.maxY
    );
  }

  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }

  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }

  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }

  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return (
      this.minX <= tileRange.maxX &&
      this.maxX >= tileRange.minX &&
      this.minY <= tileRange.maxY &&
      this.maxY >= tileRange.minY
    );
  }
}

/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileRange);


/***/ }),

/***/ "./node_modules/ol/colorlike.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asColorLike: () => (/* binding */ asColorLike)
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/color.js");
/**
 * @module ol/colorlike
 */


/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */

/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (Array.isArray(color)) {
    return (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.toString)(color);
  }
  return color;
}


/***/ }),

/***/ "./node_modules/ol/control/ScaleLine.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/css.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/asserts.js");
/**
 * @module ol/control/ScaleLine
 */





/**
 * @type {string}
 */
const UNITS_PROP = 'units';

/**
 * @typedef {'degrees' | 'imperial' | 'nautical' | 'metric' | 'us'} Units
 * Units for the scale line.
 */

/**
 * @const
 * @type {Array<number>}
 */
const LEADING_DIGITS = [1, 2, 5];

/**
 * @const
 * @type {number}
 */
const DEFAULT_DPI = 25.4 / 0.28;

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:units', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |'change:units', Return>} ScaleLineOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className] CSS class name. The default is `ol-scale-bar` when configured with
 * `bar: true`. Otherwise the default is `ol-scale-line`.
 * @property {number} [minWidth=64] Minimum width in pixels at the OGC default dpi. The width will be
 * adjusted to match the dpi used.
 * @property {number} [maxWidth] Maximum width in pixels at the OGC default dpi. The width will be
 * adjusted to match the dpi used.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {Units} [units='metric'] Units.
 * @property {boolean} [bar=false] Render scalebars instead of a line.
 * @property {number} [steps=4] Number of steps the scalebar should use. Use even numbers
 * for best results. Only applies when `bar` is `true`.
 * @property {boolean} [text=false] Render the text scale above of the scalebar. Only applies
 * when `bar` is `true`.
 * @property {number|undefined} [dpi=undefined] dpi of output device such as printer. Only applies
 * when `bar` is `true`. If undefined the OGC default screen pixel size of 0.28mm will be assumed.
 */

/**
 * @classdesc
 * A control displaying rough y-axis distances, calculated for the center of the
 * viewport. For conformal projections (e.g. EPSG:3857, the default view
 * projection in OpenLayers), the scale is valid for all directions.
 * No scale line will be shown when the y-axis distance of a pixel at the
 * viewport center cannot be calculated in the view projection.
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 * When specifying `bar` as `true`, a scalebar will be rendered instead
 * of a scaleline.
 *
 * @api
 */
class ScaleLine extends _Control_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(options) {
    options = options ? options : {};

    const element = document.createElement('div');
    element.style.pointerEvents = 'none';

    super({
      element: element,
      render: options.render,
      target: options.target,
    });

    /***
     * @type {ScaleLineOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {ScaleLineOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {ScaleLineOnSignature<void>}
     */
    this.un;

    const className =
      options.className !== undefined
        ? options.className
        : options.bar
        ? 'ol-scale-bar'
        : 'ol-scale-line';

    /**
     * @private
     * @type {HTMLElement}
     */
    this.innerElement_ = document.createElement('div');
    this.innerElement_.className = className + '-inner';

    this.element.className = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_UNSELECTABLE;
    this.element.appendChild(this.innerElement_);

    /**
     * @private
     * @type {?import("../View.js").State}
     */
    this.viewState_ = null;

    /**
     * @private
     * @type {number}
     */
    this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;

    /**
     * @private
     * @type {number|undefined}
     */
    this.maxWidth_ = options.maxWidth;

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = false;

    /**
     * @private
     * @type {number|undefined}
     */
    this.renderedWidth_ = undefined;

    /**
     * @private
     * @type {string}
     */
    this.renderedHTML_ = '';

    this.addChangeListener(UNITS_PROP, this.handleUnitsChanged_);

    this.setUnits(options.units || 'metric');

    /**
     * @private
     * @type {boolean}
     */
    this.scaleBar_ = options.bar || false;

    /**
     * @private
     * @type {number}
     */
    this.scaleBarSteps_ = options.steps || 4;

    /**
     * @private
     * @type {boolean}
     */
    this.scaleBarText_ = options.text || false;

    /**
     * @private
     * @type {number|undefined}
     */
    this.dpi_ = options.dpi || undefined;
  }

  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(UNITS_PROP);
  }

  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }

  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(units) {
    this.set(UNITS_PROP, units);
  }

  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(dpi) {
    this.dpi_ = dpi;
  }

  /**
   * @private
   */
  updateElement_() {
    const viewState = this.viewState_;

    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    const center = viewState.center;
    const projection = viewState.projection;
    const units = this.getUnits();
    const pointResolutionUnits = units == 'degrees' ? 'degrees' : 'm';
    let pointResolution = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(
      projection,
      viewState.resolution,
      center,
      pointResolutionUnits
    );

    const minWidth =
      (this.minWidth_ * (this.dpi_ || DEFAULT_DPI)) / DEFAULT_DPI;

    const maxWidth =
      this.maxWidth_ !== undefined
        ? (this.maxWidth_ * (this.dpi_ || DEFAULT_DPI)) / DEFAULT_DPI
        : undefined;

    let nominalCount = minWidth * pointResolution;
    let suffix = '';
    if (units == 'degrees') {
      const metersPerDegree = _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT.degrees;
      nominalCount *= metersPerDegree;
      if (nominalCount < metersPerDegree / 60) {
        suffix = '\u2033'; // seconds
        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix = '\u2032'; // minutes
        pointResolution *= 60;
      } else {
        suffix = '\u00b0'; // degrees
      }
    } else if (units == 'imperial') {
      if (nominalCount < 0.9144) {
        suffix = 'in';
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix = 'ft';
        pointResolution /= 0.3048;
      } else {
        suffix = 'mi';
        pointResolution /= 1609.344;
      }
    } else if (units == 'nautical') {
      pointResolution /= 1852;
      suffix = 'NM';
    } else if (units == 'metric') {
      if (nominalCount < 0.001) {
        suffix = 'μm';
        pointResolution *= 1000000;
      } else if (nominalCount < 1) {
        suffix = 'mm';
        pointResolution *= 1000;
      } else if (nominalCount < 1000) {
        suffix = 'm';
      } else {
        suffix = 'km';
        pointResolution /= 1000;
      }
    } else if (units == 'us') {
      if (nominalCount < 0.9144) {
        suffix = 'in';
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix = 'ft';
        pointResolution /= 0.30480061;
      } else {
        suffix = 'mi';
        pointResolution /= 1609.3472;
      }
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 33); // Invalid units
    }

    let i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
    let count, width, decimalCount;
    let previousCount, previousWidth, previousDecimalCount;
    while (true) {
      decimalCount = Math.floor(i / 3);
      const decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[((i % 3) + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);
      if (isNaN(width)) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
        return;
      }
      if (maxWidth !== undefined && width >= maxWidth) {
        count = previousCount;
        width = previousWidth;
        decimalCount = previousDecimalCount;
        break;
      } else if (width >= minWidth) {
        break;
      }
      previousCount = count;
      previousWidth = width;
      previousDecimalCount = decimalCount;
      ++i;
    }
    const html = this.scaleBar_
      ? this.createScaleBar(width, count, suffix)
      : count.toFixed(decimalCount < 0 ? -decimalCount : 0) + ' ' + suffix;

    if (this.renderedHTML_ != html) {
      this.innerElement_.innerHTML = html;
      this.renderedHTML_ = html;
    }

    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + 'px';
      this.renderedWidth_ = width;
    }

    if (!this.renderedVisible_) {
      this.element.style.display = '';
      this.renderedVisible_ = true;
    }
  }

  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(width, scale, suffix) {
    const resolutionScale = this.getScaleForResolution();
    const mapScale =
      resolutionScale < 1
        ? Math.round(1 / resolutionScale).toLocaleString() + ' : 1'
        : '1 : ' + Math.round(resolutionScale).toLocaleString();
    const steps = this.scaleBarSteps_;
    const stepWidth = width / steps;
    const scaleSteps = [this.createMarker('absolute')];
    for (let i = 0; i < steps; ++i) {
      const cls =
        i % 2 === 0 ? 'ol-scale-singlebar-odd' : 'ol-scale-singlebar-even';
      scaleSteps.push(
        '<div>' +
          '<div ' +
          `class="ol-scale-singlebar ${cls}" ` +
          `style="width: ${stepWidth}px;"` +
          '>' +
          '</div>' +
          this.createMarker('relative') +
          // render text every second step, except when only 2 steps
          (i % 2 === 0 || steps === 2
            ? this.createStepText(i, width, false, scale, suffix)
            : '') +
          '</div>'
      );
    }
    // render text at the end
    scaleSteps.push(this.createStepText(steps, width, true, scale, suffix));

    const scaleBarText = this.scaleBarText_
      ? `<div class="ol-scale-text" style="width: ${width}px;">` +
        mapScale +
        '</div>'
      : '';
    return scaleBarText + scaleSteps.join('');
  }

  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(position) {
    const top = position === 'absolute' ? 3 : -10;
    return (
      '<div ' +
      'class="ol-scale-step-marker" ' +
      `style="position: ${position}; top: ${top}px;"` +
      '></div>'
    );
  }

  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(i, width, isLast, scale, suffix) {
    const length =
      i === 0 ? 0 : Math.round((scale / this.scaleBarSteps_) * i * 100) / 100;
    const lengthString = length + (i === 0 ? '' : ' ' + suffix);
    const margin = i === 0 ? -3 : (width / this.scaleBarSteps_) * -1;
    const minWidth = i === 0 ? 0 : (width / this.scaleBarSteps_) * 2;
    return (
      '<div ' +
      'class="ol-scale-step-text" ' +
      'style="' +
      `margin-left: ${margin}px;` +
      `text-align: ${i === 0 ? 'left' : 'center'};` +
      `min-width: ${minWidth}px;` +
      `left: ${isLast ? width + 'px' : 'unset'};` +
      '">' +
      lengthString +
      '</div>'
    );
  }

  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const resolution = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      'm'
    );
    const dpi = this.dpi_ || DEFAULT_DPI;
    const inchesPerMeter = 1000 / 25.4;
    return resolution * inchesPerMeter * dpi;
  }

  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.viewState_ = null;
    } else {
      this.viewState_ = frameState.viewState;
    }
    this.updateElement_();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScaleLine);


/***/ }),

/***/ "./node_modules/ol/featureloader.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadFeaturesXhr: () => (/* binding */ loadFeaturesXhr),
/* harmony export */   setWithCredentials: () => (/* binding */ setWithCredentials),
/* harmony export */   xhr: () => (/* binding */ xhr)
/* harmony export */ });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/functions.js");
/**
 * @module ol/featureloader
 */


/**
 *
 * @type {boolean}
 * @private
 */
let withCredentials = false;

/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */

/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */

/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */
function loadFeaturesXhr(
  url,
  format,
  extent,
  resolution,
  projection,
  success,
  failure
) {
  const xhr = new XMLHttpRequest();
  xhr.open(
    'GET',
    typeof url === 'function' ? url(extent, resolution, projection) : url,
    true
  );
  if (format.getType() == 'arraybuffer') {
    xhr.responseType = 'arraybuffer';
  }
  xhr.withCredentials = withCredentials;
  /**
   * @param {Event} event Event.
   * @private
   */
  xhr.onload = function (event) {
    // status will be 0 for file:// urls
    if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
      const type = format.getType();
      /** @type {Document|Node|Object|string|undefined} */
      let source;
      if (type == 'json' || type == 'text') {
        source = xhr.responseText;
      } else if (type == 'xml') {
        source = xhr.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(
            xhr.responseText,
            'application/xml'
          );
        }
      } else if (type == 'arraybuffer') {
        source = /** @type {ArrayBuffer} */ (xhr.response);
      }
      if (source) {
        success(
          /** @type {Array<import("./Feature.js").default>} */
          (
            format.readFeatures(source, {
              extent: extent,
              featureProjection: projection,
            })
          ),
          format.readProjection(source)
        );
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  /**
   * @private
   */
  xhr.onerror = failure;
  xhr.send();
}

/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */
function xhr(url, format) {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<import("./Feature.js").default>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   */
  return function (extent, resolution, projection, success, failure) {
    const source = /** @type {import("./source/Vector").default} */ (this);
    loadFeaturesXhr(
      url,
      format,
      extent,
      resolution,
      projection,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function (features, dataProjection) {
        source.addFeatures(features);
        if (success !== undefined) {
          success(features);
        }
      },
      /* FIXME handle error */ failure ? failure : _functions_js__WEBPACK_IMPORTED_MODULE_0__.VOID
    );
  };
}

/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */
function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}


/***/ }),

/***/ "./node_modules/ol/format/GeoJSON.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/geom/GeometryCollection.js");
/* harmony import */ var _JSONFeature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/format/JSONFeature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/asserts.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/obj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/GeoJSON
 */















/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */

/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @api
 */
class GeoJSON extends _JSONFeature_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super();

    /**
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(
      options.dataProjection ? options.dataProjection : 'EPSG:4326'
    );

    if (options.featureProjection) {
      /**
       * @type {import("../proj/Projection.js").default}
       */
      this.defaultFeatureProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.featureProjection);
    }

    /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */
    this.geometryName_ = options.geometryName;

    /**
     * Look for the geometry name in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */
    this.extractGeometryName_ = options.extractGeometryName;

    this.supportedMediaTypes = [
      'application/geo+json',
      'application/vnd.geo+json',
    ];
  }

  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(object, options) {
    /**
     * @type {GeoJSONFeature}
     */
    let geoJSONFeature = null;
    if (object['type'] === 'Feature') {
      geoJSONFeature = /** @type {GeoJSONFeature} */ (object);
    } else {
      geoJSONFeature = {
        'type': 'Feature',
        'geometry': /** @type {GeoJSONGeometry} */ (object),
        'properties': null,
      };
    }

    const geometry = readGeometry(geoJSONFeature['geometry'], options);
    const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (
      this.extractGeometryName_ &&
      'geometry_name' in geoJSONFeature !== undefined
    ) {
      feature.setGeometryName(geoJSONFeature['geometry_name']);
    }
    feature.setGeometry(geometry);

    if ('id' in geoJSONFeature) {
      feature.setId(geoJSONFeature['id']);
    }

    if (geoJSONFeature['properties']) {
      feature.setProperties(geoJSONFeature['properties'], true);
    }
    return feature;
  }

  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(object, options) {
    const geoJSONObject = /** @type {GeoJSONObject} */ (object);
    /** @type {Array<import("../Feature.js").default>} */
    let features = null;
    if (geoJSONObject['type'] === 'FeatureCollection') {
      const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (
        object
      );
      features = [];
      const geoJSONFeatures = geoJSONFeatureCollection['features'];
      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i], options));
      }
    } else {
      features = [this.readFeatureFromObject(object, options)];
    }
    return features;
  }

  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(object, options) {
    return readGeometry(object, options);
  }

  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(object) {
    const crs = object['crs'];
    let projection;
    if (crs) {
      if (crs['type'] == 'name') {
        projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(crs['properties']['name']);
      } else if (crs['type'] === 'EPSG') {
        projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:' + crs['properties']['code']);
      } else {
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 36); // Unknown SRS type
      }
    } else {
      projection = this.dataProjection;
    }
    return /** @type {import("../proj/Projection.js").default} */ (projection);
  }

  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(feature, options) {
    options = this.adaptOptions(options);

    /** @type {GeoJSONFeature} */
    const object = {
      'type': 'Feature',
      geometry: null,
      properties: null,
    };

    const id = feature.getId();
    if (id !== undefined) {
      object.id = id;
    }

    if (!feature.hasProperties()) {
      return object;
    }

    const properties = feature.getProperties();
    const geometry = feature.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry(geometry, options);

      delete properties[feature.getGeometryName()];
    }

    if (!(0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(properties)) {
      object.properties = properties;
    }

    return object;
  }

  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(features, options) {
    options = this.adaptOptions(options);
    const objects = [];
    for (let i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], options));
    }
    return {
      type: 'FeatureCollection',
      features: objects,
    };
  }

  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(geometry, options) {
    return writeGeometry(geometry, this.adaptOptions(options));
  }
}

/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */
function readGeometry(object, options) {
  if (!object) {
    return null;
  }

  /**
   * @type {import("../geom/Geometry.js").default}
   */
  let geometry;
  switch (object['type']) {
    case 'Point': {
      geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));
      break;
    }
    case 'LineString': {
      geometry = readLineStringGeometry(
        /** @type {GeoJSONLineString} */ (object)
      );
      break;
    }
    case 'Polygon': {
      geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));
      break;
    }
    case 'MultiPoint': {
      geometry = readMultiPointGeometry(
        /** @type {GeoJSONMultiPoint} */ (object)
      );
      break;
    }
    case 'MultiLineString': {
      geometry = readMultiLineStringGeometry(
        /** @type {GeoJSONMultiLineString} */ (object)
      );
      break;
    }
    case 'MultiPolygon': {
      geometry = readMultiPolygonGeometry(
        /** @type {GeoJSONMultiPolygon} */ (object)
      );
      break;
    }
    case 'GeometryCollection': {
      geometry = readGeometryCollectionGeometry(
        /** @type {GeoJSONGeometryCollection} */ (object)
      );
      break;
    }
    default: {
      throw new Error('Unsupported GeoJSON type: ' + object['type']);
    }
  }
  return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_5__.transformGeometryWithOptions)(geometry, false, options);
}

/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {GeometryCollection} Geometry collection.
 */
function readGeometryCollectionGeometry(object, options) {
  const geometries = object['geometries'].map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */
    function (geometry) {
      return readGeometry(geometry, options);
    }
  );
  return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_6__["default"](geometries);
}

/**
 * @param {GeoJSONPoint} object Object.
 * @return {Point} Point.
 */
function readPointGeometry(object) {
  return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONLineString} object Object.
 * @return {LineString} LineString.
 */
function readLineStringGeometry(object) {
  return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_8__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {MultiLineString} MultiLineString.
 */
function readMultiLineStringGeometry(object) {
  return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {MultiPoint} MultiPoint.
 */
function readMultiPointGeometry(object) {
  return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {MultiPolygon} MultiPolygon.
 */
function readMultiPolygonGeometry(object) {
  return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_11__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONPolygon} object Object.
 * @return {Polygon} Polygon.
 */
function readPolygonGeometry(object) {
  return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](object['coordinates']);
}

/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeGeometry(geometry, options) {
  geometry = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_5__.transformGeometryWithOptions)(geometry, true, options);
  const type = geometry.getType();

  /** @type {GeoJSONGeometry} */
  let geoJSON;
  switch (type) {
    case 'Point': {
      geoJSON = writePointGeometry(/** @type {Point} */ (geometry), options);
      break;
    }
    case 'LineString': {
      geoJSON = writeLineStringGeometry(
        /** @type {LineString} */ (geometry),
        options
      );
      break;
    }
    case 'Polygon': {
      geoJSON = writePolygonGeometry(
        /** @type {Polygon} */ (geometry),
        options
      );
      break;
    }
    case 'MultiPoint': {
      geoJSON = writeMultiPointGeometry(
        /** @type {MultiPoint} */ (geometry),
        options
      );
      break;
    }
    case 'MultiLineString': {
      geoJSON = writeMultiLineStringGeometry(
        /** @type {MultiLineString} */ (geometry),
        options
      );
      break;
    }
    case 'MultiPolygon': {
      geoJSON = writeMultiPolygonGeometry(
        /** @type {MultiPolygon} */ (geometry),
        options
      );
      break;
    }
    case 'GeometryCollection': {
      geoJSON = writeGeometryCollectionGeometry(
        /** @type {GeometryCollection} */ (geometry),
        options
      );
      break;
    }
    case 'Circle': {
      geoJSON = {
        type: 'GeometryCollection',
        geometries: [],
      };
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return geoJSON;
}

/**
 * @param {GeometryCollection} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */
function writeGeometryCollectionGeometry(geometry, options) {
  options = Object.assign({}, options);
  delete options.featureProjection;
  const geometries = geometry.getGeometriesArray().map(function (geometry) {
    return writeGeometry(geometry, options);
  });
  return {
    type: 'GeometryCollection',
    geometries: geometries,
  };
}

/**
 * @param {LineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeLineStringGeometry(geometry, options) {
  return {
    type: 'LineString',
    coordinates: geometry.getCoordinates(),
  };
}

/**
 * @param {MultiLineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiLineStringGeometry(geometry, options) {
  return {
    type: 'MultiLineString',
    coordinates: geometry.getCoordinates(),
  };
}

/**
 * @param {MultiPoint} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiPointGeometry(geometry, options) {
  return {
    type: 'MultiPoint',
    coordinates: geometry.getCoordinates(),
  };
}

/**
 * @param {MultiPolygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiPolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: 'MultiPolygon',
    coordinates: geometry.getCoordinates(right),
  };
}

/**
 * @param {Point} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writePointGeometry(geometry, options) {
  return {
    type: 'Point',
    coordinates: geometry.getCoordinates(),
  };
}

/**
 * @param {Polygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writePolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: 'Polygon',
    coordinates: geometry.getCoordinates(right),
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoJSON);


/***/ }),

/***/ "./node_modules/ol/format/JSONFeature.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/format/Feature.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/format/JSONFeature
 */



/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @abstract
 */
class JSONFeature extends _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();
  }

  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return 'json';
  }

  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(source, options) {
    return this.readFeatureFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }

  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(source, options) {
    return this.readFeaturesFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }

  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(object, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromObject(object, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(source, options) {
    return this.readGeometryFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }

  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(object, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(source) {
    return this.readProjectionFromObject(getObject(source));
  }

  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(object) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(feature, options) {
    return JSON.stringify(this.writeFeatureObject(feature, options));
  }

  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(feature, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(features, options) {
    return JSON.stringify(this.writeFeaturesObject(features, options));
  }

  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(features, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(geometry, options) {
    return JSON.stringify(this.writeGeometryObject(geometry, options));
  }

  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(geometry, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }
}

/**
 * @param {Document|Element|Object|string} source Source.
 * @return {Object} Object.
 */
function getObject(source) {
  if (typeof source === 'string') {
    const object = JSON.parse(source);
    return object ? /** @type {Object} */ (object) : null;
  }
  if (source !== null) {
    return source;
  }
  return null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (JSONFeature);


/***/ }),

/***/ "./node_modules/ol/geom/Circle.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/Circle
 */





/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
class Circle extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(center, radius, layout) {
    super();
    if (layout !== undefined && radius === undefined) {
      this.setFlatCoordinates(layout, center);
    } else {
      radius = radius ? radius : 0;
      this.setCenterAndRadius(center, radius, layout);
    }
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const circle = new Circle(
      this.flatCoordinates.slice(),
      undefined,
      this.layout
    );
    circle.applyProperties(this);
    return circle;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const dx = x - flatCoordinates[0];
    const dy = y - flatCoordinates[1];
    const squaredDistance = dx * dx + dy * dy;
    if (squaredDistance < minSquaredDistance) {
      if (squaredDistance === 0) {
        for (let i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        const delta = this.getRadius() / Math.sqrt(squaredDistance);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;
        for (let i = 2; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      }
      closestPoint.length = this.stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const flatCoordinates = this.flatCoordinates;
    const dx = x - flatCoordinates[0];
    const dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  }

  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    const flatCoordinates = this.flatCoordinates;
    const radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdate)(
      flatCoordinates[0] - radius,
      flatCoordinates[1] - radius,
      flatCoordinates[0] + radius,
      flatCoordinates[1] + radius,
      extent
    );
  }

  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }

  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'Circle';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    const circleExtent = this.getExtent();
    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(extent, circleExtent)) {
      const center = this.getCenter();

      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }
      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }

      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.forEachCorner)(extent, this.intersectsCoordinate.bind(this));
    }
    return false;
  }

  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(center) {
    const stride = this.stride;
    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    const flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;
    for (let i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }
    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  }

  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(center, radius, layout) {
    this.setLayout(layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    /** @type {Array<number>} */
    const flatCoordinates = this.flatCoordinates;
    let offset = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_2__.deflateCoordinate)(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;
    for (let i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }
    flatCoordinates.length = offset;
    this.changed();
  }

  getCoordinates() {
    return null;
  }

  setCoordinates(coordinates, layout) {}

  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    const center = this.getCenter();
    const stride = this.getStride();
    this.setCenter(
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(center, 0, center.length, stride, angle, anchor, center)
    );
    this.changed();
  }
}

/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */
Circle.prototype.transform;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Circle);


/***/ }),

/***/ "./node_modules/ol/geom/flat/linechunk.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lineChunk: () => (/* binding */ lineChunk)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/math.js");


/**
 * Creates chunks of equal length from a linestring
 * @param {number} chunkLength Length of each chunk.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @return {Array<Array<number>>} Chunks of linestrings with stride 2.
 */
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
  const chunks = [];
  let cursor = offset;
  let chunkM = 0;
  let currentChunk = flatCoordinates.slice(offset, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    const [x1, y1] = currentChunk.slice(-2);
    const x2 = flatCoordinates[cursor + stride];
    const y2 = flatCoordinates[cursor + stride + 1];
    const segmentLength = Math.sqrt(
      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
    );
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      const m = (chunkLength - chunkM + segmentLength) / segmentLength;
      const x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, m);
      const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, m);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(
        flatCoordinates[cursor + stride],
        flatCoordinates[cursor + stride + 1]
      );
      cursor += stride;
    } else {
      const missing = segmentLength - chunkM;
      const x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, missing / segmentLength);
      const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, missing / segmentLength);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/straightchunk.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   matchingChunk: () => (/* binding */ matchingChunk)
/* harmony export */ });
/**
 * @module ol/geom/flat/straightchunk
 */

/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  let chunkStart = offset;
  let chunkEnd = offset;
  let chunkM = 0;
  let m = 0;
  let start = offset;
  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/textpath.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawTextOnPath: () => (/* binding */ drawTextOnPath)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/flat/textpath
 */



/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(
  flatCoordinates,
  offset,
  end,
  stride,
  text,
  startM,
  maxAngle,
  scale,
  measureAndCacheTextWidth,
  font,
  cache,
  rotation
) {
  let x2 = flatCoordinates[offset];
  let y2 = flatCoordinates[offset + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;

  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);

  let interpolate =
    segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
  const beginY = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate);

  const startOffset = offset - stride;
  const startLength = segmentM;
  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
  const endY = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate);

  // Keep text upright
  let reverse;
  if (rotation) {
    const flat = [beginX, beginY, endX, endY];
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.rotate)(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }

  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset;

  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];

  let previousAngle;
  // All on the same segment
  if (singleSegment) {
    advance();

    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x = (endX + beginX) / 2;
    const y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }

  // rendering across line segments
  text = text.replace(/\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines

  for (let i = 0, ii = text.length; i < ii; ) {
    advance();
    let angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== undefined) {
      let delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;

    const iStart = i;
    let charLength = 0;
    for (; i < ii; ++i) {
      const index = reverse ? ii - i - 1 : i;
      const len = scale * measureAndCacheTextWidth(font, text[index], cache);
      if (
        offset + stride < end &&
        segmentM + segmentLength < startM + charLength + len / 2
      ) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    const chars = reverse
      ? text.substring(ii - iStart, ii - i)
      : text.substring(iStart, i);
    interpolate =
      segmentLength === 0
        ? 0
        : (startM + charLength / 2 - segmentM) / segmentLength;
    const x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
    const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}


/***/ }),

/***/ "./node_modules/ol/interaction/Draw.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawEvent: () => (/* binding */ DrawEvent),
/* harmony export */   createBox: () => (/* binding */ createBox),
/* harmony export */   createRegularPolygon: () => (/* binding */ createRegularPolygon),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/ol/geom/Circle.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/geom/GeometryCollection.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/ol/interaction/Property.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/geom/LineString.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/math.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/coordinate.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./node_modules/ol/geom/SimpleGeometry.js");
/**
 * @module ol/interaction/Draw
 */


























/**
 * @typedef {Object} Options
 * @property {import("../geom/Geometry.js").Type} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean|import("../events/condition.js").Condition} [trace=false] Trace a portion of another geometry.
 * Ignored when in freehand mode.
 * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is
 * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with
 * either a `traceSource` or a `source`.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the draw interaction.
 */

/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */

/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */

/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */

/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */

/**
 * @typedef {Object} TraceState
 * @property {boolean} active Tracing active.
 * @property {import("../pixel.js").Pixel} [startPx] The initially clicked pixel location.
 * @property {Array<TraceTarget>} [targets] Targets available for tracing.
 * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates
 * that no trace target is active.
 */

/**
 * @typedef {Object} TraceTarget
 * @property {Array<import("../coordinate.js").Coordinate>} coordinates Target coordinates.
 * @property {boolean} ring The target coordinates are a linear ring.
 * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an
 * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).
 * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.
 */

/**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */

/**
 * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 */

/**
 * @enum {string}
 */
const DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend',
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: 'drawabort',
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */
class DrawEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(type, feature) {
    super(type);

    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */
    this.feature = feature;
  }
}

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {Array<Feature>} features The candidate features.
 * @return {Array<TraceTarget>} The trace targets.
 */
function getTraceTargets(coordinate, features) {
  /**
   * @type {Array<TraceTarget>}
   */
  const targets = [];

  for (let i = 0; i < features.length; ++i) {
    const feature = features[i];
    const geometry = feature.getGeometry();
    appendGeometryTraceTargets(coordinate, geometry, targets);
  }

  return targets;
}

/**
 * @param {import("../coordinate.js").Coordinate} a One coordinate.
 * @param {import("../coordinate.js").Coordinate} b Another coordinate.
 * @return {number} The squared distance between the two coordinates.
 */
function getSquaredDistance(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.squaredDistance)(a[0], a[1], b[0], b[1]);
}

/**
 * @param {LineCoordType} coordinates The ring coordinates.
 * @param {number} index The index.  May be wrapped.
 * @return {import("../coordinate.js").Coordinate} The coordinate.
 */
function getCoordinate(coordinates, index) {
  const count = coordinates.length;
  if (index < 0) {
    return coordinates[index + count];
  }
  if (index >= count) {
    return coordinates[index - count];
  }
  return coordinates[index];
}

/**
 * Get the cumulative squared distance along a ring path.  The end index index may be "wrapped" and it may
 * be less than the start index to indicate the direction of travel.  The start and end index may have
 * a fractional part to indicate a point between two coordinates.
 * @param {LineCoordType} coordinates Ring coordinates.
 * @param {number} startIndex The start index.
 * @param {number} endIndex The end index.
 * @return {number} The cumulative squared distance along the ring path.
 */
function getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {
  let lowIndex, highIndex;
  if (startIndex < endIndex) {
    lowIndex = startIndex;
    highIndex = endIndex;
  } else {
    lowIndex = endIndex;
    highIndex = startIndex;
  }
  const lowWholeIndex = Math.ceil(lowIndex);
  const highWholeIndex = Math.floor(highIndex);

  if (lowWholeIndex > highWholeIndex) {
    // both start and end are on the same segment
    const start = interpolateCoordinate(coordinates, lowIndex);
    const end = interpolateCoordinate(coordinates, highIndex);
    return getSquaredDistance(start, end);
  }

  let sd = 0;

  if (lowIndex < lowWholeIndex) {
    const start = interpolateCoordinate(coordinates, lowIndex);
    const end = getCoordinate(coordinates, lowWholeIndex);
    sd += getSquaredDistance(start, end);
  }

  if (highWholeIndex < highIndex) {
    const start = getCoordinate(coordinates, highWholeIndex);
    const end = interpolateCoordinate(coordinates, highIndex);
    sd += getSquaredDistance(start, end);
  }

  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {
    const start = getCoordinate(coordinates, i);
    const end = getCoordinate(coordinates, i + 1);
    sd += getSquaredDistance(start, end);
  }

  return sd;
}

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {import("../geom/Geometry.js").default} geometry The candidate geometry.
 * @param {Array<TraceTarget>} targets The trace targets.
 */
function appendGeometryTraceTargets(coordinate, geometry, targets) {
  if (geometry instanceof _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {
    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);
    return;
  }
  if (geometry instanceof _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__["default"]) {
    const coordinates = geometry.getCoordinates();
    for (let i = 0, ii = coordinates.length; i < ii; ++i) {
      appendTraceTarget(coordinate, coordinates[i], false, targets);
    }
    return;
  }
  if (geometry instanceof _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
    const coordinates = geometry.getCoordinates();
    for (let i = 0, ii = coordinates.length; i < ii; ++i) {
      appendTraceTarget(coordinate, coordinates[i], true, targets);
    }
    return;
  }
  if (geometry instanceof _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_6__["default"]) {
    const polys = geometry.getCoordinates();
    for (let i = 0, ii = polys.length; i < ii; ++i) {
      const coordinates = polys[i];
      for (let j = 0, jj = coordinates.length; j < jj; ++j) {
        appendTraceTarget(coordinate, coordinates[j], true, targets);
      }
    }
    return;
  }
  if (geometry instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_7__["default"]) {
    const geometries = geometry.getGeometries();
    for (let i = 0; i < geometries.length; ++i) {
      appendGeometryTraceTargets(coordinate, geometries[i], targets);
    }
    return;
  }
  // other types cannot be traced
}

/**
 * @typedef {Object} TraceTargetUpdateInfo
 * @property {number} index The new target index.
 * @property {number} endIndex The new segment end index.
 */

/**
 * @type {TraceTargetUpdateInfo}
 */
const sharedUpdateInfo = {index: -1, endIndex: NaN};

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {TraceState} traceState The trace state.
 * @param {import("../Map.js").default} map The map.
 * @param {number} snapTolerance The snap tolerance.
 * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned
 * object is reused between calls and must not be modified by the caller.
 */
function getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {
  const x = coordinate[0];
  const y = coordinate[1];

  let closestTargetDistance = Infinity;

  let newTargetIndex = -1;
  let newEndIndex = NaN;

  for (
    let targetIndex = 0;
    targetIndex < traceState.targets.length;
    ++targetIndex
  ) {
    const target = traceState.targets[targetIndex];
    const coordinates = target.coordinates;

    let minSegmentDistance = Infinity;
    let endIndex;
    for (
      let coordinateIndex = 0;
      coordinateIndex < coordinates.length - 1;
      ++coordinateIndex
    ) {
      const start = coordinates[coordinateIndex];
      const end = coordinates[coordinateIndex + 1];
      const rel = getPointSegmentRelationship(x, y, start, end);
      if (rel.squaredDistance < minSegmentDistance) {
        minSegmentDistance = rel.squaredDistance;
        endIndex = coordinateIndex + rel.along;
      }
    }

    if (minSegmentDistance < closestTargetDistance) {
      closestTargetDistance = minSegmentDistance;
      if (target.ring && traceState.targetIndex === targetIndex) {
        // same target, maintain the same trace direction
        if (target.endIndex > target.startIndex) {
          // forward trace
          if (endIndex < target.startIndex) {
            endIndex += coordinates.length;
          }
        } else if (target.endIndex < target.startIndex) {
          // reverse trace
          if (endIndex > target.startIndex) {
            endIndex -= coordinates.length;
          }
        }
      }
      newEndIndex = endIndex;
      newTargetIndex = targetIndex;
    }
  }

  const newTarget = traceState.targets[newTargetIndex];
  let considerBothDirections = newTarget.ring;
  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {
    // only consider switching trace direction if close to the start
    const newCoordinate = interpolateCoordinate(
      newTarget.coordinates,
      newEndIndex
    );
    const pixel = map.getPixelFromCoordinate(newCoordinate);
    if ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_8__.distance)(pixel, traceState.startPx) > snapTolerance) {
      considerBothDirections = false;
    }
  }

  if (considerBothDirections) {
    const coordinates = newTarget.coordinates;
    const count = coordinates.length;
    const startIndex = newTarget.startIndex;
    const endIndex = newEndIndex;
    if (startIndex < endIndex) {
      const forwardDistance = getCumulativeSquaredDistance(
        coordinates,
        startIndex,
        endIndex
      );
      const reverseDistance = getCumulativeSquaredDistance(
        coordinates,
        startIndex,
        endIndex - count
      );
      if (reverseDistance < forwardDistance) {
        newEndIndex -= count;
      }
    } else {
      const reverseDistance = getCumulativeSquaredDistance(
        coordinates,
        startIndex,
        endIndex
      );
      const forwardDistance = getCumulativeSquaredDistance(
        coordinates,
        startIndex,
        endIndex + count
      );
      if (forwardDistance < reverseDistance) {
        newEndIndex += count;
      }
    }
  }

  sharedUpdateInfo.index = newTargetIndex;
  sharedUpdateInfo.endIndex = newEndIndex;
  return sharedUpdateInfo;
}

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The clicked coordinate.
 * @param {Array<import("../coordinate.js").Coordinate>} coordinates The geometry component coordinates.
 * @param {boolean} ring The coordinates represent a linear ring.
 * @param {Array<TraceTarget>} targets The trace targets.
 */
function appendTraceTarget(coordinate, coordinates, ring, targets) {
  const x = coordinate[0];
  const y = coordinate[1];
  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
    const start = coordinates[i];
    const end = coordinates[i + 1];
    const rel = getPointSegmentRelationship(x, y, start, end);
    if (rel.squaredDistance === 0) {
      const index = i + rel.along;
      targets.push({
        coordinates: coordinates,
        ring: ring,
        startIndex: index,
        endIndex: index,
      });
      return;
    }
  }
}

/**
 * @typedef {Object} PointSegmentRelationship
 * @property {number} along The closest point expressed as a fraction along the segment length.
 * @property {number} squaredDistance The squared distance of the point to the segment.
 */

/**
 * @type {PointSegmentRelationship}
 */
const sharedRel = {along: 0, squaredDistance: 0};

/**
 * @param {number} x The point x.
 * @param {number} y The point y.
 * @param {import("../coordinate.js").Coordinate} start The segment start.
 * @param {import("../coordinate.js").Coordinate} end The segment end.
 * @return {PointSegmentRelationship} The point segment relationship.  The returned object is
 * shared between calls and must not be modified by the caller.
 */
function getPointSegmentRelationship(x, y, start, end) {
  const x1 = start[0];
  const y1 = start[1];
  const x2 = end[0];
  const y2 = end[1];
  const dx = x2 - x1;
  const dy = y2 - y1;
  let along = 0;
  let px = x1;
  let py = y1;
  if (dx !== 0 || dy !== 0) {
    along = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);
    px += dx * along;
    py += dy * along;
  }

  sharedRel.along = along;
  sharedRel.squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.toFixed)((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.squaredDistance)(x, y, px, py), 10);
  return sharedRel;
}

/**
 * @param {LineCoordType} coordinates The coordinates.
 * @param {number} index The index.  May be fractional and may wrap.
 * @return {import("../coordinate.js").Coordinate} The interpolated coordinate.
 */
function interpolateCoordinate(coordinates, index) {
  const count = coordinates.length;

  let startIndex = Math.floor(index);
  const along = index - startIndex;
  if (startIndex >= count) {
    startIndex -= count;
  } else if (startIndex < 0) {
    startIndex += count;
  }

  let endIndex = startIndex + 1;
  if (endIndex >= count) {
    endIndex -= count;
  }

  const start = coordinates[startIndex];
  const x0 = start[0];
  const y0 = start[1];
  const end = coordinates[endIndex];
  const dx = end[0] - x0;
  const dy = end[1] - y0;

  return [x0 + dx * along, y0 + dy * along];
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */

/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */
class Draw extends _Pointer_js__WEBPACK_IMPORTED_MODULE_9__["default"] {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    const pointerOptions = /** @type {import("./Pointer.js").Options} */ (
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_10__.FALSE;
    }

    super(pointerOptions);

    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {DrawOnSignature<void>}
     */
    this.un;

    /**
     * @type {boolean}
     * @private
     */
    this.shouldHandle_ = false;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.downPx_ = null;

    /**
     * @type {?}
     * @private
     */
    this.downTimeout_;

    /**
     * @type {number|undefined}
     * @private
     */
    this.lastDragTime_;

    /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */
    this.pointerType_;

    /**
     * @type {boolean}
     * @private
     */
    this.freehand_ = false;

    /**
     * Target source for drawn features.
     * @type {VectorSource|null}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>|null}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */
    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;

    /**
     * Geometry type.
     * @type {import("../geom/Geometry.js").Type}
     * @private
     */
    this.type_ = /** @type {import("../geom/Geometry.js").Type} */ (
      options.type
    );

    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */
    this.mode_ = getMode(this.type_);

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */
    this.stopClick_ = !!options.stopClick;

    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */
    this.minPoints_ = options.minPoints
      ? options.minPoints
      : this.mode_ === 'Polygon'
      ? 3
      : 2;

    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */
    this.maxPoints_ =
      this.mode_ === 'Circle'
        ? 2
        : options.maxPoints
        ? options.maxPoints
        : Infinity;

    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.finishCondition_ = options.finishCondition
      ? options.finishCondition
      : _functions_js__WEBPACK_IMPORTED_MODULE_10__.TRUE;

    /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */
    this.geometryLayout_ = options.geometryLayout
      ? options.geometryLayout
      : 'XY';

    let geometryFunction = options.geometryFunction;
    if (!geometryFunction) {
      const mode = this.mode_;
      if (mode === 'Circle') {
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function (coordinates, geometry, projection) {
          const circle = geometry
            ? /** @type {Circle} */ (geometry)
            : new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__["default"]([NaN, NaN]);
          const center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinates[0], projection);
          const squaredLength = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_8__.squaredDistance)(
            center,
            (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinates[coordinates.length - 1], projection)
          );
          circle.setCenterAndRadius(
            center,
            Math.sqrt(squaredLength),
            this.geometryLayout_
          );
          const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
          if (userProjection) {
            circle.transform(projection, userProjection);
          }
          return circle;
        };
      } else {
        let Constructor;
        if (mode === 'Point') {
          Constructor = _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__["default"];
        } else if (mode === 'LineString') {
          Constructor = _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__["default"];
        } else if (mode === 'Polygon') {
          Constructor = _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"];
        }
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function (coordinates, geometry, projection) {
          if (geometry) {
            if (mode === 'Polygon') {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates(
                  [coordinates[0].concat([coordinates[0][0]])],
                  this.geometryLayout_
                );
              } else {
                geometry.setCoordinates([], this.geometryLayout_);
              }
            } else {
              geometry.setCoordinates(coordinates, this.geometryLayout_);
            }
          } else {
            geometry = new Constructor(coordinates, this.geometryLayout_);
          }
          return geometry;
        };
      }
    }

    /**
     * @type {GeometryFunction}
     * @private
     */
    this.geometryFunction_ = geometryFunction;

    /**
     * @type {number}
     * @private
     */
    this.dragVertexDelay_ =
      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;

    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.finishCoordinate_ = null;

    /**
     * Sketch feature.
     * @type {Feature<import('../geom/SimpleGeometry.js').default>}
     * @private
     */
    this.sketchFeature_ = null;

    /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */
    this.sketchPoint_ = null;

    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */
    this.sketchCoords_ = null;

    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */
    this.sketchLine_ = null;

    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */
    this.sketchLineCoords_ = null;

    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */
    this.squaredClickTolerance_ = options.clickTolerance
      ? options.clickTolerance * options.clickTolerance
      : 36;

    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_14__["default"]({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false,
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileInteracting: true,
    });

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */
    this.geometryName_ = options.geometryName;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_15__.noModifierKeys;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.freehandCondition_;
    if (options.freehand) {
      this.freehandCondition_ = _events_condition_js__WEBPACK_IMPORTED_MODULE_15__.always;
    } else {
      this.freehandCondition_ = options.freehandCondition
        ? options.freehandCondition
        : _events_condition_js__WEBPACK_IMPORTED_MODULE_15__.shiftKeyOnly;
    }

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.traceCondition_;
    this.setTrace(options.trace || false);

    /**
     * @type {TraceState}
     * @private
     */
    this.traceState_ = {active: false};

    /**
     * @type {VectorSource|null}
     * @private
     */
    this.traceSource_ = options.traceSource || options.source || null;

    this.addChangeListener(_Property_js__WEBPACK_IMPORTED_MODULE_16__["default"].ACTIVE, this.updateState_);
  }

  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(trace) {
    let condition;
    if (!trace) {
      condition = _events_condition_js__WEBPACK_IMPORTED_MODULE_15__.never;
    } else if (trace === true) {
      condition = _events_condition_js__WEBPACK_IMPORTED_MODULE_15__.always;
    } else {
      condition = trace;
    }
    this.traceCondition_ = condition;
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(map) {
    super.setMap(map);
    this.updateState_();
  }

  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(event) {
    if (event.originalEvent.type === _events_EventType_js__WEBPACK_IMPORTED_MODULE_17__["default"].CONTEXTMENU) {
      // Avoid context menu for long taps when drawing on mobile
      event.originalEvent.preventDefault();
    }
    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);
    let move = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].POINTERMOVE;
    let pass = true;
    if (
      !this.freehand_ &&
      this.lastDragTime_ &&
      event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].POINTERDRAG
    ) {
      const now = Date.now();
      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = undefined;
      }
      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }
    }
    if (
      this.freehand_ &&
      event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].POINTERDRAG &&
      this.sketchFeature_ !== null
    ) {
      this.addToDrawing_(event.coordinate);
      pass = false;
    } else if (
      this.freehand_ &&
      event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].POINTERDOWN
    ) {
      pass = false;
    } else if (move && this.getPointerCount() < 2) {
      pass = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].POINTERMOVE;
      if (pass && this.freehand_) {
        this.handlePointerMove_(event);
        if (this.shouldHandle_) {
          // Avoid page scrolling when freehand drawing on mobile
          event.originalEvent.preventDefault();
        }
      } else if (
        event.originalEvent.pointerType === 'mouse' ||
        (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].POINTERDRAG &&
          this.downTimeout_ === undefined)
      ) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].DBLCLICK) {
      pass = false;
    }

    return super.handleEvent(event) && pass;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(event) {
    this.shouldHandle_ = !this.freehand_;

    if (this.freehand_) {
      this.downPx_ = event.pixel;
      if (!this.finishCoordinate_) {
        this.startDrawing_(event.coordinate);
      }
      return true;
    }

    if (!this.condition_(event)) {
      this.lastDragTime_ = undefined;
      return false;
    }

    this.lastDragTime_ = Date.now();
    this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(
        new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].POINTERMOVE,
          event.map,
          event.originalEvent,
          false,
          event.frameState
        )
      );
    }, this.dragVertexDelay_);
    this.downPx_ = event.pixel;
    return true;
  }

  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = {active: false};
  }

  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(event) {
    if (!this.traceSource_ || !this.traceCondition_(event)) {
      return;
    }

    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }

    const map = this.getMap();
    const lowerLeft = map.getCoordinateFromPixel([
      event.pixel[0] - this.snapTolerance_,
      event.pixel[1] + this.snapTolerance_,
    ]);
    const upperRight = map.getCoordinateFromPixel([
      event.pixel[0] + this.snapTolerance_,
      event.pixel[1] - this.snapTolerance_,
    ]);
    const extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_20__.boundingExtent)([lowerLeft, upperRight]);
    const features = this.traceSource_.getFeaturesInExtent(extent);
    if (features.length === 0) {
      return;
    }

    const targets = getTraceTargets(event.coordinate, features);
    if (targets.length) {
      this.traceState_ = {
        active: true,
        startPx: event.pixel.slice(),
        targets: targets,
        targetIndex: -1,
      };
    }
  }

  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(target, endIndex) {
    // three cases to handle:
    //  1. traced in the same direction and points need adding
    //  2. traced in the same direction and points need removing
    //  3. traced in a new direction
    const previouslyForward = target.startIndex <= target.endIndex;
    const currentlyForward = target.startIndex <= endIndex;
    if (previouslyForward === currentlyForward) {
      // same direction
      if (
        (previouslyForward && endIndex > target.endIndex) ||
        (!previouslyForward && endIndex < target.endIndex)
      ) {
        // case 1 - add new points
        this.addTracedCoordinates_(target, target.endIndex, endIndex);
      } else if (
        (previouslyForward && endIndex < target.endIndex) ||
        (!previouslyForward && endIndex > target.endIndex)
      ) {
        // case 2 - remove old points
        this.removeTracedCoordinates_(endIndex, target.endIndex);
      }
    } else {
      // case 3 - remove old points, add new points
      this.removeTracedCoordinates_(target.startIndex, target.endIndex);
      this.addTracedCoordinates_(target, target.startIndex, endIndex);
    }
  }

  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(fromIndex, toIndex) {
    if (fromIndex === toIndex) {
      return;
    }

    let remove = 0;
    if (fromIndex < toIndex) {
      const start = Math.ceil(fromIndex);
      let end = Math.floor(toIndex);
      if (end === toIndex) {
        end -= 1;
      }
      remove = end - start + 1;
    } else {
      const start = Math.floor(fromIndex);
      let end = Math.ceil(toIndex);
      if (end === toIndex) {
        end += 1;
      }
      remove = start - end + 1;
    }

    if (remove > 0) {
      this.removeLastPoints_(remove);
    }
  }

  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(target, fromIndex, toIndex) {
    if (fromIndex === toIndex) {
      return;
    }

    const coordinates = [];
    if (fromIndex < toIndex) {
      // forward trace
      const start = Math.ceil(fromIndex);
      let end = Math.floor(toIndex);
      if (end === toIndex) {
        // if end is snapped to a vertex, it will be added later
        end -= 1;
      }
      for (let i = start; i <= end; ++i) {
        coordinates.push(getCoordinate(target.coordinates, i));
      }
    } else {
      // reverse trace
      const start = Math.floor(fromIndex);
      let end = Math.ceil(toIndex);
      if (end === toIndex) {
        end += 1;
      }
      for (let i = start; i >= end; --i) {
        coordinates.push(getCoordinate(target.coordinates, i));
      }
    }
    if (coordinates.length) {
      this.appendCoordinates(coordinates);
    }
  }

  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(event) {
    const traceState = this.traceState_;
    if (!traceState.active) {
      return;
    }

    if (traceState.targetIndex === -1) {
      // check if we are ready to pick a target
      if ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_8__.distance)(traceState.startPx, event.pixel) < this.snapTolerance_) {
        return;
      }
    }

    const updatedTraceTarget = getTraceTargetUpdate(
      event.coordinate,
      traceState,
      this.getMap(),
      this.snapTolerance_
    );

    if (traceState.targetIndex !== updatedTraceTarget.index) {
      // target changed
      if (traceState.targetIndex !== -1) {
        // remove points added during previous trace
        const oldTarget = traceState.targets[traceState.targetIndex];
        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);
      }
      // add points for the new target
      const newTarget = traceState.targets[updatedTraceTarget.index];
      this.addTracedCoordinates_(
        newTarget,
        newTarget.startIndex,
        updatedTraceTarget.endIndex
      );
    } else {
      // target stayed the same
      const target = traceState.targets[traceState.targetIndex];
      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);
    }

    // modify the state with updated info
    traceState.targetIndex = updatedTraceTarget.index;
    const target = traceState.targets[traceState.targetIndex];
    target.endIndex = updatedTraceTarget.endIndex;

    // update event coordinate and pixel to match end point of final segment
    const coordinate = interpolateCoordinate(
      target.coordinates,
      target.endIndex
    );
    const pixel = this.getMap().getPixelFromCoordinate(coordinate);
    event.coordinate = coordinate;
    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(event) {
    let pass = true;

    if (this.getPointerCount() === 0) {
      if (this.downTimeout_) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }

      this.handlePointerMove_(event);
      const tracing = this.traceState_.active;
      this.toggleTraceState_(event);

      if (this.shouldHandle_) {
        const startingToDraw = !this.finishCoordinate_;
        if (startingToDraw) {
          this.startDrawing_(event.coordinate);
        }
        if (!startingToDraw && this.freehand_) {
          this.finishDrawing();
        } else if (
          !this.freehand_ &&
          (!startingToDraw || this.mode_ === 'Point')
        ) {
          if (this.atFinish_(event.pixel, tracing)) {
            if (this.finishCondition_(event)) {
              this.finishDrawing();
            }
          } else {
            this.addToDrawing_(event.coordinate);
          }
        }
        pass = false;
      } else if (this.freehand_) {
        this.abortDrawing();
      }
    }

    if (!pass && this.stopClick_) {
      event.preventDefault();
    }
    return pass;
  }

  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(event) {
    this.pointerType_ = event.originalEvent.pointerType;
    if (
      this.downPx_ &&
      ((!this.freehand_ && this.shouldHandle_) ||
        (this.freehand_ && !this.shouldHandle_))
    ) {
      const downPx = this.downPx_;
      const clickPx = event.pixel;
      const dx = downPx[0] - clickPx[0];
      const dy = downPx[1] - clickPx[1];
      const squaredDistance = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_
        ? squaredDistance > this.squaredClickTolerance_
        : squaredDistance <= this.squaredClickTolerance_;
      if (!this.shouldHandle_) {
        return;
      }
    }

    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(event.coordinate.slice());
      return;
    }

    this.updateTrace_(event);
    this.modifyDrawing_(event.coordinate);
  }

  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(pixel, tracing) {
    let at = false;
    if (this.sketchFeature_) {
      let potentiallyDone = false;
      let potentiallyFinishCoordinates = [this.finishCoordinate_];
      const mode = this.mode_;
      if (mode === 'Point') {
        at = true;
      } else if (mode === 'Circle') {
        at = this.sketchCoords_.length === 2;
      } else if (mode === 'LineString') {
        potentiallyDone =
          !tracing && this.sketchCoords_.length > this.minPoints_;
      } else if (mode === 'Polygon') {
        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [
          sketchCoords[0][0],
          sketchCoords[0][sketchCoords[0].length - 2],
        ];
        if (tracing) {
          potentiallyFinishCoordinates = [sketchCoords[0][0]];
        } else {
          potentiallyFinishCoordinates = [
            sketchCoords[0][0],
            sketchCoords[0][sketchCoords[0].length - 2],
          ];
        }
      }
      if (potentiallyDone) {
        const map = this.getMap();
        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
          const finishCoordinate = potentiallyFinishCoordinates[i];
          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          const dx = pixel[0] - finishPixel[0];
          const dy = pixel[1] - finishPixel[1];
          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
          if (at) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }
    return at;
  }

  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(coordinates) {
    if (!this.sketchPoint_) {
      this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_21__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__["default"](coordinates));
      this.updateSketchFeatures_();
    } else {
      const sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinates);
    }
  }

  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(geometry) {
    if (!this.sketchLine_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_21__["default"]();
    }
    const ring = geometry.getLinearRing(0);
    let sketchLineGeom = this.sketchLine_.getGeometry();
    if (!sketchLineGeom) {
      sketchLineGeom = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](
        ring.getFlatCoordinates(),
        ring.getLayout()
      );
      this.sketchLine_.setGeometry(sketchLineGeom);
    } else {
      sketchLineGeom.setFlatCoordinates(
        ring.getLayout(),
        ring.getFlatCoordinates()
      );
      sketchLineGeom.changed();
    }
  }

  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(start) {
    const projection = this.getMap().getView().getProjection();
    const stride = (0,_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_22__.getStrideForLayout)(this.geometryLayout_);
    while (start.length < stride) {
      start.push(0);
    }
    this.finishCoordinate_ = start;
    if (this.mode_ === 'Point') {
      this.sketchCoords_ = start.slice();
    } else if (this.mode_ === 'Polygon') {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
    }
    if (this.sketchLineCoords_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_21__["default"](new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.sketchLineCoords_));
    }
    const geometry = this.geometryFunction_(
      this.sketchCoords_,
      undefined,
      projection
    );
    this.sketchFeature_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_21__["default"]();
    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }
    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(
      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)
    );
  }

  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(coordinate) {
    const map = this.getMap();
    const geometry = this.sketchFeature_.getGeometry();
    const projection = map.getView().getProjection();
    const stride = (0,_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_22__.getStrideForLayout)(this.geometryLayout_);
    let coordinates, last;
    while (coordinate.length < stride) {
      coordinate.push(0);
    }
    if (this.mode_ === 'Point') {
      last = this.sketchCoords_;
    } else if (this.mode_ === 'Polygon') {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      last = coordinates[coordinates.length - 1];
      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
        // snap to finish
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }
    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(
      /** @type {!LineCoordType} */ (this.sketchCoords_),
      geometry,
      projection
    );
    if (this.sketchPoint_) {
      const sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinate);
    }
    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {
      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));
    } else if (this.sketchLineCoords_) {
      const sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }
    this.updateSketchFeatures_();
  }

  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */
  addToDrawing_(coordinate) {
    const geometry = this.sketchFeature_.getGeometry();
    const projection = this.getMap().getView().getProjection();
    let done;
    let coordinates;
    const mode = this.mode_;
    if (mode === 'LineString' || mode === 'Circle') {
      this.finishCoordinate_ = coordinate.slice();
      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (mode === 'Polygon') {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }
      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }
    this.createOrUpdateSketchPoint_(coordinate.slice());
    this.updateSketchFeatures_();
    if (done) {
      this.finishDrawing();
    }
  }

  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(n) {
    if (!this.sketchFeature_) {
      return;
    }
    const geometry = this.sketchFeature_.getGeometry();
    const projection = this.getMap().getView().getProjection();
    const mode = this.mode_;
    for (let i = 0; i < n; ++i) {
      let coordinates;
      if (mode === 'LineString' || mode === 'Circle') {
        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
        coordinates.splice(-2, 1);
        if (coordinates.length >= 2) {
          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
          const finishCoordinate = this.finishCoordinate_.slice();
          coordinates[coordinates.length - 1] = finishCoordinate;
          this.createOrUpdateSketchPoint_(finishCoordinate);
        }
        this.geometryFunction_(coordinates, geometry, projection);
        if (geometry.getType() === 'Polygon' && this.sketchLine_) {
          this.createOrUpdateCustomSketchLine_(
            /** @type {Polygon} */ (geometry)
          );
        }
      } else if (mode === 'Polygon') {
        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
        coordinates.splice(-2, 1);
        const sketchLineGeom = this.sketchLine_.getGeometry();
        if (coordinates.length >= 2) {
          const finishCoordinate = coordinates[coordinates.length - 2].slice();
          coordinates[coordinates.length - 1] = finishCoordinate;
          this.createOrUpdateSketchPoint_(finishCoordinate);
        }
        sketchLineGeom.setCoordinates(coordinates);
        this.geometryFunction_(this.sketchCoords_, geometry, projection);
      }

      if (coordinates.length === 1) {
        this.abortDrawing();
        break;
      }
    }

    this.updateSketchFeatures_();
  }

  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }

  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  finishDrawing() {
    const sketchFeature = this.abortDrawing_();
    if (!sketchFeature) {
      return;
    }
    let coordinates = this.sketchCoords_;
    const geometry = sketchFeature.getGeometry();
    const projection = this.getMap().getView().getProjection();
    if (this.mode_ === 'LineString') {
      // remove the redundant last point
      coordinates.pop();
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (this.mode_ === 'Polygon') {
      // remove the redundant last point in ring
      /** @type {PolyCoordType} */ (coordinates)[0].pop();
      this.geometryFunction_(coordinates, geometry, projection);
      coordinates = geometry.getCoordinates();
    }

    // cast multi-part geometries
    if (this.type_ === 'MultiPoint') {
      sketchFeature.setGeometry(
        new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_23__["default"]([/** @type {PointCoordType} */ (coordinates)])
      );
    } else if (this.type_ === 'MultiLineString') {
      sketchFeature.setGeometry(
        new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__["default"]([/** @type {LineCoordType} */ (coordinates)])
      );
    } else if (this.type_ === 'MultiPolygon') {
      sketchFeature.setGeometry(
        new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_6__["default"]([/** @type {PolyCoordType} */ (coordinates)])
      );
    }

    // First dispatch event to allow full set up of feature
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));

    // Then insert feature
    if (this.features_) {
      this.features_.push(sketchFeature);
    }
    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  }

  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const sketchFeature = this.sketchFeature_;
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchLine_ = null;
    this.overlay_.getSource().clear(true);
    this.deactivateTrace_();
    return sketchFeature;
  }

  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const sketchFeature = this.abortDrawing_();
    if (sketchFeature) {
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
  }

  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(coordinates) {
    const mode = this.mode_;
    const newDrawing = !this.sketchFeature_;
    if (newDrawing) {
      this.startDrawing_(coordinates[0]);
    }
    /** @type {LineCoordType} */
    let sketchCoords;
    if (mode === 'LineString' || mode === 'Circle') {
      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);
    } else if (mode === 'Polygon') {
      sketchCoords =
        this.sketchCoords_ && this.sketchCoords_.length
          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]
          : [];
    } else {
      return;
    }

    if (newDrawing) {
      sketchCoords.shift();
    }

    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
    sketchCoords.pop();

    // Append coordinate list
    for (let i = 0; i < coordinates.length; i++) {
      this.addToDrawing_(coordinates[i]);
    }

    const ending = coordinates[coordinates.length - 1];
    // Duplicate last coordinate for sketch drawing (cursor position)
    this.addToDrawing_(ending);
    this.modifyDrawing_(ending);
  }

  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(feature) {
    const geometry = feature.getGeometry();
    const lineString = geometry;
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    const last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_21__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__["default"](last));
    this.updateSketchFeatures_();
    this.dispatchEvent(
      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)
    );
  }

  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const sketchFeatures = [];
    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }
    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }
    const overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  }

  /**
   * @private
   */
  updateState_() {
    const map = this.getMap();
    const active = this.getActive();
    if (!map || !active) {
      this.abortDrawing();
    }
    this.overlay_.setMap(active ? map : null);
  }
}

/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  const styles = (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_24__.createEditingStyle)();
  return function (feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}

/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * {@link import("../geom/Circle.js").Circle} geometry.
 * @param {number} [sides] Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number} [angle] Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */
function createRegularPolygon(sides, angle) {
  return function (coordinates, geometry, projection) {
    const center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
      /** @type {LineCoordType} */ (coordinates)[0],
      projection
    );
    const end = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],
      projection
    );
    const radius = Math.sqrt((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_8__.squaredDistance)(center, end));
    geometry = geometry || (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__.fromCircle)(new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__["default"](center), sides);

    let internalAngle = angle;
    if (!angle && angle !== 0) {
      const x = end[0] - center[0];
      const y = end[1] - center[1];
      internalAngle = Math.atan2(y, x);
    }
    (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__.makeRegular)(
      /** @type {Polygon} */ (geometry),
      center,
      radius,
      internalAngle
    );

    const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
    if (userProjection) {
      geometry.transform(projection, userProjection);
    }
    return geometry;
  };
}

/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */
function createBox() {
  return function (coordinates, geometry, projection) {
    const extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_20__.boundingExtent)(
      /** @type {LineCoordType} */ ([
        coordinates[0],
        coordinates[coordinates.length - 1],
      ]).map(function (coordinate) {
        return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinate, projection);
      })
    );
    const boxCoordinates = [
      [
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_20__.getBottomLeft)(extent),
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_20__.getBottomRight)(extent),
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_20__.getTopRight)(extent),
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_20__.getTopLeft)(extent),
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_20__.getBottomLeft)(extent),
      ],
    ];
    if (geometry) {
      geometry.setCoordinates(boxCoordinates);
    } else {
      geometry = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](boxCoordinates);
    }
    const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
    if (userProjection) {
      geometry.transform(projection, userProjection);
    }
    return geometry;
  };
}

/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/Geometry.js").Type} type Geometry type.
 * @return {Mode} Drawing mode.
 */
function getMode(type) {
  switch (type) {
    case 'Point':
    case 'MultiPoint':
      return 'Point';
    case 'LineString':
    case 'MultiLineString':
      return 'LineString';
    case 'Polygon':
    case 'MultiPolygon':
      return 'Polygon';
    case 'Circle':
      return 'Circle';
    default:
      throw new Error('Invalid type: ' + type);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Draw);


/***/ }),

/***/ "./node_modules/ol/interaction/Modify.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModifyEvent: () => (/* binding */ ModifyEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/ol/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/structs/RBush.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/source/Vector.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/ol/coordinate.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/interaction/Modify
 */





















/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
const CIRCLE_CENTER_INDEX = 0;

/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
const CIRCLE_CIRCUMFERENCE_INDEX = 1;

const tempExtent = [0, 0, 0, 0];
const tempSegment = [];

/**
 * @enum {string}
 */
const ModifyEventType = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: 'modifystart',
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: 'modifyend',
};

/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth] Depth.
 * @property {Feature} feature Feature.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} [index] Index.
 * @property {Array<Array<number>>} segment Segment.
 * @property {Array<SegmentData>} [featureSegments] FeatureSegments.
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition.primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition.singleClick} with
 * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition.always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).
 * When using a style function, the point feature passed to the function will have a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the
 * pointer coordinate when clicked within the `pixelTolerance`.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */
class ModifyEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(type, features, mapBrowserEvent) {
    super(type);

    /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */
    this.features = features;

    /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */

/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerance`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */
class Modify extends _Pointer_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    super(/** @type {import("./Pointer.js").Options} */ (options));

    /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {ModifyOnSignature<void>}
     */
    this.un;

    /** @private */
    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__.primaryAction;

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultDeleteCondition_ = function (mapBrowserEvent) {
      return (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_3__.altKeyOnly)(mapBrowserEvent) && (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_3__.singleClick)(mapBrowserEvent);
    };

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.deleteCondition_ = options.deleteCondition
      ? options.deleteCondition
      : this.defaultDeleteCondition_;

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.insertVertexCondition_ = options.insertVertexCondition
      ? options.insertVertexCondition
      : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__.always;

    /**
     * Editing vertex.
     * @type {Feature<Point>}
     * @private
     */
    this.vertexFeature_ = null;

    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */
    this.vertexSegments_ = null;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.lastPixel_ = [0, 0];

    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */
    this.ignoreNextSingleClick_ = false;

    /**
     * @type {Collection<Feature>}
     * @private
     */
    this.featuresBeingModified_ = null;

    /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_4__["default"]();

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ =
      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;

    /**
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */
    this.changingFeature_ = false;

    /**
     * @type {Array}
     * @private
     */
    this.dragSegments_ = [];

    /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
        useSpatialIndex: false,
        wrapX: !!options.wrapX,
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true,
    });

    /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */
    this.SEGMENT_WRITERS_ = {
      'Point': this.writePointGeometry_.bind(this),
      'LineString': this.writeLineStringGeometry_.bind(this),
      'LinearRing': this.writeLineStringGeometry_.bind(this),
      'Polygon': this.writePolygonGeometry_.bind(this),
      'MultiPoint': this.writeMultiPointGeometry_.bind(this),
      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),
      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),
      'Circle': this.writeCircleGeometry_.bind(this),
      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),
    };

    /**
     * @type {VectorSource}
     * @private
     */
    this.source_ = null;

    /**
     * @type {boolean|import("../layer/BaseVector").default}
     */
    this.hitDetection_ = null;

    /** @type {Collection<Feature>} */
    let features;
    if (options.features) {
      features = options.features;
    } else if (options.source) {
      this.source_ = options.source;
      features = new _Collection_js__WEBPACK_IMPORTED_MODULE_7__["default"](this.source_.getFeatures());
      this.source_.addEventListener(
        _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].ADDFEATURE,
        this.handleSourceAdd_.bind(this)
      );
      this.source_.addEventListener(
        _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].REMOVEFEATURE,
        this.handleSourceRemove_.bind(this)
      );
    }
    if (!features) {
      throw new Error(
        'The modify interaction requires features, a source or a layer'
      );
    }
    if (options.hitDetection) {
      this.hitDetection_ = options.hitDetection;
    }

    /**
     * @type {Collection<Feature>}
     * @private
     */
    this.features_ = features;

    this.features_.forEach(this.addFeature_.bind(this));
    this.features_.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADD,
      this.handleFeatureAdd_.bind(this)
    );
    this.features_.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVE,
      this.handleFeatureRemove_.bind(this)
    );

    /**
     * @type {import("../MapBrowserEvent.js").default}
     * @private
     */
    this.lastPointerEvent_ = null;

    /**
     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
     * @type {Array<number>}
     */
    this.delta_ = [0, 0];

    /**
     * @private
     */
    this.snapToPointer_ =
      options.snapToPointer === undefined
        ? !this.hitDetection_
        : options.snapToPointer;
  }

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  addFeature_(feature) {
    const geometry = feature.getGeometry();
    if (geometry) {
      const writer = this.SEGMENT_WRITERS_[geometry.getType()];
      if (writer) {
        writer(feature, geometry);
      }
    }
    const map = this.getMap();
    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }
    feature.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_10__["default"].CHANGE, this.boundHandleFeatureChange_);
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */
  willModifyFeatures_(evt, segments) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new _Collection_js__WEBPACK_IMPORTED_MODULE_7__["default"]();
      const features = this.featuresBeingModified_.getArray();
      for (let i = 0, ii = segments.length; i < ii; ++i) {
        const segment = segments[i];
        for (let s = 0, ss = segment.length; s < ss; ++s) {
          const feature = segment[s].feature;
          if (feature && !features.includes(feature)) {
            this.featuresBeingModified_.push(feature);
          }
        }
      }
      if (this.featuresBeingModified_.getLength() === 0) {
        this.featuresBeingModified_ = null;
      } else {
        this.dispatchEvent(
          new ModifyEvent(
            ModifyEventType.MODIFYSTART,
            this.featuresBeingModified_,
            evt
          )
        );
      }
    }
  }

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeature_(feature) {
    this.removeFeatureSegmentData_(feature);
    // Remove the vertex feature if the collection of candidate features is empty.
    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    feature.removeEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_10__["default"].CHANGE,
      this.boundHandleFeatureChange_
    );
  }

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureSegmentData_(feature) {
    const rBush = this.rBush_;
    /** @type {Array<SegmentData>} */
    const nodesToRemove = [];
    rBush.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function (node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      }
    );
    for (let i = nodesToRemove.length - 1; i >= 0; --i) {
      const nodeToRemove = nodesToRemove[i];
      for (let j = this.dragSegments_.length - 1; j >= 0; --j) {
        if (this.dragSegments_[j][0] === nodeToRemove) {
          this.dragSegments_.splice(j, 1);
        }
      }
      rBush.remove(nodeToRemove);
    }
  }

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    super.setActive(active);
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(map) {
    this.overlay_.setMap(map);
    super.setMap(map);
  }

  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceAdd_(event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  }

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceRemove_(event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureAdd_(evt) {
    this.addFeature_(evt.element);
  }

  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(evt) {
    if (!this.changingFeature_) {
      const feature = /** @type {Feature} */ (evt.target);
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureRemove_(evt) {
    this.removeFeature_(evt.element);
  }

  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  writePointGeometry_(feature, geometry) {
    const coordinates = geometry.getCoordinates();

    /** @type {SegmentData} */
    const segmentData = {
      feature: feature,
      geometry: geometry,
      segment: [coordinates, coordinates],
    };

    this.rBush_.insert(geometry.getExtent(), segmentData);
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  writeMultiPointGeometry_(feature, geometry) {
    const points = geometry.getCoordinates();
    for (let i = 0, ii = points.length; i < ii; ++i) {
      const coordinates = points[i];

      /** @type {SegmentData} */
      const segmentData = {
        feature: feature,
        geometry: geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates],
      };

      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  writeLineStringGeometry_(feature, geometry) {
    const coordinates = geometry.getCoordinates();
    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      const segment = coordinates.slice(i, i + 2);

      /** @type {SegmentData} */
      const segmentData = {
        feature: feature,
        geometry: geometry,
        index: i,
        segment: segment,
      };

      this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)(segment), segmentData);
    }
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  writeMultiLineStringGeometry_(feature, geometry) {
    const lines = geometry.getCoordinates();
    for (let j = 0, jj = lines.length; j < jj; ++j) {
      const coordinates = lines[j];
      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        const segment = coordinates.slice(i, i + 2);

        /** @type {SegmentData} */
        const segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment,
        };

        this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)(segment), segmentData);
      }
    }
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  writePolygonGeometry_(feature, geometry) {
    const rings = geometry.getCoordinates();
    for (let j = 0, jj = rings.length; j < jj; ++j) {
      const coordinates = rings[j];
      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        const segment = coordinates.slice(i, i + 2);

        /** @type {SegmentData} */
        const segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment,
        };

        this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)(segment), segmentData);
      }
    }
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  writeMultiPolygonGeometry_(feature, geometry) {
    const polygons = geometry.getCoordinates();
    for (let k = 0, kk = polygons.length; k < kk; ++k) {
      const rings = polygons[k];
      for (let j = 0, jj = rings.length; j < jj; ++j) {
        const coordinates = rings[j];
        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          const segment = coordinates.slice(i, i + 2);

          /** @type {SegmentData} */
          const segmentData = {
            feature: feature,
            geometry: geometry,
            depth: [j, k],
            index: i,
            segment: segment,
          };

          this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)(segment), segmentData);
        }
      }
    }
  }

  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  writeCircleGeometry_(feature, geometry) {
    const coordinates = geometry.getCenter();

    /** @type {SegmentData} */
    const centerSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates],
    };

    /** @type {SegmentData} */
    const circumferenceSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates],
    };

    const featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = featureSegments;
    circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
    let circleGeometry = /** @type {import("../geom/Geometry.js").default} */ (
      geometry
    );
    const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
    if (userProjection && this.getMap()) {
      const projection = this.getMap().getView().getProjection();
      circleGeometry = circleGeometry
        .clone()
        .transform(userProjection, projection);
      circleGeometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__.fromCircle)(
        /** @type {import("../geom/Circle.js").default} */ (circleGeometry)
      ).transform(projection, userProjection);
    }
    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  writeGeometryCollectionGeometry_(feature, geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i = 0; i < geometries.length; ++i) {
      const geometry = geometries[i];
      const writer = this.SEGMENT_WRITERS_[geometry.getType()];
      writer(feature, geometry);
    }
  }

  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */
  createOrUpdateVertexFeature_(coordinates, features, geometries) {
    let vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_13__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_14__["default"](coordinates));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      const geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(coordinates);
    }
    vertexFeature.set('features', features);
    vertexFeature.set('geometries', geometries);
    return vertexFeature;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    this.lastPointerEvent_ = mapBrowserEvent;

    let handled;
    if (
      !mapBrowserEvent.map.getView().getInteracting() &&
      mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINTERMOVE &&
      !this.handlingDownUpSequence
    ) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (
        mapBrowserEvent.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_15__["default"].SINGLECLICK ||
        !this.ignoreNextSingleClick_
      ) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }

    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_15__["default"].SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }

    return super.handleEvent(mapBrowserEvent) && !handled;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */
  handleDragEvent(evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt, this.dragSegments_);

    const vertex = [
      evt.coordinate[0] + this.delta_[0],
      evt.coordinate[1] + this.delta_[1],
    ];
    const features = [];
    const geometries = [];
    for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
      const dragSegment = this.dragSegments_[i];
      const segmentData = dragSegment[0];
      const feature = segmentData.feature;
      if (!features.includes(feature)) {
        features.push(feature);
      }
      const geometry = segmentData.geometry;
      if (!geometries.includes(geometry)) {
        geometries.push(geometry);
      }
      const depth = segmentData.depth;
      let coordinates;
      const segment = segmentData.segment;
      const index = dragSegment[1];

      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index][vertex.length]);
      }

      switch (geometry.getType()) {
        case 'Point':
          coordinates = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case 'MultiPoint':
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index] = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case 'LineString':
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case 'MultiLineString':
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case 'Polygon':
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case 'MultiPolygon':
          coordinates = geometry.getCoordinates();
          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case 'Circle':
          segment[0] = vertex;
          segment[1] = vertex;
          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else {
            // We're dragging the circle's circumference:
            this.changingFeature_ = true;
            const projection = evt.map.getView().getProjection();
            let radius = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.distance)(
              (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(geometry.getCenter(), projection),
              (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(vertex, projection)
            );
            const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
            if (userProjection) {
              const circleGeometry = geometry
                .clone()
                .transform(userProjection, projection);
              circleGeometry.setRadius(radius);
              radius = circleGeometry
                .transform(projection, userProjection)
                .getRadius();
            }
            geometry.setRadius(radius);
            this.changingFeature_ = false;
          }
          break;
        default:
        // pass
      }

      if (coordinates) {
        this.setGeometryCoordinates_(geometry, coordinates);
      }
    }
    this.createOrUpdateVertexFeature_(vertex, features, geometries);
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(evt) {
    if (!this.condition_(evt)) {
      return false;
    }
    const pixelCoordinate = evt.coordinate;
    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
    this.dragSegments_.length = 0;
    this.featuresBeingModified_ = null;
    const vertexFeature = this.vertexFeature_;
    if (vertexFeature) {
      const projection = evt.map.getView().getProjection();
      const insertVertices = [];
      const vertex = vertexFeature.getGeometry().getCoordinates();
      const vertexExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)([vertex]);
      const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      const componentSegments = {};
      segmentDataMatches.sort(compareIndexes);
      for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
        const segmentDataMatch = segmentDataMatches[i];
        const segment = segmentDataMatch.segment;
        let uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(segmentDataMatch.geometry);
        const depth = segmentDataMatch.depth;
        if (depth) {
          uid += '-' + depth.join('-'); // separate feature components
        }
        if (!componentSegments[uid]) {
          componentSegments[uid] = new Array(2);
        }

        if (
          segmentDataMatch.geometry.getType() === 'Circle' &&
          segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX
        ) {
          const closestVertex = closestOnSegmentData(
            pixelCoordinate,
            segmentDataMatch,
            projection
          );
          if (
            (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestVertex, vertex) &&
            !componentSegments[uid][0]
          ) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          }
          continue;
        }

        if (
          (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(segment[0], vertex) &&
          !componentSegments[uid][0]
        ) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
          continue;
        }

        if (
          (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(segment[1], vertex) &&
          !componentSegments[uid][1]
        ) {
          if (
            componentSegments[uid][0] &&
            componentSegments[uid][0].index === 0
          ) {
            let coordinates = segmentDataMatch.geometry.getCoordinates();
            switch (segmentDataMatch.geometry.getType()) {
              // prevent dragging closed linestrings by the connecting node
              case 'LineString':
              case 'MultiLineString':
                continue;
              // if dragging the first vertex of a polygon, ensure the other segment
              // belongs to the closing vertex of the linear ring
              case 'MultiPolygon':
                coordinates = coordinates[depth[1]];
              /* falls through */
              case 'Polygon':
                if (
                  segmentDataMatch.index !==
                  coordinates[depth[0]].length - 2
                ) {
                  continue;
                }
                break;
              default:
              // pass
            }
          }

          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid][1] = segmentDataMatch;
          continue;
        }

        if (
          (0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(segment) in this.vertexSegments_ &&
          !componentSegments[uid][0] &&
          !componentSegments[uid][1] &&
          this.insertVertexCondition_(evt)
        ) {
          insertVertices.push(segmentDataMatch);
        }
      }

      if (insertVertices.length) {
        this.willModifyFeatures_(evt, [insertVertices]);
      }

      for (let j = insertVertices.length - 1; j >= 0; --j) {
        this.insertVertex_(insertVertices[j], vertex);
      }
    }
    return !!this.vertexFeature_;
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(evt) {
    for (let i = this.dragSegments_.length - 1; i >= 0; --i) {
      const segmentData = this.dragSegments_[i][0];
      const geometry = segmentData.geometry;
      if (geometry.getType() === 'Circle') {
        // Update a circle object in the R* bush:
        const coordinates = geometry.getCenter();
        const centerSegmentData = segmentData.featureSegments[0];
        const circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = coordinates;
        centerSegmentData.segment[1] = coordinates;
        circumferenceSegmentData.segment[0] = coordinates;
        circumferenceSegmentData.segment[1] = coordinates;
        this.rBush_.update((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
        let circleGeometry = geometry;
        const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
        if (userProjection) {
          const projection = evt.map.getView().getProjection();
          circleGeometry = circleGeometry
            .clone()
            .transform(userProjection, projection);
          circleGeometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__.fromCircle)(circleGeometry).transform(
            projection,
            userProjection
          );
        }
        this.rBush_.update(
          circleGeometry.getExtent(),
          circumferenceSegmentData
        );
      } else {
        this.rBush_.update((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)(segmentData.segment), segmentData);
      }
    }
    if (this.featuresBeingModified_) {
      this.dispatchEvent(
        new ModifyEvent(
          ModifyEventType.MODIFYEND,
          this.featuresBeingModified_,
          evt
        )
      );
      this.featuresBeingModified_ = null;
    }
    return false;
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  handlePointerMove_(evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
  }

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */
  handlePointerAtPixel_(pixel, map, coordinate) {
    const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);
    const projection = map.getView().getProjection();
    const sortByDistance = function (a, b) {
      return (
        projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -
        projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection)
      );
    };

    /** @type {Array<SegmentData>|undefined} */
    let nodes;
    /** @type {Point|undefined} */
    let hitPointGeometry;
    if (this.hitDetection_) {
      const layerFilter =
        typeof this.hitDetection_ === 'object'
          ? (layer) => layer === this.hitDetection_
          : undefined;
      map.forEachFeatureAtPixel(
        pixel,
        (feature, layer, geometry) => {
          if (geometry) {
            geometry = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_14__["default"](
              (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(geometry.getCoordinates(), projection)
            );
          }
          const geom = geometry || feature.getGeometry();
          if (
            geom.getType() === 'Point' &&
            feature instanceof _Feature_js__WEBPACK_IMPORTED_MODULE_13__["default"] &&
            this.features_.getArray().includes(feature)
          ) {
            hitPointGeometry = /** @type {Point} */ (geom);
            const coordinate = /** @type {Point} */ (feature.getGeometry())
              .getFlatCoordinates()
              .slice(0, 2);
            nodes = [
              {
                feature,
                geometry: hitPointGeometry,
                segment: [coordinate, coordinate],
              },
            ];
          }
          return true;
        },
        {layerFilter}
      );
    }
    if (!nodes) {
      const viewExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.createOrUpdateFromCoordinate)(pixelCoordinate, tempExtent),
        projection
      );
      const buffer = map.getView().getResolution() * this.pixelTolerance_;
      const box = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.buffer)(viewExtent, buffer, tempExtent),
        projection
      );
      nodes = this.rBush_.getInExtent(box);
    }

    if (nodes && nodes.length > 0) {
      const node = nodes.sort(sortByDistance)[0];
      const closestSegment = node.segment;
      let vertex = closestOnSegmentData(pixelCoordinate, node, projection);
      const vertexPixel = map.getPixelFromCoordinate(vertex);
      let dist = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.distance)(pixel, vertexPixel);
      if (hitPointGeometry || dist <= this.pixelTolerance_) {
        /** @type {Object<string, boolean>} */
        const vertexSegments = {};
        vertexSegments[(0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(closestSegment)] = true;

        if (!this.snapToPointer_) {
          this.delta_[0] = vertex[0] - pixelCoordinate[0];
          this.delta_[1] = vertex[1] - pixelCoordinate[1];
        }
        if (
          node.geometry.getType() === 'Circle' &&
          node.index === CIRCLE_CIRCUMFERENCE_INDEX
        ) {
          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(
            vertex,
            [node.feature],
            [node.geometry]
          );
        } else {
          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          const squaredDist1 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.squaredDistance)(vertexPixel, pixel1);
          const squaredDist2 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.squaredDistance)(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;
          if (this.snappedToVertex_) {
            vertex =
              squaredDist1 > squaredDist2
                ? closestSegment[1]
                : closestSegment[0];
          }
          this.createOrUpdateVertexFeature_(
            vertex,
            [node.feature],
            [node.geometry]
          );
          const geometries = {};
          geometries[(0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(node.geometry)] = true;
          for (let i = 1, ii = nodes.length; i < ii; ++i) {
            const segment = nodes[i].segment;
            if (
              ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestSegment[0], segment[0]) &&
                (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestSegment[1], segment[1])) ||
              ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestSegment[0], segment[1]) &&
                (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestSegment[1], segment[0]))
            ) {
              const geometryUid = (0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(nodes[i].geometry);
              if (!(geometryUid in geometries)) {
                geometries[geometryUid] = true;
                vertexSegments[(0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(segment)] = true;
              }
            } else {
              break;
            }
          }
        }

        this.vertexSegments_ = vertexSegments;
        return;
      }
    }
    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  }

  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  insertVertex_(segmentData, vertex) {
    const segment = segmentData.segment;
    const feature = segmentData.feature;
    const geometry = segmentData.geometry;
    const depth = segmentData.depth;
    const index = segmentData.index;
    let coordinates;

    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }

    switch (geometry.getType()) {
      case 'MultiLineString':
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case 'Polygon':
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case 'MultiPolygon':
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;
      case 'LineString':
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;
      default:
        return;
    }

    this.setGeometryCoordinates_(geometry, coordinates);
    const rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);

    /** @type {SegmentData} */
    const newSegmentData = {
      segment: [segment[0], vertex],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index,
    };

    rTree.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)(newSegmentData.segment), newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);

    /** @type {SegmentData} */
    const newSegmentData2 = {
      segment: [vertex, segment[1]],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index + 1,
    };

    rTree.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  }

  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  removePoint() {
    if (
      this.lastPointerEvent_ &&
      this.lastPointerEvent_.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINTERDRAG
    ) {
      const evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt, this.dragSegments_);
      const removed = this.removeVertex_();
      if (this.featuresBeingModified_) {
        this.dispatchEvent(
          new ModifyEvent(
            ModifyEventType.MODIFYEND,
            this.featuresBeingModified_,
            evt
          )
        );
      }

      this.featuresBeingModified_ = null;
      return removed;
    }
    return false;
  }

  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  removeVertex_() {
    const dragSegments = this.dragSegments_;
    const segmentsByFeature = {};
    let deleted = false;
    let component, coordinates, dragSegment, geometry, i, index, left;
    let newIndex, right, segmentData, uid;
    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(segmentData.feature);
      if (segmentData.depth) {
        // separate feature components
        uid += '-' + segmentData.depth.join('-');
      }
      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }
      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }
    }
    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;
      if (left !== undefined) {
        segmentData = left;
      } else {
        segmentData = right;
      }
      if (newIndex < 0) {
        newIndex = 0;
      }
      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;
      switch (geometry.getType()) {
        case 'MultiLineString':
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }
          break;
        case 'LineString':
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }
          break;
        case 'MultiPolygon':
          component = component[segmentData.depth[1]];
        /* falls through */
        case 'Polygon':
          component = component[segmentData.depth[0]];
          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }
            component.splice(index, 1);
            deleted = true;
            if (index === 0) {
              // close the ring again
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }
          break;
        default:
        // pass
      }

      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates);
        const segments = [];
        if (left !== undefined) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }
        if (right !== undefined) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }
        if (left !== undefined && right !== undefined) {
          /** @type {SegmentData} */
          const newSegmentData = {
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments,
          };

          this.rBush_.insert(
            (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.boundingExtent)(newSegmentData.segment),
            newSegmentData
          );
        }
        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        dragSegments.length = 0;
      }
    }
    return deleted;
  }

  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  setGeometryCoordinates_(geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  }

  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  updateSegmentIndices_(geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(
      geometry.getExtent(),
      function (segmentDataMatch) {
        if (
          segmentDataMatch.geometry === geometry &&
          (depth === undefined ||
            segmentDataMatch.depth === undefined ||
            (0,_array_js__WEBPACK_IMPORTED_MODULE_18__.equals)(segmentDataMatch.depth, depth)) &&
          segmentDataMatch.index > index
        ) {
          segmentDataMatch.index += delta;
        }
      }
    );
  }
}

/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */
function compareIndexes(a, b) {
  return a.index - b.index;
}

/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */
function projectedDistanceToSegmentDataSquared(
  pointCoordinates,
  segmentData,
  projection
) {
  const geometry = segmentData.geometry;

  if (geometry.getType() === 'Circle') {
    let circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
      geometry
    );

    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
      if (userProjection) {
        circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
          circleGeometry.clone().transform(userProjection, projection)
        );
      }
      const distanceToCenterSquared = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.squaredDistance)(
        circleGeometry.getCenter(),
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pointCoordinates, projection)
      );
      const distanceToCircumference =
        Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }

  const coordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pointCoordinates, projection);
  tempSegment[0] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[0], projection);
  tempSegment[1] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[1], projection);
  return (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.squaredDistanceToSegment)(coordinate, tempSegment);
}

/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */
function closestOnSegmentData(pointCoordinates, segmentData, projection) {
  const geometry = segmentData.geometry;

  if (
    geometry.getType() === 'Circle' &&
    segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX
  ) {
    let circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
      geometry
    );
    const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
    if (userProjection) {
      circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
        circleGeometry.clone().transform(userProjection, projection)
      );
    }
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(
      circleGeometry.getClosestPoint(
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pointCoordinates, projection)
      ),
      projection
    );
  }
  const coordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pointCoordinates, projection);
  tempSegment[0] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[0], projection);
  tempSegment[1] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[1], projection);
  return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(
    (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.closestOnSegment)(coordinate, tempSegment),
    projection
  );
}

/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  const style = (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_19__.createEditingStyle)();
  return function (feature, resolution) {
    return style['Point'];
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Modify);


/***/ }),

/***/ "./node_modules/ol/layer/BaseTile.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/Layer.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/layer/TileProperty.js");
/**
 * @module ol/layer/BaseTile
 */



/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */

/**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */
class BaseTileLayer extends _Layer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);

    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);

    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {BaseTileLayerOnSignature<void>}
     */
    this.un;

    this.setPreload(options.preload !== undefined ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== undefined
        ? options.useInterimTilesOnError
        : true
    );
  }

  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return /** @type {number} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRELOAD));
  }

  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRELOAD, preload);
  }

  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return /** @type {boolean} */ (
      this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_INTERIM_TILES_ON_ERROR)
    );
  }

  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }

  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(pixel) {
    return super.getData(pixel);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseTileLayer);


/***/ }),

/***/ "./node_modules/ol/layer/BaseVector.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/layer/Layer.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/rbush/rbush.min.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var _style_flat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/style/flat.js");
/**
 * @module ol/layer/BaseVector
 */





/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */
const Property = {
  RENDER_ORDER: 'renderOrder',
};

/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */
class BaseVectorLayer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);

    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);

    /**
     * @private
     * @type {boolean}
     */
    this.declutter_ =
      options.declutter !== undefined ? options.declutter : false;

    /**
     * @type {number}
     * @private
     */
    this.renderBuffer_ =
      options.renderBuffer !== undefined ? options.renderBuffer : 100;

    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */
    this.style_ = null;

    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */
    this.styleFunction_ = undefined;

    this.setStyle(options.style);

    /**
     * @type {boolean}
     * @private
     */
    this.updateWhileAnimating_ =
      options.updateWhileAnimating !== undefined
        ? options.updateWhileAnimating
        : false;

    /**
     * @type {boolean}
     * @private
     */
    this.updateWhileInteracting_ =
      options.updateWhileInteracting !== undefined
        ? options.updateWhileInteracting
        : false;
  }

  /**
   * @return {boolean} Declutter.
   */
  getDeclutter() {
    return this.declutter_;
  }

  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }

  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }

  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return /** @type {import("../render.js").OrderFunction|null|undefined} */ (
      this.get(Property.RENDER_ORDER)
    );
  }

  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }

  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }

  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }

  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }

  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(frameState) {
    if (!frameState.declutterTree) {
      frameState.declutterTree = new rbush__WEBPACK_IMPORTED_MODULE_0__(9);
    }
    /** @type {*} */ (this.getRenderer()).renderDeclutter(frameState);
  }

  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  }

  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(style) {
    /**
     * @type {import("../style/Style.js").StyleLike|null}
     */
    let styleLike;

    if (style === undefined) {
      styleLike = _style_Style_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultStyle;
    } else if (style === null) {
      styleLike = null;
    } else if (typeof style === 'function') {
      styleLike = style;
    } else if (style instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      styleLike = style;
    } else if (Array.isArray(style)) {
      const len = style.length;

      /**
       * @type {Array<Style>}
       */
      const styles = new Array(len);

      for (let i = 0; i < len; ++i) {
        const s = style[i];
        if (s instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          styles[i] = s;
        } else {
          styles[i] = (0,_style_flat_js__WEBPACK_IMPORTED_MODULE_3__.toStyle)(s);
        }
      }
      styleLike = styles;
    } else {
      styleLike = (0,_style_flat_js__WEBPACK_IMPORTED_MODULE_3__.toStyle)(style);
    }

    this.style_ = styleLike;
    this.styleFunction_ =
      style === null ? undefined : (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_2__.toFunction)(this.style_);
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseVectorLayer);


/***/ }),

/***/ "./node_modules/ol/layer/Heatmap.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseVector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/BaseVector.js");
/* harmony import */ var _renderer_webgl_PointsLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/webgl/PointsLayer.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/math.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/dom.js");
/**
 * @module ol/layer/Heatmap
 */





/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient
 * of the heatmap, specified as an array of CSS color strings.
 * @property {number} [radius=8] Radius size in pixels.
 * @property {number} [blur=15] Blur size in pixels.
 * @property {string|function(import("../Feature.js").default):number} [weight='weight'] The feature
 * attribute to use for the weight or a function that returns a weight from a feature. Weight values
 * should range from 0 to 1 (and values outside will be clamped to that range).
 * @property {import("../source/Vector.js").default<import("../geom/Point.js").default>} [source] Point source.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */
const Property = {
  BLUR: 'blur',
  GRADIENT: 'gradient',
  RADIUS: 'radius',
};

/**
 * @const
 * @type {Array<string>}
 */
const DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];

/**
 * @classdesc
 * Layer for rendering vector data as a heatmap.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @extends {BaseVector<import("../source/Vector.js").default, WebGLPointsLayerRenderer>}
 * @api
 */
class Heatmap extends _BaseVector_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);

    delete baseOptions.gradient;
    delete baseOptions.radius;
    delete baseOptions.blur;
    delete baseOptions.weight;
    super(baseOptions);

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.gradient_ = null;

    this.addChangeListener(Property.GRADIENT, this.handleGradientChanged_);

    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);

    this.setBlur(options.blur !== undefined ? options.blur : 15);

    this.setRadius(options.radius !== undefined ? options.radius : 8);

    const weight = options.weight ? options.weight : 'weight';
    if (typeof weight === 'string') {
      this.weightFunction_ = function (feature) {
        return feature.get(weight);
      };
    } else {
      this.weightFunction_ = weight;
    }

    // For performance reasons, don't sort the features before rendering.
    // The render order is not relevant for a heatmap representation.
    this.setRenderOrder(null);
  }

  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */
  getBlur() {
    return /** @type {number} */ (this.get(Property.BLUR));
  }

  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */
  getGradient() {
    return /** @type {Array<string>} */ (this.get(Property.GRADIENT));
  }

  /**
   * Return the size of the radius in pixels.
   * @return {number} Radius size in pixel.
   * @api
   * @observable
   */
  getRadius() {
    return /** @type {number} */ (this.get(Property.RADIUS));
  }

  /**
   * @private
   */
  handleGradientChanged_() {
    this.gradient_ = createGradient(this.getGradient());
  }

  /**
   * Set the blur size in pixels.
   * @param {number} blur Blur size in pixels.
   * @api
   * @observable
   */
  setBlur(blur) {
    this.set(Property.BLUR, blur);
  }

  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */
  setGradient(colors) {
    this.set(Property.GRADIENT, colors);
  }

  /**
   * Set the size of the radius in pixels.
   * @param {number} radius Radius size in pixel.
   * @api
   * @observable
   */
  setRadius(radius) {
    this.set(Property.RADIUS, radius);
  }

  createRenderer() {
    return new _renderer_webgl_PointsLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this, {
      className: this.getClassName(),
      attributes: [
        {
          name: 'weight',
          callback: (feature) => {
            const weight = this.weightFunction_(feature);
            return weight !== undefined ? (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(weight, 0, 1) : 1;
          },
        },
      ],
      vertexShader: `
        precision mediump float;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;
        attribute vec2 a_position;
        attribute float a_index;
        attribute float a_weight;

        varying vec2 v_texCoord;
        varying float v_weight;

        void main(void) {
          mat4 offsetMatrix = u_offsetScaleMatrix;
          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;
          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;
          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
          v_texCoord = vec2(u, v);
          v_weight = a_weight;
        }`,
      fragmentShader: `
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_weight;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_weight;
          gl_FragColor = vec4(alpha, alpha, alpha, alpha);
        }`,
      hitVertexShader: `
        precision mediump float;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;
        attribute vec2 a_position;
        attribute float a_index;
        attribute float a_weight;
        attribute vec4 a_hitColor;

        varying vec2 v_texCoord;
        varying float v_weight;
        varying vec4 v_hitColor;

        void main(void) {
          mat4 offsetMatrix = u_offsetScaleMatrix;
          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;
          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;
          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
          v_texCoord = vec2(u, v);
          v_hitColor = a_hitColor;
          v_weight = a_weight;
        }`,
      hitFragmentShader: `
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_weight;
        varying vec4 v_hitColor;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_weight;
          if (alpha < 0.05) {
            discard;
          }

          gl_FragColor = v_hitColor;
        }`,
      uniforms: {
        u_size: () => {
          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;
        },
        u_blurSlope: () => {
          return (
            this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR))
          );
        },
      },
      postProcesses: [
        {
          fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,
          uniforms: {
            u_gradientTexture: () => {
              return this.gradient_;
            },
            u_opacity: () => {
              return this.getOpacity();
            },
          },
        },
      ],
    });
  }

  renderDeclutter() {}
}

/**
 * @param {Array<string>} colors A list of colored.
 * @return {HTMLCanvasElement} canvas with gradient texture.
 */
function createGradient(colors) {
  const width = 1;
  const height = 256;
  const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(width, height);

  const gradient = context.createLinearGradient(0, 0, width, height);
  const step = 1 / (colors.length - 1);
  for (let i = 0, ii = colors.length; i < ii; ++i) {
    gradient.addColorStop(i * step, colors[i]);
  }

  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);

  return context.canvas;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Heatmap);


/***/ }),

/***/ "./node_modules/ol/layer/Tile.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseTile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/BaseTile.js");
/* harmony import */ var _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/canvas/TileLayer.js");
/**
 * @module ol/layer/Tile
 */



/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */
class TileLayer extends _BaseTile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }

  createRenderer() {
    return new _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileLayer);


/***/ }),

/***/ "./node_modules/ol/layer/TileProperty.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',
});


/***/ }),

/***/ "./node_modules/ol/layer/Vector.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseVector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/BaseVector.js");
/* harmony import */ var _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/canvas/VectorLayer.js");
/**
 * @module ol/layer/Vector
 */



/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */
class VectorLayer extends _BaseVector_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(options) {
    super(options);
  }

  createRenderer() {
    return new _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VectorLayer);


/***/ }),

/***/ "./node_modules/ol/layer/VectorImage.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseVector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/layer/BaseVector.js");
/* harmony import */ var _renderer_canvas_VectorImageLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/canvas/VectorImageLayer.js");
/**
 * @module ol/layer/VectorImage
 */



/**
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text on this layer. The priority is defined
 * by the `zIndex` of the style and the render order of features. Higher z-index means higher priority.
 * Within the same z-index, a feature rendered before another has higher priority.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the
 * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Vector data is rendered client-side, to an image. This layer type provides great performance
 * during panning and zooming, but point symbols and texts are always rotated with the view and
 * pixels are scaled during zoom animations. For more accurate rendering of vector data, use
 * {@link module:ol/layer/Vector~VectorLayer} instead.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorImageLayerRenderer>}
 * @api
 */
class VectorImageLayer extends _BaseVector_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);
    delete baseOptions.imageRatio;
    super(baseOptions);

    /**
     * @type {number}
     * @private
     */
    this.imageRatio_ =
      options.imageRatio !== undefined ? options.imageRatio : 1;
  }

  /**
   * @return {number} Ratio between rendered extent size and viewport extent size.
   */
  getImageRatio() {
    return this.imageRatio_;
  }

  createRenderer() {
    return new _renderer_canvas_VectorImageLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VectorImageLayer);


/***/ }),

/***/ "./node_modules/ol/loadingstrategy.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* binding */ all),
/* harmony export */   bbox: () => (/* binding */ bbox),
/* harmony export */   tile: () => (/* binding */ tile)
/* harmony export */ });
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/**
 * @module ol/loadingstrategy
 */



/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}

/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function bbox(extent, resolution) {
  return [extent];
}

/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */
function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function (extent, resolution, projection) {
      const z = tileGrid.getZForResolution(
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserResolution)(resolution, projection)
      );
      const tileRange = tileGrid.getTileRangeForExtentAndZ(
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(extent, projection),
        z
      );
      /** @type {Array<import("./extent.js").Extent>} */
      const extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */
      const tileCoord = [z, 0, 0];
      for (
        tileCoord[1] = tileRange.minX;
        tileCoord[1] <= tileRange.maxX;
        ++tileCoord[1]
      ) {
        for (
          tileCoord[2] = tileRange.minY;
          tileCoord[2] <= tileRange.maxY;
          ++tileCoord[2]
        ) {
          extents.push(
            (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(tileGrid.getTileCoordExtent(tileCoord), projection)
          );
        }
      }
      return extents;
    }
  );
}


/***/ }),

/***/ "./node_modules/ol/render/VectorContext.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
class VectorContext {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {}

  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(geometry) {}

  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(style) {}

  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawCircle(circleGeometry, feature) {}

  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */
  drawFeature(feature, style) {}

  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawGeometryCollection(geometryCollectionGeometry, feature) {}

  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(lineStringGeometry, feature) {}

  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(multiLineStringGeometry, feature) {}

  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(multiPointGeometry, feature) {}

  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(multiPolygonGeometry, feature) {}

  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(pointGeometry, feature) {}

  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(polygonGeometry, feature) {}

  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawText(geometry, feature) {}

  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {}

  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(imageStyle, declutterImageWithText) {}

  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(textStyle, declutterImageWithText) {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VectorContext);


/***/ }),

/***/ "./node_modules/ol/render/canvas/Builder.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent/Relationship.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/render/canvas.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/geom/flat/inflate.js");
/**
 * @module ol/render/canvas/Builder
 */









class CanvasBuilder extends _VectorContext_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super();

    /**
     * @protected
     * @type {number}
     */
    this.tolerance = tolerance;

    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent = maxExtent;

    /**
     * @protected
     * @type {number}
     */
    this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @type {number}
     */
    this.maxLineWidth = 0;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {Array<*>}
     */
    this.beginGeometryInstruction1_ = null;

    /**
     * @private
     * @type {Array<*>}
     */
    this.beginGeometryInstruction2_ = null;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.bufferedMaxExtent_ = null;

    /**
     * @protected
     * @type {Array<*>}
     */
    this.instructions = [];

    /**
     * @protected
     * @type {Array<number>}
     */
    this.coordinates = [];

    /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */
    this.tmpCoordinate_ = [];

    /**
     * @protected
     * @type {Array<*>}
     */
    this.hitDetectionInstructions = [];

    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */
    this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});
  }

  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(dashArray) {
    const pixelRatio = this.pixelRatio;
    return pixelRatio == 1
      ? dashArray
      : dashArray.map(function (dash) {
          return dash * pixelRatio;
        });
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(flatCoordinates, stride) {
    const extent = this.getBufferedMaxExtent();
    const tmpCoord = this.tmpCoordinate_;
    const coordinates = this.coordinates;
    let myEnd = coordinates.length;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      tmpCoord[0] = flatCoordinates[i];
      tmpCoord[1] = flatCoordinates[i + 1];
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsCoordinate)(extent, tmpCoord)) {
        coordinates[myEnd++] = tmpCoord[0];
        coordinates[myEnd++] = tmpCoord[1];
      }
    }
    return myEnd;
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(
    flatCoordinates,
    offset,
    end,
    stride,
    closed,
    skipFirst
  ) {
    const coordinates = this.coordinates;
    let myEnd = coordinates.length;
    const extent = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset += stride;
    }
    let lastXCoord = flatCoordinates[offset];
    let lastYCoord = flatCoordinates[offset + 1];
    const nextCoord = this.tmpCoordinate_;
    let skipped = true;

    let i, lastRel, nextRel;
    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.coordinateRelationship)(extent, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          coordinates[myEnd++] = lastXCoord;
          coordinates[myEnd++] = lastYCoord;
          skipped = false;
        }
        coordinates[myEnd++] = nextCoord[0];
        coordinates[myEnd++] = nextCoord[1];
      } else if (nextRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING) {
        coordinates[myEnd++] = nextCoord[0];
        coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    }

    // Last coordinate equals first or only one point to append:
    if ((closed && skipped) || i === offset + stride) {
      coordinates[myEnd++] = lastXCoord;
      coordinates[myEnd++] = lastYCoord;
    }
    return myEnd;
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const builderEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset,
        end,
        stride,
        false,
        false
      );
      builderEnds.push(builderEnd);
      offset = end;
    }
    return offset;
  }

  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
    this.beginGeometry(geometry, feature);

    const type = geometry.getType();
    const stride = geometry.getStride();
    const builderBegin = this.coordinates.length;

    let flatCoordinates, builderEnd, builderEnds, builderEndss;
    let offset;

    switch (type) {
      case 'MultiPolygon':
        flatCoordinates =
          /** @type {import("../../geom/MultiPolygon.js").default} */ (
            geometry
          ).getOrientedFlatCoordinates();
        builderEndss = [];
        const endss =
          /** @type {import("../../geom/MultiPolygon.js").default} */ (
            geometry
          ).getEndss();
        offset = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          const myEnds = [];
          offset = this.drawCustomCoordinates_(
            flatCoordinates,
            offset,
            endss[i],
            stride,
            myEnds
          );
          builderEndss.push(myEnds);
        }
        this.instructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateMultiCoordinatesArray,
        ]);
        this.hitDetectionInstructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          hitDetectionRenderer || renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateMultiCoordinatesArray,
        ]);
        break;
      case 'Polygon':
      case 'MultiLineString':
        builderEnds = [];
        flatCoordinates =
          type == 'Polygon'
            ? /** @type {import("../../geom/Polygon.js").default} */ (
                geometry
              ).getOrientedFlatCoordinates()
            : geometry.getFlatCoordinates();
        offset = this.drawCustomCoordinates_(
          flatCoordinates,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (
            geometry
          ).getEnds(),
          stride,
          builderEnds
        );
        this.instructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinatesArray,
        ]);
        this.hitDetectionInstructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          hitDetectionRenderer || renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinatesArray,
        ]);
        break;
      case 'LineString':
      case 'Circle':
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          false,
          false
        );
        this.instructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates,
        ]);
        this.hitDetectionInstructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates,
        ]);
        break;
      case 'MultiPoint':
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);

        if (builderEnd > builderBegin) {
          this.instructions.push([
            _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer,
            _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates,
          ]);
          this.hitDetectionInstructions.push([
            _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer,
            _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates,
          ]);
        }
        break;
      case 'Point':
        flatCoordinates = geometry.getFlatCoordinates();
        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
        builderEnd = this.coordinates.length;

        this.instructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
        ]);
        this.hitDetectionInstructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
        ]);
        break;
      default:
    }
    this.endGeometry(feature);
  }

  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  beginGeometry(geometry, feature) {
    this.beginGeometryInstruction1_ = [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY,
      feature,
      0,
      geometry,
    ];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY,
      feature,
      0,
      geometry,
    ];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates,
    };
  }

  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const hitDetectionInstructions = this.hitDetectionInstructions;
    // step 1 - reverse array
    hitDetectionInstructions.reverse();
    // step 2 - reverse instructions within geometry blocks
    let i;
    const n = hitDetectionInstructions.length;
    let instruction;
    let type;
    let begin = -1;
    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
      if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].END_GEOMETRY) {
        begin = i;
      } else if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY) {
        instruction[2] = i;
        (0,_array_js__WEBPACK_IMPORTED_MODULE_5__.reverseSubArray)(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  }

  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {
    const state = this.state;
    if (fillStyle) {
      const fillStyleColor = fillStyle.getColor();
      state.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(
        fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFillStyle
      );
    } else {
      state.fillStyle = undefined;
    }
    if (strokeStyle) {
      const strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(
        strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultStrokeStyle
      );
      const strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap =
        strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineCap;
      const strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash
        ? strokeStyleLineDash.slice()
        : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDash;
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset
        ? strokeStyleLineDashOffset
        : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDashOffset;
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin =
        strokeStyleLineJoin !== undefined
          ? strokeStyleLineJoin
          : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineJoin;
      const strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth =
        strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineWidth;
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit =
        strokeStyleMiterLimit !== undefined
          ? strokeStyleMiterLimit
          : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultMiterLimit;

      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        // invalidate the buffered max extent cache
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = undefined;
      state.lineCap = undefined;
      state.lineDash = null;
      state.lineDashOffset = undefined;
      state.lineJoin = undefined;
      state.lineWidth = undefined;
      state.miterLimit = undefined;
    }
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(state) {
    const fillStyle = state.fillStyle;
    /** @type {Array<*>} */
    const fillInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== 'string') {
      // Fill is a pattern or gradient - align it!
      fillInstruction.push(true);
    }
    return fillInstruction;
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(state) {
    this.instructions.push(this.createStroke(state));
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(state) {
    return [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth * this.pixelRatio,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      this.applyPixelRatio(state.lineDash),
      state.lineDashOffset * this.pixelRatio,
    ];
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(state, createFill) {
    const fillStyle = state.fillStyle;
    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
      if (fillStyle !== undefined) {
        this.instructions.push(createFill.call(this, state));
      }
      state.currentFillStyle = fillStyle;
    }
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(state, applyStroke) {
    const strokeStyle = state.strokeStyle;
    const lineCap = state.lineCap;
    const lineDash = state.lineDash;
    const lineDashOffset = state.lineDashOffset;
    const lineJoin = state.lineJoin;
    const lineWidth = state.lineWidth;
    const miterLimit = state.miterLimit;
    if (
      state.currentStrokeStyle != strokeStyle ||
      state.currentLineCap != lineCap ||
      (lineDash != state.currentLineDash &&
        !(0,_array_js__WEBPACK_IMPORTED_MODULE_5__.equals)(state.currentLineDash, lineDash)) ||
      state.currentLineDashOffset != lineDashOffset ||
      state.currentLineJoin != lineJoin ||
      state.currentLineWidth != lineWidth ||
      state.currentMiterLimit != miterLimit
    ) {
      if (strokeStyle !== undefined) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  }

  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    const endGeometryInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  }

  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.clone)(this.maxExtent);
      if (this.maxLineWidth > 0) {
        const width = (this.resolution * (this.maxLineWidth + 1)) / 2;
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/BuilderGroup.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _ImageBuilder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/render/canvas/ImageBuilder.js");
/* harmony import */ var _LineStringBuilder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/render/canvas/LineStringBuilder.js");
/* harmony import */ var _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/render/canvas/PolygonBuilder.js");
/* harmony import */ var _TextBuilder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/render/canvas/TextBuilder.js");
/**
 * @module ol/render/canvas/BuilderGroup
 */







/**
 * @type {Object<import("../canvas.js").BuilderType, typeof Builder>}
 */
const BATCH_CONSTRUCTORS = {
  'Circle': _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'Default': _Builder_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  'Image': _ImageBuilder_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  'LineString': _LineStringBuilder_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  'Polygon': _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'Text': _TextBuilder_js__WEBPACK_IMPORTED_MODULE_4__["default"],
};

class BuilderGroup {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, Builder>>}
     */
    this.buildersByZIndex_ = {};
  }

  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const builderInstructions = {};
    for (const zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      const builders = this.buildersByZIndex_[zKey];
      for (const builderKey in builders) {
        const builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }
    return builderInstructions;
  }

  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(zIndex, builderType) {
    const zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    let replays = this.buildersByZIndex_[zIndexKey];
    if (replays === undefined) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }
    let replay = replays[builderType];
    if (replay === undefined) {
      const Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      );
      replays[builderType] = replay;
    }
    return replay;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BuilderGroup);


/***/ }),

/***/ "./node_modules/ol/render/canvas/Executor.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/render/canvas/TextBuilder.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/render/canvas.js");
/* harmony import */ var _geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/geom/flat/textpath.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/render/canvas/Executor
 */










/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */

/**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */

/**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */

/**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * @type {import("../../extent.js").Extent}
 */
const tmpExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)();

/** @type {import("../../coordinate.js").Coordinate} */
const p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */
const p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */
const p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */
const p4 = [];

/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}

const rtlRegEx = new RegExp(
  /* eslint-disable prettier/prettier */
  '[' +
    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +
    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +
    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +
    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +
    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +
  ']'
  /* eslint-enable prettier/prettier */
);

/**
 * @param {string} text Text.
 * @param {CanvasTextAlign} align Alignment.
 * @return {number} Text alignment.
 */
function horizontalTextAlign(text, align) {
  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {
    align = align === 'start' ? 'left' : 'right';
  }
  return _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[align];
}

/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push('\n', '');
  }
  acc.push(line, '');
  return acc;
}

class Executor {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  constructor(resolution, pixelRatio, overlaps, instructions) {
    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;

    /**
     * @protected
     * @type {number}
     */
    this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {boolean}
     */
    this.alignFill_;

    /**
     * @protected
     * @type {Array<*>}
     */
    this.instructions = instructions.instructions;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.coordinates = instructions.coordinates;

    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */
    this.coordinateCache_ = {};

    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */
    this.renderedTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * @protected
     * @type {Array<*>}
     */
    this.hitDetectionInstructions = instructions.hitDetectionInstructions;

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = null;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = 0;

    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    this.fillStates = instructions.fillStates || {};

    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    this.strokeStates = instructions.strokeStates || {};

    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    this.textStates = instructions.textStates || {};

    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    this.widths_ = {};

    /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */
    this.labels_ = {};
  }

  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(text, textKey, fillKey, strokeKey) {
    const key = text + textKey + fillKey + strokeKey;
    if (this.labels_[key]) {
      return this.labels_[key];
    }
    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    const fillState = fillKey ? this.fillStates[fillKey] : null;
    const textState = this.textStates[textKey];
    const pixelRatio = this.pixelRatio;
    const scale = [
      textState.scale[0] * pixelRatio,
      textState.scale[1] * pixelRatio,
    ];
    const textIsArray = Array.isArray(text);
    const align = textState.justify
      ? _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[textState.justify]
      : horizontalTextAlign(
          Array.isArray(text) ? text[0] : text,
          textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextAlign
        );
    const strokeWidth =
      strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;

    const chunks = textIsArray
      ? text
      : text.split('\n').reduce(createTextChunks, []);

    const {width, height, widths, heights, lineWidths} = (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.getTextDimensions)(
      textState,
      chunks
    );
    const renderWidth = width + strokeWidth;
    const contextInstructions = [];
    // make canvas 2 pixels wider to account for italic text width measurement errors
    const w = (renderWidth + 2) * scale[0];
    const h = (height + strokeWidth) * scale[1];
    /** @type {import("../canvas.js").Label} */
    const label = {
      width: w < 0 ? Math.floor(w) : Math.ceil(w),
      height: h < 0 ? Math.floor(h) : Math.ceil(h),
      contextInstructions: contextInstructions,
    };
    if (scale[0] != 1 || scale[1] != 1) {
      contextInstructions.push('scale', scale);
    }
    if (strokeKey) {
      contextInstructions.push('strokeStyle', strokeState.strokeStyle);
      contextInstructions.push('lineWidth', strokeWidth);
      contextInstructions.push('lineCap', strokeState.lineCap);
      contextInstructions.push('lineJoin', strokeState.lineJoin);
      contextInstructions.push('miterLimit', strokeState.miterLimit);
      contextInstructions.push('setLineDash', [strokeState.lineDash]);
      contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
    }
    if (fillKey) {
      contextInstructions.push('fillStyle', fillState.fillStyle);
    }
    contextInstructions.push('textBaseline', 'middle');
    contextInstructions.push('textAlign', 'center');
    const leftRight = 0.5 - align;
    let x = align * renderWidth + leftRight * strokeWidth;
    const strokeInstructions = [];
    const fillInstructions = [];
    let lineHeight = 0;
    let lineOffset = 0;
    let widthHeightIndex = 0;
    let lineWidthIndex = 0;
    let previousFont;
    for (let i = 0, ii = chunks.length; i < ii; i += 2) {
      const text = chunks[i];
      if (text === '\n') {
        lineOffset += lineHeight;
        lineHeight = 0;
        x = align * renderWidth + leftRight * strokeWidth;
        ++lineWidthIndex;
        continue;
      }
      const font = chunks[i + 1] || textState.font;
      if (font !== previousFont) {
        if (strokeKey) {
          strokeInstructions.push('font', font);
        }
        if (fillKey) {
          fillInstructions.push('font', font);
        }
        previousFont = font;
      }
      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
      const fillStrokeArgs = [
        text,
        x +
          leftRight * widths[widthHeightIndex] +
          align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
        0.5 * (strokeWidth + lineHeight) + lineOffset,
      ];
      x += widths[widthHeightIndex];
      if (strokeKey) {
        strokeInstructions.push('strokeText', fillStrokeArgs);
      }
      if (fillKey) {
        fillInstructions.push('fillText', fillStrokeArgs);
      }
      ++widthHeightIndex;
    }
    Array.prototype.push.apply(contextInstructions, strokeInstructions);
    Array.prototype.push.apply(contextInstructions, fillInstructions);
    this.labels_[key] = label;
    return label;
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(
    context,
    p1,
    p2,
    p3,
    p4,
    fillInstruction,
    strokeInstruction
  ) {
    context.beginPath();
    context.moveTo.apply(context, p1);
    context.lineTo.apply(context, p2);
    context.lineTo.apply(context, p3);
    context.lineTo.apply(context, p4);
    context.lineTo.apply(context, p1);
    if (fillInstruction) {
      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
      this.fill_(context);
    }
    if (strokeInstruction) {
      this.setStrokeStyle_(
        context,
        /** @type {Array<*>} */ (strokeInstruction)
      );
      context.stroke();
    }
  }

  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(
    sheetWidth,
    sheetHeight,
    centerX,
    centerY,
    width,
    height,
    anchorX,
    anchorY,
    originX,
    originY,
    rotation,
    scale,
    snapToPixel,
    padding,
    fillStroke,
    feature
  ) {
    anchorX *= scale[0];
    anchorY *= scale[1];
    let x = centerX - anchorX;
    let y = centerY - anchorY;

    const w = width + originX > sheetWidth ? sheetWidth - originX : width;
    const h = height + originY > sheetHeight ? sheetHeight - originY : height;
    const boxW = padding[3] + w * scale[0] + padding[1];
    const boxH = padding[0] + h * scale[1] + padding[2];
    const boxX = x - padding[3];
    const boxY = y - padding[0];

    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }

    let transform;
    if (rotation !== 0) {
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)(),
        centerX,
        centerY,
        1,
        1,
        rotation,
        -centerX,
        -centerY
      );

      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p1);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p2);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p3);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p4);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdate)(
        Math.min(p1[0], p2[0], p3[0], p4[0]),
        Math.min(p1[1], p2[1], p3[1], p4[1]),
        Math.max(p1[0], p2[0], p3[0], p4[0]),
        Math.max(p1[1], p2[1], p3[1], p4[1]),
        tmpExtent
      );
    } else {
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdate)(
        Math.min(boxX, boxX + boxW),
        Math.min(boxY, boxY + boxH),
        Math.max(boxX, boxX + boxW),
        Math.max(boxY, boxY + boxH),
        tmpExtent
      );
    }
    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }
    return {
      drawImageX: x,
      drawImageY: y,
      drawImageW: w,
      drawImageH: h,
      originX: originX,
      originY: originY,
      declutterBox: {
        minX: tmpExtent[0],
        minY: tmpExtent[1],
        maxX: tmpExtent[2],
        maxY: tmpExtent[3],
        value: feature,
      },
      canvasTransform: transform,
      scale: scale,
    };
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(
    context,
    contextScale,
    imageOrLabel,
    dimensions,
    opacity,
    fillInstruction,
    strokeInstruction
  ) {
    const fillStroke = !!(fillInstruction || strokeInstruction);

    const box = dimensions.declutterBox;
    const canvas = context.canvas;
    const strokePadding = strokeInstruction
      ? (strokeInstruction[2] * dimensions.scale[0]) / 2
      : 0;
    const intersects =
      box.minX - strokePadding <= canvas.width / contextScale &&
      box.maxX + strokePadding >= 0 &&
      box.minY - strokePadding <= canvas.height / contextScale &&
      box.maxY + strokePadding >= 0;

    if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(
          context,
          p1,
          p2,
          p3,
          p4,
          /** @type {Array<*>} */ (fillInstruction),
          /** @type {Array<*>} */ (strokeInstruction)
        );
      }
      (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.drawImageOrLabel)(
        context,
        dimensions.canvasTransform,
        opacity,
        imageOrLabel,
        dimensions.originX,
        dimensions.originY,
        dimensions.drawImageW,
        dimensions.drawImageH,
        dimensions.drawImageX,
        dimensions.drawImageY,
        dimensions.scale
      );
    }
    return true;
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(context) {
    if (this.alignFill_) {
      const origin = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(this.renderedTransform_, [0, 0]);
      const repeatSize = 512 * this.pixelRatio;
      context.save();
      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }
    context.fill();
    if (this.alignFill_) {
      context.restore();
    }
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(context, instruction) {
    context['strokeStyle'] =
      /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
    context.lineWidth = /** @type {number} */ (instruction[2]);
    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
    context.miterLimit = /** @type {number} */ (instruction[5]);
    context.lineDashOffset = /** @type {number} */ (instruction[7]);
    context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
  }

  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
    const textState = this.textStates[textKey];

    const label = this.createLabel(text, textKey, fillKey, strokeKey);

    const strokeState = this.strokeStates[strokeKey];
    const pixelRatio = this.pixelRatio;
    const align = horizontalTextAlign(
      Array.isArray(text) ? text[0] : text,
      textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextAlign
    );
    const baseline = _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[textState.textBaseline || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextBaseline];
    const strokeWidth =
      strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

    // Remove the 2 pixels we added in createLabel() for the anchor
    const width = label.width / pixelRatio - 2 * textState.scale[0];
    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    const anchorY =
      (baseline * label.height) / pixelRatio +
      2 * (0.5 - baseline) * strokeWidth;

    return {
      label: label,
      anchorX: anchorX,
      anchorY: anchorY,
    };
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(
    context,
    contextScale,
    transform,
    instructions,
    snapToPixel,
    featureCallback,
    hitExtent,
    declutterTree
  ) {
    /** @type {Array<number>} */
    let pixelCoordinates;
    if (this.pixelCoordinates_ && (0,_array_js__WEBPACK_IMPORTED_MODULE_4__.equals)(transform, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__.transform2D)(
        this.coordinates,
        0,
        this.coordinates.length,
        2,
        transform,
        this.pixelCoordinates_
      );
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.setFromArray)(this.renderedTransform_, transform);
    }
    let i = 0; // instruction index
    const ii = instructions.length; // end of instructions
    let d = 0; // data index
    let dd; // end of per-instruction data
    let anchorX,
      anchorY,
      prevX,
      prevY,
      roundX,
      roundY,
      image,
      text,
      textKey,
      strokeKey,
      fillKey;
    let pendingFill = 0;
    let pendingStroke = 0;
    let lastFillInstruction = null;
    let lastStrokeInstruction = null;
    const coordinateCache = this.coordinateCache_;
    const viewRotation = this.viewRotation_;
    const viewRotationFromTransform =
      Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;

    const state = /** @type {import("../../render.js").State} */ ({
      context: context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation,
    });

    // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.
    const batchSize =
      this.instructions != instructions || this.overlaps ? 0 : 200;
    let /** @type {import("../../Feature.js").FeatureLike} */ feature;
    let x, y, currentGeometry;
    while (i < ii) {
      const instruction = instructions[i];
      const type = /** @type {import("./Instruction.js").default} */ (
        instruction[0]
      );
      switch (type) {
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].BEGIN_GEOMETRY:
          feature = /** @type {import("../../Feature.js").FeatureLike} */ (
            instruction[1]
          );
          currentGeometry = instruction[3];
          if (!feature.getGeometry()) {
            i = /** @type {number} */ (instruction[2]);
          } else if (
            hitExtent !== undefined &&
            !(0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersects)(hitExtent, currentGeometry.getExtent())
          ) {
            i = /** @type {number} */ (instruction[2]) + 1;
          } else {
            ++i;
          }
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = NaN;
            prevY = NaN;
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].CIRCLE:
          d = /** @type {number} */ (instruction[1]);
          const x1 = pixelCoordinates[d];
          const y1 = pixelCoordinates[d + 1];
          const x2 = pixelCoordinates[d + 2];
          const y2 = pixelCoordinates[d + 3];
          const dx = x2 - x1;
          const dy = y2 - y1;
          const r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLOSE_PATH:
          context.closePath();
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].CUSTOM:
          d = /** @type {number} */ (instruction[1]);
          dd = instruction[2];
          const geometry =
            /** @type {import("../../geom/SimpleGeometry.js").default} */ (
              instruction[3]
            );
          const renderer = instruction[4];
          const fn = instruction.length == 6 ? instruction[5] : undefined;
          state.geometry = geometry;
          state.feature = feature;
          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }
          const coords = coordinateCache[i];
          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }
          renderer(coords, state);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].DRAW_IMAGE:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          image =
            /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (
              instruction[3]
            );

          // Remaining arguments in DRAW_IMAGE are in alphabetical order
          anchorX = /** @type {number} */ (instruction[4]);
          anchorY = /** @type {number} */ (instruction[5]);
          let height = /** @type {number} */ (instruction[6]);
          const opacity = /** @type {number} */ (instruction[7]);
          const originX = /** @type {number} */ (instruction[8]);
          const originY = /** @type {number} */ (instruction[9]);
          const rotateWithView = /** @type {boolean} */ (instruction[10]);
          let rotation = /** @type {number} */ (instruction[11]);
          const scale = /** @type {import("../../size.js").Size} */ (
            instruction[12]
          );
          let width = /** @type {number} */ (instruction[13]);
          const declutterMode =
            /** @type {"declutter"|"obstacle"|"none"|undefined} */ (
              instruction[14]
            );
          const declutterImageWithText =
            /** @type {import("../canvas.js").DeclutterImageWithText} */ (
              instruction[15]
            );

          if (!image && instruction.length >= 20) {
            // create label images
            text = /** @type {string} */ (instruction[19]);
            textKey = /** @type {string} */ (instruction[20]);
            strokeKey = /** @type {string} */ (instruction[21]);
            fillKey = /** @type {string} */ (instruction[22]);
            const labelWithAnchor = this.drawLabelWithPointPlacement_(
              text,
              textKey,
              strokeKey,
              fillKey
            );
            image = labelWithAnchor.label;
            instruction[3] = image;
            const textOffsetX = /** @type {number} */ (instruction[23]);
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            const textOffsetY = /** @type {number} */ (instruction[24]);
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image.height;
            instruction[6] = height;
            width = image.width;
            instruction[13] = width;
          }

          let geometryWidths;
          if (instruction.length > 25) {
            geometryWidths = /** @type {number} */ (instruction[25]);
          }

          let padding, backgroundFill, backgroundStroke;
          if (instruction.length > 17) {
            padding = /** @type {Array<number>} */ (instruction[16]);
            backgroundFill = /** @type {boolean} */ (instruction[17]);
            backgroundStroke = /** @type {boolean} */ (instruction[18]);
          } else {
            padding = _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding;
            backgroundFill = false;
            backgroundStroke = false;
          }

          if (rotateWithView && viewRotationFromTransform) {
            // Canvas is expected to be rotated to reverse view rotation.
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            // Canvas is not rotated, images need to be rotated back to be north-up.
            rotation -= viewRotation;
          }
          let widthIndex = 0;
          for (; d < dd; d += 2) {
            if (
              geometryWidths &&
              geometryWidths[widthIndex++] < width / this.pixelRatio
            ) {
              continue;
            }
            const dimensions = this.calculateImageOrLabelDimensions_(
              image.width,
              image.height,
              pixelCoordinates[d],
              pixelCoordinates[d + 1],
              width,
              height,
              anchorX,
              anchorY,
              originX,
              originY,
              rotation,
              scale,
              snapToPixel,
              padding,
              backgroundFill || backgroundStroke,
              feature
            );
            /** @type {ReplayImageOrLabelArgs} */
            const args = [
              context,
              contextScale,
              image,
              dimensions,
              opacity,
              backgroundFill
                ? /** @type {Array<*>} */ (lastFillInstruction)
                : null,
              backgroundStroke
                ? /** @type {Array<*>} */ (lastStrokeInstruction)
                : null,
            ];
            if (declutterTree) {
              if (declutterMode === 'none') {
                // not rendered in declutter group
                continue;
              } else if (declutterMode === 'obstacle') {
                // will always be drawn, thus no collision detection, but insert as obstacle
                declutterTree.insert(dimensions.declutterBox);
                continue;
              } else {
                let imageArgs;
                let imageDeclutterBox;
                if (declutterImageWithText) {
                  const index = dd - d;
                  if (!declutterImageWithText[index]) {
                    // We now have the image for an image+text combination.
                    declutterImageWithText[index] = args;
                    // Don't render anything for now, wait for the text.
                    continue;
                  }
                  imageArgs = declutterImageWithText[index];
                  delete declutterImageWithText[index];
                  imageDeclutterBox = getDeclutterBox(imageArgs);
                  if (declutterTree.collides(imageDeclutterBox)) {
                    continue;
                  }
                }
                if (declutterTree.collides(dimensions.declutterBox)) {
                  continue;
                }
                if (imageArgs) {
                  // We now have image and text for an image+text combination.
                  declutterTree.insert(imageDeclutterBox);
                  // Render the image before we render the text.
                  this.replayImageOrLabel_.apply(this, imageArgs);
                }
                declutterTree.insert(dimensions.declutterBox);
              }
            }
            this.replayImageOrLabel_.apply(this, args);
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].DRAW_CHARS:
          const begin = /** @type {number} */ (instruction[1]);
          const end = /** @type {number} */ (instruction[2]);
          const baseline = /** @type {number} */ (instruction[3]);
          const overflow = /** @type {number} */ (instruction[4]);
          fillKey = /** @type {string} */ (instruction[5]);
          const maxAngle = /** @type {number} */ (instruction[6]);
          const measurePixelRatio = /** @type {number} */ (instruction[7]);
          const offsetY = /** @type {number} */ (instruction[8]);
          strokeKey = /** @type {string} */ (instruction[9]);
          const strokeWidth = /** @type {number} */ (instruction[10]);
          text = /** @type {string} */ (instruction[11]);
          textKey = /** @type {string} */ (instruction[12]);
          const pixelRatioScale = [
            /** @type {number} */ (instruction[13]),
            /** @type {number} */ (instruction[13]),
          ];

          const textState = this.textStates[textKey];
          const font = textState.font;
          const textScale = [
            textState.scale[0] * measurePixelRatio,
            textState.scale[1] * measurePixelRatio,
          ];

          let cachedWidths;
          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }

          const pathLength = (0,_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__.lineStringLength)(pixelCoordinates, begin, end, 2);
          const textLength =
            Math.abs(textScale[0]) *
            (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.measureAndCacheTextWidth)(font, text, cachedWidths);
          if (overflow || textLength <= pathLength) {
            const textAlign = this.textStates[textKey].textAlign;
            const startM = (pathLength - textLength) * _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[textAlign];
            const parts = (0,_geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__.drawTextOnPath)(
              pixelCoordinates,
              begin,
              end,
              2,
              text,
              startM,
              maxAngle,
              Math.abs(textScale[0]),
              _canvas_js__WEBPACK_IMPORTED_MODULE_3__.measureAndCacheTextWidth,
              font,
              cachedWidths,
              viewRotationFromTransform ? 0 : this.viewRotation_
            );
            drawChars: if (parts) {
              /** @type {Array<ReplayImageOrLabelArgs>} */
              const replayImageOrLabelArgs = [];
              let c, cc, chars, label, part;
              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = this.createLabel(chars, textKey, '', strokeKey);
                  anchorX =
                    /** @type {number} */ (part[2]) +
                    (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                  anchorY =
                    baseline * label.height +
                    ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /
                      textScale[0] -
                    offsetY;
                  const dimensions = this.calculateImageOrLabelDimensions_(
                    label.width,
                    label.height,
                    part[0],
                    part[1],
                    label.width,
                    label.height,
                    anchorX,
                    anchorY,
                    0,
                    0,
                    part[3],
                    pixelRatioScale,
                    false,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding,
                    false,
                    feature
                  );
                  if (
                    declutterTree &&
                    declutterTree.collides(dimensions.declutterBox)
                  ) {
                    break drawChars;
                  }
                  replayImageOrLabelArgs.push([
                    context,
                    contextScale,
                    label,
                    dimensions,
                    1,
                    null,
                    null,
                  ]);
                }
              }
              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = this.createLabel(chars, textKey, fillKey, '');
                  anchorX = /** @type {number} */ (part[2]);
                  anchorY = baseline * label.height - offsetY;
                  const dimensions = this.calculateImageOrLabelDimensions_(
                    label.width,
                    label.height,
                    part[0],
                    part[1],
                    label.width,
                    label.height,
                    anchorX,
                    anchorY,
                    0,
                    0,
                    part[3],
                    pixelRatioScale,
                    false,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding,
                    false,
                    feature
                  );
                  if (
                    declutterTree &&
                    declutterTree.collides(dimensions.declutterBox)
                  ) {
                    break drawChars;
                  }
                  replayImageOrLabelArgs.push([
                    context,
                    contextScale,
                    label,
                    dimensions,
                    1,
                    null,
                    null,
                  ]);
                }
              }
              if (declutterTree) {
                declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
              }
              for (let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i) {
                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);
              }
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].END_GEOMETRY:
          if (featureCallback !== undefined) {
            feature = /** @type {import("../../Feature.js").FeatureLike} */ (
              instruction[1]
            );
            const result = featureCallback(feature, currentGeometry);
            if (result) {
              return result;
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].MOVE_TO_LINE_TO:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = (x + 0.5) | 0;
          roundY = (y + 0.5) | 0;
          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = (x + 0.5) | 0;
            roundY = (y + 0.5) | 0;
            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];

          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle =
            /** @type {import("../../colorlike.js").ColorLike} */ (
              instruction[1]
            );
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }
          ++i;
          break;
        default: // consume the instruction anyway, to avoid an infinite loop
          ++i;
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context);
    }
    if (pendingStroke) {
      context.stroke();
    }
    return undefined;
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(
    context,
    contextScale,
    transform,
    viewRotation,
    snapToPixel,
    declutterTree
  ) {
    this.viewRotation_ = viewRotation;
    this.execute_(
      context,
      contextScale,
      transform,
      this.instructions,
      snapToPixel,
      undefined,
      undefined,
      declutterTree
    );
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(
    context,
    transform,
    viewRotation,
    featureCallback,
    hitExtent
  ) {
    this.viewRotation_ = viewRotation;
    return this.execute_(
      context,
      1,
      transform,
      this.hitDetectionInstructions,
      true,
      featureCallback,
      hitExtent
    );
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Executor);


/***/ }),

/***/ "./node_modules/ol/render/canvas/ExecutorGroup.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getPixelIndexArray: () => (/* binding */ getPixelIndexArray)
/* harmony export */ });
/* harmony import */ var _Executor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/render/canvas/Executor.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/dom.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/obj.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/render/canvas/ExecutorGroup
 */









/**
 * @const
 * @type {Array<import("../canvas.js").BuilderType>}
 */
const ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];

class ExecutorGroup {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */
  constructor(
    maxExtent,
    resolution,
    pixelRatio,
    overlaps,
    allInstructions,
    renderBuffer
  ) {
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = overlaps;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {number|undefined}
     */
    this.renderBuffer_ = renderBuffer;

    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Executor").default>>}
     */
    this.executorsByZIndex_ = {};

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitDetectionContext_ = null;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.hitDetectionTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();

    this.createExecutors_(allInstructions);
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(context, transform) {
    const flatClipCoords = this.getClipCoords(transform);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  }

  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */
  createExecutors_(allInstructions) {
    for (const zIndex in allInstructions) {
      let executors = this.executorsByZIndex_[zIndex];
      if (executors === undefined) {
        executors = {};
        this.executorsByZIndex_[zIndex] = executors;
      }
      const instructionByZindex = allInstructions[zIndex];
      for (const builderType in instructionByZindex) {
        const instructions = instructionByZindex[builderType];
        executors[builderType] = new _Executor_js__WEBPACK_IMPORTED_MODULE_1__["default"](
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          instructions
        );
      }
    }
  }

  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(executors) {
    for (const zIndex in this.executorsByZIndex_) {
      const candidates = this.executorsByZIndex_[zIndex];
      for (let i = 0, ii = executors.length; i < ii; ++i) {
        if (executors[i] in candidates) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    resolution,
    rotation,
    hitTolerance,
    callback,
    declutteredFeatures
  ) {
    hitTolerance = Math.round(hitTolerance);
    const contextSize = hitTolerance * 2 + 1;
    const transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.compose)(
      this.hitDetectionTransform_,
      hitTolerance + 0.5,
      hitTolerance + 0.5,
      1 / resolution,
      -1 / resolution,
      -rotation,
      -coordinate[0],
      -coordinate[1]
    );

    const newContext = !this.hitDetectionContext_;
    if (newContext) {
      this.hitDetectionContext_ = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(
        contextSize,
        contextSize,
        undefined,
        {willReadFrequently: true}
      );
    }
    const context = this.hitDetectionContext_;

    if (
      context.canvas.width !== contextSize ||
      context.canvas.height !== contextSize
    ) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else if (!newContext) {
      context.clearRect(0, 0, contextSize, contextSize);
    }

    /**
     * @type {import("../../extent.js").Extent}
     */
    let hitExtent;
    if (this.renderBuffer_ !== undefined) {
      hitExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createEmpty)();
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.extendCoordinate)(hitExtent, coordinate);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.buffer)(
        hitExtent,
        resolution * (this.renderBuffer_ + hitTolerance),
        hitExtent
      );
    }

    const indexes = getPixelIndexArray(hitTolerance);

    let builderType;

    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */
    function featureCallback(feature, geometry) {
      const imageData = context.getImageData(
        0,
        0,
        contextSize,
        contextSize
      ).data;
      for (let i = 0, ii = indexes.length; i < ii; i++) {
        if (imageData[indexes[i]] > 0) {
          if (
            !declutteredFeatures ||
            (builderType !== 'Image' && builderType !== 'Text') ||
            declutteredFeatures.includes(feature)
          ) {
            const idx = (indexes[i] - 3) / 4;
            const x = hitTolerance - (idx % contextSize);
            const y = hitTolerance - ((idx / contextSize) | 0);
            const result = callback(feature, geometry, x * x + y * y);
            if (result) {
              return result;
            }
          }
          context.clearRect(0, 0, contextSize, contextSize);
          break;
        }
      }
      return undefined;
    }

    /** @type {Array<number>} */
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_4__.ascending);

    let i, j, executors, executor, result;
    for (i = zs.length - 1; i >= 0; --i) {
      const zIndexKey = zs[i].toString();
      executors = this.executorsByZIndex_[zIndexKey];
      for (j = ORDER.length - 1; j >= 0; --j) {
        builderType = ORDER[j];
        executor = executors[builderType];
        if (executor !== undefined) {
          result = executor.executeHitDetection(
            context,
            transform,
            rotation,
            featureCallback,
            hitExtent
          );
          if (result) {
            return result;
          }
        }
      }
    }
    return undefined;
  }

  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(transform) {
    const maxExtent = this.maxExtent_;
    if (!maxExtent) {
      return null;
    }
    const minX = maxExtent[0];
    const minY = maxExtent[1];
    const maxX = maxExtent[2];
    const maxY = maxExtent[3];
    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
    return flatClipCoords;
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_6__.isEmpty)(this.executorsByZIndex_);
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(
    context,
    contextScale,
    transform,
    viewRotation,
    snapToPixel,
    builderTypes,
    declutterTree
  ) {
    /** @type {Array<number>} */
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_4__.ascending);

    // setup clipping so that the parts of over-simplified geometries are not
    // visible outside the current extent when panning
    if (this.maxExtent_) {
      context.save();
      this.clip(context, transform);
    }

    builderTypes = builderTypes ? builderTypes : ORDER;
    let i, ii, j, jj, replays, replay;
    if (declutterTree) {
      zs.reverse();
    }
    for (i = 0, ii = zs.length; i < ii; ++i) {
      const zIndexKey = zs[i].toString();
      replays = this.executorsByZIndex_[zIndexKey];
      for (j = 0, jj = builderTypes.length; j < jj; ++j) {
        const builderType = builderTypes[j];
        replay = replays[builderType];
        if (replay !== undefined) {
          replay.execute(
            context,
            contextScale,
            transform,
            viewRotation,
            snapToPixel,
            declutterTree
          );
        }
      }
    }

    if (this.maxExtent_) {
      context.restore();
    }
  }
}

/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */
const circlePixelIndexArrayCache = {};

/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== undefined) {
    return circlePixelIndexArrayCache[radius];
  }

  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i = 0; i <= radius; ++i) {
    for (let j = 0; j <= radius; ++j) {
      const distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance = distances[distanceSq];
      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }
      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }

  const pixelIndex = [];
  for (let i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push(...distances[i]);
    }
  }

  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExecutorGroup);


/***/ }),

/***/ "./node_modules/ol/render/canvas/ImageBuilder.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/render/canvas/Instruction.js");
/**
 * @module ol/render/canvas/ImageBuilder
 */



class CanvasImageBuilder extends _Builder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.imagePixelRatio_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorY_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.height_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.opacity_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originY_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */
    this.scale_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = undefined;

    /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */
    this.declutterMode_ = undefined;

    /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */
    this.declutterImageWithText_ = undefined;
  }

  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(pointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(pointGeometry, feature);
    const flatCoordinates = pointGeometry.getFlatCoordinates();
    const stride = pointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
        (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_,
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_,
    ]);
    this.endGeometry(feature);
  }

  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature);
    const flatCoordinates = multiPointGeometry.getFlatCoordinates();
    const stride = multiPointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
        (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_,
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_,
    ]);
    this.endGeometry(feature);
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions();
    // FIXME this doesn't really protect us against further calls to draw*Geometry
    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = undefined;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.width_ = undefined;
    return super.finish();
  }

  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(imageStyle, sharedData) {
    const anchor = imageStyle.getAnchor();
    const size = imageStyle.getSize();
    const origin = imageStyle.getOrigin();
    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
    this.image_ = imageStyle.getImage(this.pixelRatio);
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScaleArray();
    this.width_ = size[0];
    this.declutterMode_ = imageStyle.getDeclutterMode();
    this.declutterImageWithText_ = sharedData;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasImageBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/Immediate.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/colorlike.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/render/canvas.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/math.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/geom/SimpleGeometry.js");
/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?











/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
class CanvasImmediateRenderer extends _VectorContext_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(
    context,
    pixelRatio,
    extent,
    transform,
    viewRotation,
    squaredTolerance,
    userTransform
  ) {
    super();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = context;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.extent_ = extent;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = transform;

    /**
     * @private
     * @type {number}
     */
    this.transformRotation_ = transform
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toFixed)(Math.atan2(transform[1], transform[0]), 10)
      : 0;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = viewRotation;

    /**
     * @private
     * @type {number}
     */
    this.squaredTolerance_ = squaredTolerance;

    /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */
    this.userTransform_ = userTransform;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.contextFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.contextStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.contextTextState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.fillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.strokeState_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorY_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageHeight_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOpacity_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.imageRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.imageRotation_ = 0;

    /**
     * @private
     * @type {import("../../size.js").Size}
     */
    this.imageScale_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.imageWidth_ = 0;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.textRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {import("../../size.js").Size}
     */
    this.textScale_ = [0, 0];

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.textState_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = [];

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.tmpLocalTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }
    const pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    const context = this.context_;
    const localTransform = this.tmpLocalTransform_;
    const alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    let rotation = this.imageRotation_;
    if (this.transformRotation_ === 0) {
      rotation -= this.viewRotation_;
    }
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (let i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      const x = pixelCoordinates[i] - this.imageAnchorX_;
      const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
      if (
        rotation !== 0 ||
        this.imageScale_[0] != 1 ||
        this.imageScale_[1] != 1
      ) {
        const centerX = x + this.imageAnchorX_;
        const centerY = y + this.imageAnchorY_;
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
          localTransform,
          centerX,
          centerY,
          1,
          1,
          rotation,
          -centerX,
          -centerY
        );
        context.setTransform.apply(context, localTransform);
        context.translate(centerX, centerY);
        context.scale(this.imageScale_[0], this.imageScale_[1]);
        context.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        );
        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        context.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          x,
          y,
          this.imageWidth_,
          this.imageHeight_
        );
      }
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === '') {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    const pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    const context = this.context_;
    let rotation = this.textRotation_;
    if (this.transformRotation_ === 0) {
      rotation -= this.viewRotation_;
    }
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset < end; offset += stride) {
      const x = pixelCoordinates[offset] + this.textOffsetX_;
      const y = pixelCoordinates[offset + 1] + this.textOffsetY_;
      if (
        rotation !== 0 ||
        this.textScale_[0] != 1 ||
        this.textScale_[1] != 1
      ) {
        context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
        context.rotate(rotation);
        context.translate(this.textOffsetX_, this.textOffsetY_);
        context.scale(this.textScale_[0], this.textScale_[1]);
        if (this.textStrokeState_) {
          context.strokeText(this.text_, 0, 0);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, 0, 0);
        }
        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        if (this.textStrokeState_) {
          context.strokeText(this.text_, x, y);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, x, y);
        }
      }
    }
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(flatCoordinates, offset, end, stride, close) {
    const context = this.context_;
    const pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    let length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (let i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(flatCoordinates, offset, ends, stride) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(
        flatCoordinates,
        offset,
        ends[i],
        stride,
        true
      );
    }
    return offset;
  }

  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Circle.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const pixelCoordinates = (0,_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__.transformGeom2D)(
        geometry,
        this.transform_,
        this.pixelCoordinates_
      );
      const dx = pixelCoordinates[2] - pixelCoordinates[0];
      const dy = pixelCoordinates[3] - pixelCoordinates[1];
      const radius = Math.sqrt(dx * dx + dy * dy);
      const context = this.context_;
      context.beginPath();
      context.arc(
        pixelCoordinates[0],
        pixelCoordinates[1],
        radius,
        0,
        2 * Math.PI
      );
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  }

  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  }

  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(transform) {
    this.transform_ = transform;
  }

  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(geometry) {
    const type = geometry.getType();
    switch (type) {
      case 'Point':
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */ (geometry)
        );
        break;
      case 'LineString':
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */ (geometry)
        );
        break;
      case 'Polygon':
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */ (geometry)
        );
        break;
      case 'MultiPoint':
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */ (geometry)
        );
        break;
      case 'MultiLineString':
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */ (
            geometry
          )
        );
        break;
      case 'MultiPolygon':
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry)
        );
        break;
      case 'GeometryCollection':
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */ (
            geometry
          )
        );
        break;
      case 'Circle':
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */ (geometry)
        );
        break;
      default:
    }
  }

  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(feature, style) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  }

  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  }

  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Point.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }

  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/MultiPoint.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }

  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/LineString.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(
        flatCoordinates,
        0,
        flatCoordinates.length,
        geometry.getStride(),
        false
      );
      context.stroke();
    }
    if (this.text_ !== '') {
      const flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  }

  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry =
        /** @type {import("../../geom/MultiLineString.js").default} */ (
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          )
        );
    }
    const geometryExtent = geometry.getExtent();
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      let offset = 0;
      const ends = /** @type {Array<number>} */ (geometry.getEnds());
      const stride = geometry.getStride();
      context.beginPath();
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(
          flatCoordinates,
          offset,
          ends[i],
          stride,
          false
        );
      }
      context.stroke();
    }
    if (this.text_ !== '') {
      const flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  }

  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Polygon.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context = this.context_;
      context.beginPath();
      this.drawRings_(
        geometry.getOrientedFlatCoordinates(),
        0,
        /** @type {Array<number>} */ (geometry.getEnds()),
        geometry.getStride()
      );
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      const flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  }

  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context = this.context_;
      const flatCoordinates = geometry.getOrientedFlatCoordinates();
      let offset = 0;
      const endss = geometry.getEndss();
      const stride = geometry.getStride();
      context.beginPath();
      for (let i = 0, ii = endss.length; i < ii; ++i) {
        const ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      const flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  }

  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(fillState) {
    const context = this.context_;
    const contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle,
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context.fillStyle = fillState.fillStyle;
      }
    }
  }

  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(strokeState) {
    const context = this.context_;
    const contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;
      context.setLineDash(strokeState.lineDash);
      context.lineDashOffset = strokeState.lineDashOffset;
      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle,
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context.lineCap = strokeState.lineCap;
      }
      if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_6__.equals)(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(
          (contextStrokeState.lineDash = strokeState.lineDash)
        );
      }
      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context.lineJoin = strokeState.lineJoin;
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context.miterLimit = strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context.strokeStyle = strokeState.strokeStyle;
      }
    }
  }

  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(textState) {
    const context = this.context_;
    const contextTextState = this.contextTextState_;
    const textAlign = textState.textAlign
      ? textState.textAlign
      : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultTextAlign;
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = textAlign;
      context.textBaseline = textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline,
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign = textAlign;
        context.textAlign = textAlign;
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = textState.textBaseline;
        context.textBaseline = textState.textBaseline;
      }
    }
  }

  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      const fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_8__.asColorLike)(
          fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFillStyle
        ),
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      const strokeStyleColor = strokeStyle.getColor();
      const strokeStyleLineCap = strokeStyle.getLineCap();
      const strokeStyleLineDash = strokeStyle.getLineDash();
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      const strokeStyleWidth = strokeStyle.getWidth();
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      const lineDash = strokeStyleLineDash
        ? strokeStyleLineDash
        : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDash;
      this.strokeState_ = {
        lineCap:
          strokeStyleLineCap !== undefined
            ? strokeStyleLineCap
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineCap,
        lineDash:
          this.pixelRatio_ === 1
            ? lineDash
            : lineDash.map((n) => n * this.pixelRatio_),
        lineDashOffset:
          (strokeStyleLineDashOffset
            ? strokeStyleLineDashOffset
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDashOffset) * this.pixelRatio_,
        lineJoin:
          strokeStyleLineJoin !== undefined
            ? strokeStyleLineJoin
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineJoin,
        lineWidth:
          (strokeStyleWidth !== undefined
            ? strokeStyleWidth
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineWidth) * this.pixelRatio_,
        miterLimit:
          strokeStyleMiterLimit !== undefined
            ? strokeStyleMiterLimit
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultMiterLimit,
        strokeStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_8__.asColorLike)(
          strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultStrokeStyle
        ),
      };
    }
  }

  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(imageStyle) {
    let imageSize;
    if (!imageStyle || !(imageSize = imageStyle.getSize())) {
      this.image_ = null;
      return;
    }
    const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
    const imageAnchor = imageStyle.getAnchor();
    const imageOrigin = imageStyle.getOrigin();
    this.image_ = imageStyle.getImage(this.pixelRatio_);
    this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
    this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
    this.imageHeight_ = imageSize[1] * imagePixelRatio;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    const imageScale = imageStyle.getScaleArray();
    this.imageScale_ = [
      (imageScale[0] * this.pixelRatio_) / imagePixelRatio,
      (imageScale[1] * this.pixelRatio_) / imagePixelRatio,
    ];
    this.imageWidth_ = imageSize[0] * imagePixelRatio;
  }

  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        const textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_8__.asColorLike)(
            textFillStyleColor ? textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFillStyle
          ),
        };
      }
      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        const textStrokeStyleColor = textStrokeStyle.getColor();
        const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        const textStrokeStyleLineDashOffset =
          textStrokeStyle.getLineDashOffset();
        const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        const textStrokeStyleWidth = textStrokeStyle.getWidth();
        const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap:
            textStrokeStyleLineCap !== undefined
              ? textStrokeStyleLineCap
              : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineCap,
          lineDash: textStrokeStyleLineDash
            ? textStrokeStyleLineDash
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset
            ? textStrokeStyleLineDashOffset
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDashOffset,
          lineJoin:
            textStrokeStyleLineJoin !== undefined
              ? textStrokeStyleLineJoin
              : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineJoin,
          lineWidth:
            textStrokeStyleWidth !== undefined
              ? textStrokeStyleWidth
              : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineWidth,
          miterLimit:
            textStrokeStyleMiterLimit !== undefined
              ? textStrokeStyleMiterLimit
              : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultMiterLimit,
          strokeStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_8__.asColorLike)(
            textStrokeStyleColor ? textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultStrokeStyle
          ),
        };
      }
      const textFont = textStyle.getFont();
      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      const textScale = textStyle.getScaleArray();
      const textText = textStyle.getText();
      const textTextAlign = textStyle.getTextAlign();
      const textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ? textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFont,
        textAlign:
          textTextAlign !== undefined ? textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultTextAlign,
        textBaseline:
          textTextBaseline !== undefined
            ? textTextBaseline
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultTextBaseline,
      };
      this.text_ =
        textText !== undefined
          ? Array.isArray(textText)
            ? textText.reduce((acc, t, i) => (acc += i % 2 ? ' ' : t), '')
            : textText
          : '';
      this.textOffsetX_ =
        textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ =
        textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ =
        textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = [
        this.pixelRatio_ * textScale[0],
        this.pixelRatio_ * textScale[1],
      ];
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasImmediateRenderer);


/***/ }),

/***/ "./node_modules/ol/render/canvas/Instruction.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   beginPathInstruction: () => (/* binding */ beginPathInstruction),
/* harmony export */   closePathInstruction: () => (/* binding */ closePathInstruction),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fillInstruction: () => (/* binding */ fillInstruction),
/* harmony export */   strokeInstruction: () => (/* binding */ strokeInstruction)
/* harmony export */ });
/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
const Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12,
};

/**
 * @type {Array<Instruction>}
 */
const fillInstruction = [Instruction.FILL];

/**
 * @type {Array<Instruction>}
 */
const strokeInstruction = [Instruction.STROKE];

/**
 * @type {Array<Instruction>}
 */
const beginPathInstruction = [Instruction.BEGIN_PATH];

/**
 * @type {Array<Instruction>}
 */
const closePathInstruction = [Instruction.CLOSE_PATH];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Instruction);


/***/ }),

/***/ "./node_modules/ol/render/canvas/LineStringBuilder.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/render/canvas.js");
/**
 * @module ol/render/canvas/LineStringBuilder
 */




class CanvasLineStringBuilder extends _Builder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatLineCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      false,
      false
    );
    const moveToLineToInstruction = [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].MOVE_TO_LINE_TO,
      myBegin,
      myEnd,
    ];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  }

  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(lineStringGeometry, feature) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push(
      [
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDash,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDashOffset,
      ],
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction
    );
    const flatCoordinates = lineStringGeometry.getFlatCoordinates();
    const stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride
    );
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    this.endGeometry(feature);
  }

  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(multiLineStringGeometry, feature) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push(
      [
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset,
      ],
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction
    );
    const ends = multiLineStringGeometry.getEnds();
    const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    const stride = multiLineStringGeometry.getStride();
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(
        flatCoordinates,
        offset,
        /** @type {number} */ (ends[i]),
        stride
      );
    }
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    this.endGeometry(feature);
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const state = this.state;
    if (
      state.lastStroke != undefined &&
      state.lastStroke != this.coordinates.length
    ) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
    return super.finish();
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(state) {
    if (
      state.lastStroke != undefined &&
      state.lastStroke != this.coordinates.length
    ) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    super.applyStroke(state);
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasLineStringBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/PolygonBuilder.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/render/canvas.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/render/canvas/PolygonBuilder
 */





class CanvasPolygonBuilder extends _Builder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
    const state = this.state;
    const fill = state.fillStyle !== undefined;
    const stroke = state.strokeStyle !== undefined;
    const numEnds = ends.length;
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction);
    for (let i = 0; i < numEnds; ++i) {
      const end = ends[i];
      const myBegin = this.coordinates.length;
      const myEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset,
        end,
        stride,
        true,
        !stroke
      );
      const moveToLineToInstruction = [
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].MOVE_TO_LINE_TO,
        myBegin,
        myEnd,
      ];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        // Performance optimization: only call closePath() when we have a stroke.
        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
        this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.closePathInstruction);
        this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.closePathInstruction);
      }
      offset = end;
    }
    if (fill) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.fillInstruction);
    }
    if (stroke) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    }
    return offset;
  }

  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */
  drawCircle(circleGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_FILL_STYLE,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultFillStyle,
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset,
      ]);
    }
    const flatCoordinates = circleGeometry.getFlatCoordinates();
    const stride = circleGeometry.getStride();
    const myBegin = this.coordinates.length;
    this.appendFlatLineCoordinates(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride,
      false,
      false
    );
    const circleInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE, myBegin];
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction, circleInstruction);
    if (state.fillStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.fillInstruction);
    }
    if (state.strokeStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    }
    this.endGeometry(feature);
  }

  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(polygonGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_FILL_STYLE,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultFillStyle,
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset,
      ]);
    }
    const ends = polygonGeometry.getEnds();
    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    const stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(
      flatCoordinates,
      0,
      /** @type {Array<number>} */ (ends),
      stride
    );
    this.endGeometry(feature);
  }

  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(multiPolygonGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_FILL_STYLE,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultFillStyle,
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset,
      ]);
    }
    const endss = multiPolygonGeometry.getEndss();
    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    const stride = multiPolygonGeometry.getStride();
    let offset = 0;
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(
        flatCoordinates,
        offset,
        endss[i],
        stride
      );
    }
    this.endGeometry(feature);
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions();
    this.state = null;
    // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.
    const tolerance = this.tolerance;
    if (tolerance !== 0) {
      const coordinates = this.coordinates;
      for (let i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = (0,_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_3__.snap)(coordinates[i], tolerance);
      }
    }
    return super.finish();
  }

  /**
   * @private
   */
  setFillStrokeStyles_() {
    const state = this.state;
    const fillStyle = state.fillStyle;
    if (fillStyle !== undefined) {
      this.updateFillStyle(state, this.createFill);
    }
    if (state.strokeStyle !== undefined) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasPolygonBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/TextBuilder.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TEXT_ALIGN: () => (/* binding */ TEXT_ALIGN),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/colorlike.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/render/canvas.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_linechunk_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/geom/flat/linechunk.js");
/* harmony import */ var _geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/geom/flat/straightchunk.js");
/**
 * @module ol/render/canvas/TextBuilder
 */








/**
 * @const
 * @enum {number}
 */
const TEXT_ALIGN = {
  'left': 0,
  'end': 0,
  'center': 0.5,
  'right': 1,
  'start': 1,
  'top': 0,
  'middle': 0.5,
  'hanging': 0.2,
  'alphabetic': 0.8,
  'ideographic': 0.8,
  'bottom': 1,
};

class CanvasTextBuilder extends _Builder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);

    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */
    this.labels_ = null;

    /**
     * @private
     * @type {string|Array<string>}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.textRotateWithView_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    this.fillStates = {};

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    this.strokeStates = {};

    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */
    this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});

    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    this.textStates = {};

    /**
     * @private
     * @type {string}
     */
    this.textKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.fillKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.strokeKey_ = '';

    /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */
    this.declutterImageWithText_ = undefined;
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const instructions = super.finish();
    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  }

  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawText(geometry, feature) {
    const fillState = this.textFillState_;
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
      return;
    }

    const coordinates = this.coordinates;
    let begin = coordinates.length;

    const geometryType = geometry.getType();
    let flatCoordinates = null;
    let stride = geometry.getStride();

    if (
      textState.placement === 'line' &&
      (geometryType == 'LineString' ||
        geometryType == 'MultiLineString' ||
        geometryType == 'Polygon' ||
        geometryType == 'MultiPolygon')
    ) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }
      let ends;
      flatCoordinates = geometry.getFlatCoordinates();
      if (geometryType == 'LineString') {
        ends = [flatCoordinates.length];
      } else if (geometryType == 'MultiLineString') {
        ends = /** @type {import("../../geom/MultiLineString.js").default} */ (
          geometry
        ).getEnds();
      } else if (geometryType == 'Polygon') {
        ends = /** @type {import("../../geom/Polygon.js").default} */ (geometry)
          .getEnds()
          .slice(0, 1);
      } else if (geometryType == 'MultiPolygon') {
        const endss =
          /** @type {import("../../geom/MultiPolygon.js").default} */ (
            geometry
          ).getEndss();
        ends = [];
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }
      this.beginGeometry(geometry, feature);
      const repeat = textState.repeat;
      const textAlign = repeat ? undefined : textState.textAlign;
      // No `justify` support for line placement.
      let flatOffset = 0;
      for (let o = 0, oo = ends.length; o < oo; ++o) {
        let chunks;
        if (repeat) {
          chunks = (0,_geom_flat_linechunk_js__WEBPACK_IMPORTED_MODULE_2__.lineChunk)(
            repeat * this.resolution,
            flatCoordinates,
            flatOffset,
            ends[o],
            stride
          );
        } else {
          chunks = [flatCoordinates.slice(flatOffset, ends[o])];
        }
        for (let c = 0, cc = chunks.length; c < cc; ++c) {
          const chunk = chunks[c];
          let chunkBegin = 0;
          let chunkEnd = chunk.length;
          if (textAlign == undefined) {
            const range = (0,_geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_3__.matchingChunk)(
              textState.maxAngle,
              chunk,
              0,
              chunk.length,
              2
            );
            chunkBegin = range[0];
            chunkEnd = range[1];
          }
          for (let i = chunkBegin; i < chunkEnd; i += stride) {
            coordinates.push(chunk[i], chunk[i + 1]);
          }
          const end = coordinates.length;
          flatOffset = ends[o];
          this.drawChars_(begin, end);
          begin = end;
        }
      }
      this.endGeometry(feature);
    } else {
      let geometryWidths = textState.overflow ? null : [];
      switch (geometryType) {
        case 'Point':
        case 'MultiPoint':
          flatCoordinates =
            /** @type {import("../../geom/MultiPoint.js").default} */ (
              geometry
            ).getFlatCoordinates();
          break;
        case 'LineString':
          flatCoordinates =
            /** @type {import("../../geom/LineString.js").default} */ (
              geometry
            ).getFlatMidpoint();
          break;
        case 'Circle':
          flatCoordinates =
            /** @type {import("../../geom/Circle.js").default} */ (
              geometry
            ).getCenter();
          break;
        case 'MultiLineString':
          flatCoordinates =
            /** @type {import("../../geom/MultiLineString.js").default} */ (
              geometry
            ).getFlatMidpoints();
          stride = 2;
          break;
        case 'Polygon':
          flatCoordinates =
            /** @type {import("../../geom/Polygon.js").default} */ (
              geometry
            ).getFlatInteriorPoint();
          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }
          stride = 3;
          break;
        case 'MultiPolygon':
          const interiorPoints =
            /** @type {import("../../geom/MultiPolygon.js").default} */ (
              geometry
            ).getFlatInteriorPoints();
          flatCoordinates = [];
          for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
            }
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
          if (flatCoordinates.length === 0) {
            return;
          }
          stride = 2;
          break;
        default:
      }
      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
      if (end === begin) {
        return;
      }
      if (
        geometryWidths &&
        (end - begin) / 2 !== flatCoordinates.length / stride
      ) {
        let beg = begin / 2;
        geometryWidths = geometryWidths.filter((w, i) => {
          const keep =
            coordinates[(beg + i) * 2] === flatCoordinates[i * stride] &&
            coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
          if (!keep) {
            --beg;
          }
          return keep;
        });
      }

      this.saveTextStates_();

      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(
          textState.backgroundFill,
          textState.backgroundStroke
        );
        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill);
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }
        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }

      this.beginGeometry(geometry, feature);

      // adjust padding for negative scale
      let padding = textState.padding;
      if (
        padding != _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultPadding &&
        (textState.scale[0] < 0 || textState.scale[1] < 0)
      ) {
        let p0 = textState.padding[0];
        let p1 = textState.padding[1];
        let p2 = textState.padding[2];
        let p3 = textState.padding[3];
        if (textState.scale[0] < 0) {
          p1 = -p1;
          p3 = -p3;
        }
        if (textState.scale[1] < 0) {
          p0 = -p0;
          p2 = -p2;
        }
        padding = [p0, p1, p2, p3];
      }

      // The image is unknown at this stage so we pass null; it will be computed at render time.
      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
      // render time.
      const pixelRatio = this.pixelRatio;
      this.instructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        undefined,
        this.declutterImageWithText_,
        padding == _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultPadding
          ? _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultPadding
          : padding.map(function (p) {
              return p * pixelRatio;
            }),
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths,
      ]);
      const scale = 1 / pixelRatio;
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [scale, scale],
        NaN,
        undefined,
        this.declutterImageWithText_,
        padding,
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths,
      ]);

      this.endGeometry(feature);
    }
  }

  /**
   * @private
   */
  saveTextStates_() {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    const fillState = this.textFillState_;

    const strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash,
        };
      }
    }
    const textKey = this.textKey_;
    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultTextAlign,
        justify: textState.justify,
        textBaseline: textState.textBaseline || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultTextBaseline,
        scale: textState.scale,
      };
    }
    const fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle,
        };
      }
    }
  }

  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(begin, end) {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;

    const strokeKey = this.strokeKey_;
    const textKey = this.textKey_;
    const fillKey = this.fillKey_;
    this.saveTextStates_();

    const pixelRatio = this.pixelRatio;
    const baseline = TEXT_ALIGN[textState.textBaseline];

    const offsetY = this.textOffsetY_ * pixelRatio;
    const text = this.text_;
    const strokeWidth = strokeState
      ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2
      : 0;

    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      pixelRatio,
      offsetY,
      strokeKey,
      strokeWidth * pixelRatio,
      text,
      textKey,
      1,
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      1,
      offsetY,
      strokeKey,
      strokeWidth,
      text,
      textKey,
      1 / pixelRatio,
    ]);
  }

  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(textStyle, sharedData) {
    let textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = '';
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = /** @type {import("../canvas.js").FillState} */ ({});
          this.textFillState_ = fillState;
        }
        fillState.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(
          textFillStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultFillStyle
        );
      }

      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = /** @type {import("../canvas.js").StrokeState} */ ({});
          this.textStrokeState_ = strokeState;
        }
        const lineDash = textStrokeStyle.getLineDash();
        const lineDashOffset = textStrokeStyle.getLineDashOffset();
        const lineWidth = textStrokeStyle.getWidth();
        const miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineDash;
        strokeState.lineDashOffset =
          lineDashOffset === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineJoin;
        strokeState.lineWidth =
          lineWidth === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineWidth : lineWidth;
        strokeState.miterLimit =
          miterLimit === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(
          textStrokeStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultStrokeStyle
        );
      }

      textState = this.textState_;
      const font = textStyle.getFont() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultFont;
      (0,_canvas_js__WEBPACK_IMPORTED_MODULE_4__.registerFont)(font);
      const textScale = textStyle.getScaleArray();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.repeat = textStyle.getRepeat();
      textState.justify = textStyle.getJustify();
      textState.textBaseline =
        textStyle.getTextBaseline() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultPadding;
      textState.scale = textScale === undefined ? [1, 1] : textScale;

      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || '';
      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
      this.textRotateWithView_ =
        textRotateWithView === undefined ? false : textRotateWithView;
      this.textRotation_ = textRotation === undefined ? 0 : textRotation;

      this.strokeKey_ = strokeState
        ? (typeof strokeState.strokeStyle == 'string'
            ? strokeState.strokeStyle
            : (0,_util_js__WEBPACK_IMPORTED_MODULE_7__.getUid)(strokeState.strokeStyle)) +
          strokeState.lineCap +
          strokeState.lineDashOffset +
          '|' +
          strokeState.lineWidth +
          strokeState.lineJoin +
          strokeState.miterLimit +
          '[' +
          strokeState.lineDash.join() +
          ']'
        : '';
      this.textKey_ =
        textState.font +
        textState.scale +
        (textState.textAlign || '?') +
        (textState.repeat || '?') +
        (textState.justify || '?') +
        (textState.textBaseline || '?');
      this.fillKey_ = fillState
        ? typeof fillState.fillStyle == 'string'
          ? fillState.fillStyle
          : '|' + (0,_util_js__WEBPACK_IMPORTED_MODULE_7__.getUid)(fillState.fillStyle)
        : '';
    }
    this.declutterImageWithText_ = sharedData;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasTextBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/hitdetect.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HIT_DETECT_RESOLUTION: () => (/* binding */ HIT_DETECT_RESOLUTION),
/* harmony export */   createHitDetectionImageData: () => (/* binding */ createHitDetectionImageData),
/* harmony export */   hitDetect: () => (/* binding */ hitDetect)
/* harmony export */ });
/* harmony import */ var _Immediate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/style/Icon.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/math.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/**
 * @module ol/render/canvas/hitdetect
 */








const HIT_DETECT_RESOLUTION = 0.5;

/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */
function createHitDetectionImageData(
  size,
  transforms,
  features,
  styleFunction,
  extent,
  resolution,
  rotation
) {
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(width, height);
  context.imageSmoothingEnabled = false;
  const canvas = context.canvas;
  const renderer = new _Immediate_js__WEBPACK_IMPORTED_MODULE_1__["default"](
    context,
    HIT_DETECT_RESOLUTION,
    extent,
    null,
    rotation
  );
  const featureCount = features.length;
  // Stretch hit detection index to use the whole available color range
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i = 1; i <= featureCount; ++i) {
    const feature = features[i - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!styleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index = i * indexFactor;
    const color = index.toString(16).padStart(7, '#00000');
    for (let j = 0, jj = styles.length; j < jj; ++j) {
      const originalStyle = styles[j];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(extent, geometry.getExtent())) {
        continue;
      }
      const style = originalStyle.clone();
      const fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      const stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(undefined);
      const image = originalStyle.getImage();
      if (image && image.getOpacity() !== 0) {
        const imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }

        const imgContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(
          imgSize[0],
          imgSize[1],
          undefined,
          {alpha: false}
        );
        const img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(
          new _style_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
            img: img,
            imgSize: imgSize,
            anchor: image.getAnchor(),
            anchorXUnits: 'pixels',
            anchorYUnits: 'pixels',
            offset: image.getOrigin(),
            opacity: 1,
            size: image.getSize(),
            scale: image.getScale(),
            rotation: image.getRotation(),
            rotateWithView: image.getRotateWithView(),
          })
        );
      }
      const zIndex = style.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType['Polygon'] = [];
        byGeometryType['Circle'] = [];
        byGeometryType['LineString'] = [];
        byGeometryType['Point'] = [];
      }
      const type = geometry.getType();
      if (type === 'GeometryCollection') {
        const geometries =
          /** @type {import("../../geom/GeometryCollection.js").default} */ (
            geometry
          ).getGeometriesArrayRecursive();
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          const geometry = geometries[i];
          byGeometryType[geometry.getType().replace('Multi', '')].push(
            geometry,
            style
          );
        }
      } else {
        byGeometryType[type.replace('Multi', '')].push(geometry, style);
      }
    }
  }

  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_4__.ascending);
  for (let i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);
        for (let k = 0, kk = transforms.length; k < kk; ++k) {
          renderer.setTransform(transforms[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}

/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<F>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<F>} Features.
 * @template {import("../../Feature.js").FeatureLike} F
 */
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    // The pixel coordinate is clamped down to the hit-detect canvas' size to account
    // for browsers returning coordinates slightly larger than the actual canvas size
    // due to a non-integer pixel ratio.
    const index =
      ((0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(x, 0, imageData.width - 1) +
        (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(y, 0, imageData.height - 1) * imageData.width) *
      4;
    const r = imageData.data[index];
    const g = imageData.data[index + 1];
    const b = imageData.data[index + 2];
    const i = b + 256 * (g + 256 * r);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }
  // @ts-ignore Features are copied from `features` to `resultFeatures` so the type should be the same
  return resultFeatures;
}


/***/ }),

/***/ "./node_modules/ol/render/webgl/constants.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLWorkerMessageType: () => (/* binding */ WebGLWorkerMessageType)
/* harmony export */ });
/**
 * @module ol/render/webgl/constants
 */

/**
 * @enum {string}
 */
const WebGLWorkerMessageType = {
  GENERATE_POLYGON_BUFFERS: 'GENERATE_POLYGON_BUFFERS',
  GENERATE_POINT_BUFFERS: 'GENERATE_POINT_BUFFERS',
  GENERATE_LINE_STRING_BUFFERS: 'GENERATE_LINE_STRING_BUFFERS',
};

/**
 * @typedef {Object} WebGLWorkerGenerateBuffersMessage
 * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.
 * When the buffers are generated, the worked will send a message of the same type to the main thread, with
 * the generated buffers in it.
 * Note that any addition properties present in the message *will* be sent back to the main thread.
 * @property {number} id Message id; will be used both in request and response as a means of identification
 * @property {WebGLWorkerMessageType} type Message type
 * @property {ArrayBuffer} renderInstructions Polygon render instructions raw binary buffer.
 * @property {number} [customAttributesSize] Amount of custom attributes count in the polygon render instructions.
 * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).
 * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).
 * @property {import("../../transform").Transform} [renderInstructionsTransform] Transformation matrix used to project the instructions coordinates
 */


/***/ }),

/***/ "./node_modules/ol/render/webgl/utils.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorDecodeId: () => (/* binding */ colorDecodeId),
/* harmony export */   colorEncodeId: () => (/* binding */ colorEncodeId),
/* harmony export */   getBlankImageData: () => (/* binding */ getBlankImageData),
/* harmony export */   writeLineSegmentToBuffers: () => (/* binding */ writeLineSegmentToBuffers),
/* harmony export */   writePointFeatureToBuffers: () => (/* binding */ writePointFeatureToBuffers),
/* harmony export */   writePolygonTrianglesToBuffers: () => (/* binding */ writePolygonTrianglesToBuffers)
/* harmony export */ });
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/earcut/src/earcut.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/math.js");
/**
 * @module ol/render/webgl/utils
 */




const tmpArray_ = [];

/**
 * An object holding positions both in an index and a vertex buffer.
 * @typedef {Object} BufferPositions
 * @property {number} vertexPosition Position in the vertex buffer
 * @property {number} indexPosition Position in the index buffer
 */
const bufferPositions_ = {vertexPosition: 0, indexPosition: 0};

function writePointVertex(buffer, pos, x, y, index) {
  buffer[pos + 0] = x;
  buffer[pos + 1] = y;
  buffer[pos + 2] = index;
}

/**
 * Pushes a quad (two triangles) based on a point geometry
 * @param {Float32Array} instructions Array of render instructions for points.
 * @param {number} elementIndex Index from which render instructions will be read.
 * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.
 * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.
 * @param {number} customAttributesSize Amount of custom attributes for each element.
 * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.
 * @return {BufferPositions} New buffer positions where to write next
 * @property {number} vertexPosition New position in the vertex buffer where future writes should start.
 * @property {number} indexPosition New position in the index buffer where future writes should start.
 * @private
 */
function writePointFeatureToBuffers(
  instructions,
  elementIndex,
  vertexBuffer,
  indexBuffer,
  customAttributesSize,
  bufferPositions
) {
  // This is for x, y and index
  const baseVertexAttrsCount = 3;
  const baseInstructionsCount = 2;
  const stride = baseVertexAttrsCount + customAttributesSize;

  const x = instructions[elementIndex + 0];
  const y = instructions[elementIndex + 1];

  // read custom numerical attributes on the feature
  const customAttrs = tmpArray_;
  customAttrs.length = customAttributesSize;
  for (let i = 0; i < customAttrs.length; i++) {
    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];
  }

  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;
  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;
  const baseIndex = vPos / stride;

  // push vertices for each of the four quad corners (first standard then custom attributes)
  writePointVertex(vertexBuffer, vPos, x, y, 0);
  customAttrs.length &&
    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;

  writePointVertex(vertexBuffer, vPos, x, y, 1);
  customAttrs.length &&
    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;

  writePointVertex(vertexBuffer, vPos, x, y, 2);
  customAttrs.length &&
    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;

  writePointVertex(vertexBuffer, vPos, x, y, 3);
  customAttrs.length &&
    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;

  indexBuffer[iPos++] = baseIndex;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 3;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 2;
  indexBuffer[iPos++] = baseIndex + 3;

  bufferPositions_.vertexPosition = vPos;
  bufferPositions_.indexPosition = iPos;

  return bufferPositions_;
}

/**
 * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next
 * segment, in order to be able to offset the vertices correctly in the shader
 * @param {Float32Array} instructions Array of render instructions for lines.
 * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.
 * @param {number} segmentEndIndex Index of the segment start point from which render instructions will be read.
 * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)
 * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)
 * @param {Array<number>} vertexArray Array containing vertices.
 * @param {Array<number>} indexArray Array containing indices.
 * @param {Array<number>} customAttributes Array of custom attributes value
 * @param {import('../../transform.js').Transform} instructionsTransform Transform matrix used to project coordinates in instructions
 * @param {import('../../transform.js').Transform} invertInstructionsTransform Transform matrix used to project coordinates in instructions
 * @private
 */
function writeLineSegmentToBuffers(
  instructions,
  segmentStartIndex,
  segmentEndIndex,
  beforeSegmentIndex,
  afterSegmentIndex,
  vertexArray,
  indexArray,
  customAttributes,
  instructionsTransform,
  invertInstructionsTransform
) {
  // compute the stride to determine how many vertices were already pushed
  const baseVertexAttrsCount = 5; // base attributes: x0, y0, x1, y1, params (vertex number [0-3], join angle 1, join angle 2)
  const stride = baseVertexAttrsCount + customAttributes.length;
  const baseIndex = vertexArray.length / stride;

  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]
  // Depending on whether there are points before and after the segment, its final shape
  // will be different
  const p0 = [
    instructions[segmentStartIndex + 0],
    instructions[segmentStartIndex + 1],
  ];
  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];

  // to compute offsets from the line center we need to reproject
  // coordinates back in world units and compute the length of the segment
  const p0world = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.apply)(invertInstructionsTransform, [...p0]);
  const p1world = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.apply)(invertInstructionsTransform, [...p1]);

  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {
    const shift = 10000;
    const anglePrecision = 1500;
    return (
      Math.round(joinAngle1 * anglePrecision) +
      Math.round(joinAngle2 * anglePrecision) * shift +
      vertexNumber * shift * shift
    );
  }

  // compute the angle between p0pA and p0pB
  // returns a value in [0, 2PI]
  function angleBetween(p0, pA, pB) {
    const lenA = Math.sqrt(
      (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1])
    );
    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];
    const orthoA = [-tangentA[1], tangentA[0]];
    const lenB = Math.sqrt(
      (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1])
    );
    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];

    // this angle can be clockwise or anticlockwise; hence the computation afterwards
    const angle =
      lenA === 0 || lenB === 0
        ? 0
        : Math.acos(
            (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1)
          );
    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;
    return !isClockwise ? Math.PI * 2 - angle : angle;
  }

  const joinBefore = beforeSegmentIndex !== null;
  const joinAfter = afterSegmentIndex !== null;

  let angle0 = 0;
  let angle1 = 0;

  // add vertices and adapt offsets for P0 in case of join
  if (joinBefore) {
    // B for before
    const pB = [
      instructions[beforeSegmentIndex],
      instructions[beforeSegmentIndex + 1],
    ];
    const pBworld = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.apply)(invertInstructionsTransform, [...pB]);
    angle0 = angleBetween(p0world, p1world, pBworld);
  }
  // adapt offsets for P1 in case of join
  if (joinAfter) {
    // A for after
    const pA = [
      instructions[afterSegmentIndex],
      instructions[afterSegmentIndex + 1],
    ];
    const pAworld = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.apply)(invertInstructionsTransform, [...pA]);
    angle1 = angleBetween(p1world, p0world, pAworld);
  }

  // add main segment triangles
  vertexArray.push(
    p0[0],
    p0[1],
    p1[0],
    p1[1],
    computeVertexParameters(0, angle0, angle1)
  );
  vertexArray.push(...customAttributes);

  vertexArray.push(
    p0[0],
    p0[1],
    p1[0],
    p1[1],
    computeVertexParameters(1, angle0, angle1)
  );
  vertexArray.push(...customAttributes);

  vertexArray.push(
    p0[0],
    p0[1],
    p1[0],
    p1[1],
    computeVertexParameters(2, angle0, angle1)
  );
  vertexArray.push(...customAttributes);

  vertexArray.push(
    p0[0],
    p0[1],
    p1[0],
    p1[1],
    computeVertexParameters(3, angle0, angle1)
  );
  vertexArray.push(...customAttributes);

  indexArray.push(
    baseIndex,
    baseIndex + 1,
    baseIndex + 2,
    baseIndex + 1,
    baseIndex + 3,
    baseIndex + 2
  );
}

/**
 * Pushes several triangles to form a polygon, including holes
 * @param {Float32Array} instructions Array of render instructions for lines.
 * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.
 * @param {Array<number>} vertexArray Array containing vertices.
 * @param {Array<number>} indexArray Array containing indices.
 * @param {number} customAttributesSize Amount of custom attributes for each element.
 * @return {number} Next polygon instructions index
 * @private
 */
function writePolygonTrianglesToBuffers(
  instructions,
  polygonStartIndex,
  vertexArray,
  indexArray,
  customAttributesSize
) {
  const instructionsPerVertex = 2; // x, y
  const attributesPerVertex = 2 + customAttributesSize;
  let instructionsIndex = polygonStartIndex;
  const customAttributes = instructions.slice(
    instructionsIndex,
    instructionsIndex + customAttributesSize
  );
  instructionsIndex += customAttributesSize;
  const ringsCount = instructions[instructionsIndex++];
  let verticesCount = 0;
  const holes = new Array(ringsCount - 1);
  for (let i = 0; i < ringsCount; i++) {
    verticesCount += instructions[instructionsIndex++];
    if (i < ringsCount - 1) {
      holes[i] = verticesCount;
    }
  }
  const flatCoords = instructions.slice(
    instructionsIndex,
    instructionsIndex + verticesCount * instructionsPerVertex
  );

  // pushing to vertices and indices!! this is where the magic happens
  const result = earcut__WEBPACK_IMPORTED_MODULE_0__(flatCoords, holes, instructionsPerVertex);
  for (let i = 0; i < result.length; i++) {
    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);
  }
  for (let i = 0; i < flatCoords.length; i += 2) {
    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);
  }

  return instructionsIndex + verticesCount * instructionsPerVertex;
}

/**
 * Returns a texture of 1x1 pixel, white
 * @private
 * @return {ImageData} Image data.
 */
function getBlankImageData() {
  const canvas = document.createElement('canvas');
  const image = canvas.getContext('2d').createImageData(1, 1);
  image.data[0] = 255;
  image.data[1] = 255;
  image.data[2] = 255;
  image.data[3] = 255;
  return image;
}

/**
 * Generates a color array based on a numerical id
 * Note: the range for each component is 0 to 1 with 256 steps
 * @param {number} id Id
 * @param {Array<number>} [array] Reusable array
 * @return {Array<number>} Color array containing the encoded id
 */
function colorEncodeId(id, array) {
  array = array || [];
  const radix = 256;
  const divide = radix - 1;
  array[0] = Math.floor(id / radix / radix / radix) / divide;
  array[1] = (Math.floor(id / radix / radix) % radix) / divide;
  array[2] = (Math.floor(id / radix) % radix) / divide;
  array[3] = (id % radix) / divide;
  return array;
}

/**
 * Reads an id from a color-encoded array
 * Note: the expected range for each component is 0 to 1 with 256 steps.
 * @param {Array<number>} color Color array containing the encoded id
 * @return {number} Decoded id
 */
function colorDecodeId(color) {
  let id = 0;
  const radix = 256;
  const mult = radix - 1;
  id += Math.round(color[0] * radix * radix * radix * mult);
  id += Math.round(color[1] * radix * radix * mult);
  id += Math.round(color[2] * radix * mult);
  id += Math.round(color[3] * mult);
  return id;
}


/***/ }),

/***/ "./node_modules/ol/renderer/Layer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/ImageState.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/Observable.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/renderer/Layer
 */





/**
 * @template {import("../layer/Layer.js").default} LayerType
 */
class LayerRenderer extends _Observable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super();

    /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */
    this.ready = true;

    /** @private */
    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);

    /**
     * @protected
     * @type {LayerType}
     */
    this.layer_ = layer;

    /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */
    this.declutterExecutorGroup = null;
  }

  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    return null;
  }

  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(tiles, zoom, tile) {
    if (!tiles[zoom]) {
      tiles[zoom] = {};
    }
    tiles[zoom][tile.tileCoord.toString()] = tile;
    return undefined;
  }

  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (zoom, tileRange) => {
        const callback = this.loadedTileCallback.bind(this, tiles, zoom);
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    callback,
    matches
  ) {
    return undefined;
  }

  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }

  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {}

  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(event) {
    const image = /** @type {import("../Image.js").default} */ (event.target);
    if (image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      this.renderIfReadyAndVisible();
    }
  }

  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(image) {
    let imageState = image.getState();
    if (imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED && imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      image.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  }

  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const layer = this.getLayer();
    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {
      layer.changed();
    }
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/ImageLayer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/ImageState.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/ViewHint.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/**
 * @module ol/renderer/canvas/ImageLayer
 */







/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
class CanvasImageLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(imageLayer) {
    super(imageLayer);

    /**
     * @protected
     * @type {?import("../../ImageBase.js").default}
     */
    this.image_ = null;
  }

  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return this.image_ ? this.image_.getImage() : null;
  }

  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const viewResolution = viewState.resolution;

    const imageSource = this.getLayer().getSource();

    const hints = frameState.viewHints;

    let renderedExtent = frameState.extent;
    if (layerState.extent !== undefined) {
      renderedExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(
        renderedExtent,
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, viewState.projection)
      );
    }

    if (
      !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] &&
      !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING] &&
      !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(renderedExtent)
    ) {
      if (imageSource) {
        const projection = viewState.projection;
        const image = imageSource.getImage(
          renderedExtent,
          viewResolution,
          pixelRatio,
          projection
        );
        if (image) {
          if (this.loadImage(image)) {
            this.image_ = image;
          } else if (image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY) {
            this.image_ = null;
          }
        }
      } else {
        this.image_ = null;
      }
    }

    return !!this.image_;
  }

  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }

    const layer = this.getLayer();
    const coordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );

    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)(layerExtent, coordinate)) {
        return null;
      }
    }

    const imageExtent = this.image_.getExtent();
    const img = this.getImage();

    const imageMapWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(imageExtent);
    const col = Math.floor(
      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)
    );
    if (col < 0 || col >= img.width) {
      return null;
    }

    const imageMapHeight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(imageExtent);
    const row = Math.floor(
      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)
    );
    if (row < 0 || row >= img.height) {
      return null;
    }

    return this.getImageData(img, col, row);
  }

  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    const image = this.image_;
    const imageExtent = image.getExtent();
    const imageResolution = image.getResolution();
    const imagePixelRatio = image.getPixelRatio();
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const viewCenter = viewState.center;
    const viewResolution = viewState.resolution;
    const scale =
      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);

    const extent = frameState.extent;
    const resolution = viewState.resolution;
    const rotation = viewState.rotation;
    // desired dimensions of the canvas in pixels
    const width = Math.round(((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(extent) / resolution) * pixelRatio);
    const height = Math.round(((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(extent) / resolution) * pixelRatio);

    // set forward and inverse pixel transforms
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.compose)(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.makeInverse)(this.inversePixelTransform, this.pixelTransform);

    const canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.toString)(this.pixelTransform);

    this.useContainer(target, canvasTransform, this.getBackground(frameState));

    const context = this.context;
    const canvas = context.canvas;

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    // clipped rendering if layer extent is set
    let clipped = false;
    let render = true;
    if (layerState.extent) {
      const layerExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(
        layerState.extent,
        viewState.projection
      );
      render = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(layerExtent, frameState.extent);
      clipped = render && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }

    const img = this.getImage();

    const transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.compose)(
      this.tempTransform,
      width / 2,
      height / 2,
      scale,
      scale,
      0,
      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,
      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution
    );

    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;

    const dw = img.width * transform[0];
    const dh = img.height * transform[3];

    if (!this.getLayer().getSource().getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }

    this.preRender(context, frameState);
    if (render && dw >= 0.5 && dh >= 0.5) {
      const dx = transform[4];
      const dy = transform[5];
      const opacity = layerState.opacity;
      let previousAlpha;
      if (opacity !== 1) {
        previousAlpha = context.globalAlpha;
        context.globalAlpha = opacity;
      }
      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);
      if (opacity !== 1) {
        context.globalAlpha = previousAlpha;
      }
    }
    this.postRender(context, frameState);

    if (clipped) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    return this.container;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasImageLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Layer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canvasPool: () => (/* binding */ canvasPool),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/render/EventType.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/color.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/dom.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/extent.js");
/**
 * @module ol/renderer/canvas/Layer
 */









/**
 * @type {Array<HTMLCanvasElement>}
 */
const canvasPool = [];

/**
 * @type {CanvasRenderingContext2D}
 */
let pixelContext = null;

function createPixelContext() {
  pixelContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(1, 1, undefined, {
    willReadFrequently: true,
  });
}

/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
class CanvasLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super(layer);

    /**
     * @protected
     * @type {HTMLElement}
     */
    this.container = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedResolution;

    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.tempTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.pixelTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.inversePixelTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * @type {CanvasRenderingContext2D}
     */
    this.context = null;

    /**
     * @type {boolean}
     */
    this.containerReused = false;

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.pixelContext_ = null;

    /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */
    this.frameState = null;
  }

  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(image, col, row) {
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);

    let data;
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      pixelContext = null;
      return null;
    }
    return data;
  }

  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(frameState) {
    const layer = this.getLayer();
    let background = layer.getBackground();
    if (typeof background === 'function') {
      background = background(frameState.viewState.resolution);
    }
    return background || undefined;
  }

  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(target, transform, backgroundColor) {
    const layerClassName = this.getLayer().getClassName();
    let container, context;
    if (
      target &&
      target.className === layerClassName &&
      (!backgroundColor ||
        (target &&
          target.style.backgroundColor &&
          (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.equals)(
            (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(target.style.backgroundColor),
            (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(backgroundColor)
          )))
    ) {
      const canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext('2d');
      }
    }
    if (context && context.canvas.style.transform === transform) {
      // Container of the previous layer renderer can be used.
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      // Previously reused container cannot be used any more.
      this.container = null;
      this.context = null;
      this.containerReused = false;
    }
    if (!this.container) {
      container = document.createElement('div');
      container.className = layerClassName;
      let style = container.style;
      style.position = 'absolute';
      style.width = '100%';
      style.height = '100%';
      context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)();
      const canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = 'absolute';
      style.left = '0';
      style.transformOrigin = 'top left';
      this.container = container;
      this.context = context;
    }
    if (
      !this.containerReused &&
      backgroundColor &&
      !this.container.style.backgroundColor
    ) {
      this.container.style.backgroundColor = backgroundColor;
    }
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(context, frameState, extent) {
    const topLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getTopLeft)(extent);
    const topRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getTopRight)(extent);
    const bottomRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getBottomRight)(extent);
    const bottomLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getBottomLeft)(extent);

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, topLeft);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, topRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, bottomRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, bottomLeft);

    const inverted = this.inversePixelTransform;
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, topLeft);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, topRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, bottomRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, bottomLeft);

    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  }

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(type, context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      const event = new _render_Event_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        type,
        this.inversePixelTransform,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(context, frameState) {
    this.frameState = frameState;
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRERENDER, context, frameState);
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(context, frameState) {
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER, context, frameState);
  }

  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(
    center,
    resolution,
    rotation,
    pixelRatio,
    width,
    height,
    offsetX
  ) {
    const dx1 = width / 2;
    const dy1 = height / 2;
    const sx = pixelRatio / resolution;
    const sy = -sx;
    const dx2 = -center[0] + offsetX;
    const dy2 = -center[1];
    return (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
      this.tempTransform,
      dx1,
      dy1,
      sx,
      sy,
      -rotation,
      dx2,
      dy2
    );
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/TileLayer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/ImageTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/TileState.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/size.js");
/**
 * @module ol/renderer/canvas/TileLayer
 */












/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */
class CanvasTileLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(tileLayer) {
    super(tileLayer);

    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */
    this.extentChanged = true;

    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */
    this.renderedExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedPixelRatio;

    /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */
    this.renderedProjection = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedRevision;

    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */
    this.renderedTiles = [];

    /**
     * @private
     * @type {boolean}
     */
    this.newTiles_ = false;

    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */
    this.tmpExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();

    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */
    this.tmpTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, 0, 0);
  }

  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(tile) {
    const tileLayer = this.getLayer();
    const tileState = tile.getState();
    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return (
      tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED ||
      tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY ||
      (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR && !useInterimTilesOnError)
    );
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(z, x, y, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR) {
      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  }

  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }

    const layer = this.getLayer();
    const coordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );

    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)(layerExtent, coordinate)) {
        return null;
      }
    }

    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);

    for (
      let z = tileGrid.getZForResolution(viewState.resolution);
      z >= tileGrid.getMinZoom();
      --z
    ) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile = source.getTile(
        z,
        tileCoord[1],
        tileCoord[2],
        pixelRatio,
        projection
      );
      if (
        !(tile instanceof _ImageTile_js__WEBPACK_IMPORTED_MODULE_6__["default"] || tile instanceof _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_7__["default"]) ||
        (tile instanceof _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_7__["default"] && tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY)
      ) {
        return null;
      }

      if (tile.getState() !== _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
        continue;
      }

      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_8__.toSize)(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);

      const col = Math.floor(
        tilePixelRatio *
          ((coordinate[0] - tileOrigin[0]) / tileResolution -
            tileCoord[1] * tileSize[0])
      );

      const row = Math.floor(
        tilePixelRatio *
          ((tileOrigin[1] - coordinate[1]) / tileResolution -
            tileCoord[2] * tileSize[1])
      );

      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );

      return this.getImageData(tile.getImage(), col + gutter, row + gutter);
    }

    return null;
  }

  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(tiles, zoom, tile) {
    if (this.isDrawableTile(tile)) {
      return super.loadedTileCallback(tiles, zoom, tile);
    }
    return false;
  }

  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return !!this.getLayer().getSource();
  }

  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const rotation = viewState.rotation;
    const pixelRatio = frameState.pixelRatio;

    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);

    let extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    // desired dimensions of the canvas in pixels
    const width = Math.round(((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(extent) / resolution) * pixelRatio);
    const height = Math.round(((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(extent) / resolution) * pixelRatio);

    const layerExtent =
      layerState.extent && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection);
    if (layerExtent) {
      extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(
        extent,
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection)
      );
    }

    const dx = (tileResolution * width) / 2 / tilePixelRatio;
    const dy = (tileResolution * height) / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy,
    ];

    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);

    /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */
    const tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};

    const findLoadedTiles = this.createLoadedTileFinder(
      tileSource,
      projection,
      tilesToDrawByZ
    );

    const tmpExtent = this.tmpExtent;
    const tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    const viewport = rotation
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getRotatedViewport)(
          viewState.center,
          resolution,
          rotation,
          frameState.size
        )
      : undefined;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (
          rotation &&
          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)
        ) {
          continue;
        }
        const tile = this.getTile(z, x, y, frameState);
        if (this.isDrawableTile(tile)) {
          const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(this);
          if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            let inTransition = tile.inTransition(uid);
            if (inTransition && layerState.opacity !== 1) {
              // Skipping transition when layer is not fully opaque avoids visual artifacts.
              tile.endTransition(uid);
              inTransition = false;
            }
            if (
              !this.newTiles_ &&
              (inTransition || !this.renderedTiles.includes(tile))
            ) {
              this.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        const childTileRange = tileGrid.getTileCoordChildTileRange(
          tile.tileCoord,
          tmpTileRange,
          tmpExtent
        );

        let covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile.tileCoord,
            findLoadedTiles,
            tmpTileRange,
            tmpExtent
          );
        }
      }
    }

    const canvasScale =
      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;

    // set forward and inverse pixel transforms
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.compose)(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );

    const canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.toString)(this.pixelTransform);

    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context = this.context;
    const canvas = context.canvas;

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.makeInverse)(this.inversePixelTransform, this.pixelTransform);

    // set scale transform for calculating tile positions on the canvas
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.compose)(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }

    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }

    this.preRender(context, frameState);

    this.renderedTiles.length = 0;
    /** @type {Array<number>} */
    let zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_10__.ascending);

    let clips, clipZs, currentClip;
    if (
      layerState.opacity === 1 &&
      (!this.containerReused ||
        tileSource.getOpaque(frameState.viewState.projection))
    ) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(this.tempTransform, [
        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /
          tileResolution,
        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /
          tileResolution,
      ]);
      const tileGutter =
        tilePixelRatio * tileSource.getGutterForProjection(projection);
      const tilesToDraw = tilesToDrawByZ[currentZ];
      for (const tileCoordKey in tilesToDraw) {
        const tile = /** @type {import("../../ImageTile.js").default} */ (
          tilesToDraw[tileCoordKey]
        );
        const tileCoord = tile.tileCoord;

        // Calculate integer positions and sizes so that tiles align
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);
        const x = Math.round(origin[0] - xIndex * dx);
        const y = Math.round(origin[1] - yIndex * dy);
        const w = nextX - x;
        const h = nextY - y;
        const transition = z === currentZ;

        const inTransition =
          transition && tile.getAlpha((0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(this), frameState.time) !== 1;
        let contextSaved = false;
        if (!inTransition) {
          if (clips) {
            // Clip mask for regions in this tile that already filled by a higher z tile
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
            for (let i = 0, ii = clips.length; i < ii; ++i) {
              if (z !== currentZ && currentZ < clipZs[i]) {
                const clip = clips[i];
                if (
                  (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(
                    [x, y, x + w, y + h],
                    [clip[0], clip[3], clip[4], clip[7]]
                  )
                ) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }
                  context.beginPath();
                  // counter-clockwise (outer ring) for current tile
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  // clockwise (inner ring) for higher z tile
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }
        this.drawTileImage(
          tile,
          frameState,
          x,
          y,
          w,
          h,
          tileGutter,
          transition
        );
        if (clips && !inTransition) {
          if (contextSaved) {
            context.restore();
          }
          this.renderedTiles.unshift(tile);
        } else {
          this.renderedTiles.push(tile);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged =
      !this.renderedExtent_ || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.equals)(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;

    this.manageTilePyramid(
      frameState,
      tileSource,
      tileGrid,
      pixelRatio,
      projection,
      extent,
      z,
      tileLayer.getPreload()
    );
    this.scheduleExpireCache(frameState, tileSource);

    this.postRender(context, frameState);

    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    return this.container;
  }

  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
    const image = this.getTileImage(tile);
    if (!image) {
      return;
    }
    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha =
      layerState.opacity *
      (transition ? tile.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );

    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  }

  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }

  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile) {
    return tile.getImage();
  }

  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../Map.js").default} map Map.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      const postRenderFunction = function (tileSource, map, frameState) {
        const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(tileSource);
        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(
            frameState.viewState.projection,
            frameState.usedTiles[tileSourceKey]
          );
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */ (
          postRenderFunction
        )
      );
    }
  }

  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile) {
    // FIXME should we use tilesToDrawByZ instead?
    const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  }

  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(
    frameState,
    tileSource,
    tileGrid,
    pixelRatio,
    projection,
    extent,
    currentZ,
    preload,
    tileCallback
  ) {
    const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const tileQueue = frameState.tileQueue;
    const minZoom = tileGrid.getMinZoom();
    const rotation = frameState.viewState.rotation;
    const viewport = rotation
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getRotatedViewport)(
          frameState.viewState.center,
          frameState.viewState.resolution,
          rotation,
          frameState.size
        )
      : undefined;
    let tileCount = 0;
    let tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (
            rotation &&
            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)
          ) {
            continue;
          }
          if (currentZ - z <= preload) {
            ++tileCount;
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([
                  tile,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord),
                  tileResolution,
                ]);
              }
            }
            if (tileCallback !== undefined) {
              tileCallback(tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasTileLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorImageLayer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/canvas/ImageLayer.js");
/* harmony import */ var _VectorLayer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/renderer/canvas/VectorLayer.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/ImageCanvas.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/ImageState.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/rbush/rbush.min.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/ViewHint.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/extent.js");
/**
 * @module ol/renderer/canvas/VectorImageLayer
 */










/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
class CanvasVectorImageLayerRenderer extends _ImageLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {import("../../layer/VectorImage.js").default} layer Vector image layer.
   */
  constructor(layer) {
    super(layer);

    /**
     * @private
     * @type {import("./VectorLayer.js").default}
     */
    this.vectorRenderer_ = new _VectorLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"](layer);

    /**
     * @private
     * @type {number}
     */
    this.layerImageRatio_ = layer.getImageRatio();

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.coordinateToVectorPixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.create)();

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.renderedPixelToCoordinateTransform_ = null;
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    this.vectorRenderer_.dispose();
    super.disposeInternal();
  }

  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */
  getFeatures(pixel) {
    if (!this.vectorRenderer_) {
      return Promise.resolve([]);
    }
    const vectorPixel = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.apply)(
      this.coordinateToVectorPixelTransform_,
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice())
    );
    return this.vectorRenderer_.getFeatures(vectorPixel);
  }

  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    this.vectorRenderer_.handleFontsChanged();
  }

  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const viewResolution = viewState.resolution;

    const hints = frameState.viewHints;
    const vectorRenderer = this.vectorRenderer_;
    let renderedExtent = frameState.extent;
    if (this.layerImageRatio_ !== 1) {
      renderedExtent = renderedExtent.slice(0);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.scaleFromCenter)(renderedExtent, this.layerImageRatio_);
    }
    const width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getWidth)(renderedExtent) / viewResolution;
    const height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getHeight)(renderedExtent) / viewResolution;

    if (
      !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING] &&
      !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING] &&
      !(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(renderedExtent)
    ) {
      vectorRenderer.useContainer(null, null);
      const context = vectorRenderer.context;
      const layerState = frameState.layerStatesArray[frameState.layerIndex];
      context.globalAlpha = layerState.opacity;
      const imageLayerState = Object.assign({}, layerState, {opacity: 1});
      const imageFrameState = /** @type {import("../../Map.js").FrameState} */ (
        Object.assign({}, frameState, {
          declutterTree: new rbush__WEBPACK_IMPORTED_MODULE_0__(9),
          extent: renderedExtent,
          size: [width, height],
          viewState: /** @type {import("../../View.js").State} */ (
            Object.assign({}, frameState.viewState, {
              rotation: 0,
            })
          ),
          layerStatesArray: [imageLayerState],
          layerIndex: 0,
        })
      );
      let emptyImage = true;
      const image = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        renderedExtent,
        viewResolution,
        pixelRatio,
        context.canvas,
        function (callback) {
          if (
            vectorRenderer.prepareFrame(imageFrameState) &&
            vectorRenderer.replayGroupChanged
          ) {
            vectorRenderer.clipping = false;
            if (vectorRenderer.renderFrame(imageFrameState, null)) {
              vectorRenderer.renderDeclutter(imageFrameState);
              emptyImage = false;
            }
            callback();
          }
        }
      );

      image.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, () => {
        if (image.getState() !== _ImageState_js__WEBPACK_IMPORTED_MODULE_8__["default"].LOADED) {
          return;
        }
        this.image_ = emptyImage ? null : image;
        const imageResolution = image.getResolution();
        const imagePixelRatio = image.getPixelRatio();
        const renderedResolution =
          (imageResolution * pixelRatio) / imagePixelRatio;
        this.renderedResolution = renderedResolution;
        this.coordinateToVectorPixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.compose)(
          this.coordinateToVectorPixelTransform_,
          width / 2,
          height / 2,
          1 / renderedResolution,
          -1 / renderedResolution,
          0,
          -viewState.center[0],
          -viewState.center[1]
        );
      });
      image.load();
    }

    if (this.image_) {
      this.renderedPixelToCoordinateTransform_ =
        frameState.pixelToCoordinateTransform.slice();
    }

    return !!this.image_;
  }

  /**
   */
  preRender() {}

  /**
   */
  postRender() {}

  /**
   */
  renderDeclutter() {}

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    callback,
    matches
  ) {
    if (this.vectorRenderer_) {
      return this.vectorRenderer_.forEachFeatureAtCoordinate(
        coordinate,
        frameState,
        hitTolerance,
        callback,
        matches
      );
    }
    return super.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      callback,
      matches
    );
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasVectorImageLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorLayer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/ol/render/canvas/BuilderGroup.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/render/canvas/ExecutorGroup.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/ViewHint.js");
/* harmony import */ var _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/render/canvas/hitdetect.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/dom.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/renderer/vector.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/coordinate.js");
/**
 * @module ol/renderer/canvas/VectorLayer
 */














/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
class CanvasVectorLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(vectorLayer) {
    super(vectorLayer);

    /** @private */
    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);

    /**
     * @type {boolean}
     */
    this.animatingOrInteracting_;

    /**
     * @type {ImageData|null}
     */
    this.hitDetectionImageData_ = null;

    /**
     * @type {Array<import("../../Feature.js").default>}
     */
    this.renderedFeatures_ = null;

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.renderedResolution_ = NaN;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.renderedExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.wrappedRenderedExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();

    /**
     * @private
     * @type {number}
     */
    this.renderedRotation_;

    /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */
    this.renderedCenter_ = null;

    /**
     * @private
     * @type {import("../../proj/Projection").default}
     */
    this.renderedProjection_ = null;

    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */
    this.renderedRenderOrder_ = null;

    /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */
    this.replayGroup_ = null;

    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */
    this.replayGroupChanged = true;

    /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */
    this.declutterExecutorGroup = null;

    /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */
    this.clipping = true;

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.compositionContext_ = null;

    /**
     * @private
     * @type {number}
     */
    this.opacity_ = 1;
  }

  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  renderWorlds(executorGroup, frameState, declutterTree) {
    const extent = frameState.extent;
    const viewState = frameState.viewState;
    const center = viewState.center;
    const resolution = viewState.resolution;
    const projection = viewState.projection;
    const rotation = viewState.rotation;
    const projectionExtent = projection.getExtent();
    const vectorSource = this.getLayer().getSource();
    const pixelRatio = frameState.pixelRatio;
    const viewHints = frameState.viewHints;
    const snapToPixel = !(
      viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING]
    );
    const context = this.compositionContext_;
    const width = Math.round(frameState.size[0] * pixelRatio);
    const height = Math.round(frameState.size[1] * pixelRatio);

    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    const worldWidth = multiWorld ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent) : null;
    const endWorld = multiWorld
      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1
      : 1;
    let world = multiWorld
      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)
      : 0;
    do {
      const transform = this.getRenderTransform(
        center,
        resolution,
        rotation,
        pixelRatio,
        width,
        height,
        world * worldWidth
      );
      executorGroup.execute(
        context,
        1,
        transform,
        rotation,
        snapToPixel,
        undefined,
        declutterTree
      );
    } while (++world < endWorld);
  }

  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const compositionContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.createCanvasContext2D)(
        this.context.canvas.width,
        this.context.canvas.height,
        _Layer_js__WEBPACK_IMPORTED_MODULE_1__.canvasPool
      );
      this.compositionContext_ = compositionContext;
    } else {
      this.compositionContext_ = this.context;
    }
  }

  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const alpha = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_;
      this.context.drawImage(this.compositionContext_.canvas, 0, 0);
      this.context.globalAlpha = alpha;
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.releaseCanvas)(this.compositionContext_);
      _Layer_js__WEBPACK_IMPORTED_MODULE_1__.canvasPool.push(this.compositionContext_.canvas);
      this.compositionContext_ = null;
    }
  }

  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(frameState) {
    if (this.declutterExecutorGroup) {
      this.setupCompositionContext_();
      this.renderWorlds(
        this.declutterExecutorGroup,
        frameState,
        frameState.declutterTree
      );
      this.releaseCompositionContext_();
    }
  }

  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    const pixelRatio = frameState.pixelRatio;
    const layerState = frameState.layerStatesArray[frameState.layerIndex];

    // set forward and inverse pixel transforms
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.makeInverse)(this.inversePixelTransform, this.pixelTransform);

    const canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.toString)(this.pixelTransform);

    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context = this.context;
    const canvas = context.canvas;

    const replayGroup = this.replayGroup_;
    const declutterExecutorGroup = this.declutterExecutorGroup;
    if (
      (!replayGroup || replayGroup.isEmpty()) &&
      (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())
    ) {
      return null;
    }

    // resize and clear
    const width = Math.round(frameState.size[0] * pixelRatio);
    const height = Math.round(frameState.size[1] * pixelRatio);
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    this.preRender(context, frameState);

    const viewState = frameState.viewState;
    const projection = viewState.projection;

    this.opacity_ = layerState.opacity;
    this.setupCompositionContext_();

    // clipped rendering if layer extent is set
    let clipped = false;
    let render = true;
    if (layerState.extent && this.clipping) {
      const layerExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection);
      render = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(layerExtent, frameState.extent);
      clipped = render && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
      }
    }

    if (render) {
      this.renderWorlds(replayGroup, frameState);
    }

    if (clipped) {
      this.compositionContext_.restore();
    }

    this.releaseCompositionContext_();

    this.postRender(context, frameState);

    if (this.renderedRotation_ !== viewState.rotation) {
      this.renderedRotation_ = viewState.rotation;
      this.hitDetectionImageData_ = null;
    }
    return this.container;
  }

  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(pixel) {
    return new Promise((resolve) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const size = [this.context.canvas.width, this.context.canvas.height];
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(this.pixelTransform, size);
        const center = this.renderedCenter_;
        const resolution = this.renderedResolution_;
        const rotation = this.renderedRotation_;
        const projection = this.renderedProjection_;
        const extent = this.wrappedRenderedExtent_;
        const layer = this.getLayer();
        const transforms = [];
        const width = size[0] * _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_6__.HIT_DETECT_RESOLUTION;
        const height = size[1] * _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_6__.HIT_DETECT_RESOLUTION;
        transforms.push(
          this.getRenderTransform(
            center,
            resolution,
            rotation,
            _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_6__.HIT_DETECT_RESOLUTION,
            width,
            height,
            0
          ).slice()
        );
        const source = layer.getSource();
        const projectionExtent = projection.getExtent();
        if (
          source.getWrapX() &&
          projection.canWrapX() &&
          !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(projectionExtent, extent)
        ) {
          let startX = extent[0];
          const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);
          let world = 0;
          let offsetX;
          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_6__.HIT_DETECT_RESOLUTION,
                width,
                height,
                offsetX
              ).slice()
            );
            startX += worldWidth;
          }
          world = 0;
          startX = extent[2];
          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_6__.HIT_DETECT_RESOLUTION,
                width,
                height,
                offsetX
              ).slice()
            );
            startX -= worldWidth;
          }
        }

        this.hitDetectionImageData_ = (0,_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_6__.createHitDetectionImageData)(
          size,
          transforms,
          this.renderedFeatures_,
          layer.getStyleFunction(),
          extent,
          resolution,
          rotation
        );
      }
      resolve(
        (0,_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_6__.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    callback,
    matches
  ) {
    if (!this.replayGroup_) {
      return undefined;
    }
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const layer = this.getLayer();

    /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */
    const features = {};

    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position
     * @return {T|undefined} Callback result.
     */
    const featureCallback = function (feature, geometry, distanceSq) {
      const key = (0,_util_js__WEBPACK_IMPORTED_MODULE_7__.getUid)(feature);
      const match = features[key];
      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }
        matches.push(
          (features[key] = {
            feature: feature,
            layer: layer,
            geometry: geometry,
            distanceSq: distanceSq,
            callback: callback,
          })
        );
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }
        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }
      return undefined;
    };

    let result;
    const executorGroups = [this.replayGroup_];
    if (this.declutterExecutorGroup) {
      executorGroups.push(this.declutterExecutorGroup);
    }
    executorGroups.some((executorGroup) => {
      return (result = executorGroup.forEachFeatureAtCoordinate(
        coordinate,
        resolution,
        rotation,
        hitTolerance,
        featureCallback,
        executorGroup === this.declutterExecutorGroup &&
          frameState.declutterTree
          ? frameState.declutterTree.all().map((item) => item.value)
          : null
      ));
    });

    return result;
  }

  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  }

  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(event) {
    this.renderIfReadyAndVisible();
  }

  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    const vectorLayer = this.getLayer();
    const vectorSource = vectorLayer.getSource();
    if (!vectorSource) {
      return false;
    }

    const animating = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING];
    const interacting = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING];
    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (
      (this.ready && !updateWhileAnimating && animating) ||
      (!updateWhileInteracting && interacting)
    ) {
      this.animatingOrInteracting_ = true;
      return true;
    }
    this.animatingOrInteracting_ = false;

    const frameStateExtent = frameState.extent;
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const resolution = viewState.resolution;
    const pixelRatio = frameState.pixelRatio;
    const vectorLayerRevision = vectorLayer.getRevision();
    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_8__.defaultOrder;
    }

    const center = viewState.center.slice();
    const extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.buffer)(
      frameStateExtent,
      vectorLayerRenderBuffer * resolution
    );
    const renderedExtent = extent.slice();
    const loadExtents = [extent.slice()];
    const projectionExtent = projection.getExtent();

    if (
      vectorSource.getWrapX() &&
      projection.canWrapX() &&
      !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(projectionExtent, frameState.extent)
    ) {
      // For the replay group, we need an extent that intersects the real world
      // (-180° to +180°). To support geometries in a coordinate range from -540°
      // to +540°, we add at least 1 world width on each side of the projection
      // extent. If the viewport is wider than the world, we need to add half of
      // the viewport width to make sure we cover the whole viewport.
      const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);
      const gutter = Math.max((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_9__.wrapX)(center, projection);
      const loadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.wrapX)(loadExtents[0], projection);
      // If the extent crosses the date line, we load data for both edges of the worlds
      if (
        loadExtent[0] < projectionExtent[0] &&
        loadExtent[2] < projectionExtent[2]
      ) {
        loadExtents.push([
          loadExtent[0] + worldWidth,
          loadExtent[1],
          loadExtent[2] + worldWidth,
          loadExtent[3],
        ]);
      } else if (
        loadExtent[0] > projectionExtent[0] &&
        loadExtent[2] > projectionExtent[2]
      ) {
        loadExtents.push([
          loadExtent[0] - worldWidth,
          loadExtent[1],
          loadExtent[2] - worldWidth,
          loadExtent[3],
        ]);
      }
    }

    if (
      this.ready &&
      this.renderedResolution_ == resolution &&
      this.renderedRevision_ == vectorLayerRevision &&
      this.renderedRenderOrder_ == vectorLayerRenderOrder &&
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(this.wrappedRenderedExtent_, extent)
    ) {
      if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_10__.equals)(this.renderedExtent_, renderedExtent)) {
        this.hitDetectionImageData_ = null;
        this.renderedExtent_ = renderedExtent;
      }
      this.renderedCenter_ = center;
      this.replayGroupChanged = false;
      return true;
    }

    this.replayGroup_ = null;

    const replayGroup = new _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_11__["default"](
      (0,_vector_js__WEBPACK_IMPORTED_MODULE_8__.getTolerance)(resolution, pixelRatio),
      extent,
      resolution,
      pixelRatio
    );

    let declutterBuilderGroup;
    if (this.getLayer().getDeclutter()) {
      declutterBuilderGroup = new _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_11__["default"](
        (0,_vector_js__WEBPACK_IMPORTED_MODULE_8__.getTolerance)(resolution, pixelRatio),
        extent,
        resolution,
        pixelRatio
      );
    }

    const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
    let userTransform;
    if (userProjection) {
      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
        const extent = loadExtents[i];
        const userExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, projection);
        vectorSource.loadFeatures(
          userExtent,
          (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserResolution)(resolution, projection),
          userProjection
        );
      }
      userTransform = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(userProjection, projection);
    } else {
      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures(loadExtents[i], resolution, projection);
      }
    }

    const squaredTolerance = (0,_vector_js__WEBPACK_IMPORTED_MODULE_8__.getSquaredTolerance)(resolution, pixelRatio);
    let ready = true;
    const render =
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       */
      (feature) => {
        let styles;
        const styleFunction =
          feature.getStyleFunction() || vectorLayer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
        if (styles) {
          const dirty = this.renderFeature(
            feature,
            squaredTolerance,
            styles,
            replayGroup,
            userTransform,
            declutterBuilderGroup
          );
          ready = ready && !dirty;
        }
      };

    const userExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, projection);
    /** @type {Array<import("../../Feature.js").default>} */
    const features = vectorSource.getFeaturesInExtent(userExtent);
    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }
    for (let i = 0, ii = features.length; i < ii; ++i) {
      render(features[i]);
    }
    this.renderedFeatures_ = features;
    this.ready = ready;

    const replayGroupInstructions = replayGroup.finish();
    const executorGroup = new _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_12__["default"](
      extent,
      resolution,
      pixelRatio,
      vectorSource.getOverlaps(),
      replayGroupInstructions,
      vectorLayer.getRenderBuffer()
    );

    if (declutterBuilderGroup) {
      this.declutterExecutorGroup = new _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_12__["default"](
        extent,
        resolution,
        pixelRatio,
        vectorSource.getOverlaps(),
        declutterBuilderGroup.finish(),
        vectorLayer.getRenderBuffer()
      );
    }

    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = renderedExtent;
    this.wrappedRenderedExtent_ = extent;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;

    this.replayGroupChanged = true;
    return true;
  }

  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(
    feature,
    squaredTolerance,
    styles,
    builderGroup,
    transform,
    declutterBuilderGroup
  ) {
    if (!styles) {
      return false;
    }
    let loading = false;
    if (Array.isArray(styles)) {
      for (let i = 0, ii = styles.length; i < ii; ++i) {
        loading =
          (0,_vector_js__WEBPACK_IMPORTED_MODULE_8__.renderFeature)(
            builderGroup,
            feature,
            styles[i],
            squaredTolerance,
            this.boundHandleStyleImageChange_,
            transform,
            declutterBuilderGroup
          ) || loading;
      }
    } else {
      loading = (0,_vector_js__WEBPACK_IMPORTED_MODULE_8__.renderFeature)(
        builderGroup,
        feature,
        styles,
        squaredTolerance,
        this.boundHandleStyleImageChange_,
        transform,
        declutterBuilderGroup
      );
    }
    return loading;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasVectorLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/vector.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultOrder: () => (/* binding */ defaultOrder),
/* harmony export */   getSquaredTolerance: () => (/* binding */ getSquaredTolerance),
/* harmony export */   getTolerance: () => (/* binding */ getTolerance),
/* harmony export */   renderFeature: () => (/* binding */ renderFeature)
/* harmony export */ });
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/ImageState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/renderer/vector
 */



/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
const SIMPLIFY_TOLERANCE = 0.5;

/**
 * @const
 * @type {Object<import("../geom/Geometry.js").Type,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */
const GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry,
};

/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */
function defaultOrder(feature1, feature2) {
  return parseInt((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(feature1), 10) - parseInt((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(feature2), 10);
}

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
function getTolerance(resolution, pixelRatio) {
  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderCircleGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */
function renderFeature(
  replayGroup,
  feature,
  style,
  squaredTolerance,
  listener,
  transform,
  declutterBuilderGroup
) {
  let loading = false;
  const imageStyle = style.getImage();
  if (imageStyle) {
    const imageState = imageStyle.getImageState();
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
        imageStyle.load();
      }
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }
  renderFeatureInternal(
    replayGroup,
    feature,
    style,
    squaredTolerance,
    transform,
    declutterBuilderGroup
  );

  return loading;
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderFeatureInternal(
  replayGroup,
  feature,
  style,
  squaredTolerance,
  transform,
  declutterBuilderGroup
) {
  const geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(
    squaredTolerance,
    transform
  );
  const renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(
      replayGroup,
      simplifiedGeometry,
      style,
      feature,
      declutterBuilderGroup
    );
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == 'GeometryCollection') {
    const geometries =
      /** @type {import("../geom/GeometryCollection.js").default} */ (
        geometry
      ).getGeometries();
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');
  replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */ (geometry),
    feature,
    style.getRenderer(),
    style.getHitDetectionRenderer()
  );
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderGeometryCollectionGeometry(
  replayGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const geometries = geometry.getGeometriesArray();
  let i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(
      replayGroup,
      geometries[i],
      style,
      feature,
      declutterBuilderGroup
    );
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderLineStringGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      'LineString'
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiLineStringGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      'LineString'
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiPolygonGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderPointGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== 'none') {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === 'obstacle') {
          // draw in non-declutter group:
          const imageReplay = builderGroup.getBuilder(
            style.getZIndex(),
            'Image'
          );
          imageReplay.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      'Image'
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiPointGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== 'none') {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === 'obstacle') {
          // draw in non-declutter group:
          const imageReplay = builderGroup.getBuilder(
            style.getZIndex(),
            'Image'
          );
          imageReplay.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      'Image'
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderPolygonGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}


/***/ }),

/***/ "./node_modules/ol/renderer/webgl/Layer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _layer_Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/layer/Property.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/renderer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/render/EventType.js");
/* harmony import */ var _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/webgl/Helper.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/transform.js");
/**
 * @module ol/renderer/webgl/Layer
 */







/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} Options
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */

/**
 * @classdesc
 * Base WebGL renderer class.
 * Holds all logic related to data manipulation & some common rendering logic
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
class WebGLLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */
  constructor(layer, options) {
    super(layer);

    options = options || {};

    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform is only
     * set before dispatching rendering events.
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.inversePixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.pixelContext_ = null;

    /**
     * @private
     */
    this.postProcesses_ = options.postProcesses;

    /**
     * @private
     */
    this.uniforms_ = options.uniforms;

    /**
     * @type {WebGLHelper}
     * @protected
     */
    this.helper;

    layer.addChangeListener(_layer_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAP, this.removeHelper.bind(this));

    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);
    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
  }

  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPreComposeEvent(context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PRECOMPOSE)) {
      const event = new _render_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"](
        _render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PRECOMPOSE,
        undefined,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }

  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPostComposeEvent(context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POSTCOMPOSE)) {
      const event = new _render_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"](
        _render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POSTCOMPOSE,
        undefined,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }

  /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */
  reset(options) {
    this.uniforms_ = options.uniforms;
    if (this.helper) {
      this.helper.setUniforms(this.uniforms_);
    }
  }

  /**
   * @protected
   */
  removeHelper() {
    if (this.helper) {
      this.helper.dispose();
      delete this.helper;
    }
  }

  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    if (this.getLayer().getRenderSource()) {
      let incrementGroup = true;
      let groupNumber = -1;
      let className;
      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {
        const layer = frameState.layerStatesArray[i].layer;
        const renderer = layer.getRenderer();
        if (!(renderer instanceof WebGLLayerRenderer)) {
          incrementGroup = true;
          continue;
        }
        const layerClassName = layer.getClassName();
        if (incrementGroup || layerClassName !== className) {
          groupNumber += 1;
          incrementGroup = false;
        }
        className = layerClassName;
        if (renderer === this) {
          break;
        }
      }

      const canvasCacheKey =
        'map/' + frameState.mapId + '/group/' + groupNumber;

      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {
        this.removeHelper();

        this.helper = new _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
          postProcesses: this.postProcesses_,
          uniforms: this.uniforms_,
          canvasCacheKey: canvasCacheKey,
        });

        if (className) {
          this.helper.getCanvas().className = className;
        }

        this.afterHelperCreated();
      }
    }

    return this.prepareFrameInternal(frameState);
  }

  /**
   * @protected
   */
  afterHelperCreated() {}

  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */
  prepareFrameInternal(frameState) {
    return true;
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    this.removeHelper();
    super.disposeInternal();
  }

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(type, context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(
        this.inversePixelTransform_,
        0,
        0,
        frameState.pixelRatio,
        -frameState.pixelRatio,
        0,
        0,
        -frameState.size[1]
      );

      const event = new _render_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"](
        type,
        this.inversePixelTransform_,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }

  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(context, frameState) {
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PRERENDER, context, frameState);
  }

  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(context, frameState) {
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POSTRENDER, context, frameState);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/webgl/PointsLayer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _layer_BaseVector_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/layer/BaseVector.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/ViewHint.js");
/* harmony import */ var _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/webgl/Buffer.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/renderer/webgl/Layer.js");
/* harmony import */ var _webgl_RenderTarget_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/ol/webgl/RenderTarget.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/webgl/Helper.js");
/* harmony import */ var _render_webgl_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/render/webgl/constants.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _render_webgl_utils_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/ol/render/webgl/utils.js");
/* harmony import */ var _worker_webgl_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/worker/webgl.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/events.js");
/**
 * @module ol/renderer/webgl/PointsLayer
 */

















/**
 * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different
 * for each feature.
 * @property {string} name Attribute name.
 * @property {function(import("../../Feature").default, Object<string, *>):number} callback This callback computes the numerical value of the
 * attribute for a given feature (properties are available as 2nd arg for quicker access).
 */

/**
 * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize
 * rebuildBuffers by accessing these objects quicker.
 * @property {import("../../Feature").default} feature Feature
 * @property {Object<string, *>} properties Feature properties
 * @property {import("../../geom").Geometry} geometry Feature geometry
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.
 * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then
 * passed to the GPU. The `name` property of each attribute will serve as its identifier:
 *  * In the vertex shader as an `attribute` by prefixing it with `a_`
 *  * In the fragment shader as a `varying` by prefixing it with `v_`
 * Please note that these can only be numerical values.
 * @property {string} vertexShader Vertex shader source, mandatory.
 * @property {string} fragmentShader Fragment shader source, mandatory.
 * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.
 * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.
 * @property {Array<import("./Layer").PostProcessesOptions>} [postProcesses] Post-processes definitions
 */

/**
 * @classdesc
 * WebGL vector renderer optimized for points.
 * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU
 * every time the vector source changes.
 *
 * You need to provide vertex and fragment shaders for rendering. This can be done using
 * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute
 * containing the screen-space projected center of the quad, as well as a `a_index` attribute
 * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).
 *
 * To include variable attributes in the shaders, you need to declare them using the `attributes` property of
 * the options object like so:
 * ```js
 * new WebGLPointsLayerRenderer(layer, {
 *   attributes: [
 *     {
 *       name: 'size',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *     {
 *       name: 'weight',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *   ],
 *   vertexShader:
 *     // shader using attribute a_weight and a_size
 *   fragmentShader:
 *     // shader using varying v_weight and v_size
 * ```
 *
 * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`
 * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain
 * the final color that will have to be output for hit detection to work.
 *
 * The following uniform is used for the main texture: `u_texture`.
 * The following uniform is used for the layer opacity: `u_opacity`.
 *
 * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.
 *
 * Points are rendered as quads with the following structure:
 *
 * ```
 *   (u0, v1)      (u1, v1)
 *  [3]----------[2]
 *   |`           |
 *   |  `         |
 *   |    `       |
 *   |      `     |
 *   |        `   |
 *   |          ` |
 *  [0]----------[1]
 *   (u0, v0)      (u1, v0)
 *  ```
 *
 * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.
 *
 * @api
 */
class WebGLPointsLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(layer, options) {
    const uniforms = options.uniforms || {};
    const projectionMatrixTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();
    uniforms[_webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__.DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;

    super(layer, {
      uniforms: uniforms,
      postProcesses: options.postProcesses,
    });

    this.sourceRevision_ = -1;

    this.verticesBuffer_ = new _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_3__["default"](_webgl_js__WEBPACK_IMPORTED_MODULE_4__.ARRAY_BUFFER, _webgl_js__WEBPACK_IMPORTED_MODULE_4__.DYNAMIC_DRAW);
    this.hitVerticesBuffer_ = new _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_3__["default"](_webgl_js__WEBPACK_IMPORTED_MODULE_4__.ARRAY_BUFFER, _webgl_js__WEBPACK_IMPORTED_MODULE_4__.DYNAMIC_DRAW);
    this.indicesBuffer_ = new _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_3__["default"](
      _webgl_js__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_ARRAY_BUFFER,
      _webgl_js__WEBPACK_IMPORTED_MODULE_4__.DYNAMIC_DRAW
    );

    /**
     * @private
     */
    this.vertexShader_ = options.vertexShader;

    /**
     * @private
     */
    this.fragmentShader_ = options.fragmentShader;

    /**
     * @type {WebGLProgram}
     * @private
     */
    this.program_;

    /**
     * @type {boolean}
     * @private
     */
    this.hitDetectionEnabled_ =
      options.hitFragmentShader && options.hitVertexShader ? true : false;

    /**
     * @private
     */
    this.hitVertexShader_ = options.hitVertexShader;

    /**
     * @private
     */
    this.hitFragmentShader_ = options.hitFragmentShader;

    /**
     * @type {WebGLProgram}
     * @private
     */
    this.hitProgram_;

    const customAttributes = options.attributes
      ? options.attributes.map(function (attribute) {
          return {
            name: 'a_' + attribute.name,
            size: 1,
            type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__.AttributeType.FLOAT,
          };
        })
      : [];

    /**
     * A list of attributes used by the renderer. By default only the position and
     * index of the vertex (0 to 3) are required.
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     */
    this.attributes = [
      {
        name: 'a_position',
        size: 2,
        type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__.AttributeType.FLOAT,
      },
      {
        name: 'a_index',
        size: 1,
        type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__.AttributeType.FLOAT,
      },
    ].concat(customAttributes);

    /**
     * A list of attributes used for hit detection.
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     */
    this.hitDetectionAttributes = [
      {
        name: 'a_position',
        size: 2,
        type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__.AttributeType.FLOAT,
      },
      {
        name: 'a_index',
        size: 1,
        type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__.AttributeType.FLOAT,
      },
      {
        name: 'a_hitColor',
        size: 4,
        type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__.AttributeType.FLOAT,
      },
      {
        name: 'a_featureUid',
        size: 1,
        type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_2__.AttributeType.FLOAT,
      },
    ].concat(customAttributes);

    this.customAttributes = options.attributes ? options.attributes : [];

    this.previousExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.createEmpty)();

    /**
     * This transform is updated on every frame and is the composition of:
     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)
     * - current world->screen transform
     * @type {import("../../transform.js").Transform}
     * @private
     */
    this.currentTransform_ = projectionMatrixTransform;

    /**
     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space
     * @type {import("../../transform.js").Transform}
     * @private
     */
    this.renderTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();

    /**
     * @type {import("../../transform.js").Transform}
     * @private
     */
    this.invertRenderTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();

    /**
     * @type {Float32Array}
     * @private
     */
    this.renderInstructions_ = new Float32Array(0);

    /**
     * These instructions are used for hit detection
     * @type {Float32Array}
     * @private
     */
    this.hitRenderInstructions_ = new Float32Array(0);

    /**
     * @type {WebGLRenderTarget}
     * @private
     */
    this.hitRenderTarget_;

    /**
     * Keep track of latest message sent to worker
     * @type {number}
     * @private
     */
    this.lastSentId = 0;

    /**
     * @private
     */
    this.worker_ = (0,_worker_webgl_js__WEBPACK_IMPORTED_MODULE_6__.create)();

    this.worker_.addEventListener(
      'message',
      /**
       * @param {*} event Event.
       */
      (event) => {
        const received = event.data;
        if (received.type === _render_webgl_constants_js__WEBPACK_IMPORTED_MODULE_7__.WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {
          const projectionTransform = received.projectionTransform;
          if (received.hitDetection) {
            this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);
            this.helper.flushBufferData(this.hitVerticesBuffer_);
          } else {
            this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);
            this.helper.flushBufferData(this.verticesBuffer_);
          }
          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);
          this.helper.flushBufferData(this.indicesBuffer_);

          this.renderTransform_ = projectionTransform;
          (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.makeInverse)(
            this.invertRenderTransform_,
            this.renderTransform_
          );
          if (received.hitDetection) {
            this.hitRenderInstructions_ = new Float32Array(
              event.data.renderInstructions
            );
          } else {
            this.renderInstructions_ = new Float32Array(
              event.data.renderInstructions
            );
            if (received.id === this.lastSentId) {
              this.ready = true;
            }
          }

          this.getLayer().changed();
        }
      }
    );

    /**
     * This object will be updated when the source changes. Key is uid.
     * @type {Object<string, FeatureCacheItem>}
     * @private
     */
    this.featureCache_ = {};

    /**
     * Amount of features in the cache.
     * @type {number}
     * @private
     */
    this.featureCount_ = 0;

    const source = this.getLayer().getSource();
    this.sourceListenKeys_ = [
      (0,_events_js__WEBPACK_IMPORTED_MODULE_8__.listen)(
        source,
        _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE,
        this.handleSourceFeatureAdded_,
        this
      ),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_8__.listen)(
        source,
        _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGEFEATURE,
        this.handleSourceFeatureChanged_,
        this
      ),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_8__.listen)(
        source,
        _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_8__.listen)(
        source,
        _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CLEAR,
        this.handleSourceFeatureClear_,
        this
      ),
    ];
    source.forEachFeature((feature) => {
      this.featureCache_[(0,_util_js__WEBPACK_IMPORTED_MODULE_10__.getUid)(feature)] = {
        feature: feature,
        properties: feature.getProperties(),
        geometry: feature.getGeometry(),
      };
      this.featureCount_++;
    });
  }

  afterHelperCreated() {
    this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    );

    if (this.hitDetectionEnabled_) {
      this.hitProgram_ = this.helper.getProgram(
        this.hitFragmentShader_,
        this.hitVertexShader_
      );

      this.hitRenderTarget_ = new _webgl_RenderTarget_js__WEBPACK_IMPORTED_MODULE_11__["default"](this.helper);
    }
  }

  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(event) {
    const feature = event.feature;
    this.featureCache_[(0,_util_js__WEBPACK_IMPORTED_MODULE_10__.getUid)(feature)] = {
      feature: feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry(),
    };
    this.featureCount_++;
  }

  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(event) {
    const feature = event.feature;
    this.featureCache_[(0,_util_js__WEBPACK_IMPORTED_MODULE_10__.getUid)(feature)] = {
      feature: feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry(),
    };
  }

  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(event) {
    const feature = event.feature;
    delete this.featureCache_[(0,_util_js__WEBPACK_IMPORTED_MODULE_10__.getUid)(feature)];
    this.featureCount_--;
  }

  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.featureCache_ = {};
    this.featureCount_ = 0;
  }

  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState) {
    const gl = this.helper.getGL();
    this.preRender(gl, frameState);

    const projection = frameState.viewState.projection;
    const layer = this.getLayer();
    const vectorSource = layer.getSource();
    // FIXME fix hit detection isn't reliable when rendering multiple worlds
    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    const projectionExtent = projection.getExtent();

    const extent = frameState.extent;
    const worldWidth = multiWorld ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getWidth)(projectionExtent) : null;
    const endWorld = multiWorld
      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1
      : 1;

    const startWorld = multiWorld
      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)
      : 0;

    let world = startWorld;
    const renderCount = this.indicesBuffer_.getSize();

    do {
      // apply the current projection transform with the invert of the one used to fill buffers
      this.helper.makeProjectionTransform(frameState, this.currentTransform_);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.translate)(this.currentTransform_, world * worldWidth, 0);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.multiply)(this.currentTransform_, this.invertRenderTransform_);
      this.helper.applyUniforms(frameState);

      this.helper.drawElements(0, renderCount);
    } while (++world < endWorld);

    this.helper.finalizeDraw(
      frameState,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    );
    const canvas = this.helper.getCanvas();

    if (this.hitDetectionEnabled_) {
      this.renderHitDetection(frameState, startWorld, endWorld, worldWidth);
      this.hitRenderTarget_.clearCachedData();
    }

    this.postRender(gl, frameState);

    return canvas;
  }

  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrameInternal(frameState) {
    const layer = this.getLayer();
    const vectorSource = layer.getSource();
    const viewState = frameState.viewState;
    const viewNotMoving =
      !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_12__["default"].ANIMATING] &&
      !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_12__["default"].INTERACTING];
    const extentChanged = !(0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.equals)(this.previousExtent_, frameState.extent);
    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();

    if (sourceChanged) {
      this.sourceRevision_ = vectorSource.getRevision();
    }

    if (viewNotMoving && (extentChanged || sourceChanged)) {
      const projection = viewState.projection;
      const resolution = viewState.resolution;

      const renderBuffer =
        layer instanceof _layer_BaseVector_js__WEBPACK_IMPORTED_MODULE_13__["default"] ? layer.getRenderBuffer() : 0;
      const extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.buffer)(frameState.extent, renderBuffer * resolution);
      vectorSource.loadFeatures(extent, resolution, projection);

      this.rebuildBuffers_(frameState);
      this.previousExtent_ = frameState.extent.slice();
    }

    this.helper.useProgram(this.program_, frameState);
    this.helper.prepareDraw(frameState);

    // write new data
    this.helper.bindBuffer(this.verticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.attributes);

    return true;
  }

  /**
   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  rebuildBuffers_(frameState) {
    // saves the projection transform for the current frame state
    const projectionTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();
    this.helper.makeProjectionTransform(frameState, projectionTransform);

    // here we anticipate the amount of render instructions that we well generate
    // this can be done since we know that for normal render we only have x, y as base instructions,
    // and x, y, r, g, b, a and featureUid for hit render instructions
    // and we also know the amount of custom attributes to append to these
    const totalInstructionsCount =
      (2 + this.customAttributes.length) * this.featureCount_;
    if (
      !this.renderInstructions_ ||
      this.renderInstructions_.length !== totalInstructionsCount
    ) {
      this.renderInstructions_ = new Float32Array(totalInstructionsCount);
    }
    if (this.hitDetectionEnabled_) {
      const totalHitInstructionsCount =
        (7 + this.customAttributes.length) * this.featureCount_;
      if (
        !this.hitRenderInstructions_ ||
        this.hitRenderInstructions_.length !== totalHitInstructionsCount
      ) {
        this.hitRenderInstructions_ = new Float32Array(
          totalHitInstructionsCount
        );
      }
    }

    // loop on features to fill the buffer
    let featureCache, geometry;
    const tmpCoords = [];
    const tmpColor = [];
    let renderIndex = 0;
    let hitIndex = 0;
    let hitColor;
    for (const featureUid in this.featureCache_) {
      featureCache = this.featureCache_[featureUid];
      geometry = /** @type {import("../../geom").Point} */ (
        featureCache.geometry
      );
      if (!geometry || geometry.getType() !== 'Point') {
        continue;
      }

      tmpCoords[0] = geometry.getFlatCoordinates()[0];
      tmpCoords[1] = geometry.getFlatCoordinates()[1];
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.apply)(projectionTransform, tmpCoords);

      hitColor = (0,_render_webgl_utils_js__WEBPACK_IMPORTED_MODULE_14__.colorEncodeId)(hitIndex + 6, tmpColor);

      this.renderInstructions_[renderIndex++] = tmpCoords[0];
      this.renderInstructions_[renderIndex++] = tmpCoords[1];

      // for hit detection, the feature uid is saved in the opacity value
      // and the index of the opacity value is encoded in the color values
      if (this.hitDetectionEnabled_) {
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[0];
        this.hitRenderInstructions_[hitIndex++] = hitColor[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[2];
        this.hitRenderInstructions_[hitIndex++] = hitColor[3];
        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);
      }

      // pushing custom attributes
      let value;
      for (let j = 0; j < this.customAttributes.length; j++) {
        value = this.customAttributes[j].callback(
          featureCache.feature,
          featureCache.properties
        );
        this.renderInstructions_[renderIndex++] = value;
        if (this.hitDetectionEnabled_) {
          this.hitRenderInstructions_[hitIndex++] = value;
        }
      }
    }

    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */
    const message = {
      id: ++this.lastSentId,
      type: _render_webgl_constants_js__WEBPACK_IMPORTED_MODULE_7__.WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesSize: this.customAttributes.length,
    };
    // additional properties will be sent back as-is by the worker
    message['projectionTransform'] = projectionTransform;
    this.ready = false;
    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);
    this.renderInstructions_ = null;

    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */
    if (this.hitDetectionEnabled_) {
      const hitMessage = {
        id: 0,
        type: _render_webgl_constants_js__WEBPACK_IMPORTED_MODULE_7__.WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,
        renderInstructions: this.hitRenderInstructions_.buffer,
        customAttributesSize: 5 + this.customAttributes.length,
      };
      hitMessage['projectionTransform'] = projectionTransform;
      hitMessage['hitDetection'] = true;
      this.worker_.postMessage(hitMessage, [
        this.hitRenderInstructions_.buffer,
      ]);
      this.hitRenderInstructions_ = null;
    }
  }

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    callback,
    matches
  ) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_15__.assert)(this.hitDetectionEnabled_, 66);
    if (!this.hitRenderInstructions_) {
      return undefined;
    }

    const pixel = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.apply)(
      frameState.coordinateToPixelTransform,
      coordinate.slice()
    );

    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];
    const index = (0,_render_webgl_utils_js__WEBPACK_IMPORTED_MODULE_14__.colorDecodeId)(color);
    const opacity = this.hitRenderInstructions_[index];
    const uid = Math.floor(opacity).toString();

    const source = this.getLayer().getSource();
    const feature = source.getFeatureByUid(uid);
    if (feature) {
      return callback(feature, this.getLayer(), null);
    }
    return undefined;
  }

  /**
   * Render the hit detection data to the corresponding render target
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderHitDetection(frameState, startWorld, endWorld, worldWidth) {
    // skip render entirely if vertex buffers not ready/generated yet
    if (!this.hitVerticesBuffer_.getSize()) {
      return;
    }

    let world = startWorld;

    this.hitRenderTarget_.setSize([
      Math.floor(frameState.size[0] / 2),
      Math.floor(frameState.size[1] / 2),
    ]);

    this.helper.useProgram(this.hitProgram_, frameState);
    this.helper.prepareDrawToRenderTarget(
      frameState,
      this.hitRenderTarget_,
      true
    );

    this.helper.bindBuffer(this.hitVerticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.hitDetectionAttributes);

    do {
      this.helper.makeProjectionTransform(frameState, this.currentTransform_);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.translate)(this.currentTransform_, world * worldWidth, 0);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.multiply)(this.currentTransform_, this.invertRenderTransform_);
      this.helper.applyUniforms(frameState);

      const renderCount = this.indicesBuffer_.getSize();
      this.helper.drawElements(0, renderCount);
    } while (++world < endWorld);
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    this.worker_.terminate();
    this.layer_ = null;
    this.sourceListenKeys_.forEach(function (key) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_8__.unlistenByKey)(key);
    });
    this.sourceListenKeys_ = null;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLPointsLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/reproj.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateSourceExtentResolution: () => (/* binding */ calculateSourceExtentResolution),
/* harmony export */   calculateSourceResolution: () => (/* binding */ calculateSourceResolution),
/* harmony export */   canvasPool: () => (/* binding */ canvasPool),
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/dom.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/math.js");
/**
 * @module ol/reproj
 */





let brokenDiagonalRendering_;

/**
 * @type {Array<HTMLCanvasElement>}
 */
const canvasPool = [];

/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}

/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */
function verifyBrokenDiagonalRendering(data, offset) {
  // the values ought to be close to the rgba(210, 0, 0, 0.75)
  return (
    Math.abs(data[offset * 4] - 210) > 2 ||
    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2
  );
}

/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === undefined) {
    const ctx = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(6, 6, canvasPool);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ =
      verifyBrokenDiagonalRendering(data, 0) ||
      verifyBrokenDiagonalRendering(data, 4) ||
      verifyBrokenDiagonalRendering(data, 8);
    (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.releaseCanvas)(ctx);
    canvasPool.push(ctx.canvas);
  }

  return brokenDiagonalRendering_;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(
  sourceProj,
  targetProj,
  targetCenter,
  targetResolution
) {
  const sourceCenter = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transform)(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  let sourceResolution = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(
    targetProj,
    targetResolution,
    targetCenter
  );

  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)(sourceExtent, sourceCenter)) {
    const compensationFactor =
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(sourceProj, sourceResolution, sourceCenter) /
      sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceExtentResolution(
  sourceProj,
  targetProj,
  targetExtent,
  targetResolution
) {
  const targetCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getCenter)(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.forEachCorner)(targetExtent, function (corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }

  return sourceResolution;
}

/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
 */

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(
  width,
  height,
  pixelRatio,
  sourceResolution,
  sourceExtent,
  targetResolution,
  targetExtent,
  triangulation,
  sources,
  gutter,
  renderEdges,
  interpolate
) {
  const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );

  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }

  context.globalCompositeOperation = 'lighter';

  const sourceDataExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.extend)(sourceDataExtent, src.extent);
  });

  const canvasWidthInUnits = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(sourceDataExtent);
  const canvasHeightInUnits = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(sourceDataExtent);
  const stitchContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),
    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution),
    canvasPool
  );

  if (!interpolate) {
    stitchContext.imageSmoothingEnabled = false;
  }

  const stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function (src, i, arr) {
    const xPos = src.extent[0] - sourceDataExtent[0];
    const yPos = -(src.extent[3] - sourceDataExtent[3]);
    const srcWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(src.extent);
    const srcHeight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(src.extent);

    // This test should never fail -- but it does. Need to find a fix the upstream condition
    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(
        src.image,
        gutter,
        gutter,
        src.image.width - 2 * gutter,
        src.image.height - 2 * gutter,
        xPos * stitchScale,
        yPos * stitchScale,
        srcWidth * stitchScale,
        srcHeight * stitchScale
      );
    }
  });

  const targetTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(targetExtent);

  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0],
      y0 = source[0][1];
    let x1 = source[1][0],
      y1 = source[1][1];
    let x2 = source[2][0],
      y2 = source[2][1];
    // Make sure that everything is on pixel boundaries
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0],
    ];
    const affineCoefs = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.solveLinearSystem)(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();

    if (isBrokenDiagonalRendering() || !interpolate) {
      // Make sure that all lines are horizontal or vertical
      context.moveTo(u1, v1);
      // This is the diagonal line. Do it in 4 steps
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        // Go horizontally
        context.lineTo(
          u1 + pixelRound(((step + 1) * ud) / steps),
          v1 + pixelRound((step * vd) / (steps - 1))
        );
        // Go vertically
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound(((step + 1) * ud) / steps),
            v1 + pixelRound(((step + 1) * vd) / (steps - 1))
          );
        }
      }
      // We are almost at u0r, v0r
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }

    context.clip();

    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );

    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );

    context.scale(
      sourceResolution / pixelRatio,
      -sourceResolution / pixelRatio
    );

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.releaseCanvas)(stitchContext);
  canvasPool.push(stitchContext.canvas);

  if (renderEdges) {
    context.save();

    context.globalCompositeOperation = 'source-over';
    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}


/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/reproj/common.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/TileState.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/reproj/Triangulation.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/reproj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/dom.js");
/**
 * @module ol/reproj/Tile
 */












/**
 * @typedef {function(number, number, number, number) : (import("../ImageTile.js").default)} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
class ReprojTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   */
  constructor(
    sourceProj,
    sourceTileGrid,
    targetProj,
    targetTileGrid,
    tileCoord,
    wrappedTileCoord,
    pixelRatio,
    gutter,
    getTileFunction,
    errorThreshold,
    renderEdges,
    interpolate
  ) {
    super(tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE, {interpolate: !!interpolate});

    /**
     * @private
     * @type {boolean}
     */
    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = gutter;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.sourceTileGrid_ = sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.targetTileGrid_ = targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

    /**
     * @private
     * @type {!Array<import("../ImageTile.js").default>}
     */
    this.sourceTiles_ = [];

    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    this.sourceZ_ = 0;

    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();

    const limitedTargetExtent = maxTargetExtent
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(targetExtent, maxTargetExtent)
      : targetExtent;

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }

    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );

    const sourceResolution = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_3__.calculateSourceExtentResolution)(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    const errorThresholdInPixels =
      errorThreshold !== undefined ? errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_4__.ERROR_THRESHOLD;

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );

    if (this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getArea)(sourceExtent)) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    } else {
      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent,
        this.sourceZ_
      );

      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            this.sourceTiles_.push(tile);
          }
        }
      }

      if (this.sourceTiles_.length === 0) {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      }
    }
  }

  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }

  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((tile) => {
      if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage(),
        });
      }
    });
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === 'number' ? size : size[0];
      const height = typeof size === 'number' ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );

      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );

      this.canvas_ = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_3__.render)(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );

      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    }
    this.changed();
  }

  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();

      let leftToLoad = 0;

      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach((tile) => {
        const state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
          leftToLoad++;

          const sourceListenKey = (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.listen)(
            tile,
            _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE,
            function (e) {
              const state = tile.getState();
              if (
                state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED ||
                state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ||
                state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY
              ) {
                (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.unlistenByKey)(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            },
            this
          );
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });

      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function (tile, i, arr) {
          const state = tile.getState();
          if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
            tile.load();
          }
        });
      }
    }
  }

  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_7__.unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }

  /**
   * Remove from the cache due to expiry
   */
  release() {
    if (this.canvas_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_9__.releaseCanvas)(this.canvas_.getContext('2d'));
      _reproj_js__WEBPACK_IMPORTED_MODULE_3__.canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReprojTile);


/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/math.js");
/**
 * @module ol/reproj/Triangulation
 */




/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
const MAX_SUBDIVISION = 10;

/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
const MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
class Triangulation {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(
    sourceProj,
    targetProj,
    targetExtent,
    maxSourceExtent,
    errorThreshold,
    destinationResolution
  ) {
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.sourceProj_ = sourceProj;

    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.targetProj_ = targetProj;

    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
    let transformInvCache = {};
    const transformInv = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(this.targetProj_, this.sourceProj_);

    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */
    this.transformInv_ = function (c) {
      const key = c[0] + '/' + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };

    /**
     * @type {import("../extent.js").Extent}
     * @private
     */
    this.maxSourceExtent_ = maxSourceExtent;

    /**
     * @type {number}
     * @private
     */
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;

    /**
     * @type {Array<Triangle>}
     * @private
     */
    this.triangles_ = [];

    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */
    this.wrapsXInSource_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.canWrapXInSource_ =
      this.sourceProj_.canWrapX() &&
      !!maxSourceExtent &&
      !!this.sourceProj_.getExtent() &&
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(maxSourceExtent) >= (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.sourceProj_.getExtent());

    /**
     * @type {?number}
     * @private
     */
    this.sourceWorldWidth_ = this.sourceProj_.getExtent()
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.sourceProj_.getExtent())
      : null;

    /**
     * @type {?number}
     * @private
     */
    this.targetWorldWidth_ = this.targetProj_.getExtent()
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.targetProj_.getExtent())
      : null;

    const destinationTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopLeft)(targetExtent);
    const destinationTopRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopRight)(targetExtent);
    const destinationBottomRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getBottomRight)(targetExtent);
    const destinationBottomLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getBottomLeft)(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);

    /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overall reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */
    const maxSubdivision =
      MAX_SUBDIVISION +
      (destinationResolution
        ? Math.max(
            0,
            Math.ceil(
              Math.log2(
                (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getArea)(targetExtent) /
                  (destinationResolution * destinationResolution * 256 * 256)
              )
            )
          )
        : 0);

    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );

    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function (triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });

      // Shift triangles to be as close to `leftBound` as possible
      // (if the distance is more than `worldWidth / 2` it can be closer.
      this.triangles_.forEach((triangle) => {
        if (
          Math.max(
            triangle.source[0][0],
            triangle.source[1][0],
            triangle.source[2][0]
          ) -
            leftBound >
          this.sourceWorldWidth_ / 2
        ) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]],
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }

          // Rarely (if the extent contains both the dateline and prime meridian)
          // the shift can in turn break some triangles.
          // Detect this here and don't shift in such cases.
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }

    transformInvCache = {};
  }

  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c],
    });
  }

  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_
      : null;
    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);

    // when the quad is wrapped in the source projection
    // it covers most of the projection extent, but not fully
    const wrapsX =
      this.sourceProj_.canWrapX() &&
      sourceCoverageX > 0.5 &&
      sourceCoverageX < 1;

    let needsSubdivision = false;

    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.boundingExtent)([a, b, c, d]);
        const targetCoverageX =
          (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision =
          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision =
          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }

    if (!needsSubdivision && this.maxSourceExtent_) {
      if (
        isFinite(sourceQuadExtent[0]) &&
        isFinite(sourceQuadExtent[1]) &&
        isFinite(sourceQuadExtent[2]) &&
        isFinite(sourceQuadExtent[3])
      ) {
        if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
          // whole quad outside source projection extent -> ignore
          return;
        }
      }
    }

    let isNotFinite = 0;

    if (!needsSubdivision) {
      if (
        !isFinite(aSrc[0]) ||
        !isFinite(aSrc[1]) ||
        !isFinite(bSrc[0]) ||
        !isFinite(bSrc[1]) ||
        !isFinite(cSrc[0]) ||
        !isFinite(cSrc[1]) ||
        !isFinite(dSrc[0]) ||
        !isFinite(dSrc[1])
      ) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          // It might be the case that only 1 of the points is infinite. In this case
          // we can draw a single triangle with the other three points
          isNotFinite =
            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +
            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +
            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +
            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (
            isNotFinite != 1 &&
            isNotFinite != 2 &&
            isNotFinite != 4 &&
            isNotFinite != 8
          ) {
            return;
          }
        }
      }
    }

    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);

        let dx;
        if (wrapsX) {
          const centerSrcEstimX =
            ((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(aSrc[0], sourceWorldWidth) +
              (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(cSrc[0], sourceWorldWidth)) /
            2;
          dx = centerSrcEstimX - (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          // split horizontally (top & bottom)
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);

          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          // split vertically (left & right)
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);

          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }

    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }

    // Exactly zero or one of *Src is not finite
    // The triangles must have the diagonal line as the first side
    // This is to allow easy code in reproj.s to make it straight for broken
    // browsers that can't handle diagonal clipping
    if ((isNotFinite & 0xb) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 0xe) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      // Try the other two triangles
      if ((isNotFinite & 0xd) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 0x7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }

  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();

    this.triangles_.forEach(function (triangle, i, arr) {
      const src = triangle.source;
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[0]);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[1]);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[2]);
    });

    return extent;
  }

  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Triangulation);


/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ERROR_THRESHOLD: () => (/* binding */ ERROR_THRESHOLD)
/* harmony export */ });
/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
const ERROR_THRESHOLD = 0.5;


/***/ }),

/***/ "./node_modules/ol/source/OSM.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ATTRIBUTION: () => (/* binding */ ATTRIBUTION),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/OSM
 */



/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
const ATTRIBUTION =
  '&#169; ' +
  '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' +
  'contributors.';

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
class OSM extends _XYZ_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(options) {
    options = options || {};

    let attributions;
    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    const crossOrigin =
      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';

    const url =
      options.url !== undefined
        ? options.url
        : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';

    super({
      attributions: attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      opaque: options.opaque !== undefined ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      wrapX: options.wrapX,
      zDirection: options.zDirection,
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OSM);


/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/Object.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/**
 * @module ol/source/Source
 */



/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */

/**
 * A function that takes a {@link import("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../View.js").ViewStateLayerStateExtent): (string|Array<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
class Source extends _Object_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} options Source options.
   */
  constructor(options) {
    super();

    /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */
    this.projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.projection);

    /**
     * @private
     * @type {?Attribution}
     */
    this.attributions_ = adaptAttributions(options.attributions);

    /**
     * @private
     * @type {boolean}
     */
    this.attributionsCollapsible_ =
      options.attributionsCollapsible !== undefined
        ? options.attributionsCollapsible
        : true;

    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */
    this.loading = false;

    /**
     * @private
     * @type {import("./Source.js").State}
     */
    this.state_ = options.state !== undefined ? options.state : 'ready';

    /**
     * @private
     * @type {boolean}
     */
    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

    /**
     * @private
     * @type {boolean}
     */
    this.interpolate_ = !!options.interpolate;

    /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */
    this.viewResolver = null;

    /**
     * @protected
     * @type {function(Error):void}
     */
    this.viewRejector = null;

    const self = this;
    /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */
    this.viewPromise_ = new Promise(function (resolve, reject) {
      self.viewResolver = resolve;
      self.viewRejector = reject;
    });
  }

  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }

  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }

  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }

  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    return null;
  }

  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }

  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }

  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }

  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }

  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }

  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  }

  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(state) {
    this.state_ = state;
    this.changed();
  }
}

/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function (frameState) {
    return [attributionLike];
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Source);


/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TileSourceEvent: () => (/* binding */ TileSourceEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/events/Event.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/source/Source.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/TileState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/asserts.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/tilegrid.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/size.js");
/**
 * @module ol/source/Tile
 */











/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
class TileSource extends _Source_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate,
    });

    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {TileSourceOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {boolean}
     */
    this.opaque_ = options.opaque !== undefined ? options.opaque : false;

    /**
     * @private
     * @type {number}
     */
    this.tilePixelRatio_ =
      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;

    /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     */
    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

    const tileSize = [256, 256];
    if (this.tileGrid) {
      (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.toSize)(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }

    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */
    this.tileCache = new _TileCache_js__WEBPACK_IMPORTED_MODULE_3__["default"](options.cacheSize || 0);

    /**
     * @protected
     * @type {import("../size.js").Size}
     */
    this.tmpSize = [0, 0];

    /**
     * @private
     * @type {string}
     */
    this.key_ = options.key || '';

    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate,
    };

    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(projection, z, tileRange, callback) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }

    let covered = true;
    let tile, tileCoordKey, loaded;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_4__.getKeyZXY)(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = /** @type {!import("../Tile.js").default} */ (
            tileCache.get(tileCoordKey)
          );
          loaded = tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOADED;
          if (loaded) {
            loaded = callback(tile) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }

  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    return this.opaque_;
  }

  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    const tileGrid = projection
      ? this.getTileGridForProjection(projection)
      : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }

  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.abstract)();
  }

  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__.getForProjection)(projection);
    }
    return this.tileGrid;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(projection) {
    const sourceProjection = this.getProjection();
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(
      sourceProjection === null || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(sourceProjection, projection),
      68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
    );
    return this.tileCache;
  }

  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }

  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.toSize)(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.scale)(tileSize, tilePixelRatio, this.tmpSize);
  }

  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== undefined ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__.wrapX)(tileGrid, tileCoord, projection);
    }
    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_4__.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
  }

  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }

  refresh() {
    this.clear();
    super.refresh();
  }

  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(tileCount, projection) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  }

  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(z, x, y, projection) {}
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
class TileSourceEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_9__["default"] {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile) {
    super(type);

    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */
    this.tile = tile;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileSource);


/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror',
});

/**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */


/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/ImageTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/TileState.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/source/UrlTile.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/tilegrid.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/source/TileImage
 */











/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
class TileImage extends _UrlTile_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction
        ? options.tileLoadFunction
        : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate:
        options.interpolate !== undefined ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @protected
     * @type {?string}
     */
    this.crossOrigin =
      options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @protected
     * @type {typeof ImageTile}
     */
    this.tileClass =
      options.tileClass !== undefined ? options.tileClass : _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];

    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */
    this.tileCacheForProjection = {};

    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    this.tileGridForProjection = {};

    /**
     * @private
     * @type {number|undefined}
     */
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

    /**
     * @private
     * @type {boolean}
     */
    this.renderReprojectionEdges_ = false;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache()) {
      return true;
    }
    for (const key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }

    return false;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const usedTileCache = this.getTileCacheForProjection(projection);

    this.tileCache.expireCache(
      this.tileCache == usedTileCache ? usedTiles : {}
    );
    for (const id in this.tileCacheForProjection) {
      const tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    if (
      this.getProjection() &&
      projection &&
      !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.getProjection(), projection)
    ) {
      return 0;
    }
    return this.getGutter();
  }

  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ':disable-interpolation';
    }
    return key;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    if (
      this.getProjection() &&
      projection &&
      !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.getProjection(), projection)
    ) {
      return false;
    }
    return super.getOpaque(projection);
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] =
        (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_4__.getForProjection)(projection);
    }
    return this.tileGridForProjection[projKey];
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(thisProj, projection)) {
      return this.tileCache;
    }
    const projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(projection);
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new _TileCache_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        this.tileCache.highWaterMark
      );
    }
    return this.tileCacheForProjection[projKey];
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord
      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)
      : undefined;
    const tile = new this.tileClass(
      tileCoord,
      tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].EMPTY,
      tileUrl !== undefined ? tileUrl : '',
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile.key = key;
    tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleTileChange.bind(this));
    return tile;
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (
      !sourceProjection ||
      !projection ||
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(sourceProjection, projection)
    ) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const cache = this.getTileCacheForProjection(projection);
    const tileCoord = [z, x, y];
    let tile;
    const tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_8__.getKey)(tileCoord);
    if (cache.containsKey(tileCoordKey)) {
      tile = cache.get(tileCoordKey);
    }
    const key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    }
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const newTile = new _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_9__["default"](
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z, x, y, pixelRatio) =>
        this.getTileInternal(z, x, y, pixelRatio, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.getInterpolate()
    );
    newTile.key = key;

    if (tile) {
      newTile.interimTile = tile;
      newTile.refreshInterimChain();
      cache.replace(tileCoordKey, newTile);
    } else {
      cache.set(tileCoordKey, newTile);
    }
    return newTile;
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    let tile = null;
    const tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_8__.getKeyZXY)(z, x, y);
    const key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);
      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        const interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);

        //make the new tile the head of the list,
        if (interimTile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }
        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }
    return tile;
  }

  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render) {
    if (this.renderReprojectionEdges_ == render) {
      return;
    }
    this.renderReprojectionEdges_ = render;
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  }

  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
    if (proj) {
      const projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }

  clear() {
    super.clear();
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
  }
}

/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =
    src;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileImage);


/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/source/TileEventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/source/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/tilecoord.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/source/UrlTile
 */







/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Cache size.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
class UrlTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @private
     * @type {boolean}
     */
    this.generateTileUrlFunction_ =
      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;

    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */
    this.tileLoadFunction = options.tileLoadFunction;

    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }

    /**
     * @protected
     * @type {!Array<string>|null}
     */
    this.urls = null;

    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }

    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    this.tileLoadingKeys_ = {};
  }

  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }

  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction
      ? this.tileUrlFunction.bind(this)
      : this.tileUrlFunction;
  }

  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }

  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = /** @type {import("../Tile.js").default} */ (event.target);
    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(tile);
    const tileState = tile.getState();
    let type;
    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type =
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR
          ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADERROR
          : tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED
          ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADEND
          : undefined;
    }
    if (type != undefined) {
      this.dispatchEvent(new _Tile_js__WEBPACK_IMPORTED_MODULE_0__.TileSourceEvent(type, tile));
    }
  }

  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }

  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  }

  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__.expandUrl)(url);
    this.urls = urls;
    this.setUrls(urls);
  }

  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join('\n');
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction((0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__.createFromTemplates)(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return undefined;
  }

  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(z, x, y) {
    const tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__.getKeyZXY)(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UrlTile);


/***/ }),

/***/ "./node_modules/ol/source/Vector.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VectorSourceEvent: () => (/* binding */ VectorSourceEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/structs/RBush.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/source/Source.js");
/* harmony import */ var _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/functions.js");
/* harmony import */ var _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/loadingstrategy.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./node_modules/ol/obj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/ol/events.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/featureloader.js");
/**
 * @module ol/source/Vector
 */



















/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */
class VectorSourceEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
   */
  constructor(type, feature, features) {
    super(type);

    /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {import("../Feature.js").default<Geometry>|undefined}
     * @api
     */
    this.feature = feature;

    /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
     * @api
     */
    this.features = features;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default<Geometry>>|Collection<import("../Feature.js").default<Geometry>>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import Vector from 'ol/source/Vector.js';
 * import GeoJSON from 'ol/format/GeoJSON.js';
 * import {bbox} from 'ol/loadingstrategy.js';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */

/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */
class VectorSource extends _Source_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options<Geometry>} [options] Vector source options.
   */
  constructor(options) {
    options = options || {};

    super({
      attributions: options.attributions,
      interpolate: true,
      projection: undefined,
      state: 'ready',
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
    });

    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {VectorSourceOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */
    this.loader_ = _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID;

    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */
    this.format_ = options.format;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;

    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */
    this.url_ = options.url;

    if (options.loader !== undefined) {
      this.loader_ = options.loader;
    } else if (this.url_ !== undefined) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"
      this.loader_ = (0,_featureloader_js__WEBPACK_IMPORTED_MODULE_4__.xhr)(
        this.url_,
        /** @type {import("../format/Feature.js").default} */ (this.format_)
      );
    }

    /**
     * @private
     * @type {LoadingStrategy}
     */
    this.strategy_ =
      options.strategy !== undefined ? options.strategy : _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_5__.all;

    const useSpatialIndex =
      options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

    /**
     * @private
     * @type {RBush<import("../Feature.js").default<Geometry>>}
     */
    this.featuresRtree_ = useSpatialIndex ? new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__["default"]() : null;

    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */
    this.loadedExtentsRtree_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__["default"]();

    /**
     * @type {number}
     * @private
     */
    this.loadingExtentsCount_ = 0;

    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */
    this.nullGeometryFeatures_ = {};

    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */
    this.idIndex_ = {};

    /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */
    this.uidIndex_ = {};

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.featureChangeKeys_ = {};

    /**
     * @private
     * @type {Collection<import("../Feature.js").default<Geometry>>|null}
     */
    this.featuresCollection_ = null;

    /** @type {Collection<import("../Feature.js").default<Geometry>>} */
    let collection;
    /** @type {Array<import("../Feature.js").default<Geometry>>} */
    let features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection_js__WEBPACK_IMPORTED_MODULE_7__["default"](features);
    }
    if (features !== undefined) {
      this.addFeaturesInternal(features);
    }
    if (collection !== undefined) {
      this.bindFeaturesCollection_(collection);
    }
  }

  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */
  addFeature(feature) {
    this.addFeatureInternal(feature);
    this.changed();
  }

  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */
  addFeatureInternal(feature) {
    const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);

    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }
      return;
    }

    this.setupChangeEvents_(featureKey, feature);

    const geometry = feature.getGeometry();
    if (geometry) {
      const extent = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }

    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE, feature)
    );
  }

  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */
  setupChangeEvents_(featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [
      (0,_events_js__WEBPACK_IMPORTED_MODULE_10__.listen)(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].CHANGE, this.handleFeatureChange_, this),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_10__.listen)(
        feature,
        _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_12__["default"].PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      ),
    ];
  }

  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(featureKey, feature) {
    let valid = true;
    const id = feature.getId();
    if (id !== undefined) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    }
    if (valid) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source
      this.uidIndex_[featureKey] = feature;
    }
    return valid;
  }

  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */
  addFeatures(features) {
    this.addFeaturesInternal(features);
    this.changed();
  }

  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */
  addFeaturesInternal(features) {
    const extents = [];
    const newFeatures = [];
    const geometryFeatures = [];

    for (let i = 0, length = features.length; i < length; i++) {
      const feature = features[i];
      const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }

    for (let i = 0, length = newFeatures.length; i < length; i++) {
      const feature = newFeatures[i];
      const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
      this.setupChangeEvents_(featureKey, feature);

      const geometry = feature.getGeometry();
      if (geometry) {
        const extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }

    if (this.hasListener(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE)) {
      for (let i = 0, length = newFeatures.length; i < length; i++) {
        this.dispatchEvent(
          new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE, newFeatures[i])
        );
      }
    }
  }

  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(collection) {
    let modifyingCollection = false;
    this.addEventListener(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      }
    );
    this.addEventListener(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      }
    );
    collection.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (evt) => {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.addFeature(evt.element);
          modifyingCollection = false;
        }
      }
    );
    collection.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (evt) => {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.removeFeature(evt.element);
          modifyingCollection = false;
        }
      }
    );
    this.featuresCollection_ = collection;
  }

  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(fast) {
    if (fast) {
      for (const featureId in this.featureChangeKeys_) {
        const keys = this.featureChangeKeys_[featureId];
        keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_10__.unlistenByKey);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        const removeAndIgnoreReturn = (feature) => {
          this.removeFeatureInternal(feature);
        };
        this.featuresRtree_.forEach(removeAndIgnoreReturn);
        for (const id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.nullGeometryFeatures_ = {};

    const clearEvent = new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  }

  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }

  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(coordinate, callback) {
    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function (feature) {
      const geometry = feature.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      }
      return undefined;
    });
  }

  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }

  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(extent, callback) {
    return this.forEachFeatureInExtent(
      extent,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function (feature) {
        const geometry = feature.getGeometry();
        if (geometry.intersectsExtent(extent)) {
          const result = callback(feature);
          if (result) {
            return result;
          }
        }
      }
    );
  }

  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }

  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeatures() {
    let features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray().slice(0);
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!(0,_obj_js__WEBPACK_IMPORTED_MODULE_14__.isEmpty)(this.nullGeometryFeatures_)) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_15__.extend)(features, Object.values(this.nullGeometryFeatures_));
      }
    }
    return /** @type {Array<import("../Feature.js").default<Geometry>>} */ (
      features
    );
  }

  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesAtCoordinate(coordinate) {
    const features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
      features.push(feature);
    });
    return features;
  }

  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesInExtent(extent, projection) {
    if (this.featuresRtree_) {
      const multiWorld = projection && projection.canWrapX() && this.getWrapX();

      if (!multiWorld) {
        return this.featuresRtree_.getInExtent(extent);
      }

      const extents = (0,_extent_js__WEBPACK_IMPORTED_MODULE_16__.wrapAndSliceX)(extent, projection);

      return [].concat(
        ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
      );
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getArray().slice(0);
    }
    return [];
  }

  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(coordinate, filter) {
    // Find the closest feature using branch and bound.  We start searching an
    // infinite extent, and find the distance from the first feature found.  This
    // becomes the closest feature.  We then compute a smaller extent which any
    // closer feature must intersect.  We continue searching with this smaller
    // extent, trying to find a closer feature.  Every time we find a closer
    // feature, we update the extent being searched so that any even closer
    // feature must intersect it.  We continue until we run out of features.
    const x = coordinate[0];
    const y = coordinate[1];
    let closestFeature = null;
    const closestPoint = [NaN, NaN];
    let minSquaredDistance = Infinity;
    const extent = [-Infinity, -Infinity, Infinity, Infinity];
    filter = filter ? filter : _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE;
    this.featuresRtree_.forEachInExtent(
      extent,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       */
      function (feature) {
        if (filter(feature)) {
          const geometry = feature.getGeometry();
          const previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry.closestPointXY(
            x,
            y,
            closestPoint,
            minSquaredDistance
          );
          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature;
            // This is sneaky.  Reduce the extent that it is currently being
            // searched while the R-Tree traversal using this same extent object
            // is still in progress.  This is safe because the new extent is
            // strictly contained by the old extent.
            const minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      }
    );
    return closestFeature;
  }

  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(extent) {
    return this.featuresRtree_.getExtent(extent);
  }

  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(id) {
    const feature = this.idIndex_[id.toString()];
    return feature !== undefined ? feature : null;
  }

  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   */
  getFeatureByUid(uid) {
    const feature = this.uidIndex_[uid];
    return feature !== undefined ? feature : null;
  }

  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }

  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }

  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }

  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(event) {
    const feature = /** @type {import("../Feature.js").default<Geometry>} */ (
      event.target
    );
    const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
    const geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      const extent = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }
    const id = feature.getId();
    if (id !== undefined) {
      const sid = id.toString();
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }
    this.changed();
    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGEFEATURE, feature)
    );
  }

  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(feature) {
    const id = feature.getId();
    if (id !== undefined) {
      return id in this.idIndex_;
    }
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature) in this.uidIndex_;
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    if (this.featuresRtree_) {
      return (
        this.featuresRtree_.isEmpty() && (0,_obj_js__WEBPACK_IMPORTED_MODULE_14__.isEmpty)(this.nullGeometryFeatures_)
      );
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getLength() === 0;
    }
    return true;
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(extent, resolution, projection) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    const extentsToLoad = this.strategy_(extent, resolution, projection);
    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {
      const extentToLoad = extentsToLoad[i];
      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
        extentToLoad,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function (object) {
          return (0,_extent_js__WEBPACK_IMPORTED_MODULE_16__.containsExtent)(object.extent, extentToLoad);
        }
      );
      if (!alreadyLoaded) {
        ++this.loadingExtentsCount_;
        this.dispatchEvent(
          new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADSTART)
        );
        this.loader_.call(
          this,
          extentToLoad,
          resolution,
          projection,
          (features) => {
            --this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(
                _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADEND,
                undefined,
                features
              )
            );
          },
          () => {
            --this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADERROR)
            );
          }
        );
        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});
      }
    }
    this.loading =
      this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
  }

  refresh() {
    this.clear(true);
    this.loadedExtentsRtree_.clear();
    super.refresh();
  }

  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(extent) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    let obj;
    loadedExtentsRtree.forEachInExtent(extent, function (object) {
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_16__.equals)(object.extent, extent)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  }

  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */
  removeFeature(feature) {
    if (!feature) {
      return;
    }
    const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    const result = this.removeFeatureInternal(feature);
    if (result) {
      this.changed();
    }
  }

  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(feature) {
    const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
    const featureChangeKeys = this.featureChangeKeys_[featureKey];
    if (!featureChangeKeys) {
      return;
    }
    featureChangeKeys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_10__.unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    const id = feature.getId();
    if (id !== undefined) {
      delete this.idIndex_[id.toString()];
    }
    delete this.uidIndex_[featureKey];
    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE, feature)
    );
    return feature;
  }

  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(feature) {
    let removed = false;
    for (const id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  }

  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(loader) {
    this.loader_ = loader;
  }

  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(url) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.format_, 7); // `format` must be set when `url` is set
    this.url_ = url;
    this.setLoader((0,_featureloader_js__WEBPACK_IMPORTED_MODULE_4__.xhr)(url, this.format_));
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VectorSource);


/***/ }),

/***/ "./node_modules/ol/source/VectorEventType.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature',

  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: 'featuresloadstart',

  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: 'featuresloadend',

  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: 'featuresloaderror',
});

/**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */


/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/XYZ
 */




/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 * This allows artifacts of rendering at tile edges to be ignored.
 * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if `url` or `urls` are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */
class XYZ extends _TileImage_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(options) {
    options = options || {};

    const projection =
      options.projection !== undefined ? options.projection : 'EPSG:3857';

    const tileGrid =
      options.tileGrid !== undefined
        ? options.tileGrid
        : (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__.createXYZ)({
            extent: (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__.extentFromProjection)(projection),
            maxResolution: options.maxResolution,
            maxZoom: options.maxZoom,
            minZoom: options.minZoom,
            tileSize: options.tileSize,
          });

    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
  }

  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (XYZ);


/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/asserts.js");
/**
 * @module ol/structs/LRUCache
 */



/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Object} newer Newer.
 * @property {Object} older Older.
 * @property {*} value_ Value.
 */

/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */
class LRUCache {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */
    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;

    /**
     * @private
     * @type {number}
     */
    this.count_ = 0;

    /**
     * @private
     * @type {!Object<string, Entry>}
     */
    this.entries_ = {};

    /**
     * @private
     * @type {?Entry}
     */
    this.oldest_ = null;

    /**
     * @private
     * @type {?Entry}
     */
    this.newest_ = null;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }

  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  }

  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }

  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }

  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }

  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }

  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */ (entry.older);
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (entry.newer);
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }

  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }

  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }

  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }

  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }

  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }

  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }

  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T} Value.
   */
  peek(key) {
    if (!this.containsKey(key)) {
      return undefined;
    }
    return this.entries_[key].value_;
  }

  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */ (entry.newer);
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }

  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key); // update `newest_`
    this.entries_[key].value_ = value;
  }

  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value,
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }

  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LRUCache);


/***/ }),

/***/ "./node_modules/ol/structs/RBush.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/rbush/rbush.min.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/obj.js");
/**
 * @module ol/structs/RBush
 */





/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
class RBush {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(maxEntries) {
    /**
     * @private
     */
    this.rbush_ = new rbush__WEBPACK_IMPORTED_MODULE_0__(maxEntries);

    /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */
    this.items_ = {};
  }

  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(extent, value) {
    /** @type {Entry} */
    const item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value,
    };

    this.rbush_.insert(item);
    this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)] = item;
  }

  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(extents, values) {
    const items = new Array(values.length);
    for (let i = 0, l = values.length; i < l; i++) {
      const extent = extents[i];
      const value = values[i];

      /** @type {Entry} */
      const item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value: value,
      };
      items[i] = item;
      this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)] = item;
    }
    this.rbush_.load(items);
  }

  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(value) {
    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value);

    // get the object in which the value was wrapped when adding to the
    // internal rbush. then use that object to do the removal.
    const item = this.items_[uid];
    delete this.items_[uid];
    return this.rbush_.remove(item) !== null;
  }

  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(extent, value) {
    const item = this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)];
    const bbox = [item.minX, item.minY, item.maxX, item.maxY];
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.equals)(bbox, extent)) {
      this.remove(value);
      this.insert(extent, value);
    }
  }

  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    const items = this.rbush_.all();
    return items.map(function (item) {
      return item.value;
    });
  }

  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(extent) {
    /** @type {Entry} */
    const bbox = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
    };
    const items = this.rbush_.search(bbox);
    return items.map(function (item) {
      return item.value;
    });
  }

  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(callback) {
    return this.forEach_(this.getAll(), callback);
  }

  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(extent, callback) {
    return this.forEach_(this.getInExtent(extent), callback);
  }

  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(values, callback) {
    let result;
    for (let i = 0, l = values.length; i < l; i++) {
      result = callback(values[i]);
      if (result) {
        return result;
      }
    }
    return result;
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(this.items_);
  }

  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear();
    this.items_ = {};
  }

  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(extent) {
    const data = this.rbush_.toJSON();
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, extent);
  }

  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(rbush) {
    this.rbush_.load(rbush.rbush_.all());
    for (const i in rbush.items_) {
      this.items_[i] = rbush.items_[i];
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RBush);


/***/ }),

/***/ "./node_modules/ol/style/Circle.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/style/RegularShape.js");
/**
 * @module ol/style/Circle
 */



/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode
 */

/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
class CircleStyle extends _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {radius: 5};

    super({
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== undefined ? options.scale : 1,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      rotateWithView:
        options.rotateWithView !== undefined ? options.rotateWithView : false,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode,
    });
  }

  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    const style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
    style.setOpacity(this.getOpacity());
    return style;
  }

  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(radius) {
    this.radius_ = radius;
    this.render();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleStyle);


/***/ }),

/***/ "./node_modules/ol/style/Fill.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/style/Fill
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */

/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
class Fill {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
     */
    this.color_ = options.color !== undefined ? options.color : null;
  }

  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || undefined,
    });
  }

  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */
  setColor(color) {
    this.color_ = color;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Fill);


/***/ }),

/***/ "./node_modules/ol/style/Icon.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/style/Image.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/color.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/asserts.js");
/* harmony import */ var _IconImage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/style/IconImage.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/style/Icon
 */








/**
 * @typedef {'fraction' | 'pixels'} IconAnchorUnits
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */

/**
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */

/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not.
 * The provided `imgSize` needs to match the actual size of the image.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.
 * Positive values will shift the icon right and up.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number} [width] The width of the icon in pixels. This can't be used together with `scale`.
 * @property {number} [height] The height of the icon in pixels. This can't be used together with `scale`.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the
 * sub-rectangle to use from the original (sprite) image.
 * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("../size.js").Size} [size] Icon size in pixels. Used together with `offset` to define the
 * sub-rectangle to use from the original (sprite) image.
 * @property {string} [src] Image source URI.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */

/**
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {number|undefined} wantedWidth The wanted width.
 * @param {number|undefined} wantedHeight The wanted height.
 * @return {number|Array<number>} The scale.
 */
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== undefined && wantedHeight !== undefined) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== undefined) {
    return wantedWidth / width;
  }
  if (wantedHeight !== undefined) {
    return wantedHeight / height;
  }
  return 1;
}

/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
class Icon extends _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @type {number}
     */
    const opacity = options.opacity !== undefined ? options.opacity : 1;

    /**
     * @type {number}
     */
    const rotation = options.rotation !== undefined ? options.rotation : 0;

    /**
     * @type {number|import("../size.js").Size}
     */
    const scale = options.scale !== undefined ? options.scale : 1;

    /**
     * @type {boolean}
     */
    const rotateWithView =
      options.rotateWithView !== undefined ? options.rotateWithView : false;

    super({
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      rotateWithView: rotateWithView,
      declutterMode: options.declutterMode,
    });

    /**
     * @private
     * @type {Array<number>}
     */
    this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];

    /**
     * @private
     * @type {Array<number>}
     */
    this.normalizedAnchor_ = null;

    /**
     * @private
     * @type {IconOrigin}
     */
    this.anchorOrigin_ =
      options.anchorOrigin !== undefined ? options.anchorOrigin : 'top-left';

    /**
     * @private
     * @type {IconAnchorUnits}
     */
    this.anchorXUnits_ =
      options.anchorXUnits !== undefined ? options.anchorXUnits : 'fraction';

    /**
     * @private
     * @type {IconAnchorUnits}
     */
    this.anchorYUnits_ =
      options.anchorYUnits !== undefined ? options.anchorYUnits : 'fraction';

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ =
      options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    const image = options.img !== undefined ? options.img : null;

    /**
     * @private
     * @type {import("../size.js").Size|undefined}
     */
    this.imgSize_ = options.imgSize;

    /**
     * @type {string|undefined}
     */
    let src = options.src;

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!image || (image && this.imgSize_), 5); // `imgSize` must be set when `image` is provided

    if ((src === undefined || src.length === 0) && image) {
      src = /** @type {HTMLImageElement} */ (image).src || (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getUid)(image);
    }
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

    // `width` or `height` cannot be provided together with `scale`
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(
        (options.width !== undefined || options.height !== undefined) &&
        options.scale !== undefined
      ),
      69
    );

    /**
     * @type {import("../ImageState.js").default}
     */
    const imageState =
      options.src !== undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED;

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    this.color_ = options.color !== undefined ? (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(options.color) : null;

    /**
     * @private
     * @type {import("./IconImage.js").default}
     */
    this.iconImage_ = (0,_IconImage_js__WEBPACK_IMPORTED_MODULE_5__.get)(
      image,
      /** @type {string} */ (src),
      this.imgSize_ !== undefined ? this.imgSize_ : null,
      this.crossOrigin_,
      imageState,
      this.color_
    );

    /**
     * @private
     * @type {Array<number>}
     */
    this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
    /**
     * @private
     * @type {IconOrigin}
     */
    this.offsetOrigin_ =
      options.offsetOrigin !== undefined ? options.offsetOrigin : 'top-left';

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = options.size !== undefined ? options.size : null;

    /**
     * Calculate the scale if width or height were given.
     */
    if (options.width !== undefined || options.height !== undefined) {
      let width, height;
      if (options.size) {
        [width, height] = options.size;
      } else {
        const image = this.getImage(1);
        if (
          image instanceof HTMLCanvasElement ||
          (image.src && image.complete)
        ) {
          width = image.width;
          height = image.height;
        } else {
          this.initialOptions_ = options;
          const onload = () => {
            this.unlistenImageChange(onload);
            if (!this.initialOptions_) {
              return;
            }
            const imageSize = this.iconImage_.getSize();
            this.setScale(
              calculateScale(
                imageSize[0],
                imageSize[1],
                options.width,
                options.height
              )
            );
          };
          this.listenImageChange(onload);
          return;
        }
      }
      if (width !== undefined) {
        this.setScale(
          calculateScale(width, height, options.width, options.height)
        );
      }
    }
  }

  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let scale, width, height;
    if (this.initialOptions_) {
      width = this.initialOptions_.width;
      height = this.initialOptions_.height;
    } else {
      scale = this.getScale();
      scale = Array.isArray(scale) ? scale.slice() : scale;
    }
    const clone = new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color:
        this.color_ && this.color_.slice
          ? this.color_.slice()
          : this.color_ || undefined,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale,
      width,
      height,
      size: this.size_ !== null ? this.size_.slice() : undefined,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
    return clone;
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (
        this.anchorXUnits_ == 'fraction' ||
        this.anchorYUnits_ == 'fraction'
      ) {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == 'fraction') {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == 'fraction') {
          anchor[1] *= size[1];
        }
      }

      if (this.anchorOrigin_ != 'top-left') {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (
          this.anchorOrigin_ == 'top-right' ||
          this.anchorOrigin_ == 'bottom-right'
        ) {
          anchor[0] = -anchor[0] + size[0];
        }
        if (
          this.anchorOrigin_ == 'bottom-left' ||
          this.anchorOrigin_ == 'bottom-right'
        ) {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale = this.getScaleArray();
    // anchor is scaled by renderer but displacement should not be scaled
    // so divide by scale here
    return [
      anchor[0] - displacement[0] / scale[0],
      anchor[1] + displacement[1] / scale[1],
    ];
  }

  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }

  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }

  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }

  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }

  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }

  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset = this.offset_;

    if (this.offsetOrigin_ != 'top-left') {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset = offset.slice();
      if (
        this.offsetOrigin_ == 'top-right' ||
        this.offsetOrigin_ == 'bottom-right'
      ) {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }
      if (
        this.offsetOrigin_ == 'bottom-left' ||
        this.offsetOrigin_ == 'bottom-right'
      ) {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }
    this.origin_ = offset;
    return this.origin_;
  }

  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }

  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }

  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const scale = this.getScaleArray();
    if (this.size_) {
      return this.size_[0] * scale[0];
    }
    if (this.iconImage_.getImageState() == _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
      return this.iconImage_.getSize()[0] * scale[0];
    }
    return undefined;
  }

  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const scale = this.getScaleArray();
    if (this.size_) {
      return this.size_[1] * scale[1];
    }
    if (this.iconImage_.getImageState() == _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
      return this.iconImage_.getSize()[1] * scale[1];
    }
    return undefined;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(scale) {
    delete this.initialOptions_;
    super.setScale(scale);
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {
    this.iconImage_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, listener);
  }

  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {
    this.iconImage_.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, listener);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Icon);


/***/ }),

/***/ "./node_modules/ol/style/IconImage.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/ImageState.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/color.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/dom.js");
/* harmony import */ var _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/style/IconImageCache.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/Image.js");
/**
 * @module ol/style/IconImage
 */









/**
 * @type {CanvasRenderingContext2D}
 */
let taintedTestContext = null;

class IconImage extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */
  constructor(image, src, size, crossOrigin, imageState, color) {
    super();

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = image;

    /**
     * @private
     * @type {string|null}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */
    this.canvas_ = {};

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    this.color_ = color;

    /**
     * @private
     * @type {?function():void}
     */
    this.unlisten_ = null;

    /**
     * @private
     * @type {import("../ImageState.js").default}
     */
    this.imageState_ = imageState;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = size;

    /**
     * @private
     * @type {string|undefined}
     */
    this.src_ = src;

    /**
     * @private
     */
    this.tainted_;
  }

  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }

  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === undefined && this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(1, 1, undefined, {
          willReadFrequently: true,
        });
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }

  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
  }

  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  }

  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    } else {
      this.size_ = [this.image_.width, this.image_.height];
    }
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }

  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }

  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }

  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }

  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ !== _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }

    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
    try {
      /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
    } catch (e) {
      this.handleImageError_();
    }
    this.unlisten_ = (0,_Image_js__WEBPACK_IMPORTED_MODULE_4__.listenImage)(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    );
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(pixelRatio) {
    if (
      !this.color_ ||
      this.canvas_[pixelRatio] ||
      this.imageState_ !== _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED
    ) {
      return;
    }

    const image = this.image_;
    const canvas = document.createElement('canvas');
    canvas.width = Math.ceil(image.width * pixelRatio);
    canvas.height = Math.ceil(image.height * pixelRatio);

    const ctx = canvas.getContext('2d');
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image, 0, 0);

    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = (0,_color_js__WEBPACK_IMPORTED_MODULE_5__.asString)(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);

    ctx.globalCompositeOperation = 'destination-in';
    ctx.drawImage(image, 0, 0);

    this.canvas_[pixelRatio] = canvas;
  }

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
}

/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */
function get(image, src, size, crossOrigin, imageState, color) {
  let iconImage = _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.get(src, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
    _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.set(src, crossOrigin, color, iconImage);
  }
  return iconImage;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconImage);


/***/ }),

/***/ "./node_modules/ol/style/Image.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/size.js");
/**
 * @module ol/style/Image
 */



/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {"declutter"|"obstacle"|"none"|undefined} declutterMode Declutter mode: `declutter`, `obstacle`, 'none */

/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
class ImageStyle {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    /**
     * @private
     * @type {number}
     */
    this.opacity_ = options.opacity;

    /**
     * @private
     * @type {boolean}
     */
    this.rotateWithView_ = options.rotateWithView;

    /**
     * @private
     * @type {number}
     */
    this.rotation_ = options.rotation;

    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    this.scale_ = options.scale;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.scale);

    /**
     * @private
     * @type {Array<number>}
     */
    this.displacement_ = options.displacement;

    /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */
    this.declutterMode_ = options.declutterMode;
  }

  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
  }

  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }

  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }

  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }

  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }

  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }

  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }

  /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getImage(pixelRatio) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getHitDetectionImage() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(pixelRatio) {
    return 1;
  }

  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }

  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(opacity) {
    this.opacity_ = opacity;
  }

  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }

  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(scale);
  }

  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageStyle);


/***/ }),

/***/ "./node_modules/ol/style/RegularShape.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/style/Image.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/color.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/dom.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/render/canvas.js");
/**
 * @module ol/style/RegularShape
 */








/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */

/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
class RegularShape extends _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    /**
     * @type {boolean}
     */
    const rotateWithView =
      options.rotateWithView !== undefined ? options.rotateWithView : false;

    super({
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: options.scale !== undefined ? options.scale : 1,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode,
    });

    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */
    this.canvas_ = undefined;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.hitDetectionCanvas_ = null;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.points_ = options.points;

    /**
     * @protected
     * @type {number}
     */
    this.radius_ =
      options.radius !== undefined ? options.radius : options.radius1;

    /**
     * @private
     * @type {number|undefined}
     */
    this.radius2_ = options.radius2;

    /**
     * @private
     * @type {number}
     */
    this.angle_ = options.angle !== undefined ? options.angle : 0;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = null;

    /**
     * @private
     * @type {RenderOptions}
     */
    this.renderOptions_ = null;

    this.render();
  }

  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    const style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
    style.setOpacity(this.getOpacity());
    return style;
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const size = this.size_;
    if (!size) {
      return null;
    }
    const displacement = this.getDisplacement();
    const scale = this.getScaleArray();
    // anchor is scaled by renderer but displacement should not be scaled
    // so divide by scale here
    return [
      size[0] / 2 - displacement[0] / scale[0],
      size[1] / 2 + displacement[1] / scale[1],
    ];
  }

  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }

  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
    this.render();
  }

  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    if (!this.hitDetectionCanvas_) {
      this.createHitDetectionCanvas_(this.renderOptions_);
    }
    return this.hitDetectionCanvas_;
  }

  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(pixelRatio) {
    let image = this.canvas_[pixelRatio];
    if (!image) {
      const renderOptions = this.renderOptions_;
      const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
        renderOptions.size * pixelRatio,
        renderOptions.size * pixelRatio
      );
      this.draw_(renderOptions, context, pixelRatio);

      image = context.canvas;
      this.canvas_[pixelRatio] = image;
    }
    return image;
  }

  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(pixelRatio) {
    return pixelRatio;
  }

  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  }

  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }

  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }

  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }

  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }

  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }

  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
    this.render();
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {}

  /**
   * Load not yet loaded URI.
   */
  load() {}

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {}

  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
    if (
      strokeWidth === 0 ||
      this.points_ === Infinity ||
      (lineJoin !== 'bevel' && lineJoin !== 'miter')
    ) {
      return strokeWidth;
    }
    // m  | ^
    // i  | |\                  .
    // t >|  #\
    // e  | |\ \              .
    // r      \s\
    //      |  \t\          .                 .
    //          \r\                      .   .
    //      |    \o\      .          .  . . .
    //          e \k\            .  .    . .
    //      |      \e\  .    .  .       . .
    //       d      \ \  .  .          . .
    //      | _ _a_ _\#  .            . .
    //   r1          / `             . .
    //      |                       . .
    //       b     /               . .
    //      |                     . .
    //           / r2            . .
    //      |                        .   .
    //         /                           .   .
    //      |α                                   .   .
    //       /                                         .   .
    //      ° center
    let r1 = this.radius_;
    let r2 = this.radius2_ === undefined ? r1 : this.radius2_;
    if (r1 < r2) {
      const tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    const points =
      this.radius2_ === undefined ? this.points_ : this.points_ * 2;
    const alpha = (2 * Math.PI) / points;
    const a = r2 * Math.sin(alpha);
    const b = Math.sqrt(r2 * r2 - a * a);
    const d = r1 - b;
    const e = Math.sqrt(a * a + d * d);
    const miterRatio = e / a;
    if (lineJoin === 'miter' && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    // Calculate the distance from center to the stroke corner where
    // it was cut short because of the miter limit.
    //              l
    //        ----+---- <= distance from center to here is maxr
    //       /####|k ##\
    //      /#####^#####\
    //     /#### /+\# s #\
    //    /### h/+++\# t #\
    //   /### t/+++++\# r #\
    //  /### a/+++++++\# o #\
    // /### p/++ fill +\# k #\
    ///#### /+++++^+++++\# e #\
    //#####/+++++/+\+++++\#####\
    const k = strokeWidth / 2 / miterRatio;
    const l = (strokeWidth / 2) * (d / e);
    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
    const bevelAdd = maxr - r1;
    if (this.radius2_ === undefined || lineJoin === 'bevel') {
      return bevelAdd * 2;
    }
    // If outer miter is over the miter limit the inner miter may reach through the
    // center and be longer than the bevel, same calculation as above but swap r1 / r2.
    const aa = r1 * Math.sin(alpha);
    const bb = Math.sqrt(r1 * r1 - aa * aa);
    const dd = r2 - bb;
    const ee = Math.sqrt(aa * aa + dd * dd);
    const innerMiterRatio = ee / aa;
    if (innerMiterRatio <= miterLimit) {
      const innerLength = (innerMiterRatio * strokeWidth) / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  }

  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultLineJoin;
    let miterLimit = 0;
    let lineDash = null;
    let lineDashOffset = 0;
    let strokeStyle;
    let strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultStrokeStyle;
      }
      strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_4__.asColorLike)(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === undefined) {
        strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultLineWidth;
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === undefined) {
        lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultLineJoin;
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === undefined) {
        miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultMiterLimit;
      }
    }

    const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
    const size = Math.ceil(2 * maxRadius + add);

    return {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit,
    };
  }

  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const size = this.renderOptions_.size;
    this.canvas_ = {};
    this.size_ = [size, size];
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio);
    // set origin to canvas center
    context.translate(renderOptions.size / 2, renderOptions.size / 2);

    this.createPath_(context);

    if (this.fill_) {
      let color = this.fill_.getColor();
      if (color === null) {
        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultFillStyle;
      }
      context.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_4__.asColorLike)(color);
      context.fill();
    }
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  createHitDetectionCanvas_(renderOptions) {
    if (this.fill_) {
      let color = this.fill_.getColor();

      // determine if fill is transparent (or pattern or gradient)
      let opacity = 0;
      if (typeof color === 'string') {
        color = (0,_color_js__WEBPACK_IMPORTED_MODULE_5__.asArray)(color);
      }
      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }
      if (opacity === 0) {
        // if a transparent fill style is set, create an extra hit-detection image
        // with a default fill style
        const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
          renderOptions.size,
          renderOptions.size
        );
        this.hitDetectionCanvas_ = context.canvas;

        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.getImage(1);
    }
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(context) {
    let points = this.points_;
    const radius = this.radius_;
    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      const radius2 = this.radius2_ === undefined ? radius : this.radius2_;
      if (this.radius2_ !== undefined) {
        points *= 2;
      }
      const startAngle = this.angle_ - Math.PI / 2;
      const step = (2 * Math.PI) / points;
      for (let i = 0; i < points; i++) {
        const angle0 = startAngle + i * step;
        const radiusC = i % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context.closePath();
    }
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(renderOptions, context) {
    // set origin to canvas center
    context.translate(renderOptions.size / 2, renderOptions.size / 2);

    this.createPath_(context);

    context.fillStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultFillStyle;
    context.fill();
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RegularShape);


/***/ }),

/***/ "./node_modules/ol/style/Stroke.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/style/Stroke
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
class Stroke {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */
    this.color_ = options.color !== undefined ? options.color : null;

    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */
    this.lineCap_ = options.lineCap;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lineDashOffset_ = options.lineDashOffset;

    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */
    this.lineJoin_ = options.lineJoin;

    /**
     * @private
     * @type {number|undefined}
     */
    this.miterLimit_ = options.miterLimit;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = options.width;
  }

  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || undefined,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth(),
    });
  }

  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }

  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }

  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }

  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }

  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }

  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }

  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(color) {
    this.color_ = color;
  }

  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }

  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }

  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }

  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }

  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }

  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(width) {
    this.width_ = width;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stroke);


/***/ }),

/***/ "./node_modules/ol/style/Style.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDefaultStyle: () => (/* binding */ createDefaultStyle),
/* harmony export */   createEditingStyle: () => (/* binding */ createEditingStyle),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   toFunction: () => (/* binding */ toFunction)
/* harmony export */ });
/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/style/Circle.js");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/asserts.js");
/**
 * @module ol/style/Style
 */






/**
 * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */

/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void} RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */
class Style {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
     */
    this.geometry_ = null;

    /**
     * @private
     * @type {!GeometryFunction}
     */
    this.geometryFunction_ = defaultGeometryFunction;

    if (options.geometry !== undefined) {
      this.setGeometry(options.geometry);
    }

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {import("./Image.js").default}
     */
    this.image_ = options.image !== undefined ? options.image : null;

    /**
     * @private
     * @type {RenderFunction|null}
     */
    this.renderer_ = options.renderer !== undefined ? options.renderer : null;

    /**
     * @private
     * @type {RenderFunction|null}
     */
    this.hitDetectionRenderer_ =
      options.hitDetectionRenderer !== undefined
        ? options.hitDetectionRenderer
        : null;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {import("./Text.js").default}
     */
    this.text_ = options.text !== undefined ? options.text : null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.zIndex_ = options.zIndex;
  }

  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === 'object') {
      geometry = /** @type {import("../geom/Geometry.js").default} */ (
        geometry
      ).clone();
    }
    return new Style({
      geometry: geometry,
      fill: this.getFill() ? this.getFill().clone() : undefined,
      image: this.getImage() ? this.getImage().clone() : undefined,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      text: this.getText() ? this.getText().clone() : undefined,
      zIndex: this.getZIndex(),
    });
  }

  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }

  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }

  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }

  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }

  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }

  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }

  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }

  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }

  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(image) {
    this.image_ = image;
  }

  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }

  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }

  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }

  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }

  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(geometry) {
    if (typeof geometry === 'function') {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === 'string') {
      this.geometryFunction_ = function (feature) {
        return /** @type {import("../geom/Geometry.js").default} */ (
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== undefined) {
      this.geometryFunction_ = function () {
        return /** @type {import("../geom/Geometry.js").default} */ (geometry);
      };
    }
    this.geometry_ = geometry;
  }

  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(zIndex) {
    this.zIndex_ = zIndex;
  }
}

/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */
function toFunction(obj) {
  let styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof (/** @type {?} */ (obj).getZIndex) === 'function', 41); // Expected an `Style` or an array of `Style`
      const style = /** @type {Style} */ (obj);
      styles = [style];
    }
    styleFunction = function () {
      return styles;
    };
  }
  return styleFunction;
}

/**
 * @type {Array<Style>|null}
 */
let defaultStyles = null;

/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    const fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      color: 'rgba(255,255,255,0.4)',
    });
    const stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      color: '#3399CC',
      width: 1.25,
    });
    defaultStyles = [
      new Style({
        image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
          fill: fill,
          stroke: stroke,
          radius: 5,
        }),
        fill: fill,
        stroke: stroke,
      }),
    ];
  }
  return defaultStyles;
}

/**
 * Default styles for editing features.
 * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles
 */
function createEditingStyle() {
  /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */
  const styles = {};
  const white = [255, 255, 255, 1];
  const blue = [0, 153, 255, 1];
  const width = 3;
  styles['Polygon'] = [
    new Style({
      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        color: [255, 255, 255, 0.5],
      }),
    }),
  ];
  styles['MultiPolygon'] = styles['Polygon'];

  styles['LineString'] = [
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        color: white,
        width: width + 2,
      }),
    }),
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        color: blue,
        width: width,
      }),
    }),
  ];
  styles['MultiLineString'] = styles['LineString'];

  styles['Circle'] = styles['Polygon'].concat(styles['LineString']);

  styles['Point'] = [
    new Style({
      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        radius: width * 2,
        fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
          color: blue,
        }),
        stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          color: white,
          width: width / 2,
        }),
      }),
      zIndex: Infinity,
    }),
  ];
  styles['MultiPoint'] = styles['Point'];

  styles['GeometryCollection'] = styles['Polygon'].concat(
    styles['LineString'],
    styles['Point']
  );

  return styles;
}

/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Style);


/***/ }),

/***/ "./node_modules/ol/style/Text.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/size.js");
/**
 * @module ol/style/Text
 */



/**
 * @typedef {'point' | 'line'} TextPlacement
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 */

/**
 * @typedef {'left' | 'center' | 'right'} TextJustify
 */

/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */
const DEFAULT_FILL_COLOR = '#333';

/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number} [repeat] Repeat interval. When set, the text will be repeated at this interval, which specifies
 * the distance between two text anchors in pixels. Only available when `placement` is set to `'line'`. Overrides 'textAlign'.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */

/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */
class Text {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {string|undefined}
     */
    this.font_ = options.font;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = options.rotation;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = options.rotateWithView;

    /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */
    this.scale_ = options.scale;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.scale !== undefined ? options.scale : 1);

    /**
     * @private
     * @type {string|Array<string>|undefined}
     */
    this.text_ = options.text;

    /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */
    this.textAlign_ = options.textAlign;

    /**
     * @private
     * @type {TextJustify|undefined}
     */
    this.justify_ = options.justify;

    /**
     * @private
     * @type {number|undefined}
     */
    this.repeat_ = options.repeat;

    /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */
    this.textBaseline_ = options.textBaseline;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ =
      options.fill !== undefined
        ? options.fill
        : new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({color: DEFAULT_FILL_COLOR});

    /**
     * @private
     * @type {number}
     */
    this.maxAngle_ =
      options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;

    /**
     * @private
     * @type {TextPlacement}
     */
    this.placement_ =
      options.placement !== undefined ? options.placement : 'point';

    /**
     * @private
     * @type {boolean}
     */
    this.overflow_ = !!options.overflow;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {number}
     */
    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;

    /**
     * @private
     * @type {number}
     */
    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.backgroundFill_ = options.backgroundFill
      ? options.backgroundFill
      : null;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.backgroundStroke_ = options.backgroundStroke
      ? options.backgroundStroke
      : null;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.padding_ = options.padding === undefined ? null : options.padding;
  }

  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill()
        ? this.getBackgroundFill().clone()
        : undefined,
      backgroundStroke: this.getBackgroundStroke()
        ? this.getBackgroundStroke().clone()
        : undefined,
      padding: this.getPadding() || undefined,
    });
  }

  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }

  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }

  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }

  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }

  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }

  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }

  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }

  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }

  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }

  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }

  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }

  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }

  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }

  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }

  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }

  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }

  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }

  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }

  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(overflow) {
    this.overflow_ = overflow;
  }

  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(font) {
    this.font_ = font;
  }

  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }

  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }

  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }

  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(placement) {
    this.placement_ = placement;
  }

  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(repeat) {
    this.repeat_ = repeat;
  }

  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }

  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }

  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(scale !== undefined ? scale : 1);
  }

  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }

  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }

  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(textAlign) {
    this.textAlign_ = textAlign;
  }

  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(justify) {
    this.justify_ = justify;
  }

  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }

  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }

  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }

  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(padding) {
    this.padding_ = padding;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Text);


/***/ }),

/***/ "./node_modules/ol/style/flat.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toStyle: () => (/* binding */ toStyle)
/* harmony export */ });
/* harmony import */ var _style_Circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/style/Circle.js");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/style/Fill.js");
/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/style/Icon.js");
/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/style/RegularShape.js");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/style/Stroke.js");
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/style/Style.js");
/* harmony import */ var _Text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/style/Text.js");
/**
 * @module ol/style/flat
 */









/**
 * For static styling, the [layer.setStyle()]{@link module:ol/layer/Vector~VectorLayer#setStyle} method
 * can be called with an object literal that has fill, stroke, text, icon, regular shape, and/or circle properties.
 * @api
 *
 * @typedef {FlatFill & FlatStroke & FlatText & FlatIcon & FlatShape & FlatCircle} FlatStyle
 */

/**
 * A flat style literal or an array of the same.
 *
 * @typedef {FlatStyle|Array<FlatStyle>} FlatStyleLike
 */

/**
 * Fill style properties applied to polygon features.
 *
 * @typedef {Object} FlatFill
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [fill-color] The fill color.
 */

/**
 * Stroke style properties applied to line strings and polygon boundaries.  To apply a stroke, at least one of
 * `stroke-color` or `stroke-width` must be provided.
 *
 * @typedef {Object} FlatStroke
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [stroke-color] The stroke color.
 * @property {number} [stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [stroke-line-dash] Line dash pattern.
 * @property {number} [stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [stroke-miter-limit=10] Miter limit.
 */

/**
 * Label style properties applied to all features.  At a minimum, a `text-value` must be provided.
 *
 * @typedef {Object} FlatText
 * @property {string|Array<string>} [text-value] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for the immediate rendering API.
 * @property {string} [text-font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [text-max-angle=Math.PI/4] When `text-placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [text-offset-x=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [text-offset-y=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [text-overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {import("./Text.js").TextPlacement} [text-placement='point'] Text placement.
 * @property {number} [text-repeat] Repeat interval in pixels. When set, the text will be repeated at this interval. Only available when
 * `text-placement` is set to `'line'`. Overrides `text-align`.
 * @property {number|import("../size.js").Size} [text-scale] Scale.
 * @property {boolean} [text-rotate-with-view=false] Whether to rotate the text with the view.
 * @property {number} [text-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {CanvasTextAlign} [text-align] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `text-placement: 'point'`. For `text-placement: 'line'`, the default is to let the renderer choose a
 * placement where `text-max-angle` is not exceeded.
 * @property {import('./Text.js').TextJustify} [text-justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `text-justify` is ignored for immediate rendering and also for `text-placement: 'line'`.
 * @property {CanvasTextBaseline} [text-baseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {Array<number>} [text-padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-background-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-stroke-color] The stroke color.
 * @property {CanvasLineCap} [text-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [text-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [text-stroke-line-dash] Line dash pattern.
 * @property {number} [text-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [text-stroke-miter-limit=10] Miter limit.
 * @property {number} [text-stroke-width] Stroke pixel width.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-background-stroke-color] The stroke color.
 * @property {CanvasLineCap} [text-background-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [text-background-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [text-background-stroke-line-dash] Line dash pattern.
 * @property {number} [text-background-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [text-background-stroke-miter-limit=10] Miter limit.
 * @property {number} [text-background-stroke-width] Stroke pixel width.
 */

/**
 * Icon style properties applied to point features.  One of `icon-src` or `icon-img` must be provided to render
 * points with an icon.
 *
 * @typedef {Object} FlatIcon
 * @property {string} [icon-src] Image source URI.
 * @property {HTMLImageElement|HTMLCanvasElement} [icon-img] Image object for the icon. If the `icon-src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `icon-img-size` option.
 * @property {import("../size.js").Size} [icon-img-size] Image size in pixels. Only required if `icon-img` is set and `icon-src` is not.
 * The provided size needs to match the actual size of the image.
 * @property {Array<number>} [icon-anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./Icon.js").IconOrigin} [icon-anchor-origin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-x-units='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-y-units='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [icon-color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [icon-cross-origin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {Array<number>} [icon-offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {Array<number>} [icon-displacement=[0,0]] Displacement of the icon.
 * @property {import("./Icon.js").IconOrigin} [icon-offset-origin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {number} [icon-opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [icon-scale=1] Scale.
 * @property {number} [icon-width] Width of the icon. If not specified, the actual image width will be used. Cannot be combined
 * with `scale`.
 * @property {number} [icon-height] Height of the icon. If not specified, the actual image height will be used. Cannot be combined
 * with `scale`.
 * @property {number} [icon-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [icon-rotate-with-view=false] Whether to rotate the icon with the view.
 * @property {import("../size.js").Size} [icon-size] Icon size in pixel. Can be used together with `icon-offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {"declutter"|"obstacle"|"none"|undefined} [icon-declutter-mode] Declutter mode
 */

/**
 * Regular shape style properties for rendering point features.  At least `shape-points` must be provided.
 *
 * @typedef {Object} FlatShape
 * @property {number} [shape-points] Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [shape-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [shape-stroke-color] The stroke color.
 * @property {number} [shape-stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [shape-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [shape-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [shape-stroke-line-dash] Line dash pattern.
 * @property {number} [shape-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [shape-stroke-miter-limit=10] Miter limit.
 * @property {number} [shape-radius] Radius of a regular polygon.
 * @property {number} [shape-radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [shape-radius2] Second radius of a star.
 * @property {number} [shape-angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {Array<number>} [shape-displacement=[0,0]] Displacement of the shape
 * @property {number} [shape-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [shape-rotate-with-view=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [shape-scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `shape-radius`, `shape-radius1` and `shape-radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [shape-declutter-mode] Declutter mode.
 */

/**
 * Circle style properties for rendering point features.  At least `circle-radius` must be provided.
 *
 * @typedef {Object} FlatCircle
 * @property {number} [circle-radius] Circle radius.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [circle-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [circle-stroke-color] The stroke color.
 * @property {number} [circle-stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [circle-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [circle-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [circle-stroke-line-dash] Line dash pattern.
 * @property {number} [circle-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [circle-stroke-miter-limit=10] Miter limit.
 * @property {Array<number>} [circle-displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [circle-scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.
 * @property {number} [circle-rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [circle-rotate-with-view=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [circle-declutter-mode] Declutter mode
 */

/**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @return {import("./Style.js").default} A style instance.
 */
function toStyle(flatStyle) {
  const style = new _Style_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    fill: getFill(flatStyle, ''),
    stroke: getStroke(flatStyle, ''),
    text: getText(flatStyle),
    image: getImage(flatStyle),
  });

  return style;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @return {Fill|undefined} The fill (if any).
 */
function getFill(flatStyle, prefix) {
  const color = flatStyle[prefix + 'fill-color'];
  if (!color) {
    return;
  }

  return new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({color: color});
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @return {Stroke|undefined} The stroke (if any).
 */
function getStroke(flatStyle, prefix) {
  const width = flatStyle[prefix + 'stroke-width'];
  const color = flatStyle[prefix + 'stroke-color'];
  if (!width && !color) {
    return;
  }

  return new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
    width: width,
    color: color,
    lineCap: flatStyle[prefix + 'stroke-line-cap'],
    lineJoin: flatStyle[prefix + 'stroke-line-join'],
    lineDash: flatStyle[prefix + 'stroke-line-dash'],
    lineDashOffset: flatStyle[prefix + 'stroke-line-dash-offset'],
    miterLimit: flatStyle[prefix + 'stroke-miter-limit'],
  });
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @return {Text|undefined} The text (if any).
 */
function getText(flatStyle) {
  const value = flatStyle['text-value'];
  if (!value) {
    return;
  }

  const text = new _Text_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
    text: value,
    font: flatStyle['text-font'],
    maxAngle: flatStyle['text-max-angle'],
    offsetX: flatStyle['text-offset-x'],
    offsetY: flatStyle['text-offset-y'],
    overflow: flatStyle['text-overflow'],
    placement: flatStyle['text-placement'],
    repeat: flatStyle['text-repeat'],
    scale: flatStyle['text-scale'],
    rotateWithView: flatStyle['text-rotate-with-view'],
    rotation: flatStyle['text-rotation'],
    textAlign: flatStyle['text-align'],
    justify: flatStyle['text-justify'],
    textBaseline: flatStyle['text-baseline'],
    padding: flatStyle['text-padding'],
    fill: getFill(flatStyle, 'text-'),
    backgroundFill: getFill(flatStyle, 'text-background-'),
    stroke: getStroke(flatStyle, 'text-'),
    backgroundStroke: getStroke(flatStyle, 'text-background-'),
  });

  return text;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @return {import("./Image.js").default|undefined} The image (if any).
 */
function getImage(flatStyle) {
  const iconSrc = flatStyle['icon-src'];
  const iconImg = flatStyle['icon-img'];
  if (iconSrc || iconImg) {
    const icon = new _Icon_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      src: iconSrc,
      img: iconImg,
      imgSize: flatStyle['icon-img-size'],
      anchor: flatStyle['icon-anchor'],
      anchorOrigin: flatStyle['icon-anchor-origin'],
      anchorXUnits: flatStyle['icon-anchor-x-units'],
      anchorYUnits: flatStyle['icon-anchor-y-units'],
      color: flatStyle['icon-color'],
      crossOrigin: flatStyle['icon-cross-origin'],
      offset: flatStyle['icon-offset'],
      displacement: flatStyle['icon-displacement'],
      opacity: flatStyle['icon-opacity'],
      scale: flatStyle['icon-scale'],
      width: flatStyle['icon-width'],
      height: flatStyle['icon-height'],
      rotation: flatStyle['icon-rotation'],
      rotateWithView: flatStyle['icon-rotate-with-view'],
      size: flatStyle['icon-size'],
      declutterMode: flatStyle['icon-declutter-mode'],
    });
    return icon;
  }

  const shapePoints = flatStyle['shape-points'];
  if (shapePoints) {
    const prefix = 'shape-';
    const shape = new _RegularShape_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      points: shapePoints,
      fill: getFill(flatStyle, prefix),
      stroke: getStroke(flatStyle, prefix),
      radius: flatStyle['shape-radius'],
      radius1: flatStyle['shape-radius1'],
      radius2: flatStyle['shape-radius2'],
      angle: flatStyle['shape-angle'],
      displacement: flatStyle['shape-displacement'],
      rotation: flatStyle['shape-rotation'],
      rotateWithView: flatStyle['shape-rotate-with-view'],
      scale: flatStyle['shape-scale'],
      declutterMode: flatStyle['shape-declutter-mode'],
    });

    return shape;
  }

  const circleRadius = flatStyle['circle-radius'];
  if (circleRadius) {
    const prefix = 'circle-';
    const circle = new _style_Circle_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
      radius: circleRadius,
      fill: getFill(flatStyle, prefix),
      stroke: getStroke(flatStyle, prefix),
      displacement: flatStyle['circle-displacement'],
      scale: flatStyle['circle-scale'],
      rotation: flatStyle['circle-rotation'],
      rotateWithView: flatStyle['circle-rotate-with-view'],
      declutterMode: flatStyle['circle-declutter-mode'],
    });

    return circle;
  }

  return;
}


/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   fromKey: () => (/* binding */ fromKey),
/* harmony export */   getCacheKeyForTileKey: () => (/* binding */ getCacheKeyForTileKey),
/* harmony export */   getKey: () => (/* binding */ getKey),
/* harmony export */   getKeyZXY: () => (/* binding */ getKeyZXY),
/* harmony export */   hash: () => (/* binding */ hash),
/* harmony export */   withinExtentAndZ: () => (/* binding */ withinExtentAndZ)
/* harmony export */ });
/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, tileCoord) {
  if (tileCoord !== undefined) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}

/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}

/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */
function getCacheKeyForTileKey(tileKey) {
  const [z, x, y] = tileKey
    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)
    .split(',')
    .map(Number);
  return getKeyZXY(z, x, y);
}

/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}

/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}

/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}


/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createForExtent: () => (/* binding */ createForExtent),
/* harmony export */   createForProjection: () => (/* binding */ createForProjection),
/* harmony export */   createXYZ: () => (/* binding */ createXYZ),
/* harmony export */   extentFromProjection: () => (/* binding */ extentFromProjection),
/* harmony export */   getForProjection: () => (/* binding */ getForProjection),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/tilegrid/TileGrid.js");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/proj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/size.js");
/**
 * @module ol/tilegrid
 */






/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}

/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsCoordinate)(projectionExtent, center)) {
    const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== undefined ? corner : 'top-left';

  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);

  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
    extent: extent,
    origin: (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: tileSize,
  });
}

/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(options) {
  const xyzOptions = options || {};

  const extent = xyzOptions.extent || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:3857').getExtent();

  const gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    ),
  };
  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__["default"](gridOptions);
}

/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== undefined ? maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_MAX_ZOOM;
  tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_4__.toSize)(tileSize !== undefined ? tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE);

  const height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(extent);
  const width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(extent);

  maxResolution =
    maxResolution > 0
      ? maxResolution
      : Math.max(width / tileSize[0], height / tileSize[1]);

  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}

/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}

/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half =
      (180 * _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdate)(-half, -half, half, half);
  }
  return extent;
}


/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/TileRange.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/extent.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/tilecoord.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/array.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/size.js");
/**
 * @module ol/tilegrid/TileGrid
 */










/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
const tmpTileCoord = [0, 0, 0];

/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */
const DECIMALS = 5;

/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
class TileGrid {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    /**
     * @protected
     * @type {number}
     */
    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

    /**
     * @private
     * @type {!Array<number>}
     */
    this.resolutions_ = options.resolutions;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.isSorted)(
        this.resolutions_,
        function (a, b) {
          return b - a;
        },
        true
      ),
      17
    ); // `resolutions` must be sorted in descending order

    // check if we've got a consistent zoom factor and origin
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = undefined;
            break;
          }
        }
      }
    }

    /**
     * @private
     * @type {number|undefined}
     */
    this.zoomFactor_ = zoomFactor;

    /**
     * @protected
     * @type {number}
     */
    this.maxZoom = this.resolutions_.length - 1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    this.origin_ = options.origin !== undefined ? options.origin : null;

    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */
    this.origins_ = null;
    if (options.origins !== undefined) {
      this.origins_ = options.origins;
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
    }

    const extent = options.extent;

    if (extent !== undefined && !this.origin_ && !this.origins_) {
      this.origin_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(extent);
    }

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
      18
    ); // Either `origin` or `origins` must be configured, never both

    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */
    this.tileSizes_ = null;
    if (options.tileSizes !== undefined) {
      this.tileSizes_ = options.tileSizes;
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
    }

    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    this.tileSize_ =
      options.tileSize !== undefined
        ? options.tileSize
        : !this.tileSizes_
        ? _common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE
        : null;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (!this.tileSize_ && this.tileSizes_) ||
        (this.tileSize_ && !this.tileSizes_),
      22
    ); // Either `tileSize` or `tileSizes` must be configured, never both

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = extent !== undefined ? extent : null;

    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */
    this.fullTileRanges_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.tmpSize_ = [0, 0];

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.tmpExtent_ = [0, 0, 0, 0];

    if (options.sizes !== undefined) {
      this.fullTileRanges_ = options.sizes.map(function (size, z) {
        const tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_4__["default"](
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      }, this);
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }

  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(
    tileCoord,
    callback,
    tempTileRange,
    tempExtent
  ) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (this.zoomFactor_ === 2) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }

  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }

  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }

  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }

  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }

  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }

  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }

    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];

    if (z === tileCoordZ) {
      return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }

    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, minX, minY, minY, tempTileRange);
      }

      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
    }

    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }

  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,
    ];
  }

  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(minX, minY, maxX, maxY, tempExtent);
  }

  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }

  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(
    x,
    y,
    resolution,
    reverseIntersectionPolicy,
    opt_tileCoord
  ) {
    const z = this.getZForResolution(resolution);
    const scale = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);

    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];
    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordX, DECIMALS) - 1;
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordX, DECIMALS);
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordY, DECIMALS);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  }

  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);

    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordX, DECIMALS) - 1;
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordX, DECIMALS);
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordY, DECIMALS);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  }

  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }

  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }

  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_
        ? this.getTileRangeForExtentAndZ(this.extent_, z)
        : null;
    }
    return this.fullTileRanges_[z];
  }

  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.linearFindNearest)(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(z, this.minZoom, this.maxZoom);
  }

  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return (0,_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__.intersectsLinearRing)(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }

  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileGrid);


/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createFromTemplate: () => (/* binding */ createFromTemplate),
/* harmony export */   createFromTemplates: () => (/* binding */ createFromTemplates),
/* harmony export */   createFromTileUrlFunctions: () => (/* binding */ createFromTileUrlFunctions),
/* harmony export */   expandUrl: () => (/* binding */ expandUrl),
/* harmony export */   nullTileUrlFunction: () => (/* binding */ nullTileUrlFunction)
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/tilecoord.js");
/**
 * @module ol/tileurlfunction
 */




/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  const zRegEx = /\{z\}/g;
  const xRegEx = /\{x\}/g;
  const yRegEx = /\{y\}/g;
  const dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      }
      return template
        .replace(zRegEx, tileCoord[0].toString())
        .replace(xRegEx, tileCoord[1].toString())
        .replace(yRegEx, tileCoord[2].toString())
        .replace(dashYRegEx, function () {
          const z = tileCoord[0];
          const range = tileGrid.getFullTileRange(z);
          (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(range, 55); // The {-y} placeholder requires a tile grid with extent
          const y = range.getHeight() - tileCoord[2] - 1;
          return y.toString();
        });
    }
  );
}

/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}

/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      }
      const h = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.hash)(tileCoord);
      const index = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}

/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}

/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}


/***/ }),

/***/ "./node_modules/ol/vec/mat4.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   fromTransform: () => (/* binding */ fromTransform)
/* harmony export */ });
/**
 * @module ol/vec/mat4
 */

/**
 * @return {Array<number>} "4x4 matrix representing a 3D identity transform."
 */
function create() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

/**
 * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {import("../transform.js").Transform} transform Transformation matrix.
 * @return {Array<number>} "2D transformation matrix as flattened 4x4 matrix."
 */
function fromTransform(mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
}


/***/ }),

/***/ "./node_modules/ol/webgl.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARRAY_BUFFER: () => (/* binding */ ARRAY_BUFFER),
/* harmony export */   DYNAMIC_DRAW: () => (/* binding */ DYNAMIC_DRAW),
/* harmony export */   ELEMENT_ARRAY_BUFFER: () => (/* binding */ ELEMENT_ARRAY_BUFFER),
/* harmony export */   FLOAT: () => (/* binding */ FLOAT),
/* harmony export */   STATIC_DRAW: () => (/* binding */ STATIC_DRAW),
/* harmony export */   STREAM_DRAW: () => (/* binding */ STREAM_DRAW),
/* harmony export */   UNSIGNED_BYTE: () => (/* binding */ UNSIGNED_BYTE),
/* harmony export */   UNSIGNED_INT: () => (/* binding */ UNSIGNED_INT),
/* harmony export */   UNSIGNED_SHORT: () => (/* binding */ UNSIGNED_SHORT),
/* harmony export */   getContext: () => (/* binding */ getContext),
/* harmony export */   getSupportedExtensions: () => (/* binding */ getSupportedExtensions)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/has.js");
/**
 * @module ol/webgl
 */



/**
 * Constants taken from goog.webgl
 */

/**
 * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as
 * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer
 * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).
 * @const
 * @type {number}
 * @api
 */
const ARRAY_BUFFER = 0x8892;

/**
 * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.
 * Index buffers are essentially lists of references to vertices defined in a vertex buffer
 * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.
 * @const
 * @type {number}
 * @api
 */
const ELEMENT_ARRAY_BUFFER = 0x8893;

/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
const STREAM_DRAW = 0x88e0;

/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
const STATIC_DRAW = 0x88e4;

/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
const DYNAMIC_DRAW = 0x88e8;

/**
 * @const
 * @type {number}
 */
const UNSIGNED_BYTE = 0x1401;

/**
 * @const
 * @type {number}
 */
const UNSIGNED_SHORT = 0x1403;

/**
 * @const
 * @type {number}
 */
const UNSIGNED_INT = 0x1405;

/**
 * @const
 * @type {number}
 */
const FLOAT = 0x1406;

/** end of goog.webgl constants
 */

/**
 * @const
 * @type {Array<string>}
 */
const CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];

/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object} [attributes] Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */
function getContext(canvas, attributes) {
  attributes = Object.assign(
    {
      preserveDrawingBuffer: true,
      antialias: _has_js__WEBPACK_IMPORTED_MODULE_0__.SAFARI_BUG_237906 ? false : true, // https://bugs.webkit.org/show_bug.cgi?id=237906
    },
    attributes
  );
  const ii = CONTEXT_IDS.length;
  for (let i = 0; i < ii; ++i) {
    try {
      const context = canvas.getContext(CONTEXT_IDS[i], attributes);
      if (context) {
        return /** @type {!WebGLRenderingContext} */ (context);
      }
    } catch (e) {
      // pass
    }
  }
  return null;
}

/**
 * @type {Array<string>}
 */
let supportedExtensions;

/**
 * @return {Array<string>} List of supported WebGL extensions.
 */
function getSupportedExtensions() {
  if (!supportedExtensions) {
    const canvas = document.createElement('canvas');
    const gl = getContext(canvas);
    if (gl) {
      supportedExtensions = gl.getSupportedExtensions();
    }
  }
  return supportedExtensions;
}


/***/ }),

/***/ "./node_modules/ol/webgl/Buffer.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferUsage: () => (/* binding */ BufferUsage),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getArrayClassForType: () => (/* binding */ getArrayClassForType)
/* harmony export */ });
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/webgl.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/asserts.js");
/**
 * @module ol/webgl/Buffer
 */



/**
 * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`
 * or `DYNAMIC_DRAW`.
 * @enum {number}
 */
const BufferUsage = {
  STATIC_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.STATIC_DRAW,
  STREAM_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.STREAM_DRAW,
  DYNAMIC_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.DYNAMIC_DRAW,
};

/**
 * @classdesc
 * Object used to store an array of data as well as usage information for that data.
 * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on
 * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.
 *
 * To populate the array, you can either use:
 * * A size using `#ofSize(buffer)`
 * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`
 * * A plain array using `#fromArray(array)`
 *
 * Note:
 * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)
 * for more info on buffer usage.
 * @api
 */
class WebGLArrayBuffer {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */
  constructor(type, usage) {
    /**
     * @private
     * @type {Float32Array|Uint32Array}
     */
    this.array = null;

    /**
     * @private
     * @type {number}
     */
    this.type = type;

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(type === _webgl_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_BUFFER || type === _webgl_js__WEBPACK_IMPORTED_MODULE_0__.ELEMENT_ARRAY_BUFFER, 62);

    /**
     * @private
     * @type {number}
     */
    this.usage = usage !== undefined ? usage : BufferUsage.STATIC_DRAW;
  }

  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   * @return {WebGLArrayBuffer} This
   */
  ofSize(size) {
    this.array = new (getArrayClassForType(this.type))(size);
    return this;
  }

  /**
   * Populates the buffer with an array of the given size.
   * @param {Array<number>} array Numerical array
   * @return {WebGLArrayBuffer} This
   */
  fromArray(array) {
    this.array = getArrayClassForType(this.type).from(array);
    return this;
  }

  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   * @return {WebGLArrayBuffer} This
   */
  fromArrayBuffer(buffer) {
    this.array = new (getArrayClassForType(this.type))(buffer);
    return this;
  }

  /**
   * @return {number} Buffer type.
   */
  getType() {
    return this.type;
  }

  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array} Array.
   */
  getArray() {
    return this.array;
  }

  /**
   * @return {number} Usage.
   */
  getUsage() {
    return this.usage;
  }

  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */
  getSize() {
    return this.array ? this.array.length : 0;
  }
}

/**
 * Returns a typed array constructor based on the given buffer type
 * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
 * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.
 */
function getArrayClassForType(type) {
  switch (type) {
    case _webgl_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_BUFFER:
      return Float32Array;
    case _webgl_js__WEBPACK_IMPORTED_MODULE_0__.ELEMENT_ARRAY_BUFFER:
      return Uint32Array;
    default:
      return Float32Array;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLArrayBuffer);


/***/ }),

/***/ "./node_modules/ol/webgl/ContextEventType.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/webgl/ContextEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  LOST: 'webglcontextlost',
  RESTORED: 'webglcontextrestored',
});


/***/ }),

/***/ "./node_modules/ol/webgl/Helper.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeType: () => (/* binding */ AttributeType),
/* harmony export */   DefaultUniform: () => (/* binding */ DefaultUniform),
/* harmony export */   ShaderType: () => (/* binding */ ShaderType),
/* harmony export */   computeAttributesStride: () => (/* binding */ computeAttributesStride),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/ol/webgl/ContextEventType.js");
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/ol/Disposable.js");
/* harmony import */ var _PostProcessingPass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/ol/webgl/PostProcessingPass.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/webgl.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/ol/obj.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/ol/transform.js");
/* harmony import */ var _vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/ol/vec/mat4.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/webgl/Helper
 */









/**
 * @typedef {Object} BufferCacheEntry
 * @property {import("./Buffer.js").default} buffer Buffer.
 * @property {WebGLBuffer} webGlBuffer WebGlBuffer.
 */

/**
 * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.
 * @enum {number}
 */
const ShaderType = {
  FRAGMENT_SHADER: 0x8b30,
  VERTEX_SHADER: 0x8b31,
};

/**
 * Names of uniforms made available to all shaders.
 * Please note: changing these *will* break custom shaders!
 * @enum {string}
 */
const DefaultUniform = {
  PROJECTION_MATRIX: 'u_projectionMatrix',
  OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',
  OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',
  TIME: 'u_time',
  ZOOM: 'u_zoom',
  RESOLUTION: 'u_resolution',
  VIEWPORT_SIZE_PX: 'u_viewportSizePx',
  PIXEL_RATIO: 'u_pixelRatio',
};

/**
 * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`
 * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.
 * @enum {number}
 */
const AttributeType = {
  UNSIGNED_BYTE: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.UNSIGNED_BYTE,
  UNSIGNED_SHORT: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.UNSIGNED_SHORT,
  UNSIGNED_INT: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.UNSIGNED_INT,
  FLOAT: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT,
};

/**
 * Description of an attribute in a buffer
 * @typedef {Object} AttributeDescription
 * @property {string} name Attribute name to use in shaders
 * @property {number} size Number of components per attributes
 * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is
 * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).
 * Default is `FLOAT`.
 */

/**
 * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import("../transform").Transform} UniformLiteralValue
 */

/**
 * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning
 * one of the previous types.
 * @typedef {UniformLiteralValue|function(import("../Map.js").FrameState):UniformLiteralValue} UniformValue
 */

/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas which will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} Options
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform
 * names in the provided or default shaders.
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 * @property {string} [canvasCacheKey] The cache key for the canvas.
 */

/**
 * @typedef {Object} UniformInternalDescription
 * @property {string} name Name
 * @property {UniformValue} [value] Value
 * @property {UniformValue} [prevValue] The previous value.
 * @property {WebGLTexture} [texture] Texture
 * @private
 */

/**
 * @typedef {Object} CanvasCacheItem
 * @property {HTMLCanvasElement} canvas Canvas element.
 * @property {number} users The count of users of this canvas.
 */

/**
 * @type {Object<string,CanvasCacheItem>}
 */
const canvasCache = {};

/**
 * @param {string} key The cache key for the canvas.
 * @return {string} The shared cache key.
 */
function getSharedCanvasCacheKey(key) {
  return 'shared/' + key;
}

let uniqueCanvasCacheKeyCount = 0;

/**
 * @return {string} The unique cache key.
 */
function getUniqueCanvasCacheKey() {
  const key = 'unique/' + uniqueCanvasCacheKeyCount;
  uniqueCanvasCacheKeyCount += 1;
  return key;
}

/**
 * @param {string} key The cache key for the canvas.
 * @return {HTMLCanvasElement} The canvas.
 */
function getCanvas(key) {
  let cacheItem = canvasCache[key];
  if (!cacheItem) {
    const canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.left = '0';
    cacheItem = {users: 0, canvas};
    canvasCache[key] = cacheItem;
  }

  cacheItem.users += 1;
  return cacheItem.canvas;
}

/**
 * @param {string} key The cache key for the canvas.
 */
function releaseCanvas(key) {
  const cacheItem = canvasCache[key];
  if (!cacheItem) {
    return;
  }

  cacheItem.users -= 1;
  if (cacheItem.users > 0) {
    return;
  }

  const canvas = cacheItem.canvas;
  const gl = (0,_webgl_js__WEBPACK_IMPORTED_MODULE_0__.getContext)(canvas);
  const extension = gl.getExtension('WEBGL_lose_context');
  if (extension) {
    extension.loseContext();
  }

  delete canvasCache[key];
}

/**
 * @classdesc
 * This class is intended to provide low-level functions related to WebGL rendering, so that accessing
 * directly the WebGL API should not be required anymore.
 *
 * Several operations are handled by the `WebGLHelper` class:
 *
 * ### Define custom shaders and uniforms
 *
 *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:
 *
 *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).
 *   Outputs are:
 *
 *   * `gl_Position`: position of the vertex in screen space
 *
 *   * Varyings usually prefixed with `v_` are passed on to the fragment shader
 *
 *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.
 *
 *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that
 *   can be changed at every frame and can be of type float, arrays of float or images.
 *
 *   Shaders must be compiled and assembled into a program like so:
 *   ```js
 *   // here we simply create two shaders and assemble them in a program which is then used
 *   // for subsequent rendering calls; note how a frameState is required to set up a program,
 *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)
 *   const vertexShader = new WebGLVertex(VERTEX_SHADER);
 *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);
 *   const program = this.context.getProgram(fragmentShader, vertexShader);
 *   helper.useProgram(this.program, frameState);
 *   ```
 *
 *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.
 *   You can also change their value along the way like so:
 *   ```js
 *   helper.setUniformFloatValue('u_value', valueAsNumber);
 *   ```
 *
 * ### Defining post processing passes
 *
 *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas
 *   while applying special effects in screen space.
 *   Typical uses are: blurring, color manipulation, depth of field, filtering...
 *
 *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.
 *   A post process step accepts the following options:
 *
 *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.
 *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.
 *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.
 *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.
 *
 *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.
 *
 * ### Binding WebGL buffers and flushing data into them
 *
 *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.
 *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.
 *   This is done using {@link bindBuffer}.
 *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using
 *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.
 *
 *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}
 *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).
 *
 *   Examples below:
 *   ```js
 *   // at initialization phase
 *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *
 *   // when array values have changed
 *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *
 *   // at rendering phase
 *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *   ```
 *
 * ### Specifying attributes
 *
 *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).
 *   Attributes are used to specify these uses. Specify the attribute names with
 *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).
 *
 *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.
 *   ```js
 *   // here we indicate that the data array has the following structure:
 *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]
 *   helper.enableAttributes([
 *     {
 *        name: 'a_position',
 *        size: 2
 *     },
 *     {
 *       name: 'a_offset',
 *       size: 2
 *     },
 *     {
 *       name: 'a_texCoord',
 *       size: 2
 *     }
 *   ])
 *   ```
 *
 * ### Rendering primitives
 *
 *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.
 *   ```js
 *   // frame preparation step
 *   helper.prepareDraw(frameState);
 *
 *   // call this for every data array that has to be rendered on screen
 *   helper.drawElements(0, this.indicesBuffer.getArray().length);
 *
 *   // finalize the rendering by applying post processes
 *   helper.finalizeDraw(frameState);
 *   ```
 *
 * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 */
class WebGLHelper extends _Disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options || {};

    /** @private */
    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);

    /** @private */
    this.boundHandleWebGLContextRestored_ =
      this.handleWebGLContextRestored.bind(this);

    /**
     * @private
     * @type {string}
     */
    this.canvasCacheKey_ = options.canvasCacheKey
      ? getSharedCanvasCacheKey(options.canvasCacheKey)
      : getUniqueCanvasCacheKey();

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = getCanvas(this.canvasCacheKey_);

    /**
     * @private
     * @type {WebGLRenderingContext}
     */
    this.gl_ = (0,_webgl_js__WEBPACK_IMPORTED_MODULE_0__.getContext)(this.canvas_);

    /**
     * @private
     * @type {!Object<string, BufferCacheEntry>}
     */
    this.bufferCache_ = {};

    /**
     * @private
     * @type {Object<string, Object>}
     */
    this.extensionCache_ = {};

    /**
     * @private
     * @type {WebGLProgram}
     */
    this.currentProgram_ = null;

    this.canvas_.addEventListener(
      _webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOST,
      this.boundHandleWebGLContextLost_
    );
    this.canvas_.addEventListener(
      _webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESTORED,
      this.boundHandleWebGLContextRestored_
    );

    /**
     * @private
     * @type {import("../transform.js").Transform}
     */
    this.offsetRotateMatrix_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.create)();

    /**
     * @private
     * @type {import("../transform.js").Transform}
     */
    this.offsetScaleMatrix_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.create)();

    /**
     * @private
     * @type {Array<number>}
     */
    this.tmpMat4_ = (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__.create)();

    /**
     * @private
     * @type {Object<string, Object<string, WebGLUniformLocation>>}
     */
    this.uniformLocationsByProgram_ = {};

    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    this.attribLocationsByProgram_ = {};

    /**
     * Holds info about custom uniforms used in the post processing pass.
     * If the uniform is a texture, the WebGL Texture object will be stored here.
     * @type {Array<UniformInternalDescription>}
     * @private
     */
    this.uniforms_ = [];
    if (options.uniforms) {
      this.setUniforms(options.uniforms);
    }

    /**
     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the
     * options. If no post process was given, a default one is used (so as not to have to make an exception to
     * the frame buffer logic).
     * @type {Array<WebGLPostProcessingPass>}
     * @private
     */
    this.postProcessPasses_ = options.postProcesses
      ? options.postProcesses.map(
          (options) =>
            new _PostProcessingPass_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
              webGlContext: this.gl_,
              scaleRatio: options.scaleRatio,
              vertexShader: options.vertexShader,
              fragmentShader: options.fragmentShader,
              uniforms: options.uniforms,
            })
        )
      : [new _PostProcessingPass_js__WEBPACK_IMPORTED_MODULE_5__["default"]({webGlContext: this.gl_})];

    /**
     * @type {string|null}
     * @private
     */
    this.shaderCompileErrors_ = null;

    /**
     * @type {number}
     * @private
     */
    this.startTime_ = Date.now();
  }

  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  setUniforms(uniforms) {
    this.uniforms_ = [];
    for (const name in uniforms) {
      this.uniforms_.push({
        name: name,
        value: uniforms[name],
      });
    }
  }

  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(canvasCacheKey) {
    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
  }

  /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */
  getExtension(name) {
    if (name in this.extensionCache_) {
      return this.extensionCache_[name];
    }
    const extension = this.gl_.getExtension(name);
    this.extensionCache_[name] = extension;
    return extension;
  }

  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   */
  bindBuffer(buffer) {
    const gl = this.gl_;
    const bufferKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.getUid)(buffer);
    let bufferCache = this.bufferCache_[bufferKey];
    if (!bufferCache) {
      const webGlBuffer = gl.createBuffer();
      bufferCache = {
        buffer: buffer,
        webGlBuffer: webGlBuffer,
      };
      this.bufferCache_[bufferKey] = bufferCache;
    }
    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
  }

  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   */
  flushBufferData(buffer) {
    const gl = this.gl_;
    this.bindBuffer(buffer);
    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
  }

  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */
  deleteBuffer(buf) {
    const gl = this.gl_;
    const bufferKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.getUid)(buf);
    const bufferCacheEntry = this.bufferCache_[bufferKey];
    if (bufferCacheEntry && !gl.isContextLost()) {
      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
    }
    delete this.bufferCache_[bufferKey];
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    this.canvas_.removeEventListener(
      _webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOST,
      this.boundHandleWebGLContextLost_
    );
    this.canvas_.removeEventListener(
      _webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESTORED,
      this.boundHandleWebGLContextRestored_
    );

    releaseCanvas(this.canvasCacheKey_);

    delete this.gl_;
    delete this.canvas_;
  }

  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   */
  prepareDraw(frameState, disableAlphaBlend) {
    const gl = this.gl_;
    const canvas = this.getCanvas();
    const size = frameState.size;
    const pixelRatio = frameState.pixelRatio;

    if (
      canvas.width !== size[0] * pixelRatio ||
      canvas.height !== size[1] * pixelRatio
    ) {
      canvas.width = size[0] * pixelRatio;
      canvas.height = size[1] * pixelRatio;
      canvas.style.width = size[0] + 'px';
      canvas.style.height = size[1] + 'px';
    }

    // loop backwards in post processes list
    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {
      this.postProcessPasses_[i].init(frameState);
    }

    gl.bindTexture(gl.TEXTURE_2D, null);

    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
  }

  /**
   * Prepare a program to use a texture.
   * @param {WebGLTexture} texture The texture.
   * @param {number} slot The texture slot.
   * @param {string} uniformName The corresponding uniform name.
   */
  bindTexture(texture, slot, uniformName) {
    const gl = this.gl_;
    gl.activeTexture(gl.TEXTURE0 + slot);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(this.getUniformLocation(uniformName), slot);
  }

  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   */
  prepareDrawToRenderTarget(frameState, renderTarget, disableAlphaBlend) {
    const gl = this.gl_;
    const size = renderTarget.getSize();

    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
    gl.viewport(0, 0, size[0], size[1]);
    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
  }

  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   */
  drawElements(start, end) {
    const gl = this.gl_;
    this.getExtension('OES_element_index_uint');

    const elementType = gl.UNSIGNED_INT;
    const elementSize = 4;

    const numItems = end - start;
    const offsetInBytes = start * elementSize;
    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
  }

  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  finalizeDraw(frameState, preCompose, postCompose) {
    // apply post processes using the next one as target
    for (let i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {
      if (i === ii - 1) {
        this.postProcessPasses_[i].apply(
          frameState,
          null,
          preCompose,
          postCompose
        );
      } else {
        this.postProcessPasses_[i].apply(
          frameState,
          this.postProcessPasses_[i + 1]
        );
      }
    }
  }

  /**
   * @return {HTMLCanvasElement} Canvas.
   */
  getCanvas() {
    return this.canvas_;
  }

  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }

  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyFrameState(frameState) {
    const size = frameState.size;
    const rotation = frameState.viewState.rotation;
    const pixelRatio = frameState.pixelRatio;

    const offsetScaleMatrix = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.reset)(this.offsetScaleMatrix_);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.scale)(offsetScaleMatrix, 2 / size[0], 2 / size[1]);

    const offsetRotateMatrix = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.reset)(this.offsetRotateMatrix_);
    if (rotation !== 0) {
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(offsetRotateMatrix, -rotation);
    }

    this.setUniformMatrixValue(
      DefaultUniform.OFFSET_SCALE_MATRIX,
      (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__.fromTransform)(this.tmpMat4_, offsetScaleMatrix)
    );
    this.setUniformMatrixValue(
      DefaultUniform.OFFSET_ROTATION_MATRIX,
      (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__.fromTransform)(this.tmpMat4_, offsetRotateMatrix)
    );

    this.setUniformFloatValue(
      DefaultUniform.TIME,
      (Date.now() - this.startTime_) * 0.001
    );
    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
    this.setUniformFloatValue(
      DefaultUniform.RESOLUTION,
      frameState.viewState.resolution
    );
    this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);
    this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [
      size[0],
      size[1],
    ]);
  }

  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyUniforms(frameState) {
    const gl = this.gl_;

    let value;
    let textureSlot = 0;
    this.uniforms_.forEach((uniform) => {
      value =
        typeof uniform.value === 'function'
          ? uniform.value(frameState)
          : uniform.value;

      // apply value based on type
      if (
        value instanceof HTMLCanvasElement ||
        value instanceof HTMLImageElement ||
        value instanceof ImageData
      ) {
        // create a texture & put data
        if (!uniform.texture) {
          uniform.prevValue = undefined;
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        const imageReady =
          !(value instanceof HTMLImageElement) ||
          /** @type {HTMLImageElement} */ (value).complete;
        if (imageReady && uniform.prevValue !== value) {
          uniform.prevValue = value;
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            value
          );
        }

        // fill texture slots by increasing index
        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
      } else if (Array.isArray(value) && value.length === 6) {
        this.setUniformMatrixValue(
          uniform.name,
          (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__.fromTransform)(this.tmpMat4_, value)
        );
      } else if (Array.isArray(value) && value.length <= 4) {
        switch (value.length) {
          case 2:
            gl.uniform2f(
              this.getUniformLocation(uniform.name),
              value[0],
              value[1]
            );
            return;
          case 3:
            gl.uniform3f(
              this.getUniformLocation(uniform.name),
              value[0],
              value[1],
              value[2]
            );
            return;
          case 4:
            gl.uniform4f(
              this.getUniformLocation(uniform.name),
              value[0],
              value[1],
              value[2],
              value[3]
            );
            return;
          default:
            return;
        }
      } else if (typeof value === 'number') {
        gl.uniform1f(this.getUniformLocation(uniform.name), value);
      }
    });
  }

  /**
   * Set up a program for use. The program will be set as the current one. Then, the uniforms used
   * in the program will be set based on the current frame state and the helper configuration.
   * @param {WebGLProgram} program Program.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  useProgram(program, frameState) {
    const gl = this.gl_;
    gl.useProgram(program);
    this.currentProgram_ = program;
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  }

  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */
  compileShader(source, type) {
    const gl = this.gl_;
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  }

  /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   */
  getProgram(fragmentShaderSource, vertexShaderSource) {
    const gl = this.gl_;

    const fragmentShader = this.compileShader(
      fragmentShaderSource,
      gl.FRAGMENT_SHADER
    );

    const vertexShader = this.compileShader(
      vertexShaderSource,
      gl.VERTEX_SHADER
    );

    const program = gl.createProgram();
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const message = `Fragment shader compilation failed: ${gl.getShaderInfoLog(
        fragmentShader
      )}`;
      throw new Error(message);
    }
    gl.deleteShader(fragmentShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(
        vertexShader
      )}`;
      throw new Error(message);
    }
    gl.deleteShader(vertexShader);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const message = `GL program linking failed: ${gl.getProgramInfoLog(
        program
      )}`;
      throw new Error(message);
    }

    return program;
  }

  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   */
  getUniformLocation(name) {
    const programUid = (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.getUid)(this.currentProgram_);
    if (this.uniformLocationsByProgram_[programUid] === undefined) {
      this.uniformLocationsByProgram_[programUid] = {};
    }
    if (this.uniformLocationsByProgram_[programUid][name] === undefined) {
      this.uniformLocationsByProgram_[programUid][name] =
        this.gl_.getUniformLocation(this.currentProgram_, name);
    }
    return this.uniformLocationsByProgram_[programUid][name];
  }

  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   */
  getAttributeLocation(name) {
    const programUid = (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.getUid)(this.currentProgram_);
    if (this.attribLocationsByProgram_[programUid] === undefined) {
      this.attribLocationsByProgram_[programUid] = {};
    }
    if (this.attribLocationsByProgram_[programUid][name] === undefined) {
      this.attribLocationsByProgram_[programUid][name] =
        this.gl_.getAttribLocation(this.currentProgram_, name);
    }
    return this.attribLocationsByProgram_[programUid][name];
  }

  /**
   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   */
  makeProjectionTransform(frameState, transform) {
    const size = frameState.size;
    const rotation = frameState.viewState.rotation;
    const resolution = frameState.viewState.resolution;
    const center = frameState.viewState.center;
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.compose)(
      transform,
      0,
      0,
      2 / (resolution * size[0]),
      2 / (resolution * size[1]),
      -rotation,
      -center[0],
      -center[1]
    );
    return transform;
  }

  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   */
  setUniformFloatValue(uniform, value) {
    this.gl_.uniform1f(this.getUniformLocation(uniform), value);
  }

  /**
   * Give a value for a vec2 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec2(uniform, value) {
    this.gl_.uniform2fv(this.getUniformLocation(uniform), value);
  }

  /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec4(uniform, value) {
    this.gl_.uniform4fv(this.getUniformLocation(uniform), value);
  }

  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   */
  setUniformMatrixValue(uniform, value) {
    this.gl_.uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
  }

  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */
  enableAttributeArray_(attribName, size, type, stride, offset) {
    const location = this.getAttributeLocation(attribName);
    // the attribute has not been found in the shaders; do not enable it
    if (location < 0) {
      return;
    }
    this.gl_.enableVertexAttribArray(location);
    this.gl_.vertexAttribPointer(location, size, type, false, stride, offset);
  }

  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */
  enableAttributes(attributes) {
    const stride = computeAttributesStride(attributes);
    let offset = 0;
    for (let i = 0; i < attributes.length; i++) {
      const attr = attributes[i];
      this.enableAttributeArray_(
        attr.name,
        attr.size,
        attr.type || _webgl_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT,
        stride,
        offset
      );
      offset += attr.size * getByteSizeFromType(attr.type);
    }
  }

  /**
   * WebGL context was lost
   * @private
   */
  handleWebGLContextLost() {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.clear)(this.bufferCache_);
    this.currentProgram_ = null;
  }

  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {}

  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture
   * @param {WebGLTexture} [texture] Existing texture to reuse
   * @return {WebGLTexture} The generated texture
   */
  createTexture(size, data, texture) {
    const gl = this.gl_;
    texture = texture || gl.createTexture();

    // set params & size
    const level = 0;
    const internalFormat = gl.RGBA;
    const border = 0;
    const format = gl.RGBA;
    const type = gl.UNSIGNED_BYTE;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    if (data) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);
    } else {
      gl.texImage2D(
        gl.TEXTURE_2D,
        level,
        internalFormat,
        size[0],
        size[1],
        border,
        format,
        type,
        null
      );
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    return texture;
  }
}

/**
 * Compute a stride in bytes based on a list of attributes
 * @param {Array<AttributeDescription>} attributes Ordered list of attributes
 * @return {number} Stride, ie amount of values for each vertex in the vertex buffer
 */
function computeAttributesStride(attributes) {
  let stride = 0;
  for (let i = 0; i < attributes.length; i++) {
    const attr = attributes[i];
    stride += attr.size * getByteSizeFromType(attr.type);
  }
  return stride;
}

/**
 * Computes the size in byte of an attribute type.
 * @param {AttributeType} type Attribute type
 * @return {number} The size in bytes
 */
function getByteSizeFromType(type) {
  switch (type) {
    case AttributeType.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case AttributeType.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLHelper);


/***/ }),

/***/ "./node_modules/ol/webgl/PostProcessingPass.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/util.js");
/**
 * @module ol/webgl/PostProcessingPass
 */



const DEFAULT_VERTEX_SHADER = `
  precision mediump float;
  
  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;
  
  uniform vec2 u_screenSize;
   
  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`;

const DEFAULT_FRAGMENT_SHADER = `
  precision mediump float;
   
  uniform sampler2D u_image;
  uniform float u_opacity;
   
  varying vec2 v_texCoord;
   
  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;

/**
 * @typedef {Object} Options
 * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("./Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} UniformInternalDescription
 * @property {import("./Helper").UniformValue} value Value
 * @property {WebGLUniformLocation} location Location
 * @property {WebGLTexture} [texture] Texture
 * @private
 */

/**
 * @classdesc
 * This class is used to define Post Processing passes with custom shaders and uniforms.
 * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.
 *
 * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that
 * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).
 * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.
 *
 * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be
 * premultiplied.
 *
 * Default shaders are shown hereafter:
 *
 * * Vertex shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   attribute vec2 a_position;
 *   varying vec2 v_texCoord;
 *   varying vec2 v_screenCoord;
 *
 *   uniform vec2 u_screenSize;
 *
 *   void main() {
 *     v_texCoord = a_position * 0.5 + 0.5;
 *     v_screenCoord = v_texCoord * u_screenSize;
 *     gl_Position = vec4(a_position, 0.0, 1.0);
 *   }
 *   ```
 *
 * * Fragment shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   uniform sampler2D u_image;
 *   uniform float u_opacity;
 *
 *   varying vec2 v_texCoord;
 *
 *   void main() {
 *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
 *   }
 *   ```
 *
 * @api
 */
class WebGLPostProcessingPass {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    this.gl_ = options.webGlContext;
    const gl = this.gl_;

    this.scaleRatio_ = options.scaleRatio || 1;

    this.renderTargetTexture_ = gl.createTexture();
    this.renderTargetTextureSize_ = null;

    this.frameBuffer_ = gl.createFramebuffer();

    // compile the program for the frame buffer
    // TODO: make compilation errors show up
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(
      vertexShader,
      options.vertexShader || DEFAULT_VERTEX_SHADER
    );
    gl.compileShader(vertexShader);
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(
      fragmentShader,
      options.fragmentShader || DEFAULT_FRAGMENT_SHADER
    );
    gl.compileShader(fragmentShader);
    this.renderTargetProgram_ = gl.createProgram();
    gl.attachShader(this.renderTargetProgram_, vertexShader);
    gl.attachShader(this.renderTargetProgram_, fragmentShader);
    gl.linkProgram(this.renderTargetProgram_);

    // bind the vertices buffer for the frame buffer
    this.renderTargetVerticesBuffer_ = gl.createBuffer();
    const verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(verticesArray),
      gl.STATIC_DRAW
    );

    this.renderTargetAttribLocation_ = gl.getAttribLocation(
      this.renderTargetProgram_,
      'a_position'
    );
    this.renderTargetUniformLocation_ = gl.getUniformLocation(
      this.renderTargetProgram_,
      'u_screenSize'
    );
    this.renderTargetOpacityLocation_ = gl.getUniformLocation(
      this.renderTargetProgram_,
      'u_opacity'
    );
    this.renderTargetTextureLocation_ = gl.getUniformLocation(
      this.renderTargetProgram_,
      'u_image'
    );

    /**
     * Holds info about custom uniforms used in the post processing pass
     * @type {Array<UniformInternalDescription>}
     * @private
     */
    this.uniforms_ = [];
    options.uniforms &&
      Object.keys(options.uniforms).forEach((name) => {
        this.uniforms_.push({
          value: options.uniforms[name],
          location: gl.getUniformLocation(this.renderTargetProgram_, name),
        });
      });
  }

  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   * @api
   */
  getGL() {
    return this.gl_;
  }

  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @api
   */
  init(frameState) {
    const gl = this.getGL();
    const textureSize = [
      gl.drawingBufferWidth * this.scaleRatio_,
      gl.drawingBufferHeight * this.scaleRatio_,
    ];

    // rendering goes to my buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
    gl.viewport(0, 0, textureSize[0], textureSize[1]);

    // if size has changed: adjust canvas & render target texture
    if (
      !this.renderTargetTextureSize_ ||
      this.renderTargetTextureSize_[0] !== textureSize[0] ||
      this.renderTargetTextureSize_[1] !== textureSize[1]
    ) {
      this.renderTargetTextureSize_ = textureSize;

      // create a new texture
      const level = 0;
      const internalFormat = gl.RGBA;
      const border = 0;
      const format = gl.RGBA;
      const type = gl.UNSIGNED_BYTE;
      const data = null;
      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
      gl.texImage2D(
        gl.TEXTURE_2D,
        level,
        internalFormat,
        textureSize[0],
        textureSize[1],
        border,
        format,
        type,
        data
      );

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      // bind the texture to the framebuffer
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        this.renderTargetTexture_,
        0
      );
    }
  }

  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   * @api
   */
  apply(frameState, nextPass, preCompose, postCompose) {
    const gl = this.getGL();
    const size = frameState.size;

    gl.bindFramebuffer(
      gl.FRAMEBUFFER,
      nextPass ? nextPass.getFrameBuffer() : null
    );
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);

    if (!nextPass) {
      // clear the canvas if we are the first to render to it
      // and preserveDrawingBuffer is true
      const canvasId = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(gl.canvas);
      if (!frameState.renderTargets[canvasId]) {
        const attributes = gl.getContextAttributes();
        if (attributes && attributes.preserveDrawingBuffer) {
          gl.clearColor(0.0, 0.0, 0.0, 0.0);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }

        frameState.renderTargets[canvasId] = true;
      }
    }

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);

    gl.useProgram(this.renderTargetProgram_);
    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
    gl.vertexAttribPointer(
      this.renderTargetAttribLocation_,
      2,
      gl.FLOAT,
      false,
      0,
      0
    );
    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
    gl.uniform1i(this.renderTargetTextureLocation_, 0);

    const opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;
    gl.uniform1f(this.renderTargetOpacityLocation_, opacity);

    this.applyUniforms(frameState);

    if (preCompose) {
      preCompose(gl, frameState);
    }
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    if (postCompose) {
      postCompose(gl, frameState);
    }
  }

  /**
   * @return {WebGLFramebuffer} Frame buffer
   * @api
   */
  getFrameBuffer() {
    return this.frameBuffer_;
  }

  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @private
   */
  applyUniforms(frameState) {
    const gl = this.getGL();

    let value;
    let textureSlot = 1;
    this.uniforms_.forEach(function (uniform) {
      value =
        typeof uniform.value === 'function'
          ? uniform.value(frameState)
          : uniform.value;

      // apply value based on type
      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
        // create a texture & put data
        if (!uniform.texture) {
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        if (value instanceof ImageData) {
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            value.width,
            value.height,
            0,
            gl.UNSIGNED_BYTE,
            new Uint8Array(value.data)
          );
        } else {
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            value
          );
        }

        // fill texture slots
        gl.uniform1i(uniform.location, textureSlot++);
      } else if (Array.isArray(value)) {
        switch (value.length) {
          case 2:
            gl.uniform2f(uniform.location, value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(uniform.location, value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(
              uniform.location,
              value[0],
              value[1],
              value[2],
              value[3]
            );
            return;
          default:
            return;
        }
      } else if (typeof value === 'number') {
        gl.uniform1f(uniform.location, value);
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLPostProcessingPass);


/***/ }),

/***/ "./node_modules/ol/webgl/RenderTarget.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/ol/array.js");
/**
 * A wrapper class to simplify rendering to a texture instead of the final canvas
 * @module ol/webgl/RenderTarget
 */


// for pixel color reading
const tmpArray4 = new Uint8Array(4);

/**
 * @classdesc
 * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,
 * simplifying initialization and binding for rendering.
 * @api
 */
class WebGLRenderTarget {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
   */
  constructor(helper, size) {
    /**
     * @private
     * @type {import("./Helper.js").default}
     */
    this.helper_ = helper;
    const gl = helper.getGL();

    /**
     * @private
     * @type {WebGLTexture}
     */
    this.texture_ = gl.createTexture();

    /**
     * @private
     * @type {WebGLFramebuffer}
     */
    this.framebuffer_ = gl.createFramebuffer();

    /**
     * @type {Array<number>}
     * @private
     */
    this.size_ = size || [1, 1];

    /**
     * @type {Uint8Array}
     * @private
     */
    this.data_ = new Uint8Array(0);

    /**
     * @type {boolean}
     * @private
     */
    this.dataCacheDirty_ = true;

    this.updateSize_();
  }

  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   * @api
   */
  setSize(size) {
    if ((0,_array_js__WEBPACK_IMPORTED_MODULE_0__.equals)(size, this.size_)) {
      return;
    }
    this.size_[0] = size[0];
    this.size_[1] = size[1];
    this.updateSize_();
  }

  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   * @api
   */
  getSize() {
    return this.size_;
  }

  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   * @api
   */
  clearCachedData() {
    this.dataCacheDirty_ = true;
  }

  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   * @api
   */
  readAll() {
    if (this.dataCacheDirty_) {
      const size = this.size_;
      const gl = this.helper_.getGL();

      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
      gl.readPixels(
        0,
        0,
        size[0],
        size[1],
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        this.data_
      );
      this.dataCacheDirty_ = false;
    }
    return this.data_;
  }

  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @return {Uint8Array} Integer array with one color value (4 components)
   * @api
   */
  readPixel(x, y) {
    if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {
      tmpArray4[0] = 0;
      tmpArray4[1] = 0;
      tmpArray4[2] = 0;
      tmpArray4[3] = 0;
      return tmpArray4;
    }

    this.readAll();
    const index =
      Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];
    tmpArray4[0] = this.data_[index * 4];
    tmpArray4[1] = this.data_[index * 4 + 1];
    tmpArray4[2] = this.data_[index * 4 + 2];
    tmpArray4[3] = this.data_[index * 4 + 3];
    return tmpArray4;
  }

  /**
   * @return {WebGLTexture} Texture to render to
   */
  getTexture() {
    return this.texture_;
  }

  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */
  getFramebuffer() {
    return this.framebuffer_;
  }

  /**
   * @private
   */
  updateSize_() {
    const size = this.size_;
    const gl = this.helper_.getGL();

    this.texture_ = this.helper_.createTexture(size, null, this.texture_);

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
    gl.viewport(0, 0, size[0], size[1]);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture_,
      0
    );

    this.data_ = new Uint8Array(size[0] * size[1] * 4);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLRenderTarget);


/***/ }),

/***/ "./node_modules/ol/worker/webgl.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   create: () => (/* binding */ create)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];

        function create() {
          const source = "const e=\"GENERATE_POLYGON_BUFFERS\",t=\"GENERATE_POINT_BUFFERS\",n=\"GENERATE_LINE_STRING_BUFFERS\",r={1:\"The view center is not defined\",2:\"The view resolution is not defined\",3:\"The view rotation is not defined\",4:\"`image` and `src` cannot be provided at the same time\",5:\"`imgSize` must be set when `image` is provided\",7:\"`format` must be set when `url` is set\",8:\"Unknown `serverType` configured\",9:\"`url` must be configured or set using `#setUrl()`\",10:\"The default `geometryFunction` can only handle `Point` geometries\",11:\"`options.featureTypes` must be an Array\",12:\"`options.geometryName` must also be provided when `options.bbox` is set\",13:\"Invalid corner\",14:\"Invalid color\",15:\"Tried to get a value for a key that does not exist in the cache\",16:\"Tried to set a value for a key that is used already\",17:\"`resolutions` must be sorted in descending order\",18:\"Either `origin` or `origins` must be configured, never both\",19:\"Number of `tileSizes` and `resolutions` must be equal\",20:\"Number of `origins` and `resolutions` must be equal\",22:\"Either `tileSize` or `tileSizes` must be configured, never both\",24:\"Invalid extent or geometry provided as `geometry`\",25:\"Cannot fit empty extent provided as `geometry`\",26:\"Features must have an id set\",27:\"Features must have an id set\",28:'`renderMode` must be `\"hybrid\"` or `\"vector\"`',30:\"The passed `feature` was already added to the source\",31:\"Tried to enqueue an `element` that was already added to the queue\",32:\"Transformation matrix cannot be inverted\",33:\"Invalid units\",34:\"Invalid geometry layout\",36:\"Unknown SRS type\",37:\"Unknown geometry type found\",38:\"`styleMapValue` has an unknown type\",39:\"Unknown geometry type\",40:\"Expected `feature` to have a geometry\",41:\"Expected an `ol/style/Style` or an array of `ol/style/Style.js`\",42:\"Question unknown, the answer is 42\",43:\"Expected `layers` to be an array or a `Collection`\",47:\"Expected `controls` to be an array or an `ol/Collection`\",48:\"Expected `interactions` to be an array or an `ol/Collection`\",49:\"Expected `overlays` to be an array or an `ol/Collection`\",50:\"`options.featureTypes` should be an Array\",51:\"Either `url` or `tileJSON` options must be provided\",52:\"Unknown `serverType` configured\",53:\"Unknown `tierSizeCalculation` configured\",55:\"The {-y} placeholder requires a tile grid with extent\",56:\"mapBrowserEvent must originate from a pointer event\",57:\"At least 2 conditions are required\",59:\"Invalid command found in the PBF\",60:\"Missing or invalid `size`\",61:\"Cannot determine IIIF Image API version from provided image information JSON\",62:\"A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`\",64:\"Layer opacity must be a number\",66:\"`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`\",67:\"A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both\",68:\"A VectorTile source can only be rendered if it has a projection compatible with the view projection\",69:\"`width` or `height` cannot be provided together with `scale`\"};class o extends Error{constructor(e){const t=r[e];super(t),this.code=e,this.name=\"AssertionError\",this.message=t}}var i=o;function a(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function s(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new i(t)}(0!==n,32);const o=t[0],a=t[1],s=t[2],u=t[3],f=t[4],x=t[5];return e[0]=u/n,e[1]=-a/n,e[2]=-s/n,e[3]=o/n,e[4]=(s*x-u*f)/n,e[5]=-(o*x-a*f)/n,e}function u(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}new Array(6);var f={exports:{}};function x(e,t,n){n=n||2;var r,o,i,a,s,u,f,x=t&&t.length,h=x?t[0]*n:e.length,v=l(e,0,h,n,!0),d=[];if(!v||v.next===v.prev)return d;if(x&&(v=function(e,t,n,r){var o,i,a,s=[];for(o=0,i=t.length;o<i;o++)(a=l(e,t[o]*r,o<i-1?t[o+1]*r:e.length,r,!1))===a.next&&(a.steiner=!0),s.push(A(a));for(s.sort(b),o=0;o<s.length;o++)n=g(s[o],n);return n}(e,t,v,n)),e.length>80*n){r=i=e[0],o=a=e[1];for(var y=n;y<h;y+=n)(s=e[y])<r&&(r=s),(u=e[y+1])<o&&(o=u),s>i&&(i=s),u>a&&(a=u);f=0!==(f=Math.max(i-r,a-o))?32767/f:0}return c(v,d,n,r,o,f,0),d}function l(e,t,n,r,o){var i,a;if(o===P(e,t,n,r)>0)for(i=t;i<n;i+=r)a=k(i,e[i],e[i+1],a);else for(i=n-r;i>=t;i-=r)a=k(i,e[i],e[i+1],a);return a&&F(a,a.next)&&(R(a),a=a.next),a}function h(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!F(r,r.next)&&0!==Z(r.prev,r,r.next))r=r.next;else{if(R(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function c(e,t,n,r,o,i,a){if(e){!a&&i&&function(e,t,n,r){var o=e;do{0===o.z&&(o.z=w(o.x,o.y,t,n,r)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){var t,n,r,o,i,a,s,u,f=1;do{for(n=e,e=null,i=null,a=0;n;){for(a++,r=n,s=0,t=0;t<f&&(s++,r=r.nextZ);t++);for(u=f;s>0||u>0&&r;)0!==s&&(0===u||!r||n.z<=r.z)?(o=n,n=n.nextZ,s--):(o=r,r=r.nextZ,u--),i?i.nextZ=o:e=o,o.prevZ=i,i=o;n=r}i.nextZ=null,f*=2}while(a>1)}(o)}(e,r,o,i);for(var s,u,f=e;e.prev!==e.next;)if(s=e.prev,u=e.next,i?d(e,r,o,i):v(e))t.push(s.i/n|0),t.push(e.i/n|0),t.push(u.i/n|0),R(e),e=u.next,f=u.next;else if((e=u)===f){a?1===a?c(e=y(h(e),t,n),t,n,r,o,i,2):2===a&&p(e,t,n,r,o,i):c(h(e),t,n,r,o,i,1);break}}}function v(e){var t=e.prev,n=e,r=e.next;if(Z(t,n,r)>=0)return!1;for(var o=t.x,i=n.x,a=r.x,s=t.y,u=n.y,f=r.y,x=o<i?o<a?o:a:i<a?i:a,l=s<u?s<f?s:f:u<f?u:f,h=o>i?o>a?o:a:i>a?i:a,c=s>u?s>f?s:f:u>f?u:f,v=r.next;v!==t;){if(v.x>=x&&v.x<=h&&v.y>=l&&v.y<=c&&E(o,s,i,u,a,f,v.x,v.y)&&Z(v.prev,v,v.next)>=0)return!1;v=v.next}return!0}function d(e,t,n,r){var o=e.prev,i=e,a=e.next;if(Z(o,i,a)>=0)return!1;for(var s=o.x,u=i.x,f=a.x,x=o.y,l=i.y,h=a.y,c=s<u?s<f?s:f:u<f?u:f,v=x<l?x<h?x:h:l<h?l:h,d=s>u?s>f?s:f:u>f?u:f,y=x>l?x>h?x:h:l>h?l:h,p=w(c,v,t,n,r),b=w(d,y,t,n,r),g=e.prevZ,m=e.nextZ;g&&g.z>=p&&m&&m.z<=b;){if(g.x>=c&&g.x<=d&&g.y>=v&&g.y<=y&&g!==o&&g!==a&&E(s,x,u,l,f,h,g.x,g.y)&&Z(g.prev,g,g.next)>=0)return!1;if(g=g.prevZ,m.x>=c&&m.x<=d&&m.y>=v&&m.y<=y&&m!==o&&m!==a&&E(s,x,u,l,f,h,m.x,m.y)&&Z(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;g&&g.z>=p;){if(g.x>=c&&g.x<=d&&g.y>=v&&g.y<=y&&g!==o&&g!==a&&E(s,x,u,l,f,h,g.x,g.y)&&Z(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;m&&m.z<=b;){if(m.x>=c&&m.x<=d&&m.y>=v&&m.y<=y&&m!==o&&m!==a&&E(s,x,u,l,f,h,m.x,m.y)&&Z(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function y(e,t,n){var r=e;do{var o=r.prev,i=r.next.next;!F(o,i)&&T(o,r,r.next,i)&&z(o,i)&&z(i,o)&&(t.push(o.i/n|0),t.push(r.i/n|0),t.push(i.i/n|0),R(r),R(r.next),r=e=i),r=r.next}while(r!==e);return h(r)}function p(e,t,n,r,o,i){var a=e;do{for(var s=a.next.next;s!==a.prev;){if(a.i!==s.i&&M(a,s)){var u=U(a,s);return a=h(a,a.next),u=h(u,u.next),c(a,t,n,r,o,i,0),void c(u,t,n,r,o,i,0)}s=s.next}a=a.next}while(a!==e)}function b(e,t){return e.x-t.x}function g(e,t){var n=function(e,t){var n,r=t,o=e.x,i=e.y,a=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var s=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=o&&s>a&&(a=s,n=r.x<r.next.x?r:r.next,s===o))return n}r=r.next}while(r!==t);if(!n)return null;var u,f=n,x=n.x,l=n.y,h=1/0;r=n;do{o>=r.x&&r.x>=x&&o!==r.x&&E(i<l?o:a,i,x,l,i<l?a:o,i,r.x,r.y)&&(u=Math.abs(i-r.y)/(o-r.x),z(r,e)&&(u<h||u===h&&(r.x>n.x||r.x===n.x&&m(n,r)))&&(n=r,h=u)),r=r.next}while(r!==f);return n}(e,t);if(!n)return t;var r=U(n,e);return h(r,r.next),h(n,n.next)}function m(e,t){return Z(e.prev,e,t.prev)<0&&Z(t.next,e,e.next)<0}function w(e,t,n,r,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function A(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function E(e,t,n,r,o,i,a,s){return(o-a)*(t-s)>=(e-a)*(i-s)&&(e-a)*(r-s)>=(n-a)*(t-s)&&(n-a)*(i-s)>=(o-a)*(r-s)}function M(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&T(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(z(e,t)&&z(t,e)&&function(e,t){var n=e,r=!1,o=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&o<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(Z(e.prev,e,t.prev)||Z(e,t.prev,t))||F(e,t)&&Z(e.prev,e,e.next)>0&&Z(t.prev,t,t.next)>0)}function Z(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function F(e,t){return e.x===t.x&&e.y===t.y}function T(e,t,n,r){var o=S(Z(e,t,n)),i=S(Z(e,t,r)),a=S(Z(n,r,e)),s=S(Z(n,r,t));return o!==i&&a!==s||(!(0!==o||!I(e,n,t))||(!(0!==i||!I(e,r,t))||(!(0!==a||!I(n,e,r))||!(0!==s||!I(n,t,r)))))}function I(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function S(e){return e>0?1:e<0?-1:0}function z(e,t){return Z(e.prev,e,e.next)<0?Z(e,t,e.next)>=0&&Z(e,e.prev,t)>=0:Z(e,t,e.prev)<0||Z(e,e.next,t)<0}function U(e,t){var n=new B(e.i,e.x,e.y),r=new B(t.i,t.x,t.y),o=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function k(e,t,n,r){var o=new B(e,t,n);return r?(o.next=r.next,o.prev=r,r.next.prev=o,r.next=o):(o.prev=o,o.next=o),o}function R(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function B(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function P(e,t,n,r){for(var o=0,i=t,a=n-r;i<n;i+=r)o+=(e[a]-e[i])*(e[i+1]+e[a+1]),a=i;return o}f.exports=x,f.exports.default=x,x.deviation=function(e,t,n,r){var o=t&&t.length,i=o?t[0]*n:e.length,a=Math.abs(P(e,0,i,n));if(o)for(var s=0,u=t.length;s<u;s++){var f=t[s]*n,x=s<u-1?t[s+1]*n:e.length;a-=Math.abs(P(e,f,x,n))}var l=0;for(s=0;s<r.length;s+=3){var h=r[s]*n,c=r[s+1]*n,v=r[s+2]*n;l+=Math.abs((e[h]-e[v])*(e[c+1]-e[h+1])-(e[h]-e[c])*(e[v+1]-e[h+1]))}return 0===a&&0===l?0:Math.abs((l-a)/a)},x.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,o=0;o<e.length;o++){for(var i=0;i<e[o].length;i++)for(var a=0;a<t;a++)n.vertices.push(e[o][i][a]);o>0&&(r+=e[o-1].length,n.holes.push(r))}return n};var N=u(f.exports);const _=[],O={vertexPosition:0,indexPosition:0};function q(e,t,n,r,o){e[t+0]=n,e[t+1]=r,e[t+2]=o}function L(e,t,n,r,o,i){const a=3+o,s=e[t+0],u=e[t+1],f=_;f.length=o;for(let n=0;n<f.length;n++)f[n]=e[t+2+n];let x=i?i.vertexPosition:0,l=i?i.indexPosition:0;const h=x/a;return q(n,x,s,u,0),f.length&&n.set(f,x+3),x+=a,q(n,x,s,u,1),f.length&&n.set(f,x+3),x+=a,q(n,x,s,u,2),f.length&&n.set(f,x+3),x+=a,q(n,x,s,u,3),f.length&&n.set(f,x+3),x+=a,r[l++]=h,r[l++]=h+1,r[l++]=h+3,r[l++]=h+1,r[l++]=h+2,r[l++]=h+3,O.vertexPosition=x,O.indexPosition=l,O}function C(e,t,n,r,o,i,s,u,f,x){const l=5+u.length,h=i.length/l,c=[e[t+0],e[t+1]],v=[e[n],e[n+1]],d=a(x,[...c]),y=a(x,[...v]);function p(e,t,n){const r=1e4;return Math.round(1500*t)+Math.round(1500*n)*r+e*r*r}function b(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),o=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-o[1],o[0]],a=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),s=[(n[0]-e[0])/a,(n[1]-e[1])/a],u=0===r||0===a?0:Math.acos((f=s[0]*o[0]+s[1]*o[1],x=-1,l=1,Math.min(Math.max(f,x),l)));var f,x,l;return s[0]*i[0]+s[1]*i[1]>0?u:2*Math.PI-u}const g=null!==o;let m=0,w=0;if(null!==r){m=b(d,y,a(x,[...[e[r],e[r+1]]]))}if(g){w=b(y,d,a(x,[...[e[o],e[o+1]]]))}i.push(c[0],c[1],v[0],v[1],p(0,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(1,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(2,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(3,m,w)),i.push(...u),s.push(h,h+1,h+2,h+1,h+3,h+2)}function G(e,t,n,r,o){const i=2+o;let a=t;const s=e.slice(a,a+o);a+=o;const u=e[a++];let f=0;const x=new Array(u-1);for(let t=0;t<u;t++)f+=e[a++],t<u-1&&(x[t]=f);const l=e.slice(a,a+2*f),h=N(l,x,2);for(let e=0;e<h.length;e++)r.push(h[e]+n.length/i);for(let e=0;e<l.length;e+=2)n.push(l[e],l[e+1],...s);return a+2*f}const j=self;j.onmessage=r=>{const o=r.data;switch(o.type){case t:{const e=3,t=2,n=o.customAttributesSize,r=t+n,i=new Float32Array(o.renderInstructions),a=i.length/r,s=4*a*(n+e),u=new Uint32Array(6*a),f=new Float32Array(s);let x;for(let e=0;e<i.length;e+=r)x=L(i,e,f,u,n,x);const l=Object.assign({vertexBuffer:f.buffer,indexBuffer:u.buffer,renderInstructions:i.buffer},o);j.postMessage(l,[f.buffer,u.buffer,i.buffer]);break}case n:{const e=[],t=[],n=o.customAttributesSize,r=2,i=new Float32Array(o.renderInstructions);let a=0;const u=o.renderInstructionsTransform,f=[1,0,0,1,0,0];let x,l;for(s(f,u);a<i.length;){l=Array.from(i.slice(a,a+n)),a+=n,x=i[a++];for(let n=0;n<x-1;n++)C(i,a+n*r,a+(n+1)*r,n>0?a+(n-1)*r:null,n<x-2?a+(n+2)*r:null,e,t,l,0,f);a+=x*r}const h=Uint32Array.from(t),c=Float32Array.from(e),v=Object.assign({vertexBuffer:c.buffer,indexBuffer:h.buffer,renderInstructions:i.buffer},o);j.postMessage(v,[c.buffer,h.buffer,i.buffer]);break}case e:{const e=[],t=[],n=o.customAttributesSize,r=new Float32Array(o.renderInstructions);let i=0;for(;i<r.length;)i=G(r,i,e,t,n);const a=Uint32Array.from(t),s=Float32Array.from(e),u=Object.assign({vertexBuffer:s.buffer,indexBuffer:a.buffer,renderInstructions:r.buffer},o);j.postMessage(u,[s.buffer,a.buffer,r.buffer]);break}}};";
          return new Worker(typeof Blob === 'undefined'
            ? 'data:application/javascript;base64,' + Buffer.from(source, 'binary').toString('base64')
            : URL.createObjectURL(new Blob([source], {type: 'application/javascript'})));
        }
      


/***/ })

}]);
//# sourceMappingURL=geomapPanel.9fcfbb9d3801bf680bfc.js.map