"use strict";
(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["node_modules_glideapps_glide-data-grid_dist_esm_internal_data-grid-overlay-editor_data-grid-o-f5d758"],{

/***/ "./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor-style.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataGridOverlayEditorStyle: () => (/* binding */ DataGridOverlayEditorStyle)
/* harmony export */ });
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@linaria/react/dist/index.mjs");

const _exp2 = /*#__PURE__*/() => p => p.targetX;
const _exp3 = /*#__PURE__*/() => p => p.targetY;
const _exp4 = /*#__PURE__*/() => p => p.targetWidth;
const _exp5 = /*#__PURE__*/() => p => p.targetHeight;
const _exp6 = /*#__PURE__*/() => p => p.targetY + 10;
const _exp7 = /*#__PURE__*/() => p => Math.max(0, (p.targetHeight - 28) / 2);
const DataGridOverlayEditorStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({
  name: "DataGridOverlayEditorStyle",
  class: "gdg-d19meir1",
  propsAsIs: false,
  vars: {
    "d19meir1-0": [_exp3(), "px"],
    "d19meir1-1": [_exp2(), "px"],
    "d19meir1-2": [_exp4(), "px"],
    "d19meir1-3": [_exp5(), "px"],
    "d19meir1-4": [_exp6(), "px"],
    "d19meir1-5": [_exp7(), "px"]
  }
});



/***/ }),

/***/ "./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react-dom/index.js");
/* harmony import */ var _click_outside_container_click_outside_container_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@glideapps/glide-data-grid/dist/esm/internal/click-outside-container/click-outside-container.js");
/* harmony import */ var _common_styles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js");
/* harmony import */ var _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js");
/* harmony import */ var _data_grid_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor-style.js");
/* harmony import */ var _use_stay_on_screen_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/use-stay-on-screen.js");







const DataGridOverlayEditor = p => {
    const { target, content, onFinishEditing: onFinishEditingIn, forceEditMode, initialValue, imageEditorOverride, markdownDivCreateNode, highlight, className, theme, id, cell, bloom, validateCell, getCellRenderer, provideEditor, isOutsideClick, } = p;
    const [tempValue, setTempValueRaw] = react__WEBPACK_IMPORTED_MODULE_0__.useState(forceEditMode ? content : undefined);
    const lastValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(tempValue ?? content);
    lastValueRef.current = tempValue ?? content;
    const [isValid, setIsValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
        if (validateCell === undefined)
            return true;
        return !((0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isEditableGridCell)(content) && validateCell?.(cell, content, lastValueRef.current) === false);
    });
    const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCell, movement) => {
        onFinishEditingIn(isValid ? newCell : undefined, movement);
    }, [isValid, onFinishEditingIn]);
    const setTempValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal) => {
        if (validateCell !== undefined && newVal !== undefined && (0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isEditableGridCell)(newVal)) {
            const validResult = validateCell(cell, newVal, lastValueRef.current);
            if (validResult === false) {
                setIsValid(false);
            }
            else if (typeof validResult === "object") {
                newVal = validResult;
                setIsValid(true);
            }
            else {
                setIsValid(true);
            }
        }
        setTempValueRaw(newVal);
    }, [cell, validateCell]);
    const finished = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
    const customMotion = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);
    const onClickOutside = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
        onFinishEditing(tempValue, [0, 0]);
        finished.current = true;
    }, [tempValue, onFinishEditing]);
    const onEditorFinished = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newValue, movement) => {
        onFinishEditing(newValue, movement ?? customMotion.current ?? [0, 0]);
        finished.current = true;
    }, [onFinishEditing]);
    const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (event) => {
        let save = false;
        if (event.key === "Escape") {
            event.stopPropagation();
            event.preventDefault();
            customMotion.current = [0, 0];
        }
        else if (event.key === "Enter" && !event.shiftKey) {
            event.stopPropagation();
            event.preventDefault();
            customMotion.current = [0, 1];
            save = true;
        }
        else if (event.key === "Tab") {
            event.stopPropagation();
            event.preventDefault();
            customMotion.current = [event.shiftKey ? -1 : 1, 0];
            save = true;
        }
        window.setTimeout(() => {
            if (!finished.current && customMotion.current !== undefined) {
                onFinishEditing(save ? tempValue : undefined, customMotion.current);
                finished.current = true;
            }
        }, 0);
    }, [onFinishEditing, tempValue]);
    const targetValue = tempValue ?? content;
    const [editorProvider, useLabel] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
        if ((0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isInnerOnlyCell)(content))
            return [];
        const external = provideEditor?.(content);
        if (external !== undefined)
            return [external, false];
        return [getCellRenderer(content)?.provideEditor?.(content), false];
    }, [content, getCellRenderer, provideEditor]);
    const { ref, style: stayOnScreenStyle } = (0,_use_stay_on_screen_js__WEBPACK_IMPORTED_MODULE_3__.useStayOnScreen)();
    let pad = true;
    let editor;
    let style = true;
    let styleOverride;
    if (editorProvider !== undefined) {
        pad = editorProvider.disablePadding !== true;
        style = editorProvider.disableStyling !== true;
        const isObjectEditor = (0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isObjectEditorCallbackResult)(editorProvider);
        if (isObjectEditor) {
            styleOverride = editorProvider.styleOverride;
        }
        const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;
        editor = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomEditor, { isHighlighted: highlight, onChange: setTempValue, value: targetValue, initialValue: initialValue, onFinishedEditing: onEditorFinished, validatedSelection: (0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isEditableGridCell)(targetValue) ? targetValue.selectionRange : undefined, forceEditMode: forceEditMode, target: target, imageEditorOverride: imageEditorOverride, markdownDivCreateNode: markdownDivCreateNode, isValid: isValid, theme: theme }));
    }
    styleOverride = { ...styleOverride, ...stayOnScreenStyle };
    // Consider imperatively creating and adding the element to the dom?
    const portalElement = document.getElementById("portal");
    if (portalElement === null) {
        // eslint-disable-next-line no-console
        console.error('Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id="portal" />` as the last child of your `<body>`.');
        return null;
    }
    let classWrap = style ? "gdg-style" : "gdg-unstyle";
    if (!isValid) {
        classWrap += " gdg-invalid";
    }
    if (pad) {
        classWrap += " gdg-pad";
    }
    const bloomX = bloom?.[0] ?? 1;
    const bloomY = bloom?.[1] ?? 1;
    return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_common_styles_js__WEBPACK_IMPORTED_MODULE_4__.ThemeContext.Provider, { value: theme },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_click_outside_container_click_outside_container_js__WEBPACK_IMPORTED_MODULE_5__["default"], { style: (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_4__.makeCSSStyle)(theme), className: className, onClickOutside: onClickOutside, isOutsideClick: isOutsideClick },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_6__.DataGridOverlayEditorStyle, { ref: ref, id: id, className: classWrap, style: styleOverride, as: useLabel === true ? "label" : undefined, targetX: target.x - bloomX, targetY: target.y - bloomY, targetWidth: target.width + bloomX * 2, targetHeight: target.height + bloomY * 2 },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "gdg-clip-region", onKeyDown: onKeyDown }, editor)))), portalElement);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataGridOverlayEditor);
//# sourceMappingURL=data-grid-overlay-editor.js.map

/***/ }),

/***/ "./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/use-stay-on-screen.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useStayOnScreen: () => (/* binding */ useStayOnScreen)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");

function useRefState() {
    const [refState, setRefState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
    return [refState ?? undefined, setRefState];
}
function useStayOnScreen() {
    const [ref, setRef] = useRefState();
    const [xOffset, setXOffset] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
    const [isIntersecting, setIsIntersecting] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
        if (ref === undefined)
            return;
        if (!("IntersectionObserver" in window))
            return;
        const observer = new IntersectionObserver(ents => {
            if (ents.length === 0)
                return;
            setIsIntersecting(ents[0].isIntersecting);
        }, { threshold: 1 });
        observer.observe(ref);
        return () => observer.disconnect();
    }, [ref]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
        if (isIntersecting || ref === undefined)
            return;
        let rafHandle;
        const fn = () => {
            const { right: refRight } = ref.getBoundingClientRect();
            setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));
            rafHandle = requestAnimationFrame(fn);
        };
        rafHandle = requestAnimationFrame(fn);
        return () => {
            if (rafHandle !== undefined) {
                cancelAnimationFrame(rafHandle);
            }
        };
    }, [ref, isIntersecting]);
    const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
        return { transform: `translateX(${xOffset}px)` };
    }, [xOffset]);
    return {
        ref: setRef,
        style,
    };
}
//# sourceMappingURL=use-stay-on-screen.js.map

/***/ })

}]);
//# sourceMappingURL=node_modules_glideapps_glide-data-grid_dist_esm_internal_data-grid-overlay-editor_data-grid-o-f5d758.0f089e30a3bf9f5683d0.js.map