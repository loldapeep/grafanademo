{"version":3,"file":"public_app_features_alerting_unified_components_rules_state-history_StateHistory_tsx.e8da4da3400428ae6979.js","mappings":"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","sources":["webpack://grafana/./public/app/features/alerting/unified/components/rules/state-history/StateHistory.tsx","webpack://grafana/./public/app/features/alerting/unified/hooks/useManagedAlertStateHistory.ts"],"sourcesContent":["import { css } from '@emotion/css';\nimport { groupBy } from 'lodash';\nimport React, { FormEvent, useCallback, useState } from 'react';\n\nimport { AlertState, dateTimeFormat, GrafanaTheme2 } from '@grafana/data';\nimport { Alert, Field, Icon, Input, Label, LoadingPlaceholder, Tooltip, useStyles2, Stack } from '@grafana/ui';\nimport { StateHistoryItem, StateHistoryItemData } from '../../../../../../types/unified-alerting';\nimport { GrafanaAlertStateWithReason, PromAlertingRuleState } from '../../../../../../types/unified-alerting-dto';\n\nimport { useManagedAlertStateHistory } from '../../../hooks/useManagedAlertStateHistory';\nimport { AlertLabel } from '../../AlertLabel';\nimport { DynamicTable, DynamicTableColumnProps, DynamicTableItemProps } from '../../DynamicTable';\nimport { AlertStateTag } from '../AlertStateTag';\n\ntype StateHistoryRowItem = {\n  id: string;\n  state: PromAlertingRuleState | GrafanaAlertStateWithReason | AlertState;\n  text?: string;\n  data?: StateHistoryItemData;\n  timestamp?: number;\n  stringifiedLabels: string;\n};\n\ntype StateHistoryMap = Record<string, StateHistoryRowItem[]>;\n\ntype StateHistoryRow = DynamicTableItemProps<StateHistoryRowItem>;\n\ninterface Props {\n  alertId: string;\n}\n\nconst StateHistory = ({ alertId }: Props) => {\n  const [textFilter, setTextFilter] = useState<string>('');\n  const handleTextFilter = useCallback((event: FormEvent<HTMLInputElement>) => {\n    setTextFilter(event.currentTarget.value);\n  }, []);\n\n  const { loading, error, result = [] } = useManagedAlertStateHistory(alertId);\n\n  const styles = useStyles2(getStyles);\n\n  if (loading && !error) {\n    return <LoadingPlaceholder text={'Loading history...'} />;\n  }\n\n  if (error && !loading) {\n    return <Alert title={'Failed to fetch alert state history'}>{error.message}</Alert>;\n  }\n\n  const columns: Array<DynamicTableColumnProps<StateHistoryRowItem>> = [\n    { id: 'state', label: 'State', size: 'max-content', renderCell: renderStateCell },\n    { id: 'value', label: '', size: 'auto', renderCell: renderValueCell },\n    { id: 'timestamp', label: 'Time', size: 'max-content', renderCell: renderTimestampCell },\n  ];\n\n  // group the state history list by unique set of labels\n  const tables = Object.entries(groupStateByLabels(result))\n    // sort and filter each table\n    .sort()\n    .filter(([groupKey]) => matchKey(groupKey, textFilter))\n    .map(([groupKey, items]) => {\n      const tableItems: StateHistoryRow[] = items.map((historyItem) => ({\n        id: historyItem.id,\n        data: historyItem,\n      }));\n\n      return (\n        <div key={groupKey}>\n          <header className={styles.tableGroupKey}>\n            <code className={styles.goupKeyText} aria-label={groupKey}>\n              {groupKey}\n            </code>\n          </header>\n          <DynamicTable cols={columns} items={tableItems} pagination={{ itemsPerPage: 25 }} />\n        </div>\n      );\n    });\n\n  return (\n    <div>\n      <nav>\n        <Field\n          label={\n            <Label>\n              <Stack gap={0.5} alignItems=\"center\">\n                <span>Filter group</span>\n                <Tooltip\n                  content={\n                    <div>\n                      Filter each state history group either by exact match or a regular expression, ex:{' '}\n                      <code>{`region=eu-west-1`}</code> or <code>{`/region=us-.+/`}</code>\n                    </div>\n                  }\n                >\n                  <Icon name=\"info-circle\" size=\"sm\" />\n                </Tooltip>\n              </Stack>\n            </Label>\n          }\n        >\n          <Input prefix={<Icon name={'search'} />} onChange={handleTextFilter} placeholder=\"Search\" />\n        </Field>\n      </nav>\n      {tables}\n    </div>\n  );\n};\n\n// group state history by labels\nexport function groupStateByLabels(\n  history: Array<Pick<StateHistoryItem, 'id' | 'newState' | 'text' | 'data' | 'updated'>>\n): StateHistoryMap {\n  const items: StateHistoryRowItem[] = history.map((item) => {\n    // let's grab the last matching set of `{<string>}` since the alert name could also contain { or }\n    const LABELS_REGEX = /{.*?}/g;\n    const stringifiedLabels = item.text.match(LABELS_REGEX)?.at(-1) ?? '';\n\n    return {\n      id: String(item.id),\n      state: item.newState,\n      // let's omit the labels for each entry since it's just added noise to each state history item\n      text: item.text.replace(stringifiedLabels, ''),\n      data: item.data,\n      timestamp: item.updated,\n      stringifiedLabels,\n    };\n  });\n\n  // we have to group our state history items by their unique combination of tags since we want to display a DynamicTable for each alert instance\n  // (effectively unique combination of labels)\n  return groupBy(items, (item) => item.stringifiedLabels);\n}\n\n// match a string either by exact text match or with regular expression when in the form of \"/<regex>/\"\nexport function matchKey(groupKey: string, textFilter: string) {\n  // if the text filter is empty we show all matches\n  if (textFilter === '') {\n    return true;\n  }\n\n  const isRegExp = textFilter.startsWith('/') && textFilter.endsWith('/');\n\n  // not a regular expression, use normal text matching\n  if (!isRegExp) {\n    return groupKey.includes(textFilter);\n  }\n\n  // regular expression, try parsing and applying\n  // when we fail to parse the text as a regular expression, we return no match\n  try {\n    return new RegExp(textFilter.slice(1, -1)).test(groupKey);\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction renderValueCell(item: StateHistoryRow) {\n  const matches = item.data.data?.evalMatches ?? [];\n\n  return (\n    <>\n      {item.data.text}\n      <LabelsWrapper>\n        {matches.map((match) => (\n          <AlertLabel key={match.metric} labelKey={match.metric} value={String(match.value)} />\n        ))}\n      </LabelsWrapper>\n    </>\n  );\n}\n\nfunction renderStateCell(item: StateHistoryRow) {\n  return <AlertStateTag state={item.data.state} />;\n}\n\nfunction renderTimestampCell(item: StateHistoryRow) {\n  return (\n    <div className={TimestampStyle}>{item.data.timestamp && <span>{dateTimeFormat(item.data.timestamp)}</span>}</div>\n  );\n}\n\nconst LabelsWrapper = ({ children }: React.PropsWithChildren<{}>) => {\n  const { wrapper } = useStyles2(getStyles);\n  return <div className={wrapper}>{children}</div>;\n};\n\nconst TimestampStyle = css({\n  display: 'flex',\n  alignItems: 'flex-end',\n  flexDirection: 'column',\n});\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    '& > *': {\n      marginRight: theme.spacing(1),\n    },\n  }),\n  tableGroupKey: css({\n    marginTop: theme.spacing(2),\n    marginBottom: theme.spacing(2),\n  }),\n  goupKeyText: css({\n    overflowX: 'auto',\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n    display: 'block',\n  }),\n});\n\nexport default StateHistory;\n","import { useEffect } from 'react';\n\nimport { useDispatch } from '../../../../types';\nimport { StateHistoryItem } from '../../../../types/unified-alerting';\n\nimport { fetchGrafanaAnnotationsAction } from '../state/actions';\nimport { AsyncRequestState } from '../utils/redux';\n\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\nexport function useManagedAlertStateHistory(alertId: string) {\n  const dispatch = useDispatch();\n  const history = useUnifiedAlertingSelector<AsyncRequestState<StateHistoryItem[]>>(\n    (state) => state.managedAlertStateHistory\n  );\n\n  useEffect(() => {\n    dispatch(fetchGrafanaAnnotationsAction(alertId));\n  }, [dispatch, alertId]);\n\n  return history;\n}\n"],"names":[],"sourceRoot":""}