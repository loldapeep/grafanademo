{"version":3,"file":"xychart2.fa8aae60ce2e66c6e478.js","mappings":"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","sources":["webpack://grafana/./public/app/core/components/Layers/LayerName.tsx","webpack://grafana/./public/app/features/transformers/calculateHeatmap/heatmap.ts","webpack://grafana/./public/app/features/transformers/calculateHeatmap/utils.ts","webpack://grafana/./public/app/plugins/panel/heatmap/utils.ts","webpack://grafana/./public/app/plugins/panel/xychart/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/xychart/v2/SeriesEditor.tsx","webpack://grafana/./public/app/plugins/panel/xychart/v2/XYChartPanel.tsx","webpack://grafana/./public/app/plugins/panel/xychart/v2/XYChartTooltip.tsx","webpack://grafana/./public/app/plugins/panel/xychart/v2/config.ts","webpack://grafana/./public/app/plugins/panel/xychart/v2/migrations.ts","webpack://grafana/./public/app/plugins/panel/xychart/v2/module.tsx","webpack://grafana/./public/app/plugins/panel/xychart/v2/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/xychart/v2/scatter.ts","webpack://grafana/./public/app/plugins/panel/xychart/v2/utils.ts"],"sourcesContent":["import { css, cx } from '@emotion/css';\nimport React, { useState } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { Icon, Input, FieldValidationMessage, useStyles2 } from '@grafana/ui';\n\nexport interface LayerNameProps {\n  name: string;\n  onChange: (v: string) => void;\n  verifyLayerNameUniqueness?: (nameToCheck: string) => boolean;\n  overrideStyles?: boolean;\n}\n\nexport const LayerName = ({ name, onChange, verifyLayerNameUniqueness, overrideStyles }: LayerNameProps) => {\n  const styles = useStyles2(getStyles);\n\n  const [isEditing, setIsEditing] = useState<boolean>(false);\n  const [validationError, setValidationError] = useState<string | null>(null);\n\n  const onEditLayer = (event: React.SyntheticEvent) => {\n    setIsEditing(true);\n  };\n\n  const onEndEditName = (newName: string) => {\n    setIsEditing(false);\n\n    if (validationError) {\n      setValidationError(null);\n      return;\n    }\n\n    if (name !== newName) {\n      onChange(newName);\n    }\n  };\n\n  const onInputChange = (event: React.SyntheticEvent<HTMLInputElement>) => {\n    const newName = event.currentTarget.value.trim();\n\n    if (newName.length === 0) {\n      setValidationError('An empty layer name is not allowed');\n      return;\n    }\n\n    if (verifyLayerNameUniqueness && !verifyLayerNameUniqueness(newName) && newName !== name) {\n      setValidationError('Layer name already exists');\n      return;\n    }\n\n    if (validationError) {\n      setValidationError(null);\n    }\n  };\n\n  const onEditLayerBlur = (event: React.SyntheticEvent<HTMLInputElement>) => {\n    onEndEditName(event.currentTarget.value.trim());\n  };\n\n  const onKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.key === 'Enter') {\n      onEndEditName(event.currentTarget.value);\n    }\n  };\n\n  const onFocus = (event: React.FocusEvent<HTMLInputElement>) => {\n    event.target.select();\n  };\n\n  return (\n    <>\n      <div className={styles.wrapper}>\n        {!isEditing && (\n          <button\n            className={styles.layerNameWrapper}\n            title=\"Edit layer name\"\n            onClick={onEditLayer}\n            data-testid=\"layer-name-div\"\n          >\n            <span className={overrideStyles ? '' : styles.layerName}>{name}</span>\n            <Icon name=\"pen\" className={styles.layerEditIcon} size=\"sm\" />\n          </button>\n        )}\n\n        {isEditing && (\n          <>\n            <Input\n              type=\"text\"\n              defaultValue={name}\n              onBlur={onEditLayerBlur}\n              autoFocus\n              onKeyDown={onKeyDown}\n              onFocus={onFocus}\n              invalid={validationError !== null}\n              onChange={onInputChange}\n              className={styles.layerNameInput}\n              data-testid=\"layer-name-input\"\n            />\n            {validationError && <FieldValidationMessage horizontal>{validationError}</FieldValidationMessage>}\n          </>\n        )}\n      </div>\n    </>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => {\n  return {\n    wrapper: css({\n      label: 'Wrapper',\n      display: 'flex',\n      alignItems: 'center',\n      marginLeft: theme.spacing(0.5),\n    }),\n    layerNameWrapper: css({\n      display: 'flex',\n      cursor: 'pointer',\n      border: '1px solid transparent',\n      borderRadius: theme.shape.radius.default,\n      alignItems: 'center',\n      padding: `0 0 0 ${theme.spacing(0.5)}`,\n      margin: 0,\n      background: 'transparent',\n\n      '&:hover': {\n        background: theme.colors.action.hover,\n        border: `1px dashed ${theme.colors.border.strong}`,\n      },\n\n      '&:focus': {\n        border: `2px solid ${theme.colors.primary.border}`,\n      },\n\n      '&:hover, &:focus': {\n        '.query-name-edit-icon': {\n          visibility: 'visible',\n        },\n      },\n    }),\n    layerName: css({\n      fontWeight: theme.typography.fontWeightMedium,\n      color: theme.colors.primary.text,\n      cursor: 'pointer',\n      overflow: 'hidden',\n      marginLeft: theme.spacing(0.5),\n    }),\n    layerEditIcon: cx(\n      css({\n        marginLeft: theme.spacing(2),\n        visibility: 'hidden',\n      }),\n      'query-name-edit-icon'\n    ),\n    layerNameInput: css({\n      maxWidth: '300px',\n      margin: '-4px 0',\n    }),\n  };\n};\n","import { map } from 'rxjs';\n\nimport {\n  DataFrame,\n  DataTransformerID,\n  FieldType,\n  incrRoundUp,\n  incrRoundDn,\n  SynchronousDataTransformerInfo,\n  DataFrameType,\n  getFieldDisplayName,\n  Field,\n  getValueFormat,\n  formattedValueToString,\n  durationToMilliseconds,\n  parseDuration,\n  TransformationApplicabilityLevels,\n  TimeRange,\n} from '@grafana/data';\nimport { isLikelyAscendingVector } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { config } from '@grafana/runtime';\nimport {\n  ScaleDistribution,\n  HeatmapCellLayout,\n  HeatmapCalculationMode,\n  HeatmapCalculationOptions,\n} from '@grafana/schema';\n\nimport { niceLinearIncrs, niceTimeIncrs } from './utils';\n\nexport interface HeatmapTransformerOptions extends HeatmapCalculationOptions {\n  /** the raw values will still exist in results after transformation */\n  keepOriginalData?: boolean;\n}\n\nexport const heatmapTransformer: SynchronousDataTransformerInfo<HeatmapTransformerOptions> = {\n  id: DataTransformerID.heatmap,\n  name: 'Create heatmap',\n  description: 'Generate heatmap data from source data.',\n  defaultOptions: {},\n  isApplicable: (data) => {\n    const { xField, yField, xs, ys } = findHeatmapFields(data);\n\n    if (xField || yField) {\n      return TransformationApplicabilityLevels.NotPossible;\n    }\n\n    if (!xs.length || !ys.length) {\n      return TransformationApplicabilityLevels.NotPossible;\n    }\n\n    return TransformationApplicabilityLevels.Applicable;\n  },\n  isApplicableDescription:\n    'The Heatmap transformation requires fields with Heatmap compatible data. No fields with Heatmap data could be found.',\n  operator: (options, ctx) => (source) =>\n    source.pipe(\n      map((data) => {\n        if (config.featureToggles.transformationsVariableSupport) {\n          const optionsCopy = {\n            ...options,\n            xBuckets: { ...options.xBuckets } ?? undefined,\n            yBuckets: { ...options.yBuckets } ?? undefined,\n          };\n\n          if (optionsCopy.xBuckets?.value) {\n            optionsCopy.xBuckets.value = ctx.interpolate(optionsCopy.xBuckets.value);\n          }\n\n          if (optionsCopy.yBuckets?.value) {\n            optionsCopy.yBuckets.value = ctx.interpolate(optionsCopy.yBuckets.value);\n          }\n\n          return heatmapTransformer.transformer(optionsCopy, ctx)(data);\n        } else {\n          return heatmapTransformer.transformer(options, ctx)(data);\n        }\n      })\n    ),\n\n  transformer: (options: HeatmapTransformerOptions) => {\n    return (data: DataFrame[]) => {\n      const v = calculateHeatmapFromData(data, options);\n      if (options.keepOriginalData) {\n        return [v, ...data];\n      }\n      return [v];\n    };\n  },\n};\n\nfunction parseNumeric(v?: string | null) {\n  return v === '+Inf' ? Infinity : v === '-Inf' ? -Infinity : +(v ?? 0);\n}\n\nexport function sortAscStrInf(aName?: string | null, bName?: string | null) {\n  return parseNumeric(aName) - parseNumeric(bName);\n}\n\nexport interface HeatmapRowsCustomMeta {\n  /** This provides the lookup values */\n  yOrdinalDisplay: string[];\n  yOrdinalLabel?: string[];\n  yMatchWithLabel?: string;\n  yMinDisplay?: string;\n}\n\n/** simple utility to get heatmap metadata from a frame */\nexport function readHeatmapRowsCustomMeta(frame?: DataFrame): HeatmapRowsCustomMeta {\n  return (frame?.meta?.custom ?? {}) as HeatmapRowsCustomMeta;\n}\n\nexport function isHeatmapCellsDense(frame: DataFrame) {\n  let foundY = false;\n\n  for (let field of frame.fields) {\n    // dense heatmap frames can only have one of these fields\n    switch (field.name) {\n      case 'y':\n      case 'yMin':\n      case 'yMax':\n        if (foundY) {\n          return false;\n        }\n\n        foundY = true;\n    }\n  }\n\n  return foundY;\n}\n\nexport interface RowsHeatmapOptions {\n  frame: DataFrame;\n  value?: string; // the field value name\n  unit?: string;\n  decimals?: number;\n  layout?: HeatmapCellLayout;\n}\n\n/** Given existing buckets, create a values style frame */\n// Assumes frames have already been sorted ASC and de-accumulated.\nexport function rowsToCellsHeatmap(opts: RowsHeatmapOptions): DataFrame {\n  // TODO: handle null-filling w/ fields[0].config.interval?\n  const xField = opts.frame.fields[0];\n  const xValues = xField.values;\n  const yFields = opts.frame.fields.filter((f, idx) => f.type === FieldType.number && idx > 0);\n\n  // similar to initBins() below\n  const len = xValues.length * yFields.length;\n  const xs = new Array(len);\n  const ys = new Array(len);\n  const counts2 = new Array(len);\n\n  const counts = yFields.map((field) => field.values.slice());\n\n  // transpose\n  counts.forEach((bucketCounts, bi) => {\n    for (let i = 0; i < bucketCounts.length; i++) {\n      counts2[counts.length * i + bi] = bucketCounts[i];\n    }\n  });\n\n  const bucketBounds = Array.from({ length: yFields.length }, (v, i) => i);\n\n  // fill flat/repeating array\n  for (let i = 0, yi = 0, xi = 0; i < len; yi = ++i % bucketBounds.length) {\n    ys[i] = bucketBounds[yi];\n\n    if (yi === 0 && i >= bucketBounds.length) {\n      xi++;\n    }\n\n    xs[i] = xValues[xi];\n  }\n\n  // this name determines whether cells are drawn above, below, or centered on the values\n  let ordinalFieldName = yFields[0].labels?.le != null ? 'yMax' : 'y';\n  switch (opts.layout) {\n    case HeatmapCellLayout.le:\n      ordinalFieldName = 'yMax';\n      break;\n    case HeatmapCellLayout.ge:\n      ordinalFieldName = 'yMin';\n      break;\n    case HeatmapCellLayout.unknown:\n      ordinalFieldName = 'y';\n      break;\n  }\n\n  const custom: HeatmapRowsCustomMeta = {\n    yOrdinalDisplay: yFields.map((f) => getFieldDisplayName(f, opts.frame)),\n    yMatchWithLabel: Object.keys(yFields[0].labels ?? {})[0],\n  };\n  if (custom.yMatchWithLabel) {\n    custom.yOrdinalLabel = yFields.map((f) => f.labels?.[custom.yMatchWithLabel!] ?? '');\n    if (custom.yMatchWithLabel === 'le') {\n      custom.yMinDisplay = '0.0';\n    }\n  }\n\n  // Format the labels as a value\n  // TODO: this leaves the internally prepended '0.0' without this formatting treatment\n  if (opts.unit?.length || opts.decimals != null) {\n    const fmt = getValueFormat(opts.unit ?? 'short');\n    if (custom.yMinDisplay) {\n      custom.yMinDisplay = formattedValueToString(fmt(0, opts.decimals));\n    }\n    custom.yOrdinalDisplay = custom.yOrdinalDisplay.map((name) => {\n      let num = +name;\n\n      if (!Number.isNaN(num)) {\n        return formattedValueToString(fmt(num, opts.decimals));\n      }\n\n      return name;\n    });\n  }\n\n  const valueCfg = {\n    ...yFields[0].config,\n  };\n\n  if (valueCfg.displayNameFromDS) {\n    delete valueCfg.displayNameFromDS;\n  }\n\n  return {\n    length: xs.length,\n    refId: opts.frame.refId,\n    meta: {\n      type: DataFrameType.HeatmapCells,\n      custom,\n    },\n    fields: [\n      {\n        name: xField.type === FieldType.time ? 'xMax' : 'x',\n        type: xField.type,\n        values: xs,\n        config: xField.config,\n      },\n      {\n        name: ordinalFieldName,\n        type: FieldType.number,\n        values: ys,\n        config: {\n          unit: 'short', // ordinal lookup\n        },\n      },\n      {\n        name: opts.value?.length ? opts.value : 'Value',\n        type: FieldType.number,\n        values: counts2,\n        config: valueCfg,\n        display: yFields[0].display,\n      },\n    ],\n  };\n}\n\n// Sorts frames ASC by numeric bucket name and de-accumulates values in each frame's Value field [1]\n// similar to Prometheus result_transformer.ts -> transformToHistogramOverTime()\nexport function prepBucketFrames(frames: DataFrame[]): DataFrame[] {\n  frames = frames.slice();\n\n  // sort ASC by frame.name (Prometheus bucket bound)\n  // or use frame.fields[1].config.displayNameFromDS ?\n  frames.sort((a, b) => sortAscStrInf(a.name, b.name));\n\n  // cumulative counts\n  const counts = frames.map((frame) => frame.fields[1].values.slice());\n\n  // de-accumulate\n  counts.reverse();\n  counts.forEach((bucketCounts, bi) => {\n    if (bi < counts.length - 1) {\n      for (let i = 0; i < bucketCounts.length; i++) {\n        bucketCounts[i] -= counts[bi + 1][i];\n      }\n    }\n  });\n  counts.reverse();\n\n  return frames.map((frame, i) => ({\n    ...frame,\n    fields: [\n      frame.fields[0],\n      {\n        ...frame.fields[1],\n        values: counts[i],\n      },\n    ],\n  }));\n}\n\ninterface HeatmapCalculationOptionsWithTimeRange extends HeatmapCalculationOptions {\n  timeRange?: TimeRange;\n}\n\nexport function calculateHeatmapFromData(\n  frames: DataFrame[],\n  options: HeatmapCalculationOptionsWithTimeRange\n): DataFrame {\n  // Find fields in the heatmap\n  const { xField, yField, xs, ys } = findHeatmapFields(frames);\n\n  if (!xField || !yField) {\n    throw 'no heatmap fields found';\n  }\n\n  if (!xs.length || !ys.length) {\n    throw 'no values found';\n  }\n\n  const xBucketsCfg = options.xBuckets ?? {};\n  const yBucketsCfg = options.yBuckets ?? {};\n\n  if (xBucketsCfg.scale?.type === ScaleDistribution.Log) {\n    throw 'X axis only supports linear buckets';\n  }\n\n  const scaleDistribution = options.yBuckets?.scale ?? {\n    type: ScaleDistribution.Linear,\n  };\n\n  const heat2d = heatmap(xs, ys, {\n    xSorted: isLikelyAscendingVector(xs),\n    xTime: xField.type === FieldType.time,\n    xMode: xBucketsCfg.mode,\n    xSize:\n      xBucketsCfg.mode === HeatmapCalculationMode.Size\n        ? durationToMilliseconds(parseDuration(xBucketsCfg.value ?? ''))\n        : xBucketsCfg.value\n          ? +xBucketsCfg.value\n          : undefined,\n    yMode: yBucketsCfg.mode,\n    ySize: yBucketsCfg.value ? +yBucketsCfg.value : undefined,\n    yLog:\n      scaleDistribution?.type === ScaleDistribution.Log ? (scaleDistribution?.log as 2 | 10 | undefined) : undefined,\n\n    xMin: options.timeRange?.from.valueOf(),\n    xMax: options.timeRange?.to.valueOf(),\n  });\n\n  const frame = {\n    length: heat2d.x.length,\n    name: getFieldDisplayName(yField),\n    meta: {\n      type: DataFrameType.HeatmapCells,\n    },\n    fields: [\n      {\n        name: 'xMin',\n        type: xField.type,\n        values: heat2d.x,\n        config: xField.config,\n      },\n      {\n        name: 'yMin',\n        type: FieldType.number,\n        values: heat2d.y,\n        config: {\n          ...yField.config, // keep units from the original source\n          custom: {\n            scaleDistribution,\n          },\n        },\n      },\n      {\n        name: 'Count',\n        type: FieldType.number,\n        values: heat2d.count,\n        config: {\n          unit: 'short', // always integer\n        },\n      },\n    ],\n  };\n\n  return frame;\n}\n\n/**\n * Find fields that can be used within a heatmap\n *\n * @param frames\n *  An array of DataFrames\n */\nfunction findHeatmapFields(frames: DataFrame[]) {\n  let xField: Field | undefined = undefined;\n  let yField: Field | undefined = undefined;\n  let dataLen = 0;\n\n  // pre-allocate arrays\n  for (let frame of frames) {\n    // TODO: assumes numeric timestamps, ordered asc, without nulls\n    const x = frame.fields.find((f) => f.type === FieldType.time);\n    if (x) {\n      dataLen += frame.length;\n    }\n  }\n\n  let xs: number[] = Array(dataLen);\n  let ys: number[] = Array(dataLen);\n  let j = 0;\n\n  for (let frame of frames) {\n    // TODO: assumes numeric timestamps, ordered asc, without nulls\n    const x = frame.fields.find((f) => f.type === FieldType.time);\n    if (!x) {\n      continue;\n    }\n\n    if (!xField) {\n      xField = x; // the first X\n    }\n\n    const xValues = x.values;\n    for (let field of frame.fields) {\n      if (field !== x && field.type === FieldType.number) {\n        const yValues = field.values;\n\n        for (let i = 0; i < xValues.length; i++, j++) {\n          xs[j] = xValues[i];\n          ys[j] = yValues[i];\n        }\n\n        if (!yField) {\n          yField = field;\n        }\n      }\n    }\n  }\n\n  return { xField, yField, xs, ys };\n}\n\ninterface HeatmapOpts {\n  // default is 10% of data range, snapped to a \"nice\" increment\n  xMode?: HeatmapCalculationMode;\n  yMode?: HeatmapCalculationMode;\n  xSize?: number;\n  ySize?: number;\n\n  // use Math.ceil instead of Math.floor for bucketing\n  xCeil?: boolean;\n  yCeil?: boolean;\n\n  // log2 or log10 buckets\n  xLog?: 2 | 10;\n  yLog?: 2 | 10;\n\n  xTime?: boolean;\n  yTime?: boolean;\n\n  // optimization hints for known data ranges (sorted, pre-scanned, etc)\n  xMin?: number;\n  xMax?: number;\n  yMin?: number;\n  yMax?: number;\n\n  xSorted?: boolean;\n  ySorted?: boolean;\n}\n\n// TODO: handle NaN, Inf, -Inf, null, undefined values in xs & ys\nfunction heatmap(xs: number[], ys: number[], opts?: HeatmapOpts) {\n  let len = xs.length;\n\n  let xSorted = opts?.xSorted ?? false;\n  let ySorted = opts?.ySorted ?? false;\n\n  // find x and y limits to pre-compute buckets struct\n  let minX = opts?.xMin ?? (xSorted ? xs[0] : Infinity);\n  let minY = ySorted ? ys[0] : Infinity;\n  let maxX = opts?.xMax ?? (xSorted ? xs[len - 1] : -Infinity);\n  let maxY = ySorted ? ys[len - 1] : -Infinity;\n\n  let yExp = opts?.yLog;\n\n  let withPredefX = opts?.xMin != null && opts?.xMax != null;\n  let withPredefY = opts?.yMin != null && opts?.yMax != null;\n\n  for (let i = 0; i < len; i++) {\n    if (!xSorted && !withPredefX) {\n      minX = Math.min(minX, xs[i]);\n      maxX = Math.max(maxX, xs[i]);\n    }\n\n    if (!ySorted && !withPredefY) {\n      if (!yExp || ys[i] > 0) {\n        minY = Math.min(minY, ys[i]);\n        maxY = Math.max(maxY, ys[i]);\n      }\n    }\n  }\n\n  //let scaleX = opts?.xLog === 10 ? Math.log10 : opts?.xLog === 2 ? Math.log2 : (v: number) => v;\n  //let scaleY = opts?.yLog === 10 ? Math.log10 : opts?.yLog === 2 ? Math.log2 : (v: number) => v;\n\n  let xBinIncr = opts?.xSize ?? 0;\n  let yBinIncr = opts?.ySize ?? 0;\n  let xMode = opts?.xMode;\n  let yMode = opts?.yMode;\n\n  // fall back to 10 buckets if invalid settings\n  if (!Number.isFinite(xBinIncr) || xBinIncr <= 0) {\n    xMode = HeatmapCalculationMode.Count;\n    xBinIncr = 20;\n  }\n  if (!Number.isFinite(yBinIncr) || yBinIncr <= 0) {\n    yMode = HeatmapCalculationMode.Count;\n    yBinIncr = 10;\n  }\n\n  if (xMode === HeatmapCalculationMode.Count) {\n    let approx = (maxX - minX) / Math.max(xBinIncr - 1, 1);\n    // nice-ify\n    let xIncrs = opts?.xTime ? niceTimeIncrs : niceLinearIncrs;\n    let xIncrIdx = xIncrs.findIndex((bucketSize) => bucketSize > approx) - 1;\n    xBinIncr = xIncrs[Math.max(xIncrIdx, 0)];\n  }\n\n  if (yMode === HeatmapCalculationMode.Count) {\n    let approx = (maxY - minY) / Math.max(yBinIncr - 1, 1);\n    // nice-ify\n    let yIncrs = opts?.yTime ? niceTimeIncrs : niceLinearIncrs;\n    let yIncrIdx = yIncrs.findIndex((bucketSize) => bucketSize > approx) - 1;\n    yBinIncr = yIncrs[Math.max(yIncrIdx, 0)];\n  }\n\n  // console.log({\n  //   yBinIncr,\n  //   xBinIncr,\n  // });\n\n  let binX = opts?.xCeil ? (v: number) => incrRoundUp(v, xBinIncr) : (v: number) => incrRoundDn(v, xBinIncr);\n  let binY = opts?.yCeil ? (v: number) => incrRoundUp(v, yBinIncr) : (v: number) => incrRoundDn(v, yBinIncr);\n\n  if (yExp) {\n    yBinIncr = 1 / (opts?.ySize ?? 1); // sub-divides log exponents\n    let yLog = yExp === 2 ? Math.log2 : Math.log10;\n    binY = opts?.yCeil ? (v: number) => incrRoundUp(yLog(v), yBinIncr) : (v: number) => incrRoundDn(yLog(v), yBinIncr);\n  }\n\n  let minXBin = binX(minX);\n  let maxXBin = binX(maxX);\n  let minYBin = binY(minY);\n  let maxYBin = binY(maxY);\n\n  let xBinQty = Math.round((maxXBin - minXBin) / xBinIncr) + 1;\n  let yBinQty = Math.round((maxYBin - minYBin) / yBinIncr) + 1;\n\n  let [xs2, ys2, counts] = initBins(xBinQty, yBinQty, minXBin, xBinIncr, minYBin, yBinIncr, yExp);\n\n  for (let i = 0; i < len; i++) {\n    if (yExp && ys[i] <= 0) {\n      continue;\n    }\n\n    const xi = (binX(xs[i]) - minXBin) / xBinIncr;\n    const yi = (binY(ys[i]) - minYBin) / yBinIncr;\n    const ci = xi * yBinQty + yi;\n\n    counts[ci]++;\n  }\n\n  return {\n    x: xs2,\n    y: ys2,\n    count: counts,\n  };\n}\n\nfunction initBins(xQty: number, yQty: number, xMin: number, xIncr: number, yMin: number, yIncr: number, yExp?: number) {\n  const len = xQty * yQty;\n  const xs = new Array<number>(len);\n  const ys = new Array<number>(len);\n  const counts = new Array<number>(len);\n\n  for (let i = 0, yi = 0, x = xMin; i < len; yi = ++i % yQty) {\n    counts[i] = 0;\n\n    if (yExp) {\n      ys[i] = yExp ** (yMin + yi * yIncr);\n    } else {\n      ys[i] = yMin + yi * yIncr;\n    }\n\n    if (yi === 0 && i >= yQty) {\n      x += xIncr;\n    }\n\n    xs[i] = x;\n  }\n\n  return [xs, ys, counts];\n}\n","import { guessDecimals, roundDecimals } from '@grafana/data';\n\nconst { abs, pow } = Math;\n\nexport const fixedDec = new Map();\n\nexport function genIncrs(base: number, minExp: number, maxExp: number, mults: number[]) {\n  let incrs = [];\n\n  let multDec = mults.map(guessDecimals);\n\n  for (let exp = minExp; exp < maxExp; exp++) {\n    let expa = abs(exp);\n    let mag = roundDecimals(pow(base, exp), expa);\n\n    for (let i = 0; i < mults.length; i++) {\n      let _incr = mults[i] * mag;\n      let dec = (_incr >= 0 && exp >= 0 ? 0 : expa) + (exp >= multDec[i] ? 0 : multDec[i]);\n      let incr = roundDecimals(_incr, dec);\n      incrs.push(incr);\n      fixedDec.set(incr, dec);\n    }\n  }\n\n  return incrs;\n}\n\nconst onlyWhole = (v: number) => v % 1 === 0;\n\nconst allMults = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5];\n\n// ...0.01, 0.02, 0.025, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.2, 0.25, 0.3, 0.4, 0.5...\nexport const decIncrs = genIncrs(10, -16, 0, allMults);\n\n// 1, 2, 2.5, 3, 4, 5, 6, 7, 8, 9, 10, 20, 25, 30, 40, 50...\nexport const oneIncrs = genIncrs(10, 0, 16, allMults);\n\n// 1, 2,      3, 4, 5, 10, 20, 25, 50...\nexport const wholeIncrs = oneIncrs.filter(onlyWhole);\n\nexport const numIncrs = decIncrs.concat(oneIncrs);\n\nexport const niceLinearIncrs = decIncrs.concat(wholeIncrs);\n\nconst sec = 1 * 1e3;\nconst min = 60 * sec;\nconst hour = 60 * min;\nconst day = 24 * hour;\nconst year = 365 * day;\n\n// in milliseconds\nexport const niceTimeIncrs = [\n  1,\n  2,\n  4,\n  5,\n  10,\n  20,\n  25,\n  40,\n  50,\n  100,\n  200,\n  250,\n  400,\n  500,\n\n  sec,\n  2 * sec,\n  4 * sec,\n  5 * sec,\n  10 * sec,\n  15 * sec,\n  20 * sec,\n  30 * sec,\n\n  min,\n  2 * min,\n  4 * min,\n  5 * min,\n  10 * min,\n  15 * min,\n  20 * min,\n  30 * min,\n\n  hour,\n  2 * hour,\n  4 * hour,\n  6 * hour,\n  8 * hour,\n  12 * hour,\n  18 * hour,\n\n  day,\n  2 * day,\n  3 * day,\n  4 * day,\n  5 * day,\n  6 * day,\n  7 * day,\n  10 * day,\n  15 * day,\n  30 * day,\n  45 * day,\n  60 * day,\n  90 * day,\n  180 * day,\n\n  year,\n  2 * year,\n  3 * year,\n  4 * year,\n  5 * year,\n  6 * year,\n  7 * year,\n  8 * year,\n  9 * year,\n  10 * year,\n];\n","import { RefObject } from 'react';\nimport uPlot, { Cursor } from 'uplot';\n\nimport {\n  DataFrameType,\n  formattedValueToString,\n  getValueFormat,\n  GrafanaTheme2,\n  incrRoundDn,\n  incrRoundUp,\n  TimeRange,\n  FieldType,\n} from '@grafana/data';\nimport { AxisPlacement, ScaleDirection, ScaleDistribution, ScaleOrientation, HeatmapCellLayout } from '@grafana/schema';\nimport { UPlotConfigBuilder } from '@grafana/ui';\nimport { isHeatmapCellsDense, readHeatmapRowsCustomMeta } from '../../../features/transformers/calculateHeatmap/heatmap';\n\nimport { pointWithin, Quadtree, Rect } from '../barchart/quadtree';\n\nimport { HeatmapData } from './fields';\nimport { FieldConfig, HeatmapSelectionMode, YAxisConfig } from './types';\n\ninterface PathbuilderOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n  gap?: number | null;\n  hideLE?: number;\n  hideGE?: number;\n  xAlign?: -1 | 0 | 1;\n  yAlign?: -1 | 0 | 1;\n  ySizeDivisor?: number;\n  disp: {\n    fill: {\n      values: (u: uPlot, seriesIndex: number) => number[];\n      index: Array<CanvasRenderingContext2D['fillStyle']>;\n    };\n  };\n}\n\ninterface PointsBuilderOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n}\n\ninterface PrepConfigOpts {\n  dataRef: RefObject<HeatmapData>;\n  theme: GrafanaTheme2;\n  timeZone: string;\n  getTimeRange: () => TimeRange;\n  exemplarColor: string;\n  cellGap?: number | null; // in css pixels\n  hideLE?: number;\n  hideGE?: number;\n  yAxisConfig: YAxisConfig;\n  ySizeDivisor?: number;\n  selectionMode?: HeatmapSelectionMode;\n}\n\nexport function prepConfig(opts: PrepConfigOpts) {\n  const {\n    dataRef,\n    theme,\n    timeZone,\n    getTimeRange,\n    cellGap,\n    hideLE,\n    hideGE,\n    yAxisConfig,\n    ySizeDivisor,\n    selectionMode = HeatmapSelectionMode.X,\n  } = opts;\n\n  const xScaleKey = 'x';\n  let isTime = true;\n\n  if (dataRef.current?.heatmap?.fields[0].type !== FieldType.time) {\n    isTime = false;\n  }\n\n  const pxRatio = devicePixelRatio;\n\n  let heatmapType = dataRef.current?.heatmap?.meta?.type;\n  const exemplarFillColor = theme.visualization.getColorByName(opts.exemplarColor);\n\n  let qt: Quadtree;\n  let hRect: Rect | null;\n\n  let builder = new UPlotConfigBuilder(timeZone);\n\n  builder.addHook('init', (u) => {\n    u.root.querySelectorAll<HTMLElement>('.u-cursor-pt').forEach((el) => {\n      Object.assign(el.style, {\n        borderRadius: '0',\n        border: '1px solid white',\n        background: 'transparent',\n      });\n    });\n  });\n\n  if (isTime) {\n    // this is a tmp hack because in mode: 2, uplot does not currently call scales.x.range() for setData() calls\n    // scales.x.range() typically reads back from drilled-down panelProps.timeRange via getTimeRange()\n    builder.addHook('setData', (u) => {\n      //let [min, max] = (u.scales!.x!.range! as uPlot.Range.Function)(u, 0, 100, xScaleKey);\n\n      let { min: xMin, max: xMax } = u.scales!.x;\n\n      let min = getTimeRange().from.valueOf();\n      let max = getTimeRange().to.valueOf();\n\n      if (xMin !== min || xMax !== max) {\n        queueMicrotask(() => {\n          u.setScale(xScaleKey, { min, max });\n        });\n      }\n    });\n  }\n\n  builder.addHook('drawClear', (u) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s, i) => {\n      if (i > 0) {\n        // @ts-ignore\n        s._paths = null;\n      }\n    });\n  });\n\n  builder.setMode(2);\n\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    // TODO: expand by x bucket size and layout\n    range: (u, dataMin, dataMax) => {\n      if (isTime) {\n        return [getTimeRange().from.valueOf(), getTimeRange().to.valueOf()];\n      } else {\n        if (dataRef.current?.xLayout === HeatmapCellLayout.le) {\n          return [dataMin - dataRef.current?.xBucketSize!, dataMax];\n        } else if (dataRef.current?.xLayout === HeatmapCellLayout.ge) {\n          return [dataMin, dataMax + dataRef.current?.xBucketSize!];\n        } else {\n          let offset = dataRef.current?.xBucketSize! / 2;\n\n          return [dataMin - offset, dataMax + offset];\n        }\n      }\n    },\n  });\n\n  let incrs;\n\n  if (!isTime) {\n    incrs = [];\n\n    for (let i = 0; i < 10; i++) {\n      incrs.push(i * dataRef.current?.xBucketSize!);\n    }\n  }\n\n  builder.addAxis({\n    scaleKey: xScaleKey,\n    placement: AxisPlacement.Bottom,\n    incrs,\n    isTime,\n    theme: theme,\n    timeZone,\n  });\n\n  const yField = dataRef.current?.heatmap?.fields[1]!;\n  if (!yField) {\n    return builder; // early abort (avoids error)\n  }\n\n  const yFieldConfig: FieldConfig | undefined = yField.config?.custom;\n  const yScale = yFieldConfig?.scaleDistribution ?? { type: ScaleDistribution.Linear };\n  const yAxisReverse = Boolean(yAxisConfig.reverse);\n  const isSparseHeatmap = heatmapType === DataFrameType.HeatmapCells && !isHeatmapCellsDense(dataRef.current?.heatmap!);\n  const shouldUseLogScale = yScale.type !== ScaleDistribution.Linear || isSparseHeatmap;\n  const isOrdinalY = readHeatmapRowsCustomMeta(dataRef.current?.heatmap).yOrdinalDisplay != null;\n\n  // random to prevent syncing y in other heatmaps\n  // TODO: try to match TimeSeries y keygen algo to sync with TimeSeries panels (when not isOrdinalY)\n  const yScaleKey = 'y_' + (Math.random() + 1).toString(36).substring(7);\n\n  builder.addScale({\n    scaleKey: yScaleKey,\n    isTime: false,\n    // distribution: ScaleDistribution.Ordinal, // does not work with facets/scatter yet\n    orientation: ScaleOrientation.Vertical,\n    direction: yAxisReverse ? ScaleDirection.Down : ScaleDirection.Up,\n    // should be tweakable manually\n    distribution: shouldUseLogScale ? ScaleDistribution.Log : ScaleDistribution.Linear,\n    log: yScale.log ?? 2,\n    range:\n      // sparse already accounts for le/ge by explicit yMin & yMax cell bounds, so no need to expand y range\n      isSparseHeatmap\n        ? (u, dataMin, dataMax) => {\n            // ...but uPlot currently only auto-ranges from the yMin facet data, so we have to grow by 1 extra factor\n            // @ts-ignore\n            let bucketFactor = u.data[1][2][0] / u.data[1][1][0];\n\n            dataMax *= bucketFactor;\n\n            let scaleMin: number | null, scaleMax: number | null;\n\n            [scaleMin, scaleMax] = shouldUseLogScale\n              ? uPlot.rangeLog(dataMin, dataMax, (yScale.log ?? 2) as unknown as uPlot.Scale.LogBase, true)\n              : [dataMin, dataMax];\n\n            if (shouldUseLogScale && !isOrdinalY) {\n              let yExp = u.scales[yScaleKey].log!;\n              let log = yExp === 2 ? Math.log2 : Math.log10;\n\n              let { min: explicitMin, max: explicitMax } = yAxisConfig;\n\n              // guard against <= 0\n              if (explicitMin != null && explicitMin > 0) {\n                // snap to magnitude\n                let minLog = log(explicitMin);\n                scaleMin = yExp ** incrRoundDn(minLog, 1);\n              }\n\n              if (explicitMax != null && explicitMax > 0) {\n                let maxLog = log(explicitMax);\n                scaleMax = yExp ** incrRoundUp(maxLog, 1);\n              }\n            }\n\n            return [scaleMin, scaleMax];\n          }\n        : // dense and ordinal only have one of yMin|yMax|y, so expand range by one cell in the direction of le/ge/unknown\n          (u, dataMin, dataMax) => {\n            let scaleMin = dataMin,\n              scaleMax = dataMax;\n\n            let { min: explicitMin, max: explicitMax } = yAxisConfig;\n\n            // logarithmic expansion\n            if (shouldUseLogScale) {\n              let yExp = u.scales[yScaleKey].log!;\n\n              let minExpanded = false;\n              let maxExpanded = false;\n\n              let log = yExp === 2 ? Math.log2 : Math.log10;\n\n              if (ySizeDivisor !== 1) {\n                let minLog = log(dataMin);\n                let maxLog = log(dataMax);\n\n                if (!Number.isInteger(minLog)) {\n                  scaleMin = yExp ** incrRoundDn(minLog, 1);\n                  minExpanded = true;\n                }\n\n                if (!Number.isInteger(maxLog)) {\n                  scaleMax = yExp ** incrRoundUp(maxLog, 1);\n                  maxExpanded = true;\n                }\n              }\n\n              if (dataRef.current?.yLayout === HeatmapCellLayout.le) {\n                if (!minExpanded) {\n                  scaleMin /= yExp;\n                }\n              } else if (dataRef.current?.yLayout === HeatmapCellLayout.ge) {\n                if (!maxExpanded) {\n                  scaleMax *= yExp;\n                }\n              } else {\n                scaleMin /= yExp / 2;\n                scaleMax *= yExp / 2;\n              }\n\n              if (!isOrdinalY) {\n                // guard against <= 0\n                if (explicitMin != null && explicitMin > 0) {\n                  // snap down to magnitude\n                  let minLog = log(explicitMin);\n                  scaleMin = yExp ** incrRoundDn(minLog, 1);\n                }\n\n                if (explicitMax != null && explicitMax > 0) {\n                  let maxLog = log(explicitMax);\n                  scaleMax = yExp ** incrRoundUp(maxLog, 1);\n                }\n              }\n            }\n            // linear expansion\n            else {\n              let bucketSize = dataRef.current?.yBucketSize;\n\n              if (bucketSize === 0) {\n                bucketSize = 1;\n              }\n\n              if (bucketSize) {\n                if (dataRef.current?.yLayout === HeatmapCellLayout.le) {\n                  scaleMin -= bucketSize!;\n                } else if (dataRef.current?.yLayout === HeatmapCellLayout.ge) {\n                  scaleMax += bucketSize!;\n                } else {\n                  scaleMin -= bucketSize! / 2;\n                  scaleMax += bucketSize! / 2;\n                }\n              } else {\n                // how to expand scale range if inferred non-regular or log buckets?\n              }\n\n              if (!isOrdinalY) {\n                scaleMin = explicitMin ?? scaleMin;\n                scaleMax = explicitMax ?? scaleMax;\n              }\n            }\n\n            return [scaleMin, scaleMax];\n          },\n  });\n\n  const dispY = yField.display ?? getValueFormat('short');\n\n  builder.addAxis({\n    scaleKey: yScaleKey,\n    show: yAxisConfig.axisPlacement !== AxisPlacement.Hidden,\n    placement: yAxisConfig.axisPlacement || AxisPlacement.Left,\n    size: yAxisConfig.axisWidth || null,\n    label: yAxisConfig.axisLabel,\n    theme: theme,\n    formatValue: (v, decimals) => formattedValueToString(dispY(v, decimals)),\n    splits: isOrdinalY\n      ? (self: uPlot) => {\n          const meta = readHeatmapRowsCustomMeta(dataRef.current?.heatmap);\n          if (!meta.yOrdinalDisplay) {\n            return [0, 1]; //?\n          }\n          let splits = meta.yOrdinalDisplay.map((v, idx) => idx);\n\n          switch (dataRef.current?.yLayout) {\n            case HeatmapCellLayout.le:\n              splits.unshift(-1);\n              break;\n            case HeatmapCellLayout.ge:\n              splits.push(splits.length);\n              break;\n          }\n\n          // Skip labels when the height is too small\n          if (self.height < 60) {\n            splits = [splits[0], splits[splits.length - 1]];\n          } else {\n            while (splits.length > 3 && (self.height - 15) / splits.length < 10) {\n              splits = splits.filter((v, idx) => idx % 2 === 0); // remove half the items\n            }\n          }\n          return splits;\n        }\n      : undefined,\n    values: isOrdinalY\n      ? (self: uPlot, splits) => {\n          const meta = readHeatmapRowsCustomMeta(dataRef.current?.heatmap);\n          if (meta.yOrdinalDisplay) {\n            return splits.map((v) =>\n              v < 0\n                ? meta.yMinDisplay ?? '' // Check prometheus style labels\n                : meta.yOrdinalDisplay[v] ?? ''\n            );\n          }\n          return splits;\n        }\n      : undefined,\n  });\n\n  const pathBuilder = isSparseHeatmap ? heatmapPathsSparse : heatmapPathsDense;\n\n  // heatmap layer\n  builder.addSeries({\n    facets: [\n      {\n        scale: xScaleKey,\n        auto: true,\n        sorted: 1,\n      },\n      {\n        scale: yScaleKey,\n        auto: true,\n      },\n    ],\n    pathBuilder: pathBuilder({\n      each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n        qt.add({\n          x: x - u.bbox.left,\n          y: y - u.bbox.top,\n          w: xSize,\n          h: ySize,\n          sidx: seriesIdx,\n          didx: dataIdx,\n        });\n      },\n      gap: cellGap,\n      hideLE,\n      hideGE,\n      xAlign:\n        dataRef.current?.xLayout === HeatmapCellLayout.le\n          ? -1\n          : dataRef.current?.xLayout === HeatmapCellLayout.ge\n            ? 1\n            : 0,\n      yAlign: ((dataRef.current?.yLayout === HeatmapCellLayout.le\n        ? -1\n        : dataRef.current?.yLayout === HeatmapCellLayout.ge\n          ? 1\n          : 0) * (yAxisReverse ? -1 : 1)) as -1 | 0 | 1,\n      ySizeDivisor,\n      disp: {\n        fill: {\n          values: (u, seriesIdx) => dataRef.current?.heatmapColors?.values!,\n          index: dataRef.current?.heatmapColors?.palette!,\n        },\n      },\n    }),\n    theme,\n    scaleKey: '', // facets' scales used (above)\n  });\n\n  // exemplars layer\n  builder.addSeries({\n    facets: [\n      {\n        scale: xScaleKey,\n        auto: true,\n        sorted: 1,\n      },\n      {\n        scale: yScaleKey,\n        auto: true,\n      },\n    ],\n    pathBuilder: heatmapPathsPoints(\n      {\n        each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n          qt.add({\n            x: x - u.bbox.left,\n            y: y - u.bbox.top,\n            w: xSize,\n            h: ySize,\n            sidx: seriesIdx,\n            didx: dataIdx,\n          });\n        },\n      },\n      exemplarFillColor,\n      dataRef.current.yLayout\n    ),\n    theme,\n    scaleKey: '', // facets' scales used (above)\n  });\n\n  const dragX = selectionMode === HeatmapSelectionMode.X || selectionMode === HeatmapSelectionMode.Xy;\n  const dragY = selectionMode === HeatmapSelectionMode.Y || selectionMode === HeatmapSelectionMode.Xy;\n\n  const cursor: Cursor = {\n    drag: {\n      x: dragX,\n      y: dragY,\n      setScale: false,\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n\n        let cx = u.cursor.left! * pxRatio;\n        let cy = u.cursor.top! * pxRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = o;\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hRect?.sidx === seriesIdx ? 0 : Infinity),\n    },\n    points: {\n      fill: 'rgba(255,255,255, 0.3)',\n      bbox: (u, seriesIdx) => {\n        let isHovered = hRect && seriesIdx === hRect.sidx;\n\n        return {\n          left: isHovered ? hRect!.x / pxRatio : -10,\n          top: isHovered ? hRect!.y / pxRatio : -10,\n          width: isHovered ? hRect!.w / pxRatio : 0,\n          height: isHovered ? hRect!.h / pxRatio : 0,\n        };\n      },\n    },\n  };\n\n  builder.setCursor(cursor);\n\n  return builder;\n}\n\nconst CRISP_EDGES_GAP_MIN = 4;\n\nexport function heatmapPathsDense(opts: PathbuilderOpts) {\n  const { disp, each, gap = 1, hideLE = -Infinity, hideGE = Infinity, xAlign = 1, yAlign = 1, ySizeDivisor = 1 } = opts;\n\n  const pxRatio = devicePixelRatio;\n\n  const round = gap! >= CRISP_EDGES_GAP_MIN ? Math.round : (v: number) => v;\n\n  const cellGap = Math.round(gap! * pxRatio);\n\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        let d = u.data[seriesIdx];\n        const xs = d[0] as unknown as number[];\n        const ys = d[1] as unknown as number[];\n        const counts = d[2] as unknown as number[];\n        const dlen = xs.length;\n\n        // fill colors are mapped from interpolating densities / counts along some gradient\n        // (should be quantized to 64 colors/levels max. e.g. 16)\n        let fills = disp.fill.values(u, seriesIdx);\n        let fillPalette = disp.fill.index ?? [...new Set(fills)];\n\n        let fillPaths = fillPalette.map((color) => new Path2D());\n\n        // detect x and y bin qtys by detecting layout repetition in x & y data\n        let yBinQty = dlen - ys.lastIndexOf(ys[0]);\n        let xBinQty = dlen / yBinQty;\n        let yBinIncr = ys[1] - ys[0] || scaleY.max! - scaleY.min!;\n        let xBinIncr = xs[yBinQty] - xs[0];\n\n        // uniform tile sizes based on zoom level\n        let xSize: number;\n        let ySize: number;\n\n        if (scaleX.distr === 3) {\n          xSize = Math.abs(valToPosX(xs[0] * scaleX.log!, scaleX, xDim, xOff) - valToPosX(xs[0], scaleX, xDim, xOff));\n        } else {\n          xSize = Math.abs(valToPosX(xBinIncr, scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff));\n        }\n\n        if (scaleY.distr === 3) {\n          ySize =\n            Math.abs(valToPosY(ys[0] * scaleY.log!, scaleY, yDim, yOff) - valToPosY(ys[0], scaleY, yDim, yOff)) /\n            ySizeDivisor;\n        } else {\n          ySize = Math.abs(valToPosY(yBinIncr, scaleY, yDim, yOff) - valToPosY(0, scaleY, yDim, yOff)) / ySizeDivisor;\n        }\n\n        // clamp min tile size to 1px\n        xSize = Math.max(1, round(xSize - cellGap));\n        ySize = Math.max(1, round(ySize - cellGap));\n\n        // bucket agg direction\n        // let xCeil = false;\n        // let yCeil = false;\n\n        let xOffset = xAlign === -1 ? -xSize : xAlign === 0 ? -xSize / 2 : 0;\n        let yOffset = yAlign === 1 ? -ySize : yAlign === 0 ? -ySize / 2 : 0;\n\n        // pre-compute x and y offsets\n        let cys = ys.slice(0, yBinQty).map((y) => round(valToPosY(y, scaleY, yDim, yOff) + yOffset));\n        let cxs = Array.from({ length: xBinQty }, (v, i) =>\n          round(valToPosX(xs[i * yBinQty], scaleX, xDim, xOff) + xOffset)\n        );\n\n        for (let i = 0; i < dlen; i++) {\n          if (counts[i] > hideLE && counts[i] < hideGE) {\n            let cx = cxs[~~(i / yBinQty)];\n            let cy = cys[i % yBinQty];\n\n            let fillPath = fillPaths[fills[i]];\n\n            rect(fillPath, cx, cy, xSize, ySize);\n\n            each(u, 1, i, cx, cy, xSize, ySize);\n          }\n        }\n\n        u.ctx.save();\n        //\tu.ctx.globalAlpha = 0.8;\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n\n        return null;\n      }\n    );\n\n    return null;\n  };\n}\n\nexport function heatmapPathsPoints(opts: PointsBuilderOpts, exemplarColor: string, yLayout?: HeatmapCellLayout) {\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        //console.time('heatmapPathsSparse');\n\n        let points = new Path2D();\n        let fillPaths = [points];\n        let fillPalette = [exemplarColor ?? 'rgba(255,0,255,0.7)'];\n\n        let yShift = yLayout === HeatmapCellLayout.le ? -0.5 : yLayout === HeatmapCellLayout.ge ? 0.5 : 0;\n\n        for (let i = 0; i < dataX.length; i++) {\n          let yVal = dataY[i]!;\n\n          // this is a hacky by-proxy check\n          // works okay since we have no exemplars in calculated heatmaps and...\n          //  - heatmap-rows has ordinal y\n          //  - heatmap-cells has log2 y\n          let isSparseHeatmap = scaleY.distr === 3 && scaleY.log === 2;\n\n          if (!isSparseHeatmap) {\n            yVal += yShift;\n          }\n\n          let x = valToPosX(dataX[i], scaleX, xDim, xOff);\n          let y = valToPosY(yVal, scaleY, yDim, yOff);\n          let w = 8;\n          let h = 8;\n\n          rect(points, x - w / 2, y - h / 2, w, h);\n\n          opts.each(u, seriesIdx, i, x - w / 2, y - h / 2, w, h);\n        }\n\n        u.ctx.save();\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n      }\n    );\n\n    return null;\n  };\n}\n// accepts xMax, yMin, yMax, count\n// xbinsize? x tile sizes are uniform?\nexport function heatmapPathsSparse(opts: PathbuilderOpts) {\n  const { disp, each, gap = 1, hideLE = -Infinity, hideGE = Infinity } = opts;\n\n  const pxRatio = devicePixelRatio;\n\n  const round = gap! >= CRISP_EDGES_GAP_MIN ? Math.round : (v: number) => v;\n\n  const cellGap = Math.round(gap! * pxRatio);\n\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        //console.time('heatmapPathsSparse');\n\n        let d = u.data[seriesIdx];\n        const xMaxs = d[0] as unknown as number[]; // xMax, do we get interval?\n        const yMins = d[1] as unknown as number[];\n        const yMaxs = d[2] as unknown as number[];\n        const counts = d[3] as unknown as number[];\n        const dlen = xMaxs.length;\n\n        // fill colors are mapped from interpolating densities / counts along some gradient\n        // (should be quantized to 64 colors/levels max. e.g. 16)\n        let fills = disp.fill.values(u, seriesIdx);\n        let fillPalette = disp.fill.index ?? [...new Set(fills)];\n\n        let fillPaths = fillPalette.map((color) => new Path2D());\n\n        // cache all tile bounds\n        let xOffs = new Map();\n        let yOffs = new Map();\n\n        for (let i = 0; i < xMaxs.length; i++) {\n          let xMax = xMaxs[i];\n          let yMin = yMins[i];\n          let yMax = yMaxs[i];\n\n          if (!xOffs.has(xMax)) {\n            xOffs.set(xMax, round(valToPosX(xMax, scaleX, xDim, xOff)));\n          }\n\n          if (!yOffs.has(yMin)) {\n            yOffs.set(yMin, round(valToPosY(yMin, scaleY, yDim, yOff)));\n          }\n\n          if (!yOffs.has(yMax)) {\n            yOffs.set(yMax, round(valToPosY(yMax, scaleY, yDim, yOff)));\n          }\n        }\n\n        // uniform x size (interval, step)\n        let xSizeUniform = xOffs.get(xMaxs.find((v) => v !== xMaxs[0])) - xOffs.get(xMaxs[0]);\n\n        for (let i = 0; i < dlen; i++) {\n          if (counts[i] <= hideLE || counts[i] >= hideGE) {\n            continue;\n          }\n\n          let xMax = xMaxs[i];\n          let yMin = yMins[i];\n          let yMax = yMaxs[i];\n\n          let xMaxPx = xOffs.get(xMax); // xSize is from interval, or inferred delta?\n          let yMinPx = yOffs.get(yMin);\n          let yMaxPx = yOffs.get(yMax);\n\n          let xSize = xSizeUniform;\n          let ySize = yMinPx - yMaxPx;\n\n          // clamp min tile size to 1px\n          xSize = Math.max(1, xSize - cellGap);\n          ySize = Math.max(1, ySize - cellGap);\n\n          let x = xMaxPx - cellGap / 2 - xSize;\n          let y = yMaxPx + cellGap / 2;\n\n          let fillPath = fillPaths[fills[i]];\n\n          rect(fillPath, x, y, xSize, ySize);\n\n          each(u, 1, i, x, y, xSize, ySize);\n        }\n\n        u.ctx.save();\n        //\tu.ctx.globalAlpha = 0.8;\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n\n        //console.timeEnd('heatmapPathsSparse');\n      }\n    );\n\n    return null;\n  };\n}\n\nexport const boundedMinMax = (\n  values: number[],\n  minValue?: number,\n  maxValue?: number,\n  hideLE = -Infinity,\n  hideGE = Infinity\n) => {\n  if (minValue == null) {\n    minValue = Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] > hideLE && values[i] < hideGE) {\n        minValue = Math.min(minValue, values[i]);\n      }\n    }\n  }\n\n  if (maxValue == null) {\n    maxValue = -Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] > hideLE && values[i] < hideGE) {\n        maxValue = Math.max(maxValue, values[i]);\n      }\n    }\n  }\n\n  return [minValue, maxValue];\n};\n\nexport const valuesToFills = (values: number[], palette: string[], minValue: number, maxValue: number): number[] => {\n  let range = maxValue - minValue || 1;\n\n  let paletteSize = palette.length;\n\n  let indexedFills = Array(values.length);\n\n  for (let i = 0; i < values.length; i++) {\n    indexedFills[i] =\n      values[i] < minValue\n        ? 0\n        : values[i] > maxValue\n          ? paletteSize - 1\n          : Math.min(paletteSize - 1, Math.floor((paletteSize * (values[i] - minValue)) / range));\n  }\n\n  return indexedFills;\n};\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\n/**\n * Auto is \"table\" in the UI\n */\nexport enum SeriesMapping {\n  Auto = 'auto',\n  Manual = 'manual',\n}\n\nexport enum ScatterShow {\n  Lines = 'lines',\n  Points = 'points',\n  PointsAndLines = 'points+lines',\n}\n\n/**\n * Configuration for the Table/Auto mode\n */\nexport interface XYDimensionConfig {\n  exclude?: Array<string>;\n  frame: number;\n  x?: string;\n}\n\nexport const defaultXYDimensionConfig: Partial<XYDimensionConfig> = {\n  exclude: [],\n};\n\nexport interface FieldConfig extends common.HideableFieldConfig, common.AxisConfig {\n  label?: common.VisibilityMode;\n  labelValue?: common.TextDimensionConfig;\n  lineColor?: common.ColorDimensionConfig;\n  lineStyle?: common.LineStyle;\n  lineWidth?: number;\n  pointColor?: common.ColorDimensionConfig;\n  pointSize?: common.ScaleDimensionConfig;\n  show?: ScatterShow;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  label: common.VisibilityMode.Auto,\n  show: ScatterShow.Points,\n};\n\nexport interface ScatterSeriesConfig extends FieldConfig {\n  frame?: number;\n  name?: string;\n  x?: string;\n  y?: string;\n}\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip {\n  /**\n   * Table Mode (auto)\n   */\n  dims: XYDimensionConfig;\n  /**\n   * Manual Mode\n   */\n  series: Array<ScatterSeriesConfig>;\n  seriesMapping?: SeriesMapping;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  series: [],\n};\n","import { css, cx } from '@emotion/css';\nimport React, { Fragment, useState } from 'react';\nimport { usePrevious } from 'react-use';\n\nimport {\n  getFrameDisplayName,\n  StandardEditorProps,\n  // getFieldDisplayName,\n  FrameMatcherID,\n  FieldMatcherID,\n  FieldNamePickerBaseNameMode,\n  FieldType,\n  GrafanaTheme2,\n} from '@grafana/data';\nimport { Button, Field, IconButton, Select, useStyles2 } from '@grafana/ui';\nimport { FieldNamePicker } from '@grafana/ui/src/components/MatchersUI/FieldNamePicker';\nimport { LayerName } from '../../../../core/components/Layers/LayerName';\n\nimport { Options, SeriesMapping, XYSeriesConfig } from './panelcfg.gen';\n\nexport const SeriesEditor = ({\n  value: seriesCfg,\n  onChange,\n  context,\n}: StandardEditorProps<XYSeriesConfig[], unknown, Options>) => {\n  const style = useStyles2(getStyles);\n\n  // reset opts when mapping changes (no way to do this in panel opts builder?)\n  const mapping = context.options?.mapping as SeriesMapping;\n  const prevMapping = usePrevious(mapping);\n  const mappingChanged = prevMapping != null && mapping !== prevMapping;\n\n  const defaultFrame = { frame: { matcher: { id: FrameMatcherID.byIndex, options: 0 } } };\n  const [selectedIdx, setSelectedIdx] = useState(0);\n\n  if (mappingChanged || seriesCfg == null) {\n    seriesCfg = [{ ...defaultFrame }];\n    onChange([...seriesCfg]);\n\n    if (selectedIdx > 0) {\n      setSelectedIdx(0);\n    }\n  }\n\n  const addSeries = () => {\n    seriesCfg = seriesCfg.concat({ ...defaultFrame });\n    setSelectedIdx(seriesCfg.length - 1);\n    onChange([...seriesCfg]);\n  };\n\n  const deleteSeries = (index: number) => {\n    seriesCfg = seriesCfg.filter((s, i) => i !== index);\n    setSelectedIdx(0);\n    onChange([...seriesCfg]);\n  };\n\n  const series = seriesCfg[selectedIdx];\n  const formKey = `${mapping}${selectedIdx}`;\n\n  const baseNameMode =\n    mapping === SeriesMapping.Manual\n      ? FieldNamePickerBaseNameMode.ExcludeBaseNames\n      : context.data.length === 1\n        ? FieldNamePickerBaseNameMode.IncludeAll\n        : FieldNamePickerBaseNameMode.OnlyBaseNames;\n\n  context.data.forEach((frame, frameIndex) => {\n    frame.fields.forEach((field, fieldIndex) => {\n      field.state = {\n        ...field.state,\n        origin: {\n          frameIndex,\n          fieldIndex,\n        },\n      };\n    });\n  });\n\n  return (\n    <>\n      {mapping === SeriesMapping.Manual && (\n        <>\n          <Button icon=\"plus\" size=\"sm\" variant=\"secondary\" onClick={addSeries} className={style.marginBot}>\n            Add series\n          </Button>\n\n          <div className={style.marginBot}>\n            {seriesCfg.map((series, index) => {\n              return (\n                <div\n                  key={`series/${index}`}\n                  className={index === selectedIdx ? `${style.row} ${style.sel}` : style.row}\n                  onClick={() => setSelectedIdx(index)}\n                  role=\"button\"\n                  aria-label={`Select series ${index + 1}`}\n                  tabIndex={0}\n                  onKeyPress={(e) => {\n                    if (e.key === 'Enter') {\n                      setSelectedIdx(index);\n                    }\n                  }}\n                >\n                  <LayerName\n                    name={series.name?.fixed ?? `Series ${index + 1}`}\n                    onChange={(v) => {\n                      series.name = {\n                        fixed: v === '' || v === `Series ${index + 1}` ? undefined : v,\n                      };\n                      onChange([...seriesCfg]);\n                    }}\n                  />\n                  <IconButton\n                    name=\"trash-alt\"\n                    title={'remove'}\n                    className={cx(style.actionIcon)}\n                    onClick={() => deleteSeries(index)}\n                    tooltip=\"Delete series\"\n                  />\n                </div>\n              );\n            })}\n          </div>\n        </>\n      )}\n\n      {selectedIdx >= 0 && series != null && (\n        <Fragment key={formKey}>\n          <Field label=\"Frame\">\n            <Select\n              placeholder={mapping === SeriesMapping.Auto ? 'All frames' : 'Select frame'}\n              isClearable={true}\n              options={context.data.map((frame, index) => ({\n                value: index,\n                label: `${getFrameDisplayName(frame, index)} (index: ${index}, rows: ${frame.length})`,\n              }))}\n              value={series.frame?.matcher.options}\n              onChange={(opt) => {\n                if (opt == null) {\n                  delete series.frame;\n                } else {\n                  series.frame = {\n                    matcher: {\n                      id: FrameMatcherID.byIndex,\n                      options: Number(opt.value),\n                    },\n                  };\n                }\n\n                onChange([...seriesCfg]);\n              }}\n            />\n          </Field>\n          <Field label=\"X field\">\n            <FieldNamePicker\n              value={series.x?.matcher.options as string}\n              context={context}\n              onChange={(fieldName) => {\n                if (fieldName == null) {\n                  delete series.x;\n                } else {\n                  // TODO: reset any other dim that was set to fieldName\n                  series.x = {\n                    matcher: {\n                      id: FieldMatcherID.byName,\n                      options: fieldName,\n                    },\n                  };\n                }\n\n                onChange([...seriesCfg]);\n              }}\n              item={{\n                id: 'x',\n                name: 'x',\n                settings: {\n                  filter: (field) =>\n                    (mapping === SeriesMapping.Auto ||\n                      field.state?.origin?.frameIndex === series.frame?.matcher.options) &&\n                    field.type === FieldType.number &&\n                    !field.config.custom?.hideFrom?.viz,\n                  baseNameMode,\n                  placeholderText: mapping === SeriesMapping.Auto ? 'First number field in each frame' : undefined,\n                },\n              }}\n            />\n          </Field>\n          <Field label=\"Y field\">\n            <FieldNamePicker\n              value={series.y?.matcher?.options as string}\n              context={context}\n              onChange={(fieldName) => {\n                if (fieldName == null) {\n                  delete series.y;\n                } else {\n                  // TODO: reset any other dim that was set to fieldName\n                  series.y = {\n                    matcher: {\n                      id: FieldMatcherID.byName,\n                      options: fieldName,\n                    },\n                  };\n                }\n\n                onChange([...seriesCfg]);\n              }}\n              item={{\n                id: 'y',\n                name: 'y',\n                settings: {\n                  // TODO: filter out series.y?.exclude.options, series.size.matcher.options, series.color.matcher.options\n                  filter: (field) =>\n                    (mapping === SeriesMapping.Auto ||\n                      field.state?.origin?.frameIndex === series.frame?.matcher.options) &&\n                    field.type === FieldType.number &&\n                    !field.config.custom?.hideFrom?.viz,\n                  baseNameMode,\n                  placeholderText: mapping === SeriesMapping.Auto ? 'Remaining number fields in each frame' : undefined,\n                },\n              }}\n            />\n          </Field>\n          <Field label=\"Size field\">\n            <FieldNamePicker\n              value={series.size?.matcher?.options as string}\n              context={context}\n              onChange={(fieldName) => {\n                if (fieldName == null) {\n                  delete series.size;\n                } else {\n                  // TODO: reset any other dim that was set to fieldName\n                  series.size = {\n                    matcher: {\n                      id: FieldMatcherID.byName,\n                      options: fieldName,\n                    },\n                  };\n                }\n\n                onChange([...seriesCfg]);\n              }}\n              item={{\n                id: 'size',\n                name: 'size',\n                settings: {\n                  // TODO: filter out series.y?.exclude.options, series.size.matcher.options, series.color.matcher.options\n                  filter: (field) =>\n                    field.name !== series.x?.matcher.options &&\n                    (mapping === SeriesMapping.Auto ||\n                      field.state?.origin?.frameIndex === series.frame?.matcher.options) &&\n                    field.type === FieldType.number &&\n                    !field.config.custom?.hideFrom?.viz,\n                  baseNameMode,\n                  placeholderText: '',\n                },\n              }}\n            />\n          </Field>\n          <Field label=\"Color field\">\n            <FieldNamePicker\n              value={series.color?.matcher?.options as string}\n              context={context}\n              onChange={(fieldName) => {\n                if (fieldName == null) {\n                  delete series.color;\n                } else {\n                  // TODO: reset any other dim that was set to fieldName\n                  series.color = {\n                    matcher: {\n                      id: FieldMatcherID.byName,\n                      options: fieldName,\n                    },\n                  };\n                }\n\n                onChange([...seriesCfg]);\n              }}\n              item={{\n                id: 'color',\n                name: 'color',\n                settings: {\n                  // TODO: filter out series.y?.exclude.options, series.size.matcher.options, series.color.matcher.options\n                  filter: (field) =>\n                    field.name !== series.x?.matcher.options &&\n                    (mapping === SeriesMapping.Auto ||\n                      field.state?.origin?.frameIndex === series.frame?.matcher.options) &&\n                    field.type === FieldType.number &&\n                    !field.config.custom?.hideFrom?.viz,\n                  baseNameMode,\n                  placeholderText: '',\n                },\n              }}\n            />\n          </Field>\n        </Fragment>\n      )}\n    </>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  marginBot: css({\n    marginBottom: '20px',\n  }),\n  row: css({\n    padding: `${theme.spacing(0.5, 1)}`,\n    borderRadius: `${theme.shape.radius.default}`,\n    background: `${theme.colors.background.secondary}`,\n    minHeight: `${theme.spacing(4)}`,\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: '3px',\n    cursor: 'pointer',\n\n    border: `1px solid ${theme.components.input.borderColor}`,\n    '&:hover': {\n      border: `1px solid ${theme.components.input.borderHover}`,\n    },\n  }),\n  sel: css({\n    border: `1px solid ${theme.colors.primary.border}`,\n    '&:hover': {\n      border: `1px solid ${theme.colors.primary.border}`,\n    },\n  }),\n  actionIcon: css({\n    color: `${theme.colors.text.secondary}`,\n    '&:hover': {\n      color: `${theme.colors.text}`,\n    },\n  }),\n});\n","import { css } from '@emotion/css';\nimport React, { useMemo } from 'react';\n\nimport { FALLBACK_COLOR, PanelProps } from '@grafana/data';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { config } from '@grafana/runtime';\nimport {\n  TooltipDisplayMode,\n  TooltipPlugin2,\n  UPlotChart,\n  VizLayout,\n  VizLegend,\n  VizLegendItem,\n  useStyles2,\n  useTheme2,\n} from '@grafana/ui';\nimport { TooltipHoverMode } from '@grafana/ui/src/components/uPlot/plugins/TooltipPlugin2';\nimport { getDisplayValuesForCalcs } from '@grafana/ui/src/components/uPlot/utils';\n\nimport { XYChartTooltip } from './XYChartTooltip';\nimport { Options } from './panelcfg.gen';\nimport { prepConfig } from './scatter';\nimport { prepSeries } from './utils';\n\ntype Props2 = PanelProps<Options>;\n\nexport const XYChartPanel2 = (props: Props2) => {\n  const styles = useStyles2(getStyles);\n  const theme = useTheme2();\n\n  let { mapping, series: mappedSeries } = props.options;\n\n  // regenerate series schema when mappings or data changes\n  let series = useMemo(\n    () => prepSeries(mapping, mappedSeries, props.data.series, props.fieldConfig),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [mapping, mappedSeries, props.data.series, props.fieldConfig]\n  );\n\n  // if series changed due to mappings or data structure, re-init config & renderers\n  let { builder, prepData } = useMemo(\n    () => prepConfig(series, config.theme2),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [mapping, mappedSeries, props.data.structureRev, props.fieldConfig, props.options.tooltip]\n  );\n\n  // generate data struct for uPlot mode: 2\n  let data = useMemo(\n    () => prepData(series),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [series]\n  );\n\n  // todo: handle errors\n  let error = builder == null || data.length === 0 ? 'Err' : '';\n\n  // TODO: React.memo()\n  const renderLegend = () => {\n    if (!props.options.legend.showLegend) {\n      return null;\n    }\n\n    const items: VizLegendItem[] = [];\n\n    series.forEach((s, idx) => {\n      let yField = s.y.field;\n      let config = yField.config;\n      let custom = config.custom;\n\n      if (!custom.hideFrom?.legend) {\n        items.push({\n          yAxis: 1, // TODO: pull from y field\n          label: s.name.value,\n          color: alpha(s.color.fixed ?? FALLBACK_COLOR, 1),\n          getItemKey: () => `${idx}-${s.name.value}`,\n          fieldName: yField.state?.displayName ?? yField.name,\n          disabled: yField.state?.hideFrom?.viz ?? false,\n          getDisplayValues: () => getDisplayValuesForCalcs(props.options.legend.calcs, yField, theme),\n        });\n      }\n    });\n\n    const { placement, displayMode, width, sortBy, sortDesc } = props.options.legend;\n\n    return (\n      <VizLayout.Legend placement={placement} width={width}>\n        <VizLegend\n          className={styles.legend}\n          placement={placement}\n          items={items}\n          displayMode={displayMode}\n          sortBy={sortBy}\n          sortDesc={sortDesc}\n          isSortable={true}\n        />\n      </VizLayout.Legend>\n    );\n  };\n\n  if (error) {\n    return (\n      <div className=\"panel-empty\">\n        <p>{error}</p>\n      </div>\n    );\n  }\n\n  return (\n    <VizLayout width={props.width} height={props.height} legend={renderLegend()}>\n      {(vizWidth: number, vizHeight: number) => (\n        <UPlotChart config={builder!} data={data} width={vizWidth} height={vizHeight}>\n          {props.options.tooltip.mode !== TooltipDisplayMode.None && (\n            <TooltipPlugin2\n              config={builder!}\n              hoverMode={TooltipHoverMode.xyOne}\n              render={(u, dataIdxs, seriesIdx, isPinned, dismiss) => {\n                return (\n                  <XYChartTooltip\n                    data={props.data.series}\n                    dataIdxs={dataIdxs}\n                    xySeries={series}\n                    dismiss={dismiss}\n                    isPinned={isPinned}\n                    seriesIdx={seriesIdx!}\n                  />\n                );\n              }}\n              maxWidth={props.options.tooltip.maxWidth}\n            />\n          )}\n        </UPlotChart>\n      )}\n    </VizLayout>\n  );\n};\n\nconst getStyles = () => ({\n  legend: css({\n    div: {\n      justifyContent: 'flex-start',\n    },\n  }),\n});\n","import React, { ReactNode } from 'react';\n\nimport { DataFrame } from '@grafana/data';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { useStyles2 } from '@grafana/ui';\nimport { VizTooltipContent } from '@grafana/ui/src/components/VizTooltip/VizTooltipContent';\nimport { VizTooltipFooter } from '@grafana/ui/src/components/VizTooltip/VizTooltipFooter';\nimport { VizTooltipHeader } from '@grafana/ui/src/components/VizTooltip/VizTooltipHeader';\nimport { ColorIndicator, VizTooltipItem } from '@grafana/ui/src/components/VizTooltip/types';\n\nimport { getDataLinks } from '../../status-history/utils';\nimport { getStyles } from '../../timeseries/TimeSeriesTooltip';\n\nimport { XYSeries } from './types2';\nimport { fmt } from './utils';\n\nexport interface Props {\n  dataIdxs: Array<number | null>;\n  seriesIdx: number | null | undefined;\n  isPinned: boolean;\n  dismiss: () => void;\n  data: DataFrame[];\n  xySeries: XYSeries[];\n}\n\nfunction stripSeriesName(fieldName: string, seriesName: string) {\n  if (fieldName !== seriesName && fieldName.includes(' ')) {\n    fieldName = fieldName.replace(seriesName, '').trim();\n  }\n\n  return fieldName;\n}\n\nexport const XYChartTooltip = ({ dataIdxs, seriesIdx, data, xySeries, dismiss, isPinned }: Props) => {\n  const styles = useStyles2(getStyles);\n\n  const rowIndex = dataIdxs.find((idx) => idx !== null)!;\n\n  const series = xySeries[seriesIdx! - 1];\n  const xField = series.x.field;\n  const yField = series.y.field;\n\n  const sizeField = series.size.field;\n  const colorField = series.color.field;\n\n  let label = series.name.value;\n\n  let seriesColor = series.color.fixed;\n  // let colorField = series.color.field;\n  // let pointColor: string;\n\n  // if (colorField != null) {\n  //   pointColor = colorField.display?.(colorField.values[rowIndex]).color!;\n  // }\n\n  const headerItem: VizTooltipItem = {\n    label,\n    value: '',\n    color: alpha(seriesColor ?? '#fff', 0.5),\n    colorIndicator: ColorIndicator.marker_md,\n  };\n\n  const contentItems: VizTooltipItem[] = [\n    {\n      label: stripSeriesName(xField.state?.displayName ?? xField.name, label),\n      value: fmt(xField, xField.values[rowIndex]),\n    },\n    {\n      label: stripSeriesName(yField.state?.displayName ?? yField.name, label),\n      value: fmt(yField, yField.values[rowIndex]),\n    },\n  ];\n\n  // mapped fields for size/color\n  if (sizeField != null && sizeField !== yField) {\n    contentItems.push({\n      label: stripSeriesName(sizeField.state?.displayName ?? sizeField.name, label),\n      value: fmt(sizeField, sizeField.values[rowIndex]),\n    });\n  }\n\n  if (colorField != null && colorField !== yField) {\n    contentItems.push({\n      label: stripSeriesName(colorField.state?.displayName ?? colorField.name, label),\n      value: fmt(colorField, colorField.values[rowIndex]),\n    });\n  }\n\n  series._rest.forEach((field) => {\n    contentItems.push({\n      label: stripSeriesName(field.state?.displayName ?? field.name, label),\n      value: fmt(field, field.values[rowIndex]),\n    });\n  });\n\n  let footer: ReactNode;\n\n  if (isPinned && seriesIdx != null) {\n    const links = getDataLinks(yField, rowIndex);\n\n    footer = <VizTooltipFooter dataLinks={links} />;\n  }\n\n  return (\n    <div className={styles.wrapper}>\n      <VizTooltipHeader item={headerItem} isPinned={isPinned} />\n      <VizTooltipContent items={contentItems} isPinned={isPinned} />\n      {footer}\n    </div>\n  );\n};\n","import {\n  FieldColorModeId,\n  FieldConfigProperty,\n  FieldType,\n  identityOverrideProcessor,\n  SetFieldConfigOptionsArgs,\n} from '@grafana/data';\nimport { LineStyle } from '@grafana/schema';\nimport { commonOptionsBuilder } from '@grafana/ui';\n\nimport { LineStyleEditor } from '../../timeseries/LineStyleEditor';\n\nimport { FieldConfig, XYShowMode, PointShape } from './panelcfg.gen';\n\nexport const DEFAULT_POINT_SIZE = 5;\n\nexport function getScatterFieldConfig(cfg: FieldConfig): SetFieldConfigOptionsArgs<FieldConfig> {\n  return {\n    standardOptions: {\n      [FieldConfigProperty.Min]: {\n        hideFromDefaults: true,\n      },\n      [FieldConfigProperty.Max]: {\n        hideFromDefaults: true,\n      },\n      [FieldConfigProperty.Unit]: {\n        hideFromDefaults: true,\n      },\n      [FieldConfigProperty.Decimals]: {\n        hideFromDefaults: true,\n      },\n      [FieldConfigProperty.NoValue]: {\n        hideFromDefaults: true,\n      },\n      [FieldConfigProperty.DisplayName]: {\n        hideFromDefaults: true,\n      },\n\n      // TODO: this still leaves Color series by: [ Last | Min | Max ]\n      // because item.settings?.bySeriesSupport && colorMode.isByValue\n      [FieldConfigProperty.Color]: {\n        settings: {\n          byValueSupport: true,\n          bySeriesSupport: true,\n          preferThresholdsMode: false,\n        },\n        defaultValue: {\n          mode: FieldColorModeId.PaletteClassic,\n        },\n      },\n    },\n\n    useCustomConfig: (builder) => {\n      builder\n        .addRadio({\n          path: 'show',\n          name: 'Show',\n          defaultValue: cfg.show,\n          settings: {\n            options: [\n              { label: 'Points', value: XYShowMode.Points },\n              { label: 'Lines', value: XYShowMode.Lines },\n              { label: 'Both', value: XYShowMode.PointsAndLines },\n            ],\n          },\n        })\n        // .addGenericEditor(\n        //   {\n        //     path: 'pointSymbol',\n        //     name: 'Point symbol',\n        //     defaultValue: defaultFieldConfig.pointSymbol ?? {\n        //       mode: 'fixed',\n        //       fixed: 'img/icons/marker/circle.svg',\n        //     },\n        //     settings: {\n        //       resourceType: MediaType.Icon,\n        //       folderName: ResourceFolderName.Marker,\n        //       placeholderText: 'Select a symbol',\n        //       placeholderValue: 'img/icons/marker/circle.svg',\n        //       showSourceRadio: false,\n        //     },\n        //     showIf: (c) => c.show !== ScatterShow.Lines,\n        //   },\n        //   SymbolEditor // ResourceDimensionEditor\n        // )\n        .addSliderInput({\n          path: 'pointSize.fixed',\n          name: 'Point size',\n          defaultValue: cfg.pointSize?.fixed ?? DEFAULT_POINT_SIZE,\n          settings: {\n            min: 1,\n            max: 100,\n            step: 1,\n          },\n          showIf: (c) => c.show !== XYShowMode.Lines,\n        })\n        .addNumberInput({\n          path: 'pointSize.min',\n          name: 'Min point size',\n          showIf: (c) => c.show !== XYShowMode.Lines,\n        })\n        .addNumberInput({\n          path: 'pointSize.max',\n          name: 'Max point size',\n          showIf: (c) => c.show !== XYShowMode.Lines,\n        })\n        .addRadio({\n          path: 'pointShape',\n          name: 'Point shape',\n          defaultValue: PointShape.Circle,\n          settings: {\n            options: [\n              { value: PointShape.Circle, label: 'Circle' },\n              { value: PointShape.Square, label: 'Square' },\n            ],\n          },\n          showIf: (c) => c.show !== XYShowMode.Lines,\n        })\n        .addSliderInput({\n          path: 'pointStrokeWidth',\n          name: 'Point stroke width',\n          defaultValue: 1,\n          settings: {\n            min: 0,\n            max: 10,\n          },\n          showIf: (c) => c.show !== XYShowMode.Lines,\n        })\n        .addSliderInput({\n          path: 'fillOpacity',\n          name: 'Fill opacity',\n          defaultValue: 50,\n          settings: {\n            min: 0,\n            max: 100,\n            step: 1,\n          },\n          showIf: (c) => c.show !== XYShowMode.Lines,\n        })\n        .addCustomEditor<void, LineStyle>({\n          id: 'lineStyle',\n          path: 'lineStyle',\n          name: 'Line style',\n          showIf: (c) => c.show !== XYShowMode.Points,\n          editor: LineStyleEditor,\n          override: LineStyleEditor,\n          process: identityOverrideProcessor,\n          shouldApply: (f) => f.type === FieldType.number,\n        })\n        .addSliderInput({\n          path: 'lineWidth',\n          name: 'Line width',\n          defaultValue: cfg.lineWidth,\n          settings: {\n            min: 0,\n            max: 10,\n            step: 1,\n          },\n          showIf: (c) => c.show !== XYShowMode.Points,\n        });\n\n      commonOptionsBuilder.addAxisConfig(builder, cfg);\n      commonOptionsBuilder.addHideFrom(builder);\n    },\n  };\n}\n","import { FieldMatcherID, FrameMatcherID, MatcherConfig, PanelModel } from '@grafana/data';\n\nimport { ScatterSeriesConfig, SeriesMapping, XYDimensionConfig, Options as PrevOptions } from '../panelcfg.gen';\n\nimport { XYSeriesConfig, Options } from './panelcfg.gen';\n\nexport const xyChartMigrationHandler = (panel: PanelModel): Options => {\n  const pluginVersion = panel?.pluginVersion ?? '';\n\n  if (pluginVersion === '' || parseFloat(pluginVersion) < 11.1) {\n    return migrateOptions(panel);\n  }\n\n  return panel.options as Options;\n};\n\nfunction migrateOptions(panel: PanelModel): Options {\n  const { dims, seriesMapping, series: oldSeries, ...cleanedOpts } = panel.options as PrevOptions;\n  const { exclude = [], frame: frameShared, x: xShared }: XYDimensionConfig = dims ?? {};\n\n  const custDefaults = panel.fieldConfig.defaults.custom;\n\n  let oldSeries2 = oldSeries;\n\n  if (seriesMapping === SeriesMapping.Auto) {\n    oldSeries2 = [\n      {\n        x: undefined,\n        y: undefined,\n      },\n    ];\n  }\n\n  /*\n  // old manual mode example\n  \"series\": [\n    {\n      \"pointColor\": {\n        \"fixed\": \"purple\"       // this becomes override for y field.config.custom.pointColor.fixed, (or config.color?)\n        \"field\": \"BMI Male\",    // ...unless another field is mapped, then ignore\n      },\n      \"pointSize\": {\n        \"field\": \"Weight Male\",\n        \"max\": 40,              // this becomes override for y field.config.custom.pointSize.max\n        \"min\": 1,               // ...and .min\n        \"fixed\": 50.5\n      },\n      \"frame\": 0,               // byIndex frame matcher\n      \"x\": \"Height Male\",       // byName field matcher, falls back to byType/number field matcher\n      \"y\": \"Weight Male\"        // byName field matcher, falls back to byType/number field matcher\n    }\n  ],\n*/\n  let i = 0;\n\n  const newSeries: XYSeriesConfig[] = oldSeries2.map(({ x, y, pointColor, pointSize, frame }: ScatterSeriesConfig) => {\n    const { fixed: colorFixed, field: colorField } = pointColor ?? {};\n    const { fixed: sizeFixed, field: sizeField, min: sizeMin, max: sizeMax } = pointSize ?? {};\n\n    let xMatcherConfig: MatcherConfig;\n    let yMatcherConfig: MatcherConfig;\n\n    // old auto mode did not require x field defined\n    if (x == null && xShared == null) {\n      // TODO: this should just be the internal default. no need to store on save model\n      xMatcherConfig = {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      };\n    } else {\n      xMatcherConfig = {\n        id: FieldMatcherID.byName,\n        options: x ?? xShared,\n      };\n    }\n\n    if (y == null) {\n      // TODO: this should just be the internal default. no need to store on save model\n      yMatcherConfig = {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      };\n    } else {\n      yMatcherConfig = {\n        id: FieldMatcherID.byName,\n        options: y,\n      };\n    }\n\n    if (colorField == null && colorFixed && custDefaults.pointColor?.fixed !== colorFixed) {\n      // NOTE: intentionally not using custom.pointColor.fixed\n      let hasOverride = panel.fieldConfig.overrides.some(\n        (o) =>\n          o.matcher.id === yMatcherConfig.id &&\n          o.matcher.options === yMatcherConfig.options &&\n          o.properties.some((p) => p.id === 'color')\n      );\n\n      if (!hasOverride) {\n        panel.fieldConfig.overrides.push({\n          matcher: yMatcherConfig,\n          properties: [\n            {\n              id: 'color',\n              value: {\n                mode: 'fixed',\n                fixedColor: colorFixed,\n              },\n            },\n          ],\n        });\n      }\n    }\n\n    // add field overrides for custom pointSize.fixed\n    if (sizeField == null && sizeFixed && custDefaults.pointSize?.fixed !== sizeFixed) {\n      let hasOverride = panel.fieldConfig.overrides.some(\n        (o) =>\n          o.matcher.id === yMatcherConfig.id &&\n          o.matcher.options === yMatcherConfig.options &&\n          o.properties.some((p) => p.id === 'custom.pointSize.fixed')\n      );\n\n      if (!hasOverride) {\n        panel.fieldConfig.overrides.push({\n          matcher: yMatcherConfig,\n          properties: [\n            {\n              id: 'custom.pointSize.fixed',\n              value: sizeFixed,\n            },\n          ],\n        });\n      }\n    }\n\n    if (sizeField != null) {\n      // add field overrides for custom pointSize.min\n      if (sizeMin && custDefaults.pointSize?.min !== sizeMin) {\n        let hasOverride = panel.fieldConfig.overrides.some(\n          (o) =>\n            o.matcher.id === yMatcherConfig.id &&\n            o.matcher.options === yMatcherConfig.options &&\n            o.properties.some((p) => p.id === 'custom.pointSize.min')\n        );\n\n        if (!hasOverride) {\n          panel.fieldConfig.overrides.push({\n            matcher: {\n              id: FieldMatcherID.byName,\n              options: sizeField,\n            },\n            properties: [\n              {\n                id: 'custom.pointSize.min',\n                value: sizeMin,\n              },\n            ],\n          });\n        }\n      }\n      // add field overrides for custom pointSize.min\n      if (sizeMax && custDefaults.pointSize?.max !== sizeMax) {\n        let hasOverride = panel.fieldConfig.overrides.some(\n          (o) =>\n            o.matcher.id === yMatcherConfig.id &&\n            o.matcher.options === yMatcherConfig.options &&\n            o.properties.some((p) => p.id === 'custom.pointSize.max')\n        );\n\n        if (!hasOverride) {\n          panel.fieldConfig.overrides.push({\n            matcher: {\n              id: FieldMatcherID.byName,\n              options: sizeField,\n            },\n            properties: [\n              {\n                id: 'custom.pointSize.max',\n                value: sizeMax,\n              },\n            ],\n          });\n        }\n      }\n    }\n\n    return {\n      frame: {\n        matcher: {\n          id: FrameMatcherID.byIndex,\n          options: frame ?? (seriesMapping === SeriesMapping.Manual ? i++ : frameShared ?? 0),\n        },\n      },\n      x: {\n        matcher: xMatcherConfig,\n      },\n      y: {\n        matcher: yMatcherConfig,\n        ...(exclude.length && {\n          exclude: {\n            id: FieldMatcherID.byNames,\n            options: exclude,\n          },\n        }),\n      },\n      ...(colorField && {\n        color: {\n          matcher: {\n            id: FieldMatcherID.byName,\n            options: colorField,\n          },\n        },\n      }),\n      ...(sizeField && {\n        size: {\n          matcher: {\n            id: FieldMatcherID.byName,\n            options: sizeField,\n          },\n        },\n      }),\n    };\n  });\n\n  const newOptions: Options = {\n    ...cleanedOpts,\n    mapping: seriesMapping === SeriesMapping.Auto ? SeriesMapping.Auto : SeriesMapping.Manual,\n    series: newSeries,\n  };\n\n  return newOptions;\n}\n","import { PanelPlugin } from '@grafana/data';\nimport { commonOptionsBuilder } from '@grafana/ui';\n\nimport { SeriesEditor } from './SeriesEditor';\nimport { XYChartPanel2 } from './XYChartPanel';\nimport { getScatterFieldConfig } from './config';\nimport { xyChartMigrationHandler } from './migrations';\nimport { FieldConfig, defaultFieldConfig, Options } from './panelcfg.gen';\n\nexport const plugin = new PanelPlugin<Options, FieldConfig>(XYChartPanel2)\n  // .setPanelChangeHandler(xyChartChangeHandler)\n  .setMigrationHandler(xyChartMigrationHandler)\n  .useFieldConfig(getScatterFieldConfig(defaultFieldConfig))\n  .setPanelOptions((builder) => {\n    builder\n      .addRadio({\n        path: 'mapping',\n        name: 'Series mapping',\n        defaultValue: 'auto',\n        settings: {\n          options: [\n            { value: 'auto', label: 'Auto' },\n            { value: 'manual', label: 'Manual' },\n          ],\n        },\n      })\n      .addCustomEditor({\n        id: 'series',\n        path: 'series',\n        name: '',\n        editor: SeriesEditor,\n        defaultValue: [{}],\n      });\n\n    commonOptionsBuilder.addTooltipOptions(builder, true);\n    commonOptionsBuilder.addLegendOptions(builder);\n  });\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\nexport enum PointShape {\n  Circle = 'circle',\n  Square = 'square',\n}\n\nexport enum SeriesMapping {\n  Auto = 'auto',\n  Manual = 'manual',\n}\n\nexport enum XYShowMode {\n  Lines = 'lines',\n  Points = 'points',\n  PointsAndLines = 'points+lines',\n}\n\n/**\n * NOTE: (copied from dashboard_kind.cue, since not exported)\n * Matcher is a predicate configuration. Based on the config a set of field(s) or values is filtered in order to apply override / transformation.\n * It comes with in id ( to resolve implementation from registry) and a configuration that’s specific to a particular matcher type.\n */\nexport interface MatcherConfig {\n  /**\n   * The matcher id. This is used to find the matcher implementation from registry.\n   */\n  id: string;\n  /**\n   * The matcher options. This is specific to the matcher implementation.\n   */\n  options?: unknown;\n}\n\nexport const defaultMatcherConfig: Partial<MatcherConfig> = {\n  id: '',\n};\n\nexport interface FieldConfig extends common.HideableFieldConfig, common.AxisConfig {\n  fillOpacity?: number;\n  lineStyle?: common.LineStyle;\n  lineWidth?: number;\n  pointShape?: PointShape;\n  pointSize?: {\n    fixed?: number;\n    min?: number;\n    max?: number;\n  };\n  pointStrokeWidth?: number;\n  show?: XYShowMode;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  fillOpacity: 50,\n  show: XYShowMode.Points,\n};\n\nexport interface XYSeriesConfig {\n  color?: {\n    matcher: MatcherConfig;\n  };\n  frame?: {\n    matcher: MatcherConfig;\n  };\n  name?: {\n    fixed?: string;\n  };\n  size?: {\n    matcher: MatcherConfig;\n  };\n  x?: {\n    matcher: MatcherConfig;\n  };\n  y?: {\n    matcher: MatcherConfig;\n  };\n}\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip {\n  mapping: SeriesMapping;\n  series: Array<XYSeriesConfig>;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  series: [],\n};\n","import tinycolor from 'tinycolor2';\nimport uPlot from 'uplot';\n\nimport {\n  FALLBACK_COLOR,\n  Field,\n  FieldType,\n  formattedValueToString,\n  getFieldColorModeForField,\n  GrafanaTheme2,\n  MappingType,\n  SpecialValueMatch,\n  ThresholdsMode,\n} from '@grafana/data';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { AxisPlacement, FieldColorModeId, ScaleDirection, ScaleOrientation, VisibilityMode } from '@grafana/schema';\nimport { UPlotConfigBuilder } from '@grafana/ui';\nimport { FacetedData, FacetSeries } from '@grafana/ui/src/components/uPlot/types';\n\nimport { pointWithin, Quadtree, Rect } from '../../barchart/quadtree';\nimport { valuesToFills } from '../../heatmap/utils';\n\nimport { PointShape } from './panelcfg.gen';\nimport { XYSeries } from './types2';\nimport { getCommonPrefixSuffix } from './utils';\n\ninterface DrawBubblesOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n  disp: {\n    //unit: 3,\n    size: {\n      values: (u: uPlot, seriesIdx: number) => number[];\n    };\n    color: {\n      values: (u: uPlot, seriesIdx: number) => string[];\n    };\n  };\n}\n\nexport const prepConfig = (xySeries: XYSeries[], theme: GrafanaTheme2) => {\n  if (xySeries.length === 0) {\n    return { builder: null, prepData: () => [] };\n  }\n\n  let qt: Quadtree;\n  let hRect: Rect | null;\n\n  function drawBubblesFactory(opts: DrawBubblesOpts) {\n    const drawBubbles: uPlot.Series.PathBuilder = (u, seriesIdx, idx0, idx1) => {\n      uPlot.orient(\n        u,\n        seriesIdx,\n        (\n          series,\n          dataX,\n          dataY,\n          scaleX,\n          scaleY,\n          valToPosX,\n          valToPosY,\n          xOff,\n          yOff,\n          xDim,\n          yDim,\n          moveTo,\n          lineTo,\n          rect,\n          arc\n        ) => {\n          const pxRatio = uPlot.pxRatio;\n          const scatterInfo = xySeries[seriesIdx - 1];\n          let d = u.data[seriesIdx] as unknown as FacetSeries;\n\n          // showLine: boolean;\n          // lineStyle: common.LineStyle;\n          // showPoints: common.VisibilityMode;\n\n          let showLine = scatterInfo.showLine;\n          let showPoints = scatterInfo.showPoints === VisibilityMode.Always;\n          let strokeWidth = scatterInfo.pointStrokeWidth ?? 0;\n\n          u.ctx.save();\n\n          u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n          u.ctx.clip();\n\n          let pointAlpha = scatterInfo.fillOpacity / 100;\n\n          u.ctx.fillStyle = alpha((series.fill as any)(), pointAlpha);\n          u.ctx.strokeStyle = alpha((series.stroke as any)(), 1);\n          u.ctx.lineWidth = strokeWidth;\n\n          let deg360 = 2 * Math.PI;\n\n          let xKey = scaleX.key!;\n          let yKey = scaleY.key!;\n\n          //const colorMode = getFieldColorModeForField(field); // isByValue\n          const pointSize = scatterInfo.y.field.config.custom.pointSize;\n          const colorByValue = scatterInfo.color.field != null; // && colorMode.isByValue;\n\n          let maxSize = (pointSize.max ?? pointSize.fixed) * pxRatio;\n\n          // todo: this depends on direction & orientation\n          // todo: calc once per redraw, not per path\n          let filtLft = u.posToVal(-maxSize / 2, xKey);\n          let filtRgt = u.posToVal(u.bbox.width / pxRatio + maxSize / 2, xKey);\n          let filtBtm = u.posToVal(u.bbox.height / pxRatio + maxSize / 2, yKey);\n          let filtTop = u.posToVal(-maxSize / 2, yKey);\n\n          let sizes = opts.disp.size.values(u, seriesIdx);\n          // let pointColors = opts.disp.color.values(u, seriesIdx);\n          let pointColors = dispColors[seriesIdx - 1].values; // idxs\n          let pointPalette = dispColors[seriesIdx - 1].index as Array<CanvasRenderingContext2D['fillStyle']>;\n          let paletteHasAlpha = dispColors[seriesIdx - 1].hasAlpha;\n\n          let isSquare = scatterInfo.pointShape === PointShape.Square;\n\n          let linePath: Path2D | null = showLine ? new Path2D() : null;\n\n          let curColorIdx = -1;\n\n          for (let i = 0; i < d[0].length; i++) {\n            let xVal = d[0][i];\n            let yVal = d[1][i];\n\n            if (xVal >= filtLft && xVal <= filtRgt && yVal >= filtBtm && yVal <= filtTop) {\n              let size = Math.round(sizes[i] * pxRatio);\n              let cx = valToPosX(xVal, scaleX, xDim, xOff);\n              let cy = valToPosY(yVal, scaleY, yDim, yOff);\n\n              if (showLine) {\n                linePath!.lineTo(cx, cy);\n              }\n\n              if (showPoints) {\n                if (colorByValue) {\n                  if (pointColors[i] !== curColorIdx) {\n                    curColorIdx = pointColors[i];\n                    let c = curColorIdx === -1 ? FALLBACK_COLOR : pointPalette[curColorIdx];\n                    u.ctx.fillStyle = paletteHasAlpha ? c : alpha(c as string, pointAlpha);\n                    u.ctx.strokeStyle = alpha(c as string, 1);\n                  }\n                }\n\n                if (isSquare) {\n                  let x = Math.round(cx - size / 2);\n                  let y = Math.round(cy - size / 2);\n\n                  if (colorByValue || pointAlpha > 0) {\n                    u.ctx.fillRect(x, y, size, size);\n                  }\n\n                  if (strokeWidth > 0) {\n                    u.ctx.strokeRect(x, y, size, size);\n                  }\n                } else {\n                  u.ctx.beginPath();\n                  u.ctx.arc(cx, cy, size / 2, 0, deg360);\n\n                  if (colorByValue || pointAlpha > 0) {\n                    u.ctx.fill();\n                  }\n\n                  if (strokeWidth > 0) {\n                    u.ctx.stroke();\n                  }\n                }\n\n                opts.each(\n                  u,\n                  seriesIdx,\n                  i,\n                  cx - size / 2 - strokeWidth / 2,\n                  cy - size / 2 - strokeWidth / 2,\n                  size + strokeWidth,\n                  size + strokeWidth\n                );\n              }\n            }\n          }\n\n          if (showLine) {\n            u.ctx.strokeStyle = scatterInfo.color.fixed!;\n            u.ctx.lineWidth = scatterInfo.lineWidth * pxRatio;\n\n            const { lineStyle } = scatterInfo;\n            if (lineStyle && lineStyle.fill !== 'solid') {\n              if (lineStyle.fill === 'dot') {\n                u.ctx.lineCap = 'round';\n              }\n              u.ctx.setLineDash(lineStyle.dash ?? [10, 10]);\n            }\n\n            u.ctx.stroke(linePath!);\n          }\n\n          u.ctx.restore();\n        }\n      );\n\n      return null;\n    };\n\n    return drawBubbles;\n  }\n\n  let drawBubbles = drawBubblesFactory({\n    disp: {\n      size: {\n        //unit: 3, // raw CSS pixels\n        values: (u, seriesIdx) => {\n          return u.data[seriesIdx][2] as any; // already contains final pixel geometry\n          //let [minValue, maxValue] = getSizeMinMax(u);\n          //return u.data[seriesIdx][2].map(v => getSize(v, minValue, maxValue));\n        },\n      },\n      color: {\n        // string values\n        values: (u, seriesIdx) => {\n          return u.data[seriesIdx][3] as any;\n        },\n      },\n    },\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      // we get back raw canvas coords (included axes & padding). translate to the plotting area origin\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n      qt.add({ x: lft, y: top, w: wid, h: hgt, sidx: seriesIdx, didx: dataIdx });\n    },\n  });\n\n  const builder = new UPlotConfigBuilder();\n\n  builder.setCursor({\n    drag: { setScale: true },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        const pxRatio = uPlot.pxRatio;\n\n        hRect = null;\n\n        let dist = Infinity;\n        let cx = u.cursor.left! * pxRatio;\n        let cy = u.cursor.top! * pxRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            let ocx = o.x + o.w / 2;\n            let ocy = o.y + o.h / 2;\n\n            let dx = ocx - cx;\n            let dy = ocy - cy;\n\n            let d = Math.sqrt(dx ** 2 + dy ** 2);\n\n            // test against radius for actual hover\n            if (d <= o.w / 2) {\n              // only hover bbox with closest distance\n              if (d <= dist) {\n                dist = d;\n                hRect = o;\n              }\n            }\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    points: {\n      size: (u, seriesIdx) => {\n        return hRect && seriesIdx === hRect.sidx ? hRect.w / uPlot.pxRatio : 0;\n      },\n      fill: (u, seriesIdx) => 'rgba(255,255,255,0.4)',\n    },\n  });\n\n  // clip hover points/bubbles to plotting area\n  builder.addHook('init', (u, r) => {\n    u.over.style.overflow = 'hidden';\n  });\n\n  builder.addHook('drawClear', (u) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s, i) => {\n      if (i > 0) {\n        // @ts-ignore\n        s._paths = null;\n      }\n    });\n  });\n\n  builder.setMode(2);\n\n  let xField = xySeries[0].x.field;\n\n  let fieldConfig = xField.config;\n  let customConfig = fieldConfig.custom;\n  let scaleDistr = customConfig?.scaleDistribution;\n\n  builder.addScale({\n    scaleKey: 'x',\n    isTime: false,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    distribution: scaleDistr?.type,\n    log: scaleDistr?.log,\n    linearThreshold: scaleDistr?.linearThreshold,\n    min: fieldConfig.min,\n    max: fieldConfig.max,\n    softMin: customConfig?.axisSoftMin,\n    softMax: customConfig?.axisSoftMax,\n    centeredZero: customConfig?.axisCenteredZero,\n    decimals: fieldConfig.decimals,\n  });\n\n  // why does this fall back to '' instead of null or undef?\n  let xAxisLabel = customConfig.axisLabel;\n\n  if (xAxisLabel == null || xAxisLabel === '') {\n    let dispNames = xySeries.map((s) => s.x.field.state?.displayName ?? '');\n\n    let xAxisAutoLabel =\n      xySeries.length === 1\n        ? xField.state?.displayName ?? xField.name\n        : new Set(dispNames).size === 1\n          ? dispNames[0]\n          : getCommonPrefixSuffix(dispNames);\n\n    if (xAxisAutoLabel !== '') {\n      xAxisLabel = xAxisAutoLabel;\n    }\n  }\n\n  builder.addAxis({\n    scaleKey: 'x',\n    placement: customConfig?.axisPlacement !== AxisPlacement.Hidden ? AxisPlacement.Bottom : AxisPlacement.Hidden,\n    show: customConfig?.axisPlacement !== AxisPlacement.Hidden,\n    grid: { show: customConfig?.axisGridShow },\n    border: { show: customConfig?.axisBorderShow },\n    theme,\n    label: xAxisLabel,\n    formatValue: (v, decimals) => formattedValueToString(xField.display!(v, decimals)),\n  });\n\n  xySeries.forEach((s, si) => {\n    let field = s.y.field;\n\n    const lineColor = s.color.fixed;\n    const pointColor = s.color.fixed;\n    //const lineColor = s.lineColor(frame);\n    //const lineWidth = s.lineWidth;\n\n    let scaleKey = field.config.unit ?? 'y';\n    let config = field.config;\n    let customConfig = config.custom;\n    let scaleDistr = customConfig?.scaleDistribution;\n\n    builder.addScale({\n      scaleKey,\n      orientation: ScaleOrientation.Vertical,\n      direction: ScaleDirection.Up,\n      distribution: scaleDistr?.type,\n      log: scaleDistr?.log,\n      linearThreshold: scaleDistr?.linearThreshold,\n      min: config.min,\n      max: config.max,\n      softMin: customConfig?.axisSoftMin,\n      softMax: customConfig?.axisSoftMax,\n      centeredZero: customConfig?.axisCenteredZero,\n      decimals: config.decimals,\n    });\n\n    // why does this fall back to '' instead of null or undef?\n    let yAxisLabel = customConfig.axisLabel;\n\n    if (yAxisLabel == null || yAxisLabel === '') {\n      let dispNames = xySeries.map((s) => s.y.field.state?.displayName ?? '');\n\n      let yAxisAutoLabel =\n        xySeries.length === 1\n          ? field.state?.displayName ?? field.name\n          : new Set(dispNames).size === 1\n            ? dispNames[0]\n            : getCommonPrefixSuffix(dispNames);\n\n      if (yAxisAutoLabel !== '') {\n        yAxisLabel = yAxisAutoLabel;\n      }\n    }\n\n    builder.addAxis({\n      scaleKey,\n      theme,\n      placement: customConfig?.axisPlacement === AxisPlacement.Auto ? AxisPlacement.Left : customConfig?.axisPlacement,\n      show: customConfig?.axisPlacement !== AxisPlacement.Hidden,\n      grid: { show: customConfig?.axisGridShow },\n      border: { show: customConfig?.axisBorderShow },\n      size: customConfig?.axisWidth,\n      // label: yAxisLabel == null || yAxisLabel === '' ? fieldDisplayName : yAxisLabel,\n      label: yAxisLabel,\n      formatValue: (v, decimals) => formattedValueToString(field.display!(v, decimals)),\n    });\n\n    builder.addSeries({\n      facets: [\n        {\n          scale: 'x',\n          auto: true,\n        },\n        {\n          scale: scaleKey,\n          auto: true,\n        },\n      ],\n      pathBuilder: drawBubbles, // drawBubbles({disp: {size: {values: () => }}})\n      theme,\n      scaleKey: '', // facets' scales used (above)\n      lineColor: alpha(lineColor ?? '#ffff', 1),\n      fillColor: alpha(pointColor ?? '#ffff', 0.5),\n      show: !field.state?.hideFrom?.viz,\n    });\n  });\n\n  const dispColors = xySeries.map((s): FieldColorValuesWithCache => {\n    const cfg: FieldColorValuesWithCache = {\n      index: [],\n      getAll: () => [],\n      getOne: () => -1,\n      // cache for renderer, refreshed in prepData()\n      values: [],\n      hasAlpha: false,\n    };\n\n    const f = s.color.field;\n\n    if (f != null) {\n      Object.assign(cfg, fieldValueColors(f, theme));\n      cfg.hasAlpha = cfg.index.some((v) => !(v as string).endsWith('ff'));\n    }\n\n    return cfg;\n  });\n\n  function prepData(xySeries: XYSeries[]): FacetedData {\n    // if (info.error || !data.length) {\n    //   return [null];\n    // }\n\n    const { size: sizeRange, color: colorRange } = getGlobalRanges(xySeries);\n\n    xySeries.forEach((s, i) => {\n      dispColors[i].values = dispColors[i].getAll(s.color.field?.values ?? [], colorRange.min, colorRange.max);\n    });\n\n    return [\n      null,\n      ...xySeries.map((s, idx) => {\n        let len = s.x.field.values.length;\n\n        let diams: number[];\n\n        if (s.size.field != null) {\n          let { min, max } = s.size;\n\n          // todo: this scaling should be in renderer from raw values (not by passing css pixel diams via data)\n          let minPx = min! ** 2;\n          let maxPx = max! ** 2;\n          // use quadratic size scaling in byValue modes\n          let pxRange = maxPx - minPx;\n\n          let vals = s.size.field.values;\n          let minVal = sizeRange.min;\n          let maxVal = sizeRange.max;\n          let valRange = maxVal - minVal;\n\n          diams = Array(len);\n\n          for (let i = 0; i < vals.length; i++) {\n            let val = vals[i];\n\n            let valPct = (val - minVal) / valRange;\n            let pxArea = minPx + valPct * pxRange;\n            diams[i] = pxArea ** 0.5;\n          }\n        } else {\n          diams = Array(len).fill(s.size.fixed!);\n        }\n\n        return [\n          s.x.field.values, // X\n          s.y.field.values, // Y\n          diams,\n          Array(len).fill(s.color.fixed!), // TODO: fails for by value\n        ];\n      }),\n    ];\n  }\n\n  return { builder, prepData };\n};\n\nexport type PrepData = (xySeries: XYSeries[]) => FacetedData;\n\nconst getGlobalRanges = (xySeries: XYSeries[]) => {\n  const ranges = {\n    size: {\n      min: Infinity,\n      max: -Infinity,\n    },\n    color: {\n      min: Infinity,\n      max: -Infinity,\n    },\n  };\n\n  xySeries.forEach((series) => {\n    [series.size, series.color].forEach((facet, fi) => {\n      if (facet.field != null) {\n        let range = fi === 0 ? ranges.size : ranges.color;\n\n        const vals = facet.field.values;\n\n        for (let i = 0; i < vals.length; i++) {\n          const v = vals[i];\n\n          if (v != null) {\n            if (v < range.min) {\n              range.min = v;\n            }\n\n            if (v > range.max) {\n              range.max = v;\n            }\n          }\n        }\n      }\n    });\n  });\n\n  return ranges;\n};\n\nfunction getHex8Color(color: string, theme: GrafanaTheme2) {\n  return tinycolor(theme.visualization.getColorByName(color)).toHex8String();\n}\n\ninterface FieldColorValues {\n  index: unknown[];\n  getOne: GetOneValue;\n  getAll: GetAllValues;\n}\ninterface FieldColorValuesWithCache extends FieldColorValues {\n  values: number[];\n  hasAlpha: boolean;\n}\ntype GetAllValues = (values: unknown[], min?: number, max?: number) => number[];\ntype GetOneValue = (value: unknown, min?: number, max?: number) => number;\n\n/** compiler for values to palette color idxs (from thresholds, mappings, by-value gradients) */\nfunction fieldValueColors(f: Field, theme: GrafanaTheme2): FieldColorValues {\n  let index: unknown[] = [];\n  let getAll: GetAllValues = () => [];\n  let getOne: GetOneValue = () => -1;\n\n  let conds = '';\n\n  // if any mappings exist, use them regardless of other settings\n  if (f.config.mappings?.length ?? 0 > 0) {\n    let mappings = f.config.mappings!;\n\n    for (let i = 0; i < mappings.length; i++) {\n      let m = mappings[i];\n\n      if (m.type === MappingType.ValueToText) {\n        for (let k in m.options) {\n          let { color } = m.options[k];\n\n          if (color != null) {\n            let rhs = f.type === FieldType.string ? JSON.stringify(k) : Number(k);\n            conds += `v === ${rhs} ? ${index.length} : `;\n            index.push(getHex8Color(color, theme));\n          }\n        }\n      } else if (m.options.result.color != null) {\n        let { color } = m.options.result;\n\n        if (m.type === MappingType.RangeToText) {\n          let range = [];\n\n          if (m.options.from != null) {\n            range.push(`v >= ${Number(m.options.from)}`);\n          }\n\n          if (m.options.to != null) {\n            range.push(`v <= ${Number(m.options.to)}`);\n          }\n\n          if (range.length > 0) {\n            conds += `${range.join(' && ')} ? ${index.length} : `;\n            index.push(getHex8Color(color, theme));\n          }\n        } else if (m.type === MappingType.SpecialValue) {\n          let spl = m.options.match;\n\n          if (spl === SpecialValueMatch.NaN) {\n            conds += `isNaN(v)`;\n          } else if (spl === SpecialValueMatch.NullAndNaN) {\n            conds += `v == null || isNaN(v)`;\n          } else {\n            conds += `v ${\n              spl === SpecialValueMatch.True\n                ? '=== true'\n                : spl === SpecialValueMatch.False\n                  ? '=== false'\n                  : spl === SpecialValueMatch.Null\n                    ? '== null'\n                    : spl === SpecialValueMatch.Empty\n                      ? '=== \"\"'\n                      : '== null'\n            }`;\n          }\n\n          conds += ` ? ${index.length} : `;\n          index.push(getHex8Color(color, theme));\n        } else if (m.type === MappingType.RegexToText) {\n          // TODO\n        }\n      }\n    }\n\n    conds += '-1'; // ?? what default here? null? FALLBACK_COLOR?\n  } else if (f.config.color?.mode === FieldColorModeId.Thresholds) {\n    if (f.config.thresholds?.mode === ThresholdsMode.Absolute) {\n      let steps = f.config.thresholds.steps;\n      let lasti = steps.length - 1;\n\n      for (let i = lasti; i > 0; i--) {\n        conds += `v >= ${steps[i].value} ? ${i} : `;\n      }\n\n      conds += '0';\n\n      index = steps.map((s) => getHex8Color(s.color, theme));\n    } else {\n      // TODO: percent thresholds?\n    }\n  } else if (f.config.color?.mode?.startsWith('continuous')) {\n    let calc = getFieldColorModeForField(f).getCalculator(f, theme);\n\n    index = Array(32);\n\n    for (let i = 0; i < index.length; i++) {\n      let pct = i / (index.length - 1);\n      index[i] = getHex8Color(calc(pct, pct), theme);\n    }\n\n    getAll = (vals, min, max) => valuesToFills(vals as number[], index as string[], min!, max!);\n  }\n\n  if (conds !== '') {\n    getOne = new Function('v', `return ${conds};`) as GetOneValue;\n\n    getAll = new Function(\n      'vals',\n      `\n      let idxs = Array(vals.length);\n\n      for (let i = 0; i < vals.length; i++) {\n        let v = vals[i];\n        idxs[i] = ${conds};\n      }\n\n      return idxs;\n    `\n    ) as GetAllValues;\n  }\n\n  return {\n    index,\n    getOne,\n    getAll,\n  };\n}\n","import {\n  Field,\n  formattedValueToString,\n  getFieldMatcher,\n  FieldType,\n  getFieldDisplayName,\n  DataFrame,\n  FrameMatcherID,\n  MatcherConfig,\n  FieldColorModeId,\n  cacheFieldDisplayNames,\n  FieldMatcherID,\n  FieldConfigSource,\n} from '@grafana/data';\nimport { decoupleHideFromState } from '@grafana/data/src/field/fieldState';\nimport { config } from '@grafana/runtime';\nimport { VisibilityMode } from '@grafana/schema';\n\nimport { XYShowMode, SeriesMapping, XYSeriesConfig } from './panelcfg.gen';\nimport { XYSeries } from './types2';\n\nexport function fmt(field: Field, val: number): string {\n  if (field.display) {\n    return formattedValueToString(field.display(val));\n  }\n\n  return `${val}`;\n}\n\n// cause we dont have a proper matcher for this currently\nfunction getFrameMatcher2(config: MatcherConfig) {\n  if (config.id === FrameMatcherID.byIndex) {\n    return (frame: DataFrame, index: number) => index === config.options;\n  }\n\n  return () => false;\n}\n\nexport function prepSeries(\n  mapping: SeriesMapping,\n  mappedSeries: XYSeriesConfig[],\n  frames: DataFrame[],\n  fieldConfig: FieldConfigSource<any>\n) {\n  cacheFieldDisplayNames(frames);\n  decoupleHideFromState(frames, fieldConfig);\n\n  let series: XYSeries[] = [];\n\n  if (mappedSeries.length === 0) {\n    mappedSeries = [{}];\n  }\n\n  const { palette, getColorByName } = config.theme2.visualization;\n\n  mappedSeries.forEach((seriesCfg, seriesIdx) => {\n    if (mapping === SeriesMapping.Manual) {\n      if (seriesCfg.frame?.matcher == null || seriesCfg.x?.matcher == null || seriesCfg.y?.matcher == null) {\n        return;\n      }\n    }\n\n    let xMatcher = getFieldMatcher(\n      seriesCfg.x?.matcher ?? {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      }\n    );\n    let yMatcher = getFieldMatcher(\n      seriesCfg.y?.matcher ?? {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      }\n    );\n    let colorMatcher = seriesCfg.color ? getFieldMatcher(seriesCfg.color.matcher) : null;\n    let sizeMatcher = seriesCfg.size ? getFieldMatcher(seriesCfg.size.matcher) : null;\n    // let frameMatcher = seriesCfg.frame ? getFrameMatchers(seriesCfg.frame) : null;\n    let frameMatcher = seriesCfg.frame ? getFrameMatcher2(seriesCfg.frame.matcher) : null;\n\n    // loop over all frames and fields, adding a new series for each y dim\n    frames.forEach((frame, frameIdx) => {\n      // must match frame in manual mode\n      if (frameMatcher != null && !frameMatcher(frame, frameIdx)) {\n        return;\n      }\n\n      // shared across each series in this frame\n      let restFields: Field[] = [];\n\n      let frameSeries: XYSeries[] = [];\n\n      // only grabbing number fields (exclude time, string, enum, other)\n      let onlyNumFields = frame.fields.filter((field) => field.type === FieldType.number);\n\n      // only one of these per frame\n      let x = onlyNumFields.find((field) => xMatcher(field, frame, frames));\n      let color =\n        colorMatcher != null\n          ? onlyNumFields.find((field) => field !== x && colorMatcher!(field, frame, frames))\n          : undefined;\n      let size =\n        sizeMatcher != null\n          ? onlyNumFields.find((field) => field !== x && field !== color && sizeMatcher!(field, frame, frames))\n          : undefined;\n\n      // x field is required\n      if (x != null) {\n        // match y fields and create series\n        onlyNumFields.forEach((field) => {\n          if (field === x) {\n            return;\n          }\n\n          // in auto mode don't reuse already-mapped fields\n          if (mapping === SeriesMapping.Auto && (field === color || field === size)) {\n            return;\n          }\n\n          // in manual mode only add single series for this config\n          if (mapping === SeriesMapping.Manual && frameSeries.length > 0) {\n            return;\n          }\n\n          // if we match non-excluded y, create series\n          if (yMatcher(field, frame, frames) && !field.config.custom?.hideFrom?.viz) {\n            let y = field;\n            let name = seriesCfg.name?.fixed ?? getFieldDisplayName(y, frame, frames);\n\n            let ser: XYSeries = {\n              // these typically come from y field\n              name: {\n                value: name,\n              },\n\n              showPoints: y.config.custom.show === XYShowMode.Lines ? VisibilityMode.Never : VisibilityMode.Always,\n              pointShape: y.config.custom.pointShape,\n              pointStrokeWidth: y.config.custom.pointStrokeWidth,\n              fillOpacity: y.config.custom.fillOpacity,\n\n              showLine: y.config.custom.show !== XYShowMode.Points,\n              lineWidth: y.config.custom.lineWidth ?? 2,\n              lineStyle: y.config.custom.lineStyle,\n\n              x: {\n                field: x!,\n              },\n              y: {\n                field: y,\n              },\n              color: {},\n              size: {},\n              _rest: restFields,\n            };\n\n            if (color != null) {\n              ser.color.field = color;\n            }\n\n            if (size != null) {\n              ser.size.field = size;\n              ser.size.min = size.config.custom.pointSize?.min ?? 5;\n              ser.size.max = size.config.custom.pointSize?.max ?? 100;\n              // ser.size.mode =\n            }\n\n            frameSeries.push(ser);\n          }\n        });\n\n        if (frameSeries.length === 0) {\n          // TODO: could not create series, skip & show error?\n        }\n\n        // populate rest fields\n        frame.fields.forEach((field) => {\n          let isUsedField = frameSeries.some(\n            ({ x, y, color, size }) =>\n              x.field === field || y.field === field || color.field === field || size.field === field\n          );\n\n          if (!isUsedField) {\n            restFields.push(field);\n          }\n        });\n\n        series.push(...frameSeries);\n      } else {\n        // x is missing in this frame!\n      }\n    });\n  });\n\n  if (series.length === 0) {\n    // TODO: could not create series, skip & show error?\n  } else {\n    // assign classic palette colors by index, as fallbacks for all series\n\n    let paletteIdx = 0;\n\n    // todo: populate min, max, mode from field + hints\n    series.forEach((s, i) => {\n      if (s.color.field == null) {\n        // derive fixed color from y field config\n        let colorCfg = s.y.field.config.color ?? { mode: FieldColorModeId.PaletteClassic };\n\n        let value = '';\n\n        if (colorCfg.mode === FieldColorModeId.PaletteClassic) {\n          value = getColorByName(palette[paletteIdx++ % palette.length]); // todo: do this via state.seriesIdx and re-init displayProcessor\n        } else if (colorCfg.mode === FieldColorModeId.Fixed) {\n          value = getColorByName(colorCfg.fixedColor!);\n        }\n\n        s.color.fixed = value;\n      }\n\n      if (s.size.field == null) {\n        // derive fixed size from y field config\n        s.size.fixed = s.y.field.config.custom.pointSize?.fixed ?? 5;\n        // ser.size.mode =\n      }\n    });\n\n    autoNameSeries(series);\n\n    // TODO: re-assign y display names?\n    // y.state = {\n    //   ...y.state,\n    //   seriesIndex: series.length + ,\n    // };\n    // y.display = getDisplayProcessor({ field, theme });\n  }\n\n  return series;\n}\n\n// strip common prefixes and suffixes from y field names\nfunction autoNameSeries(series: XYSeries[]) {\n  let names = series.map((s) => s.name.value.split(/\\s+/g));\n\n  const { prefix, suffix } = findCommonPrefixSuffixLengths(names);\n\n  if (prefix < Infinity || suffix < Infinity) {\n    series.forEach((s, i) => {\n      s.name.value = names[i].slice(prefix, names[i].length - suffix).join(' ');\n    });\n  }\n}\n\nexport function getCommonPrefixSuffix(strs: string[]) {\n  let names = strs.map((s) => s.split(/\\s+/g));\n\n  let { prefix, suffix } = findCommonPrefixSuffixLengths(names);\n\n  let n = names[0];\n\n  if (n.length === 1 && prefix === 1 && suffix === 1) {\n    return '';\n  }\n\n  let parts = [];\n\n  if (prefix > 0) {\n    parts.push(...n.slice(0, prefix));\n  }\n\n  if (suffix > 0) {\n    parts.push(...n.slice(-suffix));\n  }\n\n  return parts.join(' ');\n}\n\n// lengths are in number of tokens (segments) in a phrase\nfunction findCommonPrefixSuffixLengths(names: string[][]) {\n  let commonPrefixLen = Infinity;\n  let commonSuffixLen = Infinity;\n\n  // if auto naming strategy, rename fields by stripping common prefixes and suffixes\n  let segs0: string[] = names[0];\n\n  for (let i = 1; i < names.length; i++) {\n    if (names[i].length < segs0.length) {\n      segs0 = names[i];\n    }\n  }\n\n  for (let i = 1; i < names.length; i++) {\n    let segs = names[i];\n\n    if (segs !== segs0) {\n      // prefixes\n      let preLen = 0;\n      for (let j = 0; j < segs0.length; j++) {\n        if (segs[j] === segs0[j]) {\n          preLen++;\n        } else {\n          break;\n        }\n      }\n\n      if (preLen < commonPrefixLen) {\n        commonPrefixLen = preLen;\n      }\n\n      // suffixes\n      let sufLen = 0;\n      for (let j = segs0.length - 1; j >= 0; j--) {\n        if (segs[j] === segs0[j]) {\n          sufLen++;\n        } else {\n          break;\n        }\n      }\n\n      if (sufLen < commonSuffixLen) {\n        commonSuffixLen = sufLen;\n      }\n    }\n  }\n\n  return {\n    prefix: commonPrefixLen,\n    suffix: commonSuffixLen,\n  };\n}\n"],"names":["_a","_b","_c","_d","_e","SeriesMapping","ScatterShow","series","_f","config","PointShape","XYShowMode","drawBubbles","customConfig","scaleDistr","s","xySeries","_g","x","color","size"],"sourceRoot":""}