{"version":3,"file":"node_modules_glideapps_glide-data-grid_dist_esm_internal_data-grid-overlay-editor_data-grid-o-f5d758.0f089e30a3bf9f5683d0.js","mappings":";;;;;;;;;;;AAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACO,gDAAgD,sDAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;ACnB8B;AACU;AACiD;AACtB;AACiD;AACpC;AACvB;AAC1D;AACA,YAAY,4OAA4O;AACxP,yCAAyC,2CAAc;AACvD,yBAAyB,yCAAY;AACrC;AACA,kCAAkC,2CAAc;AAChD;AACA;AACA,iBAAiB,iFAAkB;AACnC,KAAK;AACL,4BAA4B,8CAAiB;AAC7C;AACA,KAAK;AACL,yBAAyB,8CAAiB;AAC1C,kEAAkE,iFAAkB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,yCAAY;AACjC,yBAAyB,yCAAY;AACrC,2BAA2B,8CAAiB;AAC5C;AACA;AACA,KAAK;AACL,6BAA6B,8CAAiB;AAC9C;AACA;AACA,KAAK;AACL,sBAAsB,8CAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,uCAAuC,0CAAa;AACpD,YAAY,8EAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,gCAAgC,EAAE,uEAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2FAA4B;AAC3D;AACA;AACA;AACA;AACA,kBAAkB,gDAAmB,iBAAiB,2JAA2J,iFAAkB,8NAA8N;AACjc;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uDAAY,CAAC,gDAAmB,CAAC,2DAAY,aAAa,cAAc;AACnF,QAAQ,gDAAmB,CAAC,2FAAqB,IAAI,OAAO,+DAAY,+FAA+F;AACvK,YAAY,gDAAmB,CAAC,0FAA0B,IAAI,qPAAqP;AACnT,gBAAgB,gDAAmB,UAAU,oDAAoD;AACjG;AACA,iEAAe,qBAAqB,EAAC;AACrC;;;;;;;;;;;;ACvH+B;AAC/B;AACA,oCAAoC,2CAAc;AAClD;AACA;AACO;AACP;AACA,kCAAkC,2CAAc;AAChD,gDAAgD,2CAAc;AAC9D,IAAI,kDAAqB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,cAAc;AAC3B;AACA;AACA,KAAK;AACL,IAAI,4CAAe;AACnB;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,0CAAa;AAC/B,iBAAiB,yBAAyB,QAAQ;AAClD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA","sources":["webpack://grafana/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor-style.js","webpack://grafana/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor.js","webpack://grafana/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/use-stay-on-screen.js"],"sourcesContent":["import { styled } from \"@linaria/react\";\nconst _exp2 = /*#__PURE__*/() => p => p.targetX;\nconst _exp3 = /*#__PURE__*/() => p => p.targetY;\nconst _exp4 = /*#__PURE__*/() => p => p.targetWidth;\nconst _exp5 = /*#__PURE__*/() => p => p.targetHeight;\nconst _exp6 = /*#__PURE__*/() => p => p.targetY + 10;\nconst _exp7 = /*#__PURE__*/() => p => Math.max(0, (p.targetHeight - 28) / 2);\nexport const DataGridOverlayEditorStyle = /*#__PURE__*/styled('div')({\n  name: \"DataGridOverlayEditorStyle\",\n  class: \"gdg-d19meir1\",\n  propsAsIs: false,\n  vars: {\n    \"d19meir1-0\": [_exp3(), \"px\"],\n    \"d19meir1-1\": [_exp2(), \"px\"],\n    \"d19meir1-2\": [_exp4(), \"px\"],\n    \"d19meir1-3\": [_exp5(), \"px\"],\n    \"d19meir1-4\": [_exp6(), \"px\"],\n    \"d19meir1-5\": [_exp7(), \"px\"]\n  }\n});\n\n","import * as React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container.js\";\nimport { makeCSSStyle, ThemeContext } from \"../../common/styles.js\";\nimport { isEditableGridCell, isInnerOnlyCell, isObjectEditorCallbackResult, } from \"../data-grid/data-grid-types.js\";\nimport { DataGridOverlayEditorStyle } from \"./data-grid-overlay-editor-style.js\";\nimport { useStayOnScreen } from \"./use-stay-on-screen.js\";\nconst DataGridOverlayEditor = p => {\n    const { target, content, onFinishEditing: onFinishEditingIn, forceEditMode, initialValue, imageEditorOverride, markdownDivCreateNode, highlight, className, theme, id, cell, bloom, validateCell, getCellRenderer, provideEditor, isOutsideClick, } = p;\n    const [tempValue, setTempValueRaw] = React.useState(forceEditMode ? content : undefined);\n    const lastValueRef = React.useRef(tempValue ?? content);\n    lastValueRef.current = tempValue ?? content;\n    const [isValid, setIsValid] = React.useState(() => {\n        if (validateCell === undefined)\n            return true;\n        return !(isEditableGridCell(content) && validateCell?.(cell, content, lastValueRef.current) === false);\n    });\n    const onFinishEditing = React.useCallback((newCell, movement) => {\n        onFinishEditingIn(isValid ? newCell : undefined, movement);\n    }, [isValid, onFinishEditingIn]);\n    const setTempValue = React.useCallback((newVal) => {\n        if (validateCell !== undefined && newVal !== undefined && isEditableGridCell(newVal)) {\n            const validResult = validateCell(cell, newVal, lastValueRef.current);\n            if (validResult === false) {\n                setIsValid(false);\n            }\n            else if (typeof validResult === \"object\") {\n                newVal = validResult;\n                setIsValid(true);\n            }\n            else {\n                setIsValid(true);\n            }\n        }\n        setTempValueRaw(newVal);\n    }, [cell, validateCell]);\n    const finished = React.useRef(false);\n    const customMotion = React.useRef(undefined);\n    const onClickOutside = React.useCallback(() => {\n        onFinishEditing(tempValue, [0, 0]);\n        finished.current = true;\n    }, [tempValue, onFinishEditing]);\n    const onEditorFinished = React.useCallback((newValue, movement) => {\n        onFinishEditing(newValue, movement ?? customMotion.current ?? [0, 0]);\n        finished.current = true;\n    }, [onFinishEditing]);\n    const onKeyDown = React.useCallback(async (event) => {\n        let save = false;\n        if (event.key === \"Escape\") {\n            event.stopPropagation();\n            event.preventDefault();\n            customMotion.current = [0, 0];\n        }\n        else if (event.key === \"Enter\" && !event.shiftKey) {\n            event.stopPropagation();\n            event.preventDefault();\n            customMotion.current = [0, 1];\n            save = true;\n        }\n        else if (event.key === \"Tab\") {\n            event.stopPropagation();\n            event.preventDefault();\n            customMotion.current = [event.shiftKey ? -1 : 1, 0];\n            save = true;\n        }\n        window.setTimeout(() => {\n            if (!finished.current && customMotion.current !== undefined) {\n                onFinishEditing(save ? tempValue : undefined, customMotion.current);\n                finished.current = true;\n            }\n        }, 0);\n    }, [onFinishEditing, tempValue]);\n    const targetValue = tempValue ?? content;\n    const [editorProvider, useLabel] = React.useMemo(() => {\n        if (isInnerOnlyCell(content))\n            return [];\n        const external = provideEditor?.(content);\n        if (external !== undefined)\n            return [external, false];\n        return [getCellRenderer(content)?.provideEditor?.(content), false];\n    }, [content, getCellRenderer, provideEditor]);\n    const { ref, style: stayOnScreenStyle } = useStayOnScreen();\n    let pad = true;\n    let editor;\n    let style = true;\n    let styleOverride;\n    if (editorProvider !== undefined) {\n        pad = editorProvider.disablePadding !== true;\n        style = editorProvider.disableStyling !== true;\n        const isObjectEditor = isObjectEditorCallbackResult(editorProvider);\n        if (isObjectEditor) {\n            styleOverride = editorProvider.styleOverride;\n        }\n        const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;\n        editor = (React.createElement(CustomEditor, { isHighlighted: highlight, onChange: setTempValue, value: targetValue, initialValue: initialValue, onFinishedEditing: onEditorFinished, validatedSelection: isEditableGridCell(targetValue) ? targetValue.selectionRange : undefined, forceEditMode: forceEditMode, target: target, imageEditorOverride: imageEditorOverride, markdownDivCreateNode: markdownDivCreateNode, isValid: isValid, theme: theme }));\n    }\n    styleOverride = { ...styleOverride, ...stayOnScreenStyle };\n    // Consider imperatively creating and adding the element to the dom?\n    const portalElement = document.getElementById(\"portal\");\n    if (portalElement === null) {\n        // eslint-disable-next-line no-console\n        console.error('Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id=\"portal\" />` as the last child of your `<body>`.');\n        return null;\n    }\n    let classWrap = style ? \"gdg-style\" : \"gdg-unstyle\";\n    if (!isValid) {\n        classWrap += \" gdg-invalid\";\n    }\n    if (pad) {\n        classWrap += \" gdg-pad\";\n    }\n    const bloomX = bloom?.[0] ?? 1;\n    const bloomY = bloom?.[1] ?? 1;\n    return createPortal(React.createElement(ThemeContext.Provider, { value: theme },\n        React.createElement(ClickOutsideContainer, { style: makeCSSStyle(theme), className: className, onClickOutside: onClickOutside, isOutsideClick: isOutsideClick },\n            React.createElement(DataGridOverlayEditorStyle, { ref: ref, id: id, className: classWrap, style: styleOverride, as: useLabel === true ? \"label\" : undefined, targetX: target.x - bloomX, targetY: target.y - bloomY, targetWidth: target.width + bloomX * 2, targetHeight: target.height + bloomY * 2 },\n                React.createElement(\"div\", { className: \"gdg-clip-region\", onKeyDown: onKeyDown }, editor)))), portalElement);\n};\nexport default DataGridOverlayEditor;\n//# sourceMappingURL=data-grid-overlay-editor.js.map","import * as React from \"react\";\nfunction useRefState() {\n    const [refState, setRefState] = React.useState();\n    return [refState ?? undefined, setRefState];\n}\nexport function useStayOnScreen() {\n    const [ref, setRef] = useRefState();\n    const [xOffset, setXOffset] = React.useState(0);\n    const [isIntersecting, setIsIntersecting] = React.useState(true);\n    React.useLayoutEffect(() => {\n        if (ref === undefined)\n            return;\n        if (!(\"IntersectionObserver\" in window))\n            return;\n        const observer = new IntersectionObserver(ents => {\n            if (ents.length === 0)\n                return;\n            setIsIntersecting(ents[0].isIntersecting);\n        }, { threshold: 1 });\n        observer.observe(ref);\n        return () => observer.disconnect();\n    }, [ref]);\n    React.useEffect(() => {\n        if (isIntersecting || ref === undefined)\n            return;\n        let rafHandle;\n        const fn = () => {\n            const { right: refRight } = ref.getBoundingClientRect();\n            setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));\n            rafHandle = requestAnimationFrame(fn);\n        };\n        rafHandle = requestAnimationFrame(fn);\n        return () => {\n            if (rafHandle !== undefined) {\n                cancelAnimationFrame(rafHandle);\n            }\n        };\n    }, [ref, isIntersecting]);\n    const style = React.useMemo(() => {\n        return { transform: `translateX(${xOffset}px)` };\n    }, [xOffset]);\n    return {\n        ref: setRef,\n        style,\n    };\n}\n//# sourceMappingURL=use-stay-on-screen.js.map"],"names":[],"sourceRoot":""}